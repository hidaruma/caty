<<ignore  -*- coding: utf-8 -*- >>

= アクションフラグメント


**ID付きコードフラグメント**は、スクリプトコード内で {{{(#ID ... )}}} で識別される。
スクリプト内の任意の部分をID付きコードフラグメントにすることができるが、主たる応用は、
アクションスクリプト（//Abobeとは無関係！//）を、より細かい粒度に分解することである。

ハイパーリンクグラフのリクエスト辺は、トリガーとアクションではなくて、
//トリガーとコードフラグメントを結ぶ//ものである。

以下、ID付きコードフラグメントを単に「フラグメント」と呼ぶ。

== アクションフラグメントの分類

アクションフラグメントを次のように分類する。
以下で、**実質的入力**／**実質的出力**とは、
HTTPエンベロープ／HTML装飾をはぎ取った入力データ／出力データのことである。

# **inフラグメント** -- このフラグメントの入力がWebからの実質的入力となる。
  しかし、このフラグメントの出力がWebからの実質的出力とはならない。
# **outフラグメント** -- このフラグメントの出力がWebへの実質的出力となる。
  しかし、このフラグメントの入力がWebへの実質的入力とはならない。
# **ioフラグメント** -- このフラグメントの入力と出力がWebからの実質的入力と出力となる。

フラグメントのプロファイル（入出力の型仕様）は、内部プロファイルで記述される。
複数の内部プロファイルを書け、その記述順序は意味に関係しない。しかし、
記述順序で最初に出現したinフラグメントまたはioフラグメントを**プライマリフラグメント**と呼ぶ。

プライマリフラグメントの決定のときだけ、内部プロファイルの順序が影響する。

== フラグメントIDのネーミング

フラグメントのin, out, ioの分類を宣言（内部プロファイル）から判断するために、
フラグメントIDに次のネーミングコンベンションを設ける。

{{{

inフラグメントのID ::= 'in' ([-_0-9] 名前文字*)?

outフラグメントのID ::= 'out' ([-_0-9] 名前文字*)?

ioフラグメントのID ::= 'io' ([-_0-9] 名前文字*)?

}}}

アクションの内部プロファイルにおいては、このネーミングコンベンションが強制される。

例：

{{{

#in1 foo:Bar -> string

#io foo:Bar -> foo:Baz produces [s1, s2]

#out-ok boolean -> db:Info produces info

}}}


== アクション内部プロファイル

内部プロファイルは一般に、'#' ID 入力型 '->' 出力型 ('produces' 状態)? の構文を持つ。
アクションの内部プロファイルは次の制約が付く。

{{{

'#' inフラグメントID 入力型 '->' 出力型

'#' outフラグメントID 入力型 '->' 出力型 ('produces' 状態)?

'#' ioフラグメントID 入力型 '->' 出力型 ('produces' 状態)?

}}}

つまり、inフラグメントの内部プロファイルにはproduces節を付けることはできない。
もちろん、複数のIDは異なっている必要がある。

== アクションフラグメントへの参照

トリガーのターゲットはアクションではなくて、アクションフラグメントである。
よって、アクションフラグメントを参照する形式が必要となる。

{{{

アクションフラグメントへの参照 ::= リソース名 '.' アクション名 ('#' フラグメントID)?

}}}

フラグメントIDが省略された場合は、アクションのプライマリフラグメントを意味する。
アクションにプライマリフラグメントの宣言（内部プロファイル）が無いときは、参照はエラーとなる。

トップレベルアクションが許されれば、リソース名は省略可能となる。
また、外部アクションを参照するときはモジュール名で修飾される。

== トリガーとアクションフラグメント

トリガーは次の情報を持つ。

# href -- ターゲットURL
# method -- HTTPメソッド
# verb -- Caty動詞
# queryType -- ユーザーにより入力されるqueryデータの型（型名で指定）
# bodyType -- ユーザーにより入力されるbodyデータの型（型名で指定）

inまたはioのアクションフラグメントも次の情報を持つ。

# URLパターン -- リソースから継承する
# method -- アクションから継承する
# verb -- アクションから継承する
# 入力型 -- 内部プロファイル

トリガーとアクションフラグメントがlinks節で結ばれたとき、
次の条件を満たす必要がある。

# トリガーのリンク先のアクションが存在しなくてはならない。
# トリガーのターゲットURLは、
  アクションフラグメントのURLパターンにマッチしなくてはならない。
# トリガーのメソッドは、
  アクションフラグメントのメソッドに一致しなくてはならない。
# トリガーの動詞は、
  アクションフラグメントの動詞に一致しなくてはならない。
# トリガーのquery型は、
  アクションフラグメントのオプション型の部分型でなくてはならない。
# トリガーのbody型は、
  アクションフラグメントの入力型の部分型でなくてはならない。
# トリガーのインボーカー（URl＋メソッド＋動詞）が、他のアクションに
  インターセプト（先に奪われる）されてはならない。


これらの条件を満たすとき、ハイパーリンク（リクエスト辺）は**validである**。

== トリガー仕様の推定

トリガーの仕様が未定のとき、ハイパーリンク・ターゲットであるアクションフラグメントから、
トリガー仕様を（矢印と逆方向に）推定することができる。

# トリガーのターゲットURLは、
  アクションフラグメントのURLパターンのインスタンスである。
# トリガーのメソッドは、
  アクションフラグメントのメソッドである。
# トリガーの動詞は、
  アクションフラグメントの動詞である。
# トリガーのquery型は、
  アクションのオプション型の部分型である。（queryはアクション入り口で処理されて不変。）
# トリガーのbody型は、
  アクションフラグメントの入力型の部分型である。

このなかで、ターゲットURLとquery/bodyの入力型は不定性がある。
URLパターンのインスタンスは乱数で生成可能だが、
入力型はそうはいかない。次のルールを設ける。

* アクションフラグメントの入力型がvoidまたはclosedなobject型なら、その型をトリガーのbody型に採用する。
* フラグメントの親アクションのオプション型をトリガーのquery型に採用する。
* それ以外の場合は推定不可能とする。

ハイパーリンク処理系は、ハイパーリンク設計者の負担を減らすために、
可能な限りの推定を行わなくてはならない。

== 内部プロファイルの簡略化と詳細化

内部プロファイルにおいて、inフラグメントの出力型、outフラグメントの入力型は重要ではない。
しかし、構文上これを省略するとバランスが悪くなり視認性が落ちる懸念がある。
無名型変数として '_' を予約し、「型がなんでもいい」ときは '_' を使っていいとする。

{{{

#in1 foo:Bar -> _

#out-ok _ -> db:Info produces info

}}}

また、inフラグメントとoutフラグメントの関係を記述するために、
relaysキーワードを導入するかもしれない。

* relaysは、inフラグメントにだけ付けられる。
* relaysに続けて、outフラグメントのIDを任意個書ける。
* relaysが指定されなかったときは、すべてのoutフラグメントのIDが指定されているとみなす。

{{{

relays節 ::= 'relays' (ID | '[' ID並び ']')

ID並び ::= 空 | ID (',' ID)*

}}}

例：

{{{

#in1 foo:Bar -> _ relays [out-ok, out-err],
#out-ok  _ -> db:Info produces info,
#out-err _ -> db:ErrMessage produces retry

}}}


