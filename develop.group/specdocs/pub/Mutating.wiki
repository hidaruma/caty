<<ignore  -*- coding: utf-8 -*- >>

= 分離ミューテーション

※ まだ途中、書いた部分にも変更があるだろう。

== 目的

分離ミューテーションの最も重要な目的は、クッキー通信／セッションをProtocol-agnosticな形で実現することである。

より一般に、通信（特にRPC）やプロセス起動を介して外部システムと連携するための基盤を提供する。
分離ミューテーションが直接に適用できない場合でも
分離ミューテーションによるシミュレーションはほとんど常に可能である。
分離ミューテーションを利用することにより、極めて広範囲のシステムの雛形を作ることが出来る。

== システム予約のタグ

アンダースコア2つ（'_~_'）で始まる名前のタグは、システムが特別な目的で使用するために予約する。
ユーザーレベル／ライブラリーレベルで、_~_* という名前のタグを使用することは禁止する。

万が一、ユーザーレベル／ライブラリーレベルで、@_~_* を使った場合は、システムの動作に
致命的な影響を及ぼすことがあり、正常な運用は期待できない。極めて危険である。

== 分離ミューテーター

**分離ミューテーター**、
あるいは単に**ミューテーター**とは、
Catyの環境変数に対するミューテーション（破壊的な上書き）を行う//意図を持つ//コマンドのことである。
「意図を持つ」だけであり、実際のミューテーションが遂行されるかどうかは状況次第である。

「分離」と呼ぶのは、ミューテーションを依頼する側（ミューテーター）と実行する側（ミューテーション対応のシェル）が
完全に分かれているからである。両者が協調しない限りミューテーションは実行されない。

変数への“ミューテーションの意図”は、コマンドの出力を通じて伝達される。
ミューテーションの意図を伝えるデータを**ミューテーションリクエスト**と呼ぶ。

{{{
type MutationRequest<T default univ> = @__mutate {
 "value": T,
 @[default({})]
 "set": object?,
 @[default([])]
 "unset": [string(remark="名前")*]?,
 @[default(false)]
 "clear": boolean?
};
}}}

valueプロパティの値は、コマンドの入出力に使われる値で、set, unset, clearによりミューテーション操作を記述する。
set, unset, clear（value以外）を抜き出したデータを**更新オペレータ**と呼ぶ。

明示的なミューテーションリクエストではないデータ（タグが、@__mutateではないデータ）は、set, unset, clearがデフォルトにセットされたミューテーションリクエストであると解釈する。この事を示すために次の定義をする。

{{{
type Mut<T default univ> = (
   (T & @(string(excludes=["__mutate"])) univ) 
 | MutationRequest<T>
);
}}}

通常の型Tでは、「タグ名"__mutate"を使うことはない」という仮定のもとで、//任意の型TはMut<T>に埋め込める//ことになる。

@~__mutateタグを持つデータを**明示的なミューテーションリクエスト**、そうでないデータをMut<T>の部分型とみなしたものを
**暗黙のミューテーションリクエスト**と呼ぶ。
暗黙のミューテーションリクエストは、更新オペレータが {"set":{}, "unset":[], "clear":false} であると解釈されるので、
何の変更もしないことを意味する。

x∈T は @__mutate {"value": x} と同一視されるので、Mut<T> では通常の等号とは別な等号が必要になる。
更新オペレータのデフォルト補完も含めて、ミューテーションリクエスト（暗黙のものを含む）の正規化操作が必要となる。
(Mut<T> は標準とは違う同値関係を持ったsetoidだということ。）

== コマンドとミューテーター

入力型がA、出力型がBであるコマンドの全体を CMD(A, B) と書く。コマンドには、オプションと引数があってもよいが、
入力と出力だけに注目して分類した集合が CMD(A, B) である。

CMD(A, Mut<B>) を MUT(A, B) とも書く。T ⊆ Mut<T> だったので、CMD(A, B)→MUT(A, B) という埋め込み写像がある。
別な言い方をすると、

* 入力がAで出力がBである任意のコマンドは、同じプロファイルのミューテーターとみなせる。

あるいは、

* すべてのコマンドはミューテーターとみなせる。

一方、MutationRequest<T> ⊆ Mut<T> なので、CMD(A, MutationRequest<T>) ⊆ MUT(A, B) でもある。
CMD(A, MutationRequest<T>) に属するコマンドは、明示的なミューテーションリクエストを出力する。

任意のコマンドを、適当なA、Bに対する集合 MUT(A, B) の要素と見なすことはできるが、MUT(A, B) と MUT(B, C) に対してコマンド結合（パイプ演算）が適用できるわけではない。f∈MUT(A, B) と g∈MUT(B, C) に対して、適切な f | g を定義することがこの仕様の主たる目的である。


== 分離ミューテーションプロトコル

**分離ミューテーションプロトコル**、
または単に**ミューテーションプロトコル**
は、次の構成要素からなる。

# 環境変数の名前。
# 環境変数の値の型。型はオブジェクト型（object）の部分集合型に限る。

ミューテーションプロトコルをP、P'などで示す。

ミューテーターfが、特定のミューテーションプロトコルPを知っていて、それに合わせた挙動をするとき、
fは**P-熟知**（P-aware）なミューテーターと呼ぶ。
そうでないミューテーターは**P-無知**（P-unaware）なミューテーターと呼ぶ。
ただし、あるコマンドがプロトコルPに対して熟知か無知かは外部から知る手段はないので、
この定義は心理的な区別と言える。

一方で、ミューテーションプロトコルをラベルとして、ミューテーターを分類することは
//シェルにとっては//意味がある。
シェルの立場から、MUT[P](A, B) という記法を導入する。

集合としては、PとP'が違っていても、MUT[P](A, B) = MUT[P'](A, B) である。
f∈MUT[P](A, B) であるとは、fの出力であるミューテーターリクエストをPに従って解釈する、という意味になる。
同じコマンドfを、
f∈MUT[P'](A, B) とみなすと、P'に従って解釈するので、最終的な効果（ミューテーターの実行結果）は変わる。

分離ミューテーションプロトコルでは、コマンドの側でプロトコルを指定する／主張する方法はない。
もしやるなら、コマンド宣言のアノテーションや新しい宣言構文により行うことになるだろう。

== プロトコルとバリデーション

プロトコルPに対して、f∈MUT(A, B) が正しいかどうかを判断することができる。
Pの変数がvで、変数vの型がTのとき、フォーマルな定義は次のとおり。

* 任意の a∈A と x∈T に対して、a | f の出力（の一部）である更新オペレータをxに適用すると、その結果はTに入る。

要するに、fが出力する可能性がある更新オペレータが、T→T という自己写像を定義していればfは正しい。

実行時のバリデーションの手順は次のようになる。

# 変数vの値が、型Tに所属しているかを調べる。所属してないなら事前条件（実際には不変条件）が満たされてない。
# fを実行して、更新オペレータを変数vの値に適用してみる。
# 得られた新しい値が、型Tに所属しているかを調べる。所属してないなら事後条件（実際には不変条件）が満たされてない。

特定プロトコルPに対して正しい（valid）なミューテーターを VMUT[P] で示すと、P≠P'であれば、
VMUT[P](A, B) ≠ VMUT[P'](A, B) となる可能性がある。
ただし、集合 VMUT[P](A, B) は計算により判断できる集合ではない（f∈VMUT[P](A, B) をアルゴリズムで判断できない）。

当面、型によるバリデーションは行わない。（適当なタイミングで入れるかもしれない。）

== mutating構文

mutatingは次の構文を持つ。

{{{
mutating オプション? 環境変数の名前 { スクリプトコード }
}}}

もし、ミューテーションプロトコルの型を考慮するなら、mutationgは型パラメータを持つ。

{{{
mutating<型> オプション? 環境変数の名前 { スクリプトコード }
}}}

当面、型パラメータは持たせない。

ブロック内のスクリプトコードは通常のCatyScript構文だが、パイプ演算の解釈が変わるので、
意味論は別な圏に対して行われる。よって、原則的には、ブロック内は別なシュルが解釈実行すべきである。
実際上は別なシェルではないが、同一シェルでも“別なモード”で動くことになる。

mutatingブロックの入力と出力は、スクリプトコード全体の入出力の型が A→Mut<B> のとき、
Mut<A>→Mut<B> 型となる。

== mutatingの意味：非コミット時

型A, Bに対して f::A -> Mut<B> というコマンドを考えて、mutating FOO {f} :: Mut<A> -> Mut<B> の意味を以下に記述する。

まず次の点に注意する。

* mutating FOO は、環境変数FOOを変更する（かもしれない）ことを意味するが、デフォルトでは、
 環境変数の書き換えは一切行わない。後述する --commit オプションの値によりミューテーションは制御される。

mutating FOO {f} は次のように実行される。

{{uncommitted-mutation.gif|Uncomitted Mutation}}


# 環境変数FOOをコピーする内部的な変数を準備する。仮にそれを #(FOO) で示す。
# このブロックを評価する直前の時点の環境変数FOOの値 #(FOO) にコピーする。
  FOOが未定義の場合は、#(FOO) の値は {} と初期化する。
# 環境変数FOOの値がobjectでないときはエラーとする。（例外の種別は後で決める。）
# このブロックへの入力が Mut<A> 型でないときはInputTypeErrorとする。
  （入力型チェックは、ブロックに入ってから行なっても結果は同じ。）
# 入力から更新オペレータをs抜き出して、それを #(FOO) に適用する。
# 入力から値a抜き出して、それをミューテーターfの入力とする。
# もとの環境変数全体をコピーして、_MUTATINGの値に"FOO"をセットし
  FOOの値を#(FOO)とした環境を作り、
  その環境によってfを実行する。
# fが失敗した（例外を出した）場合は特に何もしないで、ブロック全体も同じ例外で失敗とする。
# fが成功した場合は、fの出力から更新オペレータtを抜き出し、入力の更新オペレータsとモノイド演算する。
  s・t を u と置く。
# 更新オペレータuとfの出力値bを組み合わせて、全体出力とする。
# 環境変数FOOの更新は実際には行わない。

== mutatingの意味：コミット時

mutatingには、--commit というオプションがある。
デフォルトの値は "none" である。

mutating --commit=once FOO {f} は次のように実行される。

{{committed-mutation.gif|Uncomitted Mutation}}


# 環境変数FOOをコピーする内部的な変数を準備する。仮にそれを #(FOO) で示す。
# このブロックを評価する直前の時点の環境変数FOOの値 #(FOO) にコピーする。
  FOOが未定義の場合は、#(FOO) の値は {} と初期化する。
# 環境変数FOOの値がobjectでないときはエラーとする。（例外の種別は後で決める。）
# このブロックへの入力が Mut<A> 型でないときはInputTypeErrorとする。
  （入力型チェックは、ブロックに入ってから行なっても結果は同じ。）
# 入力から更新オペレータをs抜き出して、それを #(FOO) に適用する。
# 入力から値a抜き出して、それをミューテーターfの入力とする。
# もとの環境変数全体をコピーして、_MUTATINGの値に"FOO"をセットし
  FOOの値を#(FOO)とした環境を作り、
  その環境によってfを実行する。
# fが失敗した（例外を出した）場合は特に何もしないで、ブロック全体も同じ例外で失敗とする。
# fが成功した場合は、環境変数FOOを#(FOO)の値で実際に置き換える。
# fの出力をそのまま全体の出力とする。



