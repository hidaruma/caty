<<ignore  -*- coding: utf-8 -*- >>

= データアドレス

== ここで扱う「型」と「データ」

以下で「型」とは、任意の型表現のことではなくて、“名前付きの型”のことである。
つまり、型の名前空間に名前を持つメタオブジェクトである。
名前を持たない型については考えない。
型名を持つなら、コレクションであってもよい。その実体や実装を問わない。
ただし、意味論としては//集合を表さなくてはならない//。

「データ」とは、型の集合の要素のこと。コレクションに含まれるレコード、または内包的に定義される型の値である。


== 型のアクションクラス

型に対して、型名に'Action'を続けた名前を持つクラスを、その型の**アクションクラス**と呼ぶ。
アクションクラスに属するコマンドを**アクション**、または（その型に属する）**動詞**と呼ぶ。


型Tに対するアクションクラスは次の制約を持つ。

# すべてのコマンド（アクション）の出力型はTでなくてはならない。
# getという名前のstaticコマンドを持ち、getのプロファイルは、[jsonScalar arg?, jsonScalar? ext] :: void -> T の特殊化でなくてはならない。
  ここで、jsonScalarは (null|number|string|boolean) のこと。
# getの第1、第2引数の意味と使用法は後述する。

次は、integer型のアクションクラスの例である。

{{{
@[register-public]
class integerAction ( ->integer) {
 @[static]
  command get [integer arg] :: void -> _ {
    %1
  };
};
}}}

型のアクションクラスのgetメソッドは、その型の**getアクション**、または**get動詞**と呼ばれる。

== アドレス可能なデータ

データが**アドレス可能**（addressable）とは、

# データが属する型にアクションクラスが存在する。
# したがって、型のgetアクションが存在する。
# 型のgetアクションに適切な第1引数（省略可能、第2引数はなし）を渡して実行することにより当該データが出力される。

アドレス可能なデータに対して、型の名前とgetアクションへの第1引数の組をそのデータの**アドレス**と呼ぶ。
次のデータ型でアドレスを表現する。

{{{
type DataAddr = @* {
 "type": string(remark="型の完全修飾名"),
 "arg": (null|number|string|boolean)?,
 * : any?
};
}}}

リテラルとして等しいデータが、異なるデータアドレスを持つことがある。
データアドレスも名前なので別名が存在する可能性がある。

== 相対データとそのアドレス

上記に述べたアドレス可能なデータは**トータルデータ**とも呼ぶ。
トータルデータとその一部分（portion）の組を**相対データ**と呼ぶ。
一部分はXJSONパスで表現され、そのXJSONパスを相対データの**抽出子**（extractor）と呼ぶ。

相対データまで含めたアドレスは次のようになる。

{{{
type DataAddr = @* {
 "type": string(remark="型の完全修飾名"),
 "arg": (null|number|string|boolean)?,
 "ext": string(remark="XJSONパス")?,
 * : any?
};
}}}

相対データの場合、注目しているのは抽出した部分であるが、コンテキストとしてトータルデータが存在している。

== アドレス可能な型

型システムは、指定された型（の名前）Tがアドレス可能かどうかを次の基準により判断する。

# その型はモジュールのトップレベルで定義されている（クラス内型ではない）。
# 同じモジュール内に、型Tのアクションクラス（TActionという名前のクラス）が存在する。
# アクションクラスにgetアクション（コマンド）が定義されている（実装を持つ）。
# getアクションが正しいプロファイルを持つ。

型Tがアドレス可能であっても、その型（の集合）に属するすべてのデータがアドレス可能とは限らない。
データとしてアドレス可能であるためには、getアクションの出力値でなくてはならないが、
型システムは、getアクションのすべての出力値を知るスベがない。

== reference型

Tがアドレス可能な型のとき、Tへの**参照型** reference<T> を定義できる。
参照型を定義（具体化）する前に、参照先の型は定義されてなくてはならない。
Tがアドレス可能でないときは、reference<T> はエラーとなる。

参照型データは、データとしては次のように定義される。

{{{
type Reference = @__reference {
 "type": string(remark="型の完全修飾名"),
 "arg": (null|number|string|boolean)?,
 "ext": string(remark="XJSONパス")?,
};
}}}

Reference ⊆ DataAddr であることに注意せよ。通常ID（主キー）とIDREF（外部キー）は、それ自体では区別できないときが多い。
Catyでは、この区別をタグで行う。DataAddr型は、IDとIDREFの両方を含む。

型Tが具体化されたとき、typeプロパティの値はTの完全修飾名に固定される。
また、argの型はgetアクションの第1引数の型がコピーされる。

例えば、reference<mod:Foo> であれば、次のデータとして解釈され、
ここで、バリデーションに使われる。mod:Fooのgetアクションの第1引数はstring必須と仮定する。

{{{
@__reference {
 "type": "app::mod:Foo",
 "arg": string,
 "ext": string(remark="XJSONパス")?,
};
}}}

== derefコマンド

{{{
/** 参照を解決する */
command deref :: Reference -> @Total any | @Relative [any total, any portion] ;
}}}

derefコマンドは入力の参照（データアドレス）の参照解決（dereference）をして、実際のデータを返す。

* 参照がトータルである（extがない）ときは、@Total が付く。
* 参照が相対である（extがある）ときは、@Relative がつき、全体と部分が配列になる。

derefコマンドの動作は次のとおり。

# 参照のtypeの値に、"Action.get" を文字列連接してgetアクションの名前を知る。
# getアクションを、argの値を引数として呼び出す。
# 相対データの処理は自分で処理してもよいし、
  （効率を気にしないなら）getアクションを、argとextの値を引数として再度呼び出してもよい。

== 混合パスとfollowコマンド

XJSONパスに区切り記号として'!'を許したパスを混合XJSONパスと呼ぶ。例えば、$.a!b.1 は混合パスである。
'.'が出現できる位置ならどこでも'!'で置き換え可能である。


$.a!b.1 の意味は、$.aの値が参照（データアドレス）であり、
その参照をderefした後で b.1 を解釈することである。'!'の位置でderefが実行される。

followコマンドに --auto オプションが付くと、'!'がなくても自動的に参照を判断して辿る。
$.a!b.1 の代わりに $.a.b.1 と書いても、$.aの値が参照であれば（@~_~_reference で判断できる）、
自動的に参照解決する。

{{{
/** 混合XJSONパスの値を取得する */
command follow 
  {
    /** 自動的に参照解決するか */
    @[default(false)]
    "auto": boolean?,
    /** 値が存在しないときにundefinedを返すか */
    @[default(false)]
    "safe": boolean?
  }
  [string path]
  :: Reference -> any? throws Undefined;

}}}




