<<ignore  -*- coding: utf-8 -*- >>

= Catyインタープリタ


Catyインタープリタは、CatyScriptの解釈評価系で、Catyの中核的な機能を提供する。

== 基本的な用語

* REP（レプ） -- Read-Eval-Print；インタープリタの最小実行単位。
* REPL -- Read-Eval-Printループ。REPの繰り返し。（REPと見間違うので、REPLoopと書いたほうがいいかも。）
* ライフタイム -- インタープリタの起動から終了までの時間。
  インタープリタのライフタイムは、有限回（概念的には無限回も許容）のREPの繰り返しである。
* 開始と終了 -- ライフイムの最初と最後の時点。start、stopにより開始と終了を指示する。
* 実行状態（ステータス） --- ライフタイムのなかにあるなら**running**、そうでないなら**stopped**。
  開始前もstoppedとみなす。

== インタープリタの構成

インタープリタは、評価計算を行う**評価器**（evaluator, eval）と
評価器に評価計算を行わせる**評価管理系**（evaluation manager）からなる。
評価器をインタープリタと呼ぶことも多いが、ここでは、評価管理系を含めて**インタープリタ**と呼ぶ。
つまり、「インタープリタ ＝ 評価器 ＋ 評価管理系」。

評価器は、表示的かつ操作的に完全に定義されている。表示的（denotational）な意味領域として、
評価器は（したがってインタープリタは）1つの圏を持つ。この圏をその評価器（インタープリタ）の
**計算モデル圏**、または単に**モデル圏**と呼ぶ。
モデル圏は、モナド的代数系を伴ったデカルト半環作用圏である。

* 参考： [[>http://d.hatena.ne.jp/m-hiyama/20110205/1296893800]]

インタープリタの評価管理系は、外部とデータをやり取りする**ポート**に繋がっている。
ポートは入力ポートまたは出力ポートで、**データストリーム**の入力または出力手段を提供する。

== 評価器

評価器は、インタープリタの//本体//、または//狭義のインタープリタ//である。
評価器はまた、CatyScript言語仕様の実現になっている。評価器実装を**C4エンジン**と呼びたい。
したがって、CatyScript言語仕様とC4エンジンは1：1に対応する。//C4エンジンには評価管理系が含まれない。//

評価器の操作的なモデルは記号的仮想機械（抽象C4エンジン）で、次から構成される。

# ラベルと式の対応を保持する制御マップ（プログラムがコンパイルされた場合は存在しないことがある）
# 束縛の列を保持するスコープスタック（スコープチェーン）
# 現在の値を保持するレジスタ
# 式（項）の列を保持するコードスタック（コードエリア＋プログラムカウンタ）

評価器の一時点での計算状況（computational situation / configuration）は、C;Σ;x{E1, ...} で表現される。

# C -- 制御マップ
# Σ -- 束縛列＝スコープスタック （右端がスタックトップ）
# x -- レジスタの値
# {E1, ...} -- 式の列＝コードスタック （左端がスタックトップ）

評価器は**アンビエント環境**を参照しながら動く。アンビエント環境には次の情報が格納されている。

# 型の定義 Type
# コマンドの宣言と定義 Command
# ネイティブコマンドの実装 Native
# ファシリティ
# アンビエント状態

ファシリティとアンビエント状態（ストレージ状態など）は、コマンドが利用するもので、
評価機が直接認識することはない。

評価器を動作させるには、初期入力（レジスタ初期値）と評価すべき式を与える。
結果（outcome）は値または例外で、
アンビエントに副作用（effect）を残すこともある。
ただし、副作用はコマンド実行の結果で、評価器自体が副作用を残すことはない。

=== 蛇足：ランディンのSECDマシン(1965)との比較

ランディンのSECDマシン：

* Stack -- 引数＆戻り値スタック
* Environment -- 変数の束縛環境
* Codeレジスタ -- プログラムカウンタ
* Dumpレジスタ -- コールスタックのフレームを指す

Catyの抽象C4エンジンでは：

* Stack -- 値レジスタ、単一引数なのでスタック構造は不要 
* Environment -- 束縛列＝スコープスタック 
* Codeレジスタ -- コードスタック＋制御マップ
* Dumpレジスタ -- クロージャで代用するので不要

=== さらに蛇足：CatyのVM

抽象C4エンジンではなくて、具象C4エンジン（＝CatyのVM実装）を作る場合は、
SECD同様に引数＆戻り値スタック（評価スタック）が必要になるだろう。
また、ブロック構造やコマンド呼び出しは、クロージャを使うよりスタックフレームのほうが効率的かも知れない。

== 評価管理系

評価器は、REP（レプ）のE（eval）の部分を担当する。評価管理系は、REPのRとP、それと繰り返し（Loop）を担当する。

評価管理系は次のことを行う。

# 入力ストリームから1個のデータを受け取る。
# データを解析して、評価器に渡すべき入力（レジスタ初期値）と式を作る。
# 入力と式がセットされた評価器を実行する。
# 評価の結果である値または例外を取り出す。
# 結果を出力ストリームに送り出す。
# なんらかの終了タイミングまで、以上のこと（REP）を繰り返す。

もっとも単純な評価管理系は、決められた入力（レジスタ初期値）と決められ
た式Eをセットして、//1回だけ//評価器を実行するものである。この場合でも、式Eの評価が無限に走るならば、
インタープリタ（評価器＋評価管理系）は無限に走る。
また、評価器のなかで「コマンドによるストリーム入出力」を使えば、
REPLを評価器内で回すこともできる（評価器内のインタープリタ実装）。

同一の評価器に対して、様々な評価管理系を組み合わせることによって、
様々なインタープリタを構成することができる。それらの例を以下に述べる。
また、評価管理系が単純でも、評価器内で実装された評価管理系で複雑なことを行えることは、
メタ巡回機能の基盤となる。

== ファイルインタープリタ

1つのファイルから1つの式を読み取り、それを実行するインタープリタは次のように記述できる。

# 評価管理系がファイルから式を読み取る。それをEとする（Eはファイルの内容）。
# レジスタ初期値をnull、コードスタックを{E}とする。
# 評価器を実行する。
# 結果が値なら、それを評価管理系が stdout に書きだす。
# 結果が例外なら、それを評価管理系が stderr に書きだす。

式をパイプから読み取ることもできる。この場合の stdin には式が入っていると仮定する（次節と比較せよ）。

== フィルターインタープリタ

フィルターインタープリタは、
ファイルインタープリタとほとんど同じだが、式をファイルシステム内の名前付きファイルから読み取り、
レジスタ初期値となるデータをstdinから読み込む。結果はstdoutまたはstderrに書きだす。

次は、利用例である。

{{{
/* cite-mark.caty */

text:split "\n" | each {["> ", pass] | text:concat} | text:join "\n"

}}}


{{{

$ cat foo.txt | caty-filter-interp cite-mark.caty

}}}

== コンソールインタープリタ

コンソールから1つの式を読み取りそれを実行するインタープリタは、次のように記述できる。

# 評価管理系がコンソール（キーボード）から式を読み取る。それをEとする。
# レジスタ初期値をnull、コードスタックを{E}とする。
# 評価器を実行する。
# 結果を評価管理系がコンソールに書きだす。
# これを繰り返す。

== telnetインタープリタ

セキュリティ上の問題がない状況で使用するものとする。

telnetプロトコルのサーバー機能を実装したポート（ネットワークストリーム）を評価管理系が読み書きできるとする。
動作はコンソールインタプリタと同じである。

# 評価管理系がネットワークストリームから式を読み取る。それをEとする。
# レジスタ初期値をnull、コードスタックを{E}とする。
# 評価器を実行する。
# 結果を評価管理系がネットワークストリームに書きだす。
# これを繰り返す。

ユーザーは任意のtelnetクライアントからtelnetインタープリタを使用できる。

----

Twistedにtelnetライブラリがあるようだ。

* [[>http://twistedmatrix.com/documents/8.2.0/api/twisted.conch.telnet.html]]


== Webインタープリタ

Webインタープリタは、Webアプリケーションサーバーとして機能する。
上に挙げた事例より複雑な構造を持つ。

* クロージャに関しては： [[>http://d.hatena.ne.jp/m-hiyama/20110217/1297929853]]

# 評価管理系がHTTP入力ポートからリクエストQを読み取る。Qは入り口プロセッサで既に加工されたJSONデータだが、
  Q自体は**式ではない**。
# QのURI、HTTPメソッド、動詞（クエリ文字列の一部）をキーとして、実行すべき式Eを検索する。
# Qのクエリ文字列（動詞は除く）から、パラメータ束縛αを作り、クロージャ _script{α, E} を作る。
# レジスタ初期値をQ、コードスタックを{_script{α, E}}とする。
# 評価器を実行する。
# 結果が値なら、それを評価管理系がHTTP出力ポートに書きだす。
# 結果が例外なら、評価管理系がエラーレスポンスを作ってそれをHTTP出力ポートに書きだす。
# これを繰り返す。

かつて、レジスタ初期値はQをかなり加工したデータだったが、生のHTTPリクエストに忠実なQをそのまま
レジスタ初期値にしたほうが整合性が取りやすく、柔軟性が増す。

Webインタープリタはネイティブ（Python）コードで実装されるが、
それと等価なスクリプト実装を書けるようにすることが、
CatyScript2.0の目標の一つである。

== RCI/HTTPインタープリタ

HTTPトランスポート上でRCI（Rremote Command Invocation over HTTP）を行う。
機能的にはtelnetインタープリタと同じだが、telnetクライアントを使わずにWebブラウザを使う。

使用するHTTPメソッドはPOSTだけである。
RCI/HTTPインタープリタの評価管理系をネイティブ（Python）コード実装をしなくても、
//Webインタープリタのアクション（スクリプトコード）としても実装できる。//

最初に利用者は、入力用フォームを持つHTML文書をGETする。そのフォームからPOSTリクエスが送られる。

# 評価管理系がHTTP入力ポートからリクエストQを読み取る。Qのメソッドやボディが不適切な場合は
評価管理系がすぐさまエラーレスポンスを返す（ステータスコードは
405 Method Not Allowed,
415 Unsupported Media Type,
422 Unprocessable Entity
など。）
# Qのリクエストボディ（application/x-www-form-urlencoded）から実行すべき式Eを取り出す。ここはファイルインタープリタやフィルターインタープリタと同じ。
# レジスタ初期値をnull、コードスタックを{E}とする。
# 評価器を実行する。
# 評価管理系が、評価結果と入力用フォームを持つHTML文書を作る。
# HTML文書を含むレスポンスをHTTP出力ポートに書きだす。
# これを繰り返す。

== RCI-Ajaxインタープリタ

RCI/HTTPインタープリタと同じだが、HTTP通信をAjaxによって行う。

# 評価管理系がAjax-HTTP入力ポートからリクエストQを読み取る。Qのメソッドやボディが不適切な場合は
評価管理系がすぐさまエラーレスポンスを返す。
# Qのリクエストボディ（JSON）から実行すべき式Eを取り出す。
# レジスタ初期値をnull、コードスタックを{E}とする。
# 評価器を実行する。
# 評価管理系が、結果をJSONデータとしてラップする。
# JSONレスポンスをAjax-HTTP出力ポートに書きだす。
# これを繰り返す。

== RCI-AjaxParsedインタープリタ

RCI-Ajaxインタープリタと同じだが、CatyScript式の構文解析をJavaScriptで行い、
サーバーにはXJSON形式のASTが送られる。

Webブラウザ上で実行されるクライアントは、
JavaScriptで実装されたCatyScriptパーザーを持つ。
このため、スクリプトの編集と構文エラーに対する//より良いユーザーインターフェース//を提供できる。
また、テキストだけではなくて、CatyScriptの//グラフィカルな表現//をUIに使うこともできるだろう。

== デスクトップGUIインタープリタ

お絵描きツールとしてのGUIを持ち、キャンバス上に描いた絵を適宜評価するインタープリタ。
REPLの原理はコンソールインタープリタと変わらない。

== Catyランタイムと分散システム

Catyランタイムシステムは、
いくつかのCatyインタープリタ（スレッド）を同時に実行できる環境を提供する。
また、インタープリタが利用可能な入出力ポート群も提供する。

つまり、Catyランタイムシステムは、
インタープリタという住人たちが生まれて安全に生涯（ライフタイム）をおくるための**世界**を
ホスティングする。この世界はポートにより外部に繋がっている。複数のCatyランタイム（世界）をポートで
連結することにより複合世界（compound world）を作れる。

適切なネットワークプロトコル（現状では、選択肢はHTTPに限られるだろう）により、
分散した複数のCatyランタイム／インスタンスから複合世界を作れば、
なにか楽しいことが出来るかもしれない。

もちろん、オープンプロトコルで繋がるなら、
複合世界を構成するノードがCatyランタイムである必要はない。


