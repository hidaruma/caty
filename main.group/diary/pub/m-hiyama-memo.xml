<?xml version="1.0" encoding="UTF-8"?>
<diary>
<day date="1900-01-01" title="">
<body>
*1148357193*[グロッサランダム]2006年5月19日あたりから

事情は[http://d.hatena.ne.jp/m-hiyama-memo/20060519/1148032273:title]を参照。キマイラサイトの&lt;a href=&quot;http://www.chimaira.org/docs/Glossarandom.htm&quot;&gt;グロッサランダム&lt;/a&gt;との重複は気にせず繰り返します。

+ アーベル圏の双積ではなくて、&lt;span style=&quot;font-weight:bold;&quot;&gt;テンソル積&lt;/span&gt;の定義はあるのか？
+ -- あるよ、内部homeに対する随伴だけど。
+ アーベル圏のスカラー対象（End(A)がスカラー環となるA）の定義はあるのか？
+ -- テンソル積の単位1に対するEndがスカラーなのかな。
+ そういえば、アブラムスキーが強コンパクト閉圏のスカラーを定義していたような。
+ アーベル圏の単純対象ってなんだっけ？
+ -- 部分対象が0と自分自身しかない対象だよ。
+ converse、transpose、reciprocation（アレゴリー）, dualizer (dual, dualizing)、star operatorとかって、ようは、FF = Idであるような反変関手Fだよな。identity-on-objectsの条件はあったりなかったりだが。
+ Peter Selinger(http://www.mathstat.dal.ca/~selinger/)のdagger operatorは明白にidentity-on-objects。
+ &quot;State sum construction of two-dimensional open-closed Toplogical Quantum Field Theories&quot;（http://arxiv.org/abs/math.QA/0602047）は、絵がイッパイあって楽しいよ（眺めるだけ）。これを以下[2TQFT2006]
+ [2TQFT2006]対称モノイド圏Cの&lt;b&gt;対象Xがrigid&lt;/b&gt; ⇔ left-dual (X&lt;sup&gt;*&lt;/sup&gt;, ev&lt;sub&gt;X&lt;/sub&gt;, coev&lt;sub&gt;X&lt;/sub&gt;)がある。ev:X&lt;sup&gt;*&lt;/sup&gt;×X→I, coev:I→X×X&lt;sup&gt;*&lt;/sup&gt;が、zig-zag等式を満たす。
+ [2TQFT2006]&quot;left-dual&quot;はright-dualに対して左、随伴とは直接の関係はない。
+ [2TQFT2006]対称でないケースでは、左と右がそろってはじめてrigidだと思った、たしか。対称だと片一方でOKってことらしい（要確認）。
+ [2TQFT2006]（対称）モノイド圏Cが&lt;b&gt;rigid&lt;/b&gt; ⇔ すべての対象がrigid。
+ [2TQFT2006]Xがrigidなら、C(X, X) = End(X)上に&lt;b&gt;categorical trace&lt;/b&gt; tr(f)∈End(I)を定義できる。
+ [2TQFT2006]Xがrigid、tr(id_X)∈End(X)をXの&lt;b&gt;categorical dimension&lt;/b&gt;と呼ぶ。これ、正方行列の対角成分の個数だ。
+ [2TQFT2006]XもYがrigidなら、f:X→Yのdual f*:Y*→X*を定義できる。
+ [2TQFT2006]マクレーンのcoherence theoremが次を保証するそうだ：ストリング図は曖昧性無くCの射に翻訳される。coherence theoremって、そういうもの、フーン。coherence theremわかってないわ。
+ [2TQFT2006]ウーン？ フロベニウス代数の定義をモナド／コモナド対に適用できないかな。
+ Xの右双対（right dual）を右肩星A&lt;sup&gt;*&lt;/sup&gt;で示す。が、余単位ε:A&lt;sup&gt;*&lt;/sup&gt;×A → 1 ではテンソル積（モノイド積）の&lt;strong&gt;左&lt;/strong&gt;因子として登場する、注意。
+ Xの右双対（左でも）、余単位をev、単位をcoevと呼ぶことがある。実際、ベクトル空間では、ev:A&lt;sup&gt;*&lt;/sup&gt;×A → 1 は、(f, v) |→ f(v)という双線形写像。
+ braid（組み紐）の紐はstrand（髪の毛、より糸）って呼ぶ。
+ braidのstrandは、t|→(x(t), y(t), z(t)}で、z(t)が強単調な関数。
+ braidのフレームは{0, 1, ..., n}×{0}×{0, 1}。
+ 直和をdisjoint sumというのは知っていたが、separated sumとも言うのね。
+ diagra'm'atic order（mがひとつ）でもいいのか。
+ gluingとglueingは違うか、同じか？ gluingが多いな。コボルディズム圏の結合はgluing。
+ GoI構成とInt構成って同じなんだ、実は。
+ 「CがDummet圏ならGoI(C)（Int(C)でも同じ）は古典圏」てのが長谷川さんの定理らしい。
+ で、Dummet圏てなによ？
+ トレースの一般化に、×と+を持った圏で、Tr:C(X×A, X+B) → C(A, B) がある。
+ symmetric braidingは、braidingとしては変なものだな。σ, σ'という交差の上下が異なる2つのbraidingがあって、σ;σ'=idなら自然だと思う。これはアルチン群になるのかな？
+ rigの提唱者は、Lawvere/Schanuelだそうだ（Hyland/Benton付録による）。が、僕は使わない。Bloom/Esikはsemi-ring。
+ グラフGから自由圏を作る関手FreeCat(G)は自由（生成）関手だから圏Graph上のモナドを定義する。

</body>
</day>
<day date="1901-01-01" title="絵と図のリンク集">
<body>
*1154757056*[絵図リンク]集

- ベントン／ハイランド ： &quot;TRACED PREMONOIDAL CATEGORIES&quot; →http://research.microsoft.com/~nick/premonitapdf.pdf
- 長谷川 ：&quot;The Uniformity Principle on Traced Monoidal Categories&quot; →http://www.kurims.kyoto-u.ac.jp/~hassei/papers/ctcs02.pdf
- 長谷川 ：&quot;Models of Sharing Graphs A Categorical Semantics of let and letrec&quot; University of Edinburgh 1997 →http://www.amazon.co.jp/gp/product/1852331453/250-2925753-9543409
- 〃 →http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-360/
- アブラムスキー ： &quot;Abstract Scalars, Loops, and Free Traced and Strongly Compact Closed Categories&quot; →http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/calco05.pdf
- ボブ・クック ： &quot;Kindergarten Quantum Mechanics&quot; →http://web.comlab.ox.ac.uk/oucl/work/bob.coecke/VaxjoProc.pdf
- ダンカン：&quot;An Abstract Approach to Entanglement&quot; →http://web.comlab.ox.ac.uk/oucl/work/ross.duncan/q-day-ii-slides.pdf
- 白旗 ： &quot;Geometry of Interaction explained&quot; →http://www.kurims.kyoto-u.ac.jp/~hassei/algi-13/kokyuroku/19_shirahata.pdf -- トレース付きモノイド圏、Int（GoI）構成。
- ステファネスク： &quot;ALGEBRA OF FLOWNOMIALS Part I Binary Flownomials; Basic Theory&quot; →http://www4.in.tum.de/publ/papers/TUM-I9437.pdf
- ステファネスク： &quot;Network Algebra&quot; →http://www.amazon.co.jp/exec/obidos/ASIN/185233195X/503-0219743-2685529


</body>
</day>
<day date="1902-01-01" title="オフライン文献集">
<body>
*1161131574*[オフライン文献]集

- Golan &quot;Semirings and Their Applications&quot; →[http://www.amazon.co.jp/gp/product/0792357868:title]
- Wagneur, E. &quot;Moduloids and Pseudomodules. I. Dimension theory.&quot; Discrete Mathematics, 98, 57-73, 1991 ベキ等半環の次元論があるらしい。&lt;em&gt;入手&lt;/em&gt;
- M. Takahashi &quot;On the bordism categories II -- Elementary properties of semimodules -- &quot; Math. Sem. Notes, Kobe Univ., 9(1981), 495-530.
- Joyal A. and Street R., The geometry of tensor calculus I, Advances in Math., 1991, V.88,55--112, MR92d:18011.
- G.M. Kelly and R. Street, Review of the elements of 2-categories, Proc. Sydney Category Theory Seminar 1972/73, Lecture Notes in Math. 420, Springer (1974) 75-103.

</body>
</day>
<day date="1905-01-01" title="人物リンク集">
<body>
*1154050835*[人物][リンク][人物リンク]集

- ニック・ベントン Nick Benton →http://research.microsoft.com/~nick/
- マーチン・ハイランド J. Martin E. Hyland →http://www.dpmms.cam.ac.uk/~martin/
- デクスター・コゥゼン Dexter Kozen→http://www.cs.cornell.edu/~kozen/
- ローランド・バックハウス Roland Backhouse →http://www.cs.nott.ac.uk/~rcb/
- コスロウスキー(?) Jurgen Koslowski →http://www.iti.cs.tu-bs.de/~koslowj/
- 長谷川真人→http://www.kurims.kyoto-u.ac.jp/~hassei/
- ロス・ストリート Ross Street →http://www.maths.mq.edu.au/~street/
- マイケル(?)・バタニン Michael Batanin →http://www.ics.mq.edu.au/gen/person/mbatanin.html
- ピーター・セリンガー Peter Selinger →http://www.mathstat.dal.ca/~selinger/
- J.P. メイ J.P. May →http://www.math.uchicago.edu/~may/
- ゲオルグ(?)・ステファネスク Gheorghe Stefanescu →http://www4.informatik.tu-muenchen.de/~stefanes/
- サムソン・アブラムスキー Samson Abramsky  →http://web.comlab.ox.ac.uk/oucl/people/samson.abramsky.html
- ボブ・クック Bob Coecke →http://web.comlab.ox.ac.uk/oucl/people/bob.coecke.html
- ボブ・クック Bob Coecke その2 →http://www.vub.ac.be/CLEA/Bob/Coecke.html
- ジャン・ラッテン(?) Jan Rutten →http://homepages.cwi.nl/~janr/
- バート・ジャコブス Bart Jacobs  →http://www.cs.ru.nl/~bart/
- ヨセフ(?)・ゴグエン Joseph Goguen  →http://www.cs.ucsd.edu/users/goguen/
- ジャン・イヴ・ジラール Jean-Yves Girard →http://iml.univ-mrs.fr/~girard/
- ティル・モサコウスキー(?) Till Mossakowski → http://www.informatik.uni-bremen.de/~till/
- ウォルフラム・カール Wolfram Kahl →http://www.cas.mcmaster.ca/~kahl/
- トム・ウェストン Tom Weston →http://www.math.umass.edu/~weston/
- アンジェロ・ビストリ Angelo Vistoli →http://www.dm.unibo.it/~vistoli/
- ジョン・バエズ John C. Baez →http://math.ucr.edu/home/baez/
- ロス・ダンカン Ross Duncan→http://web.comlab.ox.ac.uk/oucl/work/ross.duncan/
- 白旗優 →http://www.fbc.keio.ac.jp/~sirahata/index.html
- ユージェニオ・モッジ Eugenio Moggi→http://www.disi.unige.it/person/MoggiE/
- ウィリアム・ローベル F. William Lawvere→http://www.acsu.buffalo.edu/~wlawvere/
- バウグハン(?)・ジョーンズ Vaughan F.R. Jones→http://math.berkeley.edu/~vfr/
- ルイ・カウフマン Louis H. Kauffman→ http://www.math.uic.edu/~kauffman/
- 大槻 知忠→http://www.kurims.kyoto-u.ac.jp/~tomotada/
- ルイジ・サントカネイル Luigi Santocanale→http://www.lif.univ-mrs.fr/~lsantoca/
- 竹内 光弘→http://www.math.tsukuba.ac.jp/faculty/profiles/takeuchim/takeuchim.html
- トーマス・カーラー Thomas Kerler→http://www.math.ohio-state.edu/~kerler/
- ウロジミール(?)・リューバシェンコ Volodymyr Lyubashenko→http://www.math.ksu.edu/~lub/
- アラン・ジェフリイ Alan Jeffrey →http://cm.bell-labs.com/who/ajeffrey/
- エメリタス・ジョナサン・ゴラン Emeritus Jonathan S. Golan→http://math.haifa.ac.il/JSGOLAN/golan2.html
- 郡敏昭 →http://www.math.waseda.ac.jp/~kori/
- イムレ・テューバ Imre Tuba→http://www-rohan.sdsu.edu/~ituba/
- 辻下徹→http://ac-net.org/tjst/index.php
- ヨアヒム・コック Joachim Kock→http://mat.uab.es/~kock/
- ジェフリー・モートン Jeffrey Morton→http://math.ucr.edu/~morton/
- スティーブ・ラック Steve Lack→http://www.maths.usyd.edu.au/u/stevel/
- ミカーイル・コバノフ Mikhail Khovanov → http://www.math.columbia.edu/~khovanov/
- マイク・ステイ Mike Stay → http://math.ucr.edu/~mike/
</body>
</day>
<day date="1910-01-05" title="">
<body>
*1262664094*[caty]Catyの型解析

この日付（100年前）でCatyの型解析関係記事を書きます。

*1262682507*[型検査][caty]型解析：雑多な予備知識

&lt;h5&gt;用語法の注意&lt;/h5&gt;

型検査、型推論、型解析は同義語として使う、特に明確な区別はない。あるCatyスクリプト式（Caty式とも略称）に対する型解析が&lt;strong&gt;失敗する&lt;/strong&gt;とは、否定的な結果を出して解析が&lt;em&gt;成功する&lt;/em&gt;ことである。型解析は、成功する（肯定的な結果を出して終了する）か失敗する（否定的な結果を出して終了する）かのどちらかであり、型解析処理自体が例外を出したり無限走行することはない。（したら困る。）

型解析が“失敗した”場合は、当該のCaty式に、型の不整合があるので、この式は実行されない。型解析は、最初に発見した型不整合の場所と原因を報告することができる。

型解析が成功する場合は、完全に成功するときと&lt;strong&gt;条件付きで成功&lt;/strong&gt;するときがある。条件付きで成功するとは、式内のパイプに&lt;strong&gt;実行時型チェック条件&lt;/strong&gt;が付与されることである。

実行時型チェックを単に&lt;strong&gt;チェック&lt;/strong&gt;、実行時型チェック条件を単に&lt;strong&gt;条件&lt;/strong&gt;と呼ぶことがある。

ほとんどはスキーマ構文領域での話だから、型表現（型項）を単に型、型変数を単に&lt;strong&gt;変数&lt;/strong&gt;とも呼ぶ。値変数はここでは出てこない。

タグ付き値、タグ付き型と言った場合は、暗黙タグのことは考えない。明示タグが付いた値、明示タグが付いた型のことである。&lt;em&gt;暗黙タグに言及するときは、必ずその旨を記す。&lt;/em&gt;

&lt;h5&gt;記号法と若干の用語&lt;/h5&gt;

次のようなメタ変数を使う。

+ a, b など： スカラー定数（リテラル）
+ x, y, u, v など：型変数
+ α, β など：プロパティ名、タグ名
+ E, F など：Catyスクリプト式
+ A, B など：これもCatyスクリプト式
+ S, T など：型（の表現、項）
+ X, Y など：これも型
+ f, g など：コマンド呼び出し
+ n, m, i, j など：非負整数
+ p, q など：JSONパス式

型Tに含まれる変数をVar(T)と書く。Var(S-&gt;T) = Var(S)∪Var(T) として、これをプロファイルS-&gt;Tの変数と呼ぶ。プロファイルの右辺Tの側にだけ出現する変数を&lt;strong&gt;制御不可変数&lt;/strong&gt;、左辺Sにだけ出現する変数を&lt;strong&gt;制御可能変数&lt;/strong&gt;、両側に出現する変数を&lt;strong&gt;伝搬変数&lt;/strong&gt;と呼ぶ。read-some-file :: void -&gt; _T の _T は制御不可変数である。length :: list&amp;lt;_T&gt; -&gt; integer(minimum=0) における _T は制御可能変数、 first :: list&amp;lt;_T&gt; -&gt; T throws IndexOutOfRange における _T は伝搬変数である。

&lt;h5&gt;左辺型と右辺型&lt;/h5&gt;

型解析では、通常のスキーマ言語の型と少し違う型も使う。プロファイル S-&gt;T  の左辺に使える型を&lt;strong&gt;左辺型&lt;/strong&gt;、右辺に使える型を&lt;strong&gt;右辺型&lt;/strong&gt;と呼ぶ。

左辺型は、スキーマ言語の型と同じである。左辺型で使える型演算：

+ [, ] （配列構成、クリーニスター使用可能）
+ {, } （オブジェクト構成、ワイルドカード使用可能）
+ @
+ ?
+ | （制限有り、排他的）
+ &amp;amp;

一方、右辺型で使える型演算は次のとおり。

+ [, ]
+ {, }
+ @
+ ?
+ ∪ （制限なし）

制限付きの排他的ユニオン演算'|'の代わりに無制限のユニオン（集合の合併、ジョイン）演算∪が使える。インターセクション&amp;amp;は使えないが、これは消去不可能なインターセクション（次節）が使えないことを意味し、&lt;em&gt;消去可能なインターセクションは自由に使ってよい。&lt;/em&gt;

&lt;h5&gt;消去不可能なインターセクション&lt;/h5&gt;

インターセクション演算子&amp;amp;は分配法則を使って、式の内側へと移動することが出来る。この計算によって最終的に消えてしまうインターセクションは&lt;strong&gt;消去可能&lt;/strong&gt;と呼ぶ。&lt;strong&gt;消去不可能なインターセクション&lt;/strong&gt;とは、&amp;amp;の左右どちらか（両方かも）が変数であるものである。&amp;amp;は可換演算なので、左に変数があると仮定して一般性を失わない。つまり、x&amp;amp;T の形が消去不可能なインターセクションである。

次の制約を置く。

- &lt;b&gt;プロファイルの右辺型には、消去不可能なインターセクションを書けない。&lt;/b&gt;

この制約は、コマンドプロファイルに対して検査される。コマンドプロファイルの右辺は、インターセクションを持たないか、消去可能なインターセクションだけを持つことになる。消去可能なインターセクションは前もって消去しておくとする。そして、右辺に出現する記号'|'をすべて∪に置き換えておく。

&lt;h5&gt;型の分類&lt;/h5&gt;

型を次の12種に分類する。

+ never型
+ any型
+ シングルトン型（数値リテラル、文字列リテラル、true, false, null）
+ スカラー型（integer, number, string, boolean）
+ 配列型
+ オブジェクト型
+ タグ（明示的タグ）付き型
+ オプショナル型
+ 排他的ユニオン型
+ インターセクション型
+ ジョイン型（無制限ユニオン型）
+ 変数（不定型）

左辺型は、ジョイン型を除く11種、右辺型は、インターセクション型と排他的ユニオン型を除く10種である。変数はさらに、制御不可変数、制御可能変数、伝搬変数で扱いが少し異なる。

&lt;h5&gt;パイプ番号と条件&lt;/h5&gt;

式Eが与えられたとき、そのなかに出現するパイプ記号に1以上の整数で番号を付けておく。この番号は一意識別できればなんでもよく、番号の大小は意味を持たない。特定の式のなかで、1番パイプ、2番パイプなどで特定パイプを指示できればそれでよい。

Eが与えられた式、Aがダミーの式として、便宜上 A | E という式を考えて、Eの左に出現するパイプ（Eのなかのパイプではない）を0番パイプと呼ぶ。0番パイプは「式の入り口」とまったく同じ意味である。

n番パイプに付与された実行時型チェック条件を&lt;strong&gt;n番条件&lt;/strong&gt;と呼ぶ。特に0番条件は入り口条件である。型解析が完全に成功すると、実行時型チェック条件は不要になるが、0番条件だけは別で、多くの場合は0番条件を省略はできない。

*1262750742*[型検査][caty]型解析：タグ付きJSONパス

型解析でもJSONパスは大活躍する。JSONパスでは、配列インデックス（非負整数値）とオブジェクトプロパティ名（文字列）により部分構造にアクセスする。インデックス／プロパティ名によるアクセスには、ブラケット記号（'[', ']'）とドット記号（'.'）が使われるが、ここではドットだけを使う。

&lt;h5&gt;ドットオンリーのJSONパス&lt;/h5&gt;

プロパティ名は、原則として引用符付き文字列リテラルとして表現する。次は、JSONパスの例となる。

- $.&quot;foo&quot;.&quot;bar baz&quot;.2
- $.0.&quot;foo&quot;.3.&quot;2&quot;

「.2」と「.&quot;2&quot;」が違うことに注意。空白や特殊文字を含まず、数値と誤解されない文字列に関しては引用符を省略できるとする。

- $.foo.&quot;bar baz&quot;.2
- $.0.foo.3.&quot;2&quot;

以下では、get(data, path) という関数（メソッドではない）で、データの部分構造を抜き出せるとする。また、exists(data, path) は、パスが指す場所に値が存在するかどうかを調べる述語関数だとする。

JSONパスをgetやexistsに渡すときは、&quot;$.foo.\&quot;bar baz\&quot;.2&quot;, &quot;$.0.foo.3.\&quot;2\&quot;&quot; のように引用符のエスケープが必要である。シングルクォートやトリプルクォートが使えれば、'$.foo.&quot;bar baz&quot;.2', '''$.0.foo.3.&quot;2&quot;''' のように書ける。

&lt;h5&gt;タグチェック&lt;/h5&gt;

@foo のようなタグをJSONパスに挿入できる。次の例を見てみる。

&lt;pre&gt;
@secretData 
@person {
  &quot;name&quot; : @personName &quot;檜山&quot;,
  &quot;contact&quot; : @contactInfo {
    &quot;mail&quot; : @mail &quot;hiyama@chimaira.org&quot;,
    &quot;url&quot; : @url &quot;http://d.hatena.ne.jp/m-hiyama/&quot;
  }
}
&lt;/pre&gt;

このデータに対して、通常のJSONパスはタグを無視してアクセスする。

|* JSONパス  |* 取り出される値 |
| $.name     | @personName &quot;檜山&quot; |
| $.contact.url | @url &quot;http://d.hatena.ne.jp/m-hiyama/&quot; |

JSONパスにタグが挿入されると、データのタグを確認し、マッチしないとエラーにして、さらにタグを取り除いた値を返す。
 
|* JSONパス  |* 取り出される値 |
| $@publicData    | エラー |
| $@secretData    | @person { ...} |
| $@person        | エラー |
| $@secretData@person |  {&quot;name&quot;: ...} |
| $@secretData.name | @personName &quot;檜山&quot; |
| $@secretData.name@personName | &quot;檜山&quot; |
| $@secretData@person | {&quot;name&quot;: ...} |
| $.contact | @contactInfo {&quot;mail&quot;: ...} |
| $.contact@contactInfo | {&quot;mail&quot;: ...} |
| $.contact@contactInfo.mail | @mail &quot;hiyama@chimaira.org&quot; |
| $.contact@contactInfo.mail@mail | &quot;hiyama@chimaira.org&quot; |
| $.contact@contactInfo.mail@url | エラー |
| $.contact.mail@mail | &quot;hiyama@chimaira.org&quot; |

次のようなワイルドカードパターンがあると便利そうだが、型解析の文脈では関係しない。

+ @* -- 任意のタグ
+ @foo? -- @foo またはタグがない
+ @*? -- 任意のタグ、またはタグがない
+ @** -- 任意個のタグの連続
+ @*+ -- 1個以上のタグの連続

&lt;h5&gt;条件付きワイルドカード&lt;/h5&gt; 

「#」を数値ワイルドカード、「*」を文字列ワイルドカードに使える。これを精密化して、次のような条件付きワイルドカードを導入する。nは非負整数定数、α&lt;sub&gt;i&lt;/sub&gt;は名前文字列である。

- #&gt;n -- nより大きいすべての非負整数にマッチ
- #&gt;=n -- n以上のすべての非負整数にマッチ
- [^α&lt;sub&gt;1&lt;/sub&gt;, ..., α&lt;sub&gt;k&lt;/sub&gt;] --- α&lt;sub&gt;1&lt;/sub&gt;, ..., α&lt;sub&gt;k&lt;/sub&gt; 以外のすべての名前にマッチ

例：

- mailAddrs.#&gt;1 -- mailAddrs[2], mailAddrs[3], ... などにマッチ
- mailAddrs.#&gt;=1 -- mailAddrs[1], mailAddrs[2], ... などにマッチ
- $@person.[^&quot;name&quot;,&quot;contact&quot;] -- α≠&quot;name&quot;, α≠&quot;contact&quot; である $@person.α にマッチ

注意：ドットの代わりにブラケットを使うと、ブラケットのなかに [^&quot;name&quot;,&quot;contact&quot;] が入って、ブラケットが二重になる。なんか細工した方がいいかも。

&lt;h5&gt;pvalidate関数&lt;/h5&gt; 

Tを型表現として、validate(data, T) が妥当性検証関数とする。validate(get(data, path), T) を pvalidate(data, path, T) とする。ただし、pathにはタグチェックとワイルドカードを含めてよい。

+ パスのタグチェックに失敗したときは、pvalidateはfalseを返す。
+ ワイルドカードがあれば、dataに対して有効なパスと、ワイルドカードとのマッチを行い、マッチするすべてのパスに対して検証する。

例えば、pvalidate([0, 1, 2, 3], &quot;$.#&gt;=1&quot;, &quot;integer&quot;) は次の検証をする。

+ validate(1, &quot;$.1&quot;, &quot;integer&quot;)
+ validate(2, &quot;$.2&quot;, &quot;integer&quot;)
+ validate(3, &quot;$.3&quot;, &quot;integer&quot;)

&quot;$.#&gt;=1&quot; が、&quot;$.1&quot;, &quot;$.2&quot;, &quot;$.3&quot;, &quot;$.4&quot;, ... に展開され、実際のデータに対して有効なパス &quot;$.1&quot;, &quot;$.2&quot;, &quot;$.3&quot; だけがチェックされる。

*1262750743*[型検査][caty]型解析：細かい注意点

&lt;h5&gt;never型、undefined、型変数の値となる領域&lt;/h5&gt;

never型はいかなるインスタンスも持たない。never?型の唯一のインスタンスはundefinedと書く。undefinedは意味領域に存在する値だが、表層には出てこない。コマンドの入力にundefinedが入ることはなく、コマンドの出力にundefinedが混じることもあり得ない。undefinedはデータとして受け渡されるものではなく、配列の項目（item）、オブジェクトのプロパティ、タグ付き値のvalの不在の目印となるだけである。存在しない項目／プロパティ／valにアクセスした場合、undefinedが取り出せるわけではなく、例外などのエラーとなる。

型変数は、undefinedを含まない領域を表す。つまり、変数xに対して never⊆x  は常に成立する（公理だ）が、never?⊆x は成立しない。変数がそのままでオプショナル型になることはなく、'?'を付けてはじめてオプショナル型になる。よって、T? ⊆ x は、Tが何であっても成立しない。

&lt;h5&gt;シングルトン型とnull&lt;/h5&gt;

単にシングルトン型といえば、シングルトンスカラー型を指す。複合データを1つだけ含むシングルトン型は、シングルトンスカラー型と型構成子から作れる。

シングルトン型はスカラーリテラルによって表現される。つまり、

+ 数値リテラルはシングルトン型
+ 文字列リテラルはシングルトン型
+ true, false, null はシングルトン型

となる。もともと、null値だけからなるシングルトン型がnull型だったので、nullはリテラルと型を同一視する方式に合致している。Catyでは、nullをシングルトンスカラー型として扱う。シングルトンではないスカラー型は、integer, number, string, booleanとなる。

&lt;h5&gt;暗黙タグを付与する方法&lt;/h5&gt;

integer, number, string, boolean, null, array, object は型名として予約されている。arrayとobjectは次の定義を持つと考えてよい。

- type array = [any*];
- type array = {*:any?};

一方で、

- any = (number|string|boolean|null|array|object)

なので、arrayとobjectの定義は再帰的になる（これは余談）。

- type array = [(number|string|boolean|null|array|object)*];
- type array = {*:(number|string|boolean|null|array|object)?};

integer, number, string, boolean, null, array, object のインスタンには、型名と同じタグを付けてよい。@integer 3, @number 3.14, @string &quot;hello&quot;, @array [1, 2, 3] など。しかし、これらのタグはすぐに消滅してしまい、そのまま維持されることはない。

タグが付いてない値やデータに、どうしてもタグが必要な場合は、予約型名と同じタグ（暗黙タグ）を付与することができる。暗黙タグを付与する作業が必要になるのは、排他的ユニオンの排他性の検査のときだけである。特に、シングルトン型（スカラーリテラル）には次のルールでタグを付ける。

+ 数値リテラルには、@number を付ける。このとき、&lt;em&gt;@integerは使わない。&lt;/em&gt;
+ 文字列リテラルには、@string を付ける。
+ true, false には、@boolean を付ける。
+ null には、@null を付ける。

&lt;h5&gt;排他的ユニオンの排他性のチェック&lt;/h5&gt;

(T&lt;sub&gt;1&lt;/sub&gt; | ... | T&lt;sub&gt;n&lt;/sub&gt;) の形をしたユニオンが排他的である条件は：

- すべての型のタグ（暗黙でもよい）が異なっていること。ただし、@integerと@numberは異なるとは認めない。

成分の型に明示的なタグが付いている必要はない。例えば、次の例は排他的となっている。

&lt;pre&gt;
type coord = [number, number] 
           | {&quot;x&quot;:number, &quot;y&quot;:number} 
           | string(remark=&quot;座標のテキスト表現&quot;);
&lt;/pre&gt;

このcoord では (@array | @object | @string) という3つの暗黙タグが互いに異なる。

新スキーマ構文では、次も許される。

&lt;pre&gt;
type gender = (&quot;male&quot; | &quot;female&quot;);
&lt;/pre&gt;

この例では、(@string | @string) となり、同じタグが含まれる。同じタグを持つシングルトン型をユニオンとして許すため、次の規則を入れる。

+ ユニオンの成分に同じタグがあってもよい。
+ ただし、同じタグを持つ型はシングルトン型に限り、それらは互いに排他的（異なる値）でなくてはならない。

シングルトン型またはスカラー型は、次のどれかのタグを持つ； @integer, @number, @string, @boolean, @null。これらのタグを持つ型の排他性は容易に判定できる。例えば、(1|integer), (2|2), (integer|number), (true|boolean) などは排他的&lt;em&gt;ではない&lt;/em&gt;例。従来の列挙型、例えば (0|1|2) は、新しい排他性の定義から排他的となる。シングルトン型とスカラー型のあいだに明白な区別はないので、次のようなユニオン型も認める； (integer|false), (0|1|2|null), (number|&quot;+inf&quot;|&quot;-inf&quot;)。

型変数が含まれるユニオンは排他性が保証されないので認めない。例えば、(_X|string), (@foo _X | @foo _Y) などは認めない。しかし、(@foo _X | @bar _Y) は排他的だとすぐわかるのでOK。

ユニオンの排他性は、一般の古典論理（∨を含む）を使わず、連言論理だけで型解析を済ませるために必要な条件である。古典論理の計算負担は、∨の多段枝分かれにより、ときに手に負えなくなる。連言論理の範囲内に収めることは効率上重要である。

</body>
</day>
<day date="1910-01-06" title="">
<body>
*1262654236*[caty][型検査]型解析：SILへの準備としての連言論理

SIL（Simple Inclusion Logic; 汁）は、Catyの型解析の基盤／背景となる論理システムである。型解析アルゴリズムは、SILを直接的に実装する必要はないが、アルゴリズムの解釈と正当性の主張はSILをベースに行う。

&lt;em&gt;注意：このエントリーは他の関連エントリーとの兼ね合いで大幅に修正したり、場所を移動したりする可能性があります。&lt;/em&gt;

&lt;h4&gt;●連言論理&lt;/h4&gt;

SILは、連言論理（conjunctive logic）の一種なので、まず連言論理を一般的に説明する。一般的とは、汎用ということで、世間一般の定式化かどうかは知らない。以下は、オリジナリティはないが檜山が考えた定式化。定義の羅列となるが、型推論において、実例はいくらでも出てくる。

原子論理式を論理結合子∧により結合した記号的図形が連言論理の論理式。ここでは、∧の代わりにカンマを使い、P∧Q∧R ではなく P, Q, R のように書く。原子論理式はローマ大文字、論理式はギリシャ大文字Φ、Ψ、Δなどで表すことにする。論理式（formula）を単に式とも呼ぶ。（Catyスクリプトの式も単に式と呼ぶので、混乱に注意！）空の並び、単一の原子論理式も式に含める。Φ, P, Q, Ψ のような書き方について説明しないが、&lt;em&gt;シーケントの左辺と同じ&lt;/em&gt;、と言っておく。

横棒の上下に式を書いた図形を推論図と呼ぶ。推論図は、上が仮定で下が結論である推論規則の表現。まず、論理式を「原子論理式の集合」と解釈していいことを保証する構造規則を導入する。

&lt;pre&gt;
    Φ, P, Q, Ψ
  ---------------[換]
    Φ, Q, P, Ψ


     Φ, P, Ψ
  ---------------[増]
    Φ, P, P, Ψ


    Φ, P, P, Ψ
  ---------------[減]
     Φ, P, Ψ
&lt;/pre&gt;

P, Q, R のような図形（構文的対象物）としての論理式は、集合 {P, Q, R} とみなしてよい。特に、空な論理式は {}（空集合）、単一の原子論理式からなる論理式は {P}（単元集合、シングルトン） となる。

次は連言論理の基本推論規則である。
&lt;pre&gt;
    Φ, Ψ
  ----------[射影]
     Φ
&lt;/pre&gt;

Ψは空でもいいので：
&lt;pre&gt;
    Φ
  --------[恒等]
    Φ
&lt;/pre&gt;

射影の特別な場合として次がある。

&lt;pre&gt;
    P, Q
  --------[左射影]
     P
&lt;/pre&gt;

構造規則・換と組み合わせれば：

&lt;pre&gt;
    P, Q
  --------[右射影]
     Q
&lt;/pre&gt;

論理定数、true, false も原子論理式に含まれるとして、次の推論規則も認める。

&lt;pre&gt;
    
  -----------[true導入]
     true

     false
  -----------[矛盾]
      Φ
&lt;/pre&gt;

falseからは何を推論してもよい。それが矛盾の定義。

以上に挙げた推論図を上下左右に積み重ねて証明図を作ってよい。ΦからΨへの証明図があるとき、ΦからΨが証明可能だといい、Φ |- Ψ と書く。Φ |- Ψ はシーケントと似てるが、次の点が異なるから注意。

+ 右辺のカンマの解釈も∧であり、∨ではない。（古典論理のシーケントの右辺のカンマは∨）
+ 内容的な（メタな）主張であり、形式的な存在（構文的な図形）ではない。

Φ |- Ψ とまったく同じ内容の主張を Ψ -| Φ と書き、次の用語を使う。

- Φ |- Ψ … ΦからΨを証明できる
- Ψ -| Φ … ΨをΦに還元できる

Φ |- Ψ かつ Φ -| Ψ のとき、Φ |-| Ψ と書き、ΦとΨは（論理的に）&lt;strong&gt;同値&lt;/strong&gt;という。Φ |-| Ψ を、Φ≡Ψ と書くこともある。

必要に応じて、論理式を原子論理式の集合とみなすことにすると、射影とtrue/falseに関する推論規則は次の形で述べてもよい。

+ Ψ⊆Φ ならば、Φ |- Ψ
+  {} |- {true}
+ {false} |- Φ

「推論図を上下左右に積み重ねて証明図を作ってよい」の根拠は：

- Φ |- Ψ かつ Ψ |- Δ ならば、Φ |- Δ
- Φ |- Ψ かつ Δ |- Γ ならば、Φ, Δ |- Ψ, Γ

実際の証明図では、区切りにカンマだけでなく空白（間隔）も使い、次の規則を仮定する。

&lt;pre&gt;

   Φ      Ψ
  -------------
     Φ, Ψ


     Φ, Ψ
  -------------
   Φ      Ψ
&lt;/pre&gt;

その他、図示における省略法やレイアウトの技工があるが、今は説明しない。コツは、連言記号∧、カンマ、空白を適宜使い分けること。論理式をボックス、横棒をワイヤーにした図のほうが描きやすいかもしれない。

&lt;h4&gt;●連言的コレクション&lt;/h4&gt;

今まで、Φ、Ψなどは原子論理式の有限列または有限集合を表わしてきたが、これからは無限列／無限集合も許すとする。原子論理式の無限個の集まりを許した列／集合を&lt;strong&gt;連言的コレクション&lt;/strong&gt;（conjunctive collection）と呼ぶことにする。連言的コレクションは、必要に応じて（文脈ごとに）、カンマで区切られた列、集合、∧で構成された単一論理式、論理式の集まりなどの解釈をする。

連言論理を連言的コレクション（無限を許す）に一般化しておく。構造規則・換を少し修正するが、その他の規則はそのまま通用する。

&lt;pre&gt;
    Φ, Δ, Γ, Ψ
  ------------------[換]
    Φ, Γ, Δ, Ψ
&lt;/pre&gt;

証明図の仮定、結論、中間の式として無限の連言的コレクションを許すが、証明図が無限になることは許さない。そのため、Φ |- Ψの意味も少し修正する。Φ |- Ψ とは：

- P∈Ψ ごとに、有限のΦ'（Φ'⊆Φ）があって、Φ' から P への有限な証明図がある。

Φ |- Ψ のΦが空の時は、 |- Ψ と書く。この意味は：

- すべての P∈Ψ に対して、仮定を持たない P の有限な証明図がある。

|- Ψ のとき、Ψを&lt;strong&gt;定理コレクション&lt;/strong&gt;と呼ぶ。定理コレクションに含まれる原子論理式は、すべて公理だけから証明可能である。

連言的コレクションΦが次の性質を持つときセオリーと呼ぶ。

- Φ |- P ならば P∈Φ

同じことだが、次のようにも言える。

- Φ |- Ψ ならば Ψ⊆Φ

セオリーは、大きなコレクションになりがちで扱いやすいとは言えない。そのため、次の定義をする。

- Φが&lt;strong&gt;凖セオリー&lt;/strong&gt;とは、Φ |- Ψ ならば Ψ≡Ψ' かつ Ψ'⊆Φ となるΨ'が存在する。

与えられた連言的コレクションΔに対して、Δに対する凖セオリーΦを求めることは非常に重要である。Δに対する凖セオリーΦとは次の意味である。

- Δ≡Δ' かつ Δ'⊆Φ となるΔ'がある。
- Φは凖セオリーである。

この定義から、次の性質が出る。

- ΦがΔに対する凖セオリーだとして、Δ |- Γ ならば、Γ'≡ΓかつΓ'⊆ΦとなるΓ'がある。

セオリーは、公理系の同値類の代表元として使える。つまり、論理的に同値な公理系に対するセオリーは一致する。多くの場合、セオリーの代用として凖セオリーを使える。アルゴリズム的には、凖セオリーのほうが（還元／正規化と組み合わせれば）扱いやすい。公理系の同値類に対して、正規化された凖セオリーを一意的に対応させたい -- これがSILを扱うときの基本的な方向性となる。

*1262658438*[型検査][caty]型解析：SILと公理・規則群

SILは、連言論理の枠組み（汎用）に、SIL固有の公理と推論規則を付け加えた論理システムである。

&lt;h4&gt;●連言論理ベースの演繹系としてのSIL&lt;/h4&gt;

&lt;h5&gt;項と簡約計算&lt;/h5&gt;

Caty(新)スキーマ言語の型表現を型項、あるいは単に項（term）とも呼ぶ。項には変数（型変数）を含んでもよい。S、Tを項だとして、記号'⊆'を使った、S⊆T という記号的図形をSILの原子論理式とする。今出てきた'⊆'は単なる記号で内容的な意味はない。一方で、説明の地の文でも記号'⊆'を内容的に使うので注意（これは、形式的体系を扱うときのいつもの注意）。

SILと関連して、しかし別な計算システムとして項の簡約計算系がある。簡約計算系については今述べないが、S⇒S' は、項SがS'に簡約されることを示す（&lt;em&gt;含意ではないので注意&lt;/em&gt;）。S⇒S' であるとき、構文的に、S'はSより簡単な形となっているが、意味的には S = S'（等号）である。S⇒S' という記号的図形もSILの原子論理式として扱う。

正しい簡約計算の例をいくつか挙げる。

+ x&amp;amp;x ⇒ x
+ x∪x ⇒ x
+ x&amp;amp;any ⇒ x
+ x∪never ⇒ x

&lt;h5&gt;公理と推論規則&lt;/h5&gt;

Sが任意の項として、S⊆S の形をした式（原子論理式）はすべて公理として扱うが、後述の変数置換規則があるので、xを変数（型変数）として、x⊆x という形だけに限定しても十分である。S⇒S' が項簡約計算で示せるとき（つまり、正しいとき）S⇒S' はSILの公理である。その他の公理も含めて以下にまとめる：

+ xが変数で、x⊆x
+ xが変数で、never⊆x
+ xが変数で、x⊆any
+ 正しい簡約等式 S⇒S'
+ 以上が公理のすべて

Pが公理なら当然に、|- P となる。念のために、公理を推論図の形で書いておく。

&lt;pre&gt;
 
  --------[ref; 反射律]
   x⊆x

 
  -----------[never; 最小元]
   never⊆x
 

  ---------[any; 最大元]
   x⊆any


  ---------[eq; 正しい等式]
   S⇒S'
&lt;/pre&gt;

連言論理の推論規則以外に、次の推論を加える。なお、以下の推論図では、カンマの代わりに空白を使い、注目すべき部分以外は省略して描かないことにする。P[S] は、式Pの部分項としてSが含まれることを示す。正確には、Sは単なる部分項ではなくて、位置を特定された（複数出現を許す）出現である。P[S'/S] は、P[S]におけるSの出現をS'で置き換えた式を意味する。変数の出現に関しては、すべての出現を一斉に置き換える。例えば、x⊆x の左右のx（変数）を別々に置き換えることはできない。

&lt;pre&gt;
   S⊆T  T⊆U
  -------------[trans; 推移律]
     S⊆U

    P[S]  S⇒S'
  --------------[eq-subst-1; 等値置換-1]
      P[S'/S] 

    P[S']  S⇒S'
  --------------[eq-subst-2; 等値置換-2]
      P[S/S'] 

      P[x] （xは変数、すべての出現を扱う）
  -----------------------------------[var-subst; 変数置換]
      P[S/x] （Sは非オプショナル項、すべての出現の同時置換）
&lt;/pre&gt;

SILでは含意'⊃'はないが、P |- Q のとき、P⊃Q が成立すると考えるとして、S⊆T ∧ T⊆S を S = T の定義とすれば、SIL内で次（に相当するメタ定理）が示せる。

+ S⊆S （true ⊃ S⊆S）
+ (S⊆T ∧ T⊆Y) ⊃ S⊆U
+ S = T ⊃ S⊆T
+ S = T ⊃ T⊆S
+ (S⊆T ∧ T⊆S) ⊃ S = U

&lt;h4&gt;●分解規則&lt;/h4&gt;

分解規則とは、推論規則（図）の上下を逆にしたもので、横棒の上が結論、下が仮定となる。結論が先に与えられて、その結論を導く仮定を求める操作が&lt;strong&gt;分解&lt;/strong&gt;である。推論図と分解図を区別するため、分解図には「↑」を添える。分解規則の一部は、上下を逆さまにして推論規則とも考えるが、推論規則と分解規則の統合は後で行う。

それ以上分解できない命題（論理式）を&lt;strong&gt;既約命題&lt;/strong&gt;と呼ぶ。既約命題であることを強調するときはブラケットで囲む（常にブラケットで囲むわけではない）。黒四角■は、そこに真または偽が入る場所を示す。分解図で■のすぐ上の命題は真偽が確定する命題で、&lt;strong&gt;確定命題&lt;/strong&gt;と呼ぶ。白四角□は、真偽値が不定であることを示す。分解図で□のすぐ上の命題は&lt;strong&gt;不定命題&lt;/strong&gt;と呼ぶ。

&lt;h5&gt;記号の約束&lt;/h5&gt;

分解規則のネーミングに次の略号を採用する。

+ s- : scalar (value)
+ st- : scalar type
+ l- : left
+ r- : right
+ b- : both
+ t- : tag

次のメタ変数を用いる。

- a, b はスカラー定数（リテラル）
- X, Y は、integer, number, string, boolean のいずれか
- α, β は、タグ名
- S, T は任意の型

&lt;h5&gt;確定命題&lt;/h5&gt;

&lt;pre&gt;
    a = b 
 ↑---------[s-eq; スカラー等値]
     ■

    a∈Y 
 ↑---------[s-elem; スカラー所属]
     ■

    X⊆Y
 ↑---------[st-inc; スカラー型の包含]
     ■

   α = β 
 ↑---------[t-eq; タグ名等値]
     ■
&lt;/pre&gt;


&lt;h5&gt;不定命題&lt;/h5&gt;

&lt;pre&gt;
    x⊆T
 ↑---------[l-var; 左変数]
     □

    S⊆y
 ↑---------[r-var; 右変数]
     □
&lt;/pre&gt;

&lt;h5&gt;複合型の分解規則&lt;/h5&gt;

配列型、オブジェクト型、排他的ユニオン型は、項目／プロパティ／成分（選択肢）の個数が少数の例を記述するが、n個の場合に一般化することができる。数値ワイルドカード'#', 名前ワイルドカード'*'は、不等号と補集合を使った具体的な条件で書き下す必要がある。論理式の冒頭の丸括弧内はロケーションラベルであるが、これについてはいずれ記述。

&lt;pre&gt;
  (i, p) [S, S'*] ⊆ [T, T'*]
 ↑--------------------------------------[arr; 配列]
    (i, p.0) S⊆T AND (i, p.#) S'⊆T'

   (i, p) {α:S, *:S'] ⊆ {α:T, *:T']
 ↑--------------------------------------[obj; オブジェクト]
    (i, p.α) S⊆T  AND (i, p.*) S'⊆T'

   (i, p)  (@α S) ⊆ (@β T)
 ↑---------------------------------------[tag; タグ]
   (i, p) [α = β] AND (i, p@α) S⊆T

   (i, p)  S ⊆ T?
 ↑------------------[r-opt; 右オプショナル]
    (i, p) S ⊆ T

   (i, p)  S? ⊆ T?
 ↑------------------[b-opt; 両側オプショナル]
    (i, p) S ⊆ T

   (i, p) S ⊆ (T |  T')
 ↑--------------------------------[xuni; 排他的ユニオン]
    (i, p) S⊆T XOR (i, p) S⊆T'

   (i, p) S ⊆ y&amp;amp;T
 ↑-------------------------------[inter; インターセクション]
   (i, p) [S⊆y] AND (i, p) S⊆T 

   (i, p) S∪S' ⊆ T
 ↑------------------------------[join; 集合のジョイン(無制限ユニオン)]
   (i, p) S⊆T AND (i, p) S'⊆T
&lt;/pre&gt;

</body>
</day>
<day date="1910-01-07" title="">
<body>
*1262658439*[型検査][caty]型解析：型ユニフィケーション

型ユニフィケーションは、証明ターゲット S⊆T を証明する過程の中心的な処理である。処理の結果として、いくつかの「不定命題＝動的なチェック条件」を出力する。

&lt;em&gt;注意：このエントリーは他の関連エントリーとの兼ね合いで大幅に修正したり、場所を移動したりする可能性があります。&lt;/em&gt;

記号の約束：
+ S, T, U, V, W ：型
+ a, b ：スカラー定数
+ x, y ：型変数
+ X, Y ：スカラー型（integer, number, string, booleanの4種、nullはシングルトン型として扱う）

SとTのユニフィケーションを行うとして、Sはユニフィケーションの&lt;strong&gt;左側型&lt;/strong&gt;、Tはユニフィケーションの&lt;strong&gt;右側型&lt;/strong&gt;と呼ぶ。&lt;em&gt;左側型Sは右辺型、右側型Tが左辺型であるので注意せよ。&lt;/em&gt;

ここでは（他では違う用語法を使った気もするが）、証明ターゲット S⊆T が証明できなかったとき（ユニフィケーション＝証明が）「失敗」という。S∩T = never が確認されたときは「完全に失敗」という。失敗しても完全に失敗かどうかはわからない。完全に失敗のときは、目印に×を付ける。ユニフィケーション処理が成功または続行する場合は、○印に続けてその根拠となる公理や分解規則を示す。ユニフィケーションの後にさらに処理が必要な場合は、★を付ける。

&lt;h5&gt;1. Sがneverのとき&lt;/h5&gt;

常に例外やシグナルを投げるコマンドは、プロファイルの右辺がneverなので、このケースは理論的には無意味ではない。（現実的にはほとんど無意味 ^^;）

- 確定命題 never⊆T を出力。○公理never

never⊆T は公理から常に真だが、neverが出現するときは警告すべきことも多い。

&lt;h5&gt;2. Sがanyのとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 any⊆any を出力。○公理any
+ Tがシングルトン型bならば、確定命題 any⊆b を出力。★
+ Tがスカラー型Yならば、確定命題 any⊆Y を出力。★
+ Tが配列型ならば、確定命題 any⊆T を出力。★
+ Tがオブジェクト型ならば、確定命題 any⊆T を出力。★
+ Tがタグ付き型 @β W ならば、確定命題 any⊆(@β W) を出力。★
+ Tがオプショナル型W?ならば、確定命題 any⊆W? を出力。★（any⊆W に還元）
+ Tが排他的ユニオン型ならば、anyとTの各成分のORユニフィケーション。結果はすべて失敗。○xuni ★
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題 any⊆y を出力し、anyとWのユニフィケーション。○inter
+ Tが型変数yのとき、不定命題 any⊆y を出力。○r-var

any⊆any 以外の確定命題はすべて偽になる。しかし、完全な失敗とは限らない。

&lt;hr&gt;
&lt;h5&gt;3. Sがシングルトン型aのとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 a∈any を出力。○公理any
+ Tがシングルトン型bならば、確定命題 a = b を出力。○s-eq
+ Tがスカラー型Yならば、確定命題 a ∈ Y を出力。○s-elem
+ Tが配列型ならば、完全に失敗。×
+ Tがオブジェクト型ならば、完全に失敗。×
+ Tがタグ付き型 @β W ならば、完全に失敗。×
+ Tがオプショナル型W?ならば、aとWのユニフィケーション。○r-opt
+ Tが排他的ユニオン型ならば、aとTの各成分のORユニフィケーション。結果として、失敗かまたは単一のユニフィケーション。○xuni
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題 a∈y を出力し、aとWのユニフィケーション。○inter
+ Tが型変数yのとき、不定命題 a∈y を出力。○r-var

&lt;h5&gt;4. Sがスカラー型Xのとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 X⊆any を出力。○公理any
+ Tがシングルトン型bならば、確定命題X⊆b を出力。★
+ Tがスカラー型Yならば、確定命題 X⊆Y を出力。○st-inc
+ Tが配列型ならば、完全に失敗。×
+ Tがオブジェクト型ならば、完全に失敗。×
+ Tがタグ付き型 @β W ならば、完全に失敗。×
+ Tがオプショナル型 W? ならば、XとWのユニフィケーション。○r-opt
+ Tが排他的ユニオン型ならば、XとTの各成分のORユニフィケーション。結果として、失敗かまたは単一のユニフィケーション。○xuni
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題 X⊆y を出力し、XとWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題 X⊆y を出力。○r-var

&lt;h5&gt;5. Sが配列型のとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 S⊆any を出力。○公理any
+ Tがシングルトン型bならば、完全に失敗。×
+ Tがスカラー型Yならば、完全に失敗。×
+ Tが配列型ならば、Sの各項目とTの各項目のANDユニフィケーション。○arr
+ Tがオブジェクト型ならば、完全に失敗。×
+ Tがタグ付き型 @β W ならば、完全に失敗。×
+ Tがオプショナル型 W? ならば、SとWのユニフィケーション。○r-opt
+ Tが排他的ユニオン型ならば、SとTの各成分のORユニフィケーション。結果として、失敗かまたは単一のユニフィケーション。○xuni
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題 S⊆y を出力し、SとWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題S⊆yを出力。○r-var

&lt;h5&gt;6. Sがオブジェクト型のとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 X⊆any を出力。○公理any
+ Tがシングルトン型bならば、完全に失敗。×
+ Tがスカラー型Yならば、完全に失敗。×
+ Tが配列型ならば、完全に失敗。×
+ Tがオブジェクト型ならば、Sの各プロパティとTの各プロパティのANDユニフィケーション。○obj
+ Tがタグ付き型 @β W ならば、完全に失敗。×
+ Tがオプショナル型 W? ならば、SとWのユニフィケーション。○r-opt
+ Tが排他的ユニオン型ならば、SとTの各成分のORユニフィケーション。結果として、失敗かまたは単一のユニフィケーション。○xuni
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題S⊆yを出力し、SとWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題S⊆yを出力。○r-var

&lt;h5&gt;7. Sがタグ付き型@α Vのとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 X⊆any を出力。○公理any
+ Tがシングルトン型bならば、完全に失敗。×
+ Tがスカラー型Yならば、完全に失敗。×
+ Tが配列型ならば、完全に失敗。×
+ Tがオブジェクト型ならば、完全に失敗。×
+ Tがタグ付き型 @β W ならば、確定命題 α=β を出力し、VとWのユニフィケーション。○tag（α=β はその場でやってしまうほうが早いな）
+ Tがオプショナル型 W? ならば、TとWのユニフィケーション。○r-opt
+ Tが排他的ユニオン型ならば、SとTの各成分のORユニフィケーション。結果として、失敗かまたは単一のユニフィケーション。○xuni
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題S⊆yを出力し、SとWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題S⊆yを出力。○r-var

&lt;hr&gt;
&lt;h5&gt;8. Sが変数xのとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 x⊆any を出力。○公理any
+ Tがシングルトン型bならば、不定命題 x⊆b を出力。○l-var 
+ Tがスカラー型Yならば、不定命題 x⊆Y を出力。○l-var 
+ Tが配列型ならば、不定命題 x⊆T を出力。○l-var
+ Tがオブジェクト型ならば、不定命題 x⊆T を出力。○l-var
+ Tがタグ付き型 @β W ならば、不定命題 x⊆(@β W) を出力。○l-var
+ Tがオプショナル型 W? ならば、不定命題 x ⊆ W? を出力。○l-var ★（x⊆W に還元）
+ Tが排他的ユニオン型ならば、不定命題 x⊆T を出力。○l-var★（排他的ユニオンの一般処理ができない）
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題x⊆yを出力し、xとWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題x⊆yを出力。○r-var, l-var

&lt;h5&gt;9. Sがオプショナル型V?のとき&lt;/h5&gt;

+ Tがneverならば、完全に失敗。×
+ Tがanyならば、確定命題 V?⊆any を出力。★
+ Tがシングルトン型bならば、確定命題 V?⊆b を出力。★
+ Tがスカラー型Yならば、確定命題 V?⊆Y を出力。★
+ Tが配列型ならば、確定命題 V?⊆T を出力。★
+ Tがオブジェクト型ならば、確定命題 V?⊆T を出力。★
+ Tがタグ付き型 @β W ならば、確定命題 V?⊆(@β W) を出力。★
+ Tがオプショナル型 W? ならば、VとWのユニフィケーション。○b-opt
+ Tが排他的ユニオン型ならば、確定命題 V?⊆T を出力。★（排他的ユニオンの一般処理ができない）
+ Tがインターセクション型 y&amp;amp;W ならば、不定命題V?⊆yを出力し、V?とWのユニフィケーション。○inter
+ Tが型変数yならば、不定命題V?⊆yを出力。○r-var

確定命題はすべて偽になる。

&lt;h5&gt;10. Sが無制限ユニオン型U∪Vのとき&lt;/h5&gt;

- (U, T), (V, T)のANDユニフィケーション。○join ★

&lt;h5&gt;出力する命題の形&lt;/h5&gt;

記号の約束：
+ a, b：スカラー定数
+ α, β：タグ名
+ X, Y：スカラー型
+ x, y：型変数
+ S, T, V：型

確定命題：
+ a = b （s-eq; スカラー定数の比較）
+ α=β （t-eq; ラベル名の比較）
+ a ∈ Y （s-elem; sing(a)⊆Y； スカラー定数のスカラー型所属）
+ X⊆Y （st-eq; スカラー型の比較）

不定命題：
+ a ∈ y （sing(a)⊆y）
+ T⊆y （Tは任意の型、r-var）
+ x⊆T （Tは任意の型、l-var）

</body>
</day>
<day date="1910-01-08" title="">
<body>
*1262925105*[型検査][caty]型解析：気分転換にErlang

型を次の&lt;del datetime=&quot;2010-01-12T16:17:20+09:00&quot;&gt;12種&lt;/del&gt;13種に分類する。

|* 番号 |* 型種別   |* 旧構文   |* 新構文  |* Erlang |* 備考 |
| 1     | never型   | never     | never    | never   |みんな同じ|
| 2     | any型     | any       | any      | any     |みんな同じ|
| 3     | リテラル  | JSONリテラル| JSONリテラル | Erlangリテラル |ほとんど同じ|
| 3.1   | 数値リテラル|JSON数値 | JSON数値 | Erlang数値 | ほとんど同じ|
| 3.2   | 文字列リテラル|JSON文字列|JSON文字列| Erlang文字列|ASCIIに限れば同じ|
| 3.3   | true, false, null|JSONリテラル|JSONリテラル|アトム| - |
| 4     | スカラー型 | 名前     | 名前   | アトム| みんな同じ |
| 5     |  配列型    | array [...] | [...] | {array, [...]} | - |
| 6     |  オブジェクト型| object {...} | {...} | {object, [...Proplist]} | プロパティキーは文字列 |
| 7     | タグ（明示的タグ）付き型| @α T | @α T | {tag, Tag, Type} | - |
| 8     | オプショナル型 |   T?   | T? | {opt, Type} | - |
| 9     | 排他的ユニオン型 | T1 &amp;#124; T2 | T1 &amp;#124; T2 | {xunion, [...]} | - |
| 10    | インターセクション型 | T1 &amp;amp; T2 | T1 &amp;amp; T2 | {inter, [...]} | - |
| 11    | ジョイン型 |  T1 ∪ T2 |T1 ∪ T2 | {join, [...]} | - |
| 12    | 変数（不定型）| _Name     | _Name      | {'var', Name} | Nameはアトム |
| *     | スター（繰り返し）型 | T* | T* | {star, {opt, Type}} | ワイルドカードも同じ |

スター型（クリーネスター）は、配列の最後でだけ使えるもので、一人前の型ではない。{star, {opt, Type}} という形式は、オブジェクト型のワイルドカードとしても使っている。スター型を配列とオブジェクトで共通に使い、処理も共通にしようとしたが、実際にはそうなってない。

&lt;pre&gt;
@person {
 &quot;handle&quot; : string,
 &quot;name&quot; : string?,
 &quot;job&quot; : [string*]
}
&lt;/pre&gt;
のErlang表現は：
&lt;pre&gt;
{tag, person,
 {object, [
   {&quot;handle&quot;, string},
   {&quot;name&quot;, {opt, string}},
   {&quot;job&quot;, {array, [{star, {opt, string}}]}}
 ]}
}
&lt;/pre&gt;

</body>
</day>
<day date="1910-01-10" title="">
<body>
*1263114915*[型検査][caty]型解析：型ユニフィケーションの分類結果と処理順番

左側分類と右側分類の番号が微妙にずれてしまった。が、もう直すのが手間だから、ずれた番号をそのまま使うことにする。

ちと不恰好だが、もう勘弁してくれ。これで一応の結果としたい（間違いが発見されなければ）。後で元気があるときに、番号付けと順番を再考するかもしれない。

&lt;h5&gt;左側分類&lt;/h5&gt;

+ never
+ any
+ LIT
+ SCA
+ [,]
+ {,}
+ @
+ x (var)
+ ?
+ join

&lt;h5&gt;右側分類&lt;/h5&gt;

+ never
+ any
+ LIT
+ SCA
+ [,]
+ {,}
+ @
+ ? （ここでずれた、変数が最後になっている）
+ xunion
+ &amp;amp;
+ y (var)

&lt;h5&gt;順番&lt;/h5&gt;

10*11 = 110 の欄を持つマトリックスを、次の順番で塗りつぶす（網羅する）。この順番が絶対というわけではないし、効率は考えてない。が、とりあえず「&lt;b&gt;うまくいく&lt;/b&gt;」であろう順番。

|* 順番  |* 左側 |* 右側   |* 分類番号   |* 事後処理 |
| 1      | join  | -       |10*[1-11]    | 進行=&gt;join |
| 2      |never  | -       |1*[1-11]     | 成功終了  |
| 3      |-      | never   |[2-9]*1      | 完全失敗終了  |
| 4      |-      | &amp;amp;   |[2-9]*10     | 条件出力 and 進行=&gt;inter   |
| 5      |?      | ?       |9*8          | 進行=&gt;b-opt   |
| 6      |-      | ?       |[2-8]*8      | 進行=&gt;r-opt   |
| 7      |?      | -       |9*[2-7,9,11] | 条件出力 and 進行=&gt;l-opt |
| 8      |-      | any     |[2-8]*2      | 判定 or 条件出力(8*2) |
| 9      |any    | -       |2*[3-7,9,11] | 条件出力      |
|10      |-      | y       |[3-8]*11     | 条件出力      |
|11      |x      | -       |8*[3-7,9]    | 条件出力      |
|12      |-      | xunion  |[3-7]*9      | 完全失敗 or 進行=&gt;xunion|
|13      |LIT    | -       |3*[3-7]      | 判定         |
|14      |SCA    | -       |4*[3-7]      | 判定          |
|15      |[,]    | -       |5*[3-7]      | 進行=&gt;array     |
|16      |{,}    | -       |6*[3-7]      | 進行=&gt;object    |
|17      |@      | -       |7*[3-7]      | 完全失敗 or 進行=&gt;tag  |


構文的な正規化により、ユニフィケーションの左側（プロファイルの右側）では、∪を項の一番外側に移動できることもある。具体的には、Caty式にeachが含まれてなければ、∪を一番外まで移動できる。

∪を外に出せることはおおむね次のようにして分かる： never, any, LIT = {スカラーリテラルの全体}, SCA = {integer, number, string, boolean}, Var = {変数の全体} として、これらをベースにして、次の項構成子（コンストラクタ）によって、帰納的に項を定義する。

+ [-, ..., -*] （配列の構成）
+ {α&lt;sub&gt;1&lt;/sub&gt;:-, ..., *:-}　（オブジェクトの構成）
+ @α - （タギング）
+ -? （オプショナル）
+ -∪- （合併／ジョイン）

次の公式が示せる。

+ [A∪B, ..., X*] = [A, ..., X*]∪[B, ..., X*]
+ {α&lt;sub&gt;1&lt;/sub&gt;:A∪B, ..., *:X} = {α&lt;sub&gt;1&lt;/sub&gt;:A, ..., *:X} ∪ {α&lt;sub&gt;1&lt;/sub&gt;:B, ..., *:X}
+ @α (A∪B) = (@α A) ∪ (@α B)
+ (A∪B)? = A?∪B?

ただし、eachが入ると、(A∪B)* = A*∪B* とはならないのでうまくいかない。次は&lt;em&gt;成立しない&lt;/em&gt;。

+ {α&lt;sub&gt;1&lt;/sub&gt;:A, ..., *:(X∪Y)} = {α&lt;sub&gt;1&lt;/sub&gt;:A, ..., *:X} ∪ {α&lt;sub&gt;1&lt;/sub&gt;:B, ..., *:Y}
+ [A, ..., (X∪Y)*] = [A, ..., X*]∪[A, ..., Y*]

また、次に事実にも注意する必要がある。

- (A∪B)? = A?∪B = A∪B? = A?∪B?

これを使うと、∪を外に出すか、?を外に出すかを選べる。結論を言うと、?を外に出さないと、後の処理がうまくいかない。

*1263130616*[型検査][caty]型解析：ユニフィケーションの進行と成功／完全失敗

証明ターゲット S⊆T が完全失敗とは、S∩T = never が証明できてしまうこと。以下、S∩T = never を、S⊥T を書くことにする。

- S⊆T が成功 ⇔ S⊆T が成立（健全性より）
- S⊆T が完全失敗 ⇔ S⊥T が成立
- S⊆T が条件付きで成功 ⇔ S⊆T は成立しない（その意味では失敗）が、S⊥T ではない。

トップダウン・ユニフィケーションのとある過程（実行の途中）で成功／完全失敗したとき、その成功／完全失敗が、より上位に伝搬していく状況は以下のとおりである。

+ joinのすべての成分で成功すれば、そのjoinは成功。joinのすべての成分で完全失敗すれば、そのjoinは完全失敗。その他は成功でも完全失敗でもない。
+ interの進行先で成功しても完全失敗しても、inter全体は成功も完全失敗もしない。なぜなら、interは必ず変数を含むから。
+ b-optの進行先で成功すれば成功。b-optの進行先で完全失敗してもb-optは完全失敗しない。条件 not_exist が残る。
+ r-optの進行先で成功すれば成功。r-optの進行先で完全失敗すればr-optは完全失敗。
+ l-optの進行先で成功しても成功ではない。l-optの進行先で完全失敗すればr-optは完全失敗。
+ xunionの進行先で成功すれば成功。xunionの進行先で完全失敗すれば完全失敗。
+ arrayのすべての進行先で成功すれば成功。arrayの進行先のひとつで完全失敗すればarrayが完全失敗。
+ objectのすべての進行先で成功すれば成功。objectの進行先のひとつで完全失敗すればobjectが完全失敗。
+ tagの進行先で成功すれば成功。tagの進行先で完全失敗すればtagが完全失敗。

完全失敗に注目すると：

+ joinのすべての成分で完全失敗すれば、そのjoinは完全失敗。ALL条件
+ （interは完全失敗しない。）
+ （b-optは完全失敗しない。）
+ r-optの進行先で完全失敗すればr-optは完全失敗。
+ l-optの進行先で完全失敗すればr-optは完全失敗。
+ xunionの進行先で完全失敗すれば完全失敗。
+ arrayの進行先のひとつで完全失敗すればarrayが完全失敗。SOME条件
+ objectの進行先のひとつで完全失敗すればobjectが完全失敗。SOME条件
+ tagの進行先で完全失敗すればtagが完全失敗。

join(ALL), r-opt, l-opt, xunion, array(SOME), object(SOME), tagの7つのケースで、ボトムアップに完全失敗の可能性がある。

</body>
</day>
<day date="1910-01-11" title="">
<body>
*1262658439*[型検査][caty]型解析：型ユニフィケーション in Erlang 暫定

場合分けを17ステップに集約して、Erlangにしてみた。色々と問題もあるが、まーとりあえず動く。このエントリーに張り付けておく。

&gt;|erlang|
%% -*- coding: utf-8 -*-
%% unify.erl

-module(unify).
-compile(export_all).

%-define(DBG, 1).

-ifdef(DBG).
-define(P(F, A), io:format(F, A)).
-else.
-define(P(F, A), ok).
-endif.

%% A* は、便宜上 {star, {opt, A}} となっている。


%% @doc クリーネスターで終わる配列型の長さを増やして正規化。
extend_var_array(Len, List) when length(List) =&lt; Len -&gt;
    Last = {star, Item} = lists:last(List),
    ?P(&quot;extend_var_array~n* Item=~w~n&quot;, [Item]),
    lists:sublist(List, length(List) -1) ++ 
	lists:duplicate(Len - length(List), Item) ++
	[Last].

%% @doc 固定された配列＝タプル型の長さを増やして正規化。長さは必ず増えることになる。
extend_fixed_array(Len, List) when length(List) &lt; Len -&gt;
    List ++ 
	lists:duplicate(Len - length(List) - 1, {opt, never}) ++
	[{star, {opt, never}}].

%% @doc 配列型の長さを増やして正規化
extend_array(Len, List) -&gt;
    case is_stared(List) of
	true -&gt;
	    extend_var_array(Len, List);
	false -&gt;
	    extend_fixed_array(Len, List)
    end.

%% @doc 配列の最後がクリーネスターかどうか
is_stared([]) -&gt;
    false;
is_stared(List) -&gt;
    Last = lists:last(List),
    case Last of
	{star, _} -&gt;
	    true;
	_ -&gt;
	    false
    end.
%% @doc is_stared/1 と同じだが、trueなら0、falseなら1を返す
stared_offset(List) -&gt;
    case is_stared(List) of
	true  -&gt; 0;
	false -&gt; 1
    end.

%% 使ってない
get_array_default([]) -&gt;
    {opt, never};
get_array_default(List) -&gt;
    Last = lists:last(List),
    case Last of
	{star, Val} -&gt;
	    Val;
	_ -&gt;
	    {opt, never}
    end.

get_object_default(Proplist) -&gt;
  case proplists:get_value(star, Proplist) of
      undefined -&gt;
	  {opt, never};
      Val -&gt;
	  Val
  end.

extend_object(KeysList, Proplist) -&gt;
    DefaultValue = get_object_default(Proplist),
    lists:map(
      fun(K) -&gt;
	      case proplists:get_value(K, Proplist) of
		  undefined -&gt;
		      {K, DefaultValue};
		  Val -&gt;
		      {K, Val}
	      end
      end,
      KeysList).

%% 必ずstarを含めて返す（必要なら追加する）、結果はソート済み
object_keys(Proplist) -&gt;
    PL = 
	case proplists:get_value(star, Proplist) of
	    undefined -&gt; [{star, {opt, never}} |Proplist];
	    _ -&gt; Proplist
	end,
    X = lists:sort(proplists:get_keys(PL)), 
    X.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  ユニフィケーション
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unify/4 の第1引数はロケーションパス、第4引数には結果が累積される。

unify(S, T) -&gt; unify([], S, T, []).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              ユニフィケーションの場合分け 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% join
unify(Loc, {join, List}, T, AccRes) -&gt; %// 10*[1-11] 
    NewAccRes = [{Loc, {gothru, left_join}} |AccRes],
    unify_join(Loc, List, T, NewAccRes);

%% never を含む場合 
unify(Loc, never, T, AccRes) -&gt; %// 1*[1-11] 
  [{Loc, {true, left_never}} |AccRes];
unify(Loc, S, never, AccRes) -&gt; %// [2-9]*1
  [{Loc, {false, right_never}} |AccRes];

%% 右側がインターセクション型のとき 
%% 注意：左側にインターセクション型は出現しない、これでオシマイ
unify(Loc, S, {inter, Var, W}, AccRes) -&gt; %// [2-9]*10
    NewAccRes = [{Loc, {incl, S, Var}} | AccRes],
    unify(Loc, S, W, NewAccRes);

%% 両側がオプショナル型のとき
unify(Loc, {opt, V}, {opt, W}, AccRes) -&gt; %// 9*8
    NewAccRes = [{Loc, {gothru, both_opt}} | AccRes],
    unify(Loc, V, W, NewAccRes);

%% 右側だけがオプショナル型のとき 
unify(Loc, S, {opt, W}, AccRes) -&gt; %// [2-8]*8
    NewAccRes = [{Loc, {gothru, right_opt}} | AccRes],
    unify(Loc, S, W, NewAccRes);
    
%% 左側だけがオプショナル型のとき
unify(Loc, {opt, V}, T, AccRes) -&gt; % // 9*8
    NewAccRes = [{Loc, {exists, V}} | AccRes],
    unify(Loc, V, T, NewAccRes);

%% any を含むとき
unify(Loc, _S, any, AccRes) -&gt; %// [2-8]*2
    [{Loc, {true, right_any}} | AccRes];
unify(Loc, any, S, AccRes) -&gt; %// 2*[3-7,9,11]
  [{Loc, {incl, any, S}} |AccRes];

%% 変数を含むとき
unify(Loc, S, Var = {var, Y}, AccRes) -&gt; %// [3-8]*11
    [{Loc, {incl, S, Var}} | AccRes];
unify(Loc, Var = {var, X}, T, AccRes) -&gt; %// 8*[3-7,9]
    [{Loc, {incl, Var, T}} | AccRes];

%% a. 右側が排他的ユニオン型のとき
unify(Loc, T, {xunion, List}, AccRes) -&gt; %// [3-7]*9
    NewAccRes = [{Loc, {gothru, right_xunion}}|AccRes],
    unify_with_xunion(Loc, T, List, NewAccRes);

%%%% ここからは左側の型で場合分け 

%% 3.1. is_number(S)
unify(Loc, S, T, AccRes) when is_number(S) -&gt; %// 3.1*[3-7]
    ?P(&quot;unify/4 3.1: Loc=~w, S=~w, T=~w, A=~w~n&quot;, [Loc, S, T, AccRes]),
    unify_number(Loc, S, T, AccRes);

%% 3.2. is_list(S) listはErlangの文字列（ただし基本ラテン文字に限定）
unify(Loc, S, T, AccRes) when is_list(S) -&gt; %// 3.2*[3-7]
    unify_string(Loc, S, T, AccRes);

%% 3.3. S = true, false, null %// 3.3*[3-7]
unify(Loc, true, true, AccRes) -&gt; 
  [{Loc, {true, eq_true}} |AccRes];
unify(Loc, true, boolean, AccRes) -&gt;
  [{Loc, {true, true_is_boolean}} |AccRes];
unify(Loc, true, S, AccRes) -&gt;
  [{Loc, {false, left_true_but, S}} |AccRes];

unify(Loc, false, false, AccRes) -&gt;
  [{Loc, {true, eq_false}} |AccRes];
unify(Loc, false, boolean, AccRes) -&gt;
  [{Loc, {true, false_is_boolean}} |AccRes];
unify(Loc, false, S, AccRes) -&gt;
  [{Loc, {false, left_false_but, S}} |AccRes];

unify(Loc, null, null, AccRes) -&gt;
  [{Loc, {true, eq_null}} |AccRes];
unify(Loc, null, S, AccRes) -&gt;
  [{Loc, {false, left_null_but, S}} |AccRes];

%% 4. スカラー型 %// 4*[3-7]
%% integer
unify(Loc, integer, integer, AccRes) -&gt;
  [{Loc, {true, eq_integer}} |AccRes];
unify(Loc, integer, number, AccRes) -&gt;
  [{Loc, {true, integer_is_number}} |AccRes];
unify(Loc, integer, S, AccRes) -&gt;
  [{Loc, {false, left_integer_but, S}} |AccRes];
%% number
unify(Loc, number, number, AccRes) -&gt;
  [{Loc, {true, eq_number}} |AccRes];
unify(Loc, number, S, AccRes) -&gt;
  [{Loc, {false, left_number_but, S}} |AccRes];
%% string
unify(Loc, string, string, AccRes) -&gt;
  [{Loc, {true, eq_string}} |AccRes];
unify(Loc, string, S, AccRes) -&gt;
  [{Loc, {false, left_string_but, S}} |AccRes];
%% boolean
unify(Loc, boolean, boolean, AccRes) -&gt;
  [{Loc, {true, eq_boolean}} |AccRes];
unify(Loc, boolean, S, AccRes) -&gt;
  [{Loc, {false, left_boolean_but, S}} |AccRes];

%% 5. 配列型 %// 5*[3-7]
unify(Loc, {array, ListV}, {array, ListW}, AccRes) -&gt;
    Len1 = length(ListV) + stared_offset(ListV),
    Len2 = length(ListW) + stared_offset(ListW),
    Len = lists:max([Len1, Len2]),
    ?P(&quot;unify 5. Len1=~w, Len2=~w, Len=~w~n&quot;, [Len1, Len2, Len]),

    List1 = extend_array(Len, ListV),
    List2 = extend_array(Len, ListW),
    NewAccRes = [{Loc, {gothru, both_array}} |AccRes],
    unify_array(Loc, List1, List2, NewAccRes);

%% 6. オブジェクト型 %// 6*[3-7]
unify(Loc, {object, ProplistV}, {object, ProplistW}, AccRes) -&gt;
    Key1 = object_keys(ProplistV),
    Key2 = object_keys(ProplistW),
    Key = lists:umerge(Key1, Key2), % lists:umerge/2 はソート済みリストにしか機能しない

    Proplist1 = extend_object(Key, ProplistV),
    Proplist2 = extend_object(Key, ProplistW),
    NewAccRes = [{Loc, {gothru, both_object}} |AccRes],
    unify_object(Loc, Proplist1, Proplist2, NewAccRes);

%% 7. （明示的）タグ付き型 %// 
unify(Loc, {tag, Tag, V}, {tag, Tag, W}, AccRes) -&gt;
    NewAccRes = [{Loc, {gothru, both_tag}} |AccRes],
    unify([{tag, Tag}|Loc], V, W, NewAccRes);
unify(Loc, {tag, Tag1, V}, {tag, Tag2, W}, AccRes) -&gt;
    [{Loc, {false, tag_not_eq, Tag2}} |AccRes];
unify(Loc, {tag, Tag, V}, S, AccRes) -&gt;    
    [{Loc, {false, left_tag_but, S}} |AccRes];

%% 番外：スター型 {star, Type}
unify(Loc, {star, V}, {star, W}, AccRes) -&gt;
    NewAccRes = [{Loc, {gothru, both_star}} |AccRes],
    unify(Loc, V, W, NewAccRes);
unify(Loc, {star, V}, W, AccRes) -&gt;
    [{Loc, {false, left_star_but, W}} |AccRes];

%% 他はあり得ないはず
unify(Loc, S, T, AccRes) -&gt;
  [{Loc, {something_wrong, S, T}} |AccRes].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     ユニフィケーションの下請け関数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

unify_join(Loc, List, T, AccRes)-&gt;
    {_N, Res} = lists:foldl(
		  fun(S, {N, A}) -&gt;
			  {N+1, unify([{join, N}|Loc], S, T, A)}
		  end,
		  {1, AccRes},
		  List),
    Res.
%%
%% 3.1 is_number(S)
%% 左が数値リテラルの場合

%% 3.1 T = M  右も数値リテラル %// 3.1*[3-7]
unify_number(Loc, Num, M, AccRes) when Num == M -&gt;
   [{Loc, {true, eq_number_literal}} |AccRes];
%% 3.1 T = integer 右はスカラー型
unify_number(Loc, Num, integer, AccRes) when is_integer(Num) -&gt;
   [{Loc, {true, literal_is_integer}} |AccRes];
%% 3.1 T = number 右はスカラー型
unify_number(Loc, Num, number, AccRes) -&gt;
   [{Loc, {true, literal_is_number}} |AccRes];
%% 3.1 その他
unify_number(Loc, _Num, S, AccRes) -&gt;
   [{Loc, {false, left_number_literal_but, S}} |AccRes].

%%
%% 3.2 is_list(S)
%% 左が文字列リテラルの場合 %// 3.2*[3-7]

%% 3.2 T = Str 
unify_string(Loc, Str, X, AccRes) when is_list(X), Str == X -&gt;
   [{Loc, {true, eq_string_literal}} |AccRes];

%% 3.2 T = string
unify_string(Loc, Str, string, AccRes) -&gt;
   [{Loc, {true, string_literal_is_string}} |AccRes];

%% その他
unify_string(Loc, Str, S, AccRes) -&gt;
   [{Loc, {false, left_string_literal_but, S}} |AccRes].


%%
%% 5. 左が配列型の場合
%% 
unify_array(Loc, List1, List2, AccRes) -&gt;
    ?P(&quot;unify_array~n* List1=~w,~n* List2=~w~n&quot;, [List1, List2]),
    Zipped = lists:zip(List1, List2),
    {_N, Result} = lists:foldl(fun({S, T}, A) -&gt; unify_item_pair(Loc, S, T, A) end, {0, AccRes}, Zipped),
    Result.

unify_item_pair(Loc, S, T, {N, Acc}) -&gt;
    ?P(&quot;unify_item_pair: S=~w, T=~w, N=~w, Acc=~w~n&quot;, [S, T, N, Acc]),
    Result = unify([N|Loc], S, T, Acc),
    {N + 1, Result}.

%%
%% 6. 左がオブジェクト型の場合
%%
unify_object(Loc, Proplist1, Proplist2, AccRes) -&gt;
    Zipped = lists:zip(Proplist1, Proplist2),
    lists:foldl(fun({K_S, K_T}, A) -&gt; unify_prop_pair(Loc, K_S, K_T, A) end, AccRes, Zipped).

unify_prop_pair(Loc, {K, S}, {K, T}, Acc) -&gt;
    unify([K|Loc], S, T, Acc).

%% 下請け：右側が排他的ユニオンのときの処理
%% タグの付与はこのなかでやるので事前にやっておく必要はない。
unify_with_xunion(Loc, S, List, AccRes) -&gt; %// [3-7]*9
    TaggedS = to_tagged(S),
    TaggedList = list_to_tagged(List),
    R = lists:foldl(
	  fun(T, FoldAcc) -&gt;
		  match_and_unify(Loc, TaggedS, T, AccRes, FoldAcc)
	  end,
	  false,
	  TaggedList),
    case R of
	false -&gt;
      	    [{Loc, {false, xunion_not_match}}|AccRes];
	R -&gt;
	    R
    end.

match_and_unify(Loc, {tag, Tag1, V}, {tag, Tag2, W}, AccRes, FoldAcc) -&gt;
    R = if 
	    Tag1 == Tag2 -&gt;
		?P(&quot;match_and_unify: ~w, ~w~n&quot;, [V, W]),
		unify(Loc, V, W, AccRes);
	    true -&gt;
		false
	end,
    case R of
	false -&gt;
	    FoldAcc;
	R -&gt;
	    R
    end.

%% 排他的ユニオンの成分（選択肢）に any と neverは入れない。
%% neverはなくても同じだし、anyは排他的になるはずがない。
%% ユニオンの入れ子は結合法則で前もって取り除いて、フラットにしておく。

%% 数値と文字列
to_tagged(N) when is_number(N) -&gt;
    {tag, number, N};
to_tagged(S) when is_list(S) -&gt;
    {tag, string, S};
%% 予約定数
to_tagged(true)  -&gt;
    {tag, boolean, true};
to_tagged(false)  -&gt;
    {tag, boolean, false};
to_tagged(null)  -&gt;
    {tag, null, null};
%% スカラー型
to_tagged(integer) -&gt;
    {tag, number, integer};
to_tagged(number) -&gt;
    {tag, number, number};
to_tagged(string) -&gt;
    {tag, string, string};
to_tagged(boolean) -&gt;
    {tag, boolean, boolean};
%% 配列型
to_tagged({array, List}) -&gt;
    {tag, array, {array, List}};
%% オブジェクト型
to_tagged({object, Proplist}) -&gt;
    {tag, object, {object, Proplist}};
%% タグ付き型
to_tagged({tag, _Tag, _S} = T) -&gt;
    T.

list_to_tagged(List) -&gt;
    lists:map(fun to_tagged/1, List).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              実験と観察のツール
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

json_path(List) -&gt;
    lists:foldr(
      fun(Comp, A) -&gt; 
	     case Comp of
		 {tag, Tag} -&gt; lists:concat([A, &quot;@&quot;, Tag]);
		 {join, Num} -&gt; lists:concat([A, &quot;(&quot;, Num, &quot;)&quot;]);
		 Other -&gt; lists:concat([A, &quot;.&quot;, Other]) 
	     end
      end,
      [36], % 36 = dollar
      List).

print_result(Res) -&gt;
    S = lists:flatten(str_print_result(Res)),
    io:fwrite(&quot;~s&quot;, [S]).

str_print_result(Res) -&gt;
    lists:map(
      fun str_print_proposition/1,
      lists:reverse(Res)).

str_print_proposition({Loc, {true, Reason}}) -&gt;
    io_lib:format(&quot;~s : TRUE because ~s~n&quot;, [json_path(Loc), Reason]);

str_print_proposition({Loc, {false, Reason}}) -&gt;
    io_lib:format(&quot;~s : FALSE because ~s~n&quot;, [json_path(Loc), Reason]);

str_print_proposition({Loc, {false, Reason, Right}}) -&gt;
    io_lib:format(&quot;~s : FALSE because ~s (~p)~n&quot;, [json_path(Loc), Reason, Right]);

str_print_proposition({Loc, {incl, Left, Right}}) -&gt;
    io_lib:format(&quot;~s : ~p &lt;_ ~p~n&quot;, [json_path(Loc), Left, Right]);

str_print_proposition({Loc, {exists, V}} ) -&gt;
    io_lib:format(&quot;~s : exists (~p)~n&quot;, [json_path(Loc), V]);

str_print_proposition({Loc, {gothru, Kind}}) -&gt;
    io_lib:format(&quot;~s : ~s ==&gt;~n&quot;, [json_path(Loc), Kind]);

str_print_proposition({Loc, {something_wrong, S, T}}) -&gt;
    io_lib:format(&quot;~s : Error! ~p, ~p~n&quot;, [json_path(Loc), S, T]).

do_unify(S, T) -&gt;
    io:format(&quot;~n*** UNIFY(~p, ~p) ***~n&quot;, [S, T]),
    print_result(unify(S, T)).

%% @doc ファイルからユニファイすべき組のリストを読んで、全部ユニファイする。
test_all(Filename) -&gt;
    {ok, List} = file:consult(Filename),
    lists:foreach(
      fun ({Left, Right}) -&gt; do_unify(Left, Right) end,
      List).

file_test(Infile, Outfile) -&gt;
    {ok, List} = file:consult(Infile),
    OutList = lists:map(
		fun ({Left, Right}) -&gt; file_do_unify(Left, Right) end,
		List),
    file:write_file(Outfile, OutList).

file_do_unify(S, T) -&gt;
    io_lib:format(&quot;~n*** UNIFY(~p, ~p) ***~n&quot;, [S, T]) ++
	str_print_result(unify(S, T)).

||&lt;

</body>
</day>
<day date="1910-01-15" title="">
<body>
*1263541716*[型検査][caty]型解析：動的なPCL (Path Check Logic)

型演算'&amp;lt;&amp;lt;'を扱うためには、推論も拡張しなくてはならないが、実行時の検査条件を記述するPCL(path check logic)の変更のほうがむしろ大きい。

今までのPCLは、pをパス、'_'を無名変数だとして、次の3つの形の式を原子論理式にすれば十分だった。

+ (p) exists(_)  …… 値が存在する
+ (p) _ = スカラー定数  …… スカラー値が等しい
+ (p) _ ∈ スカラー型  …… 値の型が特定のスカラー型である

'&amp;lt;&amp;lt;'の検査にはこれだけでは不十分で、Nを名前の無限集合だとして、

- (p) ∀γ∈N.[(_.γ)∈型]

が必要になる。無限個の名前と無限個の型がでてくるが、型は、オブジェクト型（の型表現）Tを使って T.γ と書ける。つまり、

- (p) ∀γ∈N.[(_.γ)∈T.γ]

名前の無限集合Nは、通常「有限個の名前を除くすべての名前」として与えられる。検査実行時には、具体的なインスタンスが与えられるので、Nのなかの有限個の検査が実行される。だが、この有限個が検査のたびに毎回動的に変わる。この意味で、動的PCLと呼ぶことにする。動的PCLは、効率の観点からはうれしくない。

*1263541717*[型検査][caty]型解析：用語 型マップ

見た目はオブジェクト型（の型項、型表現）とまったく区別できないが、名前と型の対応を型マップと呼ぶことにする。'&amp;lt;&amp;lt;'の右側は型マップ。型マップがオブジェクト型と違う点は：

- ワイルドカードは現れない。
- 出現しない名前（プロパティ名）に対する型は単に未定義、ほんとに未定義。never?やany?で補完して解釈することは一切しない。

*1263541718*[型検査][caty]左に型更新演算子が含まれるとき

xは変数、Kは変数を含まない型マップ、Tは任意の型（型項、型表現）だとして、証明ターゲット x&amp;lt;&amp;lt;K ⊆ T を考える。

x&amp;lt;&amp;lt;K は、暗黙に x も x&amp;lt;&amp;lt;K もオブジェクト型（明示的タグもなく、確定（非オプショナル）型）であることを含意しているので、Tがオブジェクト型でないときは証明ターゲット x&amp;lt;&amp;lt;K ⊆ T は成立しない。

したがって、http://d.hatena.ne.jp/m-hiyama-memo/19100110/1263114915 の右側分類で可能性があるのは：

+ Tがオブジェクト型
+ Tがオプショナル型
+ Tが排他的ユニオン型
+ Tがインターセクション型
+ Tが変数

このなかで、オプショナル型、排他的ユニオン型、インターセクション型は分解還元処理を続けると、Tがオブジェクト型または変数のケースに帰着できる。Tが変数yのときは、証明ターゲットは x&amp;lt;&amp;lt;K ⊆ y で、推論は終り。

残るは、Tがオブジェクト型のとき。

&lt;hr&gt;
話を簡単にするために、K = {α:U, β:V} とする。まず、

+ x.α⊆T.α
+ x.β⊆T.β

だが、これは

+ U⊆T.α
+ V⊆T.β

Tはオブジェクト型なので、T.α、T.βはwell-defined、UとVも決まった型だから、U⊆T.α, V⊆T.β は新しい証明ターゲットとなり、従来と同様な推論を継続（進行）できる。

γをαともβとも違う名前だとして、x.γ⊆T.γ は、T.γ がわかっても、これ以上はどうにもならない。ユニフィケーションの出力としては、α、β以外のすべてのγに対する x.γ⊆T.γ を出力する。Tに型変数が含まれるときは、T内の型が他のユニフィケーションの効果により具体化される可能性がある。最終的に残った (_.γ)∈T.γ をすべて実行時検査条件に加えるしかない。

*1263541719*[型検査][caty]右に型更新演算子が含まれるとき

証明ターゲット S ⊆ y&amp;lt;&amp;lt;K を考える。

y&amp;lt;&amp;lt;K は、暗黙に y も y&amp;lt;&amp;lt;K もオブジェクト型であることを含意しているので、Sがオブジェクト型でないときは証明ターゲットは成立しない。したがって、http://d.hatena.ne.jp/m-hiyama-memo/19100110/1263114915 の左側分類で可能性があるのは：

+ Sがオブジェクト型
+ Sが変数
+ Sがジョイン型

Sがジョイン型は分解還元処理により、他の2つの場合に帰着する。Sが変数のとき、証明ターゲットは x ⊆ y&amp;lt;&amp;lt;K 。これは、Kをopen-constraintsで解釈した型を K↑ として、x ⊆ (K↑) となり、今までの（&amp;lt;&amp;lt;なしの）推論に帰着できる。

&lt;hr&gt;
K = {α:U, β:V} とする。まず、

+ S.α⊆ y.α
+ S.β⊆ y.β

はこのまま出力する。他のユニフィケーションとSIL推論によりyは具体化または消去される可能性がある。γをαともβとも違う名前だとして、S.γ⊆y.γ も同様な扱いになる。yが具体化されないままだと、これらの条件は実行時検査条件としては消去される。


</body>
</day>
<day date="1995-08-21" title="">
<body>
以下の記事は、次の3つの記事のコピーです。

- 「micro* (1): microな考え方／やり方」&lt;br&gt; http://d.hatena.ne.jp/m-hiyama/20050819/1124418843 
- 「micro* (2)：microdocuments」&lt;br&gt; http://d.hatena.ne.jp/m-hiyama/20050820/1124512522
- 「micro* (3)：microapplications」&lt;br&gt; http://d.hatena.ne.jp/m-hiyama/20050821/1124658799 

*1124418843*[雑記／備忘]micro* (1): microな考え方／やり方

&lt;em&gt;本編「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20050819/1124418843&quot;&gt;micro* (1): microな考え方／やり方&lt;/a&gt;」のコピー。&lt;/em&gt;

&lt;a href=&quot;http://microformats.org/&quot;&gt;microformats&lt;/a&gt;が、どうして&quot;micro&quot;という&lt;em&gt;言葉&lt;/em&gt;を選んだのか、どうも腑に落ちない感じがしました。（だって、&lt;strong&gt;Microsoft&lt;/strong&gt;だってmicroだし。）

&lt;a href=&quot;http://www-kasm.nii.ac.jp/mt/archives/000063.html&quot;&gt;武田の近況報告「Microformats (とSemantic Web）」&lt;/a&gt;と&lt;a href=&quot;http://aws.typepad.com/aws_jp/2005/07/microformats_.html2&quot;&gt;Amazon Web サービス ブログ「Microformats 運動」&lt;/a&gt;を引用してみます。なお、ブラケット内は僕が挿入したものです。

&gt;&gt;
そもそも[なぜ]Microなのかというと，既存の大量な詳細なドキュメントで規定される人間が読むことができないようなフォーマット(&quot;megaformat!&quot;)に対して，format自身も小さいし，簡単に理解できるようなフォーマットだから，ということでしょう．
&lt;&lt;

&gt;&gt;
Microformats運動は、必ずしも新しい形式を作るのではなく、現在動いている既存の方法にほんの少し手を加えて、多くの人が共通に悩んでいる問題にシンプルな解を提供し、かつそれによって今動いている仕組みには最小限の影響しか与えないことを目指しています。
&lt;&lt;

大げさ大規模ではない、少ない手間でそれなりの効果を得る、変更を最小化する、というようなところがマイクロ（極小、微少／微小）なんでしょうかね。

で、言葉自体の詮索＜せんさく＞はやめて、microという形容詞を「microformatsの意味におけるmicro」だと解釈すると、その背後には、なにかmicro主義とか、microの哲学とでも呼ぶような発想があるような気がします。もっとも、「主義」とか「哲学」という大仰＜おおぎょう＞な言葉はmicroじゃないので、“microな考え方／やり方”と呼んでおきましょう。

「Microformats (とSemantic Web）」から再び引用します：
&gt;&gt;
推進しているご当人のよると，microformatsの基本理念とは
+ 特定の問題を解け
+ できるだけ簡単に...発展的な改良
+ 人が先,機械は後... 表示可能で処理可能，現状のやり方に合わせろ
+ いまあるスタンダードを使いまわせ... semantic (X)HTML, RFC
+ モジュラリティと埋め込み可能性
だそうです
&lt;&lt;

これは、ソフトウェアツールズ、したがって&lt;a href=2http://www.chimaira.org/docs/PipeFilterEpisode.htm&quot;&gt;パイプ＆フィルター&lt;/a&gt;に通じるものを感じます。ソフトウェアツールズ的発想は、新しいプログラムはできるだけ書かずに、ひとつのことを上手にこなす小さな既存ツールを組み合わせろ、ってことですから。

実際の個別format仕様（hCard, hReviewなど）を見ると、&lt;em&gt;ショボイ&lt;/em&gt;感じがするのですが、そのショボサがmicroさであり、メリットにつながっているようです。つまり、誰でも短時間で理解できて、今すぐそれで何かをできる、ということ。

僕は、基礎から作り直すアプローチも嫌いではない（いや、好きかな）けど、基盤整備に時間がかかって「いつになったら、やりたいことができるんだよー」という&lt;em&gt;イライラ感&lt;/em&gt;も理解できるし、自分もイライラしたりしますから、microな（あるいはminiな）アプローチの必要性もけっこう切実に感じます。

僕自身のバイアスを入れて、microな考え方／やり方をまとめれば、まずは、&lt;strong&gt;単純&lt;/strong&gt;（simple）、&lt;strong&gt;軽量&lt;/strong&gt;（lightweight）、&lt;strong&gt;枯れた既存技術の（新しい）組み合わせ&lt;/strong&gt;（a (new) combination of mature technologies）であること；この特徴は分かりやすいでしょ。

それと、&lt;strong&gt;非制限的&lt;/strong&gt;（nonrestrictive）って条件が入るかな；非制限的とは、そのアーキテクチャやフレームワーク全体の使用を強要しないってことです。all or nothingみたいなことではなくて、利用したい人は一部分だけを選んで使ってもよいし、それでもちゃんと役に立つ、と。その技術や手法の体系内にロックインしないということです。

microな方法は、短期的な解決策である可能性が高いから、ロックインしたりしたらダメです。そして、現状うまくいっているものにインパクトを与えてもまずい。今の不便さを解消して、何かをできるようにする（enabling）けど、囲い込み（encompassing）はしないようなやり方。

このような考え方／やり方をmicroなんだと捉えれば、formats以外にも適用が可能なんじゃないでしょうか。それで、ワイルドカードのつもりのスターを付けて&lt;strong&gt;micro*&lt;/strong&gt;って見出しを付けたのです。… 続くかもしれない。

*1124512522*[雑記／備忘]micro* (2)：microdocuments

&lt;em&gt;本編「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20050820/1124512522&quot;&gt;micro* (2)：microdocuments&lt;/a&gt;」のコピー。&lt;/em&gt;

&quot;&lt;strong&gt;micro&lt;/strong&gt;&quot;という形容詞に、microformatsの背後にある理念が込められている、という（ひょっとすると僕の&lt;em&gt;勝手な&lt;/em&gt;）前提に基づき、その理念に沿ったナニモノカの総称として&lt;strong&gt;micro*&lt;/strong&gt;を提案しました。それが&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050819/1124418843&quot;&gt;前回&lt;/a&gt;。

さてと、micro*のワイルドカード部にdocumentsを代入してmicrodocumentsって概念をひねり出しましょう。最初に&lt;em&gt;注意&lt;/em&gt;：実は、&quot;micro-document architecture&quot;って言葉は、OmniMarkという会社（今はStiloって会社になっている）が随分と昔（10年くらいたつだろうか?）から提唱していた方式の名前です。よって、microdocumentsって言葉の使用は&lt;em&gt;問題あり&lt;/em&gt;かもしれない。が、とりあえず僕が私的に使うだけならいいでしょう、たぶん。

&lt;h4&gt;●microdocumentの概念&lt;/h4&gt;

&lt;a href=&quot;http://microformats.org/&quot;&gt;microformats&lt;/a&gt;のなかで、hCard, hCalendar, hReviewなどは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050722/1122023064&quot;&gt;多重マークアップ・ベース&lt;/a&gt;のボキャブラリと考えられます。これらのボキャブラリでマークアップされた(X)HTML文書の一部分を&lt;strong&gt;マイクロ文書（microdocument）&lt;/strong&gt;と呼びましょう。つまり、記述言語がmicroformats（のなかの特定フォーマット）で、その記述言語で書かれた文書内文書（documents within a document）がマイクロ文書です。（後で、もう少し定義を拡張します。）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050819/1124418843&quot;&gt;前回&lt;/a&gt;、マイクロの意味は「単純、軽量、既存技術の組み合わせ、非制限的」と説明しましたが、マイクロ文書のマイクロは、辞書的な意味である「小規模、空間的に狭い、細粒度」などと解釈してもツジツマがあいます。

マイクロ文書は、構文的には完結した文書とはかぎらない、文書の一部分です。しかし、意味的には自立している情報担体＜じょうほうたんたい；information bearing oobject＞です。たとえば、hCardフォーマットで記述された部分は、そこだけ切り取っても名刺情報として意味を持ちます。

&lt;h4&gt;●XML複合文書との違い&lt;/h4&gt;

マイクロ文書は、一般的なXML複合文書の構成素（成分文書）とは違う概念です。例えば、vCard（RFC2426）情報を次のようにXMLエンコードするほうが正統派ですが、それはマイクロな解決策ではありません。

&lt;pre class=&quot;code&quot;&gt;
&amp;lt;vc:vCard xmlns:vc=&quot;Namespace URI for XML-encoded vCard&quot;&gt;
 ...
&amp;lt;/vc:vCard&gt;
&lt;/pre&gt;

僕は、「マイクロ」に、時間的にもマイクロであること、つまり短期的解決であること、もっと言えば「当座しのぎ」的な意味を含めています。その代わり、「今すぐ使える」、「既にあるものだけで間にあう」、「現状にインパクトを与えない」などのメリットがあります。

上のような正統派のXMLエンコーディングでは、ブラウザ表示に悪影響を与えますし、取り扱いには新しい技術を必要とするので、「マイクロじゃない」と判断するのです。

ここいらのことも含めて、もう一度マイクロ文書を定義すると：

+ 構文的には、(X)HTML文書の要素、または（単一要素とはかぎらない）フラグメントである。
+ 意味的には、そこだけで自立しており、そこだけを取り出して扱える。（ただし、もとの(X)HTML文書との関連が重要なこともある。）
+ Webブラウザーの表示に悪影響を与えない（brwoser-friendly）。
+ そのフォーマットを知っているアプリケーション（microdocument-aware applications/tools）により抽出したり操作したりできる。

&lt;h4&gt;●埋め込みと刷り込み&lt;/h4&gt;

マイクロ文書は、ホスティング環境である(X)HTML文書に寄生して運ばれます。これは、「埋め込まれている」と言ってもいいのですが、hCardなどはホスト文書への“&lt;em&gt;入り込み方&lt;/em&gt;”がMathMLなどの埋め込みとは異なります。次の例を見てください。

&lt;pre class=&quot;code&quot;&gt;
&amp;lt;div class=&quot;vcard&quot;&gt;
 &amp;lt;a class=&quot;url fn&quot; href=&quot;http&amp;#58;//www.chimaira.org/&quot;&gt;
  檜山正幸
 &amp;lt;/a&gt;
 &amp;lt;div class=&quot;org&quot;&gt;檜山正幸事務所&amp;lt;/div&gt;
&amp;lt;/div&gt;
&lt;/pre&gt;

class属性を意識しなければ（無視すれば）、これは単なるdiv要素に過ぎません。vCardとしての意味を与える情報は、class属性を通じて、あたかも“透かし”のように刷り込まれているのです。

しかし、すべてのマイクロ文書が刷り込み（imprint）方式で寄生しているわけではありません。例えば、はてなのAccount Auto-Discovery情報は埋め込まれています。あるいは、次のようなhead内のフラグメントもマイクロ文書と考えていいでしょう。

&lt;pre class=&quot;code&quot;&gt;
 &amp;lt;title&gt;マイクロ文書について&amp;lt;/title&gt;
 &amp;lt;meta name=&quot;DC.creator &quot; content=&quot;檜山正幸&quot; /&gt;
 &amp;lt;meta name=&quot;DC.date&quot; content=&quot;2005-08-20&quot; /&gt;
&lt;/pre&gt;

&lt;h4&gt;●まとめと注意&lt;/h4&gt;

マイクロ文書は、(X)HTMLへの寄生を意図した（いろいろな意味で）小さな情報単位です。本格的な複合文書とは少し違った方式で、単一文書へ多様な情報の埋め込み／刷り込みを可能とします。

何度か触れているように、マイクロなアプローチは、本格的で重い手法をあえて避けているので、長期的（時間的マクロ）な視点では問題点とリスクを抱えています。しかし、お手軽さと即効性が魅力です。

micro* の続きはたぶんある、けど、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050820/1124510629&quot;&gt;来週は休み&lt;/a&gt;。

*1124658799*[雑記／備忘]micro* (3)：microapplications

&lt;em&gt;本編「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20050821/1124658799&quot;&gt;micro* (3)：microapplications&lt;/a&gt;」のコピー。&lt;/em&gt;

出かける準備で早起きしました。あわただしいので中途半端な記述ですが、micro*シリーズその3（の断片）を投稿してから&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050820/1124510629&quot;&gt;出発します&lt;/a&gt;。

&lt;strong&gt;マイクロアプリケーション（microapplication）&lt;/strong&gt;とは、とりあえずは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050820/1124512522&quot;&gt;マイクロ文書&lt;/a&gt;を扱うプログラムだと定義できます。しかし、OS上で直接動くネイティブアプリケーションやサーバサイドWebアプリケーションではなくて、ブラウザー上（クライアントサイド）で動作するJavaScriptプログラムです。

マイクロアプリケーションのソフトウェアとしての特徴は：

- 実行環境：Webブラウザ
- 実装言語：JavaScript
- 画面表示：ブラウザのHTMLレンダリング機能を使う
- イベント：ブラウザが生成するイベントをJavaScriptのハンドラーで処理
- データ入出力：文書の一部をデータとみなすか、XMLHttpによるリモートIO

Ajaxにより再発見・再認識されたXMLHttpコンポネントは、マイクロアプリケーションに対して、ブラウザの&lt;strong&gt;外&lt;/strong&gt;とのIO手段を与えます。その他は、特に目新しいことはありませんが、マイクロアプリケーションは次のような意図を持っています。

+ マイクロ文書に対する対話的フロントエンドを提供する。したがって、広義の（microformats.orgで策定されたものにかぎらない）マイクロフォーマットに関係する。
+ お手軽さを失わない範囲で、再利用／共有可能性、相互運用性を意識する。
+ （上の項の一部だが）できるならば表示先が何であるか（bodyかdivか、windowかframeかiframeかなど）に独立な作りにする。
+ これらの目的のために、“あるコンベンション”に従う。

広義のマイクロフォーマットで記述されたマイクロ文書というデータに、マイクロアプリケーションが&lt;em&gt;対話的振る舞いを与える&lt;/em&gt;、という構図です。

問題は、「あるコンベンション」がどうあるべきか／どう決めるか、ですが、それを今後提案できればと思っています。いずれにしても、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050819/1124418843&quot;&gt;microな&lt;/a&gt;コンベンションですから、最小限の規則集であり、非制限的なものです。コンベンションに沿ったマイクロアプリケーションをサポートするフレームワークがあれば便利でしょうが、フレームワーク必須にすると制限的になってしまうので好ましくありません。

もっと詳しいことは、またいずれ。

</body>
</day>
<day date="1998-12-18" title="">
<body>
以下の記事は、次の2つの記事のコピーです。

- 「Back to XML」&lt;br&gt; http://d.hatena.ne.jp/m-hiyama/20081216/1229410746 
- 「Back to XML (2)」&lt;br&gt;http://d.hatena.ne.jp/m-hiyama/20081218/1229589029 

*1229410746*[雑記／備忘]Back to XML

&lt;em&gt;本編「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20081216/1229410746 &quot;&gt;Back to XML&lt;/a&gt;」のコピー。&lt;/em&gt;

一時期、ある狭い範囲内では「XMLの檜山さん」だったわけですが、ここんところ、XMLにはご無沙汰で、事実上何もしてない。個人的な事情もあるけれど、期待したほどには XML everywhere、everything in XML という状況にはならないし、XML技術が変に矮小化されたり、トンチンカンな使い方をされたり、不毛な議論があったりと、デスパレートな気分にもなりますわな。

じゃ、XMLにまったく興味を失ったかというと、それはないです。不本意に別れた昔の彼女に未練があるくらいの感情は残っています。あわよくば復縁したい、とね。そうは思っていても、行き違いや誤解や不運とかが重なってなかなか復縁できなかった、とそんな感じでしたね。

最近になって、XMLに戻れるかな、もう一度なんらかの形でコミットしようか、と思いはじめました。その事情を話す前に、XML技術がどう使えるか、どう使うべきかを述べておきます。ただし、合意された一般論を述べるわけではなく、僕個人のバイアスが強くかかった議論ですから、その点はご注意ください。

&lt;b&gt;内容：&lt;/b&gt;
+ 普遍的構文プラットフォームとしてのXML
+ 不定／複雑なデータを扱えるのか
+ 文字エンコーディングの問題
+ XMLはタグなのか
+ それはどこ？

&lt;h4&gt;●普遍的構文プラットフォームとしてのXML&lt;/h4&gt;

XMLを「データ構造をテキスト形式で表現するための構文」と考えると、代替手段はたくさんあります。JSONやYAML、WindowsのINI形式やJavaのproperties形式でも間に合うことも多いでしょう。LispのS式やErlangのタームだってなかなかの表現力です。みなさんのお好みのプログラミング言語のリテラル表現を考えてみてください； かなりの用途をカバーできるでしょ。

より簡単で、より書きやすく、より親しみやすいリテラル表現があるのに、XMLを使うメリットは何でしょうか？ 個別事例を考えている限りメリットなんてないです。すべてのデータが（控えめに言って多くのデータが）XMLで表現されたときに、大きな効果があると期待できるのです。

「一週間ほど保存しておきたい私だけのデータをどうするか」と、「100年先まで考えて、世界中のデータをどうすべきか」では論点が異なります。個別的ローカルな状況下では、カンマ区切り（CSV）をXMLに変換するなんてバカバカしいだけ。

「100年先まで考えて、世界中のデータをどうすべきか」への解がXMLだったわけですが、実効的な解となるには、データ表現構文のなかで独占的な地位を確立する必要があったのです。しかし現状では one-of-them に過ぎないし、近い将来に独占的な（唯一普遍的な）構文になる可能性も見えません。

&lt;h4&gt;●不定／複雑なデータを扱えるのか&lt;/h4&gt;

JSONやS式ではカバーできない用途もあるんだよ -- 確かにそのとおりです。本来の意味の“文書”のように、不定形で複雑な入れ子や繰り返しを含むデータは従来の（XML以外の）データ形式では扱いにくいものです。

こういう不定／複雑なデータを扱うときこそXMLの本領発揮。のはずですが、不定／複雑なデータはXMLでも扱えません。ここで「扱える」は「表現できる」（テキストにエンコードできる）と同意ではありません。「扱う」は、テキストエディタがプレーンテキストを扱い、ワープロがその固有文書データを扱うように「扱う」ってことです。XMLネイティブな編集系は、実装も普及も困難だという現実がそこにあります。

既存のワープロだって、XML形式で保存できるよ -- あれはですね、単なるアンロード形式としてXMLを使っているだけです。あるいは交換形式（interchange format）としての利用です。

交換形式こそXMLの本命的な用途だと思う人も多いようですが、僕は最初からそのての意見には与してないし、XML技術の矮小化だと思っています。あまりのセコサ、ツマラナサに頭が痛くなります。

&lt;h4&gt;●文字エンコーディングの問題&lt;/h4&gt;

XML規格は、最初からUnicodeをちゃんと考慮し／ちゃんと使った事例です。僕は、「プログラミング言語のリテラル表現などに比べて、この点は大きなアドバンテージだ」と思っていました。いや、今でもencoding宣言は素晴らしいと思います。

しかし、ファイルの先頭のほうで &lt;code&gt;-*- coding: utf-8 -*-&lt;/code&gt; とか書くとうまくいくエディタやプログラミング言語もあります。つまり、encoding宣言のアイディアは、ローカル構文／野良構文でもパクることができるし、うまく機能するのです。これは良いことなのか悪いことなのか？

よく出来たXMLプロセッサは、そこいらのローカル・パーザー／野良パーザーに比べて、ずっとたくさんのエンコーディングをサポートしています。ですが、「UTF-8だけサポートすればいいじゃね」という傾向も確かにあるわけで、「文字エンコーディングで悩まなくて済むからXMLがいいぞ」ってのも、なんか説得力が落ちたようです。

&lt;h4&gt;●XMLはタグなのか&lt;/h4&gt;

僕は、普遍的構文プラットフォームとしてのXMLに期待してましたが、どうやらその目はないようです。しかし、XMLは構文を規定するだけのものではありません -- そう聞いて意外に思う人もいるかもしれませんが、現実に何かをするときに、構文が決まればOKなんてことがあるわきゃないですよ。

XHTMLでもSVGでもMathMLでも、そりゃ確かに構文が規定されています。しかしその構文の背後には、応用固有の領域があり、データ構造があり、ソフトウェア・アーキテクチャがあるのです。XML応用ボキャブラリを策定するとき、構文を決めるよりずっとずっと多くの時間と労力が、領域の定義、データ構造とそのセマンティクスの明確化、アーキテクチャの提示に使われます。構文の議論が紛糾してときに時間を食うのは、恣意的・趣味的要素があるからですよ。

だから、タグなんてなくてもいいのかも知れません。むしろ、構文なんて気にしないほうが幸せな応用もあるでしょう。アンロードや交換（interchange）が必要なら、S式でもCSVでもRubyのリテラルでも、お好きにどうぞ、ってな具合。

XMLの規格／仕様が総体として膨大になってしまったのも、いろいろな分野のセマンティクスとアーキテクチャを、構文を通じて記述し規定しようとしたからです。構文を除いてしまっても、セマンティクス／アーキテクチャは残るのです。なかには出来の悪い仕様もありますが、十分に使える／参照できる仕様もあります。

現時点において、過去に蓄積されたXML技術を再評価したいなら、構文なんて忘れちまう、無視してしまうってのも「一つの視座」を提供すると思います。実際僕は、構文の議論にはもはや食指が動かないし、必要性も感じていません。でもあいかわらず、データ構造論とソフトウェア・アーキテクチャには魅力を感じています。

&lt;h4&gt;●それはどこ？&lt;/h4&gt;

では、過去に蓄積されたXML技術のどのあたりが面白くて、再評価・再発見するにあたいするのか？ いやっ、そんな客観的な話ではなくて、過去に蓄積されたXML技術のどのあたりを檜山が面白いと感じ、再評価・再発見してみたいと望んでいるのか？

それは、また次ね。

*1229589029*[雑記／備忘]Back to XML (2)

&lt;em&gt;本編「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20081218/1229589029&quot;&gt;Back to XML (2)&lt;/a&gt;」のコピー。&lt;/em&gt;

&gt;&gt;
過去に蓄積されたXML技術のどのあたりを檜山が面白いと感じ、再評価・再発見してみたいと望んでいるのか？

それは、また次ね。
&lt;&lt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20081216/1229410746&quot;&gt;前回&lt;/a&gt;、こんな文面で終わってしまったので、「それはどこ？」の話をせざるを得ないでしょうね。だから実際しますけれども、論理的な順序から言うと、その前に話しておくべきことがあるのだった。まー、いきがかりだから論理的順序は無視します。したがって、解説としては若干不親切で、幾分錯綜した感じになりそう。致し方ない。

&lt;h5&gt;話は前世紀まで遡＜さかのぼ＞るのだが&lt;/h5&gt;

「過去に蓄積されたXML技術」という言葉は、なにか特定単一の仕様を意味してるわけではありません。いまだ脈ありと僕が思っているものが&lt;em&gt;いくつか&lt;/em&gt;あるわけです。そのなかで第一の候補を挙げれば、… … &lt;br&gt;&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;XLinkです。&lt;/b&gt;&lt;/span&gt;

XLinkは、XML 1.0仕様とほぼ同じ時期から構想されているものです。XMLの初期のドラフトでは、XLink仕様がXML仕様の一部だったと記憶しています。「過去の蓄積」の期間は、飛び抜けて長い技術ですね。

XLinkは、HyTimeやTEIの血統を継ぎ、XML 1.0の兄弟であり、将来を大いに嘱望されていたのです。1990年代後半、無邪気だった（けど、既にオッサンだった）僕なんか、HTMLのアンカーやイメージはXLinkに置き換えられるもんだと思っていましたよ。そして、諸々のハイパーメディアのベース技術として利用されるのだろうとも期待してました。で、今どうなってます？ これといった応用もないですね。実装？ なんかショボイのがあったような気もするけど…？ もうダメっぽな雰囲気が漂いまくり。

実際、XLinkはダメなところがいろいろあります。対話的処理系内でXLinkを使おうとすると、実装上の問題が山のように出てきます。僕は一時期、その問題群と格闘していたから、XLinkがなぜダメかには通じているつもりです。雑誌の連載で随分詳しく取り上げたこともあります。あまりに詳しくて、実感・共感を持って読んだ人はごく少数（皆無かも？）でしょう。今その説明を繰り返すつもりはありません。

&lt;h5&gt;XLink Again … (?)&lt;/h5&gt;

と、なんかボコボコにこき下ろしておいて、「いまだ脈あり」の技術の第一候補に挙げるとは、いったいどういう了見だ!? -- XLinkを、想定された本来の用途に使おうと思うと、たぶん「もう無理、無理」です。脈ありとすれば、別な側面に目をやるしかないでしょう。その別な側面に僕は光を感じるのです。

ところで、XLinkの想定された本来の用途とは何でしょう。そりゃ、ハイパーテキスト／ハイパードキュメント／ハイパーメディアの基盤ですよ。HTMLのアンカー（aタグ）をうーんと機能拡張したようなハイパーリンクです。既存ボキャブラリの要素や属性に影響を与えずに、ハイパーリンク機能をアタッチできるのがウリ（のはず）です。構文的には名前空間付きの大域属性のセットを使います（これは、HyTimeアーキテクチャル・フォームのXML的な焼き直し）。この本来の用途の文脈で、あの概念と構文を考えてみると、…… ほぼ破綻＜はたん＞しています（あっ、またけなしちゃったよ）。

しかしですねぇ、リンク概念／リンク機構の用途が、対話的ハイパーメディアに限定されるわけじゃありません。僕がいま想定している（あるいは、要求している）リンクは、次の意味でHTMLアンカーより頑丈（robust）でリッチなものです。

+ リンクの生成／確立に、リンク両端の調停と合意が必要とされる。
+ リンクに役割（role）／機能性（fuｎctionality）／振る舞い（behaviour/bihavior）を持たせることができる。
+ リンクを、イベント（主に変更通知）の伝搬経路として使える。
+ 以上の機能により、リンク両端の同期／協調動作／整合性維持などを行える。

リンクにこの程度のことを要求するのは、別に珍しいことではないでしょう。実際僕は、知り合いの&lt;em&gt;ありきたり&lt;/em&gt;の要望を実現しようと考えているうち、「頑丈でリッチなリンクがないと困るなー」と思い至ったのです。

XLinkの構文は忘れ去るとして（どうせ破綻しているから使いものにならない）、背後にあるデータ構造とソフトウェア・アーキテクチャを利用すれば、上記の要求はその守備範囲内です。守備範囲といえば、XLinkとRDFはその適用領域がかぶっているので、RDFに依拠する道もありますが、XLinkを選ぶのは、まー僕の嗜好ですかね。

&lt;hr&gt;
今日はここまで。だけど、XLinkの話とか、その他の埋もれた仕様とかの話をボチボチとするでしょう。ペースはゆっくりだろうけど、（圏論やErlangネタがそうであるように）継続的に取り上げるつもりではいます。

</body>
</day>
<day date="1999-07-30" title="">
<body>
*1248909338*[M4]モニャドセミナー4の予定：トランザクション計算のフレームワークとか

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090727/1248653869&quot;&gt;「モニャドセミナー4の予定：トランザクション計算のフレームワークとか」&lt;/a&gt;と&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090728/1248746528&quot;&gt;「モニャドセミナー4の予定：訂正と補足」&lt;/a&gt;を集約して、わずかに変更。

&lt;hr&gt;

&lt;h5&gt;実務者のための圏論とモナド -- つう感じで&lt;/h5&gt;

練習、質疑応答、議論を強調したいので、スライド利用講義風のスタイルはたぶん止めます。その代わり、印刷した資料((カタカナだと、レジュメ、アジェンダ、シラバスとかいうんでしょうか。))を配付します。お絵描き＆計算用のノートと筆記具は必須です。ホワイトボード2枚メイッパイ使うでしょう。&lt;b&gt;[追記 date=&quot;当日&quot;]&lt;/b&gt;ホワイトボード2枚は使えないようです…(泣く)。&lt;b&gt;[/追記]&lt;/b&gt;

「クライスリ圏の話をするぞ」という予告は守るつもりです。が、今回は次のような疑問や疑念に応えることを主眼にしたいと思います。

- こんなことを知って、なんか実務に役に立つの？
- 絵算はどう使うの、ホントにありがたみがあるの？

実務上の煩雑さは削り落としますが、それでも単純すぎずリアリティが残る素材として、表題のような、トランザクション計算((環境へのインパクトをキチンと制御して、好きなだけ汚染（破壊的変更）を遅延できるような計算なので、&lt;strong&gt;エコ計算&lt;/strong&gt;と呼んだほうが実情を表しているかも。))を組み合わせて実行するためのフレームワークを例題にします。処理が失敗した後のロールバック処理まで考えるのは面倒なので、それは割愛； 失敗に備えて、もとのデータを残したりロギングをするメカニズムを考えるのです。この題材は、今僕が興味を持っているトピックに近いものです。こういう話のほうがリアリティとかライブ感が出るのではないか、という目論見＆魂胆です。

&lt;h5&gt;キュー＆コミット・スタイルのトランザクション計算&lt;/h5&gt;

取り扱う例題をここで紹介しておきます。

次のような状況を考えます； 計算処理（コンピュテーション）をする際に、外部環境（非ローカル変数、ファイル、データベースなど）を参照すること（読み取り）は自由にできるが、外部環境を直接変更することは許されてないとします。その代わり、当該の計算処理が完了したときに実行される予定の更新リクエストを発行できます。リクエストは発行順序を保ってキューに貯えられます((一般論で言えば、リクエストは必ずしもキューイングされる必要はなくて、なんらかの意味で累積されます。))。計算処理が無事に終わると、キューイングされた更新リクエストが順に実行され、外部環境は変更されます -- 正確に言うと、&lt;em&gt;あたかも変更されたように振る舞います。&lt;/em&gt;

以上のような処理に対して、外部環境は暗黙に与えられますが、処理ごとに明示的に渡すパラメータがあってもかまいません。また、計算結果は戻り値として返せます。環境の更新は副作用と考えられます。2つの計算処理をつないだものをトランザクションとみなす場合を考えると、1つめの処理の直後でホントに環境に変更を加えると、2つ目の処理が失敗したときに初期状態を復元できないかもしれません。実際のコミットは、計算処理全体がホントに終わったときに行うべきで、部分計算に対するコミットは仮のコミットとなります。

ひとつ注意しておくと、「直接に外部環境を変更することは許されてない」というのは、外から見たときの話で、計算処理を実行する主体((フレームワークに対してプラッガブルな何者かです。コンポネント、プロセス、タスク、エージェント、コマンド、… まーお好きなように呼んでください。))は「許されている／許されてない」などを知っているわけじゃありません。リクエスト発行を変更と認識しても問題はありません。ただ、変更しても参照している元データへの即時反映が行われない点には注意が必要ですけども。

&lt;h5&gt;圏論とモナドをどう使うのか&lt;/h5&gt;

副作用としての書き込み（メモリ／ストレージの更新）はモノイダル・スタンピング・モナドで定式化して、外部環境の参照（読み取り）は、その双対であるコモノイダル・スタンピング・コモナドを使って定式化します。書き込みのコミット操作は、モノイド作用（線形代数の用語では加群）で定式化します。計算処理の逐次実行は、クライスリ結合、余クライスリ結合、両クライスリ結合となります。

（&lt;b&gt;[追記]&lt;/b&gt;以下の段落で「半関手」という言葉はまったく不適切でした。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090728/1248746528&quot;&gt;訂正と補足&lt;/a&gt;をご覧ください。&lt;b&gt;[/追記]&lt;/b&gt;）

クライスリ圏、余クライスリ圏、両クライスリ圏の計算では、&lt;strong&gt;ラッピング&lt;del datetime=&quot;2009-07-30T08:15:38+09:00&quot;&gt;半関手&lt;/del&gt;対応&lt;/strong&gt;を使う方法を紹介しましょう。&lt;del datetime=&quot;2009-07-30T08:15:38+09:00&quot;&gt;半関手（semi-functor）とは、結合は保存するが恒等の保存が保証されない対応です。&lt;/del&gt;「ラッピング」は僕がでっち上げた形容詞ですが、Adapterデザインパターンとか、あんな感じ((Adapterパターンの別名がWrapperパターン。))。結合機構（コンポジション・マシナリ）の一部を、射に押しつける技法ですね。ラッピング対応により、計算は（絵算も等式計算も）だいぶ楽になります。

なんか難しげ？ &lt;span style=&quot;font-size:large&quot;&gt;大丈夫&lt;/span&gt;、ここで絵算が威力を発揮するはず。絵に描けば難しそうな概念もクリアになります。本来、モナドの取り扱いは自然変換の計算になりますが、モノイダル・スタンピング・モナドに限れば、射の変形操作（ワイヤリング）だけでだいたい済みます。まー、モニャドセミナー3で自然変換を飛ばしちまった都合で、自然変換なしで済ませたいという事情もあります。

モノイダル・スタンピング・モナドに限定して、自然変換を正面から取り上げないことは、絵算を矮小化することになりますが、それでも絵算の威力と醍醐味は&lt;em&gt;ある程度は&lt;/em&gt;伝わるんじゃないのかなー、と思ってます。

&lt;hr&gt;

&lt;h4&gt;モニャドセミナー4の予定：訂正と補足&lt;/h4&gt;

&lt;h5&gt;半関手は2つの意味で不適切な言葉でした&lt;/h5&gt;

&gt;&gt;
クライスリ圏、余クライスリ圏、両クライスリ圏の計算では、&lt;strong&gt;ラッピング半関手&lt;/strong&gt;を使う方法を紹介しましょう。半関手（semi-functor）とは、結合は保存するが恒等の保存が保証されない対応です。「ラッピング」は僕がでっち上げた形容詞ですが、Adapterデザインパターンとか、あんな感じ。結合機構（コンポジション・マシナリ）の一部を、射に押しつける技法ですね。ラッピング半関手により、計算は（絵算も等式計算も）だいぶ楽になります。
&lt;&lt;

半関手という言葉は使うべきじゃなかったです。「結合は保存するが恒等の保存が保証されない対応」という定義はいいのですが、「F:C→D が半関手だ」というときは、CとDが圏、少なくとも半圏（圏から恒等を除いた構造）であることが前提となります。

僕が想定している状況では、Dは圏だけど、Cが何であるか全然不明なんです。Cが圏であることも、半圏であることも保証できません。この状況で半関手というのは不適切です。

Cに部分二項演算があるが、結合律さえも保証されてないとき、Cはマグマ（正確には1-マグマ((もっと正確には、1-グロービュラー・グラフ（1-globular graph）上のマグマです。))）と呼ぶことがあります。この言葉を使うなら、ラッピングは、マグマ準同型になっている、とは言えます。僕が利用したいのは次の事実です。

- Cがマグマ、Dが圏で、F:C→Dは単射であるマグマ準同型（演算を保った埋め込み）のとき、Cは半圏（結合律を満たすマグマ）である。事後的に、Fは半関手である。

ラッピング半関手と呼ぶのはダメですから、&lt;strong&gt;ラッピング対応&lt;/strong&gt;と呼ぶことにします。

それと、「恒等の保存が保証されない」と書いてますが、ラッピング対応は実は恒等も保存するのです。恒等の保存を使う必要性がなかったので、意識してなかっただけでした。恒等（歴史的事情から反射と呼ぶ）の保存を仮定できると、次の命題がなりたちます。

- Cが反射的マグマ、Dが圏で、F:C→Dは単射である反射的マグマ準同型のとき、Cは圏である。事後的に、Fは関手である。

反射的マグマとは、反射的グラフに二項演算が入った構造です。圏とほぼ同じ計算体系ですが、計算法則が何もないものです。

&lt;h5&gt;計算が簡単にならないときもある&lt;/h5&gt;

モノイダル・スタンピング・モナドと、コモノイダル・スタンピング・コモナドから、次の圏を構成します。

+ モナドからクライスリ圏
+ コモナドから余クライスリ圏
+ モナド／コモナド対から両クライスリ圏
+ 作用付きモナド／コモナド対から作用付き両クライスリ圏

最初の3つについては、ラッピング対応を使うと計算が楽になるのは確かです。ただし、何の工夫もなしにやっても大した手間ではありません。

4番目の作用付き両クライスリ圏ですが、これは、ラッピング対応を使っても全然計算が楽になりません。直接的な絵算がうまく働かない例になっているようです。しょうがないので、別な手段 -- 圏論的行列計算を使うことにします、たぶん。

圏論的行列計算は、計算手順は普通の行列計算とまったく同じですが、計算の意味論をモノイド圏のなかに取ります。ワイヤリングが複雑化しちゃったときは、直接絵算より行列計算したほうがうまく行くときもあります。

&lt;b&gt;[追記]&lt;/b&gt;二転三転ですが、やっぱり行列計算じゃなくて、直接的な絵算を使おうかと。行列計算は、発見的手法としても雑談ネタとしても面白いのですが、今回のケースでは、実用上受け入れがたい制限を付けるか、あるいは非決定性を導入して新しい圏を構成するとか、セットアップに手間がかかるんです。時間的に無理な感じ。

レイアウトに注意して描けば、直接絵算でもまーなんとかなるかな、っと。さっき絵を描いていたら、&lt;em&gt;最後の最後になって&lt;/em&gt;、右と左を逆にすれば良かったことに気が付きました。ウゲーー、&lt;em&gt;もうウンザリ。&lt;/em&gt;描き直す気力がないので、余分なスワップ（左右交換）が入るけど、これでもういいことにします。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;実務上の要請と帰結&lt;/h5&gt;

「モニャドセミナー4の予定：トランザクション計算のフレームワークとか」の冒頭で言ったとおり、今回は、「アブストラクト・ナンセンスが実務的な問題解決にどう利用できるか」ってことをデモンストレートしたいのです。その実務的観点をまとめると：

+ プラッガブル・コンポネントとフレームワークにより、ある種のトランザクション計算（エコ計算と呼ぶのが適切？）のメカニズムを作りたい。
+ コンポネント作成者の負担をできるだけ少なくしたい。特に、退屈なルーチンコードを書くようなことは強制しない。
+ フレームワークの実装もできるだけ単純にしたい。既存の知識やコードで済むならそれで済ませたい。
+ 実行される計算が、型安全であることを保証したい -- 型エラーが起きないことは実行をせずにチェックしたい。
+ 一見矛盾するような要求を調停するために、コンポネント群の組み立てと実行に先立ち、静的または動的にラッピングをする。ラップされたコンポネント群をフレームワークの実行環境上で走らせる。


</body>
</day>
<day date="1999-07-31" title="">
<body>
*1248933066*[M4]今日はモニャドセミナー4

「当日にならないと資料を作れません」病で、今日になってやっているが：

- chimaira.org用に作った自家製wiki風記法で資料を書こうと思ったら、まったく忘れていた。
- 最近まで使っていたTrack wikiにしよう、っと、、、グエーッ、Creole Wikiと混乱してダメだー。
- 結局、wiki風マークアップは「はてな記法」しか憶えてない。
- メモ編を使って原稿作成しよう。
- でも、今日の日付に&lt;del datetime=&quot;2009-07-31T01:01:43+09:00&quot;&gt;思料&lt;/del&gt;資料を貼ってしまうと問題がありそう。
- 10年前の日付をダミーに使おう。

ということです。

*1248933067*[M4]モニャドセミナー4 資料

&lt;h5&gt;前置きとか予定とか省略&lt;/h5&gt;

だけど、ちょっとは言っておくと（＜省略してねー）：

+ クライスリ圏はもちろんやるぞー
+ でも自然変換をほとんど使わないよ
+ なぜなら、スタンピング・モナド（or コモナド）に限定するから
+ 気が向いたら一般論を少し入れるが、一般論のアドリブ計算に自信がない。失敗しても責めないでね。
+ 右と左でどうせハマる
+ 現実のプログラミングやシステムとの関係を強調する予定
+ ラップ／アンラップが基本的な道具だよ
+ 目標は、トランザクション計算（エコ計算）の、作用付き両クライスリ圏の構成

&lt;h5&gt;圏と関手の復習：ステップbyステップの定義&lt;/h5&gt;

- ステップ1 dom, cod --  有向グラフ
- ステップ2 dom, cod, id --  反射的有向グラフ
- ステップ3 dom, cod, id, comp --  反射的マグマ
- ステップ4 結合法則と単位法則 --  圏

- サイドステップ2' dom, cod, comp --  マグマ
- サイドステップ3' 結合法則 --  半圏

- ステップ1 dom, cod を保存 --  有向グラフの準同型
- ステップ2 dom, cod, id を保存 --  反射的有向グラフの準同型
- ステップ3 dom, cod, id, comp を保存 --  反射的マグマの準同型＝関手

- サイドステップ2' dom, cod, comp を保存 --  マグマの準同型＝半関手

&lt;h5&gt;自然変換&lt;/h5&gt;

モニャドセミナー3で取り上げられませんでした。無念だ。今日も無理だ。ごめんなさい。

お詫びに、いいことを教えましょう。自然変換αは次のように書くと具合がいいぞ。

&lt;pre&gt;

     F
α:: ∥ : C→D
     ∨
     G

または

            C
α:: F⇒G : ↓
            D

&lt;/pre&gt;

&lt;h5&gt;箴言集&lt;/h5&gt;

箴言＜しんげん＞つうより、ぼやきの言葉：

+ とにかく、先入観、こだわり、偏見から抜け出そう。
+ 定義や計算に意味を求めすぎない。
+ 特に、唯一の意味を求めるのはたいていは不毛。
+ 実体を過剰に気にしない。「なんでもいいや」と割り切る。
+ 構文の意味は、その構文自体だという解釈だってある。
+ 集合／写像にこだわらない。数や図形は、そのまま素直に捉える。
+ 集合／写像による表現は重要だが、それがベストでも便利でもないことがある。
+ 対象に要素（元）があると思うな。あっても使うな。（「初等的」って言うのだ）
+ 「変だ」「違う」は、根拠を出して言う。気分だけで言わない。（次男のホワイトリスト方式好き嫌いには困った）
+ 認識や分類は観察者の主観であって、対象物側にあるのではない。
+ 態度を変えれば、同じ対象物に違う構造が見えてくる。違う構造は違うモノ。
+ 極めてツマンナイものに注目する。空、単元集合、pointing map、自明モノイド（いくつかの意味がある）、包含写像、射影、忘却関手など。
+ 用語・記法の歴史的な経緯や事情はあきらめろ。いまさらどうにもならない。（が、檜山はあきらめが悪い。）
+ 記号はいつだって足りない、ホントに足りない。A, B, C∈|C| -- アリッ!?
+ ズボラな記法や用法に慣れる。id&lt;sub&gt;A&lt;/sub&gt; = A とかは、計算上も重要なズボラ・テク。

圏への先入観を砕く目的で「単純平面タングル」を出した。模様が射、模様は模様、それだけ（&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090623/1245715012&quot;&gt;田辺デモ&lt;/a&gt;参照）。

力学的運動の圏なんてのはどう？ 射は写像だけど、パラメータは時間。その時間が対象なわけじゃない。

&lt;h5&gt;モノイドとコモノイド&lt;/h5&gt;

- モノイドの例を思い出そう
- 特に今日は、整数の足し算（カウンタ）、文字列の連接（テキストファイル）、2次元アフィン変換（タートル・グラフィックス）を考える。
- モノイドの法則を図示しよう。

&lt;div class=&quot;fig&quot; style=&quot;height:600&quot;&gt;
 (空白)
&lt;/div&gt;

- 矢印をひっくり返せ&lt;del datetime=&quot;2009-08-05T17:49:01+09:00&quot;&gt;べ&lt;/del&gt;ば、コモノイドの定義と法則
- 今日使うコモノイドは一種類、演算の名前は色々：対角、余積（余乗法）、余加法、複製、分岐などなど。

&lt;div class=&quot;fig&quot; style=height:600&quot;&gt;
 (空白)
&lt;/div&gt;

&lt;h5&gt;今日取り扱う圏と関手&lt;/h5&gt;

Mはモノイド、Vはコモノイドと約束する。

|* 記号 | 短い説明 |
| C     | 基本とする圏、モノイド積を持つ |
| C×M  | Mによる右スタンピング構成（で得られた圏） |
| M×C  | Mによる左スタンピング構成 |
| M×S  | M-加群Sによる右スタンピング構成、左も使うかも |
| R&lt;sub&gt;M&lt;/sub&gt; | Mによる右スタンピング（右掛け算）関手 C→C |
| L&lt;sub&gt;M&lt;/sub&gt; | Mによる左スタンピング（左掛け算）関手 C→C |
| Kl(R&lt;sub&gt;M&lt;/sub&gt;) | 右スタンピング・モナドR&lt;sub&gt;M&lt;/sub&gt;のクライスリ圏|
| Kl(L&lt;sub&gt;M&lt;/sub&gt;) | 左スタンピング・モナドL&lt;sub&gt;M&lt;/sub&gt;のクライスリ圏|
| CoKl(L&lt;sub&gt;V&lt;/sub&gt;) | コモノイドVによる左スタンピング・コモナドL&lt;sub&gt;V&lt;/sub&gt;の余クライスリ圏|
| DiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;) | 両（双）クライスリ圏|
| AcDiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;) | 作用付き両クライスリ圏|

- モノイド積の典型例は直積
- M-加群は線形代数の用語を拝借。M-作用を持つ対象。
- R&lt;sup&gt;A&lt;/sup&gt;, &lt;sup&gt;A&lt;/sup&gt;L と書くと具合がいい。

その他、重要な関手

- J : A×C→C -- スタンピング構成した圏から、もとの圏へ
- W : Kl(R&lt;sub&gt;M&lt;/sub&gt;)→C×M ラッピング
- W' : Kl(R&lt;sub&gt;M&lt;/sub&gt;)→C×S ラッピングもどき、一番わかりやすいが、アンラップ（中身の取り出し、再現）ができない
- W : Kl(L&lt;sub&gt;V&lt;/sub&gt;)→V×C ラッピング
- W : DiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;)→V×C×M ラッピング
- W : AcDiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;)→V×C×M ラッピング

&lt;h5&gt;スタンピング構成&lt;/h5&gt;

今日ずっと基礎にする圏C

+ なんらかのデータ型、データ領域が対象
+ なんらかの計算処理／計算主体が射
+ 計算処理／計算主体を計算エージェントと呼ぶことがある
+ 計算エージェントは内部と外部をわかつ境界を持っている
+ 入出力は、n-in m-out または、タプリングを許して 1-in 1-out

A∈|C|を固定して、次の圏を作れる。

- 対象は A×X の型のCの対象
- 射は、A×X→A×Y の形のCの射
- dom(f:A×X→A×Y) = X
- cod(f:A×X→A×Y) = Y
- compはfのcomp

この圏を &lt;sub&gt;A×&lt;/sub&gt;C、面倒だから A×C と書く（これはイイカゲン過ぎてヤバイ）。

ホムセットによる定義がいいかも。

&lt;h5&gt;関手J&lt;/h5&gt;

J: A×C→C

- J(X) = A×X
- J(f:X→C in A×C) = (f in C)

このJは現実的にどんな意味があるか？

- X→Y が、Cでは A×X→A×Y ってことは、、、
- クラス定義を固定しての、、、
- ×××を素朴な純関数計算で表してみると

&lt;h5&gt;数式と現象&lt;/h5&gt;

- 二次関数を学び、ちゃんと使える人はたくさんいる。
- その二次関数で、「投げたボール」を記述できて、到達点を計算できることを知らない人はたくさんいる。
- 小中学校の素材のなかにも、あれだけ圏が発見できる。
- プログラミングやシステムの「現象」に、圏やモナドが含まれてないハズはないでしょ。どう考えても。
- ヒープ（共有領域）もスタック（プライベート領域）も、参照引数も値引数も、&lt;del datetime=&quot;2009-07-31T08:44:03+09:00&quot;&gt;胃&lt;/del&gt;イミュータビリティもディープコピーも、クラスとオブジェクトも、単一代入も、DIも、総称関数も依存型も、当然に圏論で現象記述（定式化）できるよ。当たり前だ。

&lt;h5&gt;今日のモノイドさん、モナドさん&lt;/h5&gt;

+ 有限カウンタ 0から9  有界
+ 有限カウンタ 0から9  サイクリック（ラップアラウンド）
+ 出力モードのテキストファイル
+ タートルグラフィックス ペンなし
+ タートルグラフィックス ペンあり

- 状態値と作用値と遷移
- あるいは、位置と力と運動
- タートルグラフィックスのコマンドは&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090616/1245117533&quot;&gt;アフィン変換&lt;/a&gt;として考える
- タートルグラフィックスの軌跡の扱いが少し面倒かな

&lt;h5&gt;それっ、クライスリ圏&lt;/h5&gt;

状態値は無視して、作用値＝モノイドの元、作用の結合（合成）＝モノイド演算 として
クライスリ射とクライスリ結合を作ってしまえ。

結合法則と単位律も直接に証明しよう。

実例で考えると、状態空間への更新リクエストAPIを使う関数だよね。

&lt;h5&gt;ラッピングを使ってみよう&lt;/h5&gt;

- オブジェクト指向風の実行環境の上で実装するってことだね
- アンラップできるところがミソ
- アンラップがあるので、ラッピングは単射（埋め込み）
- 既にクライスリ圏を作っているので、ラッピングは関手だと言っていい

&lt;h5&gt;ラッピングを先に考えると&lt;/h5&gt;

Dがマグマ、Cが圏、F:D→C という対応があり：

+ Fは単射
+ Fはマグマの結合演算を保つ

このとき、Dは半圏であり、Fは半関手。

さらに、Dが反射的マグマ、Cが圏、F:D→C という対応があり：

+ Fは単射
+ Fはマグマの結合演算を保つ
+ Fはマグマの恒等を保つ

このとき、Dは圏であり、Fは関手。

以上の事実を使って、クライスリ圏を構成してみよう。

&lt;h5&gt;余クライスリ圏&lt;/h5&gt;

対角コモノイドのコモノイダル・スタンピング・&lt;del datetime=&quot;2009-08-04T10:47:16+09:00&quot;&gt;モナド&lt;/del&gt;コモナドから、反射的マグマを作り、余クライスリ圏も作ってしまえ。

&lt;h5&gt;状態スタンピングはイマイチ&lt;/h5&gt;

ラッピングに近いことができるが、作用がどうなっているか外部からは予測できないので、アンラップできない。アンラップがないので単射性が示せず、埋め込み関手が構成できない。

もう少し工夫しないと。

&lt;h5&gt;ここらで愚痴を言っておきたい&lt;/h5&gt;

「… だーから右と左のハナシはいやなんだよなー」

- (a・b)*x = a*(b*x) 気持ちいい左作用
- (a・b)*x = b*(a*x) 気持ち悪い左作用
- x*(a・b) = (x*a)*b 気持ちいい右作用
- x*(a・b) = (x*b)*a 気持ち悪い右作用

前回（モニャドセミナー3）でも間違えたしよ。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090711/1247288729&quot;&gt;「理解をさまたげるモノ／誤解をまねくモノ、それと対処」&lt;/a&gt;のの「右と左、上と下、前と後」参照

&lt;img src=&quot;http://www.chimaira.org/img2/m4-module-action.jpg&quot; &gt;

&lt;h5&gt;加群（作用）の公理&lt;/h5&gt;

カウンタ、テキストファイル、タートルグラフィックスが例。

結合律を絵で表そう。

&lt;h5&gt;後はなりゆき &lt;/h5&gt;

クライスリ圏の一般論はたぶんやらないと思うが、一応書いておく：

- F(μ&lt;sub&gt;X&lt;/sub&gt;) ; μ&lt;sub&gt;X&lt;/sub&gt; = μ&lt;sub&gt;F(X)&lt;/sub&gt; ; μ&lt;sub&gt;X&lt;/sub&gt;
- F(η&lt;sub&gt;X&lt;/sub&gt;) ; μ&lt;sub&gt;X&lt;/sub&gt; = id&lt;sub&gt;F(X)&lt;/sub&gt;
- η&lt;sub&gt;F(X)&lt;/sub&gt;) ; μ&lt;sub&gt;X&lt;/sub&gt; = id&lt;sub&gt;F(X)&lt;/sub&gt;

&lt;pre&gt;
  X -- (f) ---&gt; F(X)
  |              |
  |η_X          |η_F(X)
  |              |
  v              v
 F(X) -(F(f))-&gt; FF(X)
&lt;/pre&gt;

&lt;h5&gt;後はなりゆき 2&lt;/h5&gt;

次の計算はアドリブでは不安だ。写真を載せておこう。

&lt;img src=&quot;http://www.chimaira.org/img2/m4-act-diKleisli-1.jpg&quot;&gt;

&lt;img src=&quot;http://www.chimaira.org/img2/m4-act-diKleisli-2.jpg&quot;&gt;

あと、双モノイド法則（3種）が必要だが、それはアドリブ。

</body>
</day>
<day date="1999-08-01" title="">
<body>
*1249450073*[M4][モナド][JavaScript]カウンター・モナド

&gt;|html|
&lt;html&gt;&lt;!-- counter-monad.html --&gt;
&lt;head&gt;
  &lt;title&gt;Counter Monad&lt;/title&gt;

  &lt;script src=&quot;CounterMonad.js&quot; &gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;Counter Monad&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
||&lt;

&gt;|javascript|
/* CounterMonad.js */

// オペレーション・モノイド
var CounterOp = {
  // 定数
  UP : 117, // 'u' = upオペレーション
  DOWN : 100, // 'd' = downオペレーション

  // モノイド単位
  unit : function() {
    return &quot;&quot;;
  },
  // モノイド乗法
  mult : function(x, y) {
    return (&quot;&quot; + x + y);
  }
};

// カウンター・オブジェクト（シングルトン）
var Counter = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイングする
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  UPPER_BOUND : 9,
  // LOWER_BOUNDは0に固定する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _value : undefined, // 状態値
  _operations : undefined, // 累積オペレーション値
  _action : undefined // オペレーション・リクエストの実行方式

};

/* カウンター・リクエストの実行方式（ストラテジー） */

// 有界カウンタ方式
var BoundedCounterAction = {
  /* カウンターはシングルトンなので、名前で直接参照している。
   * 行儀がいいとは言えないが、よしとする。
   */
  // カウンタのアップ
  doUp : function() {
    if (Counter._value &lt; Counter.UPPER_BOUND) Counter._value++;
  },
  // カウンタのダウン
  doDown : function() {
    if (Counter._value &gt; 0) Counter._value--;
  },
  name : &quot;BoundedCounterAction&quot; // 識別用
};

// サイクリック・カウンタ方式
var CyclicCounterAction = {
  // カウンタのアップ
  doUp : function() {
    if (Counter._value &lt; Counter.UPPER_BOUND) {
      Counter._value++;
    } else {
      Counter._value = 0;
    }
  },
  // カウンタのダウン
  doDown : function() {
    if (Counter._value &gt; 0) {
      Counter._value--;
    } else {
      Counter._value = Counter.UPPER_BOUND;
    }
  },
  name : &quot;CyclicCounterAction&quot; // 識別用
};

/*  以下にメソッド群 */

Counter.init = function(action) {
  Counter._mode = Counter.QUEUE_MODE;
  Counter._value = 0;
  Counter._operations = CounterOp.unit();
  if (action) {
    Counter._action = action;
  } else {
    Counter._action = BoundedCounterAction;
  }
};

Counter.setMode = function(mode) {
  Counter._mode = mode;
};

Counter.operate = function (op) {
  var old = Counter._operations;
  Counter._operations = CounterOp.mult(old, op);
  if (Counter._mode == Counter.DIRECT_MODE) {
    Counter.execOperations();
  }
};

// キューイングされたオペレーションの実行
Counter.execOperations  = function() {
  var ops = Counter._operations;
  for (var i = 0; i &lt; ops.length; i++) {
   var op = ops.charCodeAt(i);
   switch (op) {
    case CounterOp.UP:
     Counter._action.doUp(); break;
    case CounterOp.DOWN:
     Counter._action.doDown(); break;
    default: throw &quot;Unbelievable!&quot;;
   }
 }
 // 累積されたカウンタ操作リクエストをクリアする
  Counter._operations = CounterOp.unit();
};

/* 対話的に使用する便利関数 */
/*
 * start(a) -- 初期化
 *             aにはカウンタ操作の実装を渡す
 *             デフォルトは、BoundedCounterAction
 *             他に、CyclicCounterAction が使える
 * u()      -- カウントアップ
 * d()      -- カウントダウン
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キューの表示
 * v()      -- 値の表示
 * qmode(f) -- キューイングするかどうかの設定
 *             fがtrueならキューイングモードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start(a) {
  Counter.init(a);
}

function u() {
  Counter.operate(&quot;u&quot;);
}

function d() {
  Counter.operate(&quot;d&quot;);
}

function x() {
  Counter.execOperations();
}

function q() {
  return Counter._operations;
}

function v() {
  return Counter._value;
}

function qmode(f) {
  if (f) {
    Counter.setMode(Counter.QUEUE_MODE);
  } else {
    x(); // キューをフラッシュする
    Counter.setMode(Counter.DIRECT_MODE);
  }
};
||&lt;

*1249450074*[M4][モナド][JavaScript]サイクリック・カウンター・モナド

&gt;|javascript|
/* CyclicCounterMonad.js */

// オペレーション・モノイド
var CounterOp = {
  // モノイド単位
  unit : function() {
    return 0;
  },
  // モノイド乗法
  mult : function(x, y) {
    return x + y;
  }
};

// カウンター・オブジェクト（シングルトン）
var Counter = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイング(?)する
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  UPPER_BOUND : 9,
  // LOWER_BOUNDは0に固定する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _value : undefined, // 状態値
  _operations : undefined // 累積オペレーション値
};

/* カウンター・リクエストの実行 */
/*
 * ストラテジーを使わずに、Counter内に直接記述
 */

Counter._action_do = function(ops) {
  Counter._value = (Counter._value + ops) % (Counter.UPPER_BOUND + 1);
};

/*  以下にメソッド群 */

Counter.init = function() {
  Counter._mode = Counter.QUEUE_MODE;
  Counter._value = 0;
  Counter._operations = CounterOp.unit();
};

Counter.setMode = function(mode) {
  Counter._mode = mode;
};

Counter.operate = function (op) {
  var old = Counter._operations;
  Counter._operations = CounterOp.mult(old, op);
  if (Counter._mode == Counter.DIRECT_MODE) {
    Counter.execOperations();
  }
};

// キューイング(?)されたオペレーションの実行
Counter.execOperations  = function() {
  var ops = Counter._operations;
  Counter._action_do(ops); // 実行
 // 累積されたカウンタ操作リクエストをクリアする
  Counter._operations = CounterOp.unit();
};

/* 対話的に使用する便利関数 */
/*
 * start()  -- 初期化
 * u()      -- カウントアップ
 * d()      -- カウントダウン
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キュー(?)の表示
 * v()      -- 値の表示
 * qmode(f) -- キューイング(?)するかどうかの設定
 *             fがtrueならキューイング(?)モードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start() {
  Counter.init();
}

function u() {
  Counter.operate(&quot;u&quot;);
}

function d() {
  Counter.operate(&quot;d&quot;);
}

function x() {
  Counter.execOperations();
}

function q() {
  return Counter._operations;
}

function v() {
  return Counter._value;
}

function qmode(f) {
  if (f) {
    Counter.setMode(Counter.QUEUE_MODE);
  } else {
    x(); // キュー(?)をフラッシュする
    Counter.setMode(Counter.DIRECT_MODE);
  }
};
||&lt;

*1249450075*[M4][モナド][JavaScript]タートル・モナド

&gt;|html|
&lt;html&gt;&lt;!-- turtle-monad.html --&gt;
  &lt;head&gt;
    &lt;title&gt;Turtle Monad&lt;/title&gt;

    &lt;script src=&quot;TurtleMonad.js&quot; &gt;&lt;/script&gt;
    &lt;script&gt;
      var _canvas = null;
      var _ctx = null;
      function initCanvas() {
        _canvas = document.getElementById(&quot;canvas&quot;); 
        _ctx = _canvas.getContext('2d');
      }
    &lt;/script&gt;

    &lt;style&gt;
      #canvas {border: 1px solid blue;
    &lt;/style&gt;

&lt;/head&gt;

&lt;body onload=&quot;initCanvas()&quot;&gt;
&lt;h1&gt;Turtle Monad&lt;/h1&gt;

&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot; &gt;
  &lt;h1&gt;キャンバスがサポートされていません。&lt;/h2&gt;
&lt;/canvas&gt;

&lt;/body&gt;
&lt;/html&gt;
||&lt;

&gt;|javascript|
/* TurtleMonad.js */

// オペレーション・モノイド
var TurtleOp = {
  // 定数
  GO : 1, // 直進
  ROTATE : 2, // 回転

  // モノイド単位
  unit : function() {
    return [];
  },
  // モノイド乗法
  mult : function(a, b) {
    return Array.concat(a, b); // firefox用
  }
};

// タートル・オブジェクト（シングルトン）
var Turtle = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイングする
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _canvas : undefined, // 描画キャンバス
  _width : undefined, // キャンバス幅
  _height : undefined, // キャンバス高さ
  _ctx : undefined, // 描画コンテキスト
  _x : undefined, // 現在位置のx-座標
  _y : undefined, // 現在位置のy-座標
  _dir : undefined, // 頭が向いている方向（弧度法）
  _operations : undefined // 累積オペレーション値
};


/*  以下にメソッド群 */

Turtle.init = function() {
  Turtle._mode = Turtle.QUEUE_MODE;
  // 大域変数 _canvas, _ctx はHTML側でセットしてくれている
  Turtle._canvas = _canvas;
  Turtle._ctx = _ctx;
  Turtle._width = Turtle._canvas.width;
  Turtle._height = Turtle._canvas.height;
  Turtle._x = 0;
  Turtle._y = 0;
  Turtle._dir = (1/2)*Math.PI;
  Turtle._operations = TurtleOp.unit();
  // 座標を使いやすいようにセットする
  Turtle._ctx.setTransform(1, 0, 0, -1,
    Math.round(Turtle._width/2),
    Math.round(Turtle._height/2)
  );
  // 初期状態の描画
  Turtle.draw();
};

Turtle.setMode = function(mode) {
  Turtle._mode = mode;
};

Turtle.operate = function (op) {
  var old = Turtle._operations;
  Turtle._operations = TurtleOp.mult(old, op);
  if (Turtle._mode == Turtle.DIRECT_MODE) {
    Turtle.execOperations();
  }
};

Turtle.draw = function() {
  // パラメータの設定
  var dirHead = Turtle._dir;
  var dirRight = Turtle._dir + (Math.PI* (3/4));
  var dirLeft = Turtle._dir - (Math.PI* (3/4));
  var x = Turtle._x;
  var y = Turtle._y;
  var r = 10;

  // 描画の実行
  var ctx = Turtle._ctx;
  ctx.clearRect(-Turtle._width/2, -Turtle._height/2,
			Turtle._width, Turtle._height);
  ctx.beginPath();
  ctx.moveTo(x + r*Math.cos(dirHead),  y + r*Math.sin(dirHead));
  ctx.lineTo(x + r*Math.cos(dirRight), y + r*Math.sin(dirRight));
  ctx.lineTo(x + r*Math.cos(dirLeft),  y + r*Math.sin(dirLeft));
  ctx.lineTo(x + r*Math.cos(dirHead),  y + r*Math.sin(dirHead));
  ctx.fill();
};

// タートルの直進 （アクションの実行）
Turtle._action_go = function (r) {
  var x = Turtle._x;
  var y = Turtle._y;
  var dir = Turtle._dir;
  Turtle._x = x + r*Math.cos(dir);
  Turtle._y = y + r*Math.sin(dir);
};

// タートルの回転 （アクションの実行）
Turtle._action_rotate = function (arc) {
  var dir = Turtle._dir;
  Turtle._dir = dir + arc;
};

// キューイングされたオペレーションの実行
Turtle.execOperations  = function() {
  var ops = Turtle._operations;
  for (var i = 0; i &lt; ops.length; i++) {
    var op = ops[i];
    var action = op[0];
    var param = op[1];
    switch (action) {
      case TurtleOp.GO:
	Turtle._action_go(param); break;
      case TurtleOp.ROTATE:
	Turtle._action_rotate(param); break;
      default: throw &quot;Unbelievable!&quot;;
    }
  }
  // 累積されたタートル操作リクエストをクリアする
  Turtle._operations = TurtleOp.unit();
  // 描画
  Turtle.draw();
};


/* 対話的に使用する便利関数群 */
/*
 * start()  -- 初期化
 * fd(r)    -- タートル前方に直進 forward
 * bk(r)    -- タートル後方に直進 back
 * rt(a)    -- タートル右に回転 right 角度aは360度方式
 * lt(a)    -- タートル左に回転 left 角度aは360度方式
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キューの表示
 * qmode(f) -- キューイングするかどうかの設定
 *             fがtrueならキューイングモードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start() {
  Turtle.init();
}

function fd(r) {
  Turtle.operate([[TurtleOp.GO, r]]);
}

function bk(r) {
  Turtle.operate([[TurtleOp.GO, -r]]);
}

function rt(a) {
  Turtle.operate([[TurtleOp.ROTATE, -(a/360)*(2*Math.PI)]]);
}

function lt(a) {
  Turtle.operate([[TurtleOp.ROTATE, (a/360)*(2*Math.PI)]]);
}

function x() {
  Turtle.execOperations();
}

function q() {
  return Turtle._operations;
}

function qmode(f) {
  if (f) {
    Turtle.setMode(Turtle.QUEUE_MODE);
  } else {
    x(); // キューをフラッシュする
    Turtle.setMode(Turtle.DIRECT_MODE);
  }
};
||&lt;

</body>
</day>
<day date="1999-08-02" title="">
<body>
*1249464085*[M4][Mx]モニャドセミナー4 資料 抜粋 ＋ 追加

&lt;em&gt;追加分は最後。&lt;/em&gt;

&lt;h5&gt;前置きとか予定とか（ほとんど）省略&lt;/h5&gt;

+ スタンピング・モナド（or コモナド）に限定
+ 現実のプログラミングやシステムとの関係を強調する
+ ラップ／アンラップが基本的な道具だよ
+ 目標は、トランザクション計算（エコ計算）の、作用付き両クライスリ圏の構成

&lt;h5&gt;箴言集&lt;/h5&gt;

+ 対象に要素（元）があると思うな。あっても使うな。（「初等的」って言うのだ）
+ 認識や分類は観察者の主観であって、対象物側にあるのではない。
+ 態度を変えれば、同じ対象物に違う構造が見えてくる。違う構造は違うモノ。
+ 極めてツマンナイものに注目する。空、単元集合、pointing map、自明モノイド（いくつかの意味がある）、包含写像、射影、忘却関手など。
+ 用語・記法の歴史的な経緯や事情はあきらめろ。いまさらどうにもならない。（が、檜山はあきらめが悪い。）
+ 記号はいつだって足りない、ホントに足りない。A, B, C∈|C| -- アリッ!?
+ ズボラな記法や用法に慣れる。id&lt;sub&gt;A&lt;/sub&gt; = A とかは、計算上も重要なズボラ・テク。

&lt;h5&gt;モノイドとコモノイド&lt;/h5&gt;

- 特に今日は、整数の足し算（カウンタ）、文字列の連接（テキストファイル）、2次元アフィン変換（タートル・グラフィックス）を考える。
- &lt;b&gt;[追記]&lt;/b&gt;タートルが2次元アフィン変換はほぼ嘘だった。&lt;em&gt;砲台モナドを作るつもりだ。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

- モノイドの矢印をひっくり返せば、コモノイドの定義と法則
- 今日使うコモノイドは一種類、演算の名前は色々：対角、余積（余乗法）、余加法、複製、分岐などなど。

&lt;h5&gt;今日取り扱う圏と関手&lt;/h5&gt;

Mはモノイド、Vはコモノイドと約束する。

|* 記号 | 短い説明 |
| C     | 基本とする圏、モノイド積を持つ |
| C×M  | Mによる右スタンピング構成（で得られた圏） |
| M×C  | Mによる左スタンピング構成 |
| M×S  | M-加群Sによる右スタンピング構成、左も使うかも |
| R&lt;sub&gt;M&lt;/sub&gt; | Mによる右スタンピング（右掛け算）関手 C→C |
| L&lt;sub&gt;M&lt;/sub&gt; | Mによる左スタンピング（左掛け算）関手 C→C |
| Kl(R&lt;sub&gt;M&lt;/sub&gt;) | 右スタンピング・モナドR&lt;sub&gt;M&lt;/sub&gt;のクライスリ圏|
| Kl(L&lt;sub&gt;M&lt;/sub&gt;) | 左スタンピング・モナドL&lt;sub&gt;M&lt;/sub&gt;のクライスリ圏|
| CoKl(L&lt;sub&gt;V&lt;/sub&gt;) | コモノイドVによる左スタンピング・コモナドL&lt;sub&gt;V&lt;/sub&gt;の余クライスリ圏|
| DiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;) | 両（双）クライスリ圏|
| AcDiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;) | 作用付き両クライスリ圏|

- モノイド積の典型例は直積
- M-加群は線形代数の用語を拝借。M-作用を持つ対象。
- R&lt;sup&gt;A&lt;/sup&gt;, &lt;sup&gt;A&lt;/sup&gt;L と書くと具合がいい。

その他、重要な関手

- J : A×C→C -- スタンピング構成した圏から、もとの圏へ
- W : Kl(R&lt;sub&gt;M&lt;/sub&gt;)→C×M ラッピング
- W' : Kl(R&lt;sub&gt;M&lt;/sub&gt;)→C×S ラッピングもどき、一番わかりやすいが、アンラップ（中身の取り出し、再現）ができない
- W : Kl(L&lt;sub&gt;V&lt;/sub&gt;)→V×C ラッピング
- W : DiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;)→V×C×M ラッピング
- W : AcDiKl(L&lt;sub&gt;V&lt;/sub&gt;, R&lt;sub&gt;M&lt;/sub&gt;)→V×C×M ラッピング

&lt;h5&gt;スタンピング構成&lt;/h5&gt;

今日ずっと基礎にする圏C -- 背景圏、環境（アンビアント）圏。

+ なんらかのデータ型、データ領域が対象
+ なんらかの計算処理／計算主体が射
+ 計算処理／計算主体を計算エージェントと呼ぶことがある
+ 計算エージェントは内部と外部をわかつ境界を持っている
+ 入出力は、n-in m-out または、タプリングを許して 1-in 1-out

A∈|C|を固定して、次の圏を作れる。

- 対象は A×X の型のCの対象
- 射は、A×X→A×Y の形のCの射
- dom(f:A×X→A×Y) = X
- cod(f:A×X→A×Y) = Y
- compはfのcomp

この圏を &lt;sub&gt;A×&lt;/sub&gt;C、面倒だから A×C と書く（これはイイカゲン過ぎてヤバイ）。&lt;b&gt;[追記]&lt;/b&gt;(A×)C くらいで手を打つか？&lt;b&gt;[/追記]&lt;/b&gt;

ホムセットによる定義がいいかも。

&lt;h5&gt;関手J&lt;/h5&gt;

J: A×C→C

- J(X) = A×X
- J(f:X→C in A×C) = (f in C)

このJは現実的にどんな意味があるか？

- X→Y が、Cでは A×X→A×Y ってことは、、、
- クラス定義を固定しての、、、
- ×××を素朴な純関数計算で表してみると

&lt;h5&gt;数式と現象&lt;/h5&gt;

- 二次関数を学び、ちゃんと使える人はたくさんいる。
- その二次関数で、「投げたボール」を記述できて、到達点を計算できることを知らない人はたくさんいる。
- 小中学校の素材のなかにも、あれだけ圏が発見できる。
- プログラミングやシステムの「現象」に、圏やモナドが含まれてないハズはないでしょ。どう考えても。
- ヒープ（共有領域）もスタック（プライベート領域）も、参照引数も値引数も、イミュータビリティもディープコピーも、クラスとオブジェクトも、単一代入も、DIも、総称関数も依存型も、当然に圏論で現象記述（定式化）できるよ。当たり前だ。

&lt;h5&gt;今日のモノイドさん、モナドさん&lt;/h5&gt;

+ 有限カウンタ 0から9  有界 →[http://d.hatena.ne.jp/m-hiyama-memo/19990801/1249450073:title]
+ 有限カウンタ 0から9  サイクリック（ラップアラウンド） →[http://d.hatena.ne.jp/m-hiyama-memo/19990801/1249450074:title]
+ 出力モードのテキストファイル
+ タートルグラフィックス ペンなし →[http://d.hatena.ne.jp/m-hiyama-memo/19990801/1249450075:title]
+ タートルグラフィックス ペンあり

- 状態値と作用値と遷移
- あるいは、位置と力と運動

&lt;h5&gt;それっ、クライスリ圏&lt;/h5&gt;

実例で考えると、状態空間への更新リクエストAPIを使う関数だよね。

&lt;h5&gt;ラッピングを使ってみよう&lt;/h5&gt;

- オブジェクト指向風の実行環境の上で実装するってことだね
- アンラップできるところがミソ
- アンラップがあるので、ラッピングは単射（埋め込み）
- 既にクライスリ圏を作っているので、ラッピングは関手だと言っていい

&lt;h5&gt;ラッピングを先に考えると&lt;/h5&gt;

Dがマグマ、Cが圏、F:D→C という対応があり：

+ Fは単射
+ Fはマグマの結合演算を保つ

このとき、Dは半圏であり、Fは半関手。

さらに、Dが反射的マグマ、Cが圏、F:D→C という対応があり：

+ Fは単射
+ Fはマグマの結合演算を保つ
+ Fはマグマの恒等を保つ

このとき、Dは圏であり、Fは関手。

以上の事実を使って、クライスリ圏を構成してみよう。

&lt;h5&gt;余クライスリ圏&lt;/h5&gt;

対角コモノイドのコモノイダル・スタンピング・モナドから、反射的マグマを作り、
余クライスリ圏も作ってしまえ。

&lt;h5&gt;状態スタンピングはイマイチ&lt;/h5&gt;

ラッピングに近いことができるが、作用がどうなっているか外部からは予測できないので、アンラップできない。アンラップがないので単射性が示せず、埋め込み関手が構成できない。

もう少し工夫しないと。

&lt;h5&gt;ここらで愚痴を言っておきたい&lt;/h5&gt;

「… だーから右と左のハナシはいやなんだよなー」

- (a・b)*x = a*(b*x) 気持ちいい左作用
- (a・b)*x = b*(a*x) 気持ち悪い左作用
- x*(a・b) = (x*a)*b 気持ちいい右作用
- x*(a・b) = (x*b)*a 気持ち悪い右作用

前回（モニャドセミナー3）でも間違えたしよ。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090711/1247288729&quot;&gt;「理解をさまたげるモノ／誤解をまねくモノ、それと対処」&lt;/a&gt;のの「右と左、上と下、前と後」参照

&lt;img src=&quot;http://www.chimaira.org/img2/m4-module-action.jpg&quot; &gt;

&lt;h5&gt;加群（作用）の公理&lt;/h5&gt;

カウンタ、テキストファイル、タートルグラフィックスが例。

結合律を絵で表そう。

&lt;h5&gt;後はなりゆき &lt;/h5&gt;

クライスリ圏の一般論は&lt;del datetime=&quot;2009-08-05T20:08:41+09:00&quot;&gt;たぶんやらないと思うが、&lt;/del&gt; &lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;やらない。&lt;/b&gt;&lt;/span&gt;

&lt;h5&gt;後はなりゆき 2&lt;/h5&gt;

次の計算はアドリブでは不安だ。写真を載せておこう。

&lt;img src=&quot;http://www.chimaira.org/img2/m4-act-diKleisli-1.jpg&quot;&gt;

&lt;img src=&quot;http://www.chimaira.org/img2/m4-act-diKleisli-2.jpg&quot;&gt;

あと、双モノイド法則（&lt;del datetime=&quot;2009-08-05T20:08:41+09:00&quot;&gt;3種&lt;/del&gt;4種）が必要だが、それはアドリブ。

&lt;hr&gt;

&lt;h4&gt;ここから追加分&lt;/h4&gt;

&lt;h5&gt;ちょっと練習問題&lt;/h5&gt;

+ 値が{0, 1}だけの有界カウンタの標準的（常識的に自然な）オペレーション・モノイドを記述せよ。
+ モノイド{u, d}* （星はクリーニスター）から、すぐ上のオペレーション・モノイドへのモノイド射（準同型）を記述せよ。
+ 値が{0, 1}だけのサイクリック・カウンタの標準的オペレーション・モノイドを記述せよ。
+ モノイド{u, d}* から、すぐ上のオペレーション・モノイドへのモノイド射（準同型）を記述せよ。
+ モノイド{u, d}* ではなくて、&lt;b&gt;Z&lt;/b&gt;（整数）の足し算モノイドからのモノイド射を記述せよ。
+ モノイド{on, off, toggle}* から、End({0, 1})への常識的なモノイド準同型を記述せよ。
+ モノイド{on, off, toggle}* に関係を入れて、End({0, 1}) と同型なモノイドを作れ。
+ 平面格子内を動く、マウス・グラフィックスの状態空間とモノイドを定義せよ。

&lt;h5&gt;状態空間スタンピングがダメな理由&lt;/h5&gt;

+ モノイド作用が計算エージェント内に分離不可能に組み込まれている
+ アンラップできない
+ 作用の取り替えができない
+ よって、柔軟性が低い

&lt;h5&gt;作用の取り替え&lt;/h5&gt;

- モノイド作用のモノイドの取り替え
- モイイド作用の状態空間の取り替え

状態空間Sの標準モノイド＝End(S)、作用の取り替え定理が成立する。

- a:M×S→S が作用で、f:N→M がモノイド射（モノイドの圏の射＝モノイド準同型）のとき、新しい作用b:N×S→S が定義できる。
- a:M×S→S が作用構造で、g:T→S, h:S→T が射（背景圏の射）で、ある条件を満たす&lt;del datetime=&quot;2009-08-06T13:35:16+09:00&quot;&gt;なら&lt;/del&gt;なら、新しい作用c:M×T→T が定義できる。

&lt;h5&gt;モナディックなクラアント／サーバー・アーキテクチャ&lt;/h5&gt;

構成要素は：

- クライアント側ライブラリ（便利関数群）
- リクエスト・チャンネル
- リクエスト・プロトコル
- オペレーション・モノイド
- アクション実装
- 状態空間

| クライアント側計算エージェント | クライスリ射 |
| リクエスト発行チャンネル       | クライスリ射のスタンピング出力成分 |
| リクエスト・キューイング（累積）| モノイド演算（乗法） |
| 累積されたリクエスト           |  モノイドの元 |
| リクエスト実行（アクション）   | モノイド作用 |
| 状態空間                       | モノイドの被作用域（加群の台）|


&lt;h5&gt;モノイダル・モナディックなクラアント／サーバーのメリット&lt;/h5&gt;

+ トランザクション内での遅延が可能。
+ トランザクション単位での取り消し（巻き戻し；逆操作ではない）が可能。
+ 状態空間を取り替えることができる。
+ 状態空間に直接作用するモノイドを取り替えることができる。
+ 状態空間と作用を準備してない状況でも実行できる。（自明状態空間）
+ リクエストの集約、圧縮、最適化ができる。
+ 複数の「状態空間＋作用」を直列につなぐことができる。
+ リクエストの分岐ができる。並列処理ができる。
+ サーバー側を変更しても、クライアントコードを一切変更する必要がない。
+ よって、クライアントコードの再利用ができる。


</body>
</day>
<day date="1999-08-03" title="">
<body>
*1249515663*[M4][Mx]そういえば先生は言っていた、基本は大事だと

「[http://d.hatena.ne.jp/m-hiyama-memo/20090801/1249094276:title]」と「[http://d.hatena.ne.jp/m-hiyama-memo/20090805/1249461085:title]」を一緒にした。

&lt;h4&gt;Basic, Basic, Basic! なこと&lt;/h4&gt;

人生50年以上やって、やっと納得することもある。いやっ、これは若者に納得してもらわないと困ることなんだが、

- &lt;b&gt;学校の先生が言うことはけっこう正しい。&lt;/b&gt;

曰く：

- 基本が大事だ。
- 一見つまらなそうなことでも、おろそかにしないでやれ。

セミナーの経験から、次のようなことが確実に分かってないことが理解の大きな障壁になっている感じがする。

+ 単元集合（singleton set）ってなに？
+ 単元集合はいくつあるの？
+ 単元集合が同じってどういうこと？
+ 単元集合の元は何でもいいの？
+ どうやって単元集合の元を選ぶの？
+ 単元集合からの写像ってなに？
+ 単元集合への写像ってなに？
+ 単元集合と任意の集合の直積はどうなる？
+ 2つの単元集合の直積は？
+ 2つの単元集合の直和は？
+ 空集合はいくつあるの？
+ 空集合からの写像ってなに？
+ 空集合への写像ってなに？
+ 空集合と任意の集合の直積はどうなる？
+ 空集合と任意の集合の直和はどうなる？
+ 2つ(?)の空集合の直積は？
+ 2つ(?)の空集合の直和は？
+ 定数と関数は違うの？
+ 定数関数ってなに?
+ 定数関数が同じってどういうこと？
+ 関数の引数がないってどういうこと？
+ 関数の戻り値がないってどういうこと？
+ 戻り値がない関数を他の関数に合成できるの？
+ 引数がない関数に引数を渡せるの？
+ 引数を無意味に増やして（水増し）、ほんとに無意味じゃないの？
+ 引数を無視する関数って、役に立つの？
+ 計算は関数なの？
+ 関数は計算なの？
+ 計算式と関数って違うの？

あまりBasicじゃないけど：

+ 文（statement, sentence）とか指令（instruction）、コマンドとかも関数なの？
+ Lispのprognとか、Erlangの「,」ってダメなの？
+ さすがにprint文は関数じゃないでしょ？

&lt;h4&gt;偏見、誤解、曲解など&lt;/h4&gt;

次のような傾向がある。困ったことだとも言えるが、だいたいは致し方ないこと。

+ プログラミング言語を通してしか概念や現象を見られない。
+ ハードウェアとしてのコンピュータや、大粒度コンポネントからなるシステム構造などは、単一プログラミング言語では理解できないから、まったくダメ。
+ 関数とか変数とかも、プログラミング言語の定義しか見えてない。
+ モナドやクロージャも言語機能と思っている。
+ 早い段階で習った概念は強い刷り込みになる。
+ 集合／写像が強烈に刷り込まれているのは驚き。
+ 集合／写像に強く縛られているが、実はその概念は曖昧。
+ 写像を考えても、余域は考えてなかったり。
+ 写像の同一性もハッキリと意識してない。
+ 余域と像がゴッチャ。
+ X→Y のとき、X=Y のケースを考えない。考えられない。
+ X→X なんてないと思う。代入や状態遷移の定式化ができない。
+ 引数は、構文上の引き数だけだと思っている。
+ 戻り値は、構文上の戻り値だけだと思っている。
+ メモリの上書き変更は関数じゃないと思っている。
+ それゆえ、破壊的代入やデバイスとのIOは関数で定式化できないと思っている。
+ X→X は id&lt;sub&gt;X&lt;/sub&gt; しかないと思っている。
+ 写像は、単射か全射のどちらかだと思っている。
+ 集合圏で、cod(f)⊆dom(g) なら結合可能だと思っている。（致し方ない）
+ a|→f(a) と f:X→Y がゴッチャ。（致し方ない）
+ 関数そのものと、個別の値-値対応と、式が区別できない。（致し方ない）


</body>
</day>
<day date="1999-08-04" title="">
<body>
*1249532892*[M4][Mx]これは言いたい

モナド／コモナド関連の内容：

+ 加群の公理とその絵図法（作用には別なシルシを使うが吉）
+ 加群（アクション構造）の取り替え定理を絵算で計算すると
+ 取り替え定理を応用する
++ タートルの影
++ 実数オフセッティングを四捨五入する
++ 例外付き有界カウンター
+ 加群とクライスリ射とトランザクション（遅延コミット）
+ undo問題：ロールバックとインバースアクション
+ 直和スタンピング＝例外 、、、はマーイイカ

絵算のコツとココロ

+ ワイヤーのバンドリング／アンバンドリングはテキトー。
+ トポロジカルに
+ でも、上下左右は区別する
+ （僕の描き方で）横はリソース軸、縦は時間軸
+ ほんとはアニメーションなのだ！ 静止絵図では無理がある
+ ポアンカレ双対
+ グラフ書き換え系、(チェ/チャ)ンバー分割（division）

その他：

- 「マウス・グラフィックス」って言い方はないだろう。ゴキブリは？ ダメじゃ。

</body>
</day>
<day date="1999-08-29" title="">
<body>
*1251511893*[M4][cathand][型検査]Caty-Jcentric 型理論／型推論／意味論

&lt;h5&gt;形式系の微妙なところ&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090828/1251438577 より（竹内本を参考）

意味じゃなくて、もっぱら記号の話。

+ 定数とarity 0の関数
+ 関数と演算子
+ fooとfoo()の区別
+ 関数の引数渡しのバリエーション：可変引数、省略とデフォルト値、名前付き引数
+ 関数記号と関係記号の区別
+ ソートを入れるか、特に真偽値のソート
+ 真偽値のソートがあれば、関係記号も論理記号も関数記号じゃ

追記：

- 構文と意味の区別は実際にはエエカゲン、ちゃんとやる人は滅多にいない。
- ちゃんとやればめんどくさい、エエカゲンだと混乱する。いつものジレンマ！
- やるなら、オーバーバーよりは太いブラケットが便利。
- 意味に対するコード（1つに定まる標準の表現／名前）はゲーデル記法。

&lt;h5&gt;setoid with restriction predicate&lt;/h5&gt;

+ なんでsetoidか？ 「1 と 1.0 問題」 -- なんでもsetoid
+ setoid射 「1 と 1.0」のとき
+ setoid射 バッグ配列のとき
+ setoid射 dateを入れたとき -- 変わり続けるsetoid構造
+ なんで with restriction predicate か？ 「integer, number 問題」
+ type integer = number(isInteger = true);
+ enum [1, 2] ≡ number(enum = [1, 2]) 構文糖衣
+ integer, enum, スキーマ属性はすべて restriction predicateの例。

&lt;h5&gt;原子論理式&lt;/h5&gt;

|*  論理式   |* 意味   |* 記号の乱用 |
| x is T     | val[T](x)∈Val(T) | x ∈ T |
| S included T | Val(S) ⊆ Val(T) | S ⊆ T |
| S disjoint T | Val(S)∩Val(T) = &lt;b&gt;0&lt;/b&gt;| S ◇ T |

「S ◇ T」は単なる略記で問題ないが、「x ∈ T」は相当にヤバイ。「S ⊆ T」も極めて不正確だが許して。

&lt;h5&gt;tag関数とtags関数&lt;/h5&gt;

+ まったくの別物
+ 名前はtagだが、ほんとはタグとは限らない（暗黙タグも）
+ tagはインスタンス領域の全域関数
+ tagsは型表現に対して定義される（JSONインスタンスも型表現とみなせるが、でも）
+ x is T ならば、 tag(x)∈tags(T)

tags(T) が非空有限集合である型表現はプロパー（特殊でない）。

&lt;h5&gt;接頭辞&lt;/h5&gt;

接頭辞記法 α=&gt;T は説明のためだけに使う。

+ 予約語接頭辞：number, string, boolean, null, array, object, bag
+ 使用不可能：integer, tuple, list, enum, multi, その他の予約語
+ 特別扱い：any, never
+ 予約語ではないすべてのタグ名は接頭辞

tags(T) = {α} のときに限り、 α=&gt;T と書いてよい。

&lt;h5&gt;型推論の演繹系&lt;/h5&gt;

いずれは実装する。

+ 変数のない項（閉じた項）と変数のない論理式（文）だけを考える。
+ 仮定のない、絶対的な証明だけを考える。
+ 論理式は、原子論理式またはそれの連言に限る。
+ ホントの組み込み基本型は、number, string, boolean, null の4つだけとする。
+ 組み込み型と事前定義型（predefined type）は別。integerは事前定義型扱い。
+ 特別な型として、never, undefined, anyを使う。意味論では必須。
+ 関数形式型構成子は、array, object, bagの3つとする。
+ 演算子形式型構成子は、?, &amp;amp;, @name, | とする。
+ その他、制限述語。

変数のある項／論理式、仮定のある証明（この2者は相関している）もいずれは扱う。

&lt;h5&gt;外の圏と中の演算&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090828/1251436086 より：

JSON領域が含まれる外の圏に次の演算が入る。

+ (X, p)|(Y, q) := (X + Y, [p, q]) （[q, q]は余デカルトペア）
+ (X, p)*(Y, q) := (X×Y, p(*)q) （p(*)qは∧によるテンソル積）
+ (X, p)&amp;amp;(Y, q) := (X∩Y, p∧q)

JSON領域内では：

+ 制限された演算 |
+ キーを適当に決めてobject構成
+ 演算 &amp;amp;、ただし、結果的に X = Y となる。

曇ったスノーグローブ。

&lt;h5&gt;型推論のための定理&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090826/1251259922 より：

たいした内容ではないけど、名前を付けておこう。

+ タグ排他性の原理：α≠β ⇒ (@α A)∩(@β B) = &lt;b&gt;0&lt;/b&gt;
+ 単調性の原理：S ⊆T ⇒ tags(S)⊆tags(T)
+ ハテナ定理：正規形の式なら、一番外側の'?'で確定型か不確定型か判断できる。
+ ν（nu）定理：Tがプロパーなとき、ν(T) ≧ 1、ν(T) = n なら、Tはn成分のユニオンとして書ける。
+ 排他的包含の原理：(α=&gt;A) ⊆ (β1=&gt;B1 | ... |βn=&gt;Bn) ⇔ α = βi で (α=&gt;A) ⊆ (βi=&gt;Bi)

タグ排他性の原理は、もっともベーシックな事実。単調性の原理と排他的包含の原理は、そうなるように作りましょう、という指導原理。ν定理も指導原理に近い。が、ハテナ定理は定理だ。

&lt;h5&gt;型表現のハテナ正規化&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090826/1251259924 より：

+ A?? → A?
+ (A?|B) → (A|B)? など
+ A? &amp;amp; B → A &amp;amp; B など
+ A? &amp;amp; B? → (A &amp;amp; B)?
+ bag [A?] → bag [A] (ハテナ定理には不要)
+ @name A? → @name A (ハテナ定理には不要)

ハテナ定理に必要なのは、演算子?, |, &amp;amp; に関する正規化だけ。

&lt;h5&gt;項の計算&lt;/h5&gt;

+ ハテナ正規化は計算
+ 分配法則による展開は計算
+ &amp;amp; を下に押し込めて消してしまう計算

&amp;amp; の計算

+ array [Ai] &amp;amp; array [Bi] ⇒ array [Ai &amp;amp; Bi]
+ object {pi: Ai} &amp;amp; object {pi:Bi} ⇒ object {pi: Ai &amp;amp; Bi}
+ (bag [A]) &amp;amp; (bag [B]) ⇒ bag [A &amp;amp; B]
+ (@α A) &amp;amp; (@α B) ⇒ @α (A &amp;amp; B)

neverの計算

+ array [... never ...] ⇒ never
+ object {... never ...} ⇒ never
+ bug [never] ⇒ never
+ @α never ⇒ never
+ never &amp;amp; X ⇒ never
+ never | X = X 

anyの計算

+ any &amp;amp; X ⇒ X
+ any | X 制約違反

&lt;h5&gt;分解還元法による演繹系&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090827/1251338342 より：

Catyの型推論のために、分解還元法というのを考えた。シーケント計算とタブローの中間のような感じのもの。推論は逆向きに（結論から仮定へと）行われるので、次の用語を導入する。

- 分解図 -- 推論図（1ステップ）の逆
- 還元図 -- 証明図（nステップ）の逆

シーケントに対応するのは、有限個(n≧0)の原子論理式をカンマで区切った列。列式、または単に式と呼ぶ。列式のなかの原子論理式は次のいずれか：

+ 真であるとすぐに判断できる。
+ 偽であるとすぐに判断できる。
+ 分解できる。

「真であるとすぐに判断できる」原子論理式は、aを基本型記号（basic type symbol）だとして、a⊆a か a⊆any のどちらかの形。あきらかに偽の論理式は色々ある。

分解とは、列式のなかの1個の原子論理式に注目して、それを1個以上の別な原子論理式の集合（構文的にはカンマ区切り列）に置き換えること。分解が p→q1, ..., qk のとき、次の性質が成立している。

+ |= p ⇔ |= (q1∧...∧qk)
+ rank(p) ＞ rank({q1, ..., qk})

上の主張が確認できるためには、原子論理式に対する意味論が定義されていることと、rankが定義されていることが必要。

意味論は意味領域がないとしょうがないが、rank関数は構文的に定義される。

+ 基本型記号のrankは0
+ 型項（型表現）のrankは、含まれる型関数記号、型演算子記号の総数。
+ 原子論理式のrankは、左右のrankの和
+ 列式のrankは、原子論理式rankの最大値

分解図では、上の式と下の式が意味論的には等価で、下の式のほうが確実にランクが下がっていることになる。常に分解可能性が保証できれば、ランクはゼロに落ちるから、列式の決定可能性が（メタ）証明できる。

意味論を適切に構成すれば、完全性（complete = sound and adequate）が成立する。完全になるように意味論を組み立てる、ってのがホントウのところだけど。

以上の話は、述語pに対する λx:A.p というラムダ式の定義域Aの議論。領域計算と呼びたいが、領域が多用されているから、台領域（キャリア；carrier）計算とでもするか。台の計算をもとにして、その上のラムダ式の計算が可能となる。ラムダ式の計算のほうが制限（restriction）計算となる。制限の実体はスキーマ属性だから属性計算と呼んでもいいかもしれない。

&lt;h5&gt;分解還元法の分解図&lt;/h5&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20090827/1251349683 より：

u = undefined として、記号の乱用で u = {u}。ブラケット内の数値はランクが減少する量。

&lt;pre&gt;
●opt-right

          A ⊆ B+u
[u!∈A] -----------[-1]
          A ⊆ B

●opt-both
                A+u ⊆ B+u
[u!∈A, u!∈B] -----------[-2]
                 A ⊆ B

●object

  object {pi: Ai} ⊆ object {pi: Bi}
 ------------------------------------[-2]
       Ai ⊆ Bi  (i=1, ..., n)

●array

  array [Ai] ⊆ array [Bi]
 ------------------------------------[-2]
       Ai ⊆ Bi  (i=1, ..., n)

●union-left

  A|B ⊆ C
 ----------------[-1]
  A ⊆ C, B ⊆ C

●union-right

  α=&gt;A ⊆ (α=&gt;B | C)
 ----------------------[-1]
  A ⊆ B

●bag

   bag [A] ⊆ bag [B]
 --------------------[-2]
      A ⊆ B

●tagging

  @α A ⊆ @α B
 ----------------[-2]
   A ⊆ B

●intersection-right

  A ⊆ B &amp;amp; C
 ------------------[-1]
  A ⊆ B, A ⊆ C

●intersection-left

  α=&gt;A &amp;amp; α=&gt;B ⊆ α=&gt;C
 ------------------------------[-1]
      α=&gt;X ⊆ α=&gt;C 
&lt;/pre&gt;

最後の「α=&gt;X」のところをちゃんとやる必要がある。

それと次は「すぐに偽だとわかる」ケース。

&lt;pre&gt;
                 A+u ⊆ B
[u!∈A, u!∈B] -----------
                  false
&lt;/pre&gt;


</body>
</day>
<day date="1999-11-28" title="">
<body>
*1259391684*[Mx][まとめ]「晩に渋谷でパスタの会：双対編」アジェンダ＆資料

&lt;h5&gt;イントロはマジメに（＝ツマラナイ）予習復習だ&lt;/h5&gt;

記号に慣れてね。

+ A×B
+ A + B
+ &lt;b&gt;1&lt;/b&gt;と&lt;b&gt;0&lt;/b&gt;
+ id&lt;sub&gt;A&lt;/sub&gt; = A （よく使う、特に僕は）
+ f×K （id&lt;sub&gt;A&lt;/sub&gt; = A の応用）
+ f×g
+ f + K
+ f + g
+ &amp;lt;f, g&gt; と Δ
+ [f, g] と ∇ （ただし、∇は“足し算”の意味でも使う）
+ π&lt;sub&gt;1&lt;/sub&gt;, π&lt;sub&gt;2&lt;/sub&gt; （ただし、下添字も使うときは π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A, B&lt;/sub&gt; など）
+ ι&lt;sub&gt;1&lt;/sub&gt;, ι&lt;sub&gt;2&lt;/sub&gt;

- 参考： [http://d.hatena.ne.jp/m-hiyama-memo/20091124/1259050816:title]

計算（コンピューティング）の話をするとき、多くの場合：

+ 射は計算行為の&lt;em&gt;なんらか&lt;/em&gt;の単位
+ 域は計算開始前の資源状況の型（つまり制約だ！）
+ 余域は計算&lt;del datetime=&quot;2009-11-30T08:16:36+09:00&quot;&gt;開始&lt;/del&gt;終了後の資源状況の型（ホーアトリプルを思い出せ）
+ 射の方向は時間方向（過去から未来）と一致する。

くれぐれも、&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;特定プログラミング言語や常識的な計算機構に捕らわれないこと。&lt;/b&gt;&lt;/span&gt;

例：f:int→int, g&amp;#58;int→int の結合

f:int→int はこれ（特に 5|→f(5)）：
&lt;pre class=&quot;code&quot;&gt;
int x = 5; // 入力の初期化
int y; // 出力変数
{
 // xからyを計算するコード
}
&lt;/pre&gt;

g&amp;#58;int→int はこれ（特に 10|→g(10)）：
&lt;pre class=&quot;code&quot;&gt;
int y = 10; // 入力の初期化
int z; // 出力変数
{
 // yからzを計算するコード
}
&lt;/pre&gt;

(f;g):int→int はこれ：
&lt;pre class=&quot;code&quot;&gt;
int x = 5; // 入力の初期化
int z;  // 出力変数
{
 int y;
 // xからyを計算するコード
 
 // yからzを計算するコード
}
&lt;/pre&gt;

たいていは対象＝型に（射にも）モノイド積があり、その意味は：

- 計算資源を一緒にする／寄せ集めること； または
- 場合分けによる制御フローの分岐

&lt;h5&gt;ここらで愚痴と雑談&lt;/h5&gt;

- 「頭おかしい」と「頭たりない」
- なんでみんな「対象と射は何でもいい」ってことを忘れるかなーー、頭たりないんじゃないの？
- すぐに役立たなくても、現象と法則が見えることに意味があると思う。さもしい姿を見ると、差別用語を使いたくなる。

それはそうとして、圏論のココロのごく一部だが：

- 点、要素、値は射です。インスタンスの代わりにコンストラクタを考えるようなもの。
- 対象も射で代用できる（[http://d.hatena.ne.jp/m-hiyama/20070524/1179970746:title]）。カロウビ展開圏では、対象は親の圏のベキ等射だしね。
- つまり、キホン、射しかありません。
- これは、データより計算&lt;em&gt;行為&lt;/em&gt;を重視する考え方。行為には時間方向の向きがあるから、矢印で描きやすい。

&lt;h5&gt;右自明モノイドのスタンピングモナドのクライスリ圏&lt;/h5&gt;

復習。これ(↓)みりゃわかるだろ。

&gt;|javascript|
var g = 0; // 大域変数

// 副作用付きの関数（ベースの圏では射とみなしにくい）

function foo(x) {
 g = 3*x;
 return x + 1;
}

function bar(y) {
 g = y + 2;
 return y * 2;
}

// クライスリ圏の射

function Foo(x) {
  return [x + 1, 3*x];
}

function Bar(y) {
  return [y * 2, y + 2];
}

// クライスリ結合

function kl_comp(F, G) {
  return function(x) {
    var Y = F(x);
    var Z = G(Y[0]);
    var effect;
    if (Z[1] === undefined) {
      effect = Y[1]; // undefinedでもいい
    } else {
      effect = Z[1];
    }
    return [Z[0], effect];
  };
}

function kl_commit(Z) {
  if (Z[1] !== undefined) {
    g = Z[1];
  }
  return Z[0];
}

/*

&gt;&gt;&gt; var k = kl_comp(Foo, Bar)
&gt;&gt;&gt; k(1)
[4, 4]
&gt;&gt;&gt; k(2)
[6, 5]
&gt;&gt;&gt; k(3)
[8, 6]
&gt;&gt;&gt; k(4)
[10, 7]

*/
||&lt;

&lt;h5&gt;不純な計算とは&lt;/h5&gt;

不純は面白い、不純は楽しい。

+ 副作用（ストレージへのアクセス）
+ 未定義（必然的な部分性）
+ 例外（エラー報告と処理）
+ 非決定性（不確定な計算）
+ 大域脱出（goto, setjmp/longjmp）

僕の不純な問題意識：副作用とトランザクションと例外の関係をちゃんと理解したい。

&lt;h5&gt;今までやったこと&lt;/h5&gt;

+ カリー化の圏論的取り扱い（デカルト閉圏）
+ NJの小さなサブセットと型付きラムダ計算の対応（カリー／ハワード対応）
+ クラアントサーバースタイルの副作用（アクションモノイドによるモノイダルスタンピング・モナド）

&lt;h5&gt;どんなストーリーがありうるか&lt;/h5&gt;

+ 計算から線形代数へ（非決定性、コンパクト閉圏）
+ 計算から幾何へ（多次元フローチャート、計算的ホモトピーやタングルの圏）
+ 計算から論理へ（シーケント計算、証明図の圏）

どこを経由しても、同じ所に行き着くらしい。アブラムスキー、ジラール、バエズなんかがそう言っている。行き先はいわば、

- &lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;計算の幾何的代数&lt;/b&gt;&lt;/span&gt;（geometric algebra of computation）

近隣の地図：
| ＼   |* 自明な構造   |* 非決定性で自明な構造 |
| 直積 |  対角Δ       |  合併∨（∪）   |
| 直和 |  フォールド∇ |  公平な分岐∧   |

&lt;h5&gt;今日のキーワード&lt;/h5&gt;

檜山の造語が多い。ただし、すべて線形分配圏の議論に出てくる概念の言い換え。

+ 分離する直積（separating direct product）、分離する直和
+ 混合結合律、混合交換律
+ 分合律（dissociative, 線形分配律）
+ 東西南北双対性（近隣の地図）
+ 三項、四項のホム
+ シーケント計算

&lt;h5&gt;双対性&lt;/h5&gt;

[http://d.hatena.ne.jp/m-hiyama/edit?date=20091013:title] より。

これは、直積のコモノイド／モノイド双対性：

|* 参照    |* 更新 |
|DBを参照する | DBを更新する |
|クエリ     | 更新リクエスト |
|クエリの実行 | 更新のコミット |
|クエリ結果の使い回し | 更新リクエストのキューイング|
|イミュータブルなスコープ | トランザクション | 

これは類似性：

|* ストレージ更新 |* 線形代数 |
| 更新モナド  | スカラー体 |
|ストレージ   | ベクトル空間 |
|更新リクエスト | スカラー |
|リクエストの連接 | スカラーどおしの乗法 |
|コミット    | ベクトルとスカラーの乗法 |
|何もしない操作 | スカラーの 1 |
|矛盾を引き起こすリクエスト | スカラーの 0 |
|矛盾した（回復不可能な）状態 | ゼロベクトル |

これは、状態（大域変数とか）参照と例外の双対性：分かりにくかったので文言を修正した。

|* 状態              |* 例外 |
| 状態に依存する関数 | 例外を起こす関数 |
| 状態の大域的なセット&lt;del datetime=&quot;2009-11-28T16:01:24+09:00&quot;&gt;(例：注入)&lt;/del&gt; | 例外の最終的な捕捉 |
| 状態の生成と初期化  | 例外の握りつぶし |
| 状態を出力にダンプ       | 入力を例外としてスロー |
| 状態を参照も変更もしない | 例外を捕捉しない |
| 状態のコピー | 例外の集約（同一視） |

&lt;h5&gt;一般化クライスリ結合と分合律&lt;/h5&gt;

ライブでお絵描き。

&lt;h5&gt;最近考えたラムダ抽象（カリー化）の説明&lt;/h5&gt;

僕のヒモ計算を納得しない人も多いので、クロージャと遅延評価を使った説明を考えた。

- 値（要素）は三角で描く。射だけど。
- クロージャは値なので、三角で描く。
- が、三角のなかに四角（関数、計算）が入っている。
- クロージャ三角から足が二本。
- ヒモを束ねる留め金（clasp）も使う。
- 三角のなかの三角は環境（束縛）
- 面倒になると、三角が丸になっちゃうかも。
- 遅延評価を使えば、値と式はあまり区別しなくてよい。クロージャは値を運ぶ式と思う。ときに、クロージャと値を同一視。

- [http://d.hatena.ne.jp/m-hiyama/20080623/1214181815:title]
- [http://d.hatena.ne.jp/m-hiyama/20081001/1222826833:title]

+ カリー化すると、Λ(f) = f&lt;sup&gt;^&lt;/sup&gt; ができる。
+ Λ(f) に値を入れると、fのクロージャが出力される。
+ クロージャと残余引数をevalに入れると、evalのなかでf（のミニチュア）が環境を伴って起動する。
+ でもさ、これってヒモ計算と同じじゃん。
+ ヒモ計算では、クロージャに封入された計算（ミニチュアコピー）と元の計算をなんとなく同一視する。値という概念を一切使わない（だから、分かりにくかったのだろう）。
+ 大きなラムダを使った計算は、この状況をちゃんと表してるぞ。ザマーミロ。

&lt;h5&gt;シーケント計算&lt;/h5&gt;

古典論理のシーケント計算は、直積と直和を持つ圏の計算現象に対応する。含意があれば、指数（ベキ対象、随伴）を持ち、カリー化が可能。カリー化の双対が例外ハンドリングコードの構成。

|* シーケント計算の規則     |*   計算現象   |
|三段論法（カット）         |一般化クライスリ結合 |
|減（縮約、コントラクション）左|対角による引き戻しΔ&lt;sup&gt;#&lt;/sup&gt; |
|減 右                       |余対角による前送り∇&lt;sub&gt;#&lt;/sub&gt; |
|増（水増し、ティ(ン)ニング）左|射影による引き戻しπ&lt;sup&gt;#&lt;/sup&gt; |
|増 右                      |入射による前送りι&lt;sub&gt;#&lt;/sub&gt; |
| ∧右                      |デカルトペア |
| ∨左                      |余デカルトペア |
| →右                      | カリー化 |
| →左                      |例外ハンドリング |

含意の導入と消去（演繹定理）がラムダ抽象（カリー化）と評価（eval, apply）に対応することはよく知られているが、含意の左規則が例外処理に対応していることが指摘されるのは少ない（気がする）。

&lt;h5&gt;あとそれから&lt;/h5&gt;

非決定性を導入すれば、双積とテンソル積を持ったコンパクト閉圏の議論になる。これは、驚くほどに線形性と双対性を持つ。なぜか、ヒルベルト空間の圏とソックリ。物理との類似性が濃厚。非決定性がpossibilityという質的（二値的）評価しかしないが、量的評価としてのprobabilityを入れると物理になるのか？

フローチャートの変形の幾何は、結び目やタングルの話とつながる。変形の書き換え規則は、特異点の変化の前後を記述しているが、連続に補完すると、それは高次元のなめらかな変形の影であるらしい。フロベニウス法則や双代数法則は、確かに図形変形（の影）の記述になっている。結合律や単位律はいうまでもない。

ジラールは、相互作用の幾何（GoI）とか証明の力学とか言っている。彼は、論理現象をほとんど物理的な現象だと捉えているらしい。ジラールが、「cutなし証明＝データ」「一般の証明＝アルゴリズム」「cut消去＝計算」（意味としては実行）という用語を使っているのはそれなりの意味があってだろう。

- [http://d.hatena.ne.jp/m-hiyama/20080222/1203648686:title]
- [http://d.hatena.ne.jp/m-hiyama/20090406/1238979506:title]

シーケント計算（論理）と計算（コンピュテーション）の話では、そもそもシーケント推論規則が基本射のCPS変換（またはその双対）をベースにしている。否定に関しては、大域脱出（継続）との関係が指摘されている。CPS変換＝米田埋め込みを使って、gotoとsetjmp/longjmp の話ができたらいいなー、とか思ってます（現在まだ調査考案中）。

</body>
</day>
<day date="2000-01-01" title="">
<body>
*1180587337*[メモ法][日付管理]日付管理

このエントリーは 2000-01-01になっている。過去日付を使うさいには、ここに書き込む。

+ 1900-01-01 グロッサランダム
+ 1901-01-01 絵図リンク
+ 1902-01-01 オフライン文献
+ 1904-01-01 用語集-1
+ 1905-01-01 人物リンク
+ 1905-**-** 2005年の対応日付記事のまとめ
+ 1908-**-** 2008年の対応日付記事のまとめ
+ 1910-01-05 &lt;a href=&quot;/m-hiyama-memo/19100105&quot;&gt;Catyの型解析関係記事（100年前だ）&lt;/a&gt;
+ 1999-07-30 モニャドセミナー4, 5資料
+ 1999-11-28 モニャドセミナー6以降の資料

</body>
</day>
<day date="2005-12-23" title="">
<body>
*1135301465*メモ開始

第三のアカウントを取った(苦笑)。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/&quot;&gt;キマイラ飼育記 本編&lt;/a&gt;でも、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/searchdiary?word=%2a%5b%db%d8%bb%b3%cd%d1%a5%e1%a5%e2%5d&quot;&gt;「檜山用メモ」という分類カテゴリー&lt;/a&gt;を設けているけど、これが多いと雑音になる。それでメモはこっちに書くことにした。

&lt;a href=&quot;http://www.chimaira.org/&quot;&gt;キマイラ・サイト&lt;/a&gt;に&lt;a href=&quot;http://www.chimaira.org/docs/Glossarandom.htm&quot;&gt;グロッサランダム&lt;/a&gt;ってのを書いていた時期もあるのだけど、これも続かない。

ほうってある http://chimaira.g.hatena.ne.jp/m-hiyama/を使おうかとも思ったが、プレビューを使えないのがやだ。で、結局、http://d.hatena.ne.jp/m-hiyama-memo/に書くことに。

内容的には、僕しか見ることはないだろうからプライベートでもいいのだが、他人が見て都合が悪いことも何もないのでパブリックにする。が、他人が読むことは考慮しない。typoも気にしない。表現も無頓着。

*1135302114*[indexed/fibred圏][余代数][メモ法]「多項式関手と添字化」って何だこれ？

「多項式関手と添字化」ってタイトルの書きかけ文書を見つけたのだが、自分でも、何を考えて何を書こうとしたかサッパリわからない。

書いてある断片を見ると： F:C→Cというendo-functorがあると、F代数の圏Alg(F)とF余代数の圏Coalg(F)が定義できる。2変数関手G:X×C→Cがあって、U∈|X|を固定すると、G&lt;sub&gt;U&lt;/sub&gt; = G(U, -):C→Cが定義できるから、Alg(G&lt;sub&gt;U&lt;/sub&gt;)とかCoalg(G&lt;sub&gt;U&lt;/sub&gt;)が定義できる。ここで、Uを動かすと、U |→ Alg(&amp;#40;G&lt;sub&gt;U&lt;/sub&gt;))の対応は、X上のindexed categoryを定義するだろう、ってことだ。Alg(&amp;#40;G&lt;sub&gt;U&lt;/sub&gt;))をAlg&lt;sub&gt;G&lt;/sub&gt;[U]と書くと、indexedな感じが出る。

が、これは特に多項式関手に特有な現象ではない。それと、代数と余代数を一緒に考えると何かいいことあるのか？ 教えて、過去の僕よ。うーん、何も思い出せん。何か思いついたら、アイディアの核心だけでも書き留めておくべきだな。

そんなことがあったのも、メモをちゃんと書こうとした動機。

*1135304733*[論理]抽象証明系

証明可能性関係 |- を外から見て公理化したい。とりあえず：

+ f∈A ならば、 A|-f
+ 任意のg∈Bが A|-g であり、B|-hならば、A|-h

この2つは必要だろう。A、Bともに論理式（その全体はL）の集合のとき、A|-Bを、「任意のg∈Bに対してA|-g」として、|-の定義を拡張しておく。

+ A|-A
+ A|-B,  B|-C ならば、A|-C

はいえる。最初の定義の言い換えに過ぎない。関係|-はプレ順序になる。これから同値関係を定義して、順序にできる。

集合Aに対して、A~ = {f∈L | A|- f}として演算子~を定義する。

+ A⊆B ならば、A~⊆B~ （単調性）
+ A⊆A~ （増大性；isotonic）
+ A~~ = A~ （ベキ等性）

最初は、次のほぼ自明な補題と同じ。

- A⊆B、A|-f ならば、B|-f

A⊆Bと「f∈AならばA|-f」から、B|-Aが出る。B|-A, A|-fからB|-f。

2番目は、「f∈AならばA|-f」の言い換え。

3番目； A⊆A~と単調性からA~⊆A~~は言えるから、A~~⊆A~が問題。つまり、「A~|- fならばA|-f」のことだが、A|-A~ は定義から出るから、A~|-fと組み合わせて、A|-f。

これら3つの性質を持つ演算子は&lt;strong&gt;Moore閉包&lt;/strong&gt;というそうだ。

一般化して、論理式（と呼ばれる何か）の集合LとPow(L)上のMoore閉包の組を&lt;strong&gt;証明系&lt;/strong&gt;として定義してよいだろう。

*1135305693*[論理]Moore閉包から抽象証明系

(L, ~)がMoore閉包を持った集合として、A|-Bを &lt;em&gt;B⊆A~ として定義する。&lt;/em&gt; とくに、A|-{f} をA|-fと書く。つまり、A|-f ⇔ f∈A~。

これで、「B⊆AならばA|-B」と「A|-B,  B|-C ならば、A|-C」を示してみる。「B⊆AならばB⊆A~」は「A⊆A~」から明らか。B⊆A,  C⊆B~のとき、単調性とベキ等性から C⊆B~, B~⊆A~ となるから、C⊆A~、これは A|-C。

「B⊆AならばA|-B」で、B={f}と置けば、「f∈A ならばA|-f」が出る。「A|-B,  B|-C ならば、A|-C」で、C={h}と置けば、「任意のg∈Bが A|-g であり、B|-hならば、A|-h」となる。

結局、&lt;em&gt;Moore閉包は証明系の性質をうまく反映している&lt;/em&gt;ことになる。（Moore閉包って、モナドだし。）

*1135314491*[論理][インスティチューション]証明系付きインスティチューション

証明系を抽象化する目的は、証明系をインスティチューションに組み込みたいから。

Moore閉包を使う定式化もいいのだけど、集合に対する関係|-を基本とすることにする。A|-Bのインフォーマルな意味は、「Aの論理式を全部仮定すれば、Bのどの論理式でも証明できる」。その性質は：

+ A⊆B、A|-C ならば、B|-C （水増し法則）
+ A|-B, B|-C ならば、A|-C （推移性）

インスティチューション(Sign, Sen, Mod, |=)に関して、Senの定義を変更して、σ:Σ→Γ in Signに対して、Sen(σ):Sen(Σ)→Sen(Γ)は単なる写像ではなくて、f:Pow(Sen(Σ))→Pow(Sen(Γ))であって、次を満たすとする。

+ A⊆B ならば、f(A)⊆f(B) （単調）
+ f(∪A&lt;sub&gt;i&lt;/sub&gt;) = ∪f(A&lt;sub&gt;i&lt;/sub&gt;) （∪の保存）

2番目（∪の保存）はどちらかというと技術的な要請である。

充当関係 |= も、モデルMと文の集合Aに対して M|=A と定義される。インフォーマルには、「Aのどの文も、Mに対して妥当」ということ。

この状況で、Pow(Sen(Σ))に2項関係|-があって、次の性質を持つとする。

+ σ&lt;sup&gt;*&lt;/sup&gt;N |= A ⇔ N |= σ&lt;sub&gt;*&lt;/sub&gt;A （充当関係）
+ A|-B ならば、σ&lt;sub&gt;*&lt;/sub&gt;A|-σ&lt;sub&gt;*&lt;/sub&gt;B （証明関係の保存）
+ M|=A, A|-B ならば、 M|=B （健全性）

A⊆Sen(Σ)が閉じていることは、「A|-B ⇒ B⊆A」で定義できる。

で結局、証明系付きインスティチューションは(Sign, Mod, Sen, |=, |-)で、いま述べたような性質を持つものとして定義する。

これから簡単に、証明の借用（borrowing）ができることを示せる。

- σ&lt;sup&gt;*&lt;/sup&gt;N |= A, A|-B ⇒ N |= σ&lt;sub&gt;*&lt;/sub&gt;B
- N |= σ&lt;sub&gt;*&lt;/sub&gt;A, σ&lt;sub&gt;*&lt;/sub&gt;A|-σ&lt;sub&gt;*&lt;/sub&gt;B ⇒ σ&lt;sup&gt;*&lt;/sup&gt;N |= B


</body>
</day>
<day date="2005-12-24" title="">
<body>
*1135397834*[モナド][圏一般論]Fock関手

圏Cに直積・直和などがあって、+, ×, 1, 0などに意味があるとする。この状況を抽象化すれば、ringoidal（または semiringoidal）圏とかも定義できるだろう。ま、それはいいとして、C上の多項式関手の概念があるとき、F(X) = 1 + X + X^2 + ... という級数で関手が定義できることがある；もちろんω余極限は必要だが。

具体的ケースとして、集合圏ではF(X)はXのクリーネ・スターになるし、ヒルベルト空間の圏（×はテンソル積）ならFock空間となる。Fをendo-functorと考えれば、C上のモナドになっている。しかし、FからKleisli圏を作ってみても、なんだか面白くない。方向性が間違っているのか？

Sが遷移系の状態空間のとき、SのFock空間（と呼ぶことにした）F(S)は確かに役に立つ。{S1, ..., Sn}のような状態空間の有限集合を考えると、多変数の対称級数から定義されるF(S1, ..., Sn)も多体系の状態空間として必須と言ってよい。単体遷移系から多体遷移系を作り出すオペレーションとしてFock関手（Fock空間の関手化）を考えたほうがいいのかもしれない。-- しかし、Fがモナドであることが使われないのも、それはそれで不自然のような？

遷移系の状態空間の場合を調べてみようか。

</body>
</day>
<day date="2005-12-26" title="">
<body>
*1135592087*[論理][計算]帰納構造

帰納性の公理化はないのかな？ あってもよさそうだが。自然数に対してしか帰納関数を定義できないのは不便だ。

</body>
</day>
<day date="2005-12-27" title="">
<body>
*1135675743*[論理]極大と無矛盾は冗長表現ではなかった

辞書的に使っている『情報科学における論理』を調べてみたら、「極大無矛盾」の定義に関して、僕が誤解していたようだ。（誤解していたのではなくて、用語法が2種類以上あるのかもしれない。）

まず、矛盾（無矛盾）の用法を並べる：

+ 公理系Aが矛盾する：A|- false
+ 公理系Aが矛盾する：A|- f かつ A|- ￢f
+ セオリーTが矛盾する：T = L （Lはすべての論理式）
+ セオリーTが矛盾する：false∈T
+ 公理系or証明系が矛盾する：{証明可能論理式}∩{反証可能論理式}≠空
+ 論理式の集合Aが矛盾する：Aはモデルを持たない。

1番目と2番目は、false≡f∧￢f なら区別する必要はない、単に言い方の違いに過ぎない。3番目と4番目も「false∈T ⇒ T = L（Lは全体）」のもとで同じこと。5番目は、2番目を外延的表現で言い換えたもの。最後の矛盾概念は異質で、モデル論的な概念（構文論／証明論だけでは定義不可能な概念）。

さて、A、B⊆Lがあるとき、&lt;strong&gt;対(A, B)が無矛盾&lt;/strong&gt;、または&lt;strong&gt;AがBに対して無矛盾&lt;/strong&gt;であることを次のように定義する（この定義は、『情報科学における論理』のものと少し違う。）

- 任意のb∈Bに対して、A |- b ではない。(Bのどんな論理式もAから証明できない。）

まず、「A |- b でない（bはAから証明できない）」ならば、「&amp;lt;A&gt; |- b ではない」となるので、Aは、必要があればセオリーに拡張（またはセオリーと仮定）しても問題はない。

B={￢f | f∈A}（BはAに属する式の否定の全体）とすれば、AがBに対して無矛盾なら「f∈A ならば、A |- ￢f ではない」となる。これから、「f∈A かつ A |- ￢f」となるfの存在を否定できる。よって、特にAがセオリーなら普通の（肯定／否定が共に証明できることはない、という）意味で無矛盾となる。

B={false}とすれば、セオリーAがBに対して無矛盾なことはfalse!∈Aと同じことで、これもセオリーAが無矛盾であることの表現になっている。

今度は、B={f | f!∈A}と置く（!は否定）。このケースでは、「f!∈A ならば、A |- f ではない」となり、単にAがセオリーであること（の対偶）になる。

AがBに対して無矛盾であり、A∪B = L （Lは全体）のとき、無矛盾な対(A, B)は&lt;strong&gt;極大&lt;/strong&gt;と呼ぶ。セオリーAとその補集合の対は極大無矛盾な対となる。セオリーAとAの論理式の否定を集めたBが極大無矛盾になるとは限らない。これが極大になるとき、Aは構文論的に完全（決定性を持つ）で、これまた通常の意味でAは極大。

A&lt;sup&gt;c&lt;/sup&gt;はAの補集合、A&lt;sup&gt;￢&lt;/sup&gt;をAの否定を集めた集合と約束して、以上をまとめると：

- Aは任意、(A、A&lt;sup&gt;c&lt;/sup&gt;)が無矛盾 ⇔ Aがセオリー
- Aはセオリー、(A、A&lt;sup&gt;￢&lt;/sup&gt;)が無矛盾 ⇔ A|-fかつA|-￢fでないので、Aは無矛盾セオリー
- Aはセオリー、(A、{false})が無矛盾 ⇔ false !∈A で、Aは無矛盾セオリー
- Aはセオリー、(A、A&lt;sup&gt;￢&lt;/sup&gt;)が極大無矛盾 ⇔ Aは決定性を持ち、通常の意味で極大。

セオリーAの&lt;strong&gt;Bに相対的な無矛盾性&lt;/strong&gt;は、Bの取り方で色々な概念を導けるといえる。(A, B)が極大無矛盾のとき、A∩Bは空（そうでないと無矛盾にならない）であり、&lt;strong&gt;対の極大性はAが決定性を持つ（構文的完全である）ことと同じ&lt;/strong&gt;である。

&lt;b&gt;[追記]&lt;/b&gt;&lt;br&gt;「AがBに対して無矛盾」を形式的に書けば ∀b. b∈B→￢(A |- b)。あるいは、書き換えて ∀b. ￢(b∈B)∨￢(A |- b)。

BがL（全体）のときはb∈Bが常にtrueだから、∀b. false∨￢(A |- b)、∀b. ￢(A |- b) となる。つまり、「Aが全体に対して無矛盾」のときは「Aは何も証明できない」。つまりはAが空であることを意味する。

Bが空の時はb∈Bが常にfalseだから、∀b. true∨￢(A |- b)。つまり、「Aが空に対して無矛盾」は恒真である。いかなるAも空に対しては無矛盾。&lt;br&gt;&lt;b&gt;[/追記]&lt;/b&gt;

「飽和」（saturate）という言葉もあったようが気がするが、正確な定義は憶えてないなぁ。極大と同じだったような気もするが、構成的なんだっけ？ 今はあんまり使わないのかな、飽和ってのは。


</body>
</day>
<day date="2005-12-31" title="">
<body>
*1135984624*[余代数][具体例]リストとスタック

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135302114&quot;&gt;忘れてしまう件&lt;/a&gt;、メモに動機や例を書いておかないのが&lt;em&gt;いけない&lt;/em&gt;のだと思った。そのときは、具体的な事例で考えているので自明に見えることでも、その例がなくなるとサッパリわからなくなる。

&lt;h5&gt;リストとスタックの関係&lt;/h5&gt;

で具体例。Lispのリストのようなものを考える、ただし再帰構造は考えないで、基本的な値の領域はAとする。S=A&lt;sup&gt;*&lt;/sup&gt;と考えてよい。
&lt;pre&gt;
nil:1→S
cons:A×S→S
car:S→A
cdr:S→S
&lt;/pre&gt;

一方、Aのスタックを考えると：
&lt;pre&gt;
Stack:1→S （コンストラクタ）
push:S×A→S
top:S→A
pop:S→S
&lt;/pre&gt;
細かいことを言わなければ、これは&lt;strong&gt;同型&lt;/strong&gt;。

（非再帰の）リストからcarを除くと：
&lt;pre&gt;
nil:1→S
cons:A×S→S
cdr:S→S
&lt;/pre&gt;

スタックからコンストラクタを除くと：
&lt;pre&gt;
push:S→S&lt;sup&gt;A&lt;/sup&gt;
top:S→A
pop:S→S
&lt;/pre&gt;

この状況で、リストは、1次多項式関手F(X)=1+A+Xの代数、スタックは一般ベキ単項式関手G(X)=A×X×X&lt;sup&gt;A&lt;/sup&gt;の余代数である。

おおざっぱに言えば、リストは代数でスタックが余代数、そして同型となる。だが、正確に言えばそうではない。この「おおざっぱな主張」と「正確な主張」の差をキッチリと説明できないか？ それが問題意識。

&lt;h5&gt;代数対&lt;/h5&gt;

上の議論で、リストのcarとスタックのコンストラクタは邪魔なので除いた。が、考えないわけにもいかないので、やっぱり入れておく。

&lt;pre&gt;
nil:1→S
cdr:S→S
cons:A×S→S
-----------
car:S→A
&lt;/pre&gt;

&lt;pre&gt;
Stack:1→S （コンストラクタ）
-----------
top:S→A
pop:S→S
push:S→S&lt;sup&gt;A&lt;/sup&gt;
&lt;/pre&gt;

carは定数関手C(X)=Aの余代数、コンストラクタは定数関手I(X)=1の代数である。この例から両代数（dialgebra）を考えてもよいが、まずはそのまんまの定式化：

- F, GをC上のendo-functorとして、F代数α:F(S)→S と G余代数β:S→G(S)の組(α, β)を&lt;strong&gt;代数対&lt;/strong&gt;と呼ぶ。

しかし、普通に射（準同型）を定義すると、リストとスタックの同型は定義しようがない。代数+余代数に分解可能な両代数の範囲で考えるか、あるいは、1次多項式関手と一般ベキ単項式関手を特論的に扱うか？

*1135988082*[論理]モデルの仮構性と有効性

「モデルが在る」ことは、フィクションあるいはファンタジーだと言えるだろう。誰も存在を保証できない。実際にモデルを作るには、構文領域をいじくる以外に方法がない。つまり、「構文に先立ってモデルの世界が在る」ということは全然言えなくて、「構文領域があれば、モデルらしきものを作れる」というのが現実だ。

だからモデルなんて考えても無駄か、というと、そうではない。モデルの世界があると考えるほうがなにかと便利だし、精神衛生上もよい。モデルは、&lt;strong&gt;有効なファンタジー&lt;/strong&gt;なのだ。


</body>
</day>
<day date="2006-01-03" title="">
<body>
*1136265640*[圏一般論][プログラム意味論]変数圏、係数（指数）圏、多項式関手

非常に予測できた事態（日本語変？）だが、飼育記本編よりメモ編のほうが書きやすい。本編は他人が読むであろうことを一応は仮定しているから、「あけましておめでとうございます」とか書き始めるべきかとプレッシャー(?)がかかる。

僕にとって新年なんてどうでもいいのだ。だいたいにおいて、切れ目とか記念とか土産物とかにまったく興味がない。ハレもケもなく、のんべんだらりの日々が続くのが一番安心できて一番好きだ。そして、一本道が地平線に消えるように死んでしまうのを期待している。

&lt;b&gt;まー、それはそうとして、&lt;/b&gt;&lt;br&gt;また&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135302114&quot;&gt;忘れてしまう件&lt;/a&gt;。断片メモを見ながら、「俺はいったい何を考えていたのだ？」と考えている。これは、僕の頭のなかに強力な忘却関手が作用していることを意識する作業であり、忘却関手のadjointを構成しないと、無構造な砂漠のような頭になることに対策する作業でもある。

二変数関手F(-, -)を考えるのは、「係数と変数」のようなことを考えたいからだったのだと思う。A×X×Xとか、X&lt;sup&gt;A&lt;/sup&gt;とかの単項式を考えると、係数（ベキ指数も含める）の圏を、変数の圏と別に考えたほうがいいだろう。記号を以前と逆にして、Xが圏でCがその部分圏とする。C係数の多項式をXのendo-functorと考えることは自明にできる。が、CがXとは独立だとすると、X上のC作用を明示的に考える必要がある。Cがモノイダルで、作用もモノイダルなら：

- I*U = U （作用の単位律）
- (A×B)*U = B*(A*U) （作用の結合律）

は要請されるだろう。ここで、*が作用で、“×とI”がCのモノイド構造を与えるとしている。もちろん、作用は関手に拡張できるとしている。

変数（主な定義域）圏Xに複数の係数圏C1, C2, ...が作用しているような状況では、C1×C2×...×X→Xのような多変数“多項式”関手が定義できて、係数固定でendo-functorが定義できるから、endo-functorに特有の概念；代数／余代数／モナドなども考えられる。とりあえず、2つの係数圏が、積因子、ベキ指数のごとくに作用している状況で多項式を定義して、その多項式がindexed categoryを定義することを確かめ、平坦化を実行してみる、とそんな目論見だろう。

ベキ指数として作用を定義するには、単なるモイイド圏では難しい。EP圏のような順逆対がないと定義できそうにない。しかし、係数（指数）圏がEP圏であるという仮定は、プログラム意味論としては自然だとも言える。例えば、逆極限法を適用できるのはEP圏だからね。

*1136265782*[論理]接触、爆発、崩壊

論理式の全体をF（formula）として、それに証明系が付いていているとする。証明可能な論理式の全体をP（provable）、反証可能な論理式の全体をR（refutable）とする。

P∩R≠空 のとき、PとRは&lt;strong&gt;接触&lt;/strong&gt;すると言えるだろう。そのとき、通常の証明系では、P=F、R=Fとなってしまう。これはPとRが&lt;strong&gt;爆発&lt;/strong&gt;してしまう、と表現できる。その後は、真偽の区別もなく、すべてが真でもあり偽でもある（したがって、すべてが真でもなく偽でもない）という状態で、論理系は&lt;strong&gt;崩壊&lt;/strong&gt;している。

矛盾の発生＝接触が恐ろしいのは、接触がすなわち爆発を意味し、爆発によりすべては無に帰す、崩壊するからだ。これは怖い。矛盾は致命的／壊滅的なダメージを与える。何も生き残れない。

*1136269196*[論理]「無矛盾かつ健全」は変だ

まっとうな論理系（証明系＋真偽割り当て）の条件として「無矛盾かつ健全」があるが、これはなんだか変な気がしてきた。無矛盾性と健全性は全然レベルが違う。並列にならべて議論すべき概念ではない。

健全を定義するには真偽概念がないといけない。そのためには、論理式の上に（少なくとも部分的には）真偽割り当てが存在しないといけない。矛盾する体系にどのようにして真偽割り当てすべきか。fと￢fに異なる真偽値を割り当てれば、どうやっても健全にはなりようがない（|- f かつ |- ￢fだから、偽な式を証明できる）。fと￢fに同じ真偽値を割り当てれば、真偽割り当てとして適切ではない。

つまり、矛盾する体系では、どうせ不適切な真偽割り当てしかできない、言葉を換えれば、適切な割り当ては存在しない。となると、そこで健全性を定義しても何の意味もない。つまり、無矛盾性を前提としてはじめて健全性が意味を持つ。「矛盾するが健全」なんて埒＜らち＞外だ。

+ 矛盾する体系では、適切な真偽割り当てが定義できない。無理に定義しても健全とはどうせ両立しない。
+ 真偽割り当てが存在する時点で、既に事実上、無矛盾性が前提されている。（矛盾する体系に、真偽割り当てがあっても、偽が証明され／真が反証される状況になる。）
+ 無矛盾（かつ非自明；証明できる式が1つ以上存在する）な体系なら、適切な真偽割り当てが（部分的には）定義可能である。
+ 真偽割り当てに関して証明系の健全性が定義できる。

ここでも、矛盾が論理系を&lt;em&gt;完全に破壊する&lt;/em&gt;という認識が重要。破壊されたら、健全もクソもない。

</body>
</day>
<day date="2006-01-05" title="">
<body>
*1136444972*[雑感][メモ法]ウギャ！

2ヶ月分の&lt;a href=&quot;http://www.chimaira.org/docs/Glossarandom.htm&quot;&gt;グロッサランダム&lt;/a&gt;を見ても、もう何のことかわからない（わかるのもあるけど）。1行コメントは実にお手軽でよいが、やっぱり備忘の役には不足だ。

もう、このメモを書き散らす（いや、けっこう丁寧に書く）しか、忘却関手から逃れるスベはないのか？


</body>
</day>
<day date="2006-01-06" title="">
<body>
*1136507200*[雑感]手が

デロンギ・オイルヒータ（優れもの）をメイッパイかけてるが、手がかじかんでキーボード打てんわ。サブ、sub杉。


</body>
</day>
<day date="2006-01-12" title="">
<body>
*1137055278*[トレース／コンパクト閉圏]工作圏論

東急ハンズで素材買ってくるか。矢印部分は薄い板をカッターで削ればいいか。線が問題だな、曲がらないといけないから紐か。たんなる紐だとストレートとターニングの区別がつかないし。実在の素材では無理？ でも、手で触りたい！！


</body>
</day>
<day date="2006-01-13" title="">
<body>
*1137110127*[圏一般論][具体例]指数の計算：2項（共変, 反変）関手性

今さら、こんなこと書いて、つう感じもするが、、、

Xはとりあえず集合部分圏だとしておく（X→&lt;b&gt;Set&lt;/b&gt;って忘却埋め込みがある）、CはXの適当な部分圏（Xでもよい）の&lt;em&gt;逆&lt;/em&gt;圏。k:A→B in Cは、k:A←B in Xとなる。対象U∈|X|, A∈|C|に対して、U^A = U&lt;sup&gt;A&lt;/sup&gt;とする。U^AはXのなかの関数空間（ベキ、指数）対象だから、|X|のなかで（upto-isoで）確定する。

以下では、記号を次のように使う。

- f:U→V in X
- g:V→W in X
- k:A→B in C i.e. k:B→A in X
- j:B→C in C i.e. j:C→B in X

f:U→Vと、k:A→Bに対して、f^k: U^A→V^B を次のように定義する：

a∈U^A、つまりa:A→U in Xに対して、b = (f^k)(a) = k;a;f : B→V in X 。
&lt;pre&gt;
  A ←k- B
 a|      |b
  |      |
  v      v
  U -f→ V
&lt;/pre&gt;

f^kは、U^A → V^B in Xとなる。^が2変項関手になることを示す。つまり、次を示す。

+ ^(id&lt;sub&gt;U&lt;/sub&gt;, id&lt;sub&gt;A&lt;/sub&gt;) = id&lt;sub&gt;^(U, A)&lt;/sub&gt;
+ ^( (f, k);(g, j) ) = ^(f, k);^(g, j)

中値記法を使えば：

+ id&lt;sub&gt;U&lt;/sub&gt;^id&lt;sub&gt;A&lt;/sub&gt; = id&lt;sub&gt;U^A&lt;/sub&gt;
+ (f;g)^(k;j) = (f^k);(g^j)

一番目は、次の図を見ながら、id&lt;sub&gt;U&lt;/sub&gt;^id&lt;sub&gt;A&lt;/sub&gt;(a) = id&lt;sub&gt;A&lt;/sub&gt;;a;id&lt;sub&gt;U&lt;/sub&gt; = a、id&lt;sub&gt;U^A&lt;/sub&gt;(a) = a なのでOK。
&lt;pre&gt;
  A ←== A
 a|      |a
  |      |
  v      v
  U ==→ U
&lt;/pre&gt;
二番目は、次の図を見ながら、
&lt;pre&gt;
  A ←k- B ←j- C
 a|      |      |
  |      |      |
  v      v      v
  U -f=→V -g→ W
&lt;/pre&gt;
- ( (f;g)^(k;j) )(a) = (j;k);a;(f;g) （右辺は in X）
- ( (f^k);(g^j) )(a) = (g^j)( (f^k)(a) ) = (g^j)(k;a;f) = j;(k;a;f);g
結合律で括弧を付け替えれば同じ。

以上で、C⊆X⊆&lt;b&gt;Set&lt;/b&gt;の状況で、^:X×C&lt;sup&gt;op&lt;/sup&gt;→X が2変項関手だとわかった。抽象的にベキ対象が存在する圏（例CCC）でやるなら、elementは使えないからelementless図式計算、メンド。

*1137121357*[圏一般論][具体例]指数の計算：指数法則

C⊆X⊆&lt;b&gt;Set&lt;/b&gt;の状況（具象圏のsetting）で、^:X×C&lt;sup&gt;op&lt;/sup&gt;→X が2変項関手であることはわかった。Cに積と和があるとき、次も成立。

+ f^1 ≒ f
+ f^0 ≒ 1
+ f^(k×j) ≒ (f^k)^j
+ f^(k + j) ≒ f^k×f^j

形式上は非常に単純で憶えやすいのだが、図式を追い回すだけだと混乱する。図式を横目でにらんで運算（カルク）したほうがいい。そのとき、なんか非形式的なラムダ計算をしている。ともかく、カリー化がことの本質だ。
&lt;pre&gt;
^ = λ(f, k).λa.λx.[f(a(k(x)))]
f^k = λa.λx.[f(a(k(x)))]
(f^k)(a) = λx.[f(a(k(x)))]
(f^k)(a)(x) = f(a(k(x)))
&lt;/pre&gt;

「図式をにらみながら非形式的な運算」という部分をもう少しなんとかできないものか？

*1137121490*[トレース／コンパクト閉圏][具体例]荷電境界付き有向グラフ

荷電境界付き有向グラフは、すごくいい例。面白いオモチャ。

なのに、僕はどこにも何も書いてない。まずい。これはまずい。非常にまずい。

*1137155549*[雑感]夜に、なにする

珍しく、夜まで人と会っていた。
&gt;&gt;
「図式をにらみながら非形式的な運算」という部分をもう少しなんとかできないものか？
&lt;hr&gt;
僕はどこにも何も書いてない。まずい。これはまずい。非常にまずい。
&lt;&lt;

子供は寝ちゃったろうから、
+ 非形式的な運算を形式化する
+ 荷電境界付き有向グラフについて書く
のどちらかをしてもいいのだが、先日しこたまマトメ買いした本を堕読（造語by檜山）しそうだ。

*1137156963*[雑感]なんで?!

ゲッ、堕読用の本が（少なくとも1冊）読んでないのにもうない。いったいどこにいったんだ？なんでこうなくなる？なくすんだ？ンッモーーーー！！！

</body>
</day>
<day date="2006-01-14" title="">
<body>
*1137191454*[雑感]続・なんで?!

なくなったは純堕読用本だが、買ってきてまさに読もうとしたらないから、異常に腹がたった。買い直そうか、、、それもまたムチャクチャ悔しいし。この紛失癖、なんとかならんのか、クッソーー。ムカムカムカムカ。

*1137197178*[圏一般論]運算

課題：カリー化がうまく表現できて、図式追跡と（比較的）対応した運算法。

けっちょうムズ。

非形式的な運算って、記号の乱用やオーバーロードを無闇と使っているから、切り分けるのが大変。



</body>
</day>
<day date="2006-01-16" title="">
<body>
*1137405632*[雑感]ネタなし

堕読（造語、ってシツコイ）ばっかりしていたいから、こっちに書くネタがない。ムー。


</body>
</day>
<day date="2006-01-18" title="">
<body>
*1137562767*[雑感][具体例][インスティチューション]面白い例

そういえば、インスティチューションの具体例って書いたことない。

お決まりの、フラグ、カウンタ、スタック。代数だと、半群、モノイド、線形空間（または加群）。

多項式全体もうまいことインスティチューションになる。

あと、なんか面白い例はないかいな。命題論理はつまらないか？

*1137573152*[論理]ヘンキン法？

ヘンキン（返金じゃなくて、Henkin）が使った方法が飽和法かな？

どうも飽和法の資料が少なくて、、、


*1137573483*[リンク][論理]フォーマルセマンティクス入門

http://www.lang.osaka-u.ac.jp/~ogata/fosema.pdf -- 「フォーマルセマンティクス入門」でかいPDFだ。飽和法あるかな？

</body>
</day>
<day date="2006-01-19" title="">
<body>
*1137644077*[リンク][論理][計算]一般化帰納関数

http://d.hatena.ne.jp/m-hiyama-memo/20051226/1135592087に関連、一般化された帰納構造、帰納関数に関する参考：

+ http://citeseer.ist.psu.edu/barthe03typebased.html 44P 長め
+ http://citeseer.ist.psu.edu/gimenez98structural.html 14P
+ http://citeseer.ist.psu.edu/128949.html 23P
+ http://citeseer.ist.psu.edu/598022.html 14P イマイチか？
+ http://citeseer.ist.psu.edu/geuvers92inductive.html 25P 有名
+ http://citeseer.ist.psu.edu/audebaud91partial.html 10P 短い

とりあえず、最後の2つを読むかな。

*1137660951*[リンク][論理][計算]有限モデル論

http://www.almaden.ibm.com/cs/people/fagin/tcs93.pdf

- title: Finite-model theory - a personal perspective
- 著者はRonald Fagin
- 30ページ

</body>
<comments>
<comment>
<username>酒井</username>
<body>&gt; 一般化帰納関数&lt;br&gt;&lt;br&gt;原始帰納法はuniversalityで一般化出来るので、あとは最小化をどうするかでしょうか。</body>
<timestamp>1137731771</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>“universality使う”ってのは？なにかreferenceがありますか。&lt;br&gt;最小化は自然数の順序に依存して定義されているから、何が本質なのか、よくわかりませんね。</body>
<timestamp>1137749558</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>結構一般的な方法だと思うので reference は沢山あると思いますが、例えば http://www.cs.ut.ee/~varmo/papers/thesis.pdf の chapter 3 とかはどうでしょうか。</body>
<timestamp>1137770484</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>どうもありがとうございます。覗いてみます。&lt;br&gt;んっ、レンズ括弧、これ嫌い。</body>
<timestamp>1137809310</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>僕も最初はレンズ括弧とか嫌いでしたが、だいぶ慣れました (^^;</body>
<timestamp>1137824989</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>凸レンズはバナナで、凹レンズはトゲだっつう説もあるよね。</body>
<timestamp>1137826759</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>(|ψ|) : バナナ&lt;br&gt;[(ψ)] : レンズ&lt;br&gt;[[ψ]] : envelope&lt;br&gt;&lt;[ψ]&gt; : トゲ&lt;br&gt;ですね。“Functional programming with bananas, lenses, envelopes and barbed wire.” http://research.microsoft.com/~emeijer/Papers/fpca91.pdf は、Wadlerに対抗してセクシーなタイトルにしようとしたらしいけど、正直すべってると思う...</body>
<timestamp>1137848484</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>あ、凹レンズが狭義のレンズですか。&lt;[]&gt;は外向き1つトゲで、[&lt;&gt;]は内向き2つトゲか。&lt;br&gt;XMLだって、CDATAセクションでトゲ括弧使っているぞ、ってのはヨタ話。</body>
<timestamp>1137977918</timestamp>
</comment>
</comments>
</day>
<day date="2006-01-20" title="">
<body>
*1137724144*[プログラム意味論][インスティチューション]ソースコードの形式化

http://d.hatena.ne.jp/m-hiyama/20060119/1137641539の「モゴモゴな話」に書いた件でメモ：

少し分かってきた（かな？）。まず、関連するエントリーは：
- http://d.hatena.ne.jp/m-hiyama/20050716/1121499351
- http://d.hatena.ne.jp/m-hiyama/20050719/1121756022
- http://d.hatena.ne.jp/m-hiyama/20050720/1121825875

↑ではKleisli構成を使っているが、もう一捻りして、Circ構成と組み合わせる。

&lt;h5&gt;Sign上のTermモナド&lt;/h5&gt;

Σを多ソート指標とする。Op(Σ)はオペレータ記号の集合、だが、f∈Op(Σ)をf∈Σと略記。適当な規則で、Σ上の自由変数を含まない項の集合Term(Σ)を定義する。

t∈Term(Σ)にもt:s1,...,sn→tのようなソート付けができるとする。ΣのソートにTerm(Σ)を一緒に考えると再び指標となる（無限指標も許す）。この指標も同じくTerm(Σ)と表す。TermはSign上の自己関手となり、さらにモナドである。

Sign上のTermモナドがプログラミング言語の定式化である。Sign自体はIDLのようなものだ。

&lt;h5&gt;circ-Kleisli構成&lt;/h5&gt;

Signは有限余完備とする。特に直和に関して対称モノイダル。

ΣとΓが指標のとき、α:Σ+Σ' → Term(Γ+Σ') in Signを新しい圏Progの射:Σ→Γと考える。Σ'はプライベート指標である。プライベート指標に関しての再帰ができる。α:Σ+Σ' → Term(Γ+Σ')とβ:Γ+Γ'→Term(Δ+Γ')の結合は、Σ+Σ'+Γ'、Γ+Σ'+Γ', Δ+Σ'+Γ' を考えて、適当に拡張した上でKleisli結合を作ればよい。

以上の構成は、対称モノイド圏上のモナドに関して実行できるだろう。特にIdentityモナドのときがCirc構成。通常のKleisli圏は、いま定義したcirc-Kleisli圏に埋め込める。

&lt;h5&gt;Prog圏&lt;/h5&gt;

Signから作ったcirc-Klseili構成で作った圏をProg(Sign)と書く。Termモナドも明示するなら、Prog(Sign, Term)。Prog圏の射を&lt;strong&gt;プログラム形式&lt;/strong&gt;と呼ぶことにする。

さて、問題はProg圏の意味論。Σにはモデル圏としてAlgΣ（無条件Σ代数の圏）が既に付いている。p:Σ→Γがあると、AlgΓの対象を実際に与えるとΣ代数を実際に構成できる（はず）。プログラム形式は、関手を定義する（関手意味論）。よって、SignとSign上のMod関手をProg(Sign)と拡張Mod関手に拡張できる。

しかし、Prog圏の構成から、代数のスパンとかがどっかで入る気もするが、、、要確認。

&lt;h5&gt;仕様との関係&lt;/h5&gt;

あとはSenの拡張。SenΣ、SenΓ上のセオリーと、ΣをΓを使って定義するプログラム形式Σ→Γとの関係が欲しい。証明系がないとあまり意味がないからπインスティチューションが登場するだろう。何かの事例で考えないと。

&lt;h5&gt;とにかく&lt;/h5&gt;

仕様、プログラムテスト、プログラム証明（ソースコードレビュー）、論理的証明（普通の証明）、ソースライブラリ／バイナリライブラリ、再利用（いろんな意味で）、正しさ(correctness)などの概念を定式化したい！ それで結局、コンポネントって何だろう？ コンポネントの圏を定義したーい！！


</body>
</day>
<day date="2006-01-21" title="">
<body>
*1137809681*[プログラム意味論][圏一般論]circ-Kleisli構成

circ-Kleisli構成を&lt;em&gt;きまじめに&lt;/em&gt;かつ一気に定義すると、かなり面倒。&lt;s&gt;circ-Kleisli構成＝Circ構成の&lt;em&gt;後に&lt;/em&gt;Kleisli構成だと思う。このことを確認できれば、話は単純になる。&lt;/s&gt;&lt;b&gt;←勘違い、そんなことではない。&lt;/b&gt;

現象の観察結果なので、“一気の定義”が先に来てしまった。以下、現象論的定義：

Cはを有限余完備圏として、直和構造(+, 0)で対称モノイド圏とみなす。i, jは直和の標準入射、∇が余対角射だとする。自己関手F:C→Cが、自然変換ε:I→F、μ:FF→Fでモナドになっているとする。自然変換δ&lt;sub&gt;A,B&lt;/sub&gt;:F(A)+F(B)→F(A+B) は、F(i):F(A)→F(A+B), F(j):F(B)→F(A+B) から δ&lt;sub&gt;A,B&lt;/sub&gt; = (F(i&lt;sub&gt;A,B&lt;/sub&gt;)+F(j&lt;sub&gt;A,B&lt;/sub&gt;));∇&lt;sub&gt;A+B&lt;/sub&gt;:F(A)+ F(B)→F(A+B)として定義する。δ: +(F(-),F(-)) →F(+(-, -)):C×C→C。δは余分配（変換）とでもいうべきか。

新しい圏Dを次のように定義する。|D| = |C|、α:A+X → F(B+X) in C がDの射:A→Bとする。α:A→B, β:B→C in D（'C'がだぶった、心眼で区別する）とは、α:A+X→F(B+X), β:B+Y→F(C+Y) in Cのこと。α':A+X+Y→F(B+X+Y) in Cは、(α+ε&lt;sub&gt;Y&lt;/sub&gt;);δで定義する。このδは、F(B+X)+F(Y)→F(B+X+Y)である。同様に、β&quot;:B+X+Y→F(C+X+Y) は (B+σ);(β+ε&lt;sub&gt;X&lt;/sub&gt;);δ;ηとして定義する。σは対称、ηはF(C+Y+X)→F(C+X+Y)の同型。

α'とβ&quot;のKleisli結合*を圏Dでのαとβの結合とする。つまり

- α;β in D = α'*β&quot; in C

ここで、f*g = (f;F(g));μ&lt;sub&gt;C&lt;/sub&gt; in C。
&lt;hr&gt;

定義の途中で、余対角∇や余分配δが出てくるから、余対角を持つ対称モノイド圏とか余分配を持つモナドとかの条件が付くのだろう。が、計算してないからいまいちハッキリしない。

モナドFは色々変化させたい。モナドFに従ってcirc-Kleisli(F)も変わる。C上の全モナドは比較や構成を射として圏だから、F|→circ-Kleisli(F)は、Monad(C)→Ext(C)のような関手となるだろう。Ext(C)はCの拡張圏の圏。これは、現象的には、

- 「プログラミング言語を作ると、インターフェースの実装手段が得られる」
- 「プログラミング言語のあいだの翻訳規則があれば、実装の変換手段も対応して作れる」
- 「プログラミング言語にはIDLからのマッピング（言語バインディング）が必要」
- 「マクロ展開＝構文的代入が潜在的に存在する」
- 「言語間翻訳では、言語バインディングとマクロ展開が保存されるべき」
などなど。

IDL、CDL(constraint def./desc. language)の意義や使い道はいちおう分かった。プログラミング言語とデータ記述言語、エルブラン型定理との関係をハッキリさせたい。公理的意味論≒プログラム証明はうまくいかない気がしているのだが、その理由が知りたい。プログラム証明をやるには、プログラミング言語に推論規則が最初から付いている必要がある -- が、それっていったいどういうことだ？

どうでもいいけど、インスティチューションはSignを中心とした村だな。村と村の交通／交流が必要だ。町村合併とかも。

*1137823571*[圏一般論][具体例]circ-Kleisli構成の別な例

あれれれ、Cを集合圏として、(×, 1)でモノイダル構造を与える。共変ベキ関手Powと、sigleton埋め込み{-}:I→Powと∪:Pow(Pow)→Pow でモナドを考える。

circ-Kleisli構成を考えると、状態遷移も出力も非決定的な順次機械の圏ができる。射は、A×X→Pow(B×X) で、これが遷移と出力を記述する。B=1ならば、非決定性のオートマトンだ。余分配Pow(A)×Pow(B)→Pow(A×B)は具体的な状況では自明だ。余対角が本質ではないな、こりゃ。

対称モノイド圏とモナドがあれば、かなり一般的にいける構成かな。それに、非決定性機械α:A×X→Pow(B×X)を射A→B と考えていいのはうれしい。指標Σがあると、Σの基礎項とかコンテキストの全体とかが決まるが、これはΣが定義する入出力メッセージの集合だから、Σ|→Mes(Σ)のようにして関手が決まる。Mes(Σ)は入力とする非決定性機械で実行系をモデル化するのは自然だ。

話がうまくいきそうだ。circ-Kleili構成はめっけもんのようだ。

*1137826387*[圏一般論][具体例]さらにcirc-Kleisli構成の副産物

入出力を持つ状態遷移機械を単に機械とか系と呼ぶとして、機械の圏の射α:A→Bは、集合圏でA×X→Pow(B×X)と解釈できるが、カリー化すると、α':X→Pow(B×X)^A、これは関手F(X) = Pow(B×X)^Aの余代数。

機械の圏でHom(A, B)を状態空間の適当な写像を射として再び圏と考える。これで機械の圏は2-圏になる。α|→α' はHome(A, B)の対象（1-セル）からF=F&lt;sub&gt;A,B&lt;/sub&gt;余代数を作る。Home(A, B)の射（2-セル）は余代数射に対応する。よって、coalg&lt;sub&gt;A,B&lt;/sub&gt;:Home(A, B)→Coalg(F&lt;sub&gt;A,B&lt;/sub&gt;)は関手。

coalg&lt;sub&gt;A,B&lt;/sub&gt;のグローバルな（下添字を取った）定義はなんだろう？ circ-Kleisli構成をいじっているあいだにこんなもんが出来てた。他のcirc-Kleisli構成でも同じ現象が起こるのだろうか？

*1137827095*[雑感]詳しく記録

今日はメモ編ばっかり書いていたから、そろそろオシマイ。

記憶だけや1行メモに比べて、このくらい書いておけば後で読んで分かるだろう。図式計算は文字で描くの辛いから、紙に描いて捨ててしまうけど。図式の代用（記録）になるカルク記法がやっぱ欲しい。


</body>
</day>
<day date="2006-01-23" title="">
<body>
*1137978147*[プログラム意味論][圏一般論]強モナドってか？ -- まだcirc-Kleisli構成

対称モノイド圏上のモナドFで、Fによるcirc-Kleisli構成のためにF(A)+F(B)→F(A+B)が必要だと書いたが、実際には、モナド単位B→F(B)と組み合わせて、F(A)+B→F(A)+F(B)→F(A+B)として使う。つまり、ほんとに必要なのはF(A)+B→F(A+B)だった。

F(A)+B→F(A+B)は、テンソル強度（tensorial strength）というらしい。テンソル強度を持つモナドは強モナド（strong monad）らしい。つまり、対称モノイド圏+強モナドがcirc-Kleisli構成のsettingになるようだ。

強度があれば、f:A→F(B) に対して、f'&lt;sub&gt;X&lt;/sub&gt;:A+X→F(B)+X→F(B+X)が定義できる、これは“F-resulticなf”のX拡張と呼べるだろう。F-resulticを保つモノイダルラベリングだ。circ-Klisli構成では、f:A+X→F(B+X)に対して、f':A+X+Y→F(B+Y+X)という射が必要。X+YがY+Xになっている所がミソで、対称でひねった“twisted Y拡張”だ。FがIdentityなら、f':A+X+Y→B+Y+Xとなる。g:B+Y→C+Yのとき、f'&lt;sub&gt;Y&lt;/sub&gt;:A+X+Y→F(B+Y+X)、g'&lt;sub&gt;X&lt;/sub&gt;:B+Y+X→F(B+X+Y)となり、うまいことKleisli composableである。

強モナドについては、Moggiの&quot;Computational lambda-calculus and monads&quot;（http://www.disi.unige.it/person/MoggiE/ftp/lics89.pdf）に書いてある。circ-Klisli構成とMoggiの議論、どうも状況は似たような感じだが、ハッキリとは関連を把握できない。

とりあえず、強モナドの定義を引き写しておく：
&lt;pre&gt;
tensorial strength t&lt;sub&gt;A,B&lt;/sub&gt;:A×TB→T(A×B)
×の単位性 r&lt;sub&gt;A&lt;/sub&gt;:1×A→A
×の結合性 α&lt;sub&gt;A,B,C&lt;/sub&gt;:(A×B)×C→A×(B×C)

(等式1)
1×TA-[t&lt;sub&gt;1,A&lt;/sub&gt;]→T(1×A)-[T(r&lt;sub&gt;A&lt;/sub&gt;]→TA
 ∥
1×TA-[r&lt;sub&gt;TA&lt;/sub&gt;]→TA

(等式2)
(A×B)×TC-[t&lt;sub&gt;A×B,TC&lt;/sub&gt;]→T( (A×B)×C)-[T(α)]→T(A×(B×C))
 ∥
(A×B)×TC-[α]→A×(B×TC)-[A×t&lt;sub&gt;B,C&lt;/sub&gt;]→A×T(B×C)-[t&lt;sub&gt;A,B×C&lt;/sub&gt;]→T(A×(B×C))

(等式3)
A×B-[A×η&lt;sub&gt;B&lt;/sub&gt;]→A×TB-[t&lt;sub&gt;A,TB&lt;/sub&gt;]→T(A×B)
 ∥
A×B-[η]→T(A×B)

(等式4)
A×TTB -[A×μ&lt;sub&gt;B&lt;/sub&gt;]→A×TB-[t&lt;sub&gt;A,B&lt;/sub&gt;]→T(A×B)
 ∥
A×TTB -[T&lt;sub&gt;A,TB&lt;/sub&gt;]→T(A×TB)-[T(t&lt;sub&gt;A,B&lt;/sub&gt;)]→TT(A×B) 
 -[μ&lt;sub&gt;A×B&lt;/sub&gt;]→T(A×B)
&lt;/pre&gt;

天下りだと辛いので、Moggiはラショネールを述べているが、モノイド閉圏の自己enrichmentが出てくる。そんなのが必要だとも思えないのだが、、、テンソル強度が要るのか？ほんとに。

テンソル強度t:A×TB→T(A×B)から、ペアリングT(A)×T(B)→T(A×B)を作れると、Moggiは言っている。σを対称、-&lt;sup&gt;#&lt;/sup&gt;をモナドの拡張として、σ&lt;sub&gt;TA,TB&lt;/sub&gt;;t&lt;sub&gt;TB,A&lt;/sub&gt;;(σ&lt;sub&gt;TB,A&lt;/sub&gt;;t&lt;sub&gt;A,B&lt;/sub&gt;)&lt;sup&gt;#&lt;/sup&gt;だそうだ。
&lt;pre&gt;
TA×TB-[σ]→TB×TA-[t]→T(TB×A) -
[(TB×A -[σ]→A×TB-[t]→T(A×B))&lt;sup&gt;#&lt;/sup&gt;]
&lt;/pre&gt;

ペアリング（と呼ぶらしい）の公理化はないのか？

*1138003844*[インスティチューション]Pインスティチューション

インスティチューションにプログラム（のソースコード）とプログラム証明を入れる準備。

&lt;strong&gt;Pインスティチューション&lt;/strong&gt;とは、(Sign, Mod, Sen, Prog, PMod, |=)であり、ProgとPModを除くとインスティチューション、Sign⊆Progであり、iが包含として、i;PMod = Mod。つまり、Prog, PModがSign, Modの拡張になっている。しかし、Senの定義をProgまで拡張できることは仮定されてない。Senが部分圏でしか定義されてないインスティチューションともみなせる。

f:Γ→Σ in Progは、プラットフォーム指標Σを使って(use Σ)、サービス指標Γを提供する(provide Γ）実装コードである。P⊆Sen(Σ)、S⊆Sen(Γ)だとして、A∈Mod(Σ) が A|=P ⇒ [&amp;#91;f&amp;#93;](M)|=S であるとき、fは&lt;strong&gt;(S, P)-correct&lt;/strong&gt;ということにする。fが(S, P)-correctなら、fの意味[&amp;#91;f&amp;#93;]は、Mod(Σ; P)→Mod(Γ; S)関手だと解釈できる。(S, P)-correctはメイヤーの契約概念で、プラットフォーム（動作、仕事の環境）がPを満たす条件でプログラムはサービスSを顧客に提供する義務を負う。

Pインスティチューションからプログラム証明系を作ることが課題。プログラムfから証明木（または証明ネット）Φが作れて、ΦがPからSへの証明ならfが(P, S)-correctである。(P, S)-correctを(P, S)|= fとすると、P |- S by f ⇒ (P, S)|= f。逆に、(P, S)|= f ⇒ P|-S by f なら完全なプログラム証明系。ここはゲンツェン・スタイルがいいような気がする。

なんで、「&lt;em&gt;P&lt;/em&gt;」か？  &lt;em&gt;なんとなく。&lt;/em&gt; πインスティチューションがあるけど、ギリシャ文字よりローマ字がいい、ProgのP、partialのPかも。


</body>
</day>
<day date="2006-01-24" title="">
<body>
*1138062348*[雑感]ネタ

メモ編ネタがあるときは本編ネタがなくなる。まー、そういうもんだな。

メモ編ネタ：
+ Programming in the Hugeをやりたい。
+ 仕様証明とプログラム証明は別物だ。ちゃんと区別。仕様証明はπインスティチューションの概念、プログラム証明はπPインスティチューションの概念。
+ 3変項関手F(A, B, X)=(B×X)^Aがあると、F(A, B, -)余代数の圏ができるが、Fからモナドと適当なKleisli圏が作れて、homsetは余代数の圏となる、したがって2-圏構造を持つ。終余代数を選び出すと、余代数でenrichされた圏ができる、たぶん。
+ テンソル強度、関手強度、モナド／コモナド分配法則、ペアリング、enrichment、indexed categoryって、どんな関係？

*1138069991*[論理][インスティチューション]仕様証明とプログラム証明

インスティチューションがあって、Σ∈|Sign|ごとに、証明可能性“|-”が付いているとする。A⊆Sen(Σ)、b∈Sen(Σ)に対して、A|-b は、Aを仮定してbが証明できること。|-を拡張して、A|-Bが定義できる。「A|-B ならば A|⇒B」が健全性。ここで、A|⇒B は、BがAの帰結になっていること； ∀M.[M|=A ならば、M|=B]。これで、Mod(Σ)の部分圏の大きさを比較できる。

上のような仕様証明系が付いたインスティチューションがπインスティチューション。それに対して、Pインスティチューションに別な証明系がついたインスティチューションがπPインスティチューション。Σに対して、アサーションの集合Ass(Σ)を考える。Ass(Σ)の元は、適当な論理のformulaだと考える。ただし、Sen(Σ)⊆Ass(Σ)。これは、仕様の論理はそのままプログラムの論理に使えるってこと。

P⊆Sen(Π), S⊆Sen(Σ)として、Ass(Σ+Π)のなかで証明を考える。P|-Sであれば、プラットフォーム仕様がサービス仕様を満足する可能性を示すが、それでは面白くない。具体的な証明ネットΦ:P→Sが問題。証明ネットΦからプログラムを抽出する方法progがないとしょうがない。prog(Φ):Σ→Π となる（定義の都合で反変）。健全性は、「Φ:P→S ならば、prog(Φ)は(S, P)-correct」の形。

これらを定式化するには、πインスティチューションのセオリーの圏TheoをさらにPインスティチューションの文脈で拡張する必要がある。S=(Σ, S)（S⊆Sen(Σ)）、Pなどが仕様であるとき、プログラムを埋め込んだ証明ネットを射とする圏を作る必要がある。健全性から、Φ:P→S ならば、prog(Φ):Σ→Π in Progであるだけでなく、[&amp;#91;prog(Φ)&amp;#93;]:Mod(Π,P)→Mod(Σ,S) が定義可能。

健全なプログラム証明系があれば、[&amp;#91;prog&amp;#93;]: PProof →ModCat が定義可能。ここで、ModCatはCatの部分圏で、モデルとしてふさわしい圏を集めたもの。つまり、仕様|→モデル圏、プログラム証明|→モデル圏間の関手（プログラムを経由）と対応する。

もし、プログラミング＝プログラム証明行為なら、プログラムは仕様（制約、記述）の間の変換を与え、具体的・構成的にモデル関手（モデル圏のあいだの関手）を定義する。プログラムpのモデル関手PMod(p)がMod(Π)→Mod(Σ)で定義できるのは明らかだが、どんな部分圏に制限できるかが、深刻な問題なわけだな。

まとめ： インスティチューションの拡張としてPインスティチューションが作れるのと同様に、πインスティチューションからπPインスティチューションが作れる。πPインスティチューションには、プログラム証明の圏PProofが付いていて、その対象は、インスティチューションの仕様（Senの部分集合、公理系）またはセオリーである。prog: PProof→Progでプログラムの抽出ができる。progとプログラムの意味論[&amp;#91;p&amp;#93;]を組み合わせると、プログラム証明の健全性が定義できて、それは圏論的解釈ができる。

課題：圏PProofをちゃんと定義せよ。

*1138071411*[プログラム意味論]正しさ

πPインスティチューションからあらためて見て、“既に動いている実装の正しさ”と“プログラムソースコードの正しさ”は別な概念だな。

実装が正しいとは仕様に対する充足性の問題で、たぶんvalidというのだろう。一方プログラムの正しさは、メイヤーの契約のようなもので、基礎となるプラットフォームがvalidである前提で要求を満たすことであり、こちらはcorrectかな。

言葉の問題はどうでもいいとして、仕様Sに対して正しい実装の全体はMod(Σ; S)⊆Mod(Σ)となり、Pを前提にSを提供する正しいプログラムpは、Mod(Π; P)→Mod(Σ; S) で解釈される。よって、Prog(Σ, Π)はFuctor(Mod(Π), Mod(Σ))と対応する。Prog(Σ, Π)にもFunctor(Mod(Π), Mod(Σ))にも、順序のような構造が入って、実はenrichedなのではないだろうか？

とりあえず、Prog(Σ, Π)には、最適化のようなプログラム変換があるのだから、2圏と考えるのは自然だし。

*1138094132*[プログラム意味論]コンポネントの指標と仕様

指標が極性付きでΣ=Σ&lt;sup&gt;+&lt;/sup&gt;+Σ&lt;sup&gt;-&lt;/sup&gt;でも、指標Σ上の制約やセオリーが、Σ&lt;sup&gt;+&lt;/sup&gt;上の制約とΣ&lt;sup&gt;-&lt;/sup&gt;上の制約に直和分解できるわけじゃない。そうじゃなくて、Sen(Σ&lt;sup&gt;+&lt;/sup&gt;+Σ&lt;sup&gt;-&lt;/sup&gt;)のなかで考えることになる。

これはコンポネント（双方向）のコンパクト閉圏が、単方向であるトレース付きモノイド圏のInt構成で理解できるわけじゃ&lt;strong&gt;ない&lt;/strong&gt;ことを示す。

そもそも、極性付き指標に対するSen(Σ&lt;sup&gt;+&lt;/sup&gt;+Σ&lt;sup&gt;-&lt;/sup&gt;)がなんであるかを考えてない。それじゃダメだ。内部状態の開示義務、イベントに対する反応義務、義務と権利との関係などを決めないと。いずれにしても、プラットフォーム（サービスプロバイダ）とアプリケーション（サービスユーザー）が対称（対等、公平）でないといけない。


</body>
</day>
<day date="2006-01-25" title="">
<body>
*1138151587*[リンク][モナド]スライド、あとで読む:-)

スライドPDF版→ http://www.cs.um.edu.mt/~synchrone05/Presentations/08-TarmoUustalu.pdf

キーワード：
- Comonadic Dataflow Programming
- Freyd Category
- symmetric premonoidal category
- Comonad
- Distributive law (of Monad)

*1138151588*[プログラム意味論][説明]コンポネント仕様の説明手順

+ 生体を例に刺激反応系と環境を説明
+ 生体を、ブラックルームに閉じこめられた人（主体）に喩える。
+ 外部とのインタラクションをポートとメッセージにする。（この段階で極性が入る。）
+ ブラックルームをブラックウォールに変えて、環境を第二の主体と考える。
+ パイプライン、階層化のために、ブラックウォールを2枚考える。
+ プラットフォーム（サービスプロバイダ）とアプリケーション（サービスユーザー）という役割概念と方向を導入する。役割・方向は内部の主体からウォールを見たときのラベル（床と天上、重力のような）。

絵は、床＝プラットフォーム、天上＝アプリケーション、方向＝重力方向（上から下）、ユーザー（人）からプログラム（コンピュータ）を見る視線方向。水平なら左から右。人間は原則左に描くことになる。

コール（メッセージ）方向は、caller（センダ）からcallee（レシーバ）への方向。よって、call（送信、送出）ポートは出て行くポート、called（受信、到着）ポートは入るポート。

極性は、コールは&lt;em&gt;積極的だからプラス&lt;/em&gt;、コール待ちは&lt;em&gt;消極的だからマイナス&lt;/em&gt;。

&lt;em&gt;絵の描き方を決めるのは、ホーントに難しい。&lt;/em&gt;

*1138164331*[リンク][トレース／コンパクト閉圏]スライド、これもあとで読む:-)

これもスライドPDF版→ http://www.cs.bath.ac.uk/~cf/GoI_London.pdf

キーワード：
- Geometry of Interaction (GoI)
- dualizing object
- symmetric liniarly (weekly) distributive category 
- polygraph
- Dummett category
- claasical category
- GoI construction = Int construction
- traced Dummett category / Hasegawa's theorem

*1138176030*[論理][プログラム意味論]Hoare流クアドラプル

トリプルじゃなくてクアドラプル（quadruple）。

(P, E; Q, F)なんだが、構文じゃなくて意味を使って説明する； コンポネントの（内部＋外部）状態空間をX、コンポネントのプラス（積極的、送り側）アルファベットをA、マイナス（消極的、受け側）アルファベットをBとする。P⊆X、Q⊆X、E⊆A&lt;sup&gt;*&lt;/sup&gt;、F⊆B&lt;sup&gt;*&lt;/sup&gt;である。その意味は：

- 状態がP内にあるとき、Eに含まれるメッセージを送出すれば、状態はQ内に入り、Fに含まれるどれかのメッセージをいずれ受け取る。

逆（外の人）の立場で読むと：

- 状態がP内にあるとき、Eに含まれるメッセージを受け取ったなら、状態はQ内に入り、Fに含まれるどれかのメッセージを送らなくてはならない。

うーん、いかにも様相、時相がからんできそうだ。

追記：あ、そうだ。(P, E; Q, F)を、when(P) sending {E} results(Q) cases {F}.とか書こうとしていた。あと、when(P) receiving {E} results(Q) motivates{F}.
</body>
</day>
<day date="2006-01-26" title="">
<body>
*1138253887*[論理][プログラム意味論]対話ホーア式

“クアドラプル”は言いにくいから、対話（的）ホーア式にする。

極性付きでアメナブルな多ソートprefixed隠蔽指標を&lt;strong&gt;対話（的）指標&lt;/strong&gt;と呼ぶことにする。Σがアメナブルなとき、Obs(Σ)は観測子（observer）の集合、Mut(Σ)が変更子（mutator）の集合。対話指標ΣはΣ=(Σ&lt;sup&gt;+&lt;/sup&gt;, Σ&lt;sup&gt;-&lt;/sup&gt;)。

Obs(Σ&lt;sup&gt;+&lt;/sup&gt;) + Obs(Σ&lt;sup&gt;-&lt;/sup&gt;)から作られる（適当な論理の）formulaの全体Form(Obs(Σ&lt;sup&gt;+&lt;/sup&gt;) + Obs(Σ&lt;sup&gt;-&lt;/sup&gt;))をCond(Σ)（条件）とする。Mut(Σ&lt;sup&gt;+&lt;/sup&gt;)から作られた言語（メッセージ集合）の集合をCmd(Σ)（コマンド）、Mut(Σ&lt;sup&gt;-&lt;/sup&gt;)から作られた言語の集合をEvt(Σ)（イベント）とする。実際には、CmdとEvtは言語を表現する式の集まりだと思ってよい。

対話ホーア式は、P, Q∈Cond(Σ)とF∈Cmd(Σ), E∈Evt(Σ)に対して、次の形を持つ。

- when(P) sending(F) results(Q) causes(E).
- when(P) receiving(E) results(Q) motivates(F).

ただし、条件をForm(Obs(Σ&lt;sup&gt;+&lt;/sup&gt;) + Obs(Σ&lt;sup&gt;-&lt;/sup&gt;))としていいかどうかは&lt;em&gt;非常に問題&lt;/em&gt;。因果性と自発性がからんでくる。対話の相方が自発的発展をするとき、自分の状態空間（因果的）と相手の状態空間（非因果的、自発的）を一緒にすることは、たぶんダメだろう。もっと詳細な議論が要る。

*1138256258*[論理][プログラム意味論]対話ホーア式 改

Cond&lt;sup&gt;+&lt;/sup&gt;(Σ) = Form(Obs(Σ&lt;sup&gt;+&lt;/sup&gt;))（内部条件；直接制御可能）、Cond&lt;sup&gt;-&lt;/sup&gt;(Σ) = Form(Obs(Σ&lt;sup&gt;-&lt;/sup&gt;))（外部条件；直接制御不可能、コマンド経由）だとする。

P∈Cond(Σ), Q∈Cond&lt;sup&gt;+&lt;/sup&gt;(Σ), R∈Cond&lt;sup&gt;-&lt;/sup&gt;(Σ), F∈Cmd(Σ), E∈Evt(Σ)に対して、次の形を持つ。メッセージは中括弧にする。

- when(P) sending{F} results(R) causes{E}.
- when(P) receiving{E} changes(Q) motivates{F}.

なんなら：

- when (P), sending{F} changes you(R) causes your{E}.
- when (P), receiving{E} changes me(Q) causes my{E}.

*1138256726*[論理][プログラム意味論]自発性＝ε遷移

そうか、自発性（非因果性）はε遷移で記述できるか。εを空語のみからなる言語だとして、

- when (R) sending{ε} changes you(R') causes your{E}.

「私は何もしてないのに、あんたが勝手に変わったんでしょう。」「それが悪いか？」



</body>
</day>
<day date="2006-01-27" title="">
<body>
*1138324282*[論理][プログラム意味論]因果性、自発性、法則性

（二者の）対話における因果性を、僕は一種の「慣性の法則」として理解している。つまり、「何も働きかけなければ何も起きない」と。自分または相手が非因果的であるとは、勝手に変化することだが、実際には隠れた原因があり、そこまで考慮すれば因果的なはずだ。つまり、システム境界の取り方で因果性は容易に壊れる。

今、ホーア・トリプル P{E}Q を考える（クアドラプルは面倒だから）として、自発的変化をε遷移 P{}Q で定式化する。通常は、コマンド列Eに対して、これが定義する状態空間の変換（同じくEと記す）を考えて、P{E}Qの意味はE(P)⊆Q （P, Qを状態空間の部分領域と解釈）だとする。すると、P{}Q の意味は P⊆Q となるが、これは&lt;strong&gt;オカシイ&lt;/strong&gt;。

P⊆Qはまったく静的な主張だ。P{}Q がε遷移を表すなら、これは動的なハズだ。おそらくは、時間推移（nextingと言うべきか）オペレータがある。つまり、P{next}Q だ。しかし、nextってオペレータはいったいどこに働いている？ nextは「何もしないで時間がたつ」ということだろう。「ブランクな行為」とも言えるか。

では「時間がたつ」てのはいったい何だ？ あるいは「時間がたたない」ってのはいったい何だ？

因果性とは、「今したことが、次の瞬間になにか影響する」「今は、過去にしたことで影響されている」ってなことだろう。因果性は時間概念と密着している。時間を定式化しろってか -- うーん、そりゃムズだ。

対話的因果性は、システムが対話主体二者で閉じていることだが、非因果的でも法則性はありえる。むしろ、ほとんどの法則性は対話的因果性とは別に定式化されている -- これは何を意味するのか？


</body>
</day>
<day date="2006-01-28" title="">
<body>
*1138441388*[まとめ][リンク]誰が何言っているか、と、何がどこまで分かったか

状況証拠で結ばれた複数のことが、完全には繋がらないで中途半端な感じ。&lt;em&gt;繋ぎたい、繋ぎたい、繋ぎたい。&lt;/em&gt; 時系列にはしばられずに、その状況を総括しておく。人名はなるべくカタカナ書きする。でも、今日はダルイから、途中までで止めるけど。

マーク W. ホプキンス（http://web.archive.org/web/20040607231626/www.uwm.edu/~whopkins/index.html）は、形式言語理論と物理（場の量子論）が似ている、つうか対応関係があると言っている。が、場のハミルトニアンとかS行列とか言われても僕にはわからない。今から物理ってのもシンドすぎるよー。でも、僕はマークに刺激されたのだけど。

一方で、アブラムスキー（http://web.comlab.ox.ac.uk/oucl/people/samson.abramsky.html）達は、高水準量子計算のために（強）コンパクト閉圏を使っている。セリンガー（http://www.mathstat.dal.ca/~selinger/）は、ダガー・コンパクト閉圏という名前を使っている。メイ（http://www.math.uchicago.edu/~may/）もほぼ同じことを別な名前で定式化している。マチマチな用語法が悩みの種だが、dualizer付き対称モノイド圏をベースに考えるのがいいと思う。dualが星で、共役（随伴）がダガーだ。ダガーはidentity-on-objectsなantipodal関手。

ところでメイは、コンパクト閉圏（略記しようとすると、&lt;strong&gt;CCC&lt;/strong&gt;になるのが困りもの！ KCCにすっか？）とかダガーKCCを、アティヤの公理的TQFTの文脈で論じてるのだよね。つまり、また物理に戻った。マーク、正しそう。

アティヤのTQFT公理（深谷さんの本にも載っている）は、一種の関手の公理で、定義域はコボルディズム圏になっている。なお、抽象コボルディズムに関してはトム・ウェストン（http://www.math.umass.edu/~weston/）が整理している。&quot;Bicategories of processes&quot; 1995 とかでも何故かコボルディズムが出てくる。そういうことは、http://www.chimaira.org/docs/FLT-Questions.htmに書いておいたことだ。

TQFTの場合は、値の圏は複素ヒルベルト空間からなるダガーKCCになる。遷移系（オートマトン、トランスデューサー、etc.）の圏では、値はたぶん“振る舞い”の圏なのだろう。振る舞いは関係または行列として定式化されると思う。振る舞いは計算できないといけない。その計算は線形のほうが都合がいいだろう、たぶん。計算対象はKleene的な量、ウォルフラム・カール（http://www.cas.mcmaster.ca/~kahl/）のクリーネ圏とかが役に立ちそう。クリーネ圏とトレースSMS（SMC＝対称モノイド圏）、あるいはKCCとかの関係がもう少しはっきりすればいいのだが。

あー、それと、遷移系の圏てのは、双圏、2-圏になるから、&lt;strong&gt;少なくとも2-dimensional&lt;/strong&gt;な定式化じゃないとダメだろう。

</body>
</day>
<day date="2006-01-30" title="">
<body>
*1138616870*[リンク][モナド]IterationとCoiteration

http://www.cs.nott.ac.uk/~gmh/appsem-papers/uustalu.pdf


- title: Generalized Iteration and Coiteration for Higher-Order Nested Datatypes
- Tarmo Uustaluが著者に入っている。
- 16ページ
- Mendler-Style (Co)Iteration for (Co)Inductive Types

*1138617169*[リンク][モナド]IterationとMonad

あ、これはcircKleisli構成と関係するかもヨー！

http://www.iti.cs.tu-bs.de/~adamek/AAV.ps

- title: Iteration Monad
- AczelとAdamekが著者に入っている。
- Elgotへの言及がある。
- 18ページ

</body>
</day>
<day date="2006-02-07" title="">
<body>
*1139280892*[圏一般論]反対圏の実現

このエントリを書いた理由は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060207/1139281135&quot;&gt;本編に書いてある&lt;/a&gt;。

oppositeの訳語は「反対」を使う。

&lt;h5&gt;反対圏の定義&lt;/h5&gt;

圏Cの反対圏C&lt;sup&gt;op&lt;/sup&gt;は、Cの矢印を（&lt;em&gt;まったく形式的&lt;/em&gt;に）逆向きにしたものに過ぎない。つまり、Obj(C&lt;sup&gt;op&lt;/sup&gt;) = Obj(C)であって、A, B∈Obj(C)に対して、C&lt;sup&gt;op&lt;/sup&gt;(A, B) = C(B, A)として定義される。f:A→B in C&lt;sup&gt;op&lt;/sup&gt; とは、f:B→A in C。と、&lt;em&gt;それだけのこと&lt;/em&gt;。C&lt;sup&gt;op&lt;/sup&gt;で考えたfをf&lt;sup&gt;op&lt;/sup&gt;と記すことにする（向きが逆なので、一応別物とみる）。

- dom(f&lt;sup&gt;op&lt;/sup&gt;) = cod(f)
- cod(f&lt;sup&gt;op&lt;/sup&gt;) = dom(f)

id&lt;sub&gt;A&lt;/sub&gt;は、Cで考えてもC&lt;sup&gt;op&lt;/sup&gt;で考えても同じ。compositionは、f&lt;sup&gt;op&lt;/sup&gt;;g&lt;sup&gt;op&lt;/sup&gt; = (g;f)&lt;sup&gt;op&lt;/sup&gt; で定義する。C&lt;sup&gt;op&lt;/sup&gt;の単位律と結合律はCのそれから自明に従う。

と、あまりにも形式的で拍子抜けする。定義から (C&lt;sup&gt;op&lt;/sup&gt;)&lt;sup&gt;op&lt;/sup&gt; = C となる。ここでイコールは圏同値や圏同型ではなくて、ほんとに同じとみてよい。（もっとも、大きな圏が“同じ”とは、あまり確信が持てない言明ではあるが。）

さて、対応Δ:C→C&lt;sup&gt;op&lt;/sup&gt;を、Δ(A) = A、Δ(f) = f&lt;sup&gt;op&lt;/sup&gt;で定義する。あきらかに、Δ(id&lt;sub&gt;A&lt;/sub&gt;) = id&lt;sub&gt;Δ(A)&lt;/sub&gt;、Δ(f;g) = Δ(g);Δ(f)だから、Δは反変関手。同様な定義で、C&lt;sup&gt;op&lt;/sup&gt;→C方向の反変関手を∇とする。

- Δ;∇ = Cのidentity
- ∇;Δ = C&lt;sup&gt;op&lt;/sup&gt;のidentity

つまり、Δと∇を通して、CとC&lt;sup&gt;op&lt;/sup&gt;は&lt;em&gt;反変に&lt;/em&gt;圏同型（当然に圏同値）である。と、これはバカみたいなことだが、伏線。

&lt;h5&gt;反対圏の実現&lt;/h5&gt;

圏CとDがあって、Dが必ずしもC&lt;sup&gt;op&lt;/sup&gt;とは限らない状況で、反変関手の対Δ:C→D、∇:D→Cがあって、Δ、∇によりCとDが反変に圏同値（条件をゆるくしている点に注意）になっているとする。もし、Dが具体的に構成された圏なら、DはC&lt;sup&gt;op&lt;/sup&gt;の&lt;strong&gt;具体的な実現&lt;/strong&gt;といえるだろう。

もっとも、「具体的」という語に明確な定義はなくて、心理的な効果しかないかもしれない。形式的なC&lt;sup&gt;op&lt;/sup&gt;がとらえどころがなく、存在感が薄いので、“心理的な効果＝安心感”が欲しくなる、という事情がある。

&lt;h5&gt;自分自身が反対圏の実現である例&lt;/h5&gt;

Vectが有限次元ベクトル空間の圏（係数体は適当に固定）だとして、Vect&lt;sup&gt;op&lt;/sup&gt;の実現としてVect自身がとれる。Δ:Vect→Vectを、Δ(A) = A&lt;sup&gt;*&lt;/sup&gt;（双対空間）、Δ(f) = f&lt;sup&gt;*&lt;/sup&gt;（双対写像）とする。∇はΔと同じものとする。

δを、canonicalに定義される同型δ&lt;sub&gt;A&lt;/sub&gt;:(A&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;→Aの族だとして、このδを使って Δ;∇≒Id_Vect、∇;Δ≒Id_Vect という自然同型が作れるから、VectとVectは反変に圏同値。

つまり、Vectのなかで双対空間／双対写像を考えると、Vect自身がVect&lt;sup&gt;op&lt;/sup&gt;を実現していると言える。Vectのなかに最初からVect&lt;sup&gt;op&lt;/sup&gt;の構造も（ひっくり返しに）重なっている、とでも言おうか。

&lt;h5&gt;Setの反対圏を実現するあやしい方法：準備&lt;/h5&gt;

「基礎論的にどうよ？」という疑問があるし、コジツケみたいな作為的な方法なのだが、Setに対するSet&lt;sup&gt;op&lt;/sup&gt;を“具体的に”実現する方法がある。まずは束論からの準備。

以下、束は完備束のことだとする。束の最小元を0、最大元を1で示す。a∈L（Lは束）が&lt;strong&gt;アトム&lt;/strong&gt;だとは、「a≠0 であり、x≦a ⇒ (x = a または x = 0)」のこと。ようするに、「アトムとは0の次に小さい元」。

束Lに&lt;strong&gt;アトムが十分ある&lt;/strong&gt;とは、任意のx∈Lが、X⊆(Lのアトム)を使って x = ∨X と書けること。以下、Lのアトムの全体はAtom(L)と書く。

束（完備束）の&lt;strong&gt;準同型&lt;/strong&gt;は、f:L→Mであって、任意のX⊆Lに対して、（ラフな表現を使えば） f(∨X) = ∨f(X)、f(∧X)=∧f(X)を満たすものだとする。さらに、b∈Atom(M)に対して、b≦f(a) となるa∈Atom(L)が必ず存在するようなf:L→Mだけを考えるとする。いま言った性質は、（仮にだが）&lt;strong&gt;アトム被覆性&lt;/strong&gt;と呼んでおこう。

なんか天下り（実はご都合主義）の定義になってしまったが、アトムを十分持つ完備束とアトム被覆性を持つ束準同型の全体は圏をなす。これを確認するのは容易だろう。この圏をAtomfulLatとする。

&lt;h5&gt;SetとAtomfulLatの反変圏同値&lt;/h5&gt;

状況説明で疲れた。あとはサッサといこう。

Set上の反変ベキ関手をPow&lt;sup&gt;*&lt;/sup&gt;と書く。Pow&lt;sup&gt;*&lt;/sup&gt;:Set→Setは反変のendofunctorだが、これがAtomfulLatを経由して分解することを示す。つまり、AtomfulLat→Setの忘却関手をUとして、Pow&lt;sup&gt;*&lt;/sup&gt; = Q;U という反変のQが存在する。このようなQ:Set→AtomfulLatを具体的に構成する。

まずは、集合Aのベキ集合Pow(A)が次の性質を持つことを示す。
+ Pow(A)は完備束である。
+ Pow(A)にはアトムが十分にある。

f:A→Bに対するPow&lt;sup&gt;*&lt;/sup&gt;(f)は、fの逆象により定義される。Pow&lt;sup&gt;*&lt;/sup&gt;(f):Pow(B)→Pow(A)が次の性質を持つことを示す。以下、Pow&lt;sup&gt;*&lt;/sup&gt;(f)を単にf&lt;sup&gt;*&lt;/sup&gt;と書く。

+ Y⊆Pow(B)に対して、f&lt;sup&gt;*&lt;/sup&gt;(∨Y) = ∨f&lt;sup&gt;*&lt;/sup&gt;(Y)
+ Y⊆Pow(B)に対して、f&lt;sup&gt;*&lt;/sup&gt;(∧Y) = ∧f&lt;sup&gt;*&lt;/sup&gt;(Y)

これは、たとえばf&lt;sup&gt;*&lt;/sup&gt;(∨Y)を具体的にf&lt;sup&gt;-1&lt;/sup&gt;(∪&lt;sub&gt;i&lt;/sub&gt;Y&lt;sub&gt;i&lt;/sub&gt;)のように書き下して確かめればよい。アトム被覆性を具体的に書けば次のとおり。

- {a}∈Pow(A)が単元集合のとき、{a}⊆f&lt;sup&gt;-1&lt;/sup&gt;({b})となるb∈Bが存在する。

以上から、Pow&lt;sup&gt;*&lt;/sup&gt;はAtomfulLatに値をとるとみなしてよい。このようにみなしたPow&lt;sup&gt;*&lt;/sup&gt;を改めてQと書けば、Q;U（Uは忘却関手）は通常の反変ベキ関手（Set上のendofunctor）となる。

さて、SetとAtomfulLatの圏同値を示すために、関手R:AtomfulLat→Setを定義する。AtomfulLatの対象Lに対して、R(L)=Atom(L)とする。アトム被覆性を持つ束準同型f:L→Mに対して、Atom(M)→Atom(L)を次のようにして定義できる；b∈Atom(M)に対して、アトム被覆性から、b≦f(a)（≦は束順序）となるa∈Atom(L)が存在する。このようなアトムaは実は一意である。よって、その一意的なaを選べばよい。一意性を次に示す。

b≦f(a)、b≦f(a')として、a≠a'と仮定しよう。aもa'もアトムなのだから、a∧a' = 0となる。f(a∧a') = f(0) = 0、これと、f(a∧a') = f(a)∧f(a') より f(a)∧f(a') = 0。最初の仮定「b≦f(a)、b≦f(a')」は、b≦f(a)∧f(a') を意味するが、f(a)∧f(a') = 0なのだからb = 0。しかしこれは、bがアトムであることに矛盾する。よって、a≠a' は否定され、a = a'。

いま述べた方法で、R(f):Atom(M)→Atom(L)を定義すると、RはAtomfulLatからSetへの反変関手となる。

R;Qが、AtomfulLatのidentityと自然同型になることを示すには、Pow(Atom(L)) ≒ L とかを束論的に示さないといけないが、束論の練習問題にちょうどいいでしょうから、後は任せた（って誰に？）。ヒント：x∈Lは、適当なX⊆Atom(L)を使って x = ∨X と書けるのだけど、xに対してアトムの集合Xが一意に定まることを示せ。

で結局、AtomfulLatは、Setの反対圏Set&lt;sup&gt;op&lt;/sup&gt;の具体的な実現とみなせることになったわけだ。ゴタゴタした割には、結果はあまり面白くもないのだけど、ゴタゴタやったがために、（形式的なSet&lt;sup&gt;op&lt;/sup&gt;に比べ）実在感が高いAtomfulLatを手でいじった感じが残る、という効果はあったでしょう。やっぱりつまんない？ あ、そうですか。

&lt;h5&gt;最後に&lt;/h5&gt;

なんか質問あれば、僕は&lt;strong&gt;明白に答える&lt;/strong&gt;ように努力するし、たぶん答えられると思いますよ。

*1139303427*[具体例][圏一般論]Fock空間

&lt;em&gt;忘れるといかん&lt;/em&gt;から書いておこう。

状態空間Sがあるとき、1+S+S&lt;sup&gt;2&lt;/sup&gt;+ ... としてSからFock空間を作る、と考えていたが、この無限級数表示は面白いけど&lt;em&gt;誤解のもと&lt;/em&gt;でもあった。1←S←S&lt;sup&gt;2&lt;/sup&gt;←...のような射影的な系に対して（射影|逆）極限を取るだけの話だった。

一般的に言えば、Λが有向系とかで、F:Λ→Cに対する極限としてFock空間が現れるだけ。極限空間をXとすると、X→S&lt;sup&gt;n&lt;/sup&gt;の射影があるけど、逆に、X←S&lt;sup&gt;n&lt;/sup&gt;の埋め込み（レトラクト）も構成できる、ってことらしい。

ようするに、Fock空間をあまり代数的／計算的に考えないほうがいい。極限構成が本質。Fock空間がモナドになる、というのも（特殊ケースでそれが有ったとしても）あまり期待しないほうがいい。SのFock空間はS+{bottom}の無限直積だが、位相はシリンダ位相のような気がする。


</body>
<comments>
<comment>
<username>bonotake</username>
<body>全然つまんなくなかったです(^^; 「具体的な実現」というのはなかなか興味深い内容でした。（少なくとも、私には）&lt;br&gt;どうも、Set^{op}=Setだと＊勝手に＊思い込んでいた節がありますね、私。混乱していた大元の原因はそこかも。今読ませてもらって、すごくイメージがわきました。</body>
<timestamp>1139291812</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>形式的／抽象的な構成を、具体的に（主に集合圏ベースで）手作りするのは割と大事な気がする。&lt;br&gt;束論的細部はめんどうで省略しちゃったんで、そこをゴチャゴチャ手でいじってみるといいか、と。僕の見落としがあるかもしれないし。</body>
<timestamp>1139294005</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>アトムが十分にある完備束という条件だけでは、分配則の成り立たない完備束も含まれてしまってマズくないですか?&lt;br&gt;たとえば以下の典型的な例とか...&lt;br&gt;&lt;br&gt;L = {a,b,c,1,0}&lt;br&gt;1 = a∨b = a∨c = b∨c&lt;br&gt;0 = a∧b = a∧c = b∧c&lt;br&gt;Atom(L) = {a,b,c}</body>
<timestamp>1139498039</timestamp>
</comment>
<comment>
<username>_</username>
<body>この実現法はどうやって思いついたんですか。</body>
<timestamp>1139757918</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>_（これは、anonymous variableって意味かな）さん、&lt;br&gt;＞ この実現法はどうやって思いついたんですか。&lt;br&gt;うーん、答えるのが難しい質問だなぁ。&lt;br&gt;本文にも書きましたが、「束を使う」ってのは聞くか読むかして、記憶のどこかに残っていました。あとは、Pow(X)を“束のなかで特徴付ける”という方針で適当にデッチ上げたのです。</body>
<timestamp>1139813401</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>シリンダ位相について興味を持って日記内とgoogleで検索をかけて調べてみたのですが、分かりませんでした。集合・位相の文脈での位相でしょうか。&lt;br&gt;&lt;br&gt;よろしければ定義を教えていただけませんか。よろしくお願いします。</body>
<timestamp>1214985027</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>手元に参照すべきものがないので僕の曖昧な記憶ですが、具体例で説明すると：&lt;br&gt;&lt;br&gt;I = [0, 1] を普通の長さ1の線分だとして、Iの可算個の積を考えます。これは、0 ≦ x_i ≦1 であるような x_0, x_1, x_2, ... の列の全体と考えればいいでしょう。この可算直積には、いろいろな位相の入れ方がありますが、シリンダ位相はその1つです。まず、有限個の開集合U_1, ..., U_n（重複があってもよい）を考えて、これらのU_iとIの無限個を直積した形の集合を考えます。n = 1 のケースだと、U×I×...（残り全部I）とか、I×I×I×U×I×...（残り全部I）とか。&lt;br&gt;&lt;br&gt;上の形の集合をシリンダ開集合と呼び。シリンダ開集合から生成される最小の位相がシリンダ位相です、確か。&lt;br&gt;&lt;br&gt;おそらく（ちょっと自信がないけど）、(x_0, x_1, x_2, ...)と(y_0, y_1, y_2, ..)の距離を、はじめて x_i ≠ y_i となるiに対して 1/2^i と決めた距離による位相と同じじゃないかと思います。</body>
<timestamp>1214987880</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>返信ありがとうございます。&lt;br&gt;&lt;br&gt;ネットで、上記のコメントと近いことが書いてあるpdfを探してみたら次のような資料が見つかりましたのでリンクを貼っておきます。上記のコメントと下記のpdfを併せて勉強してみます。&lt;br&gt;&lt;br&gt;原井敬子, 前田ミチエ, シリンダー測度の回転とノルム, 数理解析研究所講究録1253 巻2002 年14-25&lt;br&gt;http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1253-2.pdf</body>
<timestamp>1214994266</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>salmonsnareさん、&lt;br&gt;&gt; http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1253-2.pdf&lt;br&gt;チラっと見たけど、これ、難しすぎるのでは？&lt;br&gt;&lt;br&gt;シリンダ位相やシリンダ代数は、論理計算や記号力学系（有限離散力学）でも出てきて、そういう分野のほうがとっつきやすいかと。特に、有限集合の可算無限直積の点を状態遷移の軌跡（時間は無限）と考えて、軌跡どうしの“近さ”を考えるときにはなんらかの位相が必要で、そのとき、有限個の監視時刻で見た結果（残りの見てない無限個の時刻を無視）が近ければ“近い”とみなすのが、だいたいシリンダ位相の発想です。</body>
<timestamp>1215142496</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>＞チラっと見たけど、これ、難しすぎるのでは？&lt;br&gt;読み進めていたら、途中で挫折しました・・・。&lt;br&gt;&lt;br&gt;＞シリンダ位相やシリンダ代数は、論理計算や記号力学系（有限離散力学）でも出てきて、そういう分野のほうがとっつきやすいかと。&lt;br&gt;&lt;br&gt;アドバイスをありがとうございます。「論理計算」、「記号力学系」の分野の文献を探してみます。</body>
<timestamp>1215151166</timestamp>
</comment>
</comments>
</day>
<day date="2006-02-08" title="">
<body>
*1139364563*[雑感]リハビリか？

昨日のエントリー、「束論的細部はめんどうで省略しちゃった」のだが、詰めようかと思ったら ……不等号（順序）とかsup（∨）、inf（∧）の扱いがうまく出来ない。アレレレレ、手が忘れている。リハビリトレーニングしないとダメかも。ガックーゥ。

こんなときは「orz」って書くんでしょうかね。

*1139364900*[リンク]圏のバリアント

- http://wslc.math.ist.utl.pt/ftp/pub/MateusP/02-HM-paracat1.pdf &quot;Paracategories I: Internal Paracategories and Saturated Partial Algebras&quot; Claudio Hermida, Paulo Mateus (2 September 2002) 

付録A &quot;Background material&quot;の部分が役に立つ。

*1139386572*[圏一般論][リンク][用語法] categories: strict, strong, pseudo, lax

http://north.ecc.edu/alsani/ct02%281-2%29/msg00072.html をそのまま引用。

&lt;pre&gt;
David Benson on 2002-02-08 wrote:

  Early on, John Gray and others noticed that functors ought not
  compose on-the-nose, but up-to-isomorphism, and (I believe)
  called the result &lt;&lt;pseudo-functors&gt;&gt;.  Well, there is nothing
  &lt;&lt;pseudo&gt;&gt; about it and it is these latter entities that deserve
  the name &lt;&lt;functor&gt;&gt;, with the first 50 years of use then becoming
       XXX functor
  where XXX might be &lt;&lt;young&gt;&gt; or &lt;&lt;nasal&gt;&gt; or ...

The issues here seem to be:
What are the possible comparison methods for composition, identity, etc.,
how shall they be briefly named,
and which shall be the default?

The most conventional answers to these questions seem to be:

. COMPARISON  |         SYSTEMS        |        USAGE EXAMPLES
.             |   [E]     [I]     [M]  |   [E]       [I]       [M]
. ___________ | ______  ______  ______ | ________  ________  ________
. equality    | ------  strict  strict | X         strict X  strict X
. isomorphism | pseudo  ------  strong | pseudo-X  X         strong X
. morphism    | lax     lax     ------ | lax X     lax X     X

The leftmost column gives the three most common comparison methods.
(morphism actually has two variants depending on the sense of the morphism.)
Next come three different naming systems for the three comparison methods.
[E], [I] and [M] designate both a system and a reference for it:

[E] Kelly and Street, Review of the Elements of 2-Categories (1974), Section 
1.5
[I] Blackwell, Kelly and Power, Two-Dimensional Monad Theory (1989), Section 
1.2
[M] same reference as [E];

each reference provides examples, historical justification,
and comparisons to alternative conventions
(e.g., in the setting of bicategories, homomorphism for strong morphism).
In each naming system the default comparison method has a '------'
(the lack of a name) as its &quot;name&quot;.
Finally, in the USAGE EXAMPLES, for X take functor or morphism or
(natural) transformation or algebra or ....

The original quotation suggested taking up-to-isomorphism as the norm;
that would seem to put it squarely in the [I] camp, making its XXX = 

&lt;&lt;strict&gt;&gt;.

It would be interesting to expand the table to take into account
other comparison methods and systems;
also it would be in some ways be simpler
if the isomorphism comparison could be denoted by a single term,
but pseudo and strong have the advantage of clearly indicating
where they stand relative to the norms in their respective systems.

It has been stated that the notion of pseudo-functor originated with
Grothendieck's study of fibrations (fibred categories) in the 1961 SGA
Cat\'egories fibr\'ees et descente;
perhaps Madame Ehreshmann or Monsieur Benabou
might care to expand, confirm or comment on that...

Keith
&lt;/pre&gt;

*1139387800*[圏一般論]等しい、つっても

pseudだのlaxだのややこしいな↑

もっと基本的なところで、CとDが圏だとして：

+ CとDは同じ
+ CとDは圏同型
+ CとDは圏同値

は違う。もっとも、大きな圏になると、この3つの違いが確信持てなくなる。同じって、ほんとに同じなのか？ 圏同値がいちばんゆるいし、圏同値なら事実上同じとみなしてよいから、まー、圏同値を示すのが無難ってことでしょう。

F:C→D、G:D→Cに対して、自然同型 F;G≒C、G;F≒Dを作ればいい。とりあえず、ι&lt;sub&gt;A&lt;/sub&gt;:G(F(A))≒→A または、A≒→G(F(A)) となるような同型の族ι={ι&lt;sub&gt;A&lt;/sub&gt; | A∈|C|} を探す、と。自然性はたいていは簡単、たまに難しい（あたりまえだ）。


</body>
</day>
<day date="2006-02-09" title="">
<body>
*1139453103*[雑感]印刷しやすい

CSS @mediaを使って、印刷しやすくした。


</body>
</day>
<day date="2006-02-10" title="">
<body>
*1139529546*[雑感][圏一般論]集合の反対圏と束について

オブジェクト電波に対抗(?)して檜山電波をhttp://d.hatena.ne.jp/m-hiyama-memo/20060207/1139280892「反対圏の実現」で発信したのだった、発作的に。その内容の「Set&lt;sup&gt;op&lt;/sup&gt;と同値な圏の構成」は、どこかで読むか聞くかした印象はあるが、出典はまったく憶えてない。&lt;strong&gt;束のなかで、Pow(X)の形のものを束論的に特徴付ければいい&lt;/strong&gt;のだろう、という感じで今回再構成してみた。

とはいえ、アウトラインしか示してないから：
&gt;&gt;
僕の見落としがあるかもしれないし。
&lt;&lt;
と言い訳しておいた（コメント欄）。そしたら案の定：
&gt;&gt;
アトムが十分にある完備束という条件だけでは、分配則の成り立たない完備束も含まれてしまってマズくないですか?
&lt;&lt;
と酒井さんのツッコミ。マズいよね。

実は、分配法則を仮定しないまま詰めようと手を出したらうまくいかんので、http://d.hatena.ne.jp/m-hiyama-memo/20060208/1139364563にて：
&gt;&gt;
不等号（順序）とかsup（∨）、inf（∧）の扱いがうまく出来ない。アレレレレ、手が忘れている。リハビリトレーニングしないとダメかも。ガックーゥ。

こんなときは「orz」って書くんでしょうかね。
&lt;&lt;
となってしまった。こんとき、非分配的束（反例）もイメージしてないし。

http://d.hatena.ne.jp/bonotake/20060208/1139373344 のコメント欄で：
&gt;&gt;
無限分配律も使っているよね。
&lt;&lt;
と書いたのは、「それ使っていいの？」という気持ちと同時に「やっぱり、使うよね」という感じ。

酒井さんのhttp://www.tom.sfc.keio.ac.jp/~sakai/d/?date=20060209#p01によると、この話題は酒井さんが過去に扱っているらしい。完備ブール代数にアトムの条件を付けた束での定式化のもよう。僕がブール代数を持ち出さなかったのは、そこまで要らないような気がしたから（なんとなく）。でも分配性は最初から仮定しないとダメのようだ。あと、アトム被覆性はその場での（ご都合主義的）思い付き。

ところで、
&gt;&gt;
以前に Linear Logic complements Classical Logic のエントリで書いた CABA が Set が反対圏になっているという話について思い出した。で、真面目に考えてたら、なんか妙に時間かかるし疲れたた。俺ってこんなに頭の回転遅かったっけ……orz
&lt;&lt;
あー、orzってそう使うんですか。って、こりゃワシのセリフだ、そのまんま。

http://www.tom.sfc.keio.ac.jp/~sakai/d/?date=20050321#p01の追記：
&gt;&gt;
…とりあえず、あとでちゃんと計算しよう。
&lt;&lt;

あとは任せた。たけをさんと酒井さんで「ちゃんと計算」してちょ。

*1139531321*[雑感][圏一般論]「オートマトンの圏」とかいうと、話がややこしくなるゾ

電波文騒ぎ（っていうほどの事ではない）のmixi掲示板見て思ったのだけど、「オートマトンの圏」ってば、誤解と混乱のもとではないか。

Rutten（ルッテンかなラッテンかな？）に倣えば、必ずしも有限ではない&lt;em&gt;決定性&lt;/em&gt;オートマトンは、アルファベットA、状態空間S、遷移関数δ:A×S→S、終状態（判定関数）φ:S→{0, 1}からなる組(A, S; δ, φ)である（Ruttenは始状態を考えない）。

(B, T; δ, φ)がもうひとつのオートマトンだとして（δ、φは同じ記号を流用）、f=(f&lt;sub&gt;al&lt;/sub&gt;:A→B, f&lt;sub&gt;st&lt;/sub&gt;:S→T)がオートマトンの射だとは：

+ δ(f&lt;sub&gt;al&lt;/sub&gt;(a), f&lt;sub&gt;st&lt;/sub&gt;(s)) = f&lt;sub&gt;st&lt;/sub&gt;(δ(a, s))
+ φ(f&lt;sub&gt;st&lt;/sub&gt;(s)) = φ(s)

これで、圏Automができる。必要があれば、射の定義を拡張してもよい（例：f&lt;sub&gt;al&lt;/sub&gt;をletterに列を対応させる関数にする）。Aを固定して、f&lt;sub&gt;al&lt;/sub&gt;をAのidentityにすれば、Aごとに圏Autom&lt;sub&gt;A&lt;/sub&gt;ができる。これを使って、アルファベットの圏の上のindexed categoryにすることもできる。

&lt;h5&gt;全然別な例&lt;/h5&gt;

普通、「オートマトンの圏」といえば、上のような定義だろう（いろいろと変種、拡張はありえるけども）。だが、1つのオートマトン(A, S; δ, φ)から圏を作ることもできる（φは関係なくなるが）。

まず、δ(a, s) = tのとき、sからtにarrow a があるとみなす。この方法で、Sを頂点集合として、Aでラベル付けされた有向グラフができる。このグラフから自由生成された圏をCとする。

Obj(C) = S、C(s, t) = {頂点sからtに至るすべてのパス}。パスの道筋を無視して、パスに出現するラベル列を取り出す写像をLabelとすると、Labelは圏Cからモノイド(A&lt;sup&gt;*&lt;/sup&gt;; ・, ε)（・は列の接合、εは空列）への関手となる。ただし、モノイドは単一対象上の圏とみなす。特に、homset C(s, t)のLabelでの像は、始状態s、終状態tにより生成される言語になる。

これも、特定のオートマトンから作り出した圏だから「オートマトンの圏」と呼べる。個々のオートマトンをこの方法で圏とみなせば、最初に出したオートマトンの圏は、「圏の圏」の例となる。


</body>
<comments>
<comment>
<username>bonotake</username>
<body>あの時はあまり深く考えずに発言してたのですが、今思い起こすと、一般的な「オートマトンの圏」ではなかったですね。1つのオートマトンがなす圏、と捉えたほうが文脈にはあっているかも（自分の文章なのに他人事）&lt;br&gt;でも、「モノイドの圏」とかいった場合も同じような問題が生じませんかね？ 対象がモノイドである圏と、モノイドが圏を成す場合と。&lt;br&gt;モノイド圏（モノイダル圏）って自分はまだちゃんと理解してませんけど、その辺も合わせて混乱すると言うかなんと言うか。</body>
<timestamp>1139532959</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>結局、「言葉使いを注意しましょう」とか、「事前に定義して使いましょう」みたいな教訓になってしまうのですけどね。「hogeの圏」という言い方は、ほとんどの場合で「対象がhogeであるような圏」でいいと思います。が、「１つのhogeから作った圏」という解釈もないわけではない。それで誤解や混乱が生じるときは、（*相手をみて*）注意深い言葉使いをするのが無難だ、ってことです。</body>
<timestamp>1139534237</timestamp>
</comment>
</comments>
</day>
<day date="2006-02-13" title="">
<body>
*1139819106*[雑感][圏一般論]Setの反対圏からのimplication

&lt;em&gt;奇妙な&lt;/em&gt;事情から、Set&lt;sup&gt;op&lt;/sup&gt;の話をしてしまった。

酒井さんの指摘のように、分配律が抜けていたからAtomfulLatの対象は、「アトムを十分に持つ&lt;em&gt;分配的な&lt;/em&gt;完備束」と変更する必要がある。そうすれば、Set&lt;sup&gt;op&lt;/sup&gt;の実現になるだろう（たぶん）。分配律を導く他の条件を入れてもいい。例えば、確かハイティング（Heyting）代数になってれば分配すると思った（要確認）。

さて、AtomfulLatの条件を少し弱めてみる。例えば、アトムの条件をはずして単なる分配的完備束の圏DistCLatを考える。すると、忘却関手を通してAtomfulLat⊆DistCLatとみなせる。AtomfulLatをSet&lt;sup&gt;op&lt;/sup&gt;と（乱暴にも）同一視すると、Set&lt;sup&gt;op&lt;/sup&gt;⊆DistCLat となる。反対に（-&lt;sup&gt;op&lt;/sup&gt;を適用）しても圏包含関係が保存されることと、(C&lt;sup&gt;op&lt;/sup&gt;)&lt;sup&gt;op&lt;/sup&gt; = C を使うと、Set⊆DistCLat&lt;sup&gt;op&lt;/sup&gt; となる。

これは何を意味するか？ DistCLatの（形式的な）反対圏は、集合圏の拡張になっているってことだ。elementの概念を使わずに記述できる集合に関する命題は、DistCLat&lt;sup&gt;op&lt;/sup&gt;でも成立する可能性がある。つまり、elementを持たない（より正確には、elementに依拠しない）集合、pointを持たない空間の概念を導入することになる。

酒井さんも言及していたが、フレーム（束論的概念）とロケール（位相空間的概念）は、反対（opposite）を使って定式化される。ロケールは、標語的には「点を持たない空間」だ。

代数構造から位相空間（みたいなもの）を作るのは珍しくなく、ブール代数のストーン表現は典型例だし、可換ノルム環の表現も有名。代数幾何のアフィンスキームも可換環のoppositeになっている。つまり、Set&lt;sup&gt;op&lt;/sup&gt;の構成はなんか作為的ではあったが、それでも、Stone - Gelfand - Grothendieck の系譜にある、と言えなくもない（ような、やっぱ言えないような）。

量子力学、場の量子論では、（空間の）点概念が問題になるらしい。が、僕は物理はカラッキシ全然わからなくて、量子力学も、Mr.お水・江本勝先生の言っている程度の量子力学（あるいは、それと同等のトンドモ説）しか知らない。で、物理的な内容はジェンジェンわからんけど、束の変種であるクオンテイル（quantale）が量子力学を起源として提案されている。

で、クオンテイルの定義をみるかぎり（っても、今は思い出せない((ここは「orz」を使うべきか？))）、クリーネ代数（クリーニ代数）とよく似てる。クリーネ代数といえば形式言語理論で、クオンテイルは量子論、… うーむ、またしてもマーク・ホプキンスが言っていた「形式言語理論と場の量子論は似ている」というobservationを思い出してしまう今日この頃。


</body>
</day>
<day date="2006-02-14" title="">
<body>
*1139893778*[雑感][計算][圏一般論]なぜ、僕が多値を問題にしたか

本編のエントリー&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060213/1139789926&quot;&gt;「多値関数の話をもう少し -- 課題を3つ」&lt;/a&gt;に対して、「メモ編」的な補足を行う。

関数fの値が、y1, y2, ..., yn であるとき、それをタプル(y1, y2, ..., yn)であると見なせば、ハナシが済むのか？ 通常の数学の範囲内では、それで困らないだろう。つまり、直積も&lt;strong&gt;1つの&lt;/strong&gt;集合だから、所詮は「1つの集合→１つの集合」として多引数／多値関数（写像）も定式化できる。

だが以上の論法には、集合概念と直積の存在が暗黙に仮定されている。よって、その前提が使えない状況では、タプルを持ち出すのは無意味・無力となる。

例えば、ゲンツェン流のシーケント計算では、集合概念が（有限集合でさえ）前提されていない。使えるのは、目前に与えられた記号列（図形）に対する直観だけである。そのため、集合概念を使えば自明である「縮約（減）、水増し（減）、交換（換）」などの図形操作が明示的に（構造規則として）与えられている。これが過剰な潔癖主義かというとそうではなく、構造規則の一部を制限することにより新しい論理が生まれる（可能性がある）。実際、線形論理では構造規則が自由に使えない（線形論理、よく知らんのだけど）。

圏論のほうの例をあげれば、標準的“圏”の拡張として、複圏（multicategory）、多圏（polycategory）がある。複圏、多圏が、いつでも通常の圏に還元できるわけではない。複数のモノを並べることができても、それらの直積が考えられないときもある。

論理や計算の世界では、多引数／多値とタプルの間には（ひょっとして越えがたい）ギャップがある。（※ストリート、バタニンのコンピュータッドも面白そうだが、ちっとも理解してない。）


</body>
</day>
<day date="2006-02-15" title="">
<body>
*1139982978*[高次圏論]なんだかわからん言葉達

higher (dimensional) category では、妙な言葉がワサワサ：

- globular set
- computad
- operad
- opetope
- multitope

*1139994336*[計算][雑感]ウエス計算（Uesu calculus） 2006

うーん、多引数・多値が全然スッキリしない。

上江州（忠弘）先生が若い頃に構成した計算法があるんだが、あれを整理してみようか。ご本人も忘れているかもしれないから（1981; 25年前）、大幅に変更しても文句もでまい。

2006年版上江州計算(Uesu calculus 2006)。

※それにしても、上江州さんはWeb上でプレゼンスがないなー。

*1139996125*[計算]ウエス計算（Uesu calculus） #1

とりあえず、はじめよう。

Cは有限積を持つ圏。Vが（集合とは限らない）変数の集まり。#:V→|C|が、割り当て。#(x)∈|C|を「&lt;strong&gt;xの変域&lt;/strong&gt;」（もちろん、#を仮定して）と呼ぶ。

Cの適当な拡張圏C'（C=C'でもよい）があって、Vの重複を持たない有限列Xに対して、#:USeq(V)→|C'|があって次を満たすとする。

+ X=(x1, ..., xn)として、#(X)≒#(x1)×...×#(xn)
+ 特に#( ())≒1、#( (x))≒#(x)

事情を明確にするため、Vの有限列Xに対して、ι&lt;sub&gt;X&lt;/sub&gt;:#(X)≒→#(x1)×...×#(xn)を同型だとする。ι&lt;sub&gt;()&lt;/sub&gt;、ι&lt;sub&gt;(x)&lt;/sub&gt;などが1や#(x)との同型を与える。以上の(C, V, #, C', #, ι)の組をC上の&lt;strong&gt;変数系&lt;/strong&gt;と呼ぶ。記号#は、V→|C|とUSeq(V)→|C'|の両方の意味で使っている。


</body>
</day>
<day date="2006-02-16" title="">
<body>
*1140060883*[計算][雑感]ウエス計算2006 #2

上江州さんは、彼の計算（それを僕が「ウエス計算」と名付けた）を、トポスを扱うときの&lt;em&gt;チョッとした道具&lt;/em&gt;くらいにしか考えてなかったのだろう。ていねいに作ってないし、まじめに説明もしてない。でも僕は、ウエス計算はそれなりに使えると思うから、再構成する。

Cは直積×でモノイド圏になっている。C⊆C'で、C'のほうは実際はデカルト閉圏としていいだろう。ラムダ風計算をするために、CをC'にまで拡張する必要がある。が、変数の変域割り当て#:V→|C|はCの範囲で考え、&lt;em&gt;変数列&lt;/em&gt;への変域割り当てやベキの構成にはC'も使う。

変数列Xは集合ではないが、[X]を成分の集合とする。変数列に重複はないから、length(X) = card([X])。変数列に集合と同じような演算を同じ記号で定義する。

- X＼Y -- Xから、Yに出現する変数をすべて取り除く。
- X・Y -- 単なる連接、重複が生じる可能性あり。
- X∩Y -- Xを見ていって、Yにも出現する成分だけを取り出して列にする。
- X∪Y -- X・(Y＼X)

順序は3種類定義できる。

- X&lt;≦Y -- XがYの接頭辞になっている。
- X≦Y -- XはYの部分列になっている。
- X⊆Y -- Xの成分はすべてYに出現する。

X∩Y≦Xだが、X∩Y≦Yではない（限らない）。X&lt;≦X∪Yだが、Y&lt;≦X∪Yではない。

X=(x1, ..., xn)として#(X)から#(x1)×...×#(xn) in CへのC'での同型射をι&lt;sub&gt;X&lt;/sub&gt;と書いたが、これを&lt;x1, ..., xn&gt;とも書く。つまり、&lt;x1, ..., xn&gt;:#(X)→#(x1)×...×#(xn) in C'。&lt;x1, ..., xn&gt;の逆射は&lt;x1, ...,xn&gt;&lt;= という記号で表す。この記号はマルチ代入をイメージしている。&lt;x1, ...,xn&gt;&lt;= : #(x1)×...×#(xn)→#(X) となる。

&lt;strong&gt;射影&lt;/strong&gt; #( (x1, ..., xn))-(ι)→#(x1)×...×#(xn)-(πi)→#(xi) をxi/Xと略記する。例えば、x1/X:#( (x1, ..., xn))→#(x1)。Xが文脈から明らかなときはxi/-と書く。Xごとにx1/Xの意味は変わるが、xi/- は一般的に「変数に対する射影」と解釈してよい。

C'の射fがf:#(X)→A（A∈C）の形をしているとき、fを&lt;strong&gt;変数列Xからの射&lt;/strong&gt;または、&lt;strong&gt;X上のv→射&lt;/strong&gt;と呼ぶ（v→射が上江州さんの呼称）。変数xが列Xに出現して、fが変数列Xからの射のとき、記号を乱用して x∈f と書く。

とりあえず、今回はここまで。ウエス抽象（圏的抽象）とチャーチ抽象（ラムダ抽象）が定義できたらウエス計算の定義だけは終わる。上江州さんは、ウエス計算をバキバキ使って、高階ハイティング・セオリーとトポスの間の関係とか、論理関手の随伴とかを具体的に構成しているのだが、知られてない、つうか忘れ去られているのだろう。MOTTAINAI.

*1140078947*[プログラム意味論][圏一般論]リファクタリングとPインスティチューション

Fが圏C上のモナドだとして、DがFのKleisli圏だとする。f∈C(A, B)に対して、fにモナド単位ε&lt;sub&gt;B&lt;/sub&gt;:B→F(B)を後結合すれば、B-resulticな射f':A→F(B)ができる。これを使えば、CをDに埋め込めるから、C⊆Dと考えてよい。この埋め込みを込めて、DをCのKleisli F-拡張とも呼ぶことにする。

Pインスティチューションでは、圏Progは圏SignのKleisli拡張になっている。Σ、Γを指標として、射p∈Prog(Σ, Γ)は、&quot;uses Γ, provides Σ&quot;なプログラムである。pの“意味”（varianceは反変）は、ModΓ→ModΣ の関手として与えられるはずだから、localには、Prog(Σ, Γ)→Functor(ModΓ, ModΣ)という写像がある。

ところで、Functor(ModΓ, ModΣ)は、関手を対象、自然変換を射として、so-called縦結合の圏になる。とするなら、Prog(Σ, Γ)も圏になっていて、localにProg(Σ, Γ)→Functor(ModΓ, ModΣ)が関手になっているのが望ましい。

で、問題はProg(Σ, Γ)はどんな圏か？ 対象はソースコードだから、射は明らかにプログラム変換。ΣとΓでしばられているから、勝手な変換ではない。制約（セオリー）が入ることを考えると、外部仕様を変えないプログラム変換となる。つまり、世間的に言えばリファクタリングだ。

モデルの実体として余代数（オートマトン、トランスデューサなど）を考えると、リファクタリングは振る舞い同値、観測的弁別不可能性を導くから、ツジツマはあっている。Progは、localに圏になっているから、Cat-enriched categoryで、双圏（だから2-圏だか）になる。

- 0セル -- 指標、仕様
- 1セル -- プログラム
- 2セル -- リファクタリング

Mod側では、

- 0セル -- モデル圏
- 1セル -- 関手
- 2セル -- 自然変換

となる。具体的実体に移って：

- 0セル -- 入出力領域（境界）
- 1セル -- 余代数
- 2セル -- 余代数の準同型

終対象を取れば、1セルは状態空間の点になり、2セルが状態遷移になるのだろう（たぶん、イマイチわからん？）。ただし、代数仕様と余代数仕様を整合させる問題は残っているし、振る舞い関手も定義してない。

終対象はモジュライに似ているし、双圏構造はコボルディズムやホモトピーと似ている。アティヤのTQFT公理にもほぼ合致する -- やっぱり計算現象は物理的・幾何的現象なのかもしれないな。

ウーム、どっから攻める？ 嗚呼、物理が分かっていれば手持ち道具がもっとあるだろうに、無念。


</body>
</day>
<day date="2006-02-17" title="">
<body>
*1140143585*[計算][雑感]ウエス計算2006 #3

上江州さんは、略記、記号の乱用（オーバーロード）を多用するので、僕も真似してしまうのだが、X, Yが変数列のとき：

- x∈X -- 変数xが列Xに出現する。
- X⊆Y -- Xに出現する変数はYにも出現する。ただし、順序はどうでもいい。
- X≒Y -- Xに置換をほどこすとYになる。

x∈Xのとき、x/X は射影:#(X)→#(x) を表す。実は記号#もオーバーロードしていて、#( (x))と#(x)が一致することは保証されていない（同型だが）。よって、x/(x) はidentityとは限らない。

x/Xの拡張として、X⊆Yに対してX/Yを定義する。X/Y:#(Y)→#(X)は、次の図を可換にする射として定義する。

&lt;pre&gt;
  #(Y)
    | ＼
X/Y |   ＼x/Y
    |     ＼
    v        &gt;
  #(X)-(x/X)--&gt; #(x)
&lt;/pre&gt;

ここで、xはXに出現する変数を走るが、xは有限個なので、可換図式も有限個である。X/Yを具体的に表示することもできるが、退屈だからやめておく。

2つのv→射f, gがあるとき、&lt;strong&gt;fとgがcompatible&lt;/strong&gt;であることを、次の図が可換になることだと定義する。

&lt;pre&gt;
  #(X∪Y) -(Y/(X∪Y))-&gt;#(Y)
     |                  |
   X/(X∪Y)             g
     |                  |
     v                  v
   #(X)------(f)-------&gt;A
&lt;/pre&gt;

要するに、compatibleなv→射は同じ余域A(A∈|C|）を持ち、域#(X∪Y)に対する共通な拡張を持つことである。この共通の拡張:#(X∪Y)→Aを[f, g]と記す。

複数のv→射に対して、v→ペアリングやv→タプリングが定義できる。v→タプリング（n=2のときがv→ペアリング）は、通常のタプリング／直積構成とは違う。v→射にだけ定義できるウエス計算独自の概念である。

f:#(X)→A, g:#(Y)→Bが2つのv→射であるとき、v→ペアリング(f, g)は次の図を可換にする射である。p, qはそれぞれ、第一射影、第二射影。

&lt;pre&gt;
  #(X∪Y)-(X/(X∪Y))-&gt;#(X)
     |                  |
   (f, g)               f
     |                  |
     v                  v
    A×B------(p)------&gt;A

  #(X∪Y)-(Y/(X∪Y))-&gt;#(Y)
     |                  |
   (f, g)               g
     |                  |
     v                  v
    A×B------(q)------&gt;B
&lt;/pre&gt;

v→ペアリングは、通常のf×g、&lt;f, g&gt;=Δ;(f×g)（Δはダイアゴナル）などの便利な拡張になっている。v→ペアリングの存在、一意性、表示などは練習問題、または次回。

上江州さんは、イイカゲンな記法を合理化しているのだが、結局、イイカゲンなままの記法を使い続けている。別にそれでいいと思うが、一回は合理化の部分をきちんと説明したほうがいいだろう。

ネルソンのテンソル解析の教科書があったのだけど、これは概念的にはやたらにモダンなのだが、古典的な記法を合理化して使っていた。「添字をベクトルと思い直す」とか、相当に強引なコジツケを使っているが「古典計算法は正しい」というポリシーは気持ちよかった。ウエス計算は、ネルソン流のテンソル計算に通じるものがあるな。


</body>
</day>
<day date="2006-02-22" title="">
<body>
*1140586967*[論理][雑感]Yoriyukiさんへの返答：内容的なコメント編

くどいですけど、最初に「プログラマのためのゲーデルの不完全性定理」の目的を再確認すると、&lt;strong&gt;プログラマ／技術者に&lt;/strong&gt;わかるように、ゲーデル型不完全性定理の&lt;strong&gt;一変種&lt;/strong&gt;を説明すること。

だから、想定読者はプログラマ／技術者であり、僕なりに想定読者向けに“最適化した”表現を（方便だとのそしりを覚悟で）使ってます。記号論理の使用は最小化します。もちろん、記号論理の基礎知識を伝える目的もあるのだけど、それを予備知識とはしない。

あと、注意： 僕は「超越的」という言葉を、「構成可能性／計算可能性を、まったく意に介さない」という意味で使います。

さて、プログラマにとって関数とは、プログラムで実装された計算可能関数のイメージが強い。超越的な関数を持ち出すときは、なにか明示的に注意しないと、たぶん、暗黙に無意識に計算可能と仮定してしまう。

ちなみに、僕は論理の専門家でもなんでもないし、自然な状態（特に集中や緊張してない状態）ではプログラマ／技術者の感覚なので、意識／意図して頭をスイッチしないと、超越的な議論はやりにくいです。

&gt;&gt;
canProveは全域関数になるのか、と思ってしまいました。これが混乱の１点目。
&lt;&lt;

全域か部分かなんてプログラマは意識しません(笑)。willStopに関しては、「どんなプログラム（ソースコード）に対しても停止性を判定するんだ」という&lt;strong&gt;強い仕様&lt;/strong&gt;を事前に注意しているから、「それは仕様が強すぎて（高望みすぎて）できない」という話し方（ストーリー展開）ができます。

強いて言えば、プログラマにとっての関数は常に部分関数です。なぜなら、入力によって関数（プログラム）の挙動は変わるし、ときに無限走行・暴走します。このことは、日常体験／肌感覚でみんな認識しているはずです。この肌感覚が僕が依拠しようとしている説明の基盤（のひとつ）です。

&gt;&gt;
willStopもcanProveもなんら違いはなく、全域関数としては定義できない(部分関数としては定義できる)ということだと思うのですが？
&lt;&lt;

そうです。どちらも事情は同じなのです。willStopに関して、強い仕様は無理だが、弱い仕様ならそれを実装できます。同様に、canProveも強い仕様（全域）は無理でも弱い仕様で実現できます。問題は、この「弱さ」が無意味なほどに弱いのか？です。僕の「速攻速習編」の最後の注意は、「確かに弱いが、人間やコンピュータがアルゴリズム的に遂行する証明行為と同程度の弱さ（あるいは強さ）だ」と示唆したつもりです。

&gt;&gt;
アルゴリズムと言うと(特に断らない限り)全域関数を意味しませんか。
&lt;&lt;

（少なくともプログラマ的には）そんなことないですよ。アルゴリズムは、プログラムで実装する“モトネタの記述”みたいなもんですから、常に未定義／挙動不可解となる入力が存在するリスクを抱えます。それ（アルゴリズムの実装）が全域になることを保証したいときはよくありますが、もちろんのこと、難しいですよね:-)。

&gt;&gt;
ゲーデルはcanProveのような関数を定義したわけではありません。
&lt;&lt;

ごめんなさい。

&gt;&gt;
一つの考え方としては、p=0から順番にisProof(p,predDef,arg)が成り立つかどうか調べてみる、という方法ですが、この場合trueを返すとき以外は停止しません。
&lt;&lt;

僕が採用したのはこの考え方です。証明可能な命題（の符号達）は、帰納的に枚挙可能です。以下「発端編」を引用：

&gt;&gt;
ともかくも、説明の基本的方針としては、停止しないプログラムって概念を利用する。あと、ゲーデル符号化はコンパイルと解釈して、帰納的に枚挙可能な定理集合は、無限に定理をはき出し続けるプロセスと解釈する。こうして、プログラマにお馴染みの概念だけでゲーデルの不完全性定理を解説できる気がするのだ。
&lt;&lt;

上記のプロセスをproverと呼ぶとして： 関数呼び出しcanProve1(x)は、proverの出力（ある体系の定理）を監視して、xを検出すればtrueを返して停止、￢xを検出すればfalseを返して停止するのです。（毎回proverを起動するのは無駄なので、proverを“バックエンド”として走らせて、出力はデータベースに貯めます； どう？ プログラム的でしょ。）

&gt;&gt;
算術の論理式で書けても、その真理値を求める関数が(部分関数であっても)いつもあるとは限りません。
&lt;&lt;

あー、そういうこと。

「ゲーデルが作ったcanProveは算術の述語であって、計算可能な関数ではありません。」と書いてあったので、算術の述語を“真偽値を値とする関数”とみて「計算可能な関数ではありません」と言っているのかと思った。（だとするとワケワカメ。）

計算可能でないのは、「算術の論理式で書いた算術的命題の、真偽性の判定の関数」ですね。それはまー、認識しているつもりです。ディオファントス方程式系の可解性（解の存在）判定とか、解を求める具体的なアルゴリズムが必ずしも存在しない、といったたぐいの話題と解釈していいですよね。これも、ゲーデル的現象かな、と思います。

僕の予定では、Provable(Subst(Pn, m))のようなものを直接表に出す気はなくて、{x | Provable(x)} で定義される集合の枚挙可能性から、それをプロセス（走行するプログラム）proverを通して利用しようとしているのです。Subst(Pn, m)に相当する操作は、proverのフロントエンドであるcanProve(n, m)にやらせます。それと、自然数n, mではなくて、別な符号化データを使います。

&gt;&gt;
ちなみに、不完全性定理を示す一番簡単な方法は、isValid(s)「sが真である」という計算可能な関数が定義できないことを、willStopが定義できないことと同じように導いて、もし正しくて完全な形式体系があれば、isValidが定義できてしまうことを示すことだと思います。
&lt;&lt;

なるほど。確かにwillStopと並行に話を進めたいのですが、背理法の使いどころは難しいのですよ。どっかで背理法は使いますが、「騙された」感じがしないように使うのは難しいです。

理屈が間違っているのは困りますが、心理的に納得が容易な説明を探しています。体系Sの条件に健全性を入れているのは、構文と意味論をわけるってのが実は分かりにくくて、意味論付きの構文体系のほうが自然だと思うからです。真理値割り当て（isValidです）の定義と健全性の仮定に、無矛盾性が含まれてしまっているのですが、「体系が無矛盾」という概念をあえて取り出して説明するより、「体系が健全」だけで進めたほうがスムーズにいくと思っています。

遭遇のキッカケがなんであれ、袖振れ合うも多生の縁とも申しますから、ゲーデル型不完全性定理の一変種の説明戦略にお知恵を貸していただけると幸いです。もちろん、無理強いしません（できるわけもない）けど。

（ランチ・ドリンク付き税込み580円の店にて）

</body>
<comments>
<comment>
<username>sumii</username>
<body>横からすみません。他の点は詳しくないのでyoriyuki氏にお任せしますが、&lt;br&gt;&lt;br&gt;&gt; &gt; アルゴリズムと言うと(特に断らない限り)全域関数を意味しませんか。&lt;br&gt;&lt;br&gt;&gt; （少なくともプログラマ的には）そんなことないですよ。&lt;br&gt;&lt;br&gt;これはさすがに違うと思います。通常の定義では、「アルゴリズム」といったら（特に断らなければ）任意の有効な入力について停止せねばならず、停止しない（かもしれない）場合は「セミアルゴリズム」といいます。もしそれ以外の理解をしている「プログラマ」がいるとしたら、単なる誤りか、少なくとも通常の定義とは異なるかと。</body>
<timestamp>1140598712</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>エエーッ、そうなんですか。かなりビックリしました。で、本編エントリに昇格(?)させて続きを書きます。</body>
<timestamp>1140652014</timestamp>
</comment>
<comment>
<username>lethevert</username>
<body>「普通」の意味にもよりますけど、「普通のプログラマ」は「アルゴリズムは、プログラムで実装する“モトネタの記述”みたいなもん」くらいの意味で使うことの方が多いと思いますよ。対象読者のことを考えたら「アルゴリズム」と「セミアルゴリズム」を区別するのは逆に混乱を招きそう。</body>
<timestamp>1140652605</timestamp>
</comment>
<comment>
<username>おどりこますたー</username>
<body>セミアルゴリズムなんてはじめて聞いたよ・・・</body>
<timestamp>1140665936</timestamp>
</comment>
<comment>
<username>yoriyuki</username>
<body>何だか、用語法が違うので私が誤解した、に収束しそうではありますが、2点指摘を。まず、「述語」ですが、檜山さんは「算術で与えられたプリミティブな述語」(普通は等号とか不等号)を考えておられるのか(これが計算可能なのは当たり前)、それとも変数を含む論理式一般が述語と呼ぶことができる(例えばProvable(n)とか)のいずれでしょうか。後者であれば、これを真理関数と見たとき、計算可能でないものは500万個はあります。「1変数（変域は自然数、変数名は便宜上固定する）の述語を表現する論理式がP1, P2, ... と列挙可能だとして、Provable(x)が「xが証明可能」を、Subst(P, m)が「Pに含まれる変数を値mの表現で置き換える」を意味するとして、Provable(Subst(Pn, m)) を2変数の述語（関係）とみれば…」とおっしゃっているので、後者ではないかと思うのですが...　だとすれば明確な誤りです。</body>
<timestamp>1140712388</timestamp>
</comment>
<comment>
<username>yoriyuki</username>
<body>2点目：JavaScriptの真理値を返す関数を述語とみなそう、という発想ですが、この場合止まらない関数も含まれているので、不完全になるのは当たり前な気がします。真偽が定まっていると考えられる数学の命題だからこそ、体系が不完全でしかありえないことに驚きがあるわけで。</body>
<timestamp>1140712738</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>yoriyukiさん、コメントありがとうございます。コメント欄は書きにくいので、後で本文のほうにご返答を書きます。&lt;br&gt;それと、yuriyukiさんの「ちなみに、不完全性定理を示す一番簡単な方法は、」のアイディアを拝借させていただきます。これだけを使うわけではないのですが、背理法を使う方法と、機械的証明プロセスの2本立てがいいような気がしてきました。この方針の説明を、すぐに本編にポストします。</body>
<timestamp>1140740815</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>＞ 後で本文のほうにご返答を書きます。&lt;br&gt;http://d.hatena.ne.jp/m-hiyama-memo/20060228/1141092707 です。</body>
<timestamp>1141092781</timestamp>
</comment>
</comments>
</day>
<day date="2006-02-25" title="">
<body>
*1140859058*[論理][雑記]不完全性定理シリーズの背景とシナリオ

yoriyukiさんのご指摘と質問に個別に答える前に、局所的な説明でまた誤解されるのもナンですから、全体的な話をしておきます。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060224/1140742533&quot;&gt;ルデーゲ氏とダボーラ氏のオハナシ&lt;/a&gt;に少し補足します。

これはまた、本編の下書きでもあります。

&lt;h4&gt;●形式的体系からJavaScriptへ&lt;/h4&gt;

まず、僕自身として「方便だ」との非難を一番覚悟していた部分は、JavaScriptの使用です。termやformulaを出さず、代わりにJavaScriptのソースコード断片を使います。当然に、厳密度は下がりますが、「日常感覚で理解しやすくなるだろう」との目論見。以下でも、この方便による記法を主に使います。

foo, bar, bazなどは、JavaScriptコード断片を表すメタ変数。fooDefなどは、コード断片の文字列化であり、fooDefはJavaScriptが扱える対象データ（String型データ）となります。

コード断片fooに自由変数（に相当するJavaScript変数）がなく、boolean値に評価される（と構文的にみなされる）式であるとき、それを&lt;strong&gt;命題コード&lt;/strong&gt;と呼びます。

コード断片barの自由変数が1つ以下であり、boolean値に評価される&lt;em&gt;式&lt;/em&gt;を&lt;strong&gt;述語コード&lt;/strong&gt;と呼びます。便宜上、述語コードの自由変数名は'arg'に固定し、String型変数だけを考えます。そうでない変数のときは、一種のアルファ変換でリネームし、パーズや型変換を使えばいいでしょう。

barが述語コードであるとき、barDefはその文字列化データでした。文字列 &quot;return &quot; + barDef + &quot;;&quot; を定義本体として作った関数をbarPFuncと書くことにして、これを、述語コードbarから作った&lt;strong&gt;述語関数&lt;/strong&gt;と呼びます（「関数としての述語」、とか「述語的関数」のほうがいいと思うが、述語関数が一番簡単だから）。

まとめ：

- bar -- 述語コード （自由変数の個数(bar) ≦ 1 である論理式、ただし構文は複雑）
- barDef -- 対応する文字列 （Stringを符号領域としてのcode(bar)）
- barPFunc -- プログラムとして実装された述語関数 （【λarg.bar】:String→{true, false}、部分関数かも知れない）

また、述語関数にbazという名前がついているときは、対応する述語コードのほうをbazCodeという名で呼びます。

&lt;h4&gt;●tryProof関数と証明エンジン&lt;/h4&gt;

ルデーゲ氏の証明エンジン（機械的定理証明系）により、命題コードfooが証明されるとき、|- foo という書き方（メタな言明）を使います。tryProofの定義（ルデーゲ氏の説明）から：

- tryProof(barDef, realArg) == true ⇔ |- bar[realArg]
- tryProof(barDef, realArg) == false ⇔ |- !bar[realArg]

ここで、bar[realArg]は、述語コードに現れる変数argを文字列データrealArgで置き換えたもの。!barは、barの否定を表す述語コード。

ルデーゲ氏とダボーラの主張の違いは次の点：

- ルデーゲ氏：tryProofがtrueもfalseも返さないこともある。
- ダボーラ氏：tryProofは常に停止し、&lt;b&gt;必ず&lt;/b&gt;trueかfalseのどちらかを返す。

&lt;h4&gt;●健全性&lt;/h4&gt;

もう一点。通常の不完全性定理と、前提や手法が違うのは、体系の健全性を最初から仮定に入れていることです。つまり、命題コードfooに対して、

- |- foo ならば、|= foo

|= foo は超越的真偽性判定を表すメタな言明。|= の定義をちゃんと与えるのは面倒ですが、fooがbar[realArg]の形をしているときは、次のよう：

- |- bar[realArg] ⇒ barPFunc(realArg) == true

つまり、「述語コードbarの自由変数を埋めた形を証明できるなら、barに対応する述語関数barPFuncに当該引数を渡した値が確実にtrueとなる」。引数の個数を一般化して、次も許す。

- |- bar[realArg1, ..., realArgN] ⇒ barPFunc(realArg1, ..., realArgN) == true

以上のことは、証明エンジンの条件として要求します。

&lt;h4&gt;●背理法によりダボーラ氏を論破する&lt;/h4&gt;

※この節は、なぜか「だ・である」調

tryProofは、そのバックエンドである証明エンジンまで含めれば大規模なコードだろうが、原理的には単一のJavaScriptコードにまとめることができ、全体としてboolean値の式とみなせる。つまり、tryProofは2変数の述語関数である。tryProof(arg, arg)は1変数の述語関数とみなせ、対応する述語コードも存在するはず。

次のコードを考える。
&lt;pre class=&quot;code&quot;&gt;
var strangeDef = &quot;!tryProof(arg, arg)&quot;;
var trueOrFalse = strangePFun(strangeDef, strangeDef);
&lt;/pre&gt;

strangeDefは、必要があれば、（おそらくは）長い長い述語コードとみなしてもよい。いずれにしろ意味的には、式 !tryProof(arg, arg) を計算するコードの文字列化である。

もし、ダボーラ氏の主張のごとく、tryProofが全域なら、!tryProof(arg, arg) （から定義される関数）も全域となる。つまり、strangePFunは全域関数となり、その値はtrueかfalseの2つの可能性しかない。（健全性とあわせれば、証明で真偽が完全に決定できる。）

&lt;h5&gt;strangePFun(strangeDef, strangeDef)がtrueの場合：&lt;/h5&gt;

このとき、tryProof(strangeDef, strangeDef)の値はfalse、よって、tryProofの定義（証明エンジンとの関係）から、|- !strange[strangeDef] 。ここで、述語コード!strangeは、意味的に!!tryProof(arg, arg)だとstrangeDefを見ればわかる。さらにこれは、tryProof(arg, arg)と意味的に同じ（二重否定を除去）。よって、|- !strange[strangeDef] とは、|- tryProofCode[strangeDef, strangeDef] のこと。

健全性から、|- tryProofCode[strangeDef, strangeDef] ⇒ tryProof(strangeDef, strangeDef) == trueとなる。だがこれは、「tryProof(strangeDef, strangeDef)の値はfalse」と矛盾する。

よって、strangePFun(strangeDef, strangeDef)がtrueの場合はあり得ない。

&lt;h5&gt;strangePFun(strangeDef, strangeDef)がfalseの場合：&lt;/h5&gt;

同様。

&lt;h4&gt;●最初の記述との比較&lt;/h4&gt;

混乱を避けるため、今回は、次のように表現を変えました。

- 述語 → 述語関数、述語コード
- canProve → tryProof
- 機械的証明系 → 証明エンジン
- cannotProveDef → strangeDef
- if文 → 否定記号!
- provableOrNot → trueOrNot

オリジナル（僕の最初の記述）を引用します。
&gt;&gt;
ゲーデルの不完全性定理では、willStop(progDef, someArg)の代わりにcanProve(predDef, someArg)を考えます。この意味は：

- 1引数で真偽値（trueかfalse）を返す関数を述語（predicate）と呼ぶ。
- predDefは、述語の関数定義本体（を表す文字列）である。
- canProve(predDef, someArg)は、predDefのargをsomeArgで置換した定義（あくまで文字列！）が、ある機械的定理証明系で証明可能であればtrue、反証可能（否定が証明可能）であればfalseを返す。

この状況で、次のコードを考えます。
&lt;pre class=&quot;code&quot;&gt;
 var cannotProveDef = 
  &quot;if (canProve(arg, arg)) {return false;} else {return true;}&quot;;
 var provableOrNot = canProve(cannotProveDef, cannotProveDef);
 alert(provableOrNot);
&lt;/pre&gt;
停止問題と同じ議論でパラドックス（正確には矛盾）が生じます。
&lt;&lt;

さらに冒頭の「ゲーデルの不完全性定理では、」を、「&lt;strong&gt;ゲーデルの不完全性定理の一変種に対して檜山が予定している証明では、&lt;/strong&gt;」に変更してください。結局は今回のこの説明とまったく同じになります（短すぎたが）。

今回、「停止問題と同じ議論でパラドックス（正確には矛盾）が生じます。」を実行してみたわけです。これはまた、yoriyukiさんの次の指摘と近い方式だと思います。
&gt;&gt;
ちなみに、不完全性定理を示す一番簡単な方法は、isValid(s)「sが真である」という計算可能な関数が定義できないことを、willStopが定義できないことと同じように導いて、もし正しくて完全な形式体系があれば、isValidが定義できてしまうことを示すことだと思います。
&lt;&lt;

&lt;h4&gt;●なぜ、ルデーゲ（旧ゲーデル）氏が登場したか&lt;/h4&gt;

僕は次のようにも書いてます。
&gt;&gt;
確かにwillStopと並行に話を進めたいのですが、背理法の使いどころは難しいのですよ。どっかで背理法は使いますが、「騙された」感じがしないように使うのは難しいです。
&lt;&lt;

敵役のダボーラ氏を登場させて、背理法を使いやすくなったと思います。しかし、背理法で「…が不可能」とわかっても、それは、「我々（人間やコンピュータ）は何ができないのか？」には答えますが、「我々は何ができるのか？」には答えてない気がするのです。

人間／コンピュータの証明行為が全能でないこと、超越的真偽判定と同じことはできないことはわかりました。では、人間／コンピュータはどこまでならできるのか。それを、やれるところまでやり切った人物がストーリー上必要だったのです。その人物を何も考えずに「ゲーデル」と書いてしまったのが僕の大失敗ですが。

&gt;&gt;
しかし、停止問題とは異なり、「だからcanProveなんてあり得ない」とは言えません。なぜなら、ゲーデルは非常によくできたcanProveをホントに作ってしまったからです。

ただし！ ゲーデルは嘘つきでもホラ吹きでもないので、「canProveは、どんな述語定義に対しても必ずtrueかfalseを返す」とは言ってません。確実な前提と確実な推論から導かれる結果は、ゲーデルが定義したcanProve関数（に相当するアルゴリズム）は完全ではないということです。「完全ではない」の意味は、canProve(predDef, someArg)がtrueもfalseも返さない事態が起こりえるということです。これは、証明可能でも反証可能でもない命題の存在を示します。
&lt;&lt;

この部分が、後で書き直したルデーゲ氏の正直な説明に相当します。「完全でない」ことは、上の背理法から既に言えてます。「嘘つきでもホラ吹きでもない」は、ダボーラ氏との比較により鮮明になっていると思います。

最後の文：
&gt;&gt;
「アルゴリズム的に行為する限り、人間もcanProve以上のことは出来ない」と言うのがより適切でしょう。
&lt;&lt;

このcanProveは、tryProofと証明エンジン一式に相当します。止まる保証がないので、「セミアルゴリズム的」と言うべきでしょうが :-)。

&lt;/h5&gt;●ゲーデルの証明ではないこと&lt;/h5&gt;

これは憶測ですが、yoriyukiさんは僕が、ゲーデルの原論文／原証明をたどる説明をすると予測していたように思えます。が、それは&lt;em&gt;最初からまったく考えてません&lt;/em&gt;。ω無矛盾のような概念をうまく消化して説明できる自信がありません。それより、超越的な真偽概念と健全性を使ってしまうほうを選んだわけです。これには2つのメリットがあります。

+ 全体に、説明が簡略化される。
+ 「完全ではない」と背理法で示すとき、停止性と同じ論法が使える。

と、そういう事情です。よって、一般論として、次の諸点をどなたかに批判されても「いまさらどうにもならない」のです。

+ 形式化をさぼっている。JavaScriptでイイカゲンに代用している。
+ 健全性を最初から仮定している。仮定として強すぎるし、妥当性／健全性の定義もあいまいである。
+ いずれにしろ、ゲーデル本人の原論文とは似ても似つかない。

最初から、それらを捨てて、分かりやすさを取ったのですから。僕のシナリオ自体は、&lt;em&gt;最初から今まで何一つ変更してません！&lt;/em&gt; それは、今回の説明をふまえて、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060104/1136328998&quot;&gt;第一回&lt;/a&gt;、&lt;a href=&quot;http://www.chimaira.org/docs/GodelsIncomplete.htm&quot;&gt;発端編&lt;/a&gt;、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060110/1136843110&quot;&gt;第二回&lt;/a&gt;を読み直してもらえば、おそらく了解できることでしょう。


</body>
<comments>
<comment>
<username>yoriyuki</username>
<body>「僕が、ゲーデルの原論文／原証明をたどる説明をすると予測していたのでしょうが、」であるとか、「次の諸点を批判されても「いまさらどうにもならない」のです。&lt;br&gt;&lt;br&gt;   1. 形式化をさぼっている。JavaScriptでイイカゲンに代用している。&lt;br&gt;   2. 健全性を最初から仮定している。仮定として強すぎるし、妥当性／健全性の定義もあいまいである。&lt;br&gt;   3. いずれにしろ、ゲーデル本人の原論文とは似ても似つかない。」であるとか、私が言ってもいない主張を私に帰属させようとする檜山さんの意図は何ですか？</body>
<timestamp>1140864097</timestamp>
</comment>
<comment>
<username>yoriyuki</username>
<body>いや、これはあまりにもケンカ腰だ。とにかく、上記のようなことは言っておりません。</body>
<timestamp>1140877649</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>＞ いや、これはあまりにもケンカ腰だ。とにかく、上記のようなことは言っておりません。&lt;br&gt;議論や検討は歓迎ですが、ケンカをする気はもちろんありません。「言っておりません」に関しては、確かに僕の憶測が入ってます。&lt;br&gt;&lt;br&gt;＞ (檜山)ゲーデルの原論文／原証明をたどる説明をすると予測していたのでしょうが、&lt;br&gt;この憶測は違うのですか？ 用語の解釈だけが原因ですか？ 用語だとすると、「述語」と「アルゴリズム」？&lt;br&gt;&lt;br&gt;＞ （檜山）1, 2, 3の箇条書き&lt;br&gt;&lt;br&gt;これは、yoriyukiさんに帰属させようとしてはいません。が、文章はそう読めます、ごめんなさい。「ゲーデルの原論文／原証明をたどる説明をすると予測していた」は、確かにyuroyukiさんに帰属すると僕が考えた憶測ですが、箇条書きの三点は一般的に、このテの批判は覚悟してはいる（そのとおりであるので）が、修正のしようもない、どうにもならないという釈明の記述です。</body>
<timestamp>1140999961</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>yoriyukiさん、もうひとつ：&lt;br&gt;＞ (檜山)局所的な説明でまた誤解されるのもナンですから、全体的な話をしておきます。&lt;br&gt;＞ (檜山)本編の下書きでもあります。&lt;br&gt;と書いているのは、そもそも「展望」のところが、今後の展開の手短な予告だったのですが、そこが手短すぎて誤解を発生させたのは事実ですよね。で、詳しい予告（ほとんど書ききっている気がする）がこのエントリーです。このエントリーの程度の説明と用語法だと誤解をふせげますか？ あるいは、yoriyukiさんの観点から許容できる範囲にありますか？</body>
<timestamp>1141000351</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>文言を、僕の本来の意図を表現するように多少修正しました。少なくとも、憶測の部分、一般論の部分は区別できるかと。</body>
<timestamp>1141024592</timestamp>
</comment>
</comments>
</day>
<day date="2006-02-28" title="">
<body>
*1141092707*[論理][雑記]用語法、述語、数学の命題など

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060222/c/&quot;&gt;コメント欄のご指摘／ご質問&lt;/a&gt;に答えるつもりですが、その前に； どうも釈然としないことがあるんですよ。用語法が食い違っていた、ってのは事実でしょうが、それにしても「&lt;strong&gt;用語法って、そんなに問題になるのか？&lt;/strong&gt;」てのが僕の疑問です。これは、とても気になることです。

僕の用語法が厳密でなかったのは、そのとおりです。が、しかし、理解できない／誤解を招くほどにひどかったでしょうか。言葉（の解釈）にはある程度の幅があり、その弾力性の範囲内でテキトーに使っても、だいたいは通じるものだ、といった楽観主義が僕にはあったのだけど、そうでないとすると考え方を改めねばなりません。

いまだに「用語法だけ」が問題だったとは考えにくいので、「yoriyukiさんは、僕が、ゲーデルの原論文／原証明をたどる説明をすると予測していたのでしょう」という憶測も生まれるのです。

もう一点思い当たるフシは（これも、もちろん憶測です。間違っていたらゴメンナサイ）、「canProve」という名前です。これはもともと、証明エンジンの結果（証明できた／反証できた）を返すだけの関数ですが、「canProve → can prove → provable → |- 」という連想が働いて、超越的でメタな述語と解釈されたような気もしました。そうすれば、
&gt;&gt;
ゲーデルが示したのは、あるφがあって、canProve(φ)もcanProve(￢φ)も共にfalseになること、であってcanProve(φ)がtureでもfalseでもない、と言っているのではありません。
&lt;&lt;
この部分を次のように解釈できると思われます。
&gt;&gt;
ゲーデルが示したのは、あるφがあって、|- φ も |- ￢φ も共に成立しないこと、であって、 |- φ の真偽が決定できない、と言っているのではありません。
&lt;&lt;

僕の憶測（あくまで憶測）をまとめれば、用語法も確かに誤解の要因ではあろうが、次の2点（のどちらか、あるいは両方）も絡んでいるように思えたのです。

+ 僕が予定していた方法とは別な証明法を予測していた。
+ 「canProve」を、超越的に見ての証明可能を意味する「|-」（または、それを自然数などの符号領域上に移したもの）と受け取った。

もしこういう理由（他の理由でもいいですが）がなくて、単に「用語の使い方が不正確だ」というだけで誤解されたとすれば、ちょっとガックリきてしまいますね。そこまで注意深く言葉を使わなければコミュニケーションが成立しないとなれば、かなり疲れるハナシです。

僕は、言葉の弾力性を利用して、（その許容範囲内で）できるだけ面白おかしく語ろうと意図しているし、それでも正確性がひどく犠牲になることはないはずだ、と楽観していたので。

&lt;h5&gt;述語とは何か&lt;/h5&gt;

&gt;&gt;
まず、「述語」ですが、檜山さんは ...（略）...いずれでしょうか。
&lt;&lt;

場合によりけりで、いずれとも決めてかかってはいません。僕は伝わる範囲内で、場合場合で言葉の使い方はテキトーに変えています。むしろ、変えたほうがコミュニケーションが成立しやすいと思っています。日常会話でも、相手が三歳児と中学生と大人では語彙や表現を変える（つうか、自然に変わる）でしょう。

もっと具体的に答えれば：

+ 算術で与えられたプリミティブな述語(普通は等号とか不等号)
+ 変数を含む論理式一般が述語と呼ぶことができる(例えばProvable(n)とか)

以上の2つも含めて、「述語」と呼ぶ可能性がある概念を列挙します。

- Xが任意の集合として、f:X&lt;sup&gt;n&lt;/sup&gt;→{true, false} のような関数（写像）
- 事実上は同じことだが、Xが任意の集合として、X&lt;sup&gt;n&lt;/sup&gt;の部分集合

気分としては、下の方は「関係」と呼びたいし、X&lt;sup&gt;n&lt;/sup&gt;→{true, false}の n = 1 のときを特に「述語」と呼びたいのですが、気分に過ぎません。

- 形式的体系の述語記号（あくまで記号）
- 述語記号の意味となる関数または部分集合

この2つを区別せずに、「述語」または「関係」と呼んでしまうことが僕は多いです。

- 自由変数が1つ以下である論理式（1変数で考えるとき）
- そのような論理式から定義される関数または部分集合

論理式をAとして、それに含まれる唯一の自由変数がx（または自由変数を含まない）として、便宜上ラムダ記法を使うと、それから定義される関数は【λx.A】と書いていいでしょう。（【】は意味割り当てです。tを変数を含まないtermだとして、【λx.A】(【t】) = 【A[t/x]】となります。）Aと【λx.A】もあまり区別しないことも、やっぱり多いです。Aにイッパイ自由変数が入っているときや多変数関数を作りたいときは、A←→【λ(x1, ..., xn).A】の対応で考えます。

&gt;&gt;
後者であれば、これを真理関数と見たとき、計算可能でないものは500万個はあります。「1変数（変域は自然数、変数名は便宜上固定する）の述語を表現する論理式がP1, P2, ... と列挙可能だとして、Provable(x)が「xが証明可能」を、Subst(P, m)が「Pに含まれる変数を値mの表現で置き換える」を意味するとして、Provable(Subst(Pn, m)) を2変数の述語（関係）とみれば…」とおっしゃっているので、後者ではないかと思うのですが...　だとすれば明確な誤りです。』
&lt;&lt;

「後者」とは「変数を含む論理式一般」ですよね。「これを真理関数と見たとき、計算可能でないものは500万個はあります。」 -- 500万個という数値がなんのことかよくわからないのですが、真理関数とみて計算可能でないものがあるのは了解します。

「後者ではないかと思うのですが...　だとすれば明確な誤りです。」 -- くどいですが、後者とは「変数を含む論理式一般を述語と呼ぶ」ことですよね。それが「明確な誤り」ですか？ 論理式はあくまで構文的な対象であり、（真偽を値とする）関数ではないというハナシですか？それなら言いたいことはわかります。それとも、計算可能でない真理関数となるから述語とは呼べないということ？それだとわからない。

&lt;h5&gt;JavaScriptと数学の命題&lt;/h5&gt;

&gt;&gt;
2点目：JavaScriptの真理値を返す関数を述語とみなそう、という発想ですが、この場合止まらない関数も含まれているので、不完全になるのは当たり前な気がします。真偽が定まっていると考えられる数学の命題だからこそ、体系が不完全でしかありえないことに驚きがあるわけで。
&lt;&lt;

これはそのとおりだと思います。数学の命題が、JavaScriptの“命題コード”で表現できて、そのような“埋め込まれた数学命題”の範囲でもやっぱり不完全となることを示す必要があります。

当初、そのことも説明する予定でしたが、今はあきらめ気分です。説明の労力がかかること、それと、「term, formulaの代わりにJavaScriptを使う」という方針では、そこまで行くのに無理があるような気がしているからです。


</body>
</day>
<day date="2006-03-02" title="">
<body>
*1141280252*[インスティチューション][プログラム意味論][雑感]簡単なインスティチューション


&lt;b&gt;[追記 date=&quot;2006-03-04&quot;]&lt;/b&gt;文言、わずかに手直しをした。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060302/1141268885&quot;&gt;本編のコレ&lt;/a&gt;とかでは、簡単なインスティチューションの例を提供しようとしている。インスティチューションの定義くらいは仮定して、本編の例が実際にインスティチューションの例になっていることをザッと説明する。

まず、インターフェースは指標のことである。Javaのインターフェースのような形を使っているので余代数指標、あるいは隠蔽ソートを1つだけ持つ隠蔽代数ソートになる。話を簡単にしたいなら、可視ソートは基本ソート（int, booleanなど）だけに限定してもよい。

J extends I のとき、おおざっぱにいえば I⊆J と考えてよい。つまり、extendsはinclusion（の逆向き；反対）を意味している。inclusionを射と考えれば、インターフェース（指標）の全体は圏になる。inclusionより複雑な射を考えてもいいが、とりあえずinclusionだけでも圏Signができるのは確か。

指標Iに関するホーア制約式を適切に定義すれば、Iのホーア制約式の全体Hoare(I)が定まる。特に自由変数を含まないホーア制約式をSen(I)とすれば、Signの対象ごとに文集合が定まる。I⊆J のとき、Sen(I)⊆Sen(J) と、共変関手が定まる。よって、SenはSign上のSet値の関手。

インターフェース（指標）Iに対して、A⊆Sen(I)を選んだ組(I, A)が仕様である。2つの仕様(I, A), (J, B)に対して、I⊆J、A⊆Bのとき、(I, A)⊆(J, B) として仕様のinclusion圏も定義できる。ここで、A⊆Sen(I)⊆Sen(J) なので、A⊆Bが意味を持つ点に注意。

以上のように定義した仕様のinclusion圏は、Sign上のPow(Sen(-)) で定義したindexed category（Powは共変ベキ関手、varianceは適当に細工する）の平坦化になっている。ModをSign上に定義してもよいが、今定義した平坦化圏Spec上に定義して、Mod:Spec→Cat と考えるのは自然である。ただし、これがうまく定義できることを保証するために、Sign上での充足条件は必要になる。

</body>
</day>
<day date="2006-03-04" title="">
<body>
*1141455936*[インスティチューション]多項式インスティチューション

思わぬところでインスティチューションに出会うことがある。多項式インスティチューションは典型的なインスティチューションではないが、「こんなところにも」という例にはなる。それに説明が簡単だし。

以下で、インスティチューションの単純化である簡易インスティチューションを定義して、多項式の集合達が簡易インスティチューションの例であることを示す。

&lt;h5&gt;簡易インスティチューションの定義&lt;/h5&gt;

Bを圏として、S:B→Setが共変関手、M:B→Setが反変関手だとする。Bの対象は（習慣に従って）Σ、Γなどの文字で示し、射はσ、ρなどで示す。以下、Bの対象を&lt;strong&gt;指標&lt;/strong&gt;、Bの射を&lt;strong&gt;指標射&lt;/strong&gt;、S(Σ)をΣの&lt;strong&gt;文集合&lt;/strong&gt;、M(Σ)をΣの&lt;strong&gt;モデル集合&lt;/strong&gt;と呼ぶ。

Σ∈|B|ごとに、V&lt;sub&gt;Σ&lt;/sub&gt;⊆M(Σ)×S(Σ)が割り当てられているとして、これをΣの&lt;strong&gt;充足関係&lt;/strong&gt;、または&lt;strong&gt;妥当関係&lt;/strong&gt;と呼ぶ。x∈M(Σ)とp∈S(M)に対して、(x, p)∈V&lt;sub&gt;Σ&lt;/sub&gt; を、x |=&lt;sub&gt;Σ&lt;/sub&gt; p と書くことにする。下添字Σを省略して、x |= p とも書く。

x |= p は、「モデルxは文pを満たす」と読む。さらに、関手S, M、関係の族|= のあいだに次が成立しているとする。

- σ:Σ→Γ in Bとして、y∈M(Γ), p∈S(Σ)に対して、M(y) |= p ⇔ y |= S(p)

上の条件は&lt;strong&gt;充足条件&lt;/strong&gt;と呼ぶ。以上の状況で、(B, S, M, |=)を&lt;strong&gt;簡易インスティチューション&lt;/strong&gt;と呼ぶ。

一般的なインスティチューションは、MがB→Setの関手ではなくて、B→Cat（圏の圏）となっている。集合は対象だけの圏とみなせるので、簡易インスティチューションはインスティチューションである。

&lt;h5&gt;一番簡単な多項式インスティチューション&lt;/h5&gt;

体Kを固定する、例えばKは有理数体。Bは有限集合を対象として、inclusionを射とする圏とする。X⊆YのときX→Yの射がある。K[X]は、有限集合Xを不定元とするK係数多項式の集合とする。X⊆YのときK[X]⊆K[Y]となるから、K[-]は共変関手である。S(-) = K[-]としてS:B→Setを定義する。

K&lt;sup&gt;X&lt;/sup&gt;は、X上に定義されたK値関数の全体とする。X={x1, ..., xn}とすれば、K&lt;sup&gt;X&lt;/sup&gt;の元は{x1:v1, ...., xn:vn}というレコード形式で書ける。よって、K&lt;sup&gt;X&lt;/sup&gt;は、Xを名前の集合とするK値レコード全体だとみなせる。X⊆Yのとき、レコードの制限（射影といってもよい）によってK&lt;sup&gt;Y&lt;/sup&gt;→K&lt;sup&gt;X&lt;/sup&gt;が定義できるから、K&lt;sup&gt;-&lt;/sup&gt;は反変関手となる。M(-) = K&lt;sup&gt;-&lt;/sup&gt; として反変M:B→Setを定義する。

a∈M(X)、f∈S(X)に対して、a |= f を 「fにaによる代入をして計算した値が0」と定義する。X={x1, ..., xn}で、a={x1:a1, ..., xn:an}のときf[a1/x1, ..., an/xn] = 0 が a |= f の意味するところである。

以上のsettingで、充足条件を確認すれば、(B, S, M, |=)は簡易インスティチューションとなる。

- 充足条件：X⊆Yだとして、M(b) |= f ⇔ b |= S(f)。

X={x1, ..., xn}, Y={x1, ..., xn, y1, ..., ym}とする。b={x1:a1, ..., xn:an, y1:b1, ..., ym:bm} で、fはx1, ..., xnの多項式である。fにはy1, ..., ymは含まれていないので、

- f[a1/x1, ..., an/xn, b1/y1, ..., bm/ym] = f[a1/x1, ..., an/xn]

これから、f[a1/x1, ..., an/xn] = 0 ⇔ f[a1/x1, ..., an/xn, b1/y1, ..., bm/ym] = 0 が従うが、これは充足条件に他ならない。

&lt;h5&gt;多項式インスティチューションの拡張&lt;/h5&gt;

指標圏Bは、有限集合とinclusionの圏としたが、有限集合とinjectionの圏でも事情はほとんど変わらない。これは、不定元のリネームを許すことになる。

inclusion, injectionだけでなく一般の写像を許しても大丈夫だ。例えば、{x, y}→{t}という写像を考えると、共変関手SによるS(→)は、f(x, y)|→f(t, t) で与えられる。一方、反変関手MによるM(→)は、{t:a}|→{x:a, y:a}で与えられる。充足条件は、{x:a, y:a} |= f(x, y) ⇔ {t:a} |= f(t, t) だから、ほぼ自明だろう。

不定元の集合が有限でなくても多項式は定義できる。よって、Setを指標圏と考えての多項式インスティチューションも定義できる。代入をモナドで定式化するときなどは、このような一般的な定義が必要になる。

&lt;h5&gt;多項式インスティチューションの使い道&lt;/h5&gt;

まず、多項式インスティチューションは簡単で具体的だから、実験や確認を行う事例として役に立つ。特に、モデルが圏でなくて単なる集合（レコードの集合）なので扱いが簡単だ。

個人的には、中学校以来納得がいかなかった不定元（代数的変数）の概念がやっと飲み込めた気がする。不定元は具体的な名前を持っているが、実際には名前が問題になることはない。名前があるが、なくてもいいという奇妙な感じに決着がついた、という思いがある。

ここから先はホラだが； 多項式インスティチューションは、座標による具体的表示を使った代数幾何の舞台といっていいだろう。一方、もともとインスティチューションはソフトウェア工学の概念であり、その起源はバーワイズによるモデル論の抽象化である。となると、多項式インスティチューションは、代数幾何、ソフトウェア工学／計算科学、論理／モデル論の交差点に位置するかもしれない。


</body>
</day>
<day date="2006-03-06" title="">
<body>
*1141630915*[インスティチューション][具体例]簡易インスティチューションのすごく簡単な例

多項式インスティチューションは簡易インスティチューションの簡単な例だと思う。似たような例に命題論理のインスティチューションがある。が、もっと簡単な例がある。

Pow&lt;sub&gt;*&lt;/sub&gt;、Pow&lt;sup&gt;*&lt;/sup&gt;をそれぞれ、共変と反変のベキ関手だとする。Pow&lt;sub&gt;*&lt;/sub&gt;(f)をf&lt;sub&gt;*&lt;/sub&gt;、Pow&lt;sup&gt;*&lt;/sup&gt;(f)をf&lt;sup&gt;*&lt;/sup&gt;と略記する。集合Xに対するPow&lt;sub&gt;*&lt;/sub&gt;(X)とPow&lt;sup&gt;*&lt;/sup&gt;(X)は同じものだから、Pow(X)とも書く。

X∈|Set|だとして、Pow&lt;sup&gt;*&lt;/sup&gt;(X)×Pow&lt;sub&gt;*&lt;/sub&gt;(X) = Pow(X)&lt;sup&gt;2&lt;/sup&gt;の関係|=&lt;sub&gt;X&lt;/sub&gt; を次のように定義する。

- A, B∈Pow(X)に対して、A |= B とは B⊆A のことだと定義する。

以上の状況で、(Set, Pow&lt;sub&gt;*&lt;/sub&gt;, Pow&lt;sup&gt;*&lt;/sup&gt;, |=)は、指標圏Set、文関手Pow&lt;sub&gt;*&lt;/sub&gt;、モデル関手Pow&lt;sup&gt;*&lt;/sup&gt;、充足関係族 |= から成る簡易インスティチューションになる -- 次の充足条件が成り立てばよい。

- f:X→Y、A∈Pow(X)、B∈Pow(Y)に対して、f&lt;sup&gt;*&lt;/sup&gt;(B) |= A  ⇔ B |= f&lt;sub&gt;*&lt;/sub&gt;(A)。

|=の定義によれば、これは次のことを意味する。

- A⊆f&lt;sup&gt;-1&lt;/sup&gt;(B) ⇔ f(A)⊆B 。

上の命題が成り立つことは練習問題だろう。


</body>
</day>
<day date="2006-03-07" title="">
<body>
*1141721346*[インスティチューション][具体例]命題論理の簡易インスティチューション

ついで(?)だから、命題論理も書いてしまえ。

Bを有限集合と単射の圏だとする、これが指標圏。X∈|B|のとき、Xは命題変数の集合だとみなす。Ω={true, false}を2値のブール代数として、多項式インスティチューションと同じようにして簡易インスティチューションを作る。

M(X) = Ω&lt;sup&gt;X&lt;/sup&gt;とする。M(X)は命題変数への真偽値割り当ての全体になる。a∈M(X)は、ブール値のレコード{x1:v1, ..., vn:vn}の形で書いてもよい（多項式のときと同じ）。それで、S(X)は、Xに含まれる命題変数を含む命題論理式の全体とする。

a∈M(X)、p∈S(X)に対して、a |= p とは、論理式pにaによる真偽値割り当てを実行（代入）して、ブール値として評価した結果を【p[a]】だとして、【p[a]】= true のことだと定義する。

充足条件は、σ:X→Yが単射（指標射ですね）だとして

- b∈M(Y), p∈S(X)に対して、M(σ)(b) |= p ⇔ b |= S(σ)(p)

となる。これは、命題論理式pと割り当てaに関して次を示せばよい。

- 【p[b&lt;sup&gt;σ&lt;/sup&gt;]】 = 【p&lt;sub&gt;σ&lt;/sub&gt;[b]】

ここで、b&lt;sup&gt;σ&lt;/sup&gt; = b・σ（写像の合成）であり、p&lt;sub&gt;σ&lt;/sub&gt;は、σによって命題変数を置き換えたpのことである。これをまじめに示すには、論理式の構成に沿った帰納法を使うことになり意外と面倒だが、難しくはないだろう。

命題論理のインスティチューションは、構造的に、多項式のインスティチューションとほとんど同じである。

- 不定元 ←→ 命題変数
- 体K ←→ ブール代数Ω
- 演算記号 ←→ 論理記号
- 多項式 ←→ 命題論理式
- 座標点（レコード） ←→ 真偽値割り当て
- Kの計算 ←→ Ωの計算
- 0  ←→ true

</body>
</day>
<day date="2006-03-22" title="">
<body>
*1142988102*[雑感][具体例]information-hiding boundaries

Jonathan Aldrich &quot;Open Modules: Reconciling Extensibility and Information Hiding&quot;に、&lt;strong&gt;information-hiding boundaries&lt;/strong&gt; という言葉が出てくる。なるほど、これはいい。


</body>
</day>
<day date="2006-03-30" title="">
<body>
*1143683030*[インスティチューション][雑感]Goguen先生がぁ

インスティチューションの元祖Goguen先生の奥様（Ryokoさん）にコメントいただいちゃったよー。→http://d.hatena.ne.jp/m-hiyama/20060119#c1143599637

&gt;&gt;
Joseph Goguenの妻のRyoko Goguenです。&lt;br&gt;この度は、主人の研究について、記載していただき誠に有難うございます。もし失礼でなかったら、お世話をおかけしますが、この内容について、主人に英文でメールしていただけないでしょうか。&lt;br&gt;大変興味を持たして頂いた様子です。
&lt;&lt;

ヒョエー、英文でご説明かよ、、、緊張しちゃうよー。


</body>
</day>
<day date="2006-04-05" title="">
<body>
*1144209531*[雑感][メモ法]もっとメモ、さらにメモ、どんどんメモ（すべし）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20051223&quot;&gt;2005年の末にメモ編を開始&lt;/a&gt;、この日書いたこと：
&gt;&gt;
「多項式関手と添字化」ってタイトルの書きかけ文書を見つけたのだが、自分でも、何を考えて何を書こうとしたかサッパリわからない。

…[snip]… 教えて、過去の僕よ。うーん、何も思い出せん。何か思いついたら、アイディアの核心だけでも書き留めておくべきだな。

そんなことがあったのも、メモをちゃんと書こうとした動機。
&lt;&lt;

部屋を少し片付けたら小さなノートが出てきて、30ページくらいpictorial calculationの跡が残っている。これは、ボックス中心からワイヤー中心に替えて計算したものだ（と思う）。いろんな図式変形でイッパイ等式を示しているのだが、見てもサッパリわからない。ほんとに全然わからない！ ガーン。ため息。

pictorial calcはやっているときは直観的に進むのだが、勘が鈍ると徹底的にできないし、あっというまに勘が鈍る。やっぱりレゴつうか、ルービックキューブとかあんな感じ。せめてルールくらいは明文化して残すべきだな。オモチャを作って常にいじっているのが一番よさそうだが、、、、

※ そういえば、大昔、古典テンソル計算が出来た時期もあったな。

*1144220979*[雑感][リンク][人物]ステファネスク

&lt;a href=&quot;http://www4.informatik.tu-muenchen.de/~stefanes/buk01/indexRht.html&quot;&gt;ステファネスク（って発音でいいのか？ Gheorghe Stefanescu）&lt;/a&gt;は&lt;b&gt;偉大&lt;/b&gt;だ、スゲー人だ。

1980年代に、対称モノイド圏とトレースの概念を得ている。&lt;a href=&quot;http://www.kurims.kyoto-u.ac.jp/~hassei/&quot;&gt;Hasegawa&lt;/a&gt;/&lt;a href=&quot;http://www.dpmms.cam.ac.uk/site2002/People/hyland_jme.html&quot;&gt;Hyland&lt;/a&gt;の定理もこの当時に示していたらしいし。

ところで、&lt;a href=&quot;http://www.springer.com/sgw/cda/frontpage/0,11855,5-0-22-2093249-0,00.html?referer=www.springer.de%2Fcgi%2Fsvcat%2Fsearch_book.pl%3Fisbn%3D1-85233-195-X&quot;&gt;この本（Network Algebra）&lt;/a&gt;はアマゾンにないのかな？これか→http://www.amazon.co.jp/exec/obidos/ASIN/185233195X/503-0219743-2685529 ￥12,293 たけーよ。
これならタダ→http://www4.in.tum.de/publ/papers/TUM-I9437.pdf
</body>
</day>
<day date="2006-04-07" title="">
<body>
*1144403920*[インスティチューション][プログラム意味論]System(Γ, Σ)

疲れた、ヘロヘロだ。朦朧状態。

インスティチューションIの上のプログラムの圏Progは、|Prog| = |Sign|であり、自然な埋め込み Sign ⊆ Progがある。つまり、SignがProgの広大部分圏で入っている。

&lt;b&gt;[追記]&lt;/b&gt;自然な埋め込みがあるのではなくて、埋め込みの族があるような気がする。それは、翻訳系（トランスデューサ）の圏に単なる写像の圏を埋め込むようなことだろう。このときは、状態空間で添字付けられた埋め込みの族が存在する。&lt;b&gt;[/追記]&lt;/b&gt;

射 Σ→Γ in Prog とは、集合レベルでの写像 Σ → Term(Γ) 。つまり、{σi := τi}のように書ける。τiはTerm(Γ)に属するので、use Γ provide Σ なプログラムコードとなる。

Prog(Σ, Γ)は、リファクタリング（プログラムの規則的書き換え）により圏となるから、Prog全体は2-圏となる。p:Σ→Γ in Prog があると、ΓのモデルからΣのモデルを構成できるので、Mod(Γ)→Mod(Σ)の関手としての解釈ができる。つまり、Modの拡張Mod'を Prog→Catとして構成できるが、これは2-圏の関手（2-関手っていうのか？）になるような気がする。

それで、p:Σ→Γの意味を Functor(Mod(Γ), Mod(Σ))のなかで求めるのだが、それより手前(?)にシステムの圏とでも呼ぶべき2-圏があって、pの意味はProg→Systemという反変2-関手で定式化されるべきだ、という気がしてきた。

んじゃ、Systemって2-圏はなにか？ 特にhome-catであるSystem(Γ, Σ)ってのがなにか？ それは、use Γ provide Σ なプログラムコードのコンパイル結果（なんらかの実行可能なもの）なんだと思う。e:Γ→Σ in System があると、指標Γなモデルから、指標Σなモデルを構成できるから、Mod(Γ)→Mod(Σ)という解釈が可能となるのだろう。

もっと大事なことは、System(Γ, Σ)が余代数の圏（と似た）の構造を持ち、終対象を持つことだろう。Φが空指標だとして、use Φ provide Σな実行プログラムは、ライブラリやプラットフォームなしのネイティブ・プログラムのはず、となると、System(Φ, Σ) = Mod(Σ) なのかもしれない。|Sign|上の2-圏Systemは、Modより基本的な存在かもしれない。 -- 朦朧としているから、幻想か？


</body>
</day>
<day date="2006-04-08" title="">
<body>
*1144475364*[インスティチューション][具体例]System(Γ, Σ)の具体例：翻訳系

とにかくメモ、しゃべるようにメモじゃ。

インスティチューションのMod関手を一般化したい。指標Σ、Γと指標射φがあるとき、Mod(φ): Mod(Γ)→Mod(Σ) となるが通常のMod関手だが、Modを2引数Mod(Γ, Σ)にしたいのだが、混乱をさけるため2引数のバージョンはSystem(Γ, Σ)と書くことにする。直観的には、System(Γ, Σ)のメンバー（射, 1セル）は、Γの実装を渡されてΣを実現するような実行系である。

System(Γ, Σ)はそれ自身が圏になっている。Systemの全体は2-圏。2-圏／双圏の定義はいつまでも憶えられないけど、とりあえず、hom-setスタイルの圏の定義をcat-enrichしてみよう -- つまり、hom-catスタイルで定義する。

&lt;h5&gt;セルと結合の記法&lt;/h5&gt;

|Sign| = S と略記する。Sが0セルの集合になる。通常の習慣とは違い、0セルをΣ, Γなどで表し、1セルをA, Bなど、2セルをα、βなどとする。0セル -- 指標または仕様、1セル -- 実行系、2セル -- 実行形のあいだの変換＝準同型、と意味づけられる。2セルに関しては、 α: A→B :: Γ→ Σ のような記法を使おう。これは、A:Γ→ Σ, B:Γ→ Σ, α:A→B をまとめて書いただけのこと。対応するペースティング図式を思い出せば自然な記法だと思う。

2セルの縦結合と横結合をどう書き表すか？で非常に悩む。僕は、このての記法が異常に気にかかる性分だからなぁー。α:A→B :: Γ→Σ と β:B→C :: Γ→Σ の縦結合は、α;βが自然だろう。んんんん、横結合はパイプ記号|にしようかな。んんんん、とりあずそれでいこう。α:A→B :: Σ→Γ、ξ:X→Y :: Γ→Δ として、α|ξ: A;X → B;Y :: Σ→Δ となる。2セルの縦結合と1セルの通常結合が同じ「;」だけど、、、、んんんん、いいとしよう。

&lt;h5&gt;Systemのhom-cat&lt;/h5&gt;

んで、肝心の具体例。

Signは集合の圏とする。Sは集合の類。直観的には、集合をアルファベットとみなす。1セルA:Γ→Σは、決定性の翻訳系（トランスデューサ）とする。Aの状態空間を同じAで表すとして、翻訳写像は、A×Γ → A×Σ&lt;sup&gt;*&lt;/sup&gt; となる。

翻訳写像の状態遷移部分はtA:A×Γ→A 、出力部分はoA:A×Γ→Σ&lt;sup&gt;*&lt;/sup&gt;で表す。翻訳写像の全体はタプル(tA, oA)で書ける。Aがシングルトンのときは、t:Γ→Σ&lt;sup&gt;*&lt;/sup&gt;となるから、単なる関数になる。

入力アルファベットがΓ, 出力アルファベットがΣである翻訳系の圏をSystem(Γ, Σ)とする。翻訳系の射は状態空間の写像α:A→Bで翻訳写像の効果を保つものである。この圏の定義は、ΓとΣを固定すると（そのΓ、Σごとに）局所的に与えられる。

&lt;h5&gt;0, 1セルが作る圏の定義&lt;/h5&gt;

次に、通常の結合「;」をSystem(Γ, Σ)とSystem(Σ, Δ)に対して与えなくてはならない。Kleisli圏の構成と似た方法を使う。補助定理からはじめる。

Zが状態空間だとして、翻訳写像 Z×Σ→Z×Δ&lt;sup&gt;*&lt;/sup&gt;があるとき、この定義域をZ×Σ&lt;sup&gt;*&lt;/sup&gt;に自然に拡張できる。それには、まずZ×Σ&lt;sup&gt;*&lt;/sup&gt;→Z×(Δ&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;に拡張する。拡張に~を付けて示すと：

- tZ~(z, σ1σ2...σn) = tZ(...(tZ(tZ(z, σ1), σ2)...), σn)
- oZ~(z, σ1σ2...σn) = oZ(z, σ1)oZ(tZ~(z, σ1), σ2) ... oZ(tZ~(z, σ1...σn-1), σn)

記号法を工夫すれば、もう少しわかりやすく表記できる。状態zにσが入力されたときの遷移先をz*σとして、出力をz^σとする。

- z*(σ1σ2...σn) = (...((z*σ1)*σ2)...)*σn
- z^(σ1σ2...σn) = z^σ1 (z*σ1)^σ2 ... (z*(σ1...σn-1))^σn

演算子*を左結合的に使い、z=z0, z*σ1 = z1, z*(σ1σ2) = z2などの略記を使うと：

- z*(σ1σ2...σn) = z*σ1*σ2*. ..*σn
- z^(σ1σ2...σn) = z0^σ1 z1^σ2 ... zn-1^σn

要するに、けっこう自然な概念だ。

Z×Σ&lt;sup&gt;*&lt;/sup&gt;→Z×(Δ&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;からZ×Σ&lt;sup&gt;*&lt;/sup&gt;→Z×Δ&lt;sup&gt;*&lt;/sup&gt;に落とすには、(Δ&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;→Δ&lt;sup&gt;*&lt;/sup&gt;という自然な写像を使う。拡張してから落とすのは、モナドに対するKleisli構成と同じである。

やっと準備ができた。A∈System(Γ, Σ)、X∈System(Σ, Δ)だとする。翻訳写像は、A×Γ→A×Σ&lt;sup&gt;*&lt;/sup&gt;、X×Σ→X×Δ&lt;sup&gt;*&lt;/sup&gt;である。新しい状態空間を Z=A×X とする。X×A×Γ→X×A×Σ&lt;sup&gt;*&lt;/sup&gt;の拡張は自明にできる。直積の順序を交換すればZ×Γ→Z×Σ&lt;sup&gt;*&lt;/sup&gt;となる。A×X×Σ→A×X×Δ&lt;sup&gt;*&lt;/sup&gt;が自明な拡張とすれば、これは何もしなくてもZ×Σ→Z×Δ&lt;sup&gt;*&lt;/sup&gt;である。

Z×Γ→Z×Σ&lt;sup&gt;*&lt;/sup&gt;、Z×Σ→Z×Δ&lt;sup&gt;*&lt;/sup&gt;が用意できた。先の拡張可能性定理を使って、Z×Σ&lt;sup&gt;*&lt;/sup&gt;→Z×Δ&lt;sup&gt;*&lt;/sup&gt;と拡張する。Z×Γ→Z×Σ&lt;sup&gt;*&lt;/sup&gt;とZ×Σ&lt;sup&gt;*&lt;/sup&gt;→Z×Δ&lt;sup&gt;*&lt;/sup&gt;は普通に結合できるから、結合して、Z×Γ→Z×Δ&lt;sup&gt;*&lt;/sup&gt; が得られる、これは System(Γ, Δ)に入る。

Γの恒等写像は状態空間をシングルトンにとって、Γ→Γ&lt;sup&gt;*&lt;/sup&gt;を自然な埋め込みにとればよい。あとは圏の公理を確認する（省略）。

&lt;h5&gt;2セルの横結合&lt;/h5&gt;

残るは2セルの横結合|の定義だ。

α:A→B :: Γ→Σ、 ξ:X→Y :: Σ→Δ として、A;Xの状態空間はA×X、B;Yの状態空間はB×Yとなる。αとξは状態空間の変換 A→BとX→Yなのだから、A×X→B×Yは、写像の直積として定義できる。この直積写像をα|βと定義する。

横結合の結合律、単位律、縦結合との交替律は、まー、たぶん成立するだろう。

&lt;h5&gt;課題&lt;/h5&gt;

とりあえず、はしょったところをきちっと埋める。

この例は決定性だが、非決定のときも考える。非決定の定式化で、Pow(A×Σ&lt;sup&gt;*&lt;/sup&gt;)を使うのと、Pow(A)×Pow(Σ&lt;sup&gt;*&lt;/sup&gt;)を使うのでは事情が変わる。Pow(A)×Σ&lt;sup&gt;*&lt;/sup&gt;もあり得る。A×Pow(Σ&lt;sup&gt;*&lt;/sup&gt;)もあるな。そういうバリエーションをどう説明するのか？

インスティチューションの立場から言えば、SignとSystemの関係が問題。|Sign| = |System|という関係では寂しすぎる。ModとSystemの関係をハッキリさせる。SystemからModが定義できるような気がする、そのはずだ。

翻訳系の例で、Sen(Σ)とかProg(Σ, Γ)とは何だ？ TermモナドにあたるのがKleeneスターモナドとか言語モナドなのか？

翻訳系では観測がないので、観測理論が使えないし、終対象も作れない（いや、作れるのか？）。観測付きの翻訳系の場合まで拡張しよう。

翻訳系はオートマトンとの関係があるはずだが、ハッキリしない。

状態空間を集合圏で考えているが、一般の対称モノイド圏ではどうなるの？

Circ構成やKleisli構成に似た構成が出てくるんだけど、これはどうして？やっぱり強モナドが背後にあるのかな？

1セルの圏はコンパクト閉圏にできると思う。向きが付いたコボルディズムと同じような絵が描けるはず。

*1144476403*[インスティチューション]SignからSpecへの持ち上げ

以前、Pow(Sen(-))という関手をindexed categoryだとみなして、それを平坦化してSpecを定義した。SystemはSpec上で定義した方が自然だろうから、Γ、Σは指標じゃなくて仕様だとしてSystem(Γ, Σ)は「Γを満たす実装を渡されてΣを満たすような実装」となる。

Prog(Σ, Γ)もSpec上で定義すれのは簡単だ。あとは、証明と証明変換をSpec上で定義すればいいような気がする。

*1144484173*[トレース／コンパクト閉圏]Janusの絵と向き

なんでコンパクト閉圏かと言えば、Janus（ヤヌス）コンポネントを考えたら自然に必然的にコンパクト閉圏になるからだ。

で、絵の向きがあらためて気になって仕方ない。典型的な例として、モデルとエンジンからなるプラットフォーム（DOMとか）とUIにはさまれた対話的コンポネントを考える。まず、横向きの絵を描くとき、左から右に、UI、コンポネント、プラットフォーム、の順にしよう。縦なら、上から下に同じ順序。左→右、上→下を対応させるのは書字方向の観点からは自然だと思う。

プラットフォームとかエンジンとかシステムのことをPで表そう、もともとはproviderだが、もはやどうでもいい、Pだ。同様に、UIのところはUで表す、service userだから。この記号を使うと、コンポネントはP側とU側に顔を持つことになる（双面！）。

メソッド呼び出しを 「caller（利用権限）→ callee（実装義務）」の矢印でかいて、これを呼び出し弧（call-arc）と呼ぶ。呼び出しの出入りは、P側からのcall-in、P側へのcall-out、U側へのcall-out、U側からのcall-inがある。それぞれの典型的な例は：

- P側からのcall-in -- ミューテーションイベント
- P側へのcall-out -- モデル操作API
- U側へのcall-out -- Window System/Toolkiの呼び出し（描画）
- U側からのcall-in -- ユーザーイベント

反応は2種類あり：
- P call-in により、P call-out と U call-out の列が発生する。
- U call-in により、P call-out と U call-out の列が発生する。

これを半分に切ってしまい（P call-in と U call-outだけとか）、イベントとコマンドの引数をナシにしてしまえば、翻訳系と同じになる。つまり、Janusコンポネントはcat-enrichedなコンパクト閉圏の射＝1セルとなる。


</body>
</day>
<day date="2006-04-12" title="">
<body>
*1144823026*[計算][圏一般論]nセルの記法

α:A→B :: Γ→Σ のような記法を使ったが、コロンの個数を逆にして、α:: A→B : Γ→Σ にしよう。2セルに関しては、⇒を使ったり、上に点が付いた→を使う例があるが、コロンの数＝セルの次元にすればわかりやすい。

圏Catでいえば、自然変換αは、α::F→G:C→D となる。これは「F:C→D, G:C→D, α::F→G」の略記。3セルが出てきても a:::α→β::F→G のように書ける（3セルあつかったことない）。

ところで、モノイド圏の対象を1セル（0セルではない！）、射を2セルと考えると、隠れた単一0セル上の2-（or 双）圏となる。であるなら、アルファベットΣを固定してのΣ→Σの翻訳系の圏はモノイダルになる、これは何だ？

*1144823639*[圏一般論]2-圏のCat主表現

局所小な圏Cに対して、Setへの主（あるいは標準）共変表現hom(A, -)、反変表現hom(-, A)がある。同様に、局所小2-圏に対して、Catへの主表現が作れるだろう。この主表現に対して、米田補題の2-バージョンが成立すれば、2-圏を2-構造を保ってCatに埋め込める。

具体的なケースでこの埋め込みを調べると何になるだろう？



</body>
</day>
<day date="2006-04-13" title="">
<body>
*1144909876*[雑感][リンク]Distributive Lawとか2-(bi)Categoryとか

イライラしているときにCiteSeerで探すと、CiteSeerが重くて余計にイライラする。

で、まー、特に理由も脈絡もないけど、F. Marmolejo, R.D. Rosebrugh, R.J. Woodの&quot;A Basic Distributive Law&quot;つうのを読んでみよう。→http://citeseer.ist.psu.edu/315879.html

F. Marmolejo &quot;Distributive Laws For Pseudomonads&quot; (1999)のほうが丁寧そうだが、58ページもある。→http://citeseer.ist.psu.edu/marmolejo99distributive.html

木下さんの&quot;A bicategorical analysis of E-categories&quot;に2次元版米田補題が出てるようだ。→http://citeseer.ist.psu.edu/kinoshita97bicategorical.html

M. Bunge and S. Lack &quot;Van Kampen theorems for toposes&quot;にも2圏の情報が→http://citeseer.ist.psu.edu/607860.html、しかしトポスにファンカンペンてのもなんだか？

*1144915409*[雑感]めんどうだから「2」で済ます

2-圏とか2-関手とか「2-」と書いてきたが、単に「2」で済ます。それと、「2」と「bi」の区別ももうやめる。必要なら、strict 2 と weak 2 を使う。

</body>
</day>
<day date="2006-04-14" title="">
<body>
*1145007216*[雑感]モナドとモノイド

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060414/1144983506&quot;&gt;本編&lt;/a&gt;にて：
&gt;&gt;
モナド結合律とモナド単位律が、通常の（例えば整数の掛け算の）結合律・単位律とほんとに同類であることを納得するには、相当に抽象的な定式化が必要です。
&lt;&lt;

どのくらい抽象度を上げればいいのか？ モノイド圏（monoidal category）のモノイド対象を持ち出さないと、自信を持って「同類である」とは言えないだろうな。モナドとモノイドは発音が似てるけど、実際、モナドはとある圏のモノイドになっている。この事情が分かれば、モノイドつながりで「同類である」ことになる。

ところで、モノイド圏は、圏の圏におけるモノイド対象になっている。圏の圏でモノイド対象が定義できるってことは、圏の圏がモノイド圏ってことだから、圏の圏は、圏の圏の圏のモノイド対象のはずで、ってことは……  ウエエエーー。

こういう循環は、魅力的だが不気味だ。&lt;b&gt;怖い。&lt;/b&gt;子供の頃から、このての発想は恐怖だった。なのに、… 怖いもの見たさで興味があるってことか？


</body>
</day>
<day date="2006-04-15" title="">
<body>
*1145092249*[雑記][モナド]モナドとモノイドの続き

昨日：
&gt;&gt;
実際、モナドはとある圏のモノイドになっている。
&lt;&lt;

そうなることを追いかけておく（概略）。

Cが圏だとして(C, *, I)がモノイド圏（monoidal cat.）とは：

+ -*-:C×C → C は2項関手
+ I∈|C|は特定の対象
+ 結合律と単位律が成立する。

イコール記号をいくつか並べてある横線は、上側と下側が&lt;em&gt;ほぼ等しい&lt;/em&gt;（ってイイカゲンな言い方だこと）を意味する：

&lt;pre&gt;
 /* 関手としてのCは、id_Cのこと、
  * 関手としてのIは、自明な圏{-}からのIを値とする定数関手 
  */

 (C×C)×C -[(-*-)×C]→C×C -[-*-]→C
 ====================================== 結合律
 C×(C×C) -[C×(-*-)]→C×C -[-*-]→C

 C×{-} -[C×I]→ C×C -[-*-]→C // {-}は自明な圏
 ================================ 単位律1
 C -=→ C (identity)

 {-}×C -[I×C]→ C×C -[-*-]→C
 ================================ 単位律2
 C -=→ C (identity)
&lt;/pre&gt;

例：(Set, ×(直積), {0})はモノイド圏。(Kベクトル空間, (×)(テンソル積), K)はモノイド圏。

(C, *, I)がモノイド圏のとき、(X, μ, η)が(C, *, I)におけるモノイドだとは：

+ XはCの対象
+ μ:X*X → X はCの射
+ η:I → X はCの射
+ 結合律と単位律が成立する。

&lt;pre&gt;
 /* 関手としてのXは、id_Xのこと */

 (X*X)*X -[μ*X]→X*X -[μ]→X
 =============================== 結合律
 X*(X*X) -[X*μ]→X*X -[μ]→X

 X*I -[X*η]→ X*X -[μ]→X
 =========================== 単位律1
 X -=→ X (identity)

 I*X -[η*X]→ X*X -[μ]→X
 =========================== 単位律2
 X -=→ X (identity)
&lt;/pre&gt;

例：普通のモノイドは、(Set, ×(直積), {0})におけるモノイド。K代数（多元環）は、(Kベクトル空間, (×)(テンソル積), K)におけるモノイド。

&lt;h5&gt;モノイド圏End(C)&lt;/h5&gt;

Cは圏だとして、新しい圏Dを次のように定義する。

|D| = Functor(C, C)。よって、F, G:C→Cなどは対象。α::F→G:C→Cなる自然変換が圏Dの射。α::F→G:C→C, β::G→H:C→Cの結合は、普通の自然変換結合α;β::F→H:C→D。

&lt;pre&gt;
   A   -[f]→    B
α::F→G ------------
  F(A)-[F(f)]→F(B)
   |            |
  [α_A]      [α_B]
   v            v
  G(A)-[G(f)]→G(B)

   A   -[f]→    B
β::G→H ------------
  G(A)-[G(f)]→G(B)
   |            |
  [β_A]      [β_B]
   v            v
  H(A)-[H(f)]→H(B)

それで：
(α;β)_A = α_A;β_(A)::F→H:C→C
&lt;/pre&gt;

ここで、FとG:C→Cの結合F;Gを、混乱を避けるためにF*Gという記号に変える（α;βはそのまま使う）。Iは恒等関手id_Cのことだとすると、I∈|D|である。

さて、Dの対象（Cの自己関手）に既に定義されている*（もとは;と書いていた）を、Dの射（自然変換）にも定義する。α::F→F'、β::G→G' だとして、α*β::F*G→F'*G' を次のように定義する。

&lt;pre&gt;
    A   -[f]→   B
α:: F→F' ---------------
  F(A)-[F(f)]→F(B)
   |           |
 [α_A]      [α_B]
   v           v
  F'(A)-[F'(f)]→F'(B)

上の四角図式をGで移す：
  G(F(A))-[G(F(f))]→G(F(B))
   |                   |
 [G(α_A)]          [G(α_B)]
   v                   v
  G(F'(A))-[G(F'(f))]→G(F'(B))

それとは別に：
    F'(A)   -[F'(f)]→   F'(B)
β::G→G'------------------------
  G(F'(A))-[G(F'(f))]→G(F'(B))
    |                     |
  [β_F'(A)]          [β_F'(B)]
    v                     v   
  G'(F'(A))-[G'(F'(f))]→G'(F'(B))

それで：
(α*β)_A = G(α_A);β_F'(A)
α*β::F*G → F'*G':C→C
&lt;/pre&gt;

α*βが再び自然変換になることは、可換性の伝搬を追えばわかる（*は自然変換の横結合である）。(D, *, I)がモノイド圏であることはルーチンワーク（けっこうな手間）で確認できる。Dは、Cの自己関手を対象とする圏なのでEnd(C)と書くことにする（End(C) = |D|なので適切じゃないけど）。End(C)の射は自然変換で、通常の自然変換の結合（縦結合）以外に、演算*が定義されている。

モノイド圏(End(C), *, I)におけるモノイドとは、F∈|End(C)|とη:I→F、μ:F*F→Fの組である。Cで考えればFは自己関手、ηはI=id_CからFへの自然変換だから、A→F(X)の族（Aがインデックス）、μはF(F(A))→F(A)の族である。結合律と単位律を、モノイド圏(End(C), *, I)のなかで書き下すと、モナド結合律とモナド単位律になる。

したがって、C上のモナドは、モノイド圏End(C)のモノイドである。一番お馴染みのモノイド圏Setのモノイド（＝普通のモノイド）とモナドは、基礎圏が違うだけで形式的定義は同じとなる。


</body>
</day>
<day date="2006-04-19" title="">
<body>
*1145439245*[圏一般論][雑記]モノイドの恐怖

先日：
&gt;&gt;
こういう循環は、魅力的だが不気味だ。&lt;b&gt;怖い。&lt;/b&gt;
&lt;&lt;

圏のモノイド（対象）の定義には、外の圏がモノイド圏である必要があるが、モノイド圏の結合律は：

&lt;pre&gt;
 (C×C)×C -[(-*-)×C]→C×C -[-*-]→C
 ====================================== 結合律
 C×(C×C) -[C×(-*-)]→C×C -[-*-]→C
&lt;/pre&gt;

これをホントの等式にするには、「≒」を同型として、(C×C)×C≒C×(C×C)を与える同型射の束（自然変換）α:(C×C)×C→C×(C×C) が必要だ。同様に、λ:C×{-}→C、ρ:{-}×C→C も必要。つまり、×（圏の直積）と{-}（自明圏）に関して、Catが非厳密なモノイド圏である事実を使う。ウーン、Catのモイノド性は具体的に示せるから循環は止まる、ともいえるのだが、「結合律の定式化に結合律が必要」という状況はなんか不安になる。気持ちが落ち着かない、というか；これが怖い感じなのだ。

それはそうと、モノイド概念はモノイド圏内で定義できるが、モナド概念は2圏のなかで定義できるのだろうか -- Fが2圏Dの1セルF:X→X（X∈|D|）として、μ::F*F→F:X→X、η::I→F:X→X（IはId_Xのこと）という2セルに対して結合律と単位律は定式化できるから、そのような(X, F, μ, η)はD内のモナドといっていいだろう。これは、D(X,X)が横結合*をモノイド積としてモノイド圏になるから、このなかでのモノイド対象になる。しかし、0セルXは構造を持たないから具体的なKleisli構成などは無理だ。単なる形式定義に意味（意義）があるのか？ あるかもしれない。

*1145439517*[高次圏論][具体例]2圏の例

+ Cat
+ Catの部分圏； モノイド圏の圏、対称モノイド圏の圏など
+ 空間、連続写像、写像のホモトピーの圏
+ いろいろなコボルディズム圏
+ 空間の点、弧、弧のホモトピーの圏
+ 荷電境界付き有向グラフの圏
+ 埋め込まれた境界付き有向グラフの圏
+ 翻訳系の圏
+ 両側加群の圏
+ 局所プレ順序な圏
+ 特にベキ構成による圏
+ settoid-enrichedな圏
+ 証明の圏（3圏）

説明； Catとその部分圏（すべてのナントカ圏、ナントカ関手、ナントカ変換からなる圏）は典型的な2圏。コボルディズムとホモトピーは2圏の幾何学的なイメージかな。

埋め込まれた境界付き有向グラフ： グラフGの頂点集合|G|にG0, G1⊆|G|が定まっている。G0∩G1 ≠ 空でもよい。空間Mに対して幾何学的埋め込みG→Mがあるとき、埋め込まれたグラフと呼ぶ。G1とH0がの像がMの同じ点集合のとき結合可能だとして、G;Hを定義する。α::G→H:S→Tは、SとTを固定するようなグラフ準同型。

証明の圏：論理式（の並び）が0セル、シーケントが1セル、推論／証明が2セル、証明の変形が3セルで、3圏になる（ような気がする）。証明ネット（証明サーキット図）があると、それは2セルを定義する。論理演算は、テンソルやパーとなる。Cut消去は、3セルを構成して、任意の2セルをCutなしの2セルに変形する定理（だろう、たぶん）。



</body>
</day>
<day date="2006-04-20" title="">
<body>
*1145498971*[モナド][具体例]モナドの例

本編にて：
&gt;&gt;
モナド概念は非常に普遍的なので、モナドの実例はとんでもなくイッパイあります。
&lt;&lt;

本編で使った例Countupは、monoidal stamping monadの一例。Outputもmonoidal stampingになる。A+A→Aをfoldingとして、X|→X+Aも似た例。A={-}のときは一点付加。comonoidal stampingでcomonadも作れる；Δ:A→A×Aとかがcomonoidの例。

多項式や一次式なども、不定元集合に関するモナドになる。置換または展開が乗法を与える。

図形や順序構造の閉包作用素もモナド。上半平面で p↓=(a, b)↓={(x, y)| x = a and y ≦ b}として、A↓={p↓ | p∈A}なんてかんたんな例だ。

Xはコンパクトハウスドルフ空間として、K(X) = Max(C(X)) とする。Maxは極大イデアル集合、C(X)は連続関数環。Kもモナドになるはずだ。二重否定とか二重双対とかがモナドを与える例もある（よく知らんが）。

*1145499109*[高次圏論][具体例]3圏の例

3圏はよくわかってないが、次はたぶん3圏だろう。

LOCを局所順序圏（locally (pre)ordered categories）の圏とする。LOCはCatの部分圏、つうかCatの部分圏への忘却関手を持つ圏となる。C, D∈|LOC|のとき、1セルを関手F:C→D、2セルを自然変換α::F→G:C→Dとして2圏となる（順序構造と整合するように定義する）。

α, β:F→G:C→Dだとすると、α_A, β_A:F(A)→G(A) （A∈|C|; F(A), G(A)∈|D|）である。つまり、α_A, β_A ∈D(F(A), G(A))。ところで、D∈|LOC|であることから、D(F(A), G(A))は順序集合であり、不等式 α_A ≦ β_A が意味を持つ（解釈可能）。

以上の状況で、すべてのA∈|C|に対して α_A ≦ β_A on D(F(A), G(A)) のとき、α≦βと定義する。これはLOC(C, D)が局所順序圏であることを意味する。順序集合を圏だと考え、α≦βを表す射をΓとすると、Γ:::α→β::F→G:C→D である。このLOCは、局所順序圏でenrichされた圏ともいえる。

</body>
</day>
<day date="2006-04-22" title="">
<body>
*1145676117*[高次圏論]横結合の絵

α::F→F':C→D, β::G→G':D→Eの横結合α*β:F;G→F';G':C→Eを絵に描いていみた。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/horiz-composition.gif&quot; &gt;
&lt;/div&gt;

(α*β)*γとα*(β*γ)を“側面”から見た図。結合律を示す目安になる。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/horiz-comp-assoc.gif&quot; &gt;
&lt;/div&gt;

実際に、この図を眺めて横結合*の結合律を示してみる。ただし、記号がかち合うことに気が付いたので：

- 圏：A, B, C, D
- 圏の対象と射：f:a→b
- 関手：F, G, H, F', G', H'
- 自然変換：α, β, γ

定義に注意すれば、ストレートに従う。
&lt;pre&gt;
// ブラケットは丸括弧と同じことだが強調の意図あり

  ((α*β)*γ) 
= H((α*β)_Fa);γ_G'F'a
= H[G(α_a);β_F'a];γ_G'F'a
= HG(α_a);H(β_F'a);γ_G'F'a

  (α*(β*γ))
= HG(α_a);(β*γ)_G'F'a
= HG(α_a);[H(β_F'a);γ_G'F'a]
= HG(α_a);H(β_F'a);γ_G'F'a
&lt;/pre&gt;

ストレートとはいいながら、図を見ないでこれを書き下すのは難しい。

*1145692404*[圏一般論]Catの性質と計算

どうでもいいようなことではあるが； 2圏Catのハナシ。

F:A→Bによる引き戻しF&lt;sup&gt;★&lt;/sup&gt;:Cat(B, C)→Cat(A, C) を次のように定義する。

- G:B→C に対して、F&lt;sup&gt;★&lt;/sup&gt;(G) = F;G :A→C
- β::G→G':B→C に対して、(F&lt;sup&gt;★&lt;/sup&gt;(β))_a = β_Fa::F;G→F;G':A→C

G∈|Cat(B, C)|に対してF&lt;sup&gt;★&lt;/sup&gt;G∈|Cat(A, C)|、β∈Cat(B, C)に対してF&lt;sup&gt;★&lt;/sup&gt;β∈Cat(A, C)、F&lt;sup&gt;★&lt;/sup&gt;が反変関手になっていることは確かめられる。よって、F|→F&lt;sup&gt;★&lt;/sup&gt; は、Cat(A, B)→Cat(Cat(B, C), Cat(A, C)) になっている。

Cat(-, -)を[-, -]と書くと、(-)&lt;sup&gt;★&lt;/sup&gt;:[A, B]→&amp;#91;[B, C], [A, C&amp;#93;]。ここで、Cは本質ではないから、(-)&lt;sup&gt;★&lt;/sup&gt;:[A, B]→&amp;#91;[B, -], [A, -&amp;#93;] とかける。&amp;#91;[B, -], [A, -&amp;#93;]をキチンと定式化すると、米田埋め込みに似てるような？

G:B→Cに対しては、G&lt;sub&gt;★&lt;/sub&gt;(F) = F;G, (G&lt;sub&gt;★&lt;/sub&gt;(α))_a = G(α_a) として共変の(-)&lt;sub&gt;★&lt;/sub&gt;も定義できる。

ところで、自然変換ι::F→F:A→Bをι_a = id_Fa :Fa→Fa で定義する。ιはFごとに決まるから、ιFと書く。すると、(ιF)*β = F&lt;sup&gt;★&lt;/sup&gt;β、α*(ιG) = G&lt;sub&gt;★&lt;/sub&gt;α が成立する。

(-)&lt;sup&gt;★&lt;/sup&gt;、(-)&lt;sub&gt;★&lt;/sub&gt;、ι(-)などで計算が簡単になるか？


</body>
</day>
<day date="2006-04-24" title="">
<body>
*1145871959*[圏一般論][モナド]分配律のハナシ

&quot;A Basic Distributive Law&quot;をザッと眺めたが、一割くらいしか分からない（一割は分かったから良かった、と考えるが）。その一割分の知識：

2つのモナドD, Uがあるとき、その関手としての結合DU（U;D）が再びモナドになることは多い。例えば、列を作る関手Listとベキ集合関手PowをつないでPow(List(-))を作ると言語関手ができるが、ListもPowもPow(List(-))もみんなモナドになっている。この現象の背後にある仕掛けは結局、分配律（を定義する自然変換）UD→DUの存在なのだ。

分配律変換の公理化はBeckが60年代（フッルーイ！）にやっていて、比較的分かりやすい可換図式で表現できる。この変換UD→DUとDU上のモナド構造が1：1対応することが大昔から知られていたのか、、、はぁー（ため息）。モナドのKleisli圏やE-M（Eilenberg MacLane）圏への持ち上げも同様に議論できるようだ（要確認だが）。

CにモナドD, Uがあるとき、DのKleisli圏C&lt;sub&gt;D&lt;/sub&gt;上でUを考えたいことがしばしばあるから、その判定条件が分配律変換の存在であると分かって、まーよかった。

それと、Kleisli構成だけじゃなくて、E-M構成も一緒に考えたほうがよさそうだ、という気がしてきたわ。


</body>
</day>
<day date="2006-04-27" title="">
<body>
*1146110974*[高次圏論]さらに変更：「二」、「三」を使う

&quot;2-&quot;と&quot;bi&quot;を区別しないとき「二」、&quot;3-&quot;と&quot;tri&quot;を区別しないとき「三」を使うことにする。

*1146111103*[高次圏論][モナド][お絵描き]絵算の基礎

二圏、三圏を扱うため、絵算（pictorial calc.）の練習をすることにした。

自然変換α::F⇒G:A→Dを描いてみる。ペースティング図、スタック図（Santiago graphical notation）、ストリング図で描くと、次のようになる。
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/d-nattrans.gif&quot; &gt;
&lt;/div&gt;

交替律（interchange law）は、スタック図、ストリング図で次のようになるだろう。
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/d-interchange.gif&quot; &gt;
&lt;/div&gt;

モナドの結合律は次のようか？ ストリング図もどきも描いてみたが、これでいいかどうかよくわからない。雰囲気は伝わる。
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/d-assoc.gif&quot; &gt;
&lt;/div&gt;

(F:C→C, μ, η）と(G:C→C, ν, ε)がモナドのとき、結合モナド(F;G:C→C, μ, η)（同じμ、ηを使ったが、Fのそれとは違う）に関する中間単位律（middle unitary law）は次のように描ける。
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/d-midunitary.gif&quot; &gt;
&lt;/div&gt;

等式的に書けば：
&lt;pre&gt;
 F;G =~→(F;I);(I;G) -[(F;ε)*(η;F)]→(F;G);(F;G) -[μ]→F;G
 ===========================================================
 F;G ==→ F;G
&lt;/pre&gt;

 これは、XとYがモノイドのとき、X×Yに入れる乗法（標準的な直積構成）に対して、(x, 1_Y)*(1_X, y) = (x, y) が成立することに対応する。

スタック図はけっこう使いやすそうだ。モノイド圏のボックス図、ワイヤー図、多圏のサーキット図もふくめて、各図の関連をハッキリさせたいものだ。

*1146111163*[高次圏論][気付いた]今さらわかったこと

絵を描いていて、今さらにわかったのだが、ペースティング図とスタック図の関係をみると、2セルがホモトピーそのもの。高次圏とホモトピー的存在は、単なる類似ではなくて、本質的に同じナニモノカの側面なのだろう。

それと、可換四角や可換三角に、2セルの膜を張り付けてみて、lax（oplax）やpseudoの意味がやっと掴めた。等式（同一性の主張）を弱くする（equals up-to *）ために、等式を高次元に持って行くわけね。「同じにする／同じとみなす」過程を明示的に取り出して、過程の法則性により、「モノが同じこと」を間接的に指定する、ってことか。


</body>
</day>
<day date="2006-04-28" title="">
<body>
*1146194433*[モナド][具体例][計算]絵算の感想

composite monadのassociativityをやってみた。

+ ストリング図のほうが描きやすく、計算しやすい。
+ コツは、グラフを部屋（chamber）にわけて、部屋の内部を規則でそっくり置き換える。
+ 書き換えるべき部屋と規則を見つけるところが発見的。
+ 分配律のBeck公理より、スワッパー（swapper）公理のほうが使いやすい。
+ スワッパーが使いやすいのは、ストリング図だと（スワッパーが）対称フリップと似た扱いになるからだ。ブレイディングに近い。

*1146194434*[高次圏論]ホモトピーとの関連

&gt;&gt;
絵を描いていて、今さらにわかったのだが、ペースティング図とスタック図の関係をみると、2セルがホモトピーそのもの。高次圏とホモトピー的存在は、単なる類似ではなくて、本質的に同じナニモノカの側面なのだろう。
&lt;&lt;

これはまったくに「今さら」だった。Baez/Dolanが書いている：
&gt;&gt;
homotopy theory is our best source of insight into n-categories.
&lt;&lt;

*1146216299*[計算][具体例][モナド]ストリング図の使いかた

ストリング図を使った絵算が少しできるようになった。Beckの分配律の公理に出てくる五角形（つうより5点四角形）2つから、スワップ結合律を示して、結合モナドの結合律が示せる。この程度なら、ストリング図で簡単。

で、絵算の計算は何をしているかというと：

+ 可換図式、またはペースティング図から、グラフ書き換え規則をいくつか作る（機械的）。
+ 与えられたグラフ（ストリング図）を眺めて、部屋を１つ作る（チャンバリング）。
+ その部屋と書き換え規則の対応をとる。一種のパターンマッチング。
+ 書き換え規則を実行した結果で、部屋の内部を置き換える。
+ おなじことを繰り返して、目的のグラフを得る。

普通の等式的計算と比べると：

- チャンバリングが部分式の特定に対応する。
- 部屋の置き換えが等式の変形に対応する。

通常の（形式的）証明と同じように、グラフ書き換え規則の集合が公理系で、その規則集合によって得られた書き換え（のマクロ規則）が定理のようなもんだ。


</body>
</day>
<day date="2006-05-02" title="">
<body>
*1146561237*[雑記]いいニュース

明日からは事務所にも来ない＝僕にはしんどい日々。

休日前に2つの懸案が片づいた、やったー！！ 以下の2つのエントリーで報告。

*1146561238*[モナド][圏一般論]Circ-Kleisli構成

懸案のCirc-Kleisli構成をやっと確認できた。対称モノイド圏Cの上の強モノイドTに対して、Circ-Kleisli圏C_+Tを&lt;strong&gt;確実に構成&lt;/strong&gt;できます。

&lt;h5&gt;Circ-Kleisli射のU-stamping&lt;/h5&gt;

C=(C; +, 0, σ)を対称モノイド圏、T=(T, μ, η, τ)をC上の強モナドとする。τはTの強度(tensorial strength)である。ただし、τは T(A)+B → T(A+B) の形を採用する（通常の定義とは左右が逆）。強度の公理もすべて左右が逆になる。

f:A+X→T(B+X)の形をしたCの射を&lt;strong&gt;Circ-Kleisli射&lt;/strong&gt;と呼ぶ。

U∈|C|に対して、&lt;strong&gt;fのU-stamping&lt;/strong&gt;を次のように定義する。

- f_U = (f+U);τ_(B+X, U);T(B+σ_(X, U))

この定義から、f_U:A+X+U → T(B+U+X) となる（UとXの順序に注意）。

&lt;h5&gt;Circ-Kleisli結合&lt;/h5&gt;

以下、Circ-KleisliをCKと略記。

f:A+X → T(B+X)、g:B+Y → T(C+Y) が2つのCK射とするとき、&lt;strong&gt;CK結合&lt;/strong&gt;##を次のように定義する。

- f##g = f_Y # g_X

ここで、#は普通のKleisli結合； u#v = u;T(v);μ。

Aの&lt;strong&gt;CK単位&lt;/strong&gt; A+0 → T(A+0)は、Tの単位ηとする。正確にいえば、(η+0);τ_(A, 0)である。

&lt;h5&gt;仮定する等式群&lt;/h5&gt;

CK射の全体は、CK結合とCK単位に関して圏になる。これを示すためには次の等式群が使われる。単位律は簡単だから、結合律の証明に関して述べる。

まず、通常のKleisli圏の結合律に相当する次の等式。f:A→T(B)として：
&lt;pre&gt;
 TT(A) -[μ_A]→ T(A) -[T(f)]→ TT(B) -[μ_B]→ T(B)
 ===================================================
 TT(A) -[TT(f)]→ TTT(B) -[T(μ_B)]→ TT(B) 
   -[μ_B]→ T(B)
&lt;/pre&gt;

次の2つは強度の公理：
&lt;pre&gt;
 T(A)+B+C -[τ_(A, B)]→ T(A+B)+C 
    -[τ_(A+B, C)]→ T(A+B+C)
 ==================================
 T(A)+B+C -[τ_(A, B+C)]→ T(A+B+C)

 
 TT(A)+B -[μ_A +B]→ T(A)+B  
    -[τ_(A, B)]→ T(A+B)
 ===============================================
 TT(A)+B  -[τ_(T(A), B)]→ T(T(A)+B) 
    -[T(τ_(A, B))] → T(T(A+B))  
    -[μ_(A+B)]→ T(A+B)
&lt;/pre&gt;

そして、（&lt;em&gt;忘れないでね&lt;/em&gt;）τが自然変換であること。K(A, B)=T(A)+B、L(A, B)=T(A+B)とすると、τ::K⇒L となっている。これを、f:A→B、u:X→Yに関して書き下すと：

&lt;pre&gt;
 T(A)+X -[T(f)+u]→ T(B)+Y -[τ_(B, X)]→ T(B+Y)
 ===============================================
 T(A)+X -[τ_(A, X)]→ T(A+X) -[T(f+u)]→ T(B+Y)
&lt;/pre&gt;

&lt;h5&gt;計算法&lt;/h5&gt;

 このままだと、計算はけっこう大変である（brute force calc.）。全部pictureに翻訳して、絵算（pictorial calc.）を行う。仮定する等式群を、絵算のグラフ書き換え規則にして、そのパターンを参照しながら、グラフ書き換えを行う。T(-)を「四角の箱で囲む」、τを「合流して箱に入る」、μを「入れ子の箱から中身の箱を引っ張り出す」ような印を使うと直観的に絵算を遂行できる。射の方向を上から下にしたほうがレイアウトが楽なようである。

*1146561239*[モナド][気付いた]モナドの作用乗法（action multiplication）

うーーーん、なんでこんな事に気が付かなかったんだぁー！！ 灯台もと暗し、コロンブスの卵だ。これがmissing pieceだったんだ。独断で目が曇っていた。

1つ前のエントリーと似た記号を使っているが、独立（別物）である。

(L, μ, η)をC上のモナドとする。もうひとつのモナド(M, μ', η')を考える。MLは、M(L(-))で定義される関手だとして、τ:ML⇒Lとρ:M⇒Lという自然変換があり、次の結合律、単位律が成立すると仮定する。

&lt;pre&gt;
 MLL -[τL]→ LL -[μ]→ L
 ========================== 結合律
 MLL -[Mμ]→ ML -[τ]→ L


 IL -[ηL]→ML -[τ]→L
 ====================== 単位律1
 IL →L

 MI -[Mη]→ML -[τ]→L
 ====================== 単位律2
 MI → M -[ρ]→ L
&lt;/pre&gt;

それでKleisli圏C_MとC_Lを作ると、C_MがC_Lに作用する。（これに気付いた。）

作用をもっと詳しく記述すると； u:A→M(B), g:B→L(C)をC_M, C_Lの射だとする（正確には、Cで考えたKleisli射＝M-resultic射）。uとgの“結合”u*gを次のように定義する。

- u*g = u;M(g);τ_C

C_Lの結合＝Kleisli結合を#として、次が成立する（と思う）。

- (u*g)#f = u*(f#g)
- (u#v)*f = u*(v*f)
- B^#g = g （B^はKleisli恒等）

さらに、u:A→B は、*作用を通じてC_L＼B→C_L＼Cというスライス圏の反変関手を定義する。これからC_Mをベースとするindexed categoryも定義できる。

この事実は、メタ項やスキーマの意味論に使える。また、γ:L→Mで、γ;τが恒等であるとき、LはMに埋め込めるので、MはLの拡張としての解釈を許す。

圏Xが圏Cに作用している状況を一般的に考えるのも興味あるかもしれない。


</body>
</day>
<day date="2006-05-05" title="">
<body>
*1146781124*[モナド][圏一般論]Circ-Kleisli構成のもっといい定式化

子供が起き出す前にメモ。

直接計算で、対称モノイド圏CのTによるCirc-Kleisli圏CK_T(C)を構成できたが、CK_T(C)=Circ(Kleisli_T(C))だともっと都合がいい。実は、最初はそのような構成を目指したが、Kleisli_T(C)にモノイド構造を入れることができなくてあきらめたのだった。

CK構成にはモナドの強度（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060123/1137978147&quot;&gt;tensorial strength&lt;/a&gt;）を使ったのだが、強度付きならモノイド積が構成できるような気もしてきた。調べてみると、John Power &amp;amp; Edmund Robinson &quot;Premonoidal categories and notions of computation&quot; で既にやっていた。

まずは定義から；τがTの強度だとして、τ' = σ|τ|σ;;T として定義する（通常記法なら Tσ・t・σ）。
&lt;pre&gt;
τ':: T(A)+B -[σ]→ B+T(A) -[τ]→ T(B+A) -[T(σ)]→ T(A+B)
&lt;/pre&gt;

次の条件を満たすとき、モナド強度は可換だという。
&lt;pre&gt;
 T(A)+T(B) -[τ]→T(TA+B) -[T(τ')]→TT(A+B) -[μ]→ T(A+B)
 =========================================================
 T(A)+T(B) -[τ']→T(A+TB) -[T(τ)]→TT(A+B) -[μ]→ T(A+B)
&lt;/pre&gt;

John Power &amp;amp; Edmund Robinsonによれば：

- TのKleisli圏C_Tがプレモノイド圏となる ⇔ Tは強度を持つ
- TのKleisli圏C_Tがモノイド圏となる ⇔ Tは可換強度を持つ

つまり、Kleisli圏のプレモノイド構造と強度が1対1に対応している。Circ構成は（おそらく）プレモノイド圏でも通用するだろうから、Circ(Kleisli_T(C))はトレース付きプレモノイド圏になる。これに関しては、Nick Benton &amp;amp; Martin Hylandの&quot;Traced Premonodal Categories&quot;がある。

D=CK_T(C)は、hom-catを持つので二圏となる。A, Bを固定してhom-cat D(A, B)を考えると、CでA×X→T(B×X)なので、Cが閉圏なら、X→[A, T(B×X)]とできる。これは、関手F(X)=[A, T(B×X)]を定義するので、home-cat D(A, B)はFの余代数の圏と考えられる。つまりD(A, B) = Coalg_F(C)。

Cが閉でなくても、Int(CK(C))を構成してコンパクト閉圏が構成できる。CをインスティチューションのSignとしてInt(CK(C))の射こそ、コンポネントを定義するとふんでいる。

一番簡単な例は、ミーリー機械と線形文法（元祖BNF）だから、これを調べよう。


</body>
</day>
<day date="2006-05-06" title="">
<body>
*1146901543*[モナド][圏一般論]Circ-Kleisli構成、それから

あんれー、実際に定義を書き下したり計算してみたら、どうも予想と違うぞ。

まず、Moggiが触れていたTの強度τ:A+T(B)→T(A+B)を使ったペアリング T(A)+T(B)→T(A+B)は、τの左右を逆にした余強度τ':T(A)+B →T(A+B)を使って書くと自然なことがわかった。ペアリングの定義は強度と余強度（costrength）を使う順序により2種類定義できる。この2つのペアリングが一致することが可換モナド（commutative monad）の定義になる。

&lt;pre&gt;
τ':: T(A)+B -[σ]→ B+T(A) -[τ]→ T(B+A) -[T(σ)]→ T(A+B)

ペアリング:: T(A)+T(B) -[τ']→ T(A+T(B)) -[T(τ)]→ T(T(A+B))
              -[μ]→T(A+B)

ペアリング':: T(A)+T(B) -[τ]→ T(TA+B) -[T(τ')]→ T(T(A+B))
              -[μ]→T(A+B)
&lt;/pre&gt;

さて、Moggiのペアリングを使うとf:A→T(B)、g:C→T(D)のモノイド積f+g:A+C → T(B+D)は簡単に定義できる。ペアリング＝Kleisli圏のモノイド積を使ってU-stamping f_U を定義すると、けっこう複雑になる。僕の定義とはどうも違うようだ。

&lt;pre&gt;
 A+B -[f+g]→ T(B)+T(D) -[ペアリング]→ T(B+D)
&lt;/pre&gt;

もうひとつ、hom-catをうまく定義できるかどうかがポイントとなる -- hom-cat = 余代数圏 となってほしい。どんな定義がいいのかは、やっぱり例を調べるしかないようだ。とにかく例を作らないと。



*1146901880*[雑記]いろいろ

連休は忙しくて(?)メモ書くひまもない。が、いろいろ書く&lt;em&gt;べき&lt;/em&gt;ことはある。

&lt;h5&gt;デカルト性&lt;/h5&gt;

cartesianという形容詞を詮索する。

+ 有限直積がある。または、モノイド積が有限直積を与える。
+ 有限完備、有限連続。
+ 引き戻し図に関係する；デカルト自然変換、ファイブレーションのデカルト射

&lt;h5&gt;変形された自然性&lt;/h5&gt;

マクレーンの本に、対角自然性（dinaturality）、特別自然性（extranaturality）が載っている。対角自然の例は、不動点オペレータやトレースに出てくる。特別自然性は、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943110&quot;&gt;notions of process&lt;/a&gt;に出てきた。TODO: 事例と共にまとめる。

不動点では、D^Eが指数だとして、f:D→Eに対して、D^E -[(-)^f]→D^D と D^E -[f^(-)]→ E^D を考える。α_D, α_Eに関して次が対角自然性：
&lt;pre&gt;
 D^E -[(-)^f]→D^D -[α_D]→D -[f]→ E
 ====================================
 D^E -[f^(-)]→E^E -[α_E]→E
&lt;/pre&gt;

※ ついでにトレースの自然性： home-set関手 K(X) = C(A+X, B+X) と定数関手L(X) = C(A, B)を考える。K, L :C×C&lt;sup&gt;op&lt;/sup&gt; → Set 。TrのXを固定して、A, Bをインデックスとする変換（射の族）として、K⇒Lの自然性はタイトニングになる。

&lt;h5&gt;cotensorial strength&lt;/h5&gt;

コモナドにcotensorial strength（余テンソル強度）ってのがあるらしい。tensorial costrength（テンソル余強度）とは違う。bistrengthってのもあるらしい。

&lt;h5&gt;ツリー状レコードのモナド&lt;/h5&gt;

フィールド名にパスを使うと、レコードをモナドにできる。しかもイデアルモナドになる。リストモナドと複合することができて、モナド直和の例になる。モナド直和は素性構造になる。

パラメータを持ったモナドの例でもある。これは、インデックス圏かファイブレーションだろう。

</body>
<comments>
<comment>
<username>酒井</username>
<body>dinaturalityのdiって対角に由来するのでしょうか。&lt;br&gt;私はずっと「両～」のdiだと思ってたのですが…</body>
<timestamp>1146962825</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>僕もdialgebraとかのdiだと思っていたのですけど、翻訳本の訳語が「対角」と「特別」だったので、（珍しく）従ってみました。そもそも「ディ」なのか「ダイ」なのかも分からないです。dialgebraはディアルジェブラだろうと思うけど、digraphはdirectedから来てるからダイグラフですよね。biも「バイ」か「ビ」かよく分からんし、、、</body>
<timestamp>1146983861</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>うぎゃ。マクレーンの英語の方の本を参照したら、セクションのタイトルが「Diagonal Naturality」になってました。……ちゃんと読んでないのバレバレの私(^^;</body>
<timestamp>1147048832</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>酒井さん、&lt;br&gt;＞ ちゃんと読んでないのバレバレの私&lt;br&gt;ふつう、ちゃんと読まんでしょう、アレは。僕は索引ひいて調べるだけ。&lt;br&gt;いずれにしても、diagonal起源なら「ダイナチュラル」ですね。</body>
<timestamp>1147074905</timestamp>
</comment>
<comment>
<username>酒井</username>
<body>＞ふつう、ちゃんと読まんでしょう、アレは。僕は索引ひいて調べるだけ。&lt;br&gt;&lt;br&gt;おー。そういうものなのですか。&lt;br&gt;なんか安心しました(^^;&lt;br&gt;&lt;br&gt;P.S.&lt;br&gt;グロッサランダムの完備ハイティング代数は完備束になってるハイティング代数だと思いますよ。</body>
<timestamp>1147280492</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>＞ なんか安心しました(^^;&lt;br&gt;安心しないでちゃんと読んだほうがいいのであろうけど、、、&lt;br&gt;＞ 完備ハイティング代数は完備束になってる&lt;br&gt;あ、そういうことですか、どうもありがとうございます。</body>
<timestamp>1147309723</timestamp>
</comment>
</comments>
</day>
<day date="2006-05-08" title="">
<body>
*1147077417*[雑記]愚痴

もう疲れた、ホント。頭も霧がかかった状態。

でも、早いところBeckの分配律とか強度（strength）とかの話を書き記しておかないと、まーたサッパリ-スッパリと忘れたりするんだよなぁ。

リハビリしないと。


</body>
</day>
<day date="2006-05-10" title="">
<body>
*1147222954*[雑記][圏一般論][課題]境界付きグラフ

境界付きグラフについて、やっぱり書くべきだよな。非常にいい素材だから。

+ 開いた辺を持つ／持たないグラフを考えて、inclusionと閉包を考えると随伴
+ in境界、out境界、境界全体（in/ouの対）を対応させるとファイブレーション
+ 境界での接合で圏。直和を考えて対称モノイド圏
+ hom-catを考えると二圏
+ ループ構成でトレース付きモノイド圏
+ 圏Cへのグラフ写像を考えると、圏的バンドルができる
+ FreeCat(G)はモナド
+ 圏的バンドルもモノイド二圏
+ グラフG上のバンドル圏Bundle[G]はindexed category
+ ペトリネットにすると、複圏と多圏へ拡張できる
+ 荷電（極性）を入れると、コンパクト閉圏、ダガー・コンパクト閉圏
+ アティヤのTQFTを構成できる

*1147248190*[圏一般論]概念と名前

&lt;h5&gt;近アーベル圏&lt;/h5&gt;

アーベル圏を弱めたような概念を考えている。semi-additiveとかsemi-Abelianて概念があるにはあるが定義が安定してない。

それで&lt;strong&gt;近アーベル圏&lt;/strong&gt;（near-Abelian / nearly Abelian category）とでも呼ぶことにしよう。

+ 双積と零対象がある。（双積は積かつ余積、零は終かつ始対象）
+ 可換モノイドでenrichされている。

近アーベル圏では行列計算ができて、End(A)が半環になる。

&lt;h5&gt;重畳モナド&lt;/h5&gt;

モナドLとGに&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561239&quot;&gt;作用乗法が付いた構造&lt;/a&gt;。典型例は、Lが言語モナドでGが文法モナド。こういう構造、調べても見つからないので、とりあえず&lt;strong&gt;重畳モナド&lt;/strong&gt;とでも呼んでおこう。overlayかoverlapped。作用乗法により２つのKeisli圏がほとんど重なってしまうから。

&lt;h5&gt;トロピカル&lt;/h5&gt;

トロピカル代数（半体）って、max-plus代数のことだったんだ。和が積に変わるからlogっぽいわけだが、超離散化とかベキ等解析にも関係するらしい。トロピカル代数の多項式で定義される実の図形の幾何がトロピカル幾何らしい。

なんでも創始者がブラジル人だったからトロピカルなんだとさ。


</body>
</day>
<day date="2006-05-12" title="">
<body>
*1147423777*[雑記]衒学趣味じゃなかったのね

コンピューティング・サイエンスの話にコボルディズムやホモトピーを持ち出すなんてのは、イヤミな衒学趣味だと感じていたわけだが、どうもそういうことではなかったんだなあー。

境界概念はホントに重要だ。だから、コボルディズムはほぼ必然だったんだ。


</body>
</day>
<day date="2006-05-16" title="">
<body>
*1147744765*[プログラム意味論][形式言語理論]反アクセッサと反ミューテータ

僕は激しく健忘症だ。トシのせいもあろうが、どうも、若い頃から物覚え悪く、&lt;em&gt;すぐさま忘れる&lt;/em&gt;ほうだったし。でまー、なるべく思い付きは外在化しないとね。

メイヤー先生の影響で、インターフェースをアクセッサ（クエリー）とミューテータ（コマンド）にわけるべきと言っているが、もう少し追加・細分すると：

- 基本アクセッサ：戻り値が基本データ型
- 基本じゃないアクセッサ：戻り値が基本データ型ではない（通常は参照、状態型）
- コンストラクタ：普通の意味、ただし引数は基本型
- ミューテータ：状態遷移

&lt;h5&gt;状態項と反アクセッサ／反ミューテータ&lt;/h5&gt;

コンストラクタもミューテータも関数形式で書いて（隠れたthisを陽に書く）、次の記号表現を状態項と呼ぶ。

- 変数、定数
- コンストラクタ（引数は埋める）は状態項である。
- sが状態項、mがミューテータ（基本型引数は埋める）なら、m(s)も状態項である。

cをコンストラクタ、mをミューテータとして、特別な状態項 c(x1, ..., xn), m(s, y1, ..., ym)を考えて、

- f(c(x1, ..., xn)) = xi
- k(m(s, y1, .., ym), y1, ..., ym) = s

のような等式がKleene等号で（if-definedで）成り立つとき、fをcの反アクセッサ、kをmの反ミューテータと&lt;em&gt;とりあえず&lt;/em&gt;呼ぶ（ネーミングが激しく良くないから変更するだろう）。

&lt;h5&gt;言語理論からの例&lt;/h5&gt;

$()をコンストラクタ, a(-), b(-)をミューテータとする。状態項は、$(), a($())、b(a($()))など。これらを、ε, a, ba などの文字列と同一視する。反ミューテータa', b'を：

- a'(ax) = x
- b'(bx) = x

として導入する。a'とb'は、すべての文字列の集合の上の部分関数として解釈できる。さらに、a', b'を列言語の集合上の全関数と解釈できる。列言語を状態点とする状態空間の上で、a', b'はミューテータとして定義できる。これが、いわゆる「言語の微分」の議論だろう。

ツリー言語の場合には：

- a#(a&lt;x&gt;) = x
- a'(ax) = x

のようにして、ミューテータ（アルファベットに対応）aに対して、縦・横二方向の反ミューテータが定義される。ツリー言語を状態点とする状態空間を考えれば、列言語と同様な議論ができる。

ただし、この定式化では並列パージングやボトムアップパージングをうまく説明できない。いずれ、項、時間、状態の概念を変えなくてはならない。

&lt;h5&gt;部分関数の完備join半束への持ち上げ&lt;/h5&gt;

もう少し詳しくいうと、f:X→Yが部分関数のとき、f_0:X→Y+1を普通に定義できる。Y+1はPow(Y)に普通に埋め込んでf_1とする。f_1(a) = {f(a)} or {} となる。∪を使って、f*:Pow(X)→Pow(Y)に拡張できるが、定義からjoin半束の準同型。

部分関数の圏Partialを、完備join半束の圏CJSLattに埋め込んでいる。Partialの力学系はCJSLattの力学系として考えることができる。

&lt;h5&gt;almost invertible&lt;/h5&gt;

インターフェース（指標）Iの部分集合Jがあって、Jはコンストラクタとミューテータからなるとする。(I, J)が仕様Sにおいてalmost invertibleだとは、Jのコンストラクタに反アクセッサが存在し、Jのミューテータに反ミューテータが存在すること。もちろん、反*を定義する等式はSに入っている。

almost invertibleな(I, J, S)のモデルの圏をベースに、パーザー（受理器）概念を定式化したい。(I, J, S) から(I, J*, S*)のような双対を作れる気がする。(I, J*, S*)は全然別な圏の生き物かもしれない。構成可能性（可達性）と観測可能性が双対らしい（http://citeseer.ist.psu.edu/bidoit01duality.html）から、それをミューテータまで広げればいいのだろうか？ このへん、わかってない。ダメだー。

*1147823694*[形式言語理論][TQFT][リンク][復習]TQFTの定式化

マーク・ホプキンス（Mark William Hopkins）は「&lt;strong&gt;形式言語理論と場の量子論が似ている（同じ枠組みだ）&lt;/strong&gt;」と指摘している。僕は、このホプキンスの観察をマジメに理解したいのだな。

- [http://www.chimaira.org/docs/FLT-Questions.htm:title]
- [http://d.hatena.ne.jp/m-hiyama/20050614/1118708091:title]
- &lt;a target=&quot;_blank&quot; href=&quot;http://web.archive.org/web/20040618191737/www.uwm.edu/~whopkins/compalg/KleeneQFT.txt&quot;&gt;KleeneQFT&lt;/a&gt;

ところが、物理が&lt;em&gt;まったくサッパリわからない&lt;/em&gt;僕には、「場の量子論」と言われても&lt;strong&gt;困ってしまう&lt;/strong&gt;！手の出しようがない。

唯一なんとか見当が付くのは、アティヤの公理だけ。Mayのまとめを眺めた。

- J.P. May  &quot;NOTES ON ATIYAH'S TQFT'S&quot; → http://www.math.uchicago.edu/~may/MISC/TopQFTNotes.pdf

今日検索で見つけた次の論文は、解説になっているようだ。

- TQFT - a new direction in algebraic topology→http://arxiv.org/PS_cache/math/pdf/9912/9912085.pdf
- Multiplicative Structures of 2-dimensional Topological Quantum Field Theory→http://basilo.kaist.ac.kr/preprint/ESIPR/2003/esi1394.pdf

TQFTの定義域はコボルディズム圏だが、コボルディズムの解説は：
- Tom Weston &quot;AN INTRODUCTION TO COBORDISM THEORY&quot; →http://www.math.umass.edu/~weston/oldpapers/cobord.pdf

マーク・ホプキンス自身、KleeneQFT という言葉を使っているが、*QFTやら*FTやら、色々な例がありそうだ。僕のイメージは：

- (0+1)コボルディズムの圏で考える。次元は最小。
- ノードは、ペトリネット風に考えたほうがいいかもしれないが、当面、単なるノードでもよし。
- 半線形な量を考える。Kleene代数やトロピカル代数（いずれもsemiring）がとりあえずの例。
- 行列計算をしたい。
- バンドルは、グラフGから圏Cへのグラフ準同型（関手に拡張できる）
- バンドルの圏Bundle(G, C)を定義する。A, Bがバンドルのとき、射α:A→Bは、自然変換のようなもの。
- 「場」は、圏Bundle(G, C)の射α::A⇒B:G→Cのこと（バンドルA, Bが対象）。
- 特に、自明なバンドル（幾何学なら自明直線束）からの射はセクションを与える。
- 場があれば、力学ができる。
- 2セルとかトレースも入れたいのだが、どうするかわからない。いや、少しはわかるが。
- 作用積分はよくわからないが、経路積分（総和）は定義できるだろう。
- Bundle(G, C)のGやCを動かすとどうなる？
- Bundleはindexed categoryになるな。
- Bundle(G, C)とBundle(H, C)のgluingもできる。
- 行列Mat(Σ,Γ; C)は、Bundle(G, C)でGを特別に選んだモノだろう。
- 場からQFT関手を実際に構成する。このとき経路総和を使うのか？
- dualizer * (スター演算）は定義できるか？

あ、それと、Kleene圏に関しては：

- Wolfram Kahl &quot;Refactoring Heterogeneous Relation Algebras around Ordered Categories and Converse&quot;→http://www.cosc.brocku.ca/Faculty/Winter/JoRMiCS/Vol1/PDF/v1n12.pdf

</body>
</day>
<day date="2006-05-17" title="">
<body>
*1147834337*[雑記]ジグソーパズルを解きたい

マーク・ホプキンスの観察（&lt;a href=&quot;http://www.chimaira.org/archive/KleeneQFT.txt&quot;&gt;KleeneQFT&lt;/a&gt;）を（自分が）納得できる形で書き下すことは、僕にとっては割と大きなテーマになっている。

これはまー、ジグソーパズルだな。ただし、ピースも自分で探してきたり描いたりする必要がある。で、少しずつは組み上がっているのだが、はかばかしくはない。問題は、ピースを紛失したり、何度も（無駄に）再発見していることだ。生来の紛失癖・健忘症が&lt;em&gt;わざわい&lt;/em&gt;している、哀しい、なさけない。

全体の絵柄は（おぼろげながらも）予想がついている。はまったピースもいくつかある。はまってないピースの管理をシッカリすれば、ことは進むはずだ。それと、空白部分（わかってないところ）の輪郭がハッキリすれば方策も立てられるのだ。

いずれにしてもだ、もう少し系統的にパズルを解かないと、絵は永久に完成しないがね。もう、いつ死ぬか分からんしよー。

*1147835358*[形式言語理論][圏一般論][まとめ][課題]形式言語理論から力学へ向かう（あるいは逆の）ために

直前のエントリで書いた「空白部分（わかってないところ）の輪郭」をスケッチするために書く。すっげー&lt;em&gt;ラフスケッチ&lt;/em&gt;だけど。

&lt;h5&gt;項モナドからの構成&lt;/h5&gt;

まず、指標Σに対する圏C上の項モナドT_Σから出発。T=T_ΣのKleisli圏C_TとCirc-Kleisli圏C_+Tは作れる。が、C_T、C_+Tの二構造（two-structure）、モノイド構造、トレース構造が完全にわかっているわけではない。

指標Σと変数集合の類Vから出発すると、単純代入系と再帰代入系ができる。Σ項tから項グラフ（グラフ項とよんだほうがいいのかもしれないが）を作れる。このグラフは解放辺（開いた辺）を持つものだ。単純代入系／再帰代入系からもグラフができる。こっちはペトリネットに近い、関数ノードと変数ノードを持つ。

Σの項、単純代入系、再帰代入系がそれぞれ、解放辺付きΣグラフ、境界付き（アサイクリック）Σグラフ、境界付きサイクリックΣグラフに対応する。一方で、C_T=C_Σの射（Kleisli射）は単純代入系で表現されるから、境界付きΣグラフを定義する。同様に、C_+T=C_+Σの射（Circ-Kleisli射）は境界付きサイクリックΣグラフを定義する。

まとめると、指標Σごとに、

- Σ単純代入系の圏 = Kleisli圏C_T = C_Σ ⊆ 境界付きΣグラフの圏
- Σ再帰代入系の圏 = Circ-Kleisli圏C_+T = C_Σ ⊆ 境界付きサイクリックΣグラフの圏

一方、C_T⊆T_+Tなのだから、&lt;strong&gt;項モナドT_ΣのCirc-Klsisli圏と境界付きサイクリックΣグラフの圏を詳しく調べればいい&lt;/strong&gt;という方針は得られる。

&lt;h5&gt;圏bGraph上の力学&lt;/h5&gt;

境界付きサイクリックΣグラフの圏をbGraph_Σと書く。Σが明らかなら単にbGraph。

- bGraphは(0+1)コボルディズム圏
- bGraphは、それだけでは意味論を持たない（構文的な圏）
- bGraphは二構造を持つはず、その二構造はよくわかってない。複数の二構造を持つかも。
- bGraphは n &gt; 2のn構造を持つ（持たせられる）かもしれない。
- bGraphにトレース（いやっ、フィードバックか）を定義できるはず。
- bGraphはコンパクト閉圏に埋め込めるはず。

問題となるのは、bGraph上に意味論をどう組み立てるか -- そのためにTQFTを採用したい。具体的にTQFT関手を作るのだが、まず、グラフG上に「場」を構成して、その場からTQFT関手を作るつもりだ。がしかし！ &lt;em&gt;場の方程式＝力学を定義する原理がよくわからない&lt;/em&gt;、アヘーーーー。「最小作用の原理」なのかな？

&lt;h5&gt;近アーベル圏と行列計算&lt;/h5&gt;

普通のTQFT（より一般にxQFT, xFT）の場合、TQFT関手の値の圏はアーベル圏である。物理／幾何的な文脈なら、有限次元の複素ベクトル空間の圏になることが多い。有限次元の代わりにヒルベルトとするとか、一般の体を考えたりもする。

形式言語理論に対してアーベル圏では辛い。ベキ等半環上の加群の圏がふさわしいだろう。ベキ等性までは仮定しなくていいが、半環を使う必要はある。それで、近アーベル圏が欲しくなる。僕が考えている近アーベル（nearly Abelian）な圏とは：

+ 射の足し算ができる； 可換モノイドでenrichされている。
+ 双積が存在する； 有限積、有限余積を持ち、それが一致する。
+ 零対象を持つ；始対象、終対象を持ち、それが一致する。

他にも必要な条件があるかもしれないが、欲しい事実は：

+ 双積と零対象を特定（distinguish）することにより、対称モノイド圏となる。
+ End(A)が半環となる。
+ 行列計算ができる。

特に行列計算は重要。I, Jが集合だとして、a:I+J → |C|とA:J×I→Cが行列だとは、A(j,i) : a(i)→a(j) in C となっていること。Aの意味は、Σa(i) → Σa(j) なるCの射で与えられる；ここで（ここだけ）Σは双積。

&lt;h5&gt;C係数行列の圏とグラフの圏／場の圏&lt;/h5&gt;

※記述が多少混乱しているが、直さない。

近アーベル圏Cを固定する。添字集合の圏Vも固定する。実際上、VはSetだと思ってもよい。

Mat(V,C)は行列の圏である。|Mat(V, C)| = V となっている。I, Jに対して、Mat(V, C)(I, J)を単にMat(I, J)とも書く。A∈Mat(I, J)のとき、添字を明示すると、A(j, i)となるのはあきらめる（イヤだけど）。

A∈Mat(I, J)、つまり、A:I→J in Mat のとき、IとJの完全二部グラフ上に、係数a(j, i)で辺ラベリングができる（辺の向きはIからJとする）。IからJの二部グラフをBip(I, J)とすると、BipはMatからbGraphへの埋め込み関手を定義して、さらに、辺ラベル付きのグラフはバンドル（バンドルも接続付きだから「場」と考えてよさそう）となる。

もう少し整理するために、近アーベル圏Cの対象Iを決める。I≠Oとして、K = End(I)。V=Setとする。0は零対象の恒等、1はIの恒等だとする。これで、係数が0, 1だけからなる行列はMat(C) = Mat(V, C)で意味を持つ。

Setの射、つまり普通の写像と、Setの二項関係は、Mat(C)に埋め込める。より具体的には、Mat(C)の{0,1}係数の行列に埋め込める。一方で、有向二部グラフを考えると、普通の写像も関係もbGraphに埋め込める。Matを経由した埋め込みと、直接二部グラフを作る埋め込みは同じものである。

さてここで、SetもRelもMat(C)もbGraphも全部埋め込める大きな圏を作る。それが「C値バンドルの圏」。バンドル圏の対象は、添字集合I（これは境界ノード集合ともみなす）で添字付けられたCの対象の族。バンドル圏の射{a_i|i∈I}→{b_j|j∈J}は、I, Jを境界とするグラフG上で定義されたCへのグラフ準同型で、境界IとJへの制限が{a_i|i∈I}、{b_j|j∈J}に一致するもの。

bGraphをバンドル圏に埋め込むには、すべてのノードをI∈|C|に対応させて、すべての辺を1 = Id_I∈Cに対応させる。Mat(C)のバンドル圏への埋め込みは、二部グラフ上のバンドルを考えればよい。

&lt;h5&gt;課題&lt;/h5&gt;

- 近アーベル圏Cに係数を持つ行列圏Mat(C)と行列計算を調べよ。
- 近アーベル圏にテンソル積を定義できないか。Iはテンソル単位としたい。
- Mat(C)内で形式的にテンソル積（クロネッカー積）を定義できないか。
- 二圏上のトレースの定義はどうあるべきか。
- Circ-Kleisli圏の上の二構造とトレース構造を調べよ。
- bGraph上の二構造とトレース構造を調べよ。
- バンドル圏を正確に定義せよ。
- バンドル圏は、局所的に（グラフごとに）圏構造（射は場）を持つが、大域的な圏構造と局所的な圏構造の関係をハッキリと。
- 具体的なTQFTは、行列圏Mat(C)（添字は集合）に値を持つが、これは随伴対を定義するのではないか。
- 行列の基本変形は、なにか2セルを定義するのではないか。
- グラフ書き換えとの関係は？
- 近アーベル圏の例をたくさん作れ。

うーん、これらを調べても、静的な構造しか出てこない。力学＝場の方程式＝運動の法則はどこでどう入ってくるのだろう。別な言い方すると、時間をどこで入れるか？ 

コボルディズムの説明で、境界多様体は「空間概念」で、コボルディズム多様体は「時空概念」だと説明があった。時区間は[0, 1]でモデル化される。しかし、時間が[0, 1]ってのは単純すぎるしな。

*1147858001*[形式言語理論][プログラム意味論]ネロード同値とか

今日はメモ編をやたらにイッパイ書く日だな、ウン。

列言語の理論で、言語Lが正規言語であることは、Lから作ったネロード（マイヒル/ネロード）同値による商集合が有限集合になることと同値となる。このネロード同値関係は、振る舞い同値（behavioural equivalence; 実験・観測で識別不可能）の特殊なケースになっている。

&lt;h5&gt;振る舞い同値と商状態空間上の実装&lt;/h5&gt;

まず、次のようなアメナブルな（アクセッサとミューテータだけからなる）インターフェース（指標）を考える。

+ コンストラクターは1つだけ：$()とする。
+ アクセッサは1つだけ:ψ(x)とする、値は真偽値。
+ ミューテータはいずれも1引数（状態を引数にとる）で、a(-), b(-)など。

状態xに対して、b(a(x))を(x).a.b のようにも書く。a.bのようなパス表記は、ミューテータの連続適用で、{a;b}のような複文ともみなせる。p, qなどはミューテータのパス（あるいは任意の文）を表す。

状態空間がSであるインターフェースの実装（モデル）があったとして、x, ｙ∈Sが振る舞い同値（あるいはネロード同値）だとは、任意パスqとアクセッサψに関して：

- ψ((x).q) = ψ((y).q)

振る舞い同値を≡として、S' = S/≡ を作って、その上に再びインターフェースの（抽象）実装を（理論上は）定義することができる。この（商空間を使った）実装は、“最小”な実装といってよい。

&lt;h5&gt;実装と言語の受理&lt;/h5&gt;

ミューテータと同じ記号集合をアルファベットAとして、Aの列の全体を状態空間とした実装を考える。ミューテータaは、a(x) = x・a （右連接）として定義する。b(a(x)) = (x・a)・b = x・(ab)などに注意。$() = 空列、ψ(x) = [x∈L] とすると、振る舞い同値は、Lによるネロード同値になる。

上の定義は、インターフェースの超越的な、しかし標準的な実装になっている。Lはこの状態空間の部分集合になっている。Lを決めるとψが決まり、それに対して商状態空間も決まる。ミューテータの列により状態空間内を空列（それが始状態）からL内部（それが終状態）まで運動できるかどうかが、言語の受理の問題となる。

&lt;h5&gt;別な実装&lt;/h5&gt;

Ruttenに従えば、もっと巨大な状態空間の標準実装がある。アルファベットAの言語の全体を状態空間とする。ミューテータaをaによる微分として定義する。ψはψ(X) = [ε∈X]で定義する。これも超越的な実装となる。Lは状態空間の点になっている。

振る舞い同値は、

- 任意の列qに対して ε∈q(X) ⇔ ε∈q(Y)

一般に、状態空間Sの実装に対して、Pow(S)の実装を作れるってことだろう。Sが部分力学系（遷移がpartial）でもPow(S)は全域になる点がメリットか？ SでもPow(S)でも振る舞い同値による商は定義できる。


</body>
</day>
<day date="2006-05-18" title="">
<body>
*1147942817*[雑記]notion of ナントカ

Moggiがnotion of computationって言ったのはだいぶ昔だが、抽象化したものを notion of * って呼ぶのが習慣化したのかな。続くエントリーに、&lt;strong&gt;notion of process&lt;/strong&gt;と&lt;strong&gt;notion of behaviour&lt;/strong&gt;の定義を書いておく。

*1147943110*[圏一般論][プログラム意味論]Notion of Process

&quot;Categories of Processes Enriched in Final Coalgebras&quot;（http://citeseer.ist.psu.edu/411633.html）から。

C=(C, ×, I)がモノイド圏だとして、C上(over C)のnotion of processとは：
- 三項の関手T:C×C&lt;sup&gt;op&lt;/sup&gt;×C→C
- extranaturalな族 i_A : I→T(I, A, A)
- extranaturalな族 c_X,Y,A,B,C : T(X, A, B)×T(Y, B, C)→T(X×Y, A, C)

具体例は、T(X, A, B) = [A×X, B×X]（[-, -]は内部hom）。満たすべき条件（公理）は：

&lt;pre&gt;
 T(X, A, B)×I -[id×i_B]→T(X, A, B)×T(I, B, B) 
     -[c]→ T(X×I, A, B)
 ================================================
 T(X, A, B)×I =→ T(X×I, A, B)

 I×T(Y, A, B) -[i_A×id]→ T(I, A, A)×T(Y, A, B)
    -[c]→ T(I×Y, A, B)
 =================================================
 I×T(Y, A, B) =→ T(I×Y, A, B)

 T(X, A, B)×T(Y, B, C)×T(Z, C, D) -[c×id]→T(X×Y, A, C)×T(Z, C, D)
    -[c]→T(X×Y×Z, A, D)
 =====================================================================
 T(X, A, B)×T(Y, B, C)×T(Z, C, D) -[id×c]→T(X, A, B)×T(Y×Z, B, D)
    -[c]→T(X×Y×Z, A, D)
&lt;/pre&gt;

T(X, A, B)は、Xがプロセスの内部空間（状態、ストレージなど）、Aが入力、Bが出力であるプロセスの全体（を対象と見なしたモノ）。i_Aは任意のデータ型Aに対して、内部空間I（自明空間）としてAの恒等を対応させる。c_X,Y,A,B,Cは、A→C(内部空間X）とB→C（内部空間Y）を順次合成する操作。

この定義では、Cが閉モノイダルだとか自分自身でenrichされているとか言ってないが、事実上内部homを持っている状況を想定しているようだ。高階対象を考えるときは自然な仮定だが。

Tが、（Cではなくて）他のモノイド圏Dに値をとるケースを考えるとどうなるだろう。なんか、Circ-Kleisli構成と似た状況のような気がするぞ。

*1147943257*[圏一般論][プログラム意味論]Notion of Behaviour

&quot;Notions of Behaviour and Reachable-Part and their Institutions&quot;（http://www.cs.le.ac.uk/~akurz/Papers/beh-reach.ps）から。

Cに対する(for C)notion of behaviourとは：
- B:|C|→|C| （対象に対して定義された写像）
- 射の族 η = {η_M: M→B(M) | M∈|C|}

条件は：
+ η_Mはepiである。
+ (-)# : C(M, B(M)) → C(B(M), B(N))があって、η_M;f# = f

(-)# : C(M, B(M)) → C(B(M), B(N))の一意性は、epi条件から出てくるので、次のように定義してもよい。

- B:|C|→|C|
- epiの族 η = {η_M: M→B(M) | M∈|C|}
- M, Nごとに(-)# : C(M, B(N)) → C(B(M), B(N))
- 条件：η_M;f# = f

具体例は、オートマトンの圏で、B(M)はMの最小実現（つまり、マイヒル／ネロード定理の帰結）。M→B(M)は商集合への射影（epi）。

しかし、これは他の人が定義したbehaviour functorとはだいぶ違うな。notion of minimal realizationでしょう。まー、もっとも、B(M)=B(N)によって、behavioural equivalenceを定義できるからイイってことはあるだろうが。

結局、notion of behaviourは、unitがepiなidempotentモナドになっているので、新しい概念が出てくるわけではない。むしろ、他の圏へのbehaviour functorがあるとき、notion of behaviourをrespectすべしって感じで使うのだろうね。

*1147943512*[圏一般論][具体例]タングルの圏と図解法の正体

category of tanglesの例を記す。

I=[0, 1]として、“正方形”I×Iのなかのn個の点を対象とする。A, B, Cなどが正方形に入った有限個の点だとして、射A→Bは、キューブ(I×I)×Iに埋め込まれた紐の、キューブ自己同型（の適当なクラス）で移りあう同値類だとする。ただし、紐は切れたり合流せずに、天上から床に降りていくものとする。この仮定では、A→Bの射があれば、Aの点の個数=Bの点の個数。f:A→B、g:B→Cの結合は、高さを半分にして、縦に積み重ねたキューブ（の類）で定義する。id_A:A→Aは、まっすぐに降りる紐（の類）。

床と天上である正方形を横に並べて適当に縮尺する操作により、モノイド積が入って、対称モノイド圏になる。このままではトレースを入れられないが、任意のコンパクト1次元多様体（適当な個数の円と線分の直和になる）の境界（線分の両端）を保ってキューブに埋め込む写像（の同値類）を射だと考えるとトレースを定義できる。

要するに、トレース付き対称モノイド圏を表す図そのものが、実際にトレース付き対称モノイド圏となる（当たり前のような不思議なような）。点に電荷を与えて、多少の特異点を許すとなコンパクト閉圏となる。

我々が使う図解は、見えざるものを可視化していたのではなくて、典型例そのものを提示していたに過ぎないわけだ、なるほど！


</body>
</day>
<day date="2006-05-19" title="">
<body>
*1148032273*[雑記]グロッサランダムを再開（たぶん）

そもそもこのメモ編は、chimairaサイトの&lt;a href=&quot;http://www.chimaira.org/docs/Glossarandom.htm&quot;&gt;グロッサランダム&lt;/a&gt;の代わりとしてはじめたのだった（→&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135301465&quot;&gt;その事情&lt;/a&gt;）。グロッサランダムは、用語に関する短いコメントを箇条書きでひたすら並べる書き方をしていた。が、そのコメントを後で読むと意味不明なことがあるので、ちゃんとした説明を伴うメモでないとダメだと思ったわけ。

だが、箇条書きで並んでいるスタイルもときには便利。それで、またグロッサランダムをはじめる。が、このメモ編のなかに書く。はてなの「過去に書き込む」機能を使って、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/19000101/&quot;&gt;1900-01-01からのエントリー&lt;/a&gt;をグロッサランダム用に使用。グロッサランダムで日付は重要ではないから、これでいい。

グロッサランダムに気楽にベタベタ書いて、そのなかからトピックを選んでメモ・エントリーにするって感じだろうか。


</body>
</day>
<day date="2006-05-20" title="">
<body>
*1148108427*[雑記][圏一般論]いろいろな構造

僕が興味を持っている圏は、かなりリッチだな。だいたい、次のような構造を持つようだ。

- モノイド構造： 対象にモノイド積があり、射にも積が定義できる。
- 二構造： homがcatになっている、hom-cat。2セルの縦／横結合がある。ときに三構造を持つケースも。
- スター／ダガー構造： involutiveな反変自己関手がある。identity-on-objectsならダガーオペレータ。モノイド構造、二構造（があれば、それ）と協調する。
- ファイブレーション／インデキシング： 基底圏があって、そこへのファイブレーション、または基底圏からの圏(Cat)値関手。複数のファイブレーション／インデキシングがあるかもしれない。
- enrichment構造：厳密二構造はenrichmentの例。可換モノイドでenrichされれば、semi-additive、内部homを持つケースが多い。内部hom（hom積）の随伴としてテンソル積が定義できることもある。
- トレース／不動点構造：一般的にはトレース。繰り返しや不動点オペレータのこともある。

現実のモデルは、それなりに複雑豊饒なのだろうね。


</body>
</day>
<day date="2006-05-23" title="">
<body>
*1148367773*[プログラム意味論][インスティチューション]ソートと演算記号の分類

Bidoit、Hennicker、Kurz等が、指標に現れるソートや演算（operation）の記号を分類している。彼らは、天下りにコンストラクター記号Consとオブザーバー（観測子）記号Obsを与える。Cons∩Obs = 空 だと思うが、明示的な記述はなんか見あたらない。

とりあえずまとめると：

|* 原語           |* 訳語（試訳） |* 説明 |
|constrained sort |制約ソート  |コンストラクタの値となっている |
|loose sort       |非制約ソート|constrainedでない |
|state/hidden sort|状態／隠蔽ソート|オブザーバーの（主）定義域となっている|
|observable sort  |観測量ソート |stateでない|

原語もあんまり適切じゃない気がするが、訳語も変な感じだ。ed付き形容詞は毎度悩むし。

それはそうと、観測量ソートはオブザーバーの値としては定義されて&lt;em&gt;いない&lt;/em&gt;。オブザーバーは状態ソートを値としてもよい。これは自然かもしれない。観測量ソートを値とするオブザーバーは&lt;strong&gt;直接オブザーバー&lt;/strong&gt;、そうでないものは&lt;strong&gt;間接オブザーバー&lt;/strong&gt;と呼んでいる。

「多くのケースでは、状態ソートは制約ソートである」と言っているが、非制約の状態ソートも認める。観測量ソートは、制約でも非制約でもあまり影響はないような感じである。だいたいの雰囲気は：

|* -      |* 制約    |* 非制約 |
|* 状態   |生成可能なオブジェクト | 生成できないオブジェクト |
|* 観測量 |定数を持つ値 | 定数が存在しない値 |



</body>
</day>
<day date="2006-05-25" title="">
<body>
*1148523219*[形式言語理論][トレース／コンパクト閉圏]Kleene代数の行列計算とトレース

Kozenは、Kleene代数Kを係数とする正方行列の代数Mat&lt;sub&gt;K&lt;/sub&gt;(n, n)が再びKleene代数になることを示した。半環になることはすぐさまわかるから、問題はKleeneスターの定義となる。これが非常に憶えにくい。

2×2行列のときが本質的で、あとはinductionだから、2×2で話す。第1行が[a b]、第2行が[c d]である行列を[a, b; c, d]と書くことにすると、[a, b; c, d]* は：

- [(a + bd*c)*, (a+bd*c)*bd*; (d+ca*b)*ca*, (d+ca*b)*]

ウゲッ、天下りに暗記はシンド過ぎる。

が、Cazanescu, Stefanescu, Hyland, Hasegawa（カザネスク、ステファネスク、ハイランド、長谷川）などの結果を参照すると、絵算で計算できる。まず、双積と零対象でモノイド圏になっているような対称モノイド圏を考える。そこにトレースがあれば、endo射f:X→XのKleeneスターf*が次のように定義できる。

- f* = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;X,X&lt;/sub&gt;(∇;f;Δ)

∇は余対角、Δは対角である（対角はduplicator、ramificator、folkなどとも呼ぶ）。一方、行列[a, b; c, d]は、a, b, c, d:X→Xとして次のように表現できる。

- (Δ&lt;sub&gt;X&lt;/sub&gt;;(a+c) + Δ&lt;sub&gt;X&lt;/sub&gt;;(b+d));(X+σ&lt;sub&gt;X&lt;/sub&gt;+X);(∇&lt;sub&gt;X&lt;/sub&gt;+∇&lt;sub&gt;X&lt;/sub&gt;)

上の表現は、行列を4辺の有向二部グラフに描けばすぐに得られる。この二部グラフに対してTr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;X,X&lt;/sub&gt;(∇;f;Δ)を作り、ワイヤーを追いかけて書き下すとKozenの表示が得られる。

Cazanescu/Stefanescu/Hyland/Hasegawaの結果を標語的に言えば、

- &lt;strong&gt;デカルト・モノイド圏のトレースは不動点を定義し（逆も真）、双デカルト・モノイド圏のトレースはKleeneスターを定義する（逆も真だったと思う）。&lt;/strong&gt;

ここで、双デカルトとは、デカルト積（直積）かつ余デカルト積（直和）である双積（と零対象）を持つことを意味する。

- traced cartesian monoidal category = category with fixed-point operator
- traced bicartesian monoidal category = category with Kleene-star operator

ところで、双デカルト性から、半加法性（可換モノイドでenrichできる）ことが出るのだろうか？ つまり、余対角∇が足し算になるのだろうか？ 双デカルトでモノイド閉なら、hom積[A, B] が定義できて、随伴を作れるならテンソル積が定義できて、テンソル単位IのEndを取ればスカラー半環ができる -- って、そんなにウマクいくかよ、オイッ。

*1148539204*[形式言語理論][トレース／コンパクト閉圏]トレース、ダガー、スター

トレース付きモノイド圏（対称性は当然に仮定）がデカルトのとき、f:A×X→Xの不動点f&lt;sup&gt;†&lt;/sup&gt;は次のように定義できる。

- f&lt;sup&gt;†&lt;/sup&gt; = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;(f;Δ&lt;sub&gt;X&lt;/sub&gt;)

さらに双デカルトなら、f:X→X の繰り返し（repetition）f*は：

- f* = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;X,X&lt;/sub&gt;(∇&lt;sub&gt;X&lt;/sub&gt;;f;Δ&lt;sub&gt;X&lt;/sub&gt;)

これらから、双デカルト・モノイド圏では：

- f* = (∇;f)&lt;sup&gt;†&lt;/sup&gt;

逆に、スターでダガーを定義できる。f:A×X→Xのとき

- f&lt;sup&gt;†&lt;/sup&gt; = (&amp;#40;Δ&lt;sub&gt;A&lt;/sub&gt;+X);(A+f))*

ダガーによるトレースの定義は：

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;(f) = (π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;A,B&lt;/sub&gt;;f)&lt;sup&gt;†&lt;/sup&gt;;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;B,X&lt;/sub&gt;

ここで、π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;、π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;は、それぞれ第一、第二射影（直積因子は２つ）。

これらは、絵算を使った“次元解析”で直観的かつ容易に得られる。

&lt;h5&gt;起源は誰だ&lt;/h5&gt;

繰り返しを表すスターはKleeneスターと呼んでよいだろう。ダガーのほうは誰を起源とすべきか？ Cazanescu/Stefanescu（カザネスク／ステファネスク）は&quot;Feedback, iteration and repetition&quot;のなかで、Elgot's iteration (dagger) と言っている。一方、Hyland/Bentonの&quot;Traced Premonoidal Categories&quot;では、圏論的に都合がいい不動点オペレータはConwayオペレータと呼んでいる。Conwayオペレータ公理：

- [対角自然性] f:A×U→V, g:U→V に対して、(f;g)&lt;sup&gt;†&lt;/sup&gt; = (A×g;f)&lt;sup&gt;†&lt;/sup&gt;;g
- [対角性(diagonal prop.)] f:A×U×U→Uとして、(&amp;#40;(A×Δ);f)&lt;sup&gt;†&lt;/sup&gt; = (f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt;

適当な条件化で、圏CのConwayオペレータは、半環End(U)（U∈C）上の単項演算&lt;sup&gt;†&lt;/sup&gt;で、次のConway等式を満たすものに対応するらしい。

- (ab)&lt;sup&gt;†&lt;/sup&gt; = 1 + a(ba)&lt;sup&gt;†&lt;/sup&gt;b
- (a + b)&lt;sup&gt;†&lt;/sup&gt; = (a&lt;sup&gt;†&lt;/sup&gt;b)&lt;sup&gt;†&lt;/sup&gt;a&lt;sup&gt;†&lt;/sup&gt;

仮にそういう半環をConway代数とすると、「Conway圏⇔Conway代数」ってことだね。同様なことは「Kleene圏⇔Kleene代数」でも起きるのだろうか？まー、Kleene圏の定義次第だな。フロベニウス代数でも同じようなことがあったな。行列Lawvere理論と関係しそうだ。Cazanescu/Stefanescu、Gadducci/Corradini（カザネスク／ステファネスク／ガダッチ／コラディニ）がだいたいやっていると思うが。

んで結局、ダガーはElgotダガーかConwayダガーか？ Elgot/Conway（エルゴット／コンウェイ）ダガーにするか？

*1148550581*[形式言語理論][トレース／コンパクト閉圏]対角性とスライディング

Elgot/Conway（エルゴット／コンウェイ）不動点オペレータの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148539204&quot;&gt;対角性&lt;/a&gt;（diagonal property）を絵に描くと、2回の対角射の変形が出てくる。

&lt;pre&gt;
－＋－＋→ 3
　↓　↓
　1　　2

－－＋－→ 3
　　↓
　 ／＼
　↓　↓
　1　　2
&lt;/pre&gt;
これは実は、対角の余結合律になる。つまり、対角性は、対角の余結合性とトレースのスライディングから得られる。これから、対角性≒スライディング。

*1148550633*[雑記][圏一般論]双積、指数、テンソル積

なんか、双積と指数とテンソル積の関係が混乱していた。アーベル圏はself-enrichされていると思いこんでいたが、勘違い。モノイド積が双積である状態で、「指数対象とev」とか「結合を与える射」とか、うまく定義できない。

アーベル圏をenrichするモノイド圏は、テンソル積をモノイド積とする圏だな。結合を与えるcomp:hom(A, B)×hom(B, C)を考えるとき、この×は集合圏の×だし、compは双線形。双積のモノイド圏(A, +, 0)それ自身を使ってenrichしているわけではない。

テンソル積の定義を普通に考えるなら、複線形写像が必要だ。複線形写像はいったいどこに在る？ アーベル圏Cの外に環境（ambient category）Aを考えて、C⊆Aとして考えたほうがいいような気がする。自然埋め込みC→Aは直積は保存するが、双積は保存しない。

アーベル圏Cと環境Aがあれば、複線形写像が定義できて、複線形写像の複圏も定義できるだろう。テンソル積は複圏を（通常の）圏で表現するような操作だろう。

近アーベルで考えるときも状況はほぼ同じはずだ。


</body>
</day>
<day date="2006-05-26" title="">
<body>
*1148632477*[トレース／コンパクト閉圏]ElgotダガーとConwayダガー

Elgotのダガー（iterationオペレータ）は、f:A→A+B から f&lt;sup&gt;†&lt;/sup&gt;:A→Bを作るらしい。

明白に添字（上下はイイカゲン）を書くと：

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;::(A+X → B+X)⇒(A → B)
- Fp&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A&lt;/sub&gt;::(A+X → X)⇒(A → X) （Conway）
- Rep&lt;sup&gt;X&lt;/sup&gt;::(X → X)⇒(X → X) （Kleene）
- Itr&lt;sub&gt;A,B&lt;/sub&gt;::(A → A+B)⇒(A → B) （Elgot）

Cazanescu/Stefanescu, Hasegawa, Hyland/Bentonを読めばいいのだろうけど、、、気力・能力が不足している。

それにしても、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060405/1144220979&quot;&gt;ステファネスク（Stefanescu）さん&lt;/a&gt;はすごい。私淑しよう。高い本&quot;Network algebra&quot;も買おうかな、高いけど。

*1148632623*[トレース／コンパクト閉圏][圏一般論]デカルトと双デカルトの本質byステファネスク

ステファネスクさんのflownomials解説の冒頭に曰く、「m個の入力とn個の出力を持つ機能や計算が、m×n個の1入力1出力の機能／計算達f&lt;sub&gt;i,j&lt;/sub&gt;により完全に決定される」ことが双デカルト・モノイダル圏の計算＝行列計算の本質だ（というような、そんなこと）を述べている。実に当たり前で明確 -- すばらしい。

これを弱めて、

- m個の入力とn個の出力を持つ機能や計算が、1入力n出力の機能／計算達f&lt;sub&gt;i&lt;/sub&gt;（1≦i≦m）により完全に決定される。
- m個の入力とn個の出力を持つ機能や計算が、m入力1出力の機能／計算達f&lt;sub&gt;j&lt;/sub&gt;（1≦j≦n）により完全に決定される。

これらが、デカルト／余デカルトなモノイダル圏の本質ってことになる。行列計算はできないが、縦ベクトルまたは横ベクトルの計算ができる。

*1148633039*[圏一般論]Lawvere流セオリー

Lawvere流のセオリーの理論がよくわかってないから、変なことを書くかもしれないが、それもよしとしよう。

指標ΣのLawvere代数セオリーLawvereAlgTh(Σ)とする。これは対象（の集合）が&lt;b&gt;N&lt;/b&gt;と同型な圏で、Σの記号が射として追加されていて、最小な圏ということだろう。圏Cから圏Dへの関手の圏（射は自然変換）を[C, D]と書くことにすると、

- [LawvereAlgTh(Σ), C] ≒ Alg&lt;sub&gt;Σ&lt;/sub&gt;(C) （≒は圏同値）

Alg&lt;sub&gt;Σ&lt;/sub&gt;(C)は、圏C内のΣ代数の圏。

いまいち曖昧な書き方なのだが、LawvereAlgTh(Σ) = LawvereTh(Cartesian, Σ)と書いてみる。Catesianとは定数記号を持たない、デカルト・モノイダル圏のセオリーとする。ここで出た“セオリー”は古典的等式的セオリーのこと。

U∈Cだとして、Uをgenerating objectとするLawvere流セオリーのモデルは[LawvereTh(Cartesian, Σ), (C, U)]と書く。セオリーのただ１つのソート記号に対応する対象をUにする、ということ。

LawvereTh(Cartesian, Σ)以外に、
- LawvereTh(Cocartesian, Σ)
- LawvereTh(Bicartesian, Σ)
- LawvereTh(SymmetricMonoidal, Σ)
- LawvereTh(CompactClosed, Σ)

とかを考えて（単項生成の最小）モデルを考えると、計算できる小さな圏が作れそうだ。特に、LawvereTh(CompactClosed) = LawvereTh(CompactClosed, Φ)はKelly達が作ったモデルのような気がする。


</body>
</day>
<day date="2006-05-27" title="">
<body>
*1148715173*[トレース／コンパクト閉圏][形式言語理論]トレース付き双デカルト・モノイド圏

木下「不動点をめぐる代数構造たち」（http://unit.aist.go.jp/cvs/tr-data/PS02-005.PDF）とKahl &quot;Refactoring Heterogeneous Relation Algebras around Ordered Categories and Converse&quot;（http://www.cosc.brocku.ca/Faculty/Winter/JoRMiCS/Vol1/PDF/v1n12.pdf）においてKleene圏が定義されている。これらは同等だが、適当にミックスした定義を採用する。

圏Cが&lt;strong&gt;Kleene圏&lt;/strong&gt;であるあるとは：

- C(A, B)が最小元0 = 0&lt;sub&gt;A,B&lt;/sub&gt;を持つjoin半束であり、結合C(A, B)×C(B, C)→C(A, C)はjoin半束の準同型である。
- r∈C(A, A)に対してr*∈C(A, A)が定義されていて、以下の等式を満たす。

r:A→A, q:B→A, s:A→Cに対して、
+ r* = id_A + r + r*;r* (recursive star definition)
+ q;r⊆q ⇒ q;r* ⊆ q (right induction)
+ r;s⊆s ⇒ r*;s ⊆ s (left induction)

順序⊆は、r⊆s ⇔ r + s = s なので等式的条件である。最小元を持つjoin半束は、可換ベキ等モノイドなので、Kleene圏は可換ベキ等モノイドの圏でenrichされていると考えてよい。

次の問題を考えたい。

- &lt;strong&gt;ベキ等な双デカルト・モノイド圏がトレースを持つとき、その圏はKleene圏であるか？&lt;/strong&gt;

まず、双デカルトなら半加法的（semi-additive、可換モノイドでenrichできる）を示す必要があるが、これは難しくないだろう。(+)を双積（双デカルト積）として、加法は f + g = Δ;(f(+)g);∇で定義すればよい。

ベキ等性を入れてないと、あまりうまくいきそうにない（やってみないと、よくわからないが）。Δ;(f(+)f);∇ = f がベキ等性になる。Δ(f(+)f) = f;Δを使えば、Δ;∇ = 1 （2 = 1）で十分かな。

Kleeneスターf* は、Tr(∇;f;Δ)と、トレースを使って定義できる。圏的構造からEnd(A)にinduceされる集合論的構造を調べるのがいいかもしれない。圏がある程度単純なときは、あるUのEnd(U)のKleene代数構造から圏の構造も決まると思う。“ある程度単純”をうまく定義しないといけないが。

*1148715174*[トレース／コンパクト閉圏]Kleene圏の周辺

Kleene圏が直積を持つなら、双積になるような気がするが、どうだろう？ ようするに、一般のKleene圏を行列圏で表現できないか？ってこと。

もし、デカルト（直積／終対象を持つ）Kleene圏が双デカルトなら、Kleeneスターを使ったトレースの定義によりトレースを付与できるから、「デカルトKleene圏 = トレース付きベキ等双デカルト圏」となる。これがほんとなら、「デカルト積 + Kleeneスター」 = 「双積 + トレース」 -- 状況証拠からは成立しそうだ。

しかし、「直積 = 直和」を示すには、splitが必要そうだな。Ker, Imとかも必要で、結局アーベル圏と近い議論になるのかな。

*1148715175*[トレース／コンパクト閉圏]Elgotダガー

Elgotダガー（Elgot反復オペレータ）は、Conwayダガーとは本質的に異なる。トレースで書き下してみる。

θ&lt;sub&gt;A&lt;/sub&gt;を始対象からAへの唯一射として、∇は余デカルト積+に関する余対角だとして、f:X→A+XのElgotダガーは次のように書ける。

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;(&amp;#40;(θ&lt;sub&gt;A&lt;/sub&gt; + X) + f);∇&lt;sub&gt;A+X&lt;/sub&gt;)

トレース概念は自己双対（self-dual）で、C上のトレースはC&lt;sup&gt;op&lt;/sup&gt;上のトレースも与えるので、Elgotダガーの双対形も書ける。

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;(Δ&lt;sub&gt;A+X&lt;/sub&gt;;(&amp;#40;!&lt;sub&gt;A&lt;/sub&gt; + X) + f))

しかしやはり、余デカルト圏の定義が自然なようである。（Conway不動点も、余不動点Tr(∇;f)の形式で書けるが自然ではない。）

*1148715176*[トレース／コンパクト閉圏]圏とloopingオペレータのまとめ

対角自然（dinatural）で&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148539204&quot;&gt;対角性&lt;/a&gt;（diagonal property;ダブルダガー公式）を持つ不動点をConwayオペレータ、Conwayオペレータを持つ圏をConway圏と呼ぶ。同様に、適当な公理（Cazanescu/Stefanescu；カザネスク／ステファネスク）を満たすElgotオペレータを持つ圏をElgot圏と呼ぶ（Elgotオートマトンの圏はおそらくElgot圏だろう）。

Kleeneスターを持つ双デカルト圏をKleene圏と呼んでしまうのは、既存のKleene圏の定義（Kahl/木下）があるから&lt;em&gt;まずい&lt;/em&gt;ので、概Kleene圏としておく。

以上の用語法でまとめると：

|* 圏の名称 |* ベースとなる圏     |* loopingオペレータ |*スカラー代数|
|Conway圏   |デカルト・モノイド圏 |Conwayダガー、不動点|Conway代数 |
|Elgot圏   |余デカルト・モノイド圏 |Elgotダガー、反復| ? |
|概Kleene圏 |双デカルト・モノイド圏|Kleeneスター、繰り返し|Kleene代数|

ベクトル空間とテンソル積の圏は、このどれとも違うし、コンパクト閉圏（内積が入ればダガー・コンパクト閉圏）になっている。

形式言語理論（as 0+1次元 xQFT）が値をとる圏は、おそらく“トレース付きベキ等デカルト・モノイド圏”ということだろう。双デカルトになっていれば行列計算ができる。あとは、文字列のreverse、関係のconverse、極性（あるいは荷電）との関係とかが問題だな。

KleeneQFTと呼ぶべきものは、余デカルト・モノイダルなトレース付き二圏（0+1コボルディズム圏）を定義域として、デカルト・モノイダルなトレース付き圏に値をとると思われる。値が双デカルトなら行列計算ができるし、さらに条件があれば、行列の共役も取れる（ダガー・コンパクト閉圏に似た状況）のだろう。

*1148716056*[圏一般論]圏の単純さ

アーベル圏Cの対象Uが単純（simple）⇔monoなV→Uがあれば、V≒0かV≒U。

単純とは、部分対象が自明なものしかないこと。半単純な対象とは、単純対象の有限積で書けること。すべての対象が半単純なら、圏は半単純。

*1148722163*[トレース／コンパクト閉圏]Elgotオートマトン

いまさらながらにElgotオートマトンが面白いと気が付いた。余デカルト圏上で定義された反復またはトレース（フィードバック）。二圏構造も持つし、モナド、コモナドも出てくる。behaviour functorはモノイダル・スタンピング・モナドのKleisli圏に値を取る。

ElgotダガーもElgotオートマトンとの関連で考えるのが理解しやすいようだ。


</body>
</day>
<day date="2006-05-29" title="">
<body>
*1148893117*[形式言語理論][具体例]ISRの圏

ベキ等半環（idempotent semiring; ISR）の圏が面白い気がしてきた。

ISRは環に近いので、（非可換）環論の技法が（ある程度）使える。ブール代数（可換）とクリーニ代数（クリーネ代数）（非可換）はISRの例となる。Aが集合のとき、Powf(A*)はISRになる；A*は有限列で、Powfは有限ベキ集合である。Powf((-)*)はモナドである。

F(A) = Powf(A*)として関手F:Set→ISRが定義できる。これは自由生成関手だから、忘却関手U:ISR→Setと随伴となる。ISRの始対象はブール代数&lt;b&gt;2&lt;/b&gt;（as ISR）で、終対象は自明代数である。環論的テンソル積A(×)Bが定義できるだろう。そしておそらく、F(A+B)=F(A)(×)F(B)だろう。R = F(A)のとき、イデアル論的にAを再現できそうだ。

ISRが理解できたら（まだ理解できてないけど）、次はISR上の半加群が問題だ。ISRは一般に非可換だから、右加群と左加群を区別する必要がある。可換のケースでも、左右の区別は重要で、R左S右の両側半加群を考える実際的な理由がある。


</body>
</day>
<day date="2006-05-30" title="">
<body>
*1148959698*[圏一般論][モナド]IAM-enrichementとCat上のモナド

Idempotent Abelian MonoidをIAMと略記して、IAMの圏も同じくIAMと書く。IAMは最小元付きのjoin semi-latticeの圏と圏同値。だから、必要に応じて順序構造を入れられる。

さて、圏Cに対して、自由なIAM-enriched圏を作る。それをD=IAM[C]と書くと：

+ |D| = |C|
+ D(X, Y) = Powf(C(X, Y)) （Powfは有限ベキ集合）
+ {f1, .., fn}∈D(X, Y), {g1, ..., gm}∈D(Y, Z)に対して、f;g = {fi;fj | i=1, ..., n,  j = 1, ..., m}
+ id_X in D = {id_X in C}

各hom-set D(X, Y)は、{}を単位元として∪をモノイド演算とするIAM構造が入る。特に、End(X) = D(X, X)には結合を乗法として半環構造が入る。各hom-IAM D(X, Y)は2つの半環End(X), End(Y)の両側半加群となる。

C|→IAM[C]という構成を、Cat→Catの関手と考えると、（要確認だが）モナドになっているだろう。モナド単位はC⊆IAM[C]という自然な包含。IAM[IAM[C]]→IAM[C]は、hom-setごとのPowfのモナド乗法を使う。

このケースでは、Powfのモナド性が持ち上がるだけのことだが、Circ構成、Int構成などもモナドのような気がする。Cat上のモナドはもっと意識して探したほうがいいようだ。

*1148959821*[プログラム意味論][形式言語理論]Bidoit/Hennicker/Kurz-双対性

うーん、人名は片仮名で書きたいのだが、、、発音がサッパリわからん。ビドォイト／ヘンニッカー／カーツかなぁ？？？

まーとにかく、到達可能性（reachability）と観測可能性（observability）との双対性。到達可能でないものは存在しても指示（あるいは表記）できない。観測可能でないものは存在しても認識できない。

表記・表現のパワーと観測・認識のパワーについて考えるときに、Bidoit/Hennicker/Kurz-双対性は基本的な気がする。文法とオートマトンも、Bidoit/Hennicker/Kurz-双対の枠組みで考えるべきだろう。

*1148980185*[雑記]なか見検索と散財の関係

ステファネスクの&quot;Netwrok Algebra&quot;を注文した。これは、出版社からはもう出てなくて、ユーズドを（Amazonマーケットプレイス）thurmanbooksなる業者に注文。ロープライスといいながらも￥11,547。

&quot;Network Algebra&quot;は考えた末だからいいのだが、ついでに衝動買いもしてしまった。前から気になっていた&quot;Idempotency Analysis&quot;って本。最近またIdempotencyに興味があるのだが、それにしても、なか見検索（Search Inside!）がなければ買わなかったろうな。内容確認できることは、購買の動機になりえるよ、確かに。Idempotency本もやたらに高いのに、、、


</body>
</day>
<day date="2006-05-31" title="">
<body>
*1149037770*[メモ法]メモするときの注意

- まとめをもっと頻繁にする（月に1回くらい）。
- 定義や重要部分は抜き書きする（自分の言葉で書く）。
- 出典を忘れないように。
- リンクには、googleの検索でもよい（はてなのgoogle記法）
- 効果的な見出しを付ける。ムズ。
- 日記内検索にかかりやすいように（キーワードを揃えるなど）。ムズ。
- 分類カテゴリーに神経質にならない。
- たまに見直して整理。
- 過去への書き込み＋分類カテゴリーを利用
- 修正追記はドンドンやる。
- 日付の扱いを工夫する。


</body>
</day>
<day date="2006-06-01" title="">
<body>
*1149117607*[リンク][論理]ヘンキンとか飽和法とか

飽和法が出ている資料を見つけた！

- http://www.math.psu.edu/simpson/courses/math563/master.pdf

- title: Model Theory
- author: Stephen G. Simpson

*1149126059*[論理]ヘンキンとか飽和法とか、誤解混乱していたわ

僕のナントナクの理解（いや、理解してないんだけど）では、文の極大無矛盾集合とは、極大フィルターと同等なものであって、極大無矛盾集合を作ってコンパクト性が示せる、と。そして、構成的に極大無矛盾集合を作る方法を飽和法といい、ヘンキンが創始者なんだろう、と。（参考→[http://d.hatena.ne.jp/m-hiyama-memo/20051227/1135675743:title]）

しかーし、上の記述はほとんど&lt;strong&gt;間違い&lt;/strong&gt;のようだ。先のエントリーの&quot;Model Theory&quot;を眺めると、確かに、「飽和」という概念はモデル論にあるようだが、極大無矛盾とは直接の関係はないようだ。注意すべきはモデル論的無矛盾（consistent）とは、文の集合がモデルを持つことを意味するに過ぎないこと。

で、ヘンキンだが、彼は1949年にコンパクト性定理を証明しているのは確からしい。ただし、可算ケースでは1929にゲーデル、非可算は1936にマルセフ（Malcev）が示しているので最初の証明ではない。

ヘンキンの方法はtransfinite inductionを用いる。そのときに、ヘンキン文とかヘンキン定数が出てくる。たぶん、transfinite inductionによる構成をヘンキン構成、できたモデルはヘンキン・モデルと呼んでいいだろう。ヘンキンの功績は、既存モデルから出発してどんどんモデルを精密化していく具体的方法を考えたことかな。

ウルトラフィルターを使ったコンパクト性定理の証明を見るが、これは誰が始めたのだろう？

コンパクト性定理は、ある種のモジュライ空間の存在とそのコンパクト性を示しているから、やっぱり幾何学的だよな。

*1149126489*[論理]極大（ウルトラ）フィルターの補題

バート・ジャコブスが&quot;Many-Sorted Coalgebraic Modal Logic: a Model-Theoretic Study&quot;(http://citeseer.ist.psu.edu/jacobs01manysorted.html)のなかで、Ultrafilter Lemma として、「ブール代数Bのプロパーな（最小元を含まない）フィルターは、ウルトラフィルターに拡大できる」を挙げている。

その直後に、&quot;Scott open filter lemma&quot;として、「任意のフィルターが、それを含むウルトラフィルターの共通部分として書ける」を挙げている。

Ultrafilter lemmaは「空でない空間には点がある」、Scott open filter lemmaは「図形に含まれる点の全体が図形である（図形を規定する）」を意味する。両方あわせて、「空間と図形は点で構成（規定）される」となるから、2つあわせて「極大（ウルトラ）フィルターの基本補題」だといっていいだろう。

*1149135680*[プログラム意味論][トレース／コンパクト閉圏]アメナブル性と境界付け

C = (C, ×, 1, σ, *, η, ε)がコンパクト閉圏だとして、f:A→Bに対して、fのネーム[f]:1→A×B* が決まる。しかし、[f]と[g]が同型でも、fとgは全然違うケースもある。この状況をJanusコンポネントの圏で考えてみる。

Janus profileからinputとoutputの別を取り除いてしまったものをundirected profileと呼ぶ。input/output（または右と左）の区別があるprofileを特にdirected profileとも呼ぶ。directed profile → undirected profile はまったく自明だが、与えられたundirected profileからdirected profileを作るのは簡単ではない。単に組み合わせ的にdirectionを選んでいいわけではない。

この事情にはアメナブル性やらシステム境界がからんでくる。profile（とそれを満たすコンポネント）がアメナブルであるとは、「観測子に副作用はない」ことである。これは指標の構文的な条件だけでは済まない。指標Σと部分指標Σ'があるとき、ホーア式を使ってAmenable(Σ, Σ')を書き下すことができる。観測子の部分指標Obs(Σ)が指定されているとき、(Σ, Obs(Σ))がアメナブルであることは、Amenable(Σ, Obs(Σ))として書ける。

単一のObs付きの指標Σをもとにしたアメナブルなundirected profileが与えられているとき、これを2つの部分指標Σ1とΣ2に分割して、どちらもアメナブルにするのが問題となる。イイカゲンに分割すればアメナブル性は壊れる。アメナブルな分割ができるかどうか？どのくらいの数の分割があるか？がプロファイルの単純さの基準となる。換言すると、アメナブルな部分プロファイルの大きさが尺度となる。

Janusコンポネント（のプロファイル）はアメナブルなものに限定していいだろう。アメナブル性がコンパクト閉圏の演算で保たれることを確認する必要があるが。

プロファイルの分割はシステム境界の設定でもある。単一境界のシステムを、複数境界のシステムとして配備できるか？ということだ。undirected profileをdirected profileにする作業は&lt;strong&gt;境界付け&lt;/strong&gt;と呼んでよいだろう。

下手な境界付けはアメナブル性を壊す。これは、因果的に見えなくなることだと言ってもいいかもしれない。非アメナブル／非因果的なシステムは、制御不可能な見えない介入者がいるようにふるまう。

*1149136250*[トレース／コンパクト閉圏]たすきがけ結合（crossing composition）

Int構成でもGoI構成でも、その結合を絵に描くとワイヤーが交差する。バッテン、たすきがけになる。よって、この結合方法を「&lt;strong&gt;たすきがけ結合&lt;/strong&gt;」（&lt;strong&gt;crossing composition&lt;/strong&gt;）と呼ぼう。そう決めた。

*1149147684*[山勘][まとめ]力学との類似

とにかく、書けるときはワサワサ書いておくぞー。

ちゃんと調べたり確認したりする余裕／気力／能力に欠けるので、&lt;em&gt;激しく山勘&lt;/em&gt;を働かせてイイカゲンな作業仮説を書くことにする。

まず、「状態空間が存在する」と信じよう。たまに信じられなくなるのだが、信じないと現状どうにもならん！ Sが状態空間として、Pow(S)の部分ブール代数Aがあるとする。Aがほぼ観測量に相当する。実際には、観測量（基本値）空間Vがあって、V内で適当な論理でdefinableな部分集合達があって、それらの逆像達としてAが与えられる。

Aの極大イデアル空間をXとする；X = Max(A)。XとSは違うかもしれないが、Aに対する自然な定義域はSではなくてXとなる。Aしか与えられるない状況では、Sは単なるフィクション（理想概念）であり、むしろXが認識可能な実在である。状態空間Sとブール代数Aの組(S, A)からなる対象の圏が考えられるが、我々から見えるのは、空間と反変的なブール代数とブール代数準同型の圏である。

空間S（むしろX）上の力学とは何か？ とりあえずそれは遷移α:S→Pow(S)だと考える。遷移はブール代数A上の様相オペレータを定義する。Aの様相オペレータの全体をMO(A)とすると、MO(A)が空間S（むしろX）上の“力学”の全体を与える（と考える）。

次が重要な事実となるだろう。

- ブール代数Aから、Sの点を観測的（observational）に同一視した空間を再現できる。それはXである。
- ブール代数Aの様相オペレータαから、X上の遷移を定義できる。これは、S上の遷移を観測的な同一視を除いて（up-to equiv.で）再現する。

次のような類似がある。

|* 多様体   |* 状態機械 |
| 空間M     | 空間S    |
| 実数体    | 2値ブール代数 |
| 関数環C(M) | ブール代数A⊆Pow(S) |
| 極大イデアル空間 | 極大フィルター空間 |
| M上のベクトル場 | S上の遷移 |
| C(M)の微分 | Aの様相オペレータ |
| 多様体の写像 | 状態空間の写像 |
| 可換環の準同型 | ブール代数の準同型 |
| ベクトル場の軌道 | 遷移の軌跡 |

*1149154055*[プログラム意味論]ホーア4つ組の定式化

ホーア4つ組の定義らしきもの。やっと、しかし、まだ詰めが甘い。

Sは状態空間、Aが入力記号の集合で、指標Σのミューテータ記号で与えられる。Bは出力記号の集合で、指標Γのミューテータ記号で与えられる。A*（Aの列）をコマンド、B*（Bの列）をイベントと呼ぶこともある。

A*×S → Pow(S×B*) を遷移とする。α∈A*に対してS→Pow(S×B*)が決まる。これを、【α】とかく。p, qなどはS上の述語だとする。EがBの正規表現だとして、組(q, E)は、【q】×【E】∈Pow(S×B*)という解釈をする。【q】⊆S、【E】⊆B*（正規言語）である。

4つ組 p→[α]q, E の意味は、【p】⊆【α】&lt;sup&gt;-1&lt;/sup&gt;(【q】×【E】) だとする。【α】&lt;sup&gt;-1&lt;/sup&gt;は、ブール代数Pow(S×B*)からPow(S)への様相オペレータとなっている。4つ組の解釈はPow(S)内で行える。

α∈A* と x∈Sが与えられたとき、「x∈【p】ならば【α】(s)∈【q】×【E】」のとき、ホーア4つ組'p→[α]q, E'を満たしている。

A*×S → Pow(S×B*) はCirc-Kleisli構成を一般化して、とある圏のA→Bという射と考えることができるだろう。またこれは、S|→[A*, Pow(S×B*)]という関手の余代数にもなっている。


</body>
</day>
<day date="2006-06-03" title="">
<body>
*1149299168*[プログラム意味論]キャット（KAT）とバオ（BAO）を統合できないか

KozenのKAT（Kleene Algebra with Test）は、ブール半環上のベキ等半加群として再定義できる。一方で、異なる状態空間のあいだの遷移を認める形でKleene圏を定義できる。KATとKleene圏の統合は、ブール半環を対象として、A, Bのhom-set K(A, B)として左A-右Bな両側半加群を採用すればよい。ベキ等半加群（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060530/1148959698&quot;&gt;IAM, Idempotent Abelian Monoid&lt;/a&gt;）でenrichさていれば、order-enrichもされている。

BAO（Boolean Algebra with Operator）は、状態空間Sの述語のブール代数A（A⊆Pow(S)と考えてよい）と、S上の遷移αによる作用【[α]p】 = α&lt;sup&gt;-1&lt;/sup&gt;(【p】) を一緒に考えたものだ。遷移αが一価全域なら、αはブール代数の準同型となる。

一般には、遷移が一価全域であることは仮定が強すぎる。S→Pow(S)とするなら、ブール代数のmeet semi-lattice構造しか保存しない。meet保存のオペレータを様相オペレータと呼ぶことにする。

ジャコブスとゴールドブラッドの双対に関する仕事を寄せ集めると、様相オペレータ付きブール代数が遷移系（transition system、クリプキ構造）を定義するようである。

KATもBAOも、状態空間／述語／遷移と強く結びついている。なにか同じものの別な側面のように思える。基礎となるのは、ブール代数と準同型の圏で、これはBoole/Stone空間と連続写像の圏だと思ってもよい（反対圏の実現）。

*1149299169*[プログラム意味論][モナド]トランスデューサの圏論的解釈とか

「ホーア4つ組の定式化」（[http://d.hatena.ne.jp/m-hiyama-memo/20060601/1149154055:title]）で、次の状況を考えた： Aを入力アルファベット、Bを出力アルファベット、Sを状態空間とする非決定性トランスデューサは、A*×S → Pow(S×B*) で表現できる。

A|→A* はモナド、S|→S×Xはコモナド、Powはモナドとなる。星印なしの A×S → Pow(B×S) なら、これは、Circ-Kleisli構成になる。3項関手 S, A, B|→ [A*×S, Pow(S×B*)]を考えれば、これって&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943110&quot;&gt;notion of process&lt;/a&gt;になるんじゃないのか？

形式的に一般化してみれば、TとPを強モナド、×は直積とは限らないモノイド積として、T(A)×S → P(S×T(B))とかも考えられる。PとTには分配法則（スワッパー）が存在する必要はあるだろう。あるいはさらに、パラメータSを持つコモナド族F[S]を使って、F[S](T(A)) → P(F[S](T(B))) と書けるケースとか。

CがV-enriched圏のとき、C上のモナド／コモナドを組み合わせて作られる3項の関手 C×C&lt;sup&gt;op&lt;/sup&gt;×C → V が問題になっているような気がする。

Tがgeneralized term mond、Pがgeneralized powerset monadのケースで、T(A)×S → P(T(B)×S)を考えるのがいいかもしれない。TもPも強モナドで、PはT上に分配するから分配法則（スワッパー）δ:: P;;T⇒T;;P の存在も仮定してよい。T(A)は記号Aの時間方向への展開で、Sは記憶／履歴の空間、Pは非決定性を表現する。コモナド族F[S]を使う形なら、F[S]は、Sをスタンピングする操作、計算に記憶Sを持たせる操作となるだろう。

*1149299350*[雑記]文房具

- コクヨ セレクションパッド レ-511N -- B4で10mmの方眼。方眼は薄い水色なのでコピーやスキャンでは写らない。\420、高い。
- コクヨ Expedient notebook Γ64° -- こっちはB5、完全に罫なし。リング式なので、シート一枚ずつ使える。

*1149306037*[課題]確認すること

次を確認するには、紙と体力を使うしかないのだろう、ヒエー。
参考→[http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561238:title]

- Cが対称モノイド圏、T, PがC上の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060123/1137978147&quot;&gt;強モナド&lt;/a&gt;で、PはT上に分配する。この状況で、適当な圏Xがあって、|X| = |C|、X(A, B) ≒ {すべてのSに対する C(T(A)×S, P(T(B)×S))} となる。
- 上のXにおいて、X(A, B)は圏になり、X全体は二圏となる。
- X(A, B)は余代数の圏とみなせる。
- Xにトレースが定義できる。
- Cが閉モノイド圏のとき、H(S, A, B) = [T(A)×S, P(T(B)×S)] とすると、Hは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943110&quot;&gt;notion of process&lt;/a&gt;となる。

*1149306038*[具体例]身近なトランスデューサ：文字のエンコード

Aを文字（とりあえず文字番号、またはコードポイント；最近はコードユニット？）だとして、Bはバイト（8ビット・コンビネーション）の集合だとする。エンコーディングがA→B*という関数で与えられというのは嘘で、それはISO-2022-JPを考えれば明らかだろう。

状態をSとして、エンコーディングは A×S→B*×Sとして与えられる。Aに未定義な文字があれば、出力は空だし、エンコード表現に曖昧性／多義性があれば、遷移＋出力は部分的かつ非決定性となるから、A×S→Pow(B*×S)となる。状態遷移は確定的にしたいなら、A×S→Pow(B*)×Sとなるが、Powが強モナドなので、テンソル強度:Pow(X)×Y→Pow(X×Y)があるから、A×S→Pow(B*)×SをA×S→Pow(B*×S)に埋め込める。

Aに合成文字の素片が含まれると、A×Sでは遷移が定義できないがA*×Sでは定義できることになる。A×S→Pow(B*×S)をA*×S→Pow(B*×S)に埋め込むのは簡単だ。

まとめると：
+ エンコーディングには状態が必要になることもある。
+ １つの文字に複数のエンコード表現（encoded representation）があるかも知れない。
+ エンコードが定義されてない文字が含まれるかもしれない。
+ 合成文字の素片が含まれるかもしれない。
+ 状態遷移だけ引き起こす制御信号があるかもしれない。

*1149318446*[課題]確認できたこと

&gt;&gt;
- 上のXにおいて、X(A, B)は圏になり、X全体は二圏となる。
- X(A, B)は余代数の圏とみなせる。
&lt;&lt;

X(A, B)が余代数の圏になるのは簡単だった。H(S) = H&lt;sub&gt;A,B&lt;/sub&gt;(S) = [T(A), P(T(B), S)] とする。余代数f:S → H(S)があれば、それは f:T(A)×S → P(T(B)×S)とみてよい。つまり、射＝余代数＝1セル。2セルは余代数の準同型で定義すれば、常識的な定義が得られる。ただし、閉圏でないと途方にくれる。

&gt;&gt;
- Xにトレースが定義できる。
&lt;&lt;

あんだか、よくわかんない。具体例作らないと。

&gt;&gt;
- Cが対称モノイド圏、T, PがC上の強モナドで、PはT上に分配する。この状況で、適当な圏Xがあって、|X| = |C|、X(A, B) ≒ {すべてのSに対する C(T(A)×S, P(T(B)×S))} となる。
- Cが閉モノイド圏のとき、H(S, A, B) = [T(A)×S, P(T(B)×S)] とすると、Hはnotion of processとなる。
&lt;&lt;

これは、定義がシッカリと書き下せれば同時に解決しそう。T = (-)*, P=Powの状況で考えてみよう。

*1149319484*[プログラム意味論][余代数]ゴールドブラッド双対

Σが余代数指標だとして、Σ余代数が普通に定義できる。ところが、Σから代数の仕様を作り出すことができる。そして、そのΣ代数のモデルはBAOになる。BAOは、余代数の状態空間上の述語（部分集合）のブール代数であり、余代数の遷移（アクション）を様相オペレータとするもの。

余代数→代数は比較的簡単。代数→余代数はウルトラフィルターを使う。余代数→代数→余代数でもとに戻るわけではないが、結果は（余代数の）ウルトラフィルター拡大になっている。ウルトラフィルター拡大ともとの余代数は普通には区別がつかないので、ある意味では同じといってもよい。

指標をマンナカにして、余代数圏とBAO圏が反変に対応する構造をゴールドブラッド（Goldblatt）双対と呼ぶ（ことにした）。ゴールドブラッドは、BAO圏でバーコフの定理が成立する事と双対性を使って、余代数の圏の余バーコフ定理を導いている。

ビドゥイット／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）双対とゴールドブラッド双対はどういう関係があるのだろう？別物なのか？

*1149326993*[モナド][具体例][説明]スタンピング

モノイド圏に（コ）モノイドがあれば、それを使って（コ）モノイダル・スタンピングにより（コ）モナドができる。この方法は、安直だが、けっこう役に立つ。例えば、∇: 1 + 1 → 1 を余対角（folding）とすると、これはモノイドになる。モノイダル・スタンピング・モナドは部分写像の（Maybe in Haskell）モナド。


</body>
</day>
<day date="2006-06-06" title="">
<body>
*1149560696*[メモ法]リンクには見出し

はてな記法の:titleを利用して、リンクに見出しをいれたほうがいい。

*1149560697*[雑記][インスティチューション][マンダラ]現象のモデルはマンダラ

現象をモデル化した構造は複雑なんじゃなかろうか。ここで、“複雑”とは、規模が大きくて階層的で有機的に絡み合っているということ。so-called“複雑系”の「複雑」とは違う。例えば、代数系を公理化したとき、等式が50も100も出てくると、とても単純な系とはいえないけど、そんな感じの複雑さかな -- シッカリと法則性はあるのだが、それを書き下すと量が多くなってしまうという。

計算現象（のとある一面）のモデルとして、インスティチューションが骨格を与えると思っている。だが、インスティチューションは骨格のみで、それに肉やら内臓やら神経系やら皮膚やら脂肪やら、とにかくいろんなものがひっつく。さまざまな代数系や圏が重なりあい、ひしめきあっている。部分的には単純かもしれないが、全体としては階層的／重層的／多面的な構造を持つ。

これは何と表現すればいいのだろう。「マンダラ」（仏教用語）って言葉の正確な意味は知らないが、たくさんの小世界が集積しているイメージがする（僕のイメージに過ぎないが）。仮にそのイメージが的はずれでないなら、「&lt;strong&gt;現象のモデルはマンダラ&lt;/strong&gt;」という標語を作ってもいいかもしれない。

&gt;&gt;
全ての曼荼羅に共通する点としては、(1)複数の要素（尊像など）から成り立っていること、(2)複数の要素が単に並列されているのではなく、ある法則や意味にしたがって配置されている、ということがあげられる。密教系の絵画でも、仏像1体だけを表わしたものは「曼荼羅」とは呼ばない。「曼荼羅」とは、複数の要素がある秩序のもとに組み合わされ、全体として何らかの宗教的世界観を表わしたものと要約できるであろう。
&lt;&lt;

↑wikipediaがホントなら、僕のイメージも悪くはないようだ。

僕はsimpleは好きだが、over-simplifyが嫌いなのだ。

*1149562049*[圏一般論][インスティチューション]指標と関手モデル

[http://d.hatena.ne.jp/m-hiyama-memo/20060526/1148633039:title]の話を少し整理する。

ソート付きの指標Σは、ソートを頂点、演算記号を辺とするグラフ（またはハイパーグラフ）とみなせる。FreeCat(Σ)を、Σから作られた圏とする。グラフの圏と圏の圏において、Graph(Σ, U(C))≒Cat(FreeCat(Σ), C)の随伴性がある。Cat(FreeCat(Σ), C)のほうに注目すると、これは関手圏とみなせて、Cat(FreeCat(Σ), C) = Model&lt;sub&gt;C&lt;/sub&gt;(Σ) = Alg&lt;sub&gt;Σ&lt;/sub&gt;(C)としてよい。

FreeCat(Σ)の代わりに、FreeCartesianCat(Σ)、FreeMonoidalCat(Σ)、FreeCompactClosedCat(Σ)などを考えて、これらを一般にFreeXCat(Σ)とすると、XCat(FreeXCat(Σ), C) = XModel&lt;sub&gt;C&lt;/sub&gt;(Σ) だろう、ということ。例えば、CartesianCat(FreeCartesianCat(Σ), C) = CartesianModel&lt;sub&gt;C&lt;/sub&gt;(Σ)。

一方、Graph←→Cat対応と同じように、HyperGraph←→MultiCat対応がある。圏の種別ごとに、対応するグラフの圏が（ある程度は）定義できる気がする。

ところで、インスティチューションにおいて、Mod(Σ) = Cat(FreeCat(Σ), C) = Graph(Σ, U(C))と考えると、f:Γ→ΣをGraph(Γ, Σ)の射と考えて、f&lt;sup&gt;*&lt;/sup&gt;:Graph(Σ, U(C))→Graph(Γ, U(C))の定義が自明に近くなる（pre-compose）。

*1149586253*[雑記]Network Algebra

が届いた。早かったし、きれい。いい業者だったみたい。

扱いやすいペーパーバック。


</body>
</day>
<day date="2006-06-07" title="">
<body>
*1149652184*[形式言語理論]ウィルケ（Wilke）代数

[http://citeseer.ist.psu.edu/bloom00iteration.html:title]にWilke代数というのが出てくる。

A&lt;sup&gt;*&lt;/sup&gt;がAの有限列なら、それはモノイドとなるが、Aの無限列A&lt;sup&gt;∞&lt;/sup&gt;では乗法が定義できない。それで、F=A&lt;sup&gt;*&lt;/sup&gt;、X=A&lt;sup&gt;∞&lt;/sup&gt;として、FとXの組を公理化できる。それがウィルケ代数だと思えばいいだろう。ウィルケのダガーa&lt;sup&gt;†&lt;/sup&gt;は、aaaa... という無限繰り返しである。

・:F×F→F、*：F×X→X、(-)&lt;sup&gt;†&lt;/sup&gt;:F→X があって：
+ ・は結合的二項演算である。
+ (a・b)*x = a*(b*x)
+ (a・b)&lt;sup&gt;†&lt;/sup&gt; = a*((b・a)&lt;sup&gt;†&lt;/sup&gt;)
+ (a&lt;sup&gt;n&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt; = a&lt;sup&gt;†&lt;/sup&gt; （n ≧ 2）

f:F→G、f':X→Yが準同型であるとは：

+ fが半群の準同型
+ f'(a&lt;sup&gt;†&lt;/sup&gt;) = (f(a))&lt;sup&gt;†&lt;/sup&gt;
+ f'(a*x) = f(a)*f'(x)

1∈Fがあって、1*x = x のとき単位ウィルケ代数（unitary Wilke Algebra）と呼ぶ。

*1149652815*[インスティチューション]インスティチューションの仕様圏

インスティチューションのSen(Σ)上にムーア閉包作用素&lt;/a&gt;が存在している状況を考える。参考：

- [http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135304733:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135305693:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135314491:title]

A⊆Sen(Σ)を（Σの）仕様、Aが閉包で変わらない（閉じている）ときは（Σの）セオリーと呼ぶことにする。仕様とセオリーは、&lt;em&gt;ほとんど同じ&lt;/em&gt;ものである。

Clを閉包作用素として、仕様AとBのあいだの順序を Cl(A)⊆Cl(B)で定義すると、⊆を射として圏となる。これをSpec(Σ)とする。SpecはSign上のCat値の反変関手になるので、indexed categoryを定義する。このindexed categoryの平坦化圏をSpec(I)（Iはインスティチューション）とする。Σ|→(Σ, Φ)（Φは空仕様）として、ΣをSpec(I)に埋め込むことができる。あるいは、(Σ, A)|→Σを射影とするファイブレーションを定義できる。

ModやSystemを考える際に、SignよりはSpec=Spec(I)の上で考えたほうが自然な気がする。つまりMod(&amp;#40;Σ, A))、Prog(&amp;#40;Σ, A), (Γ, B))、System(&amp;#40;Σ, A), (Γ, B))のようなものを考えることになる。

*1149652816*[トレース／コンパクト閉圏]極性、指標、圏

こんな感じ。

|* ＼ |*  極性なし |* 極性あり |
| 指標 | 普通の指標 | 対話指標 |
| モデル圏 | トレース付き圏 | コンパクト閉圏 |
| ソフトウェア| ライブラリ／ミドルウェア | 対話コンポネント |

*1149652817*[トレース／コンパクト閉圏]Int構成のKleisli圏

Int構成（またはGoI構成）は、トレース付きモノイド圏から自由なコンパクト閉圏を定義する関手。つまり、Int:TrMonCat → KCC、これはKCC（コンパクト閉圏の圏）からの忘却関手と随伴のはずだから、モナドを定義する。これのKleisli射は、トレース付きモノイド圏CからInt(D)へのトレース付きモノイド圏準同型（関手；TrMonCatの射）ってことだが、まだ説得的具体例がない。

</body>
</day>
<day date="2006-06-12" title="">
<body>
*1150103622*[メモ法]近くてもリンクする

同日のエントリなど、空間的（むしろ時間的か）に近い位置であっても、リンクを張る。でないと、単独エントリーだけを見たときにとまどうことになる。

</body>
</day>
<day date="2006-06-13" title="">
<body>
*1150188663*[人物]Zoltan Esik

- http://www.grammars.grlmc.com/Grammars/GRLMC/PersonalPages/ze/tarragonaindex.html

Zoltanのaの上と、EsikのEの上にプラムみたいなダイアクリティカルマークが付いている。なんて読むか？わからん！

ハンガリーの人で、Bloom &amp;amp; Esik &lt;a href=&quot;http://www.amazon.co.jp/gp/product/0387563784/250-2925753-9543409&quot;&gt;&quot;Iteration theory&quot;&lt;/a&gt;の著者。Elgotのお弟子さんみたい（よくわからんけど）。

*1150189085*[雑記]絵を描いた

説明はいずれ。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/matrix-graph.gif&quot; &gt;
&lt;/div&gt;
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/looping.gif&quot; &gt;
&lt;/div&gt;
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/kozen-formula.gif&quot; &gt;
&lt;/div&gt;

</body>
</day>
<day date="2006-06-14" title="">
<body>
*1150258287*[トレース／コンパクト閉圏]絵算でゴー：行列

まず、双デカルト・モノイド圏における行列を説明する。行列の定義は、直積と直和があればできるが、双デカルト・モノイド圏じゃないと面白くないだろう。双積は+, 零対称を0、0からの唯一射をθ、0への唯一射を!、対称ブレイディング（クロス）をσ、対角をΔ、余対角を∇とする。

&lt;hr&gt;

a:X1→Y1, b:X2→Y1, c:X1→Y2, d:X2→Y2だとして、a, b, c, dから定義される射f:X1+X2→Y1+Y2が行列だが、それを有向（左から右）二部グラフで示す（一番上の図）。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/matrix-graph.gif&quot; &gt;
&lt;/div&gt;

一番上の有向二部グラフを変形して二番目の図、これから次の表示を得る。

- (Δ&lt;sub&gt;X1&lt;/sub&gt; + Δ&lt;sub&gt;X2&lt;/sub&gt;);(X1 + σ&lt;sub&gt;X1,X2&lt;/sub&gt; + X2);((a + b);∇&lt;sub&gt;Y1&lt;/sub&gt; + (c + d);∇&lt;sub&gt;Y2&lt;/sub&gt;)
- (Δ&lt;sub&gt;X1&lt;/sub&gt;;(a + c) + Δ&lt;sub&gt;X2&lt;/sub&gt;;(b + d));(X1 + σ&lt;sub&gt;X1,X2&lt;/sub&gt; + X2);(∇&lt;sub&gt;Y1&lt;/sub&gt; + ∇&lt;sub&gt;Y2&lt;/sub&gt;)

この2つの表示が同値であることは次の等式（公理か定理かは、まーいいとして）からわかる。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/crossingswap-and-shift.gif&quot; &gt;
&lt;/div&gt;

次に、fとgの積の対（product pairing）を&lt;f,g&gt;、和の対（sum pairing）を[f, g]とする； &lt;f, g&gt; = Δ;(f+g)、[f, g]=(f+g);∇ である（ステファネスクは&lt;strong&gt;逆の記法&lt;/strong&gt;を使っているから注意！）。この記法で：

- f = &lt;[a, b], [c, d]&gt; = [&lt;a, c&gt;, &lt;b, d&gt;]

このことを表した絵が三番目、四番目。上記の等式を示すには、次の公式（等式と絵）を使って、直前の結果に帰着する。

- Δ&lt;sub&gt;X+Y&lt;/sub&gt; = (Δ&lt;sub&gt;X&lt;/sub&gt; + Δ&lt;sub&gt;Y&lt;/sub&gt;);(X + σ&lt;sub&gt;X,Y&lt;/sub&gt; + Y)
- ∇&lt;sub&gt;X+Y&lt;/sub&gt; = (X + σ&lt;sub&gt;X,Y&lt;/sub&gt; + Y);(∇&lt;sub&gt;X&lt;/sub&gt; + ∇&lt;sub&gt;Y&lt;/sub&gt;)

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/sum-and-diagonal.gif&quot; &gt;
&lt;/div&gt;

*1150258420*[トレース／コンパクト閉圏]絵算でゴー：looping

次の各種loopingオペレータを絵で示す。“圏”はトレース付き対称モノイド圏の範囲で考えるとする。

- デカルト圏：Conway不動点オペレータ -- 上付きダガーで示す。
- 余デカルト圏：Elgot反復オペレータ -- 上付きシャープで示す。
- 双デカルト圏：Kleene繰り返しオペレータ -- 上付き星で示す。

- f&lt;sup&gt;†&lt;/sup&gt; = Fp&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sub&gt;A, X&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f;Δ&lt;sub&gt;X&lt;/sub&gt;)
- f&lt;sup&gt;#&lt;/sup&gt; = Itr&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sub&gt;X,A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;([θ&lt;sub&gt;A&lt;/sub&gt; + X, f]) （[,]は和の対）
- f&lt;sup&gt;*&lt;/sup&gt; = Rep&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sub&gt;X,X&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(∇&lt;sub&gt;X&lt;/sub&gt;;f;Δ&lt;sub&gt;X&lt;/sub&gt;)

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/looping.gif&quot; &gt;
&lt;/div&gt;

f&lt;sup&gt;#&lt;/sup&gt;の図から意味のない枝を取り去った図も描いている。もう少しわかりやすいレイアウトで描いてみると下の図、これは簡略型のElgotオートマトン、矢印の向きを逆にすると普通のオートマトン（遷移翻訳系）になる（ただし、出力は遷移先状態をそのまま出力する）。

[追記]f&lt;sup&gt;#&lt;/sup&gt;は次でもいいな。

- f&lt;sup&gt;#&lt;/sup&gt; = Tr&lt;sub&gt;X,A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;&amp;#40;(X + f);(σ&lt;sub&gt;X,A&lt;/sub&gt; + X);(A + ∇&lt;sub&gt;X&lt;/sub&gt;))

表示は複雑だが、絵としてはかえってわかりやすい。[/追記]

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/elgot-dual.gif&quot; &gt;
&lt;/div&gt;

やっぱり、絵算はオモシレー。

*1150266458*[トレース／コンパクト閉圏]絵算でゴー：トランスデューサ

上の絵を見てると言わずにおれん。

Elgot反復を双対圏で考える。余デカルト圏の双対圏はデカルト圏だから、余Elgotオペレータはデカルト圏に働く。面倒なので、余Elgotoオペレータも上付きの#で示す。普通は†で示して、Conwayオペレータと呼ぶ。

もとのf&lt;sup&gt;#&lt;/sup&gt;の絵の矢印（方向）を逆にして、さらにそれを“裏”から見た（あるいは鏡像の）絵を描く。遷移関数f:A×X→Xに対して余Elgotオペレータ（＝Conwayオペレータ）を作用させたf&lt;sup&gt;#&lt;/sup&gt;:A→Xは、単純なオートマトンになる。別に出力関数g:A×X→Bがあれば、Δ&lt;sub&gt;A&lt;/sub&gt;;(A×f&lt;sup&gt;#&lt;/sup&gt;);g としてトランスデューサが定義できる。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/pict-transducer.gif&quot; &gt;
&lt;/div&gt;

逆に、トランスデューサはこの形に限るのか？ まーこれは、トランスデューサの定義に依存する問題だな。

ところで、Elgotオペレータがデカルト圏で意味を持つのだから、Conwayオペレータ（の双対）も余デカルト圏で意味を持ちそうだな（以前は、無意味かと思っていたが）。


</body>
</day>
<day date="2006-06-15" title="">
<body>
*1150332251*[トレース／コンパクト閉圏]loopingオペレータ再まとめ

関連：
- [http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715176:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060614/1150258420:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715175:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060526/1148632477:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148539204:title]

双対も含めてまとめる。×は直積、+は直和、*は一般的なモノイド積だとする。

|* オペレータ名称 |* 記号 |* プロファイル |* 略記|
|トレース|Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;|(A*X→B*X)→(A→B)|f↑|
|Conway不動点|Fp&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;|(A×X→X)→(A→X)|f&lt;sup&gt;†&lt;/sup&gt;|
|Elgot反復   |Itr&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;|(X→A+X)→(X→A)|f&lt;sup&gt;#&lt;/sup&gt;|
|Kleene繰り返し|Rep&lt;sup&gt;X&lt;/sup&gt;|(X→X)→(X→X)|f&lt;sup&gt;*&lt;/sup&gt;|
|余Conway不動点|coFp&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;|(X→A+X)→(X→A)|f&lt;sup&gt;-†&lt;/sup&gt;|
|余Elgot反復   |coItr&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;|(A×X→X)→(A→X)|f&lt;sup&gt;-#&lt;/sup&gt;|

対称モノイド圏の種類とオペレータの関係：

|* 圏の種類 |* 許容できるオペレータ |
|一般        | Tr |
| デカルト   | Tr, Fp, coItr |
| 余デカルト | Tr, Itr, coFp |
| 双デカルト | Tr, Fp, Itr, coFp, coItr, Rep|

と、この程度のことは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060606/1149586253&quot;&gt;Network Algebra&lt;/a&gt;に書いてあるのだよな。

*1150332252*[トレース／コンパクト閉圏][山勘]単成的な双デカルト・モノイド圏

C = (C, +, 0)が双デカルト・モノイド圏とする。X∈|C|が単純だとは、Xは0に同型でなくて、「monoなi:S→Xがあるとき、S≒0またはS≒X」なこと。Cが単成的（単項生成的）とは：

- 単純対象が（同型を除いて）1つしかない。
- すべての対象は半単純、つまり単純対象の有限積として書ける。

単成的でベキ等「Δ;∇ = 1」な双デカルト・モノイド圏にトレースがあるとき、次が成立するのではないか？

- Uは単純対象として、K = End(U)はKleene代数になる。
- Cは行列の圏Mat&lt;sub&gt;K&lt;/sub&gt;に圏同値である。

もし、そうなら、KozenのKleene行列計算に対する圏論的特徴付け（再定義）となる。もう少し、なんか（なんだ？）あるような気もするけど。

参考：
-[http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715173:title]
-[http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715174:title]
-[http://d.hatena.ne.jp/m-hiyama-memo/20060526/1148632623:title]
-[http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148523219:title]

*1150342747*[トレース／コンパクト閉圏][計算]絵算のコツ（ダミーワイヤー）

射影と入射は確かに双対だ。絵算の観点からは、どちらもダミーワイヤーを導入するときに使う。ダミーワイヤーは繋がってない（通電してない）ワイヤーで、捨てても同じ。配線の帳尻を合わせるために適宜挿入する。

絵算でダミーワイヤーは必須だけど、どうせ後で捨てる（discharge, discard）のだから、複雑な配線はしてもしょうがない。例えば、クロス配線（対称ブレイディング）とかは避ける。

まー、最初は適当に配線して、後から整理してもいい。

&lt;span style=&quot;font-size:large;&quot;&gt;実例は近々出す。&lt;/span&gt;→[http://d.hatena.ne.jp/m-hiyama-memo/20060616/1150425654:title]

*1150344387*[リンク][人物]ゴールドブラッド

意外と少ない。

- [google:coalgebra Robert Goldblatt]


</body>
</day>
<day date="2006-06-16" title="">
<body>
*1150425654*[トレース／コンパクト閉圏][計算]トレースの再現

[http://d.hatena.ne.jp/m-hiyama-memo/20060615/1150342747:title]の件：

まず、余デカルト圏のElgot反復と、デカルト圏のConway不動点から、トレース・オペレータをもう一度作り出す絵。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/trace-again-1.gif&quot; &gt;
&lt;/div&gt;

律儀に、θ、σ、+（または、!、σ、×）を組み合わせて準備をしている。それぞれ、次の射を最初に作るのだ。

- (f + θ&lt;sub&gt;A&lt;/sub&gt;);(B + σ&lt;sub&gt;X,A&lt;/sub&gt;)
- (A × σ&lt;sub&gt;X,B&lt;/sub&gt;);(f × !&lt;sub&gt;B&lt;/sub&gt;);

だが、クロスは不要で、次のようにすればいい。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/trace-again-2.gif&quot; &gt;
&lt;/div&gt;

ここで、ιを入射、πを射影だとすると、次の射を準備している。

- f;(B + ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;)
- (π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; × X);f

こうやってもいいことは、次からわかる。

- B + σ&lt;sub&gt;X,A&lt;/sub&gt; ≒ B + ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;
- A × σ&lt;sub&gt;X,B&lt;/sub&gt; ≒ π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; × X

さらにこれを示すには、直積／直和の性質まで戻らないとダメかな。


</body>
</day>
<day date="2006-06-17" title="">
<body>
*1150515090*[トレース／コンパクト閉圏][計算]回ったワイヤーをほどく

箱を囲んで回り込んでいるワイヤーをほどいて真っ直ぐにする操作は割と出てくる。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/untie-looping.gif&quot; &gt;
&lt;/div&gt;

見た感じから、ヤンキングを使うことは予想できるが、手順は次のようにする。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/deloop-proof.gif&quot; &gt;
&lt;/div&gt;

+ クロス（対称ブレイディング）のスワップ公式で、箱をループから外に出す。
+ 右タイトニングを使って輪を縮める。
+ クロスと輪の部分にヤンキングを適用する。
+ クロス＋輪がなくなる。

[http://www.chimaira.org/docs/Superposing.htm:title]も参照。


</body>
</day>
<day date="2006-06-19" title="">
<body>
*1150676276*[トレース／コンパクト閉圏][リンク][課題]Kozen圏

&lt;a href=&quot;http://www.chimaira.org/archive/KleeneCat.txt&quot;&gt;ホプキンス（Hopkins）&lt;/a&gt;／&lt;a href=&quot;http://www.cosc.brocku.ca/Faculty/Winter/JoRMiCS/Vol1/PDF/v1n12.pdf&quot;&gt;カール（Kahl）&lt;/a&gt;／&lt;a href=&quot;http://unit.aist.go.jp/cvs/tr-data/PS02-005.PDF&quot;&gt;木下&lt;/a&gt;等によりKleene圏が定義されているが、事実上のKleene圏の創始者は&lt;a hre=&quot;http://www.cs.cornell.edu/~kozen/&quot;&gt;デクスター・コゥゼン（Kozen）&lt;/a&gt;のような気がする。それで、Kleene圏のバリアントを&lt;strong&gt;Kozen圏と呼ぶ&lt;/strong&gt;ことにしよう。（[http://d.hatena.ne.jp/m-hiyama-memo/20060706/1152164791:title]参照。）

コゥゼンは圏論が嫌いのようだ（あえて圏論を避けているように思える）から、Kozen圏なんてネーミングはイヤがるかもしれない。が、コゥゼンのTyped Kleene AlgebraとKleene代数係数行列の概念を圏論的に定式化するとKozen圏なのだから、別にイイガカリ(?)ではない。

Kozen圏とは、トレース付き・ベキ等・双デカルト・対称モノイド圏のことである。要するに、この&lt;em&gt;長ったらしい言い方&lt;/em&gt;を縮めたかった。カザネスク／ステファネスク／ハイランド／長谷川の結果から、Kozen圏はConway圏（不動点オペレータを持つ圏）である。つまり、Kozen圏は“線形不動点方程式が解ける圏”として特徴付けられる。

定義の妥当性のためには、次を示す必要がある。

- Kozen圏は、ホプキンス／カール／木下の意味のKleene圏である。
- 単生（単項生成）Kozen圏は、生成対象をU, K=End(U)として、Mat&lt;sub&gt;K&lt;/sub&gt;に圏同値である。

念のため、単生Kozen圏とは：

+ 単純対象が（up to isoで）ただ1つ存在する（通常Uと書かれる）。
+ すべての対象は、単純対象の直積（直和でもあるが）で書ける。

K |→ Mat&lt;sub&gt;K&lt;/sub&gt; と C |→ K=End(U) により、Kleene代数と単生Kozen圏は対応する。（一方、木下埋め込みは、Kleene圏をKleene代数（1対象Kleene圏）に埋め込む。）

*1150706460*[メモ法]脈絡は大事か

脈絡は過剰に気にすることはないだろう。後からリンクを張ればいい。


</body>
</day>
<day date="2006-06-20" title="">
<body>
*1150785000*[トレース／コンパクト閉圏]Kozen圏のスターとトレース

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060619/1150676276&quot;&gt;Kozen圏&lt;/a&gt;で、f:A+X→B+X のトレースは次のように表現できる。（ιは入射、πは射影、ブラケットは特に意味はなく単なる括弧）

- ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B,X&lt;/sub&gt;;[(π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;+X);f;(ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;+X)]&lt;sup&gt;*&lt;/sup&gt;;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B,X&lt;/sub&gt;

なんか複雑だが、この形は絵算の“次元解析”で容易に得られる。
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/trace-from-rep.gif&quot; &gt;
&lt;/div&gt;

fの正方化R(f)を次のように定義する。

- R(f) = (π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;+X);f;(ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;+X)

これを何で「正方化」と呼ぶかというと、行列（二部グラフ）を使って書くとわかる。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/rectangularized-matrix.gif&quot; &gt;
&lt;/div&gt;
ようするに、domainとcodomainを一致させたもの。トレースは、R(f)のスターを適当な入射／射影ではさんだ形をしている。

スターを使ったトレースはけっこう複雑なので、中間にConway不動点をはさんで扱ったほうがよさそうだ。

*1150785001*[トレース／コンパクト閉圏]不動点のダブル・ダガー公式

ダブル・ダガー公式（不動点の対角性）は：

- (f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt; = &amp;#40;(A+Δ);f)&lt;sup&gt;†&lt;/sup&gt;

ダガー（不動点オペレータ）がトレースで定義されている状況で、これを示す。

まずは次の簡単な補題：

- Tr&lt;sup&gt;X+X&lt;/sup&gt;(f;Δ;(Δ+X)) = Tr&lt;sup&gt;X&lt;/sup&gt;(Tr&lt;sup&gt;X&lt;/sup&gt;(f;Δ);Δ)

&lt;pre&gt;
   Tr&lt;sup&gt;X+X&lt;/sup&gt;(f;Δ;(Δ+X)) //↓バニッシング
=  Tr&lt;sup&gt;X&lt;/sup&gt;(Tr&lt;sup&gt;X&lt;/sup&gt;(f;Δ;(Δ+X))) //↓内側に右タイトニング
=  Tr&lt;sup&gt;X&lt;/sup&gt;(Tr&lt;sup&gt;X&lt;/sup&gt;(f;Δ);Δ)
&lt;/pre&gt;

（以下の図では、X1 = X2 = X）

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/double-trace-lemma.gif&quot; &gt;
&lt;/div&gt;

それと、Δに余結合律が成立することに注意：

- Δ;(Δ+X) = Δ(X+Δ)

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/diagonal-coassoc.gif&quot; &gt;
&lt;/div&gt;

ダブル・ダガー公式は次の手順：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/double-dagger-formula.gif&quot; &gt;
&lt;/div&gt;

(f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt; = Tr(Tr(f;Δ);Δ) だが、補題から Tr(Tr(f;Δ);Δ) = Tr(f;Δ;(Δ+X))、余結合律を考慮すれば、(f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt; = Tr(f;Δ;(X+Δ))。Δをスライディングで移動させれば、Tr((A+Δ);f;Δ) = (A+Δ;f)&lt;sup&gt;†&lt;/sup&gt;、これが求める結果。

*1150792194*[リンク]SOME RECENT APPLICATIONS OF SEMIRING THEORY

- http://moonstone.math.ncku.edu.tw/AlgebraConference/golantalk.pdf


</body>
</day>
<day date="2006-06-21" title="">
<body>
*1150863246*[雑記][リンク][人物]IdempotencyとMaslov

[http://d.hatena.ne.jp/m-hiyama/20060621/1150861661:title]の状況。どうしようなか？こういうときに美容院に行っておくのもテだが、それさえめんどくさい。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060530/1148980185&quot;&gt;Idempotency&lt;/a&gt;が来ているから、これを眺めるか。

Golan（著者）の&lt;a href=&quot;http://moonstone.math.ncku.edu.tw/AlgebraConference/golantalk.pdf&quot;&gt;SOME RECENT APPLICATIONS OF SEMIRING THEORY&lt;/a&gt;は、[google:&quot;Victor P. Maslov&quot;]で見つけた。このマスロフは、Web上のプレゼンスは薄いが、エライ数理物理学者で、ベキ等解析の創始者でもあるようだ。

*1150871144*[トレース／コンパクト閉圏][形式言語理論]繰り返しx*と強い繰り返しx+、長谷川の不動点補題

正規表現において、x* と x+ のどっちを基礎においてもかまわない。

- x* = 1 + x+
- x+ = (x*)x

トレースを使ったスターの定義 Tr(∇;f;Δ) は、どちらかというと+の定義だと思ったほうがいいような気がしてきた。絵を見てもx+の絵だし、次の等式が状況証拠：

- x+ = (1 + x+)x

この等式の両辺に1を足せば：

- x* = 1 + (x*)x

となって、通常の不動点方程式となる。ところが、x+ = (1 + x+)x は、次のトレースに関する公式から出るのだ。

- Tr(f) = &amp;lt;A, Tr(f;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;B,X&lt;/sub&gt;;Δ&lt;sub&gt;X&lt;/sub&gt;)&gt;;f;π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;B,X&lt;/sub&gt;

プログラミングでは、whileとdo-whileの違いだが、do-whileから公理化するアプローチも別に悪い点はない。

もし、Tr'(f) = &amp;lt;A, Tr(f;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;B,X&lt;/sub&gt;;Δ&lt;sub&gt;X&lt;/sub&gt;)&gt; とするなら、Tr':(A,X →B, X)→(A→A,X) だが、このTr'のほうが*に近い存在だろう。先に出したトレースの公式は、長谷川さんが彼の定理（カザネスク／ステファネスク／ハイランド／長谷川）の補題として使っている。けっこうキモな公式だから、&lt;strong&gt;長谷川の不動点補題&lt;/strong&gt;と呼んでおこう。

*1150873298*[トレース／コンパクト閉圏]厳密な双デカルト・対称モノイド圏は自明にAbMon圏

コラディニ／ガダッチ（Corradini/Gadducci）のGSモノイド圏のような等式（equational）スタイルで厳密（strict）な双デカルト・対称モノイド圏が定義されているとする。一方、マクレーン本のAb圏とまったく同様にAbMon圏を定義する。AbMonはアーベル（可換）モノイドの圏である。

この状況で、厳密な双デカルト・対称モノイド圏がAbMon圏になることは、ほぼ自明である。f∨g = Δ;(f+g);∇ として：

- (f∨g)∨h = f∨(g∨h) は、Δの余結合律と∇の結合律から出る。
- f∨g = g∨f は、Δの余可換律と∇の可換律、対称ブレイディングσのスワップ公式から出る。
- 0∨f = f は、Δの余単位律と∇の単位律から出る。
- f;(g∨h) = f;g∨f;h は、f;Δ = Δ;(f+f)と ∇;f = （f+f);∇ から出る。

結局、対角と終対象(Δ&lt;sub&gt;X&lt;/sub&gt;, !&lt;sub&gt;X&lt;/sub&gt;)、余対角と始対象(∇&lt;sub&gt;X&lt;/sub&gt;, θ&lt;sub&gt;X&lt;/sub&gt;)が、Xごとに可換コモノイド、可換モノイドを作る点が重要。

AbMon圏では、XごとにEnd(X)が半環を作る。圏がベキ等であればEnd(X)もベキ等半環。特に、圏が単生（1つの対称で生成）ならば、半環上の行列圏に圏同値、ベキ等ならば、ベキ等半環上の行列圏に圏同値。Lawvereスタイルの（つまり、対象が&lt;b&gt;N&lt;/b&gt;である）行列理論（matrix theory）があれば、そのCモデルM:T→C（Tが理論）は、M(1)で決定されることになる。よって、Model(T, C)≒|C| となる。さらに、Model(T, C)を圏と考えれば、Model(T, C)≒C -- って、コレ、もう少し詳しい記述が欲しい。

</body>
</day>
<day date="2006-06-22" title="">
<body>
*1150934405*[雑記][リンク]Traced Premonoidal Categories

めまいのせい、つうわけではなくて、本編書く気がしないな。

- [google:&quot;traced premonoidal categories&quot;]

やっぱり、トレース付き前モノイド圏を調べるほうがいいような気がしてきた。

*1150935680*[トレース／コンパクト閉圏][プログラム意味論]Bekicの公式

ベキック（Bekic; cの上にv字形のダイアクリティカルマーク）の公式は、並列結合の不動点を、不動点の直列結合で表現する。これをソフトウェア的に解釈する。

fは、制御パラメータ領域Aと入出力領域Xを持つ関数、プロセス、力学系などとする。制御パラメータa∈Aを固定するごとに、f_a:X→Xの不動点fix(f_a)が定まるとしよう。これをaの関数と見て、λa∈A.fix(f, a) : A→X が定まる。この (A,X→X)→(A→X) がConway不動点オペレータ。

f:A,X→X, g:A,Y→Y が2つの系だとして、制御パラメータ領域Aは共通。このとき、並列結合 A,X×Y→X×Y が定義できる。この並列結合を&amp;lt;f|g&gt;と書くことにする。&amp;lt;f|g&gt;の不動点&amp;lt;f|g&gt;&lt;sup&gt;†&lt;/sup&gt;をfの不動点とgの不動点によって書き下す公式がBekicの公式。（Bekicの公式を今は書き下さない。）

Bekicの公式は、Conwaｙのsum-star equation (x+y)* = (x*y)*x* と似ている。たぶん、対応しているのだろう。それと、sum-star equationとKozenによるスターの行列表示も似ている。本質的に同じなんだと思うが、ハッキリとしない。

*1150935681*[トレース／コンパクト閉圏]Δと∇と□

双デカルト・モノイド圏において、Δ&lt;sub&gt;X&lt;/sub&gt;を単にΔ、id&lt;sub&gt;X&lt;/sub&gt;を1と略記して、f∨g = Δ;(f+g);∇ と定義する。このとき、f∨f = f、1∨1 = 1、Δ;∇ = 1 は同値になる。これがベキ等性。

□ = ∇;Δ と定義する。□を完全行列と呼ぶ。理由は、完全グラフに対応する行列で、すべての成分が1になるからだ。ベキ等であっても、□は1にはならない。(f∨g)* は、Tr(∇(Δ;(f+g);∇)Δ)と書けるから、Tr(□;(f+g);□)である。f @ g = □;(f+g);□ とすると、演算@は役に立つだろうか？ とりあえず (f∨g)* = Tr(f @ g) は（定義より）成立する。

ソフトウェア的には、f @ g は、fとgを分離的に並列結合して、その入出力を混ぜてしまう演算だ。

*1150946986*[雑記][リンク]Polarized Categories

次の検索でなんかひっかかってきた。

- [google:&quot;polarized categories&quot; functor]

ウーム、ムムムム。圏論的moduleってのはイッパイ呼び名があったけど、忘れた。moduleだと検索に不便だしなー。（調べた：profunctor, bimodule, distributor）

偏極圏てのはゲーム圏に関係するのか、線形論理にも関係する、と。制御圏（cotrol categories）とか応答圏（response categories）てのもあるわけ？ほえー。

[google:category module bifunctor]でまたいろいろ引っかかる。

*1150959337*[雑記]ペトリネット

繰り返し言うが、証明図やオートマトンの状態遷移図を描くときは、単なる有向グラフではなくて、&lt;strong&gt;ペトリネットで描くべき。&lt;/strong&gt;ペトリネットなら、有向ハイパーグラフの有向ハイパー辺も遷移ノードとして描ける。ツリー・オートマトンの遷移規則も遷移ノードとして描ける。

*1150960156*[トレース／コンパクト閉圏]余ElgotオペレータとConwayオペレータ

トレースのある余デカルト圏では、Elgotオペレータは、f:X→A+Xに対して Tr[(X+f);(σ+X)(A+∇)]:X→A となる。双対的に余Elgotオペレータは、Tr[(A×Δ);(σ×X);(X×f)]:A→X である。

ところが、余Elgotオペレータを変形すると、Tr(f;Δ)となり、Conway不動点オペレータとなる。つまり、トレース付きデカルト圏では「余Elgotオペレータ = Conwayオペレータ」となる。双対的に、トレース付き余デカルト圏では「Elgotオペレータ = 余Conwayオペレータ」。

*1150960157*[トレース／コンパクト閉圏]余トランスデューサ

デカルト圏では「トレース＝トランスデューサ（を構成する操作）」と考えてよい。対応する余デカルト圏の概念として余トランスデューサを考えることができる。余トランスデューサは、入力関数で入力を振り分けして、必要ならElgotオートマトン X→A+Xにかけて、出力をはき出す。余デカルト圏では、トレース（の結果できるモノ）は余トランスデューサで表現できる。

*1150962733*[まとめ][用語法][その他代数]Exotic Semirings

トロピカル関係：

|*台集合        |*加法 |*乗法 |* 名称 |
|&lt;b&gt;N&lt;/b&gt;∪{+∞} |min|+ |tropical半環 |
|&lt;b&gt;N&lt;/b&gt;∪{-∞} |max|+ |polar半環 |
|&lt;b&gt;N&lt;/b&gt;∪{+∞} |min|max|fuzzy半環 |
|&lt;b&gt;R&lt;/b&gt;∪{+∞} |min|+ |optimization代数 |
|&lt;b&gt;R&lt;/b&gt;∪{-∞} |max|+ |schedule代数, max-plus代数|

熱帯(tropical)と極地(polar)ですか。なるほどEXOTIC。max-plusはトロピカルじゃなくてポーラーのほうか。実数ベースだとoptimizationが正式のようだが、こっちもトロピカルと言うことも多いな。実際、トロピカル（代数）幾何は、実空間の図形をトロピカル半環（半体になっている）上の多項式のイデアル論（半イデアル論か？）で扱うようなものだ。

ところで、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060621/1150863246&quot;&gt;マスロフ&lt;/a&gt;が、&lt;b&gt;R&lt;sub&gt;+&lt;/sub&gt;&lt;/b&gt;上に正数hに対するh加法を：

- (a&lt;sup&gt;1/h&lt;/sup&gt; + b&lt;sup&gt;1/h&lt;/sup&gt;)&lt;sup&gt;h&lt;/sup&gt;

で定義している。hが0に近づくと、これはmax(a, b)に近づく。このh加法（h=0でもよい）と普通の乗法で半環R&lt;sub&gt;+&lt;/sub&gt;(h)ができる。

一方、1＜t≦∞ に対して、&lt;b&gt;R&lt;/b&gt;上に：

- log&lt;sub&gt;t&lt;/sub&gt;(t&lt;sup&gt;a&lt;/sup&gt; + t&lt;sup&gt;b&lt;/sup&gt;)

として“[t]加法”を定義して、乗法を普通の加法だとする半環R[t]も定義できる。R&lt;sub&gt;+&lt;/sub&gt;(h)とR[t]は、t = exp(1/h) の関係で移りあう。

このへんが、アメーバ理論や超離散と関係するらしい。超離散とからむってことは可積分系だろうから、やっぱり物理なんだろうな、あー、物理はわからん。

</body>
</day>
<day date="2006-06-23" title="">
<body>
*1151031526*[まとめ][トレース／コンパクト閉圏]圏のloopingと不動点

なんか、思惑とは違った展開だな -- 別にいいけど。状況をまとめておく。

まず、ElgotオペレータとConwayオペレータは、&lt;strong&gt;本質的に同じ&lt;/strong&gt;ことがわかった。Elgotオペレータが余デカルト（な対称モノイド）圏、Conwayオペレータがデカルト圏に作用するもので、お互いに双対になっている。

- デカルト圏で、Conwayオペレータ ⇔ トレース
- 余デカルト圏で、Elgotオペレータ ⇔ トレース

結局は、カザネスク／ステファネスク／ハイランド／長谷川の定理に集約される。この定理の副産物として、X&lt;sup&gt;+&lt;/sup&gt; = (1 + X&lt;sup&gt;+&lt;/sup&gt;)X に対応する補題があり、これがトランスデューサの構造をうまく表現して、f = &amp;lt;f&lt;sub&gt;out&lt;/sub&gt;, f&lt;sub&gt;tran&lt;/sub&gt;&gt; という分解を与える。

- Tr(f) = Δ;(A × (f&lt;sub&gt;tran&lt;/sub&gt;)&lt;sup&gt;†&lt;/sup&gt;);f&lt;sub&gt;out&lt;/sub&gt; = &amp;lt;A, (f&lt;sub&gt;tran&lt;/sub&gt;)&lt;sup&gt;†&lt;/sup&gt;&gt;; f&lt;sub&gt;out&lt;/sub&gt;

双デカルト圏で、Tr(∇;f;Δ)がKleeneスターになると踏んでいたのだけど、これはどうも無理があるような気がする。というのも、Kleene代数／Kleene圏の条件には、Horn条件付き等式があって、完全に等式的ではない。双デカルト圏を（GSモノイダル圏のように）等式的に定義するなら、Horn式が示せる見込みはない。

しかし、双デカルト圏でも、不動点に関する条件と、sum-star equationは示せるような気がする。となると、End(X)はConway代数（ベキ等とは限らない半環）と思ったほうがよさそうだ。

そこで、Conway代数とKleene代数の差が問題になる。Zoltan Esik, Werner Kuichi &quot;Rationally Additive Semirings&quot;（http://www.brics.dk/RS/01/42/BRICS-RS-01-42.pdf）から要点を引き写しておく。

まずはConway代数（Conway半環）の等式：

- (x + y)* = (x*y)*(x*)
- (xy)* = 1 + x(yx)*y

行列に関するスターの定義は：

M = [a, b; c, d], M* = [α, β; γ, δ] として：

- α = (a + bd*c)*
- β = αbd*
- γ = δca*
- δ = (d + ca*b)*

このへんはKleene代数と特に変わりがない。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148523219&quot;&gt;([(a + bd*c)*, (a+bd*c)*bd*; (d+ca*b)*ca*, (d+ca*b)*])&lt;/a&gt;

さて、a∈End(A), b∈End(B), f:A→B に対して、次が条件を考える：

- a;f = f;b ならば、a*;f = f;b*

この条件もEsik, Kuichiにあるのだが、これでKleene代数に近づけないか？

もうひとつのヒントは、Idempotency本P.114に載っていた partially additive category概念かな（その定義は、なんかイマイチな気がするが）。partially additive categoryでは、可算個の対象や、可算個の射に対して足し算ができるので、だいたいω極限がとれると思ってよい。これは、圏のなかで無限級数の計算ができるようなものだと思っていいだろう。すると、ω極限としてKleeneスターを作れるかもしれない。

*1151055999*[リンク][論理][トレース／コンパクト閉圏]線形論理とトレース

なんかのはずみで見つけた&quot;Polarized Proof Nets with Cycles and Fixpoints Semantics&quot;（http://www.pps.jussieu.fr/~montela/papers/tlca03.pdf）がけっこうひろいものだった。どうやって引っかけたか忘れたが：

- [google:&quot;linear logic&quot; polarized  functor]
- [google:&quot;linear logic&quot; polarized  taraced]

とかでリストされる。

僕が興味を持ったのは、推論図ごとにトレース付きデカルト閉圏における解釈が表になっていたところ。実際には条件“デカルト閉”を弱められて：

- 特定のオブジェクトRが存在する。
- R&lt;sup&gt;(-)&lt;/sup&gt;に相当する自己関手Pがあって、C(A×B, R)とC(A, P(B))が同型。

つまり、Rに関してだけ、ベキ、（アン）カリー化などの概念が使える。ゲンツェン風LJの解釈は、こういう圏（なんて呼ぶのか？）でもできるようだ。Rを真偽値、P(B)をB上の述語の全体（を対象とみなしたもの）と解釈できるのだろう、たぶん。デカルト閉圏とは違い、無制限に高階対象を作れるわけではない。×をテンソル積、Rをスカラー体と思うと、線形代数でも通用するハナシだと思う

mixルールがモノイド積、cutがトレース、コントラクションが余対角、水増しが終対象兼モノイド単位に対応する。明示的に換(interchange)を入れると、換は対称になるのだろう。ここで、「モノイド積と対称とトレースで、結合が表現できる」というアノ定理（[http://www.chimaira.org/docs/CompositionInTMC.htm:title]）が意味を持つかもしれない。

</body>
</day>
<day date="2006-06-26" title="">
<body>
*1151280740*[まとめ][XML]XMLに戻ろう

道具が十分揃った、とは全然&lt;em&gt;言えない&lt;/em&gt;けど、当初の目的であったXMLへのアタックを再開しよう。そう思った理由は：

&lt;h4&gt;理由その1：インラインテーブル問題&lt;/h4&gt;

昔（20世紀だな）設定したいくつかの問題のなかでも難問だと思っていた「インラインテーブル問題」、ふと思い出して考えたら、10分くらいでアッサリ／スッキリ解けてしまった。これが解けたからOKというわけではないが、2000年くらいに何ヶ月もイライラして七転八倒していたことを思えば、随分と事情は改善した気がする。

&lt;pre class=&quot;code&quot;&gt;
&amp;lt;!ENTITY % td_content &quot;ANY&quot;&gt;

&amp;lt;!ELEMENT table (tr*)&gt;
&amp;lt;!ELEMENT tr (td*)&gt;
&amp;lt;!ELEMENT td (%td_content;)&gt;
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
&amp;lt;!ENTITY % more_inlines &quot;&quot;&gt;

&amp;lt;!ELEMENT p (#PCDATA|em %more_inlines;)* &gt;
&amp;lt;!ELEMENT em (#PCDATA)&gt;
&lt;/pre&gt;

この状況で、%td_content;に&quot;p&quot;を入れて、%more_inlines;に&quot;|table&quot;を入れたら何が起きるか？ その意味論をキチンと組み立てろ -- これがインラインテーブル問題。

上のDTDと同等な文法モジュールをtable、下のDTDと同等な文法モジュールをparとする。要素集合の集合をE、内容集合の集合をC、Eを混合内容の材料と見なしたものをDとする。EとDは実際は同じだから、その同型をi, EをD（Cと同じ）に埋め込む写像をjとする。

- table:C→E
- par:D→E
- i:E→C
- j:E→D

fを次のように定義する。

- f = par;Δ&lt;sub&gt;E&lt;/sub&gt;;(E × j;table);(E × Δ&lt;sub&gt;E&lt;/sub&gt;);(E × (E × j))

すると、f: D → E×E×D。Dに関してfのトレースをとって、Tr&lt;sup&gt;D&lt;/sup&gt;&lt;sub&gt;1,E×E&lt;/sub&gt;(f):1 → E×E。これが結局、インラインテーブルと段落が相互に入れ子になったものを定義する。

一見複雑そうだが、絵算を使えばそうでもない。

&lt;h4&gt;理由その2：圏ΩΟ&lt;/h5&gt;

ωο（omega-omicron）集合を次のように定義する。(A, ≦, 0)がωο集合であるとは：

+ (A, ≦)は順序集合。
+ 0∈Aは、≦に関して最小元
+ 任意のω増加列（可算上昇鎖、厳密には非減少列）は極限（上限）を持つ。

射は、単調でω連続な写像だとする。0が0に写ることは&lt;strong&gt;要求しない&lt;/strong&gt;。この具象圏をΩΟ（Omega-Omicron）と呼ぶ。

この圏は終対象と直積を持ち、これに関してモノイド圏、さらにベキも存在して閉圏である。始対象（空）は存在するが（空を除外する事もある）、直和は定義できない。しかし、A+B+{⊥}やA+B+{⊥}+{T}を直和の代わりに使える。トップ添加、ボトム添加、サイド添加、下方閉ベキ集合などがΩΟ上にモナドとして作用している。

ΩΟの最大の特徴は、任意の自己射が最小不動点を持つことで、これはConway不動点オペレータとなる。したがって、カザネスク／ステファネスク／ハイランド／長谷川の定理からトレースが定義できる。よって、ΩΟは、トレース付きデカルト閉圏。

ΩΟは具体的で非常に使いやすい。これをXML意味論の背景圏（ambient category）に使える。

&lt;h4&gt;理由その3：XML指標&lt;/h5&gt;

当然ながらインスティチューションを使いたいのだが、指標圏の構成が問題になる。指標は順序付き多ソート（ordered many-sorted, order-sorted）指標を使う。ある程度現実を反映させると、典型的XML指標は10個のソートを必要とする（もっと要るかも）。

+ Data
+ Symbol
+ Attribute
+ Tag
+ Element
+ Sequence
+ Collection
+ Mixture
+ Content
+ AttributedContent

順序は：

+ Symbol⊆Tag
+ Tag⊆Element
+ Element⊆Sequence
+ Data⊆Sequence
+ Sequence⊆Content
+ Element⊆Collection
+ Mixture⊆Content
+ Attribute⊆AttributedContent
+ Content⊆AttributeedContent

演算（記号）も山のようにある。&lt;strong&gt;しかたないのだ！&lt;/strong&gt;指標Σを選ぶことが、ほぼスキーマ言語を選ぶことになる。

&lt;h4&gt;理由その4：まだ足りない、だからこそ&lt;/h5&gt;

実際は、まだ道具が足りない。が、足りない点を埋めるためにも、出来るところをやってしまおう、ということもある。

*1151280989*[XML]Katy記法

Katy（ケイティ）記法に関してもそのうち記述。とりあえず、インラインテーブル問題。
&lt;pre class=&quot;code&quot;&gt;
module Table
 provides element table;
 requires content td_content;
{
 element table = &amp;lt;table&gt;(tr*);
 element tr = &amp;lt;tr&gt;(td*);
 element td = &amp;lt;td&gt;(td_content);
}

module Par
 provides element p;
 requires collection more_inlines;
{
 element p = &amp;lt;p&gt;(#(em|more_inlines));
 element em = &amp;lt;em&gt;(#);
}

module Nested = rec{more_inlines}(
 |-{table, more_inlines=table}Table&amp;lt;-{p, td_content=p}Par);
&lt;/pre&gt;

モジュールの定義は次のように書いても同じ。
&lt;pre class=&quot;code&quot;&gt;
module Par = mod[element p &amp;lt;= collection more_inlines]{
 p = &amp;lt;p&gt;(#(em|more_inlines)); element em = &amp;lt;em&gt;(#); };
&lt;/pre&gt;

Katyは、モジュール定数、モジュール変数、モジュール演算からモジュール式を組み立てて、モジュール定義（モジュールの名前へのバインド）を行う言語。

</body>
</day>
<day date="2006-06-27" title="">
<body>
*1151380173*[XML]XML構造の絵

とりあえず、XML構造を順序付き多ソート指標で表現するとして、順序（領域集合間の自然な包含）を図示するとこんな感じ。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/xml-incl-diag.gif&quot; &gt;
&lt;/div&gt;

次に、（抜けがあるし杜撰だが）各領域の依存関係。ペトリネット風。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/xml-depend-diag.gif&quot; &gt;
&lt;/div&gt;

図中で：

- AN : 属性項目名
- TN : タグ名
- Char : 文字

*1151380324*[XML]代数構造達

XMLがらみで出てくる代数構造に略記を与えておこう。

|* 名前 | 略記 |
|単なる集合              |S|
|モノイド                |M|
|可換ベキ等モノイド      |CIM|
|可換ベキ等モノイド（和と解釈）|AbIM|
|ベキ等半環              |ISR |
|可換ベキ等半環          |CISR|
|クリーネ(Kleene、クリーニ)代数    |KA |
|可換クリーネ代数（クリーニ代数）        |CKA |

Y作用を伴うXを「X-Y」と書くことにする。

|* 名前 | 略記 |
|集合作用付きモノイド              |M-S|
|可換ベキ等モノイド作用付き集合    |S-CIM|
|集合作用付きクリーネ代数          |KA-S |

具体例；
|* 領域の種別 | 代数構造 |
|列（リスト） | M |
|要素列       | M-S |
|シンボル型   | AbIM |
|属性型       |CISM, 退化CKA |
|タグ型       |S-CIM (AbIM-CISM)|
|列型         |KA|
|要素列型     |KA-S (KA-AbIM)|

マクロレベルでは、トレース付きモノイド圏、特にΩΟを使うが、ミクロレベルでは個別のインスタンス領域／型領域（言語領域）の代数構造を調べる必要がある。ここで、“領域”と呼んでいるのはωο集合であることを仮定するから。「領域＝圏ΩΟの対象」


</body>
</day>
<day date="2006-06-28" title="">
<body>
*1151464078*[XML][圏一般論]圏ΩΟ、モデル論、ambient category

ΩΟに空集合を入れるのは&lt;em&gt;止めた&lt;/em&gt;。直和が定義できないのだから始対象だけあってもしょうがない。

なんかのモデル論をやるとき、その内部でモデルを構成する側の圏を背景圏（ambient category）と呼んでおこう。Set、Ord（順序集合）、Vect（線形空間）なんかが背景圏によく使われますね。ΩΟ（Omega-Omicron）も背景圏のために定義した。

+ ΩΟは具象的である。手で触れる。
+ ΩΟは直積と終対象を持つ。
+ ΩΟは指数を持ち、デカルト閉である。
+ ΩΟは自分自身でenrichされている。
+ ΩΟは共変、反変のpower monadを持つ。
+ ΩΟは集合圏からの自然な埋め込み関手を持つ。
+ ΩΟはConway不動点オペレータを持つ。
+ ΩΟはトレース付きモノイド圏である。

あと、dualityがあるといいんだけどな。

*1151472387*[XML]教訓

今までやって気が付いたことを再確認しておこう。

- 代数構造にこだわりすぎない。
- 順序を忘れるな、順序が本質。
- 不動点⇔μオペレータ⇔トレース -- つまりCSHH定理を使え。
- 対称σの扱いに注意。
- 直和の扱いに注意。

Sequenceの代数は確かにクリーニ（クリーネ）代数になるのだが、他の領域もきれいな代数になるとは限らない。実は代数構造がなくてもなんとかなるし、演算の選び方も&lt;em&gt;激しく恣意的&lt;/em&gt;。順序さえあればいいのだ。だから順序に注目すべき。

不動点は順序から構成する。不動点概念とμ記法による表現とトレースを使った意味論、となる。表現の圏のほうが扱いが難しい。表現の圏では、対称や直和がみえにくくなるので注意。人間が手で扱う表現とモデルとのあいだに、適当な圏（二圏、hom-catは表現の書き換えの圏）をはさむと良いだろう。&lt;em&gt;α変換とμ計算の形式的体系が必要だ。&lt;/em&gt;

*1151476298*[トレース／コンパクト閉圏]Conway不動点のμ表現

+ 不動点：f&lt;sup&gt;†&lt;/sup&gt; = &amp;lt;f&lt;sup&gt;†&lt;/sup&gt;, A&gt;;f --  μx.f(x, a) = f(μx.f(x, a), a)
+ 自然性：[(g×X);f]&lt;sup&gt;†&lt;/sup&gt; = g;f&lt;sup&gt;†&lt;/sup&gt; --  μx.(f(x, g(b)) = (μx.f(x, a))[g(b)/a]
+ 対角自然性：(f;g)&lt;sup&gt;†&lt;/sup&gt; = [(A×g);f]&lt;sup&gt;†&lt;/sup&gt; -- μx.g(f(x, a)) = μt.f(g(t), a)
+ 対角性（ダブルダガー）：(f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt; = [(A×Δ);f]&lt;sup&gt;†&lt;/sup&gt; -- μx.(μx'.f(x', x, a)) = μx.f(x, x, a)

μで書くと、また違った味わい。

ちなみに、Conwayのdouble iteration identities, composition identitiesは、t = t(x, y, z1, ...), s = s(x, z1, ...), r=r(x, z1, ...) として、
+ μx.(μy.t) = μz.(t[z/x, z/y]) （ダブルダガー）
+ μx.(s[r/x]) = s[μx.(r[s/x])/x] （対角自然＋不動点性）

（[http://citeseer.ist.psu.edu/bloom00iteration.html:title]より。）

普通の自然性はどうなっているんだ？

それはそうと、λ記法やμ記法を使うと簡単になるのかな？ 圏論にあわせると、なんだか風変わりなラムダになってしまう気もする。Katyだって、まーラムダみたいなもんだしな。

*1151483919*[雑感]ワカラン

表層的な現象が見えているけど、背後にある仕掛けがわかんない状態はイライラするね。もうヤメタ、、、、ってやめないけど。

</body>
</day>
<day date="2006-06-29" title="">
<body>
*1151539333*[雑記]プレゼントに応募

ウチの長男が欲しがってる！

マージンFXのひまわり証券さん、ニンテンドーDS Lite欲しい！

*1151547767*[圏一般論][インスティチューション]関手圏によるモデル圏構成、代入系の圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060628#1151483919&quot;&gt;昨日：&lt;/a&gt;
&gt;&gt;
表層的な現象が見えているけど、背後にある仕掛けがわかんない状態はイライラするね。もうヤメタ、、、、って止めないけど。
&lt;&lt;

あいかわらずイライラ。が、わかることだけ記録しておくしかない、クッソー。

とりあえず、Σを普通の多ソート指標とする。つまり、ソート記号の集合Σ&lt;sub&gt;S&lt;/sub&gt;と関数（演算子）記号の集合Σ&lt;sub&gt;F&lt;/sub&gt;があって、

- arity:Σ&lt;sub&gt;F&lt;/sub&gt;→(Σ&lt;sub&gt;S&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;
- coarity:Σ&lt;sub&gt;F&lt;/sub&gt;→Σ&lt;sub&gt;S&lt;/sub&gt;

という写像がある。

ambient categoryであるCはデカルト圏だとして、ΣのCモデルMは、M&lt;sub&gt;S&lt;/sub&gt;:Σ&lt;sub&gt;S&lt;/sub&gt;→|C|とM&lt;sub&gt;F&lt;/sub&gt;:Σ&lt;sub&gt;F&lt;/sub&gt;→Cの組。次の条件を満たす。

- ε（空列）に対してM(ε)=(Cの始対象)、M(s1,...,sn)=M(s1)×...×M(sn)としてMを拡張すると、dom(M(f))= M(arity(f))、cod(M(f)) = M(coarity(f))

Σから記号的に自由生成される圏をΣ~ とすると、MはΣ~からCへの直積保存関手となる。Model(Σ; C) = Functor(Σ~, C) である。Functor(Σ~, C)は自然変換を射とする圏だと考える。これで、モデル圏の圏論的（関手的）な定式化はできる。

Xを勝手な有限（に限る？）集合として、s:X→Σ&lt;sub&gt;S&lt;/sub&gt;があるとき、ソート付き変数集合と呼ぶ。x∈Xに対して直積Πs(x)を作って、これを[X]とする。[X]からの射の全体と対象とする圏（カンマ圏だっけ？）を(Σ~↑[X])とする。項集合T&lt;sub&gt;Σ&lt;/sub&gt;(X)ってのは、(Σ~↑[X])に近いと思うのだが。項の構成にタプルまで入れれば、T&lt;sub&gt;Σ&lt;/sub&gt;(X) = (Σ~↑[X]) かな？ ここ、よくわからん。

話は変わって、S=Σ&lt;sub&gt;S&lt;/sub&gt;として、Sソート付き集合の圏Set&lt;sub&gt;S&lt;/sub&gt;上の項モナドT&lt;sub&gt;Σ&lt;/sub&gt;のKleisli圏の反対圏（opposite）をAss&lt;sub&gt;Σ&lt;/sub&gt;と書いて&lt;strong&gt;代入系の圏&lt;/strong&gt;と呼ぶ。Model(Σ;C)、つまりFunctor(Σ~, C)から、Functor(Ass&lt;sub&gt;Σ&lt;/sub&gt;, C)への関手が自然に定まる。その手順：

+ ΣのCモデルMを決める。
+ ψ∈T&lt;sub&gt;Σ&lt;/sub&gt;(X) に対して、【ψ】=f:[X]→B in C が決まる。
+ Kleisli射 Ψ:Y→T&lt;sub&gt;Σ&lt;/sub&gt;(X) に対して、&lt;f1, ..., fn&gt;:[X]→[Y]が決まる。
+ これは、Kleisli圏からCへの反変関手である。

【ψ】の定義にはvaluationを使うが、valuationの全体が[X]である。valuationや【ψ】はわかるが、どうも背後にある全体的仕掛けがわからない。グギギギギ。

*1151565636*[XML]ベキ・モデルとボトム添加モデル

XMLの意味論とは、ΩΟをambient categoryとする多ソート指標のモデル論の特殊ケースだと思っている。次の事実は実際的に役に立つ。

Σを普通の多ソート指標、MをΣのΩΟモデルとする。NをΣのSetモデルとする。このとき：

- Mのpowerモデル（ΩΟ上の共変powerを適用する）M&lt;sub&gt;*&lt;/sub&gt;もまたΣのΩΟモデルである。
- Nのボトム添加モデルN&lt;sub&gt;⊥&lt;/sub&gt;は、ΣのΩΟモデルである。
- したがって、(N&lt;sub&gt;⊥&lt;/sub&gt;)&lt;sub&gt;*&lt;/sub&gt; などもΩΟモデルになる。

ソートをインスタンス領域と解釈するSetモデルNがあると、それから(N&lt;sub&gt;⊥&lt;/sub&gt;)&lt;sub&gt;*&lt;/sub&gt;を作れば、同じ指標に関する型（言語）領域モデルが自動的に出てくる。インスタンス演算は、自動的に型（言語）演算に持ち上がる。ただし、演算法則（セオリー）が持ち上がる保証は全然ないので注意！ セオリーごとにliftableかチェックする必要がある。

*1151565807*[圏一般論]具象表現とな何か

普通、具象圏というと、Setの部分圏とかSetへの忘却関手を持つ圏だが、少し別な味方をしてみる。

まず、Set、Ord、Vect、ΩΟのような具象的だと&lt;em&gt;思える&lt;/em&gt;圏を選んで、それをVと置く。このVは普通の意味で具象的、つまり集合論的だとする。それで、Cが具象的だとは、Vへの表現を（なにか、1つでも）持つときだとする。CがV-enrichedなら、V具象的となる。なぜなら、&lt;strong&gt;主表現がある&lt;/strong&gt;からだ。

A∈|C|に対して、V表現であるR&lt;sup&gt;A&lt;/sup&gt;:C→Vと、反変のR&lt;sub&gt;A&lt;/sub&gt;:C→Vを定義しよう（主表現）。添字の上下が普通と逆だが、後で事情がわかるはず。X∈|C|に対して、R&lt;sup&gt;A&lt;/sup&gt;(X) = C(A, X) だが、C(A, X)∈|V|。f:X→Yに対して、fのpost-composeにより R&lt;sup&gt;A&lt;/sup&gt;(f):R&lt;sup&gt;A&lt;/sup&gt;(X)→R&lt;sup&gt;A&lt;/sup&gt;(Y) in V を定義する。これでAによる共変主表現ができた。反変ケースR&lt;sub&gt;A&lt;/sub&gt;も同様。

特定のAに対する（共変／反変）主表現を「きつい（tight）表現」と呼ぼう。Aを動かして考えるときは「ゆるい（loose）表現」。以下、ゆるい表現を構成する。まず、A |→ R&lt;sup&gt;A&lt;/sup&gt;は、C&lt;sup&gt;op&lt;/sup&gt;→[C, V] を定義する。[C, V]は、CからVへの関手圏（射は自然変換）である。なぜなら、k:A→Bがあったとき、R&lt;sup&gt;B&lt;/sup&gt;→R&lt;sup&gt;A&lt;/sup&gt;という表現間の変換κ:: R&lt;sup&gt;B&lt;/sup&gt;⇒R&lt;sup&gt;A&lt;/sup&gt; が定義できる。

κを具体的に記述すれば：
κ&lt;sub&gt;X&lt;/sub&gt; : C(B, X)→C(A, X) ; g |→ k;g in V

このκをR&lt;sup&gt;k&lt;/sup&gt;と書くと、R&lt;sup&gt;k&lt;/sup&gt;:: R&lt;sup&gt;B&lt;/sup&gt;⇒R&lt;sup&gt;A&lt;/sup&gt;； つまり、R&lt;sup&gt;*&lt;/sup&gt;は、対象→関手、射→自然変換の反変対応となる。R&lt;sup&gt;*&lt;/sup&gt;:C→[C&lt;sup&gt;op&lt;/sup&gt;, V] が、ゆるい反変表現となる。一点AにおけるR&lt;sup&gt;*&lt;/sup&gt;の“値”がきつい共変表現となる。[C&lt;sup&gt;op&lt;/sup&gt;, V]は、“C上のV層”だから、ゆるい表現はV層への埋め込みになっている（埋め込みであることは米田補題から）。

基礎項を使った反変表現がきつい反変表現（の典型例）を提供するから、基礎項を非基礎項まで拡張して、全部一緒に考えると、ゆるい共変表現＝（余）層表現が得られるだろう。

以上の事実（たぶん事実）を、構文論と意味論の構成に利用したいのだけど、なんかヒッカカリがあるんだよな、なんだろう？

*1151570602*[圏一般論]上江州ラムダ

上江州さんが使っていたラムダは、チャーチのラムダとは別で、関数抽象はしない。やることは：

+ 引数変数から名前を奪う。v→射をCの射にする。
+ 式（項）の射としての定義域をハッキリとさせる。

チャーチのラムダはデカルト閉圏でないと使えないが、上江州ラムダはデカルト圏で意味を持つ。いや、単なるモノイド圏でもOK。非対称なモノイド圏でさえ使えるだろう。とりあえず、Katyの形式化でウエス（上江州）ラムダを使おう。


</body>
</day>
<day date="2006-06-30" title="">
<body>
*1151632158*[形式言語理論][トレース／コンパクト閉圏]ウッギャーッ！！ テンプレートを忘れてた

もう、なにやっているんだぁーーー、俺はぁ。見つけたミッシングピースをまた置き忘れている。バッカじゃないの。

ソート付きプレイスホルダーを持つテンプレートとコンテキストを使うべし！使うべし！使うべし！

非終端記号という&lt;em&gt;変な概念&lt;/em&gt;にまっとうな定式化を与える。ソート付き変数をプレイスホルダーだと定義して：

- すべての変数名が違うときはソートだけを指定すればいい。
- あるいは、出現場所が変数名の代わりをすると考える。
- 同じ変数名であることは、何か特別な方法で指定する。
- 変数名を番号として、1から順に使う約束をする。

などで、従来の非終端記号をエミュレートできる。&lt;span style=&quot;font-weight:bold;&quot;&gt;←少しウソ入っている。&lt;/span&gt;

テンプレート（テンプレートインスタンス）とは、ソート付き変数を含む項に過ぎないが、「テンプレート」とか「フォーム」と言い換えると言語理論的な解釈がしやすくなる。そして、&lt;em&gt;コンテキストがKleisli射と解釈できる。テンプレート置換がKleisli結合になる。&lt;/em&gt;

おっと、定義； Xをソート付き変数集合として、指標Σのテンプレート・インスタンスの集合TI&lt;sub&gt;Σ&lt;/sub&gt;(X)は、事実上変数を含む項集合に過ぎない。その例は、線形文形式（linear sentential form; 右端だけにプレイスホルダーがある列）。TI&lt;sub&gt;Σ&lt;/sub&gt;はモナドになる、そのKleisli射が重要。

TI&lt;sub&gt;Σ&lt;/sub&gt;のKleisli射は、単純な文法（テンプレート文法／パターン文法と呼ぶといいかも）でもあり、図式化すると構文図になる。図式（グラフ）的にトレースをいれて、トレース付き圏にできる。さらに、木下のベキ圏構成を使えば“言語の圏”ができる。以上の構成以外に、Pow(TI&lt;sub&gt;Σ&lt;/sub&gt;(-)) というモナドを作って、これのKleisli圏を作る方法もあるが、２つの構成は一致するはずだ。

これらの概念で、構文図、境界付き有向グラフが実はテンプレート・コンテキスト＝Kleisli射であることがわかり、ベキ構成（hom-setスタイル／モナドス・タイル）により、新しい圏ができる。新しい圏は、テンプレート言語圏と呼んでもよいだろう。ベキ構成を使っているので、テンプレート言語圏はorder-enrichedになっている。

つまり、テンプレート言語圏TLは、OrdやΩΟに対して“具象的”である。よって、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060629/1151565807&quot;&gt;具象表現の枠組み&lt;/a&gt;が適用できて、TLをTL上の具象（余）層で表現することができる。

一方で、テンプレート言語モナドと文法モナドのあいだに作用積が定義できて（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060510/1147248190&quot;&gt;重畳モナド構造&lt;/a&gt;）、Klesili圏がoverlapする現象が生じる。２つのKleisli圏のoverlapからindexed categoryが定義できて、その平坦化も定義できる。

基礎(ground)インスタンス／基礎言語は、テンプレートインスタンス／テンプレート言語のなかに埋め込める。よって、テンプレートインスタンスの圏とテンプレート言語の圏を考えれば十分。基礎(ground)が欲しいなら、空変数集合上で局所的な議論をすればよい。

境界付き有向グラフに極性を入れて考えれば、「正規言語のreverse問題」が解けるかもしれない。射f:A→Bに対して、f&lt;sup&gt;*&lt;/sup&gt;:B&lt;sup&gt;*&lt;/sup&gt;→A&lt;sup&gt;*&lt;/sup&gt;が定義できればいい。偏極アルファベット上のタプルをプレイスノードとするペトリネットを考えればいいような気がする。トランジションノードが射だ。双対は、プレイスノードの極性反転とトランジションンの逆転ができればいい。生成規則と遷移規則が、ある種の双対になっている理由も説明できるかもしれない。

とにかく、とにかく、とにかく、非終端記号をまっとうな定式化に置き換えて、テンプレートインスタンスを境界付きグラフ（ペトリネット）で表現し、ベキ構成をマジメに考えよう。

*1151632333*[形式言語理論][トレース／コンパクト閉圏]ペトリ記法

グラフをペトリネットで描くべきだが、普通のペトリネットとノードの描き方が逆になる。

- 遷移ノード： 円や四角
- プレイスノード： 黒点や短い棒

遷移ノードは、有向ハイパー辺といってもいい。ペトリネットの意味での“辺”＝ワイヤーはラベリングされないが、遷移ノード＝ハイパー辺はラベリングされる。境界はプレイスノードとなる。

プレイスノードにバッファリング（キューイング）機能を入れることができる。この場合、プレイスノードにリスト構造データを割り当てることができる。他に、プレイスノードにはさまざまな量（データ）を割り当て可能。プレイスにデータ領域を対応させて、デカルト圏への反変表現ができる。

*1151632470*[その他代数]Conway代数とKleene代数

今日は本編お休みにしよう。もう、エネルギー使ったから。

Conway代数とKleene代数は、同じ指標（semiringの指標 + star）の上で定義される。Conway代数はベキ等を仮定しなくてもいいし、完全に等式的に定義される。一方、Kleene代数の公理からConway代数の公理がでるので、Kleene代数 → Conway代数 の関手を構成できる（おおよそ Kleene⊆Conway）。

Kleene代数の順序は等式的だが、そうはいっても順序だろうよ、アレは。それに、等式的に定義できず、Horn式になる。つまり、Conway代数は純代数的だが、Kleene代数は&lt;strong&gt;順序的&lt;/strong&gt;なのだ。

ω条件を満たすISRはKleene代数だが、逆は成立しない。つまり、ωISR → Kleene代数 の関手は構成できるが、逆向きの関手は構成できない。ωISRは可算列だの極限だのと言うので&lt;strong&gt;解析的&lt;/strong&gt;。

つまり、解析的な対象から順序的対象を作り出せる、順序的対象から代数的対象を作り出せる。が、逆向きの構成はうまくいかない。

トレース付き双デカルト圏は代数的な条件だから、これからConway不動点が出てくるのは当たり前だといえる。しかし、Kleene圏にはならない。圏になんらかのω条件を付けるのは、解析的な議論を許すことになる。となると、ω条件を持ったトレース付き双デカルト圏がKleene圏になるのも当たり前だな。まー、ものごとが自明にみえるのは、それはそれでいいとするか。

こう考えると、Kleene圏がConway圏であることは、「順序→代数」の意味でも当然だし、「双デカルト → デカルト」の意味でも当然になるな。オモシロイのだかツマラナイのだか、わかんなくなってきた。

*1151637344*[形式言語理論][DFD]状態遷移とは、時間たしあげと空間たしあげ

オートマトンによる列の認識を、列のカレント位置を示すカーソル（ニードル）があって、一方では状態空間のカレント位置を示すトークンがあって、カーソルとトークンが動き回る、というイメージで考えることがある。トークンを分割して複数にしてもいいなら非決定性というわけだ。

一見これは直観的でいいようだが、実は&lt;em&gt;全然ダメ&lt;/em&gt;だ。離散ステップ時間てのは、まーしょうがないとしよう。で、ステップごとにノードに蓄積される量（Kleene的加法量）が移動つうか再分配されるように思ったほうがいい。境界ノードで初期状態が定まるから、蓄積された量の配置（場の量かな？）が時々刻々変化していく、無限時間後の安定状態における境界値が問題だ。

そんなこんなで、マーク（Hopkins）は、ハミルトニアン＝時間発展演算子＝遷移規則とか言っているわけかな？ グラフに対する行列がハミルトニアン？  時間が無限に経過した後の状態を計算するのに、すべてのパスの寄与を足しあげてもいいわけかな、パスってのは時間による軌道でもあるわけだから。無限時間後には、すべての有限時間による寄与＝有限パスによる寄与が寄り集まるってことかな。

1ステップごとの全空間に渡る時間発展の時間方向足しあげ（Kleene級数）と、すべてのパスに対するパス空間での空間的足しあげが同じ値か。で、パス空間はhom-setで与えられる。フロイド／ウォーシャル（Floyd-Warshall）法（http://boole.stanford.edu/pub/am4.pdf）の根拠はこんなところか？？

それはそうと、グラフ（ペトリネット）上の生成規則ノード（generator）gを言語を入出力とする関数と考えて、その双対である認識（遷移）規則ノードをrとすれば、y⊆g(x) ⇔ x⊆r(y) となる。gのいる世界Gとrのいる世界Rを全然別だと考えて、r側では包含も逆転すると考えると、 y⊆g(x) in G ⇔ r(y)⊆x in R、これは G(y, g(x)) ≒ R(r(y), x) という形なので、随伴つうかガロア・コネクションつうか、になってはいる。意味あるかどうかわからんが。



</body>
</day>
<day date="2006-07-01" title="">
<body>
*1151737708*[形式言語理論][トレース／コンパクト閉圏]列言語の場合でも謎だナゾだ

列言語の場合でさえ、決して簡単ではない。いや、予想外に&lt;em&gt;難しい&lt;/em&gt;。

まず、アルファベットΣは、単ソート指標と考える。単ソートだから、ソート列の集合は0, 1, 2, ... でエンコードできる。ストレート、クロス、対角（重複）、放電のジャンクションがあれば、[n] = {1, ..., n}としての[n]→[m]の写像はジャンクションだけで反変に表現可能。[0]→[1]の関数が１つ存在するから、それの対応物を$と書いて、EndOfStringとして使う。Σに属する記号は、すべて1→1だとみなす。このタイプの指標を&lt;strong&gt;単ソート単純指標&lt;/strong&gt;（single-sorted simple signature）と呼ぼう。有限集合と単純単ソート指標は1対1に対応する。

対象を自然数として、Σで生成されるトレース付きデカルト圏（トレース付きGSモノイド圏というべきか；Circ(GS(Σ))である）は、変数（非終端記号）なしの構文図の圏となる。コラディニ／ガダッチに敬意を払って、この圏をTrGS(Σ)と書こう。双対（反対）圏も同じくトレース付き余GSモノイダルになる。

TrGS(Σ)に「モノイド単位によるtightな主表現＋ベキ構成」を行うと、列言語行列の圏ができる、これをL[Σ]と書くことにする。L[Σ](n, m)は、n→mの射で、（書き方の流儀によるが）m行n列の行列になる。ベキ構成により、余対角∇と零が生じて、L[Σ]は双デカルト圏になり、ベキ集合がω条件を満たすことからKleene圏であることが示せる。

ここまでは、ある意味単純だし、でてくる演算も結合、モノイド積、トレースに限られる。Conway不動点やKleeneスターもトレースから組み立てられる。構文図の圏TrGS(Σ)から、L[Σ]を構成する部分は、モノイド単位によるSetへの主表現に、木下ベキ構成、またはPowerモナドKleisli構成を組み合わせればいいから、「トレース付きデカルト（または余デカルト）圏→トレース付き双デカルト圏→Kleene圏」という構成だといえる。

で、問題は何かというと、&lt;em&gt;Σを動かしたとき&lt;/em&gt;のことだ。Σは相変わらず単純単ソート指標だとして、いろいろな（実はすべての）単純単ソート指標を考える。Signを指標の圏だとする；とりあえず指標射は普通の写像。指標射ψ:Σ→Γに対して何が起きるか？ ψは置き換えだから、反変的にGS(Γ)→GS(Σ)の関手を引き起こす。引き起こされた関手ψ&lt;sup&gt;*&lt;/sup&gt;は、圏の圏GSMonCatの射である。つまり、Sign→GSMonCatという関手がある。

件のSign→GSMonCatは、圏から“圏の圏”への反変関手だからindexed categoryである。一方、Circ構成、 tight主表現（の像圏）、木下構成などはすべて“圏の圏”のあいだの関手なので、indexed categoryを定義する。例えば、Σ→L[Σ]はindexed categoryである。ψに対して、反変的に関手L[ψ]:L[Γ]→L[Σ]が定義できる。この関手はスカラーK(Γ) = L[Σ](1, 1)と、別なスカラーK(Σ)の対応で事実上決定されてしまう。行列の係数半環を取り替える（書き換える）ことになる。

余談だが、行列圏L[Σ]にも圏論的トレースが持ち上がり、ここで、普通の意味の「トレース」がやっと出てくる :-)

次に指標圏Signを拡張する。有限集合に限定せず、Sign=Setとして、さらにSign=Set上のモナドMを考えて、指標圏Sign（Setだが）を、MのKleisi圏にする。特に考えたいモナドはPow(Seq(-))という言語モナドだ。（言語モナドは、indexed category L[-]とは別物、L[Σ]はKleene半環係数の行列圏である。）言語モナドのKleisli圏の射は、言語割り当てになる。Kleisli射 σ:Γ→M(Σ) は、L[Γ]→L[Σ]の関手を引き起こす（実は、Kleisli圏の反対圏のほうが自然）。この点は以前と変わらず、行列の（係数ごとに）系統的書き換えとなる。

指標圏のKleisli圏（その反対圏のほうが直感的だが）を、いまXSignと置く。この状態では、XSignの指標射とL[Σ]の射である行列は別物に見える。だが、構文変数＝非終端記号を使うと、圏L[Σ]の対象類は|Set|に一致してしまい、行列は線形テンプレート言語モナドのKleisli射なので、指標射と区別がつきにくくなる。

実際のところ、指標射である言語割り当てと、線形文法（あるいは構文図）である行列を僕は区別してなかった。これはいったいどうしたことか？ 区別してない（&lt;em&gt;区別できてない&lt;/em&gt;）のに、何で今まで計算がうまくいっていたのだろう／実はうまくいってなかったのか？ &lt;em&gt;ここが謎。&lt;/em&gt;

Σを固定したL[Σ]でさえ、単なるモノイド圏ではなくて、hom-set L[Σ](n, m)内に順序があるので、モノイド二圏（特殊な三圏）になっている。さらに、σ:Γ→Σによって、L[Σ]をL[σ(Γ)]に置き換えるような作用が存在する。これは、比喩的に言えば、奧から手前への次元での変換（矢印）である（結合が横方向、モノイド積が縦方向としての、第三の次元）。

行列ベースで考えるとして、X→Yの行列集合はMat[Σ;X, Y]のように書くべきなのだろう。Σも一種の入力パラメータと考えると、Mat[Σ, X→Y]のように書けなくもないが、Σに関しては線形ではなくなるから行列計算はできない。二種類の入力があると考え、Mat[A, X→Y]のような2引数で、パラメータXに実引数を渡しても、Aに渡してもいいというハナシはある。が、AとXを区別なしでM[A×X→Y]とみていいかどうかは不明。構文図で考えれば、AとXは全然別物（プレイスノードとトランジション・ノード）なんだけど、、、

- Xへの入力は、&lt;strong&gt;ワイヤーをつなぐこと -- Connect&lt;/strong&gt;
- Aへの入力は、&lt;strong&gt;ボックスを置き換えること -- Substitute&lt;/strong&gt;

ひょっとして、connectionはsubstitutionで代用（エミュレート）できるから、connectionによる圏をsubstitutionによる圏に埋め込めるって構造なのかな？ いずれにしても graph connectionとgraph substitutionを&lt;em&gt;区別しよう！&lt;/em&gt;

幾何学的には、gluingとdeformation（爆発とかも含める）の違いかな。なんだかヨクワカンナイ。

とにかく、僕はconnectionとsubstitutionの区別が付いてなくて、substitutionをconnectionのように考えていた。Mat[A, 0→B]を、Hom(A, B)として圏を作っていたって状況だろうか。やっぱり、線形テンプレートって概念が抜け落ちていたのが痛い。&lt;em&gt;考え直そう。&lt;/em&gt;

結局僕は、&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;元祖BNF（線形文法）も正規表現もろくにわかってない&lt;/strong&gt;&lt;/span&gt;ってことだなぁ。
</body>
</day>
<day date="2006-07-02" title="">
<body>
*1151833180*[形式言語理論][トレース／コンパクト閉圏]リカバる -- 考え直す
&gt;&gt;
結局僕は、元祖BNF（線形文法）も正規表現もろくにわかってないってことだなぁ。
&lt;&lt;

まーまー、&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;落ち着け、落ち着け。&lt;/strong&gt;&lt;/span&gt;

破綻している&lt;strong&gt;わけではない。&lt;/strong&gt;なにから何までうまくいってない、って&lt;strong&gt;わけではない。&lt;/strong&gt;いやむしろ、けっこううまくいっているのだ。今まで調べて事情がわかっている素材を使おう。

+ 絵算、ハイパーグラフ（ペトリネット）表現
+ ウエス（上江州）計算、特に&lt;em&gt;変数を圏にアタッチする&lt;/em&gt;手法、v→射。
+ Kleene圏、Conway（Elgot）圏、Kozen圏などの相互関係
+ Free*Cat関手と忘却関手の随伴、対応するモナド
+ ソート付き（あるいは、Kozenの意味で型付き）正規表現
+ 指標Σに対してFunctor(Σ&lt;sup&gt;~&lt;/sup&gt;, C)がCモデルの圏であること。

&lt;h5&gt;KとLを区別しよう&lt;/h5&gt;

指標（アルファベット）Σの言語圏を、太字を使って&lt;b&gt;L&lt;/b&gt;[Σ]と書く。
&lt;b&gt;L&lt;/b&gt;[Σ]は行列圏でああり、&lt;b&gt;L&lt;/b&gt;[Σ](n, m)がhom-setとなる。係数半環Kは、K=&lt;b&gt;L&lt;/b&gt;[Σ](1, 1)で与えられる。

Aを単なる集合（指標とは思わない）だとして、Aから作った正規列言語全体をL(A)、Aから自由生成したKleene半環をK(A)とする。L(A)とK(A)は、集合として同型だが、別物だ。集合としての同型を過剰に受け止めてはならない。L(A)とK(A)は構造的には&lt;strong&gt;まったく別物だ。&lt;/strong&gt; Aを指標だと思ったものをΣとすると；K(A)≒&lt;b&gt;L&lt;/b&gt;[Σ](1, 1) とはなる。

&lt;h5&gt;回路で考えよう&lt;/h5&gt;

回路は、入力ポートセットX、出力ポートセットYを持つ。これとは別に、記号素子を含むとすると、その記号素子を実素子や他の回路図で置き換える操作がある。置き換え可能な記号の集合をΣとすると、この回路は Σ, X→Y のようなプロファイルを持つ。Σに対する素子ライブラリ（記号達Σに、実素子や回路が対応している）があれば、置き換えができる。置き換えた後に含まれる記号群はΓとなる（Γが空かもしれない）。

以上の議論で、X, Yの端子（ポート）は識別可能だが、本来名前は持たない。ポートセットに名前を持たせてしまうのが、ウエス計算における変数集合のアタッチだ。このアタッチのテクニックをウエス・トリックと呼んでおく。今まで計算がうまくいってしまったのは、ウエス・トリックが働いていたからだ。

ウエス・トリックでは、名前を持たない端子達X, Yに、Γ、Δという名前をアタッチする。その結果、Σ, X→Yが、Σ, Γ→Δ となり、端子のconnectionがsubstitutionで実行できてしまう。特にXが始対象のときは、Σ→Δとなり、端子のconnectionが忘れられてしまう。

本来、回路のconnectionと、記号に対するライブラリによるsubstitutionは別な操作だったのに、ウエス・トリックにより、回路がライブラリになって、操作がすべてsubsitutionになってしまう。まさにトリックなのだ。

&lt;h5&gt;指標圏がクセモノだ&lt;/h5&gt;

指標圏は最初から二圏だと思わないといけない。0セルは端子（ポート）の集合、1セルは記号素子だ。指標Σ:X→Yは、二部ハイパーグラフ、または境界付きグラフだと思えばよい。この段階で既に、モノイド圏になる。1セルの結合はconnection、またはgluingで与えられる。

&lt;em&gt;問題は2セル&lt;/em&gt;なのだ！ X, Yが端子集合だとして、Σ, Γ∈Sign(X, Y)に対して、f::Σ⇒Γ:X→Y が通常はKleisli射で与えられる。最初のステップとしては、基本的な指標射によって、圏Sign(X, Y)を構成する。圏Sign(X, Y)に対して、モナド（自由生成モナドFree*Cat(-)）F&lt;sub&gt;X,Y&lt;/sub&gt;が決まる。結局、（拡張された）指標射は、f:Σ→F&lt;sub&gt;X,Y&lt;/sub&gt;(Γ) in Sign(X, Y)という形をしている。必要がなければ、Fの添字は落とすことにする（実際、Fは大域的に、Sign全体で一挙に定義されることが多い）。

ambient category Cを選ぶと、Model(Σ) = Functor(F(Σ), C)となる。Σ:X→Y、Γ:Y→Zのとき、Model(Σ;Γ)がどう記述されるか？ それはこれから考える。

&lt;h5&gt;変数とウエス・アタッチメント&lt;/h5&gt;

指標を境界付きグラフだと思い、ウエス・トリックについて考えてみると、項モナドTerm&lt;sub&gt;Σ&lt;/sub&gt;(X)に対する新しい定式化／見方が出てくる。

ソート付き変数集合X→Sというのは、実は、対象しかない離散圏Sに対してXをウエス・アタッチすることだと言える。x∈Xに対してsort(x)=s∈Sならば、xとsを同型射で繋ぐことがウエス・アタッチだ。ウエス・アタッチで作られたグラフ（X+Sがノード）は圏とみなせる。つまり、ソート付き変数集合は圏なのだ。

ソートがSである指標Σがあると、Sソート付き変数集合とΣはSで貼り合わせて融合和を作れる。融合和であるグラフΣ∪&lt;sub&gt;S&lt;/sub&gt;Xから作られた自由圏は、最初からウエス構造（変数がアタッチされていること）を持つ。この圏は、ソート付けX→Sによる写像柱をΣにくっつけた形をしている。

上のようにして作った圏（Dとする）は、XとSを対象に含み、Σを部分グラフに含む。この圏Dのなかで、XまたはXから生成された対象から、部分圏Cの対象（S）に至る射を、X-項と呼び、その全体をTerm&lt;sub&gt;Σ&lt;/sub&gt;(X)と書く。

&lt;h5&gt;ウエス・アタッチメントの応用&lt;/h5&gt;

ウエス・アタッチメントは、いろいろと応用がある。変数（離散圏）ではなくて、２つの圏（またはグラフ）を写像柱のソリッドパイプで繋ぐことができる。

境界付きグラフ達がコボルディズムlikeな圏を作るのだが、実は、圏の圏もコボルディズム圏なのではないか？ 境界付き圏を考えると、圏のgluingが考えられる。境界を固定する関手が2セルを与える。自然変換は3セルだから、三圏の例となる。

- 0セル -- 離散圏
- 1セル -- 境界付き圏
- 2セル -- 関手
- 3セル -- 自然変換

&lt;h5&gt;話を戻すと&lt;/h5&gt;

言語理論を圏論的に扱うなら、自由圏、AbIM enrichment、ω-AbIM enrichmentなどが鍵になる。

注意すべきは、無意識のうちに指標やdenotationが変わっていたり、番号と変数が入れ替わっていたり、connectionがsubstitutionになっていたり、と、知らぬ間にドンドン状況が変わってしまうことだ。状況を整理したり、パラメータを固定しないと、ほんとに混乱する。


</body>
</day>
<day date="2006-07-03" title="">
<body>
*1151886025*[トレース／コンパクト閉圏]整理、整理。メモ、メモ。

次のアナロジーがある。

|* レベル |* 圏 |* 図形 |
|0     |離散圏| n次元複体 |
|1     |境界付き圏| (n+1)次元境界付き複体 |
|2     |関手| 写像 |
|3     |自然変換| ホモトピー |

ウエス・トリックで写像柱が出てくる。錐体構成、ループ空間なども出てくるときがある。ソリッドパイプによる結合は、なんか名前があった（ナントカ和）、ハンドル体（取っ手）もよく使うテクニック。ハンドル体を付けることはトレースにソックリだし。圏論とホモトピー的幾何の類似は本質的のようだ。

有向完全二部グラフの両端を一致させると完全グラフになる。これはけっこうトレースの本質を表している。

Pが射影行列、Iが埋め込みを表す行列、Tがトランジションを表す行列として、(P, I, T）の3つ組をオートマトンとみなすことがある。そして、行列PT&lt;sup&gt;*&lt;/sup&gt;I をオートマトンの振る舞いとみなす。振る舞い行列は、適当な半ベクトル空間の写像となる。振る舞いを作る操作は、行列の直和圏でトレースだ。

行列のテンソル積圏でのトレースがホンモノ（?）のトレースだ。これは、Streetなどがペンローズ計算の合理化でやっていたと思うが、手元に資料がない。

*1151931297*[形式言語理論][トレース／コンパクト閉圏]自由構成

自由構成（クリーネ圏、コォゼン圏含む）：

|* モノイド     |* 圏               |* デカルト圏 |
|アルファベットΣ|単純多ソート指標Σ|多ソート指標Σ|
|自由モノイドΣ&lt;sup&gt;*&lt;/sup&gt;|自由圏Σ&lt;sup&gt;~&lt;/sup&gt;|自由デカルト圏Σ&lt;sup&gt;~×&lt;/sup&gt;|
|ベキモノイドPow(Σ&lt;sup&gt;*&lt;/sup&gt;)|ベキ圏PowCat(Σ&lt;sup&gt;~&lt;/sup&gt;)|ベキデカルト圏PowCCat(Σ&lt;sup&gt;~×&lt;/sup&gt;)|
|Kleene半環K(Σ)|Kleene圏KC(Σ) |Conway圏ConwC(Σ)|
|正規表現 |ソート付き正規表現| - (うれしくない)|

*1151931298*[山勘]圏のトレース（ルーピング）

繰り返しだが； 重み／ラベル付き二部グラフと半環係数の行列は同じものだと考えていい。二部グラフの両端を重ねてグラフやオートマトンが作れる。もとの正方行列は隣接行列や遷移行列に他ならない。始状態は入射行列、終状態は射影行列で表現される。入射I、遷移S、射影Pの組(I, S, P)でオーマトンを表現すると、振る舞いはI;S*;P = PS*I となる（「;」は図式順結合）。絵で描くと：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/transition-graph.gif&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/transition-matrix.gif&quot;&gt;
&lt;/div&gt;

(I, S, P)と(J, T, Q)があるとき、これらの結合を直接的に書き下すには、直和S+Tとトレース記法を使う必要がある。だが、振る舞いはI;S*;P;J;T*;Qで与えられるので、非常に単純化される。これが振る舞いを考える大きな理由だろう。

構文図式、オートマトンの例を山勘で一般化すると、こんな感じ：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/category-with-boundaries.gif&quot;&gt;
&lt;/div&gt;

入り口Xから入った経路は、圏Cのなかを走ってから出口Yに至る。境界付き圏。

特殊ケースとして、ウエス・アタッチメントがある：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/attached-category.gif&quot;&gt;
&lt;/div&gt;

変数集合Vの有限集合の全体Xが入り口であり出口である。変数を含んで変数に出力する式（射）を問題にすれば、出入り口（変数集合の集合）をウエス・アタッチメントして、そこをスタート・エンドとする射だけを考えることになる。実際には、出入り口に関してトレース（ルーピング）しているのだけど、出入り口断面を基点とする経路（射）だけを考える。アタッチしてトレースして、対象を断面に制限（部分圏を考える）している。

もっと一般的な状況：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/path-in-a-category.gif&quot;&gt;
&lt;/div&gt;


</body>
</day>
<day date="2006-07-04" title="">
<body>
*1151987338*[形式言語理論][トレース／コンパクト閉圏][説明]半環の行列

半環係数の行列計算について説明するなら：

+ 二部グラフによる行列計算 -- &lt;b&gt;N&lt;/b&gt;, ブール値, max-plus（polar）代数
+ パスの積和公式  -- max-plus代数では
+ 推移的閉包、そのとき A*(i, j)の意味
+ 生成規則の表現 そのとき A*(i, j)の意味 圏とhom-set解釈
+ GSモノイダル公理 例：Δ&lt;sub&gt;X+Y&lt;/sub&gt;=(Δ&lt;sub&gt;X&lt;/sub&gt;+Δ&lt;sub&gt;Y&lt;/sub&gt;);(X+σ+Y)
+ 行列の分解 &amp;lt;f, g&gt;, [f, g]
+ 生成規則の直列結合とOR結合
+ 行列の直和、結合（積）、トレース
+ トレースとKleeneスターの関係
+ トレース（ルーピング）付き行列圏での結合のスタック化公式


</body>
</day>
<day date="2006-07-05" title="">
<body>
*1152060191*[形式言語理論][トレース／コンパクト閉圏]オートマトンの行列表現

f:X→X、j:A→X、p:X→Bがあるとき：

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;[(A+Δ&lt;sub&gt;X&lt;/sub&gt;);(σ&lt;sub&gt;A,X&lt;/sub&gt;+X);(p+j+f);(B+∇&lt;sub&gt;X&lt;/sub&gt;)] = j;f&lt;sup&gt;*&lt;/sup&gt;;p

これは実用的。Trの被演算項がゴチャゴチャしているが、f, j, pの3つのブロックを合わせて（残りは零で埋めて）行列を作るだけの操作。三項演算として、(j ? f ! p) とでも書きたいところだ。

絵算で示せるが、そのとき、「交差＋巻き込み（取り囲み）」を取り除く操作が出てくるが、これはしょっちゅう使う、定番だ。

*1152068961*[課題][トレース／コンパクト閉圏]さまざまな構造と圏の関係

まず、&lt;strong&gt;クリーネ圏（Kleene圏）&lt;/strong&gt;という用語は定着まではしてないが安定した定義があるからソレデヨイとしよう。（[http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715173:title]）
- Kleene圏は本質的に順序的である（定義の上では等式的でも）。
- 定義に、条件式（Horn式）が入る。
- 任意の圏のベキ圏がKleene圏になる。したがって、対象類に関して特に制限はない。
- Kleene代数は単一対象のKleene圏である。

以前（[http://d.hatena.ne.jp/m-hiyama-memo/20060619/1150676276:title]）、トレース付き・ベキ等・双デカルト・対称モノイド圏をコォゼン圏（Kozen圏）と定義したが、むしろ、&lt;em&gt;双積を持つKleene圏をKozen圏と呼ぶべき&lt;/em&gt;だという気もする。行列計算ができるKleene圏という感じ。さて：

+ Kleene圏が直積を持てば、それは双積か？
+ 双積を持つKleene圏は、Δ;∇=1 という意味でベキ等か？
+ 圏の意味での零射は、home-setの最小元と一致するか？
+ 双積から定義される和は、home-setの和と一致するか？

*1152085556*[雑記]ベキックとガウス

えっ、なんだって？！ ベキックの不動点公式はガウスの消去法だと？

*1152086189*[リンク]Esik; The Equational Theory of Fixed Points with ...

最近、Zoltan Esik（[http://d.hatena.ne.jp/m-hiyama-memo/20060613/1150188663:title]）ばっかし読んでいるような。

- http://www.brics.dk/RS/01/22/BRICS-RS-01-22.pdf : The Equational Theory of Fixed Points with Applications to Generalized Language Theory


</body>
</day>
<day date="2006-07-06" title="">
<body>
*1152149521*[雑記]ロゴを作ったぞー、traced monoidal category

これは、トレース付きモノイド圏（traced monoidal categories）のロゴです。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/TMC-logo.gif&quot; &gt;
&lt;/div&gt;

直線が傾いているとか、下側のマルがもう少し大きいほうがいいとか、デザイン上の問題はあるけども、図形としてはコレだよ、やっぱり。

イメージは線形なトレース付きモノイド圏、上の直線が直接計算、下がloopingを表現している。&lt;span style=&quot;font-size:large;&quot;&gt;いいねー、&lt;/span&gt;ロゴがあると盛り上がるね（なにが？）。

[追記]下側はマンマル（真円）がいいかな？[/追記]

*1152164791*[形式言語理論][トレース／コンパクト閉圏]コォゼン圏（Kozen圏） 再び

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060706/1152149521&quot;&gt;ロゴもできた（？）&lt;/a&gt;ことだし、トレース付きモノイド圏を形式言語理論に使うヤツをさくさく進めよう（と言って進むもんじゃねー）。

それで、やっぱり、双積を持つクリーネ圏（Kleene圏）を&lt;strong&gt;Kozen圏&lt;/strong&gt;と呼ぶことにした。この双積は、圏論的な直積かつ直和（余直積）がいいのか、それとも、GSモノイダルとその双対を満たすようなモノイド積がいいのか？ 僕はどっちでもいいのだけど、その差を明らかにすべきだとは思う。圏論的双積⇒GSモノイダル は当たり前だから、問題はその逆。GSモノイダルだけで双積はでないが、Kleene条件があればどうか？

Kozen圏は実に計算しやすい。これは要するに線形システムの圏なのだろう。線形だから行列表示もできるわけだが、トレースで扱いやすくするなら、4ブロックに切り分けるのが&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;吉&lt;/strong&gt;&lt;/span&gt;。F:k→m, I:k→n, S:n→n, P:n→m として、[F, P;I, S]:k+n→m+n を考える。Iが入射、Pが射影が典型的だが、実は何でもいい。

[F, P;I, S]をnに対してトレースすれば、その振る舞いは F+PS*I（S*はKleeneスター）で与えられる。その他の計算イロイロもETB（回路）図と行列に翻訳できる。この翻訳結果は&lt;span style=&quot;font-size:large;&quot;&gt;&lt;strong&gt;驚くほど初等的で自明&lt;/strong&gt;&lt;/span&gt;だ。

*1152177847*[XML]XML構造

[http://d.hatena.ne.jp/m-hiyama-memo/20060627/1151380173:title]で絵を描いた「XML構造」の定義を与えておく。

構文構成素に次がある。

+ 文字
+ 名前
+ 文字列
+ 属性（の集まり）
+ タグ
+ 内容
+ 要素

それぞれの構成素をすべて集めた集合を（構文的）&lt;strong&gt;インスタンス領域&lt;/strong&gt;と呼ぶ。インスタンス領域の部分集合を&lt;em&gt;行きがかり上&lt;/em&gt;&lt;strong&gt;型&lt;/strong&gt;と呼ぶ。型の全体は&lt;strong&gt;型領域&lt;/strong&gt;。

順序付き多ソート指標Σに対する割り当てが：

- ソート記号にインスタンス領域か型領域が割り当ててある。
- ソート順序は、領域間の埋め込みが割り当ててある。

このとき、Σと割り当ての組を&lt;strong&gt;XML構造&lt;/strong&gt;と呼ぶ。典型的なXML構造を具体的に与えることと、いろいろなXML構造を同時に考える問題がある。


</body>
</day>
<day date="2006-07-07" title="">
<body>
*1152239473*[雑記][リンク]えっ？！ UMLがぁ？

- [google:&quot;compact closed category&quot; INT]

この検索結果は楽しいよ。で：

- http://www.cs.sunysb.edu/~grosu/bsbs99.pdf

いやーーー、ビックリしたー！ UML-RTの図が、traced monoidal/compact closed categoriesそのものだってサ。著者にステファネスク（[http://d.hatena.ne.jp/m-hiyama-memo/20060405/1144220979:title]）も入っているし。

*1152260973*[課題]いろいろ

+ sum-star, product-star等式を満たすConway半環と、Esikが言っているConway代数（μを使って表現される不動点を持つ代数）はどういう関係がある？
+ Kozenのmatrix-star等式は、Conway半環／Conway代数とどう関係する？
+ Bekicの公式がガウス消去法ってのは、どういうこと？
+ Kozen圏にInt構成(GoI構成）するとどうなる？
+ GSモノイダル性とデカルト性の関係は？
+ 呼び出しがキューイングされない状況では、コンポネントのトレースは困難なのか？
+ いろいろな半環について、それをスカラーとするKozen圏を作ったらどうなる？
+ ベクトル空間が対象、テンソル積の圏におけるトレース（元祖トレース）の計算。

</body>
</day>
<day date="2006-07-10" title="">
<body>
*1152491516*[リンク]本：Elgotがらみ

- Calvin C. Elgot: Selected Papers (ハードカバー) http://www.amazon.co.jp/exec/obidos/ASIN/3540563784/303-9204520-3937814
- Iteration Theories (EATCS Monographs in Theoretical Computer Science S.) (ハードカバー)  http://www.amazon.co.jp/exec/obidos/ASIN/0387906983/250-2925753-9543409

高いなぁ。Iteration Theoriesはよく引き合いに出される。Conwayの本が手に入らないようだから、コレしかないのかもしれない。

*1152491517*[リンク]検索：Elgotがらみ

- [google:Elgot iteration monad category]

*1152491759*[トレース／コンパクト閉圏]Cospan(C)はself-dualコンパクト閉圏

Cが有限余完備のとき、Cospan(C)はself-dualコンパクト閉圏になる。self-dualとは、dualizerがidentity-on-objectsなこと。さらにCospan(C)は、well-supportedというすごく強い性質を持つらしい。

Int構成とどんな関係がある（あるいはない）のだろう？

</body>
</day>
<day date="2006-07-11" title="">
<body>
*1152599185*[リンク][トレース／コンパクト閉圏]園児の量子力学！ ですかぁ

ワッハー、これはスゲー。

- Kindergarten Quantum Mechanics →http://web.comlab.ox.ac.uk/oucl/work/bob.coecke/VaxjoProc.pdf

アブラムスキーと一緒に、Categorical Quantum Mechanicsを作っているBob Coeckeの最近のlecture notes。

僕も[http://www.chimaira.org/docs/PictorialCategoryTheory.htm:title]という記事を書いたが、Coeckeのlecture notesは、それを数千倍グレードアップしたようなもんだ。

檜山：
&gt;&gt;
コンパクト閉圏は本質的にやさしいものなのだ。小学3、4年生なら、計算のルールを理解できるし、実際の計算も遂行できるだろう。その計算とは、「図形ゲームに過ぎない」のだから。
&lt;&lt;

Coecke:
&gt;&gt;
The whole point about these notes is the graphical calculus which could be taught in kindergarten.
&lt;&lt;

小学生じゃなくて&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;幼稚園児&lt;/strong&gt;&lt;/span&gt;ですか、そうですか。絵もきれいに描かれているので、これなら確かに子供が喜びそうな感じだ。

絵に関する工夫で感心したのは（でも僕は使わないだろうが）、射を&lt;strong&gt;下から上に&lt;/strong&gt;描いているところ。Y座標が下から上だからさほどに不自然ではない。それでいて、上から下に読み下すと逆diagrammatic order（古典記法）になる。Coeckeが古典記法にこだわるのは、ディラックのブラケット記法と整合させるため。v;fを、f・v = f|v&gt; と書きたいわけ。|v&gt;（ケット）は下がとがった三角形で描くことになる。

ひとつ、&lt;em&gt;どうもゲセネー&lt;/em&gt;のは、ヤンキングだけが公理だと言っているのだが、ヤンキング→ジグザグ恒等式のところで、η&lt;sub&gt;A*&lt;/sub&gt; = η&lt;sub&gt;A&lt;/sub&gt;;σ&lt;sub&gt;A,A*&lt;/sub&gt;（ねじり公式）を使っていると思うんだけど、ねじりがヤンキングから出るとは思えないのだけど、、、Samson Abramsky の&quot;Abstract Scalars, Loops, and Free Traced and Strongly Compact Closed Categories&quot;（http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/calco05.pdf）を読んでみよう。


その他、これで探せる。

- [google:site:web.comlab.ox.ac.uk &quot;compact closed category&quot;]


</body>
</day>
<day date="2006-07-12" title="">
<body>
*1152682948*[プログラム意味論][トレース／コンパクト閉圏]セオリーと証明の圏

セオリーT⊆Sen(Σ)を対象として、“Tを前提としてS（S⊆Sen(Γ)）を帰結するような証明（図、ネット）”を射とする圏を考える。これはπインスティチューション、ないしはπインスティチューションからModを除いた構造の上で定義できる。この圏をProofとする。α∈Proof(S, T)とは、αが、SからTを導く証明のこと。

まず、Proofが直和で対称モノイド圏になることが欲しい。さらに、有限余完備であれば文句がない。内部セオリー（隠蔽セオリー、作業用セオリー）の概念を導入すれば、（あるいはCirc構成により）Proofをトレース付きモノイド圏にできるだろう。

もし、有限余完備性とトレース付きモノイド圏の両方が成立するなら、Proofからコンパクト閉圏を作る選択肢が2つある。

- Int(GoI)構成
- Cospan構成

この2つの構成を実行して結果を比較できる。

指標Σ、Γに対して適当なプログラミング言語モナドを使ってProg(Γ, Σ)を作れる。Proof(S, T)→Prog(Γ, Σ)という反変（変性はどうでもいいが）関手が定義できるだろう。すると、プログラムの正しさは：

- そのプログラムに対する証明が存在する：構文論的正しさ
- そのプログラムのモデルが存在する：意味論的正しさ

の二通りが定義できて、古典的な概念を再現できそうだ。ここでモデルとは、Mod(Σ)→Mod(Γ)という関手Fだが、FによるMod(S)の像がMod(T)に入るものが正しい（関手意味論、loose semantics）。健全性には、リンデンバウム構成の圏論版が使えるだろう。


*1152718450*[トレース／コンパクト閉圏][お絵描き]ねじり

ねじりがジグザグから出るのか？ まー、僕の見落としとか勘違いがあるかもしれないが、&lt;em&gt;ジグザグ⇒ねじり&lt;/em&gt;  がサッパリわかん。

左右のねじりを仮定するなら：

- ヤンキング ⇔ ジグザグ

がいえる。次の図、左右対称だから、Z字もS字もヤンキングから出る。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/yanking-to-zigzag.gif&quot; &gt;
&lt;/div&gt;

f:A→Bから双対f*:B*→A* を作る方法が二通り（左右対称）あるが、それらが同じであることもねじりが使えれば出る。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/dual-in-compactcc.gif&quot; &gt;
&lt;/div&gt;

最後に得られた形が左右対称だから、双対の定義も左右対称なわけだ。これを使うと、双対がinvolutiveであることは簡単に出る。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/dual-involutive.gif&quot; &gt;
&lt;/div&gt;

双対が反変的であることも出る。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/dual-contravariance.gif&quot; &gt;
&lt;/div&gt;

他に必要なことも、ねじりがあれば出ると思う。結局、&lt;em&gt;ねじりが問題&lt;/em&gt;。もうメンドーだ、左右のねじり＋ヤンキングを当面は公理にしようかな。

</body>
</day>
<day date="2006-07-13" title="">
<body>
*1152782067*[トレース／コンパクト閉圏]モノイダル積とクロスケーブル

次は、(f + g)* = f* + g* を示したつもりだったが、実際はちょっと違っていた。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/dual-monoidal-prod.gif&quot; &gt;
&lt;/div&gt;

ちょっとの違いに関して、[http://www.chimaira.org/docs/DefiningCompactCC.htm:title] の記述：
&gt;&gt;
X* + Y* から X + Y へと、カーブしたワイヤーで繋ごうと思うと、ストレートワイヤーでは無理で、曲がりと共にねじりを入れる必要がある。つまり、ターニング・ジャンクションはリバース・ケーブルなのである
&lt;&lt;
&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/docs/bundling.gif&quot; &gt;
&lt;/div&gt;

それと、次はなんかに使えるかも。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/move-crossing.gif&quot; &gt;
&lt;/div&gt;


</body>
</day>
<day date="2006-07-14" title="">
<body>
*1152845428*[プログラム意味論][論理]仕様とプログラム証明の圏

少し前に[http://d.hatena.ne.jp/m-hiyama-memo/20060712/1152682948:title]というのを書いたし、随分以前に&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=PProof&quot;&gt;PProof&lt;/a&gt;を問題にしていた。

最近、仕様とプログラム証明の圏がやっとわかった気がする。この圏の対象は仕様(Σ, A)（A⊆Sen(Σ)）。射の定義が問題なのだ。射を定義するために、適当なプログラミング言語PLを固定して、そのプログラミング言語に関するプログラム証明の体系を作る。この体系を（PLに関する）&lt;strong&gt;プログラム論理&lt;/strong&gt;と呼ぶ。PLogをプログラム論理として、これを指標Σで拡張したものをPLog(Σ)とする。PLog(Σ)の文をPSen(Σ)とする。PSen(Σ)にはプログラミング言語PLの文（実行文）も埋め込まれている。

さて、(Σ, A)から(Γ, B)への射は、文（論理式）の集合の余スパンである。余スパンを構成する写像を左脚／右脚と呼ぶことにする。余スパンのボディはPSen(Σ)とする。Sen(Σ)→Psen(Σ)という埋め込みがある。これが左脚になる。文集合AのPSen(Σ)への埋め込み像も同じ記号Aで示す。

問題は右脚。プログラム形式（ソースコード）は、Γ→PTerm(Σ)というKleisli射を定義するが、これを使うと、指標Γの文を、指標Σとプログラミング言語PLが混ざったモノに変換できる。つまり、プログラム形式は、Sen(Γ)→PSen(Σ)を定義する。これを右脚に使う。

プログラム形式pが定義するSen(Γ)→PSen(Σ)をp*として、Bのp*による像をp*(B)と書く。PLog(Σ)は論理系だから、A⊆PSen(Σ), p*(B)⊆PSen(Σ)が与えられれば、その証明（が可能ならば、それ）が存在する。証明をαとする。αは、A|-p*(B) in PLog(Σ) を保証する。

で、いよいよ射の定義：(Σ, A)→(Γ, B)は、Γ→Σ（意味的には逆向きか）のプログラム形式pとPLog(Σ)のなかの証明αで定義される。その条件は：

- αにより、A |- p*(B) である。 

項モナドPTermや論理系PLogを定義するときに、パラメータとしてプログラミング言語を渡す。よって、仕様とプログラム証明の圏PProofは、プログラミング言語によってindexingされるだろう。

もう少し厳密に定義するには、&lt;strong&gt;論理系（証明系）の余スパンの構成&lt;/strong&gt;が必要になる。とりあえず、証明系はムーア閉包作用素を持った文集合で定義すればいいだろう。以前から余スパンが関係するとは思っていたから、これはいい方向への進展だろう。


</body>
</day>
<day date="2006-07-15" title="">
<body>
*1152971994*[圏一般論]ブレイド

論理やコンピューティングサイエンスの関係だと、対称モノイド圏はよく出てくるが、ブレイドモノイド圏（braided monoidal category）はあまり出てこないようだ。が、ちょっと調べておく。

まず、アルチン（Artin）によるブレイド群（braid group）の定式化。ストランド（紐、毛髪）の数をnとして、ストランドを1, 2, ..., nで番号付ける。iとi+1を入れ替える交差（他はストレートにつなぐ）をβiとして、次がアルチンのブレイド関係式（braid relations）：

+ j ≧ i + 2 ならば、βi・βj = βj・βi （隣じゃなければ無関係）
+ βi・βi+1・βi = βi+1・βi・βi+1 （お隣の交差のあいだの関係）

βiは次の図のようだが、βiとその逆βi&lt;sup&gt;-1&lt;/sup&gt;は入れ替えても何も変わらないので、どちらをβiと思ってもよい。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img/braid-base.gif&quot; &gt;
&lt;/div&gt;

左から右へのストランドが上に来る交差を基本として（それが僕の好み）考えると、アルチンのブレイド関係式は次の図になる。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img/braid-relation.gif&quot; &gt;
&lt;/div&gt;

図の描き方を少し変えてみると、ライデマイスター移動（Reidemeister moves）のひとつになる。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img/reidemeister-move.gif&quot; &gt;
&lt;/div&gt;

圏論的に定式化するため、σ&lt;sub&gt;A,B&lt;/sub&gt;:A+B → B+A を導入する。σの逆をσ'と書く。逆なのだから：

- σ&lt;sub&gt;A,B&lt;/sub&gt;;σ'&lt;sub&gt;B,A&lt;/sub&gt; = A+B
- σ'&lt;sub&gt;B,A&lt;/sub&gt;;σ&lt;sub&gt;A,B&lt;/sub&gt;; = B+A

ブレイド関係式は：

- (σ&lt;sub&gt;A,B&lt;/sub&gt; + C);(A + σ&lt;sub&gt;B,C&lt;/sub&gt;);(σ&lt;sub&gt;A,B&lt;/sub&gt; + C) = (A + σ&lt;sub&gt;B,C&lt;/sub&gt;);(σ&lt;sub&gt;A,B&lt;/sub&gt; + C);(A + σ&lt;sub&gt;B,C&lt;/sub&gt;)

ところで、ライデマイスター移動は3種あるのだが、1つ目はσとσ'が互いに逆であること、2つ目はアルチンのブレイド関係式になる。そして3つ目は、トレースのヤンキングになっている。ただし、Tr(σ&lt;sub&gt;A,A&lt;/sub&gt;) = A&lt;sup&gt;*&lt;/sup&gt; になっているようだ。トレースとはいっても、双対（逆向き）が必要なので、最初からコンパクト閉圏を考えることになる。コンパクト閉なブレイド圏は、物理がらみで別な呼び方があるようだ。

ブレイド圏だと、σを何度も続けると、お下げ髪のような編み込み紐ができる。これをほどくにはσ'をcomposeする必要がある。直感的はこれが自然で、対称ブレイディングは不自然な感じがする。まー、計算は簡単だからいいのだけど。

</body>
</day>
<day date="2006-07-16" title="">
<body>
*1153019640*[圏一般論][からみ系]ライデマイスター移動III

カウフマンの本を見ると、ライデマイスター移動に0から3の番号が付けられている。移動とコンパクト閉圏との関係は：

- 移動0 -- ジグザグ引き伸ばし
- 移動1（I） -- ヤンキング
- 移動2（II） -- σとσ'が逆であること
- 移動3（III） -- アルチンのブレイド関係式

移動IIIにはバリアントがあって、次のはバリアントのひとつ。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img/Reidemeister-move-III.gif&quot; &gt;
&lt;/div&gt;

2番のストランドが実質的に移動するのだが、2番が一番奥にある。他に、2番が一番手前に来るバージョンもある。


</body>
</day>
<day date="2006-07-17" title="">
<body>
*1153116253*[圏一般論][リンク]自由構成は重要だ

&quot;GENERIC COMMUTATIVE SEPARABLE ALGEBRAS AND COSPANS OF GRAPHS&quot;（http://www.tac.mta.ca/tac/volumes/15/6/15-06.pdf）とか、アブラムスキーの&quot;Abstract Scalars, Loops, and Free Traced and Strongly Compact Closed Categoris&quot;（http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/calco05.pdf、関連資料は[google:site:web.comlab.ox.ac.uk &quot;compact closed category&quot;]で探せる）とかを眺めるに、圏の自由構成が非常に大事なことがわかる。

圏に関するあるセオリー（形式的理論）TがあるときFreeCat[T](Σ)を（圏的な）指標Σから生成される自由T圏だとする。FreeCat(Σ) = FreeCat[](Σ)は単なるプレーンな自由圏とする。&lt;b&gt;1&lt;/b&gt;を自明な指標として：

- FreeCat(&lt;b&gt;1&lt;/b&gt;) = {1つの対象と恒等だけの圏}
- Mはモノイド圏論として、FreeCat[M](&lt;b&gt;1&lt;/b&gt;) = (&lt;b&gt;N&lt;/b&gt;, +, 0) 射は恒等だけ、離散的な可算圏。&lt;b&gt;1&lt;/b&gt;以外の指標では非可換積になる。
- SMは対称モノイド圏論として、FreeCat[SM](&lt;b&gt;1&lt;/b&gt;) = (&lt;b&gt;N&lt;/b&gt;, +, 0)に加えて、Hom(n, m) = if (n = m) S(n) else Empty （S(n)は対称群）となるgroupoid。
- BMはブレイドモノイド（braided monoidal）圏論として、FreeCat[BM](&lt;b&gt;1&lt;/b&gt;) = (&lt;b&gt;N&lt;/b&gt;, +, 0)に加えて、Hom(n, m) = if (n = m) B(n) else Empty （B(n)はブレイド群）となるgroupoid。
- SM-dはdischarger付き対称モノイド圏論として、FreeCat[SM-d](&lt;b&gt;1&lt;/b&gt;) = (&lt;b&gt;N&lt;/b&gt;, +, 0)に加えて、Hom(n, m) = {[m]から[n]への単射の圏}
- BM-dはdischarger付きブレイドモノイド圏論として、FreeCat[BM-d](&lt;b&gt;1&lt;/b&gt;) = (&lt;b&gt;N&lt;/b&gt;, +, 0)に加えて、Hom(n, m) = {n≧m で、射はストランドの途中消滅を許すブレイド}

セオリーTに対するT圏の圏をCAT[T]とすると、FreeCat[T](&lt;b&gt;1&lt;/b&gt;)はCAT[T]の始対象となる。

いろいろなTに関して関手FreeCat[T]:Sign→CAT[T] を&lt;strong&gt;具体的に&lt;/strong&gt;構成することは重要だし、いろいろと役に立つ。例えば、クリーネ圏（Kleene圏）、コンウェイ圏（Conway圏）、コンパクト閉ブレイド圏の自由構成など。

*1153116630*[プログラム意味論]Janusの図式法

最近、次のように考えている。

- 面（サイド、フェイス）の区別は、フロント面、バック面とする。通常、フロント→バックの向きに（奧に向かって）矢印を描く。
- 面への呼び出し線が入る場所にマイナス、出る場所にプラスの符号を与える。外側ではプラス→マイナスの向きで呼び出しが流れる。
- フロントマイナスのポートをリクエストポート、フロントプラスのポートをレスポンスポート
- バックプラスのポートをコマンドポート、バックマイナスのポートをイベントポート。
- 他にクエリーポートが両面にある。
- フロント面とバック面では、プラスマイナスを逆の位置に置く。フロントではプラスが上、バックではプラスが下。
- プラスマイナスより、インポート、アウトポートがいいかもしれない。
- 面ごとの指標は&amp;lt;A; B&gt;の形に書く。Aがプラス（イン）、Bがマイナス（アウト）。
- 同じ指標&amp;lt;A; B&gt;もフロントとバックでは解釈が変わる。フロントではAがプラス、バックではBがプラス。
- フロントでもバックでも、&amp;lt;A; B&gt;はAが上、Bが下になるように描く。
- &amp;lt;A; B&gt; → &amp;lt;B; A&gt;が双対（対蹠、包合）。
- &amp;lt;A; B&gt;+&amp;lt;C; D&gt; = &amp;lt;A, C; B, D&gt;がモノイド積。
- compositionではワイヤーの交差がない。
- 恒等は、上から上、下から下にスルーする矢印。内部での交差はない。

こういう方針を決めるのにエライ労力がかかる！！

</body>
</day>
<day date="2006-07-18" title="">
<body>
*1153215459*[トレース／コンパクト閉圏][用語法]図式法と用語法

普通の圏論、ETB図、Janus図での対応。

|*圏論    |* 型なしETB図 |* Janus図 |
|単純対象 |ポート       |単純指標|
|対象     |ポートセット（自然数）| 指標|
|対象の積（和）|並置（和）|指標の和|
|単位対象|空ポートセット（0）|空指標|
|射      |ボックス |ボックス |
|恒等射  |ストレートジャンクション|スルーボックス|
|結合（合成）|直列結合|対話的結合|
|射の積|ボックスの並置|ボックスの並置とワイヤ交差|
|対称|クロスジャンクション| ダブルクロスボックス|
|双対| - | 反転 |
|単位／余単位|ターニングジャンクション| エコーボックス|


</body>
</day>
<day date="2006-07-20" title="">
<body>
*1153368536*[トレース／コンパクト閉圏]Janusの指標の計算

Janusの図式法で、対象は指標になる。指標は、基本ソートの集合をΣ（アルファベット）として、A, B∈Σ*（Σの有限列）を使って&amp;lt;A; B&gt;と表現される。「ε」が空列、「・」が連接として：

- &amp;ltA; B&gt; + &amp;ltC; D&gt; = &amp;lt;A・C; B・D&gt;
- &amp;ltA; B&gt;* = &amp;lt;B; A&gt;

として、和（モノイド積）と反転（双対）を定義する。「＋」は可換ではないが結合的であり、&amp;ltε; ε&gt;が単位（モノイドになる）。反転に関しては：

- &amp;ltA; B&gt;** = &amp;lt;A; B&gt;
- (&amp;ltA; B&gt; + &amp;ltC ; D&gt;)* = &amp;lt;A; B&gt;* + &amp;ltC ; D&gt;*

こういう構造を「*(star) monoid」とか「involutive monoid」と呼んでもいいかもしれない。

*1153368740*[トレース／コンパクト閉圏][からみ系]対称群の作用、ビーズのネックレス、古代の絵心

絵算をしていると、モノイド積（図形的には並置）にブレイド群が作用しているのが自然に感じる。対称の基底である転置（入れ替え）は、ブレイドのアルチン基底（隣を入れ替えるフリップ）βとβ'（逆元）を同一視してできるけど、この同一視は、紐が互いにすり抜ける（幽霊みたいな）現象に対応する。この交差した紐の上下すり抜けを許す計算が「ブレイド群を対称群に退化させる」ことになっている。

ブレイドにしろ対称にしろ、インディオ（だかなんだか正確にはわからんが）の石とか木とかに穴を開けたビーズに紐を通して、さらに編み上げて作るネックレスみたいなイメージだ。両端を引っ張って伸ばすとか、輪にするとかの操作がブレイド／対称の計算、トレース計算になっている。

ペンローズのテンソル計算は「ヒエログリフ」と呼ばれるが、確かに何か原始的、原初的、あるいは呪術的な感じがする。僕は、古代の壁画のような図像がそもそも好きなんだよな。絵算をしていて楽しい感じがするのは、なんか原初的／太古の絵心を刺激されるせいかもしれない。

*1153375617*[トレース／コンパクト閉圏]strictly commutative monoidal category

モノイド圏がstrictly commutativeとは、X + Y = Y + X が等式の意味で成り立つこと。対象が自然数モノイドなら、strictry commutativeになる。

strictly commutativeだと対称（symmetry）も要らなくなり、計算はやたらに単純化される。しかし、単純化されるといいか、というとそうではない。ブレイドが対称に退化すると不自然な感じがするように、対称さえも退化すると、かえってワケワカラナクなる。僕が90年代にさんざん混乱していたのは、strictly commutativeな状況で考えていたから。

しかし現実には、条件（XとYが無共分、あるいは直行）を満たすときに限って和（モノイド積）が定義できて、可換になる状況が発生するので、これを定式化しないといけない気もする。


</body>
</day>
<day date="2006-07-25" title="">
<body>
*1153787427*[トレース／コンパクト閉圏]トレースの表記を少し拡張

f:A1+X+A2→B1+X+B2に対して、Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A1,A2;B1,B2&lt;/sub&gt;(f)を、Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A1+A2,B1+B2&lt;/sub&gt;(σ&lt;sub&gt;A2,X&lt;/sub&gt;;f;σ&lt;sub&gt;X,B2&lt;/sub&gt;)とすると、クロスが減るので表記が単純になることがある。

f;A→B+X, g:X+C→Dのとき、f;&lt;sub&gt;X&lt;/sub&gt;g:A+C→B+Dを、(f + C);(B + g)と定義すると、これも表記が単純化することがある。

シークエントなら：
&lt;pre&gt;
 A1, X, A2 ⇒ B1, X, B2
 ---------------------
  A1, A2 ⇒ B1, B2

 A ⇒ B, X    X, C ⇒ D
 ----------------------
      A, C ⇒ B, D
&lt;/pre&gt;

やっぱり、トレース付き多圏とかコンパクト閉多圏とかを考える必然性はあるな。

*1153796643*[リンク][雑記]多圏

多圏とその応用：

- &lt;a target=&quot;_blank&quot; href=&quot;http://www.maths.mq.edu.au/~craig/pdf/msc.pdf&quot;&gt;ΣΠ-Polycategories, Additive Linear Logic, and Process Semantics&lt;/a&gt;

モノイド圏Cがあれば、簡単な構成法で多圏Poly(C)ができる。CはPoly(C)に埋め込めるし、Poly(C)からCへの“射影”もあって、EPペアーになっている。Cが対称モノイド圏なら、Poly(C)は対称多圏になる。

圏と多圏を一緒に考えるなら、対象類Xから出発して：

+ 域許容列の集合D⊆X&lt;sup&gt;*&lt;/sup&gt;
+ 余域許容列の集合C⊆X&lt;sup&gt;*&lt;/sup&gt;
+ cut許容列の集合M⊆X&lt;sup&gt;*&lt;/sup&gt;

を定め、Γ∈D, Δ∈Cに対してpoly hom-set P(Γ;Δ)があり、Δ1, x, Δ2 とΦ1, x, Φ2 がそれぞれ許容列、xがcut許容列のときにかぎりcutを定義する。空列をどう解釈してどう操作するかが問題となりそう。

*1153799158*[トレース／コンパクト閉圏][からみ系]からんでいるモノ色々

タングル（訳語は「もつれ」か？）の定義がハッキリとは確定できないが、たぶん、次のように定義しておけば十分に一般的だと思う。

I=[0, 1]（区間）、C=S&lt;sup&gt;1&lt;/sup&gt;（円周）として、IとCのいくつかの直和をXとする。連続写像 X→R&lt;sup&gt;3&lt;/sup&gt;のなかで、次の条件を満たすものをタングルと呼ぶ。

- Xの境界（あれば）の像は、R×{0}×{0}（X軸）またはR×{0}×{1}（上に1あげたX軸）に入る。

実際には、そのような写像のイソトピー類を扱う。

+ XがCだけの直和なら絡み目（リンク）
+ XがCなら結び目（ノット）
+ XがIだけで適当な条件を満たすなら組み紐（ブレイド）

アレクサンダーの定理により、すべての絡み目は組み紐のブレイディングクロージャによって定義できる。ブレイディングクロージャはトレースだから、自由生成のトレース付きブレード圏が絡み目の表現になっているってことだろう。

枠付きの組み紐／絡み目だと事情が変わるから、それはたぶん（トレース付き）リボン圏の議論になるのだろう。向きや荷電が付けば、コンパクト閉圏が登場するだろう。



</body>
</day>
<day date="2006-07-26" title="">
<body>
*1153875196*[リンク][トレース／コンパクト閉圏][からみ系]結び目を勉強しなかった不徳

次の本を渋谷の本屋でパラパラめくっていた。

ISBN:4254116020:detail

146ページ以降に、いつも僕が絵算で描いている図がワラワラと出てきてビックリした。冷静になってみれば、ブレイド圏などが3次元トポロジーや位相的場の量子論（TQFT）に関係するのだから、まー、サモアリナンなんだけど。

しかし、タングル基本図式がストレートな単一線、2種のブレイド生成元（互いに逆）、Kelly単位／余単位に対応する半円形なのか（P.147）。これらで自由生成される図形に同値関係を入れるのだが：

- 縦スライドは、僕がストレートジャンクションの伸ばし／縮め、射のずらし（シフト）と呼んでいるものだ。
- 極点対の消滅は、ジグザグ公式、または剛性だ。
- 交点の回転は、クロスオーバー公式とクロスの計算をあわせたものだろう。

ヤンキングとアルチン・ブレイド関係式に相当するライデマイスター移動（ヤンキングがそのI, アルチンがII, III）と、上の縦スライド、対消滅、交点回転をトゥラエフ（Turaev）移動と呼ぶそうだ。トゥラエフ移動で移る図式はイソトピーらしい。

うーむ、、、しかし、僕は激しく&lt;em&gt;あさはか&lt;/em&gt;だった。むかーし、図書館で結び目理論の翻訳本（おそらくクロウェ ル＆フォックス 寺阪＆野口訳）を見つけたことがあった。そのとき僕は、結び目理論は箱庭みたいなもんだと思った。趣味的に面白いかもしれないが、小さな閉じた世界と感じたわけだ。広がりや普遍性がないものが好きでなかった僕は、こんなものは勉強するに値しないと判断した。

これはとんでもない&lt;span style=&quot;font-size:large;&quot;&gt;&lt;strong&gt;オオマチガイ&lt;/strong&gt;&lt;/span&gt;だった。タングル、絡み目、結び目、ブレイドは、今や整数論から数理物理まで、そして圏論にも多大な影響と刺激を与える壮大な理論になってしまった。素数も量子重力場も、その根源はタングルや結び目のようなものだというハナシまである。あのとき、あの本をちゃんと読んでいれば、、、と、そんな後悔ばっかし。

*1153889775*[論理][トレース／コンパクト閉圏]多圏上のシーケント計算

シーケント計算は、別に論理と考える必要はなくて、&lt;strong&gt;単なる計算法&lt;/strong&gt;と割り切ったほうがいいようだ。

トレース付き対称多圏（traced symmetric polycategory）を考えることはできる。そこでの計算はシーケント計算が便利。まずは、トレースによるカット（trace-cut）を基本推論として導入する。
&lt;pre&gt;
  Γ, x ⇒ Δ, x
 ----------------[trace]
    Γ ⇒ Δ
&lt;/pre&gt;

トレース・カットを使って伝統的なカットを導いてみる。
&lt;pre&gt;
 Γ ⇒ Δ, x   x, Φ ⇒ Ψ
 -------------------------[monoidal product]
 Γ, x, Φ ⇒ Δ, x, Ψ 
 -------------------------[symmetry]
 Γ, Φ, x ⇒ Δ, Ψ, x
 -------------------------[trace]
   Γ, Φ ⇒ Δ, Ψ

 i.e.

 Γ ⇒ Δ, x   x, Φ ⇒ Ψ
 ==========================[cut]
   Γ, Φ ⇒ Δ, Ψ
&lt;/pre&gt;

これって、f;g = Tr[(f×g);σ] のことだ！ 

命題変数に順序が入れば、それから公理系を作れる。図形的には有向グラフから多圏を作って、その上でシーケント計算することになる。極性（polarity）は否定（negation）として解釈することもできるだろうし、ベキがあればそれはimplicatioになる。

そういや、白旗さんも線形論理の文脈でコンパクト閉圏を持ち出していたし、線形分配圏（多圏）も線形論理から来ていた。線形論理には近付きたくなかったのだが、なんか引き寄せられているような、、、

*1153889891*[プログラム意味論][トレース／コンパクト閉圏][janus]Janusと圏／多圏

ベースとなるトレース付き（対称）モノイド圏Cだが、これはセオリーの列(A1, ..., An)またはセオリーのレコード{a1:A1, ..., an:An}を対象とする。射f:A→Bは、ライブラリ／プラットフォームBを使ってサービスAを提供するプログラムになる（「プログラム」って何だ？ってことにはなるが）。

Cのなかに、振る舞い正規化（マイヒル／ネロード関手）とそれによる振る舞い同値関係を入れて、この同値関係と整合する振る舞い関手を定義したい。

コンポネントの圏は、CからInt構成で作る。一方で、Cに対応するtraced symmetric polycategory Poly(C)も作っておきたい。Int構成は多圏の圏でも使えるかな？ そもそも多圏の圏のmorphismをどう定義すべきか？polyfunctorか、morphism of polycategoriesなのか？ いずれにしても圏PolyCat、SymmPolyCat、TrPolyCat、ComClPolyCatなんかが必要。

*1153892741*[プログラム意味論][トレース／コンパクト閉圏]Janusの階層構造

ベースとなるトレース付き（対称）モノイド圏Cの射を機能体（functionality）、G=Int(C)の射を（対話的）コンポネント、Gにおける射を表現する項をクラスタと呼ぶ。コンポネント名やクラスタ名の記号空間が必要になる。クラスタをラップしてコンポネントにすることもできる。

Gにおいて、X→0 の形をした射を閉じたクラスタと呼ぶ。射としては基礎射（ground morphism）である。閉じたクラスタ（の実体）がサービスとなる。

+ &lt;strong&gt;コンポネント&lt;/strong&gt;は何個かの機能体を箱詰め（enbox）したものである。
+ 機能体を一個も持たないコンポネント（ジャンクション、コネクター）もある。
+ コンポネントから、コンパクト閉圏における演算で組み立てられた式が&lt;strong&gt;クラスタ&lt;/strong&gt;である。
+ 余域（バック面）が空であるクラスタが&lt;strong&gt;サービス&lt;/strong&gt;である。


</body>
</day>
<day date="2006-07-27" title="">
<body>
*1153959797*[論理][トレース／コンパクト閉圏]多圏とカット

多圏の定義には、結合であるカットが単一（単純）カット（single/simple cut）と複合カット（multicut）のバージョンがある。

multicutができるときは、f:Γ→Δ1,Θ,Δ2  g:Γ1,Θ,Γ2→Δに対して、cutは、f;&lt;sub&gt;Θ&lt;/sub&gt;g:Γ1,Γ,Γ2 → Δ1,Δ,Δ2 となる。|Θ|≧1の条件が付くが、これを|Θ|=1のしたのがsinglecutの多圏。

多圏では、原子対象Aに対するidentityはあるが、列Γ=(A1, ..., An)に対するidentityはない。これが不便だが、定義に追加していいときもあるだろう。交替律f;&lt;sub&gt;X&lt;/sub&gt;g;&lt;sub&gt;Y&lt;/sub&gt;h = f;&lt;sub&gt;Y&lt;/sub&gt;h;&lt;sub&gt;X&lt;/sub&gt;gも定義に入っていたりいなかったり、、、（多圏は人気がない）

僕としては、基本命題集合（アルファベット）に順序があるとき（アルファベットがDAGのとき）、それを元にした推論ができればいい。A⇒Aだけでなくて、Γ⇒Γも公理に入れていいかもしれない。必要な推論規則は：

&lt;pre&gt;
  （A≦B）
  ---------[preorder]
    A⇒B

  （|Γ|≧1)
  ----------[multi-id]
    Γ⇒Γ

  Γ⇒Δ  Φ⇒Ψ
  ----------------[monoidal product/sum]
   Γ,Φ⇒Δ,Ψ

  Γ⇒Δ1,Θ,Δ2  Γ1,Θ,Γ2⇒Δ（|Θ|≧1）
  ----------------------------------------[multicut composition]
       Γ1,Γ,Γ2⇒Δ1,Δ,Δ2 

    Γ⇒Δ （σ,τは対称作用）
  -----------------------------[symmetry]
  σΓ⇒τΔ

  Γ1,Θ,Γ2⇒Δ1,Θ,Δ2（|Θ|≧0）
  ---------------------------------[generalized trace]
  Γ1,Γ2⇒Δ1,Δ2
&lt;/pre&gt;

*1153959798*[トレース／コンパクト閉圏][具体例]回路グラフ

境界付き有向グラフは、グラフGの次数1の頂点部分集合dGが指定されたもの。つまり、(G, dG)、dG⊆Node(G)、x∈dG⇒ord(x) = 1。もとになるグラフGには、ループ、並行辺、サイクル、サークル（頂点なしのサイクル）なども認める。

回路グラフGは、境界付きグラフで、境界がdom(G)とcod(G)に分割されていて、dom(G)もcod(G)も全順序が付いている。より一般的に、すべてのノードに対してその出る辺と入る辺に全順序（番号）が付いている。

Σがアリティ／コアリティともに自然数になっている指標とすると、Σラベル付き回路グラフが定義できる。Σにソートがあれば、ソート列でアリティ／コアリティを定義して、辺にソートを与えたΣラベル付き回路グラフも定義できる。

極性を与えれば、Σラベル付き回路グラフの全体がコンパクト閉圏になることは容易にわかる。


*1153975057*[リンク][トレース／コンパクト閉圏]トゥラエフのTQFT公理

トゥラエフ移動のトゥラエフ（Turaev）はTQFTの公理化もやっている。→http://www.numdam.org/numdam-bin/recherche?h=nc&amp;id=AFST_1994_6_3_1_135_0&amp;format=complete

Turaev, Vladimir G. &quot;Axioms for topological quantum field theories.&quot;

- ベース圏として位相空間の圏Cがある。
- space-structureという関手:C→Setがある。
- space-structure関手で、Cの和に対してSetの積が対応する。空に対して一点集合が対応する。
- さまざまなspace-structureが考えられる。
- Xのspace-structure A(X)の一点aを指定した(X, a)が構造付き空間である。A構造付き空間の圏ができる。
- A(X)にはinvolution(-)*があり、(X, a*)を-Xと書く。*は恒等でもよい。
- 2つのspace-structure関手に関して、コボルディズム圏を考える。
- 直和（disjoint union）、貼り合わせ（gluing）、反転に関して適切に振る舞うアーベル圏に値をとる関手を考える。

*1153975058*[論理][トレース／コンパクト閉圏]対称モノイド圏のシーケント計算

&lt;a href=&quot;http://citeseer.ist.psu.edu/shirahata96sequent.html&quot;&gt;白旗さんの論文&lt;/a&gt;をもとにする。Compact Multiplicative Linear Logicのシーケント計算から、否定（極性）を除くと次のようになる。

Σをアルファベット（基礎記号集合）として、式（formula）は次のように定義する。

+ Σの元
+ I（IはΣに入らない）
+ (式+式) （括弧は適宜省略）

A, Bなどは式だとして、式の列をΓ, Δなど。Γ⇒Δがシーケント。公理は：

+ a∈Σとして、a⇒a
+ ⇒I

構造的推論規則、式の量は変わらない。
&lt;pre&gt;
  Γ,A,B,Δ⇒Φ
  --------------[換 左; exchange left]
  Γ,B,A,Δ⇒Φ

  Γ⇒Δ,A,B,Φ
  --------------[換 右; exchange right]
  Γ⇒Δ,B,A,Φ

  Γ⇒Δ  Φ⇒Ψ
  ----------------[混合; mix]
  Γ,Φ⇒Δ,Ψ
&lt;/pre&gt;

導入規則、式（部分式も含める）の量は変わらず論理記号（+, I）が増える。
&lt;pre&gt;
  Γ,A,B,Δ⇒Φ
  --------------[+導入 左]
  Γ,A+B,Δ⇒Φ

  Γ⇒Δ,A,B,Φ
  --------------[+導入 右]
  Γ⇒Δ,A+B,Φ

  Γ⇒Δ
  ----------[I導入; unit weakening]
  I,Γ⇒Δ
&lt;/pre&gt;

カットは式が減る。
&lt;pre&gt;
  Γ⇒Δ,A  A,Φ⇒Ψ
  ------------------[切断; cut]
  Γ,Φ⇒Δ,Ψ
&lt;/pre&gt;

対称モノイド圏とは次の関係がある。

|*シーケント計算   |* 対称モノイド圏 |
| +  | 対象のモノイド積 |
| I  | モノイド単位 |
| 公理| 恒等射 |
| 換 | 対称ブレイディング|
|混合 |射のモノイド積（と対称）|
|切断 |（部分的な）結合 |

コンパクト閉圏では次が追加される。

- Aが式ならA*も式である。

&lt;pre&gt;
  Γ⇒A,Δ
  ----------[*導入 左]
  A*,Γ⇒Δ

  Γ,A⇒Δ
  ----------[*導入 右]
  Γ⇒Δ,A*
&lt;/pre&gt;


</body>
</day>
<day date="2006-07-28" title="">
<body>
*1154053279*[まとめ][人物]人と概念：暫定

まとめになってないし、裏を取ってないけど、とりあえずバラバラと書いておく。後で確認してリンクとか付けよう。人名はできるだけ片仮名書きするが、発音が見当もつかないのは原綴。[追記][http://d.hatena.ne.jp/m-hiyama-memo/19050101:title]参照。[/追記]

&lt;h5&gt;トゥラエフ&lt;/h5&gt;

最近、気になりだしたのはウラジミール・トゥラエフ（Vladimir G. Turaev）、フランスにいるらしいけど、名前は旧ソ連系だな。TQFT、結び目、量子不変量、低次元幾何あたりが専門領域か。コボルディズムを小さく切って解析する方法を使っているようだ、その簡単なケースが輪切り図とトゥラエフ移動（小島さんの本ISBN:4254116020に記述がある）。この手法は図式の書き換えや正規化に役立ちそうだ。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060726/1153875196:title]

&lt;h5&gt;ストリートとケリー&lt;/h5&gt;

最近やっと[JSV96] &quot;Traced Monoidal Categories&quot;のコピーを入手した。このなかで例に取り上げられていたのは、行列の直和に関するトレース（普通のトレースではない）で、クリーネ・スターを使って表現できる。これは、カザネスク／ステファネスク／ハイランド／長谷川の定理の応用として知っていたことだが、話題としては面白い。

どうでもいいが、2005年のロス・ストリートの還暦祝いはStreetFestって“祭り”だったらしい。ストリートはオーストラリア圏論グループ（バタニンもいるかも？）を率いているが、ケリー（オーストラリアにいた）の弟子らしい。そのケリーの[KL80]はマクレーンの還暦に捧げられたようだ。

&lt;h5&gt;東欧の人々&lt;/h5&gt;

ステファネスクには何度か言及している（Network Algebra, UML-RT）。カザネスクはステファネスクの師匠スジだと思う。エルゴット、ブルーム、Esikなども東欧の人のようだ（たぶん）。ブルームはエルゴットの選集を編集している。Iteration Theories（Bloom/Esik）は読んでみたいが高い、、、

- [http://d.hatena.ne.jp/m-hiyama-memo/20060707/1152239473:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060530/1148980185:title]
- [http://www.amazon.co.jp/gp/product/0387563784/250-2925753-9543409:title]
- [http://www.amazon.co.jp/gp/product/3540563784/250-2925753-9543409:title]
- [http://www.amazon.co.jp/gp/product/0387906983/250-2925753-9543409:title]

&lt;h5&gt;ハイランドと周辺の人々&lt;/h5&gt;

マーチン・ハイランドは本来は論理学者なのかな？ コンピューティングサイエンスでもとても有名だけど。長谷川さんはおそらくハイランドに教わっているだろう。角谷さんて人は長谷川さんに教わったらしい、ハイランドの孫弟子ってことか。MS研究所のニック・ベントンもハイランドの弟子だと思う。プレモノイド圏はハイランドとベントンが一緒に書いているし。ハイランドやベントンはエジンバラだと思うが、MS研究所もエジンバラで、地理的には近い（お隣？）みたい。

&lt;h5&gt;アブラムスキーと周辺の人々&lt;/h5&gt;

オックスフォードのサムソン・アブラムスキー（Samson Abramsky）は、以前は領域論、並行処理、ゲーム・セマンティクスとかやっていた。対話圏（interaction categories）なんてのもあったな。最近は、Bob Coecke 、ロス・ダンカン（Ross Duncan）と量子計算／量子論理をやっている。

セリンガー（selinger）も高水準量子計算のリーダーだが、ラムダ計算や継続に関してもイロイロやっている。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060711/1152599185:title]

&lt;h5&gt;マーク・ホプキンスとコゥゼン&lt;/h5&gt;

マーク・ホプキンスは生きているらしい(笑)。物理のほうが本職か？ &quot;markwh04 AT yahoo DOT com&quot;で彼に届くかもしれない。

マークはデクスター・コゥゼンとパリクの定理の論文を書いている。コゥゼンといえば、クリーネ代数を定義したり、正規言語の代数を公理化し、その完全性を示したりした人だ。問題意識とか手法とかはユニークで面白い。が、どうも記述スタイルが僕の趣味に合わない。とても気になるけど苦手なタイプ。

&lt;h5&gt;日本人：白旗、長谷川&lt;/h5&gt;

コンパクト閉圏の論文を書いている珍しい人・白旗さん。彼の問題意識はコンパクト線形論理だったのかな。任意の圏A上に作ったCompact Multicative Linear Logic CMLL(A)の完全なモデルが自由生成コンパクト閉圏F(A)であり、それは別な構成によるG(A)と同じだということを示している。つまり、次の3つの構成法が同じだということだろう。

+ 論理系CMLL(A)をもとにした一種のリンデンバウム構成
+ 忘却関手 CompactClCat→Catと随伴になる自由構成
+ ケリー／ラプラザにより与えられた具体的で幾何学的な構成

さらに、F(A)=G(A)は、“Aの拡張であるコンパクト閉圏全体の圏”の始対象になる。アブラムスキーの高水準量子論理でも、圏に対するシーケント計算を使っている。ただし、アブラムスキーの文脈ではシーケントは不十分で、証明ネット（スライスの寄せ集め）を使っている。

長谷川さんは言うまでもなく、我が国計算科学のホープだ。

&lt;h5&gt;所感&lt;/h5&gt;

僕が、クリーネスターや不動点を経由してトレース付きモノイド圏／コンパクト閉圏に興味を持った理由のひとつに、マーク・ホプキンスの指摘がある。曰く、「形式言語理論は場の量子論だ」

トレース付きモノイド圏は、ブレイドや結び目と明らかに関係している。結び目のジョーンズ多項式は作用素環から出てきたらしい。作用素環といえばフォン・ノイマンとノイマン流量子力学 -- 一方で、ブレイドっぽい図式を駆使してアブラムスキー・グループは高水準量子計算を構成している。それはファインマン図式とも似ているし、[JSV96]はペンローズのヒエログリフ・テンソル計算にも影響を受けているし。

システムとコボルディズムの関係は、コラディニ（Corradini）、ガダッチ（Gaddacci）、ケイティス（Katis）、サバディニ（Sabadini）、R.F.Cウォルターズ（R.F.C. Walters）も指摘していた。その指摘はTQFTを彷彿とさせる。幾何学的定式化ならば、プラット（Vaughan Pratt）、ガウチャー（Philippe Gaucher）、ゴーバルト（Eric Goubault）、グランディス（Marco Grandis）などもやっている。

TQFTはコボルディズムの上で構成されるし、低次元トポロジーと関係し、結び目の量子不変量を与える。思うに、Kleenean TQFTとでも呼ぶべきTQFTのバリアントがあり、それが形式言語理論を与えるのだろう。system with boundaryが位相空間の代わりとなる。入れ子のオートマトンが現れるが、これはバンドルみたいなものだろうか。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060128/1138441388:title]

</body>
</day>
<day date="2006-07-29" title="">
<body>
*1154136168*[リンク][からみ系]Javaによる不変量計算

2-結び目の不変量を計算するJavaプログラムとその背景。

- The Java program for 2-knot invariants→http://tigger.uic.edu/~rgl/javaknots.html
- Glenn Lancaster / Richard Larson / Jacob Towber&quot;On the Combinatorics of Carter-Rieger-Saito Movies in the Theory of Smoothly Knotted Surfaces in R4&quot; (November 13, 2004)→http://tigger.uic.edu/~rgl/shrtknots.pdf

*1154136249*[メモ法]分類カテゴリの追加とメンテ

新しいカテゴリを追加したら、できるだけ過去のものも直す。が、神経質にはならない。検索でも対応可能だから。

*1154137339*[リンク][からみ系]2次元タングル

2次元（余次元2）のタングル：

- John C. Baez, Laurel Langford &quot;Higher-Dimensional Algebra IV: 2-Tangles&quot;→http://citeseer.ist.psu.edu/342936.html （64Pある）
- John C. Baez, Laurel Langford &quot;2-Tangles&quot;→http://arxiv.org/abs/q-alg/9703033
- Laurel Langford &quot;2-Tangles as a Free Braided Monoidal 2-Category with Duals (1997) &quot;→http://citeseer.ist.psu.edu/140678.html

*1154140088*[janus]ソリッドボックスとカスタムボックス

ボックスはコンポネントの別名として使う。ソリッドボックスとは、機能体と箱が一体のモノ、機能体が箱に作り付け、ハードワイヤされている。融通は効かない。例えば、プロファイルの変更は容易ではない。

カスタムボックスは、機能体（ベース圏の射）と箱が分離していて、箱詰めによって作られたコンポネントのこと。

*1154141572*[用語法][からみ系]tortile, writhing, crossing

tortile の訳語は「可捻」とか。

writhingもねじれを意味する。twistじゃなくてwrithingにするか。twistには、twist isomorphismって用語（記号はθ）がある。これは、「ひねり同型」とか。

2つのブレイド生成元をpositive crossing, negative crossingという人もいる。

*1154151745*[メモ法]はてなダイアリーブック

- 損したとは思わない。
- 大きさはgood
- 持ち歩き、俯瞰するのに便利
- 上付き下付きがなくなるのはキツイ。
- TeX数式は？期待できない。
- 図（画像）は落ち、飾りやサイズはなくなる。リンクも当然に、、
- 表も表らしくは出ない。
- 見出しもわからない。
- だから、段落は1字下げにすべきだった。
- 意味不明なところも出る。
- 文字だけ日記ならいいかも。
- 日付改ページは不要。


</body>
</day>
<day date="2006-08-01" title="">
<body>
*1154404268*[用語法][リンク]チョー（超）とモドキ

[http://d.hatena.ne.jp/m-hiyama/20050622/1119403339:title]、[http://d.hatena.ne.jp/m-hiyama/20050622/1119403496:title]を引き写しておく。

&lt;h4&gt;チョー（超）なモノ&lt;/h4&gt;

&lt;strong&gt;ultra&lt;/strong&gt; - ultracategoryはenrichmentとの関係で定義される。ultrametricとのアナロジーがあるようだ。
- Citeseer→http://citeseer.ist.psu.edu/613332.html
- 原稿→http://www.mat.uc.pt/preprints/ps/p0110.ps

&lt;strong&gt;hyper&lt;/strong&gt; - hypercategoryは、2-category, higher categoryの古い言い方らしい。今は使われてないみたい。

&lt;strong&gt;super&lt;/strong&gt; - supercategoryはごく普通にsubcategoryと対になる言葉として使う。が、まれに符号{+, -}（2次対称群）が作用するような圏の意味で使うこともある。
- http://math.ias.edu/~carlo/data/pdfthesis.pdf
super algebra（特にリー代数）はたまに見るね。

&lt;h4&gt;モドキなモノ&lt;/h4&gt;

&lt;strong&gt;pseudo&lt;/strong&gt; - pseudo-categoryはほとんど使われていないようだ。が、directed homotopyのGrandisが使っている：
- http://www.dima.unige.it/~grandis/Dbl.Adj.pdf

&lt;strong&gt;quasi&lt;/strong&gt; - quasi-category
- http://www.ima.umn.edu/talks/workshops/SP6.7-18.04/may/PorterMay.pdf
- http://citeseer.ist.psu.edu/671814.html
- http://citeseer.ist.psu.edu/mossakowski95hierarchy.html

局所的にも巨大な圏のこと？

&lt;strong&gt;pre&lt;/strong&gt; - precategory
- http://citeseer.ist.psu.edu/sassone03deriving.html
演算の定義が部分的でもよし、単位律は厳密に成立しているが、結合律がKleene等号の意味でしか成立してない。

&lt;strong&gt;他&lt;/strong&gt; - Ehresmannの&lt;em&gt;neo&lt;/em&gt;categoryとかHerrlichの&lt;em&gt;semi&lt;/em&gt;categoryとかもあるらしいが、調べてない。
- http://wslc.math.ist.utl.pt/ftp/pub/SernadasA/99-MSS-precat1.ps

*1154408514*[からみ系]タングルとジョーンズ多項式

タングルの定義は、次が明確。

Xは1次元コンパクト多様体、I=[0, 1]として、なめらかな埋め込みf:X→I×I×I を考える。Xの境界はI×I×{0, 1}に入るとする。さらに、I×I×{0}の周辺では、fの像がI×I×{0}にのった有限個の点との直積構造を持つとする。つまり、{(x, y, z) | (x, y)∈有限集合, 0≦z＜ε}の形をしているとする。I×I×{1}の周辺でも同じ。

このとき、埋め込みf（あるいはその像）を&lt;strong&gt;タングル&lt;/strong&gt;と呼ぶ。

床と天井で直積構造になるのは、メルローズのb多様体の定義にもあったな、確か。一般化するには、Xの次元と、埋め込み先の次元を任意にする。すると、狭義のタングルは1次元／余次元2のタングルとなる。

バエズ（John C. Baez）などによると、タングルのイソトピー類は圏となり、完全に代数的／組み合わせ的な記述ができるらしい。Shum（女性）の結果によれば、枠付き向き付き（framed oriented）タングルは、双対付きブレイド・モノイド圏（braided monoidal category with duals）であり、単一の自己双対対象から自由生成された圏に同型（か同値か）になる。コンパクト閉圏に近い構造を持つ。

ジョーンズ多項式は、タングル圏で定義され、他の双対付きブレイド・モノイド圏に値を取る関手になるらしい。ジョーンズ多項式では、値の圏が量子群の表現の圏という事情があったらしい。一般的に言えば、量子不変量は、“双対付きブレイド・モノイド圏の圏”の射（関手）となるのだろう。

タングルは、ある種のコボルディズムと考えられるから、確かにTQFTの枠組みに入っている。

*1154446687*[リンク]印刷途中

- http://www.ima.umn.edu/talks/workshops/SP6.7-18.04/forcey/talk.pdf

印刷途中でインク切れた。

</body>
</day>
<day date="2006-08-03" title="">
<body>
*1154581552*[形式言語理論]斜随伴

XとYが順序集合（実際は束のときが多い）で、f:X→Y、g:Y→Xがあって、「x≦g(y) ⇔ f(x)≦y」ならば、fとgは随伴だといっていい。さて、次の状況を考える。

- x≦g(y) ⇔ y≦f(x)

Yの順序≦' を「x≦'y ⇔ y≦x」と定義すれば、これも随伴だと考えることができるのだが、X = Y のときはそうはいかない。そこで、この状況を「fとgが&lt;strong&gt;斜随伴&lt;/strong&gt;」と呼ぼう。不等号の形が同じなので、fとgを左右で区別するのはふさわしくない。fを斜随伴の&lt;strong&gt;分解子&lt;/strong&gt;、gを斜随伴の&lt;strong&gt;生成子&lt;/strong&gt;と呼ぶ。

なんで、分解と生成としたかというと。Xが言語からなる順序集合として、fがオートマトンによる認識や言語微分を表現するとする。言語xに対してf(x)はxを分解していくような働きをする。g(y)はyを元にして文法による生成である。eを空語だけからなる言語だとすると、x⊆f(e) ⇔ e⊆g(x) 特にx = {a}と、xを単元言語にすると、a∈f({ε}) ⇔ ε∈g({a}) 。つまり、「文aが文法fで生成される ⇔ 言語{a}を分解するとεを含む言語になる」

実は斜随伴が意味を持つ例はこれしか知らないのだが、僕は、随伴と勘違いしていてトンチンカンなことをやってしまったから、随伴とは違うことを強調して、斜随伴という概念を定式化した。

いや、まて。以前、病原菌の伝染（伝搬）をTQFTの例に考えたときがあったが、あれは斜随伴になるかもしれない。

*1154581748*[用語法]パラ

正統とは違うようなナニカを「パラ××」というそうだ。

*1154597217*[からみ系][高次圏論][TQFT]タングル仮説と2-cobord伝承

ジョン・バエズの&lt;strong&gt;タングル仮説&lt;/strong&gt;というのは、すさまじい予想で、枠（法線場だと思ってよい）や向きがついた埋め込み多様体（それがタングル）のイソトピー同値類の圏が代数的／組み合わせ的に定義できるだろう、というもの。さらに、その代数構造が、弱高次圏に他ならない、と。

具体例として、余次元2の枠付き向き付き1タングルの圏が、単一の自己双対対象で生成された双対付きブレイド・モノイド圏だというシャム（Shum）の結果を挙げている。どうもそれだけでなく、自然数や整数の発生も、タングル仮説に入る気がする。

さて一方、&quot;GENERIC COMMUTATIVE SEPARABLE ALGEBRAS AND COSPANS OF GRAPHS&quot;（http://www.tac.mta.ca/tac/volumes/15/6/15-06.pdf）に次のフレーズがある。

&gt;&gt;
(1×∇)・(Δ×1) = Δ・∇ = (∇×1)・(1 × Δ) is an axiom characteristic of 2-cobordisms.

The free symmetric monoidal category with a Frobenius algebra object is the category 2-Cobord.
&lt;&lt;

2-Cobrod（むしろ1+1コボルディズム）の構造は伝承であったそうだが、次の本で伝承が真実であることを示しているらしい

- J. Kock, Frobenius algebras and 2D topological Quantum Field Theories, Cambridge University Press, 2004.


</body>
</day>
<day date="2006-08-05" title="">
<body>
*1154756632*[雑記][リンク][JavaScript]白旗さんのJavaScriptセミナー

コンパクト閉圏や線形論理（線形集合論）をやっている白旗さんが、こんなこともやっていた。→ http://gentzen.math.hc.keio.ac.jp/JavaScript/index.html


</body>
</day>
<day date="2006-08-07" title="">
<body>
*1154909875*[圏一般論]圏の全不連結性、亜群、圏の貼り合わせ

僕がジャンクションと呼んだもの（ステファネスクは確かコネクターと呼んでいた）を定式化するのに、細かい定義や補題が要る。

圏Cが&lt;strong&gt;全不連結&lt;/strong&gt;とは：

- X≠Y ならば C(X, Y)=空。

要するに、End(X) = C(X, X)にしか射がない。本質的に全不連結とは：

- C(X, Y)≠空 ならば XとYは同型。

例を挙げる。

+ S(n, n) = S(n) がn次対称群として定義される対称亜群は全不連結である。
+ 同様に、ブレイド亜群も全不連結である。
+ 集合の双射だけを射とした圏は、本質的に全不連結である。

次に圏の自由貼り合わせを定義する。C, Dを圏として、単射写像 i:X→|C|、j:X→|D|があるとする。i, jを使って、|C|と|D|を貼り合わせることができる。新しいグラフE（圏ではない）を次のように定義する。

+ |E| = (|C|と|D|の貼り合わせ)
+ X, Y∈|C|, X', Y'∈|D|であり、[X}=[X']、[Y]=[Y']となっているときは、E([X], [Y]) = C(X, Y) + D(X',Y') （直和）
+ その他のときは、E(X, Y) = C(X, Y) または E(X, Y) = D(X, Y)として定義する。

i, jが単射であることは落とせるし、より一般に関手X→C, X→Dを使っての貼り合わせも定義できる。

さて、Eは圏ではないが、グラフEからの自由生成圏から適切に商をとって、CとDをi, jで貼り合わせた圏を定義できる。貼り合わせた圏は普遍性によって特徴付けできると思われる。

*1154909876*[メモ法]見出しカテゴリー

- 見出しカテゴリーが増えるのはしょうがない。現状ではカテゴリー編集手段がない。が、カテゴリー表示の順序だけでも直しておくとよい。
- カテゴリー編集がないのは実に辛い。手で直すか？
- カテゴリー表示（はてなモジュール）に区切り線を入れた。



</body>
</day>
<day date="2006-08-10" title="">
<body>
*1155159653*[論理][からみ系]アレクサンダーの定理とカット消去定理

結び目／からみ目のアレクサンダーの定理は、カット消去定理と類似かも。

</body>
</day>
<day date="2006-08-11" title="">
<body>
*1155286117*[論理][からみ系]アレクサンダーの定理とカット消去定理 もっと

アレクサンダーの定理は、絡み目／結び目がブレイドのブレイディング・クロージャであることを主張する。つまり、xを絡み目とすると、適当なブレイドbがあって、x = Cl(b) と書ける。Clはクロージャ。ここで、Cl(b)は、一種の正規形表現だと解釈できる。つまり、絡み目を、より簡単なブレイドと&lt;em&gt;ただ一回の&lt;/em&gt;クロージャだけで表現している。

トレース付きモノイド圏で同じことが言える。Cをトレース付きモノイド圏だとして、Cの対象／射を表現する記号と、対象／射を同一視して話すとして： &lt;strong&gt;基本項&lt;/strong&gt;を次のように定義する。

+ Cの、ある選ばれた射は基本項である。
+ AがCの対象だとして、id&lt;sub&gt;A&lt;/sub&gt;（しばしばAと書かれる）は基本項である。
+ A, BがCの対象だとして、σ&lt;sub&gt;A, B&lt;/sub&gt;は基本項である。

基本項の有限モノイド積の形の項を&lt;strong&gt;スライス&lt;/strong&gt;と呼ぶ。スライスの結合の形の項を&lt;strong&gt;単純項&lt;/strong&gt;と呼ぼう。tが単純項だとして、Tr&lt;sup&gt;X&lt;/sup&gt;(s)の形の項を&lt;strong&gt;正規形&lt;/strong&gt;とする（本来の意味の正規形ではないが）。

項で表現可能なCの射は、実は正規形でも表現できる。別な言い方をすると、内側のトレースを除くことができる。


</body>
</day>
<day date="2006-08-17" title="">
<body>
*1155783593*[用語法]semiringal

monoid + al で monoidal という形容詞ができる。semiring + al で semiringal。ステファネスクは、semiringal categoryという言葉を使っている。半環圏と訳そう。

半環圏は、2つのモノイド構造を持ち。それらが、分配性（distributivity）自然変換で関係しているような圏だ。加法的関係圏と乗法的関係圏を一緒に考えた複合（mixed）関係圏が半環圏の例になる。双積とテンソル積を持つ圏も半環圏になるだろう。

*1155784617*[トレース／コンパクト閉圏][リンク]一様性、酵素、模倣

ステファネスクは酵素（enzymatic）公理／規則を使っているが、これは他の概念と関係する。

+ 酵素公理／規則
+ 一様性原理（uniformity principle; Plotkin）
+ （双）模倣 （bisimulation）
+ 圏の振る舞い正規化（notion of behaviour）→[http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943257:title]

とりあえず、オートマトンの行列表現を詳しく調べてみよう。

それと→http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf
- author:Peter Selinger
- title: Categorical Structure of Asynchrony

*1155784829*[多圏][論理]順序ベース多圏と名前ベース多圏、シーケント計算

最近、少しだけ多圏の使い方に慣れてきた。多圏はけっこうバリエーションがある。まず、カットの自由度から、シングルカット多圏とマルチカット多圏がある。シングルカットはワイヤー1本に関してカットする。マルチカットは束（たば；リボン）でカットできる。

シーケント計算にならって、多圏の多対象（polyobject）をΓ、Δなどで表す。多対象の長さを|Γ|と書くが、ここでは|Γ|は{1, 2, ..., n}を表すとして、Γの&lt;strong&gt;台&lt;/strong&gt;と呼ぶ。|Γ|⊆&lt;b&gt;N&lt;/b&gt;だが、台は必ず区間の形をしている。

多対象を列ではなくて、レコードにしてみる。名前（キー）の集合Kを固定して、レコード{a1:A1, ..., an:An}を考える。Γ={a1:A1, ..., an:An}のとき、Γの台|Γ|は、名前の集合{a1, ..., an}だとする。

単対象の集合Oと名前の集合Kを固定すると、そこでシーケント計算が定義できる。定数記号×、Iを導入して、A∈Oに対する「A⇒A」と「⇒I」を公理として、次の推論を許す。

&lt;pre&gt;
 Γ, a:A, b:B, Δ ⇒ Φ
 ----------------------[× 左導入]
 Γ, x:A×B, Δ ⇒ Φ（x!∈|Γ|∪|Δ|）

 Γ ⇒ Φ, a:A, b:B, Ψ
 ----------------------[× 右導入]
 Γ ⇒ Φ, x:A×B, Ψ （x!∈|Φ|∪|Ψ|）

 Γ ⇒ Φ
 -------------[I導入]
 x:I, Γ ⇒ Φ （x!∈|Γ|）

 Γ, a:A Δ ⇒ Φ
 ----------------------[左改名]
 Γ, x:A, Δ ⇒ Φ（x!∈|Γ|∪|Δ|）

 Γ ⇒ Φ, a:A, Ψ
 ----------------------[右改名]
 Γ ⇒ Φ, x:A, Ψ （x!∈|Φ|∪|Ψ|）

 Γ ⇒ Φ   Δ ⇒ Ψ
 --------------------[mix]
 Γ, Δ ⇒ Φ, Ψ （|Γ|∩|Δ| = |Φ|∩|Ψ| = 空）

 Γ, Δ ⇒ Φ, Δ
 -----------------[trace cut]
 Γ ⇒ Φ
&lt;/pre&gt;

この計算を多圏の定義に直せば：

+ トレース付きモノイド圏で解釈可能である。
+ 改名の亜群が作用している。
+ モノイド積は条件付きでしか定義できない（部分的になる）。
+ マルチカットを許す

つまり、可置換部分モノイド多圏（permutable partially-monoidal polycategory）とでも呼ぶべき構造になる。カット（結合）はトレースカットから定義できる。

*1155784911*[多圏][論理][トレース／コンパクト閉圏]証明、項、射

トレース付きモノイド圏Cに意味を持つような形式的体系の項を考えると、その項はシーケント計算の証明に対応する。証明図の木構造がちょうど項の木構造に対応する。よって、項の変形は証明図の変形になっている。

さらに、項の値（意味）は圏Cの射だから、証明図、項、射に対応が付く。開いた証明図、開いた項を考えると、それは多変項関手になる。

この対応により、カット消去定理、項の準正規化が対応していることがわかる。これは、結び目理論のアレクサンダーの定理の類似物だが、結び目ではさらにマルコフの定理がある。証明系と項計算におけるマルコフの定理の類似は何だろう？


</body>
</day>
<day date="2006-08-18" title="">
<body>
*1155894528*[トレース／コンパクト閉圏]トレース付きモノイド圏の対角、一様性など

セリンガー（Peter Selinger）の&quot;Categorical Structure of Asynchrony&quot;（→http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf）から、いくつかの概念：

対称モノイド圏Cが|C|でインデックスされた族Δ&lt;sub&gt;A&lt;/sub&gt;:A→A×A、◇&lt;sub&gt;A&lt;/sub&gt;:A→Iを持ち、Aに対してΔ&lt;sub&gt;A&lt;/sub&gt;と◇&lt;sub&gt;A&lt;/sub&gt;が対称（可換）コモノイドになっているとき、(C, Δ, ◇)を&lt;strong&gt;対角付き（対称）モノイド圏&lt;/strong&gt;（monoidal category with diagonals）と呼ぶ。◇を弱終射（weak terminal morphism）と呼ぶことがある。

f;Δ = Δ;(f×f)を満たす射fを&lt;strong&gt;コピー可能&lt;/strong&gt;（copyable）、f;◇= ◇を満たす射を&lt;strong&gt;破棄可能&lt;/strong&gt;（discardable）と呼ぶ。コピー可能射、破棄可能射の全体はそれぞれ部分圏をなす。コピー可能かつ破棄可能な射からなる部分圏を対角付きモノイド圏の&lt;strong&gt;焦点&lt;/strong&gt;（focus）と呼ぶ。焦点に入る射は焦点的（focal）と呼ぶ。焦点部分圏は、対角付きモノイド圏に対してのみ定義できる。

トレース付きモノイド圏でありかつ対角を持つ圏Cを考える。Tr(Δ&lt;sub&gt;A&lt;/sub&gt;)を弱始射（weak initial morphism）と呼び、□&lt;sub&gt;A&lt;/sub&gt;と書く。□;f = □である射を&lt;strong&gt;厳密射&lt;/strong&gt;（strict）と呼ぶ。厳密射の全体も部分圏となる。

トレース付き対角付きモノイド圏Cに部分（対称）モノイド圏Uが指定されていて、Uは次に性質を持つとする。

+ |U| = |C|
+ すべての同型はUに属する。
+ すべての対角、弱終射、弱始射はUに属する。

次に性質を持つとき、トレースは一様である、あるいは(C, U)が&lt;strong&gt;一様トレース付きモノイド圏&lt;/strong&gt;（uniformly traced - ）と呼ぶ。

- あるh∈Uに対して f;(id×h) = (id×h);g ならば、Tr(f) = Tr(g)

長谷川さんは、Uが圏になる必要はないし、圏にならない例もあることを強調している。よって、Uは単なる射の族としていいだろう。

また、長谷川さんのstrictの定義はセリンガーと違っていて、一様性原理が成立する射を厳密と呼んでいる。例えば、「同型は厳密」という定理がある。

セリンガーの意味の厳密は、保存的とか保守的と呼んで、長谷川さんの意味の厳密は一様または酵素的（enzymatic）がいいと思う。


</body>
</day>
<day date="2006-08-19" title="">
<body>
*1155979043*[多圏][プログラム意味論]レコード形式指標に対するセオリーとシーケント

名前ベースの多圏を考える。多圏の多対象は、レコード{a1:A1, ..., an:An} だが、A1, ..., Anはプログラムのインターフェース（指標）（の名前）だとする。

レコード＝多対象に対して、a1, ..., anでプリフィックスされた演算記号を寄せ集めた指標 a1.A1 + ... + an.An を考える。この指標の上でセオリーを考える。シーケントの記号「⇒」を適当に解釈して、セオリーの伴意計算ができないだろうか？

*1155980941*[説明]行列圏

|Set| = |Rel| = S とする。類X上のK係数行列の圏をMat(X, K)とする。Bはブール半環として、Rel≒Mat(S, B)。よって、Set⊆Mat(S, B)。

半環RがB⊆Rならば、Set⊆Rel⊆Mat(S, R) となる。


</body>
</day>
<day date="2006-08-29" title="">
<body>
*1156817276*[形式言語理論]ダガー行列圏

半環にダガーまたは包合と呼ばれる演算が備わっているとき、それをダガー半環（dagger semiring）と呼ぶ。ダガーの公理（冗長だが）は：

- a†† = a
- (a + b)† = a† + b†
- (ab)† = b†a†
- 0† = 0 
- 1† = 1

Rがダガー半環として、R係数の行列A:n→mに対して、A†は、反転して成分をダガーしたものだとする。明らかにA†:m→n。さらに、行列達もダガー半環と同じ性質を持つ。

行列圏の対象nに対してはn† = n とすると、ダガーは反変関手Dag : Mat(X, R)→Mat(X, R)になる。この関手は、identity-on-objectsの対蹠的反変モノイド関手なので、セリンガーの意味の圏論的ダガーである。よって、ダガー半環係数の行列圏はダガー圏になる。

実例は、ダガー集合（包合的演算を持つ集合）をアルファベットとする列言語の半環に、反転によりダガーを入れたものを係数とする行列圏。

*1156817394*[トレース／コンパクト閉圏][からみ系]ヤンキングの不思議

ヤンキングは、トレース付きモノイド圏でもコンパクト閉圏でも基本的な性質になっている。が、ベルトなどで実演するとわかるが、実際には、引き延ばすと180度ねじれてしまう。これを考慮したヤンキング公式もある。

ところで、ブレイドのクロッシングを「⊃⊂」の形に変形する操作がよく出てくる。確かザイフェルト局面を作るときに出てきたような？ それと、散乱行列でも交差を対消滅／対生成に置き換えても遠方でも区別がつかないことを表現する（のだろう）。

さて、ヤンキングに出てくる交差を「⊃⊂」に置き換えると、直線＋円（ループ、サークル）になる。テンパリー／リーブ代数（Temperley-Lieb）のカウフマン（Kauffman）図による計算では、ループの数だけスカラー乗数が掛け算される。

なんか不思議だ。

</body>
</day>
<day date="2006-08-30" title="">
<body>
*1156912096*[圏一般論]はじめての圏論 -- メイキング／NG集 1

本編の「はじめての圏論」の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060825/1156469121&quot;&gt;第5歩&lt;/a&gt;、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060828/1156723970&quot;&gt;第6歩&lt;/a&gt;は、ちょっと先走りだったかもね（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060829/1156816404&quot;&gt;番外&lt;/a&gt;は“番外”だからまーいいとしても）。

「圏論によりソフトウェアを理解する」のが僕の問題意識だから、話がソッチ方向にいってしまうのは、まー、いたしかたないのだけど、ソフトウェア（計算科学）への応用は、入門ネタとしては（ひょっとして一般論としても）難しい。

ソフトウェア（ハードウェアでもいいけど）への圏論の適用方法の大原則があるにはあるが、実際にやってみると、対象、射、結合を特定／定義するのが難しかったりする。圏構造を見つけて同定するのが面倒なのだ。しかも、圏構造がいくつも重層的に入っていたりする。ケースごとに圏構造を使い分けたり、たくさんの圏を一度に考える必要があったりする。

入門的説明としては、行列の圏を中心にする方針もあるし、他に手でいじれる具体例もあるから、それらでもう少し圏に慣れてからでないと、ソフトウェアを圏でモデル化するのは抵抗感と困難があるかもしれない。

ただし、変換キューはいい例だと思っている。Unixのパイプ機構をうまく説明しているし、半圏からの圏の構成にもなっている。半圏と、パラメトライズされたベキ等射の族q&lt;sub&gt;x&lt;/sub&gt;:J&lt;sub&gt;x&lt;/sub&gt;→J&lt;sub&gt;x&lt;/sub&gt; （x∈X、Xは半圏の外にある任意の集合でよい）から圏を作る構成は割と広く使える。他にも、半圏と射の族（バッファ、コネクタ、アダプタ）から圏を作る構成法は色々ありそうだ。

*1156912357*[余代数][その他代数]ラベル付きマルコフ・プロセス

ミスロフ（Mislove）やパブロビック（Pavlovic）等による&quot;Duality for Labelled Markov Processes&quot;（http://citeseer.ist.psu.edu/642236.html）という割と短い論文がある。&quot;Processes&quot;は、マルコフ過程の意味のプロセスと、計算科学のソフトウェアとしてプロセスの両方の意味を持っていて、ラベル付き遷移系（labelled transition system）の遷移が確率分布に従うようなものである。

で、ミスロフ等は、ラベル付きマルコフ・プロセスの終余代数のようなものを構成している。これに、ストーン／ゲルファンド／ナイマルク（Stone/Gelfand/Naimark）双対を使っている。ここが非常に面白い。計算科学、確率、物理が交錯する領域かもしれない。

</body>
</day>
<day date="2006-09-02" title="">
<body>
*1157178847*[プログラム意味論]時間と走行

時間には離散時間と連続時間があるが、いずれにしても、有界なら両端（始点と終点）がある全順序集合となる。時間の直列接続が定義できる。始点と終点を複数許せば、並列接続も定義できる。有界時間の全体を、&lt;b&gt;N&lt;/b&gt;を対象とするモノイド圏と考えてよい。分岐時間とか合流時間を考えると、ほぼ境界付き無輪有向グラフの圏だと思ってよい。

そういうわけで、有界時間とは「始点／終点という境界を持った幾何学的（辺が1次元図形である）有向グラフ」だと思ってよいだろう。辺に正実数値を対応させれば計量的のグラフとなる。

境界付き遷移変換系があるとき、時間からの境界付きグラフ準同型があれば、それが走行（run）となる。時間のなかに部分線形時間が含まれるとき、部分線形時間に制限した走行がスレッドとなるだろう。要するに多時間構造だが、分岐／合流もありえる。

構造付きの多時間を使って、並列処理を定式化できないだろうか？

*1157178848*[トレース／コンパクト閉圏][具体例]とても簡単なトレース付きモノイド圏

(A, B, X) を集合の3つ組として、A∩X = B∩X = 空 なものとする。ただし、A∩Bは空である必要はない。

(A, B, X);(B, C, Y) = (A, C, X+B+Y) 、Tr(A+X, B+X, Z) = (A, B, X + Z) と定義すると、やたらに簡単なトレース付きモノイド圏になる。

*1157182581*[からみ系][リンク]えっ、またトゥラエフかよ

- Coalgebras of words and phrases http://arxiv.org/abs/math.QA/0408258
- Topology of words (59P) http://arxiv.org/abs/math.CO/0503683 
- Cobordism of words (47P) http://arxiv.org/abs/math.CO/0511513
- Knots and words (19P) http://arxiv.org/abs/math.GT/0506390


なんか面白いことするなー、と思ったら、トゥラエフ（Vladimir Turaev）でした。

それと：
- [google:&quot;balanced braided tensor category&quot;]
- [google:&quot;balanced braided category&quot;]

これから見つけた
- Yu.N. Bespalov（ベスパロフ）, Crossed modules and quantum groups in braided categories （53P） http://arxiv.org/abs/q-alg/9510013

面白い絵算が使ってある。


</body>
</day>
<day date="2006-09-04" title="">
<body>
*1157331116*[雑記]駄洒落（被リンク用）

自民党の総裁選、現在（Sep 2006）3人の候補者がいる。

+ 谷垣財務相
+ 麻生外相
+ 安倍官房長官

これが頻繁に報道されているわけだが、3氏の名前から：

+ 歯磨き
+ あ、そう
+ ヤベーッ

</body>
</day>
<day date="2006-09-07" title="">
<body>
*1157599403*[からみ系][リンク]ブレイド関係資料

- [google:Artin &quot;braid group&quot; theorem proof]
- [google:Fenn &quot;an elementary introduction&quot; braid]

とかで拾ったURLs。

- http://www.math.ucla.edu/~radko/191.1.05w/jordan.pdf ;ブレイドの解説、最初に読むべき！
- http://www.math.hmc.edu/seniorthesis/archives/2003/mmacaule/mmacaule-2003-thesis.pdf -- M. Macauley, Braids and Juggling Patterns, 2003 ;jordanから参照されている。面白い。
- http://arxiv.org/abs/math.GT/0409205 -- Braids: A Survey ;jordanから参照されている。ていねい、入門によい。が、90ページ。
- http://www.cirget.uqam.ca:16080/~liam/mythesis.pdf  -- KNOTS, TANGLES AND BRAID ACTIONS  ;LIAM THOMAS WATSONの学位論文、最初の部分は解説。
- http://www.math.utah.edu/~margalit/papers/pure-braids.pdf -- GEOMETRIC PRESENTATIONS FOR THE PURE BRAID GROUP ;絵がきれい。円盤の写像を使う。
- http://caislab.icu.ac.kr/Paper/paper_files/2004/SCIS04/scis2004%20-%20zeenkim.pdf ;ブレイドと暗号セキュリティ
- http://www.math.columbia.edu/~jb/slvcb-i.pdf -- STUDYING LINKS VIA CLOSED BRAIDS I: A FINITENESS THEOREM ;Birmanなどの歴史的論文
- http://citeseer.ist.psu.edu/karowski93combinatorial.html -- A Combinatorial Approach to Topological Quantum Field Theories and Invariants of Graphs ;Turaev式の組み合わせ論、具体的な計算。行間あきすぎ。60ページ以上。

カウフマンも多くの解説を書いている。

- http://citeseer.ist.psu.edu/497874.html -- Knots ;これはいい入門資料、絵がすばらしい。

こんなんもある。カウフマン、間口が広すぎ。

- http://citeseer.ist.psu.edu/629713.html -- Time, Imaginary Value, Paradox, Sign and Space
- http://citeseer.ist.psu.edu/kauffman01mathematics.html -- The Mathematics of Charles Sanders Peirce (2001)

*1157599489*[メモ法]URLにはコメント

URLだけを並べたリンク集は後で困る。短くてもいいからコメントを。

</body>
</day>
<day date="2006-09-08" title="">
<body>
*1157672503*[メモ法]それは忘れるぞ

なんだか忘れそう、と思ったものはたいていホントに忘れる。しんどくてもメモ。

*1157705529*[雑記]忘れそうなこと！マルコフ定理、テンプレート言語

- ブレイドのマルコフの定理は、ステファネスクの酵素公理や長谷川の一様性原理と関係あると思う。
- 昔、僕は、再帰方程式系のx=x、{x=x', x'=x} の扱いに困っていたが、マルコフの定理と関係するだろう。
- テンプレート言語＝テンプレートインスタンスの集合は、べき級数で表現できる。これは、クリーネ／フォック構成にもなっている。二進木のクレイジー計算とかとも関係する。
- 無音記号が時の刻みだと思った件。

*1157706613*[トレース／コンパクト閉圏]行列のトレースの性質をやっと納得

カウフマンの&quot;Knots&quot;（http://citeseer.ist.psu.edu/497874.html）のfigure38を見てやっと納得した。

f:1×X→1×Xに対して、tr(f) = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;1,1&lt;/sub&gt;(f)と定義すると、自己射の全トレースが定義できる。tr(f)の値はいわゆるスカラー射（1→1のこと）になる。id&lt;sub&gt;X&lt;/sub&gt;の全トレースは（圏論的）次元（categorical dimension）というやつだ。

tr(f;g) = tr(g;f) は、行列のトレースで出会うが、これは全然わからなかったな。計算しても納得いかなかった。f;g = Tr[(f×g);σ] を使うとわかる。詳細はともかくとして：
&lt;pre&gt;
    tr(f;g)
  = tr(Tr[(f×g);σ])
  = Tr(Tr[(f×g);σ]) // バニッシングを使って
  = Tr[(f×g);σ] // ×の対称性
  = Tr[(g×f);σ] 
  = Tr(g;f)
  = tr(g;f)
&lt;/pre&gt;

絵算を使うと明白。tr(f;g) = tr[(f×g);σ]だから、コンパクト閉圏では、η;(f×g);ε と書けるのじゃないのかな？（&lt;b&gt;η';(f×g*);εでした。&lt;/b&gt;） だとすると、tr(f;g)ってのは、fとgから作ったサークルだな。サークルはスカラーになるのか？ だとすると、カウフマンブラケットやテンパリー／リーブ代数でサークルがスカラー乗法になるのが少しは説明できるかも。スケイン関係式はそれでも謎だが。


</body>
</day>
<day date="2006-09-12" title="">
<body>
*1158031282*[からみ系][トレース／コンパクト閉圏]ライデマイスター、トゥラエフ、マルコフの移動

カウフマン（Kauffman;http://www.math.uic.edu/~kauffman/）の本（ISBN:4563002372:title）と小島さんの本（ISBN:4254116020:title）をもとにして記述する。カウフマンP.11と、小島P.148, 149の図を比較する。

まず、トゥラエフ移動はライデマイスター移動を完全に含むことに注意。通常、ライデマイスター移動は、I, II, IIIと番号が付けられるが、カウフマンは移動0を加えている。トゥラエフ移動は3次元タングルを2次元に射影した図（タングル図）に関するもの、ライデマイスター移動は結び目の射影図に関するものだが、事情はよく似ている。

小島本の図からわかるように、トゥラエフ固有の移動は、一般のモノイド圏で成立する縦スライド（トレース付きモノイド圏の公理に「スライディング」があるので、用語「シフト」が適切だろう）、交差と極大点の交換、ジグザグ公式。ジグザグ公式はライデマイスター移動0だから、実際は交差（クロッシング）と極大点（ベント、ターニング）の交換だけが、トゥラエフ固有の移動である。

一応、トゥラエフ移動を列挙してみる。σとσ'は符号が逆な交差（クロッシング）である。

+ id;f = f, f;id = f に対応する2つの縦スライド
+ (f + id);(id + g) = (id + f);(g + id)に対応する縦スライド
+ ジグザグ公式に対応する2つの移動（ライデマイスター移動0）
+ (1 + ε);(σ + 1) = (ε + 1);(1 + σ')、(1 + ε);(σ' + 1) = (ε + 1);(1 + σ) に対応するトゥラエフ固有の移動。
+ ライデマイスター移動I -- ヤンキング
+ ライデマイスター移動II -- σσ' = 1 （ブレイドの逆元）
+ ライデマイスター移動III -- アルチンのブレイド関係式

トゥラエフに固有の移動は、「⊂」形のマンナカ（極点）を直線を貫いた形をどのように表現するか、それらの表現バリアントが等しいことを示す。（次の図）

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/proper-turaev-move.gif&quot; &gt;
&lt;/div&gt;

ライデマイスター移動IIは、90度回転して(?)見ると、重なった（だが、からんでない）「⊃」と「⊂」を引き離す移動にも見える。2つのクロスと重なった（からむ、からまない）ベントは同じとはこういうことか。（左右の親指人差し指で実験できる。）

以下は、特異点（尖点、二重接点、三重点）と関連させたライデマイスター移動の図。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/singulars-and-moves.gif&quot; &gt;
&lt;/div&gt;

&lt;hr&gt;
次は&lt;strong&gt;マルコフ移動&lt;/strong&gt;。

マルコフ（Markov）は、ブレイド閉包を考察したわけだが、閉包をとって同じからみ目になるブレイドがどんな関係かをみる。つまり、Cl(b) = Cl(b')なとき、bとb'にはどんな関係があるか？

+ bとx'bxは閉包が同じになる。x'はxの逆元。
+ bと(b + 1);((n-1) + σ)は閉包が同じになる。σは交差。

1番目は、トレースのスライディングを使えば明らか。2番目はタイトニングしてからヤンキングすればわかる。つまり、トレース付きモノイド圏の公理から出る。

マルコフ移動は、ブレイド圏における同値関係を生成する基本関係式だと捉えてよい。

*1158031283*[トレース／コンパクト閉圏]酵素公理、一様性原理

f:A×X→B×X, g:A×Y→B×Y がトレースを取ったとき等しくなる、つまり、Tr&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sup&gt;Y&lt;/sup&gt;(g) について考える。u:X→Yがあって、f;(B + u) = (A + u);g がその条件になるときがある。推論規則で書くなら：

&lt;pre&gt;
 f;(B + u) = (A + u);g : A×X→B×Y
 ------------------------------------
 Tr&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sup&gt;Y&lt;/sup&gt;(g)
&lt;/pre&gt;

この形式の推論を酵素公理とか一様性原理による推論と呼ぶ。

トレース付きモノイド圏Cと射の属U⊆Cが「酵素公理（一様性原理）を満たす」とは、u∈Uに対して、上の推論が妥当であること。実際には、Cに対してUを探して、推論の妥当性を(C, U)に関する定理として示す必要がある。Uは部分圏である必要はないが、同型射はUに含まれる。Uの射は酵素射とか厳密射／一様射と呼ぶ。→[http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528:title]

一方で、既存の定理が酵素公理になっていることもある。オートマトンの最小化（マイヒル／ネロード型の定理）や、振る舞い同値と双模倣などが例になっているようだ。振る舞い関手と振る舞い正規化（notion of behaviour)も関係するだろう。→[http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943257:title]

*1158031284*[課題]セリンガーの論文

セリンガーの&quot;Categorical Structure of Asynchrony&quot;（→http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf）は、面白いトピックがいろいろ載っているので、まとめる必要がある。

+ コンパクト閉圏の公理の簡略化：7つから4つになる。バニッシングがなくなり、スライディングは対称についてだけ。Alan Jeffrey &quot;Flow graphs and semantics of programs&quot;の付録に証明があるようだ。
+ T構成：木下のべき構成をうんと一般化したようなもの。enriched settingで使う。一般化ベキ構成と言ってよいだろう。
+ 線形／アフィン／連関（relevant）関手：T構成に伴って、関手の性質を定義している。


*1158031285*[リンク][TQFT][その他代数]TQFTとフロベニウス代数

ティルマン（Ulrike Tillmann） &quot;COMBINATORICS OF THE SURFACE CATEGORY AND TQFTS&quot;（http://www.hindawi.com/books/977594502X/B977594502X000230.pdf）に：
&gt;&gt;
The following theorem is folklore and can be proved as an exercise.
&lt;&lt;
として、(1+1)コボルディズム圏がそのフロベニウス代数で決まることが書いてあるが、exerciseで出来るわけもない。幸いに次に説明されている。（[http://d.hatena.ne.jp/m-hiyama-memo/20060803/1154597217:title]も参照）

- Lowell Abrams &quot;Two-Dimensional Topological Quantum Field Theories And Frobenius Algebras&quot;（http://citeseer.ist.psu.edu/350217.html）

次はティルマン自身の解説だが、ページの最終行は欠けているし、図はないし、読みにくい。

- Ulrike Tillmann &quot;S-Structures for k-linear categories and the definition of a modular functor&quot;（http://arxiv.org/abs/math/9802089）

次は120ページ超の論説だが、TQFTの総論としてもナカナカいい。2章だけ印刷した。

- H.B. Posthuma &quot;Quantization of Hamiltonian loop group actions&quot;（http://remote.science.uva.nl/~npl/proefschrift.pdf）

*1158031286*[トレース／コンパクト閉圏]リボン圏、プレ・リボン圏

H.B. Posthuma &quot;Quantization of Hamiltonian loop group actions&quot;（http://remote.science.uva.nl/~npl/proefschrift.pdf）を見てのまとめ／雑感。

数理物理だと、モノイド圏を&lt;strong&gt;テンソル圏&lt;/strong&gt;と呼ぶことが多いようだ。特に、対象がベクトル空間の時はそう呼ぶ。ブレイド付きテンソル圏（モノイド圏）は、ブレイディング自然変換βを持ったテンソル圏。βとその逆β'によりブレイドが生じる。ブレイディングの公理は次：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/braiding-axioms.gif&quot; &gt;
&lt;/div&gt;

βとβ'が等しいとき、ブレイディングは対称（symmetric braiding）に退化する。

テンソル（モノイド）圏において、各対象VごとにV*、η&lt;sub&gt;V&lt;/sub&gt;:1→V×V*、ε&lt;sub&gt;V&lt;/sub&gt;:V*×V→1 があり、(V, V*, η&lt;sub&gt;V&lt;/sub&gt;, ε&lt;sub&gt;V&lt;/sub&gt;)がジグザグ公式（三角恒等式、剛性恒等式）を満たすとき、剛（リジット）テンソル圏と呼ぶ。

V|→V*を可逆関手とする定義もある。このとき(-)*の逆を*(-)と書く。定義より、*(V*) = (*V)* = V である。剛性の定義は、コンパクト閉性と同じで、数理物理や幾何学の剛テンソル圏とは、結局（多少の揺らぎはあるが）コンパクト閉圏である。

リボン圏（ribbon category）は、剛ブレイド付きテンソル圏にひねり同型（twist isomorphism）を加えた構造である。しかし、双対（随伴）と剛性はなくてもひねり（ツイスト）は定義できる。そこで、ブレイド付きモノイド圏にひねり同型を加えてプレ・リボン圏が定義できる。ひねりの公理は：

- θ&lt;sub&gt;X,Y&lt;/sub&gt; = (θ&lt;sub&gt;X&lt;/sub&gt;×θ&lt;sub&gt;Y&lt;/sub&gt;);β&lt;sub&gt;Y,X&lt;/sub&gt;;β&lt;sub&gt;X,Y&lt;/sub&gt;;

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/twist-axiom.gif&quot; &gt;
&lt;/div&gt;


ちなみに、リボン圏では θ&lt;sub&gt;X*&lt;/sub&gt; = (θ&lt;sub&gt;X&lt;/sub&gt;)* を付け加える。

双対*が存在するなら、半ひねりをρとして、ρの逆ρ'を使って、次のように定義するのもいいように思う。

- ρ&lt;sub&gt;X,Y&lt;/sub&gt; = (ρ&lt;sub&gt;X&lt;/sub&gt;×ρ'&lt;sub&gt;Y&lt;/sub&gt;);β&lt;sub&gt;Y*,X*&lt;/sub&gt;

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/half-twist-axiom.gif&quot; &gt;
&lt;/div&gt;

*1158031287*[用語法]flip functor

C×C→C×C; (X, Y)|→(Y, X) で定義される関手は入れ替え関手（flip functor）と呼ぼう。swap, transposeなどは他用途にとっておく。

*1158031288*[プログラム意味論]ラベル付き遷移系

A, Bなどをアルファベット（ラベル集合）として、S, Tなどを、それぞれA, Bラベル付き遷移系とする。S, Tの状態空間はX, Yとする。S+T, S×T, S#T を次のように定義できる。

|* 系 |*アルファベット |*状態空間 |
|S + T| A∪B | X + Y |
|S×T | A + B | X×Y |
|S＃T | A×B  | X×Y |

無音記号、初期状態などを考えるとどうなるか？

</body>
</day>
<day date="2006-09-13" title="">
<body>
*1158107334*[メモ法]印刷済みを表記

論文への参照は、印刷したかどうか書いておいたほうがいい。

*1158117183*[圏一般論][プログラム意味論]コピー可能性、対称の入れ替えは自然性、

Cがモノイド圏として、C→Cの関手IとDを、Iは恒等、D(X) = X×Xとする。δ::I⇒D が自然変換であるためには：

- δ&lt;sub&gt;X&lt;/sub&gt;;(f×f) = f;δ&lt;sub&gt;Y&lt;/sub&gt;

これは、fが分岐δに関してコピー可能の条件と同じ。

C×C→C×Cの関手JとFを、Jは恒等、Fはフリップとする。σ::J⇒F が自然変換であるためには：

- σ&lt;sub&gt;X,Y&lt;/sub&gt;;(g×f) = (f×g);σ&lt;sub&gt;U,V&lt;/sub&gt;

これはσが対称である条件の1つ。

ところで、Δ&lt;sub&gt;X+Y&lt;/sub&gt; = (Δ&lt;sub&gt;X&lt;/sub&gt; + Δ&lt;sub&gt;Y&lt;/sub&gt;);(X + σ + Y) はどう説明する？？

*1158134735*[形式言語理論][プログラム意味論]ω完備順序半環上のベキ級数の圏

Rが順序半環で、「上昇ω列の極限が常に存在する」という意味で完備とする。Xが集合として、R&amp;#91;[X&amp;#93;]を形式ベキ級数の半環とする。型式ベキ級数fで、出現する変数（Xの元）が有限で、f(1)が上昇ω列を定義するようなもの全体をR([X])とする。

Yの有限部分集合で定義されたF:Y⊃→R([X])をF:X→Yとみなす圏ができるだろう。これを示すには、X|→R([X])がモナドであることを示すのが早い。

この例は、ツリーのテンプレート集合と密接に関係するが、大幅に一般化できそうな気がする。半環の代わりに圏を考えて、多項式関手の拡張としての解析関手を定義できるだろう。

*1158136329*[リンク][TQFT]絵が素晴らしい論文

- &quot;Topological and conformal field theory as Frobenius algebras&quot; Ingo Runkel, Jens Fjelstad, J¨urgen Fuchs, and Christoph Schweigert →http://www.mth.kcl.ac.uk/staff/i_runkel/PDF/canb.pdf

絵が素晴らしい。印刷した。


</body>
</day>
<day date="2006-09-16" title="">
<body>
*1158384373*[説明][janus]ブラックなもの

- ブラックボックス（外から中を見て）
- ブラックルーム（中から外を見て）
- ブラックウォール（外と中を対等に考えて）

*1158384374*[説明][トレース／コンパクト閉圏]方陣行列から二部グラフへ

- 普通の2×2行列とかで、各成分を乗法作用の射とみなす。
- 4つの射（成分）と、対角、余対角（加法）を使って、行列を回路として表現する。
- トポロジカルに変形して、行列の二部グラフ表示を得る。

ここでも、Δ&lt;sub&gt;X+Y&lt;/sub&gt; = (Δ&lt;sub&gt;X&lt;/sub&gt; + Δ&lt;sub&gt;Y&lt;/sub&gt;);(X + σ + Y)がミソ。

*1158384375*[トレース／コンパクト閉圏]3次元的な図式

トレース、対称またはブレイドによる交差、Kelly単位を3次元方向に描くと、図がスッキリすると思う。トポロジカルにも何か面白そうだし。

*1158386447*[論理][janus]janusのシーケント計算

参考：

- [http://d.hatena.ne.jp/m-hiyama-memo/20060727/1153975058:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060817/1155784829:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060819/1155979043:title]

janusコンポネントのプロファイルは、「ポート名:ポート型」を使って、
- {a1:A1, ..., an:An ; b1:B1, ..., bm:Bm}⇒{x1:X1, ..., xs:Xs ; y1:Y1, ..., yt:Yt}

と書ける。これはまた、次のようにも書ける。

- +a1:A1, ..., +an:An, -b1:B1, ..., -bm:Bm ⇒ +x1:X1, ..., +xs:Xs, -y1:Y1, ..., -yt:Yt

次のような推論で、プロファイル＝シーケントの計算が出来るだろう。なお、前件、後件はそれぞれ、フロントフェイス、バックフェイスと呼ぶ。
&lt;pre&gt;
 Γ, ±a:A Δ ⇒ Φ
 ----------------------[左改名]
 Γ, ±x:A, Δ ⇒ Φ（x!∈|Γ|∪|Δ|）

 Γ ⇒ Φ, ±a:A, Ψ
 ----------------------[右改名]
 Γ ⇒ Φ, ±x:A, Ψ （x!∈|Φ|∪|Ψ|）

 Γ ⇒ Φ   Δ ⇒ Ψ
 --------------------[mix]
 Γ, Δ ⇒ Φ, Ψ （|Γ|∩|Δ| = |Φ|∩|Ψ| = 空）

 Γ, Δ ⇒ Φ, Δ
 -----------------[trace cut]
 Γ ⇒ Φ

 Γ ⇒ Δ, Σ   Σ, Φ ⇒ Ψ
 ----------------------------[traditional cut]
 Γ, Φ ⇒ Δ, Ψ

 Γ⇒A,Δ
 ----------[*導入 左]
 A*,Γ⇒Δ

 Γ,A⇒Δ
 ----------[*導入 右]
 Γ⇒Δ,A*
&lt;/pre&gt;

</body>
</day>
<day date="2006-09-21" title="">
<body>
*1158796495*[雑記]有向グラフの指数（exponentiation）をもっと調べる

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060921/1158795968&quot;&gt;「有向グラフの指数（exponentiation）」&lt;/a&gt;の続き。A&lt;sup&gt;A&lt;/sup&gt;が&lt;strong&gt;3頂点6辺&lt;/strong&gt;だという別な状況証拠を示します。当該のAは、2頂点3辺（うち非自明な辺は1本）の反射的有向グラフ（を指す固有名詞）でした。Aはまた、二元集合を台集合（underlying set）とする線形順序構造ともみなせました。

&lt;h5&gt;辺集合と頂点集合はホムセットで表現できる&lt;/h5&gt;

反射的有向グラフの圏をRDGとして、任意のグラフBに対してホムセットRDG(A, B)を考えましょう。f∈RDG(A, B)は、f(s), f(a), f(t)で決まるBの辺を特定します。逆に、Bの辺e:x→yがあれば、f(s) = x, f(a) = e, f(t) = y として射f:A→Bが決まるので、RDG(A, B) ＝ Edge(B) 。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/map-edge.gif&quot; &gt;
&lt;/div&gt;

A&lt;sup&gt;A&lt;/sup&gt;がRDG内に存在すると仮定して、特にBをA&lt;sup&gt;A&lt;/sup&gt;にすれば：

- RDG(A, A&lt;sup&gt;A&lt;/sup&gt;) ＝ Edge(A&lt;sup&gt;A&lt;/sup&gt;) ……(edge)

Aの代わりに、1頂点1辺の自明なグラフをIとすると、RDG(I, B) ＝ Node(B) が得られます。BをA&lt;sup&gt;A&lt;/sup&gt;にすれば：

- RDG(I, A&lt;sup&gt;A&lt;/sup&gt;) ＝ Node(A&lt;sup&gt;A&lt;/sup&gt;) ……(node)

等式（つうより同型式）(edge)と(node)から、A&lt;sup&gt;A&lt;/sup&gt;の辺集合と頂点集合は、特別なホムセットRDG(A, A&lt;sup&gt;A&lt;/sup&gt;)とRDG(I, A&lt;sup&gt;A&lt;/sup&gt;)で与えられることがわかりました。で、RDG(A, A&lt;sup&gt;A&lt;/sup&gt;)とRDG(I, A&lt;sup&gt;A&lt;/sup&gt;)を探ることにします。

&lt;h5&gt;補題としてクイズを解いておこう&lt;/h5&gt;

直積グラフA×Aを作ると、下図の左のようになりますが、それは、順序集合としては“いわゆるダイヤモンド束”と同型です。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/diamond-lattice.gif&quot; &gt;
&lt;/div&gt;

上記の四元ダイヤモンド束をDとして、次のクイズ問題を考えます； Dを、D = D&lt;sub&gt;0&lt;/sub&gt; + D&lt;sub&gt;1&lt;/sub&gt; と直和に分解する。このとき、x∈D&lt;sub&gt;1&lt;/sub&gt;, y∈D&lt;sub&gt;0&lt;/sub&gt;、x ＜ y となるようなx, yが生じないような分解は何通りあるか？ つまり、D&lt;sub&gt;1&lt;/sub&gt;のメンバーがD&lt;sub&gt;0&lt;/sub&gt;のメンバーの下に来るのを許さないようなD&lt;sub&gt;0&lt;/sub&gt;, D&lt;sub&gt;1&lt;/sub&gt;への分割法を列挙してください。

答えは&lt;a href=&quot;http://www.chimaira.org/img/diamond-partitioning.gif&quot;&gt;コチラ&lt;/a&gt;。

&lt;h5&gt;そういう分割は単調写像と同じこと&lt;/h5&gt;

さてと、Aの二元を一時的に便宜上{0, 1}（sを0, tを1）として、四元ダイヤモンド束Dから二元線形順序集合Aへの単調写像fを考えます。逆像f&lt;sup&gt;-1&lt;/sup&gt;(0)、f&lt;sup&gt;-1&lt;/sup&gt;(1)をそれぞれD&lt;sub&gt;0&lt;/sub&gt;、D&lt;sub&gt;1&lt;/sub&gt;とすると、上のクイズ問題の条件を満たします。正確に言うと：

- 単調写像f:D→A と、上のクイズ問題の条件を満たす分割 D = D&lt;sub&gt;0&lt;/sub&gt; + D&lt;sub&gt;1&lt;/sub&gt; は一対一に対応する。

このことは、∀x, y∈D.[x ≦ y ⇒ f(x) ≦ f(y)] をゴニョゴニョして、￢(∃x, y∈D.[x ＜ y ∧ f(x) = 1 ∧ f(y) = 0]) まで変形、とその逆ができればいいですね。

&lt;h5&gt;もし、積とベキの随伴が使えれば、辺集合がわかる&lt;/h5&gt;

ここで、圏RDG上の自己関手について考察。“Aを直積で掛け算する関手(-)×A”と、“Aをベキ指数に載せる関手(-)&lt;sup&gt;A&lt;/sup&gt;”が、もし随伴ならば、任意のグラフG, Hに対して次の同型があるはずです。

- RDG(G×A, H) ＝ RDG(G, H&lt;sup&gt;A&lt;/sup&gt;)

特に、G = H = A と置けば：

- RDG(A×A, A) ＝ RDG(A, A&lt;sup&gt;A&lt;/sup&gt;)

A×A ＝ D （Dはダイヤモンド束）だったので、RDG(A×A, A) ＝ RDG(D, A)。RDGにおける射f:D→Aは、順序構造の単調写像とみなしてよいので：

- RDG(A×A, A) ＝ RDG(D, A) ＝ Monoto(D, A) ＝ {D&lt;sub&gt;1&lt;/sub&gt;がD&lt;sub&gt;0&lt;/sub&gt;の下に来ないようなDの分割}

この等式（同型式）の最後の集合は&lt;a href=&quot;http://www.chimaira.org/img/diamond-partitioning.gif&quot;&gt;クイズの答え&lt;/a&gt;から6元でした。

右辺であるRDG(A, A&lt;sup&gt;A&lt;/sup&gt;)は、(edge)から Edge(A&lt;sup&gt;A&lt;/sup&gt;)だったので、随伴の同型RDG(A×A, A) ＝ RDG(A, A&lt;sup&gt;A&lt;/sup&gt;) は：

- Monoto(D, A) ＝ Edge(A&lt;sup&gt;A&lt;/sup&gt;)

と解釈できます。そんなわけで、Edge(A&lt;sup&gt;A&lt;/sup&gt;)が6元であるとわかりました。

&lt;h5&gt;頂点集合もわかる&lt;/h5&gt;

もう一度、随伴の同型に戻って：

- RDG(G×A, H) ＝ RDG(G, H&lt;sup&gt;A&lt;/sup&gt;)

G = I、H = A と置けば：

- RDG(I×A, A) ＝ RDG(I, A&lt;sup&gt;A&lt;/sup&gt;)

右辺は冒頭の(node)から、Node(A&lt;sup&gt;A&lt;/sup&gt;)ですが、左辺RDG(I×A, A)はRDG(A, A) ＝ Monoto(A, A)、よって：

- Monoto(A, A) ＝ Node(A&lt;sup&gt;A&lt;/sup&gt;)

&lt;h5&gt;まとめると&lt;/h5&gt;

A&lt;sup&gt;A&lt;/sup&gt;の辺集合、頂点集合は、それぞれ Monoto(D, A)とMonoto(A, A)で与えられます。これらは6元、3元。

ただし、圏RDGで、Aによる積とベキが存在して随伴であることを仮定しているので、ホントに随伴であることを確認する必要があります。積因子／べき指数をAに限れば、それほど難しくはないでしょう。


</body>
</day>
<day date="2006-09-23" title="">
<body>
*1158990074*[janus]手抜きコンポネント・コーディング

ポートベース・コンポネントを書くときに、できるだけコーディング量を減らすには：

- すべてフィールド方式を使う。

それが無理なときは：

+ セッターが必要なポートが少数（1個か2個）なら、そこだけセッターにする。
+ セッターの使用が多いなら、混乱を避けるために全部セッターにする。
+ ゲッターは作らなくてよい（フィールドでよい）。

ワイヤリングは、&lt;code&gt;h.printer = p.printer;&lt;/code&gt;か、&lt;code&gt;h.setPrinter(p.printer);&lt;/code&gt;のどちらか。

セッターは：

+ 利用者を信じて、引数チェックはしない。
+ ポートの利用回数（1回だけ）とかのチェックもしない。
+ どうにもならないときは、捕捉可能例外ではなくてランタイム例外を投げる。（ワイヤリング時にtry/catchが不要。）

特別なメカニズムを使わずに手書きでポートとワイヤリングを書いたときは、アノテーションは“人間にとってのメモ”として以外に使われないので、コメントにしてしまってもよい。（importを減らせる。）

&lt;pre class=&quot;code&quot;&gt;
/* @Require */
public void setHoge(Hoge hoge) {
 // ...
}
&lt;/pre&gt;
</body>
</day>
<day date="2006-09-30" title="">
<body>
*1159582102*[janus][まとめ]全体的な構造と定式化

+ ソフトウェア的な技法
+ 圏論的な解釈
+ 論理計算
+ ラムダ計算
+ 具体的なモデル

ソフトウェア的な技法としては、とりあえずはコンベンションと動的（実行時）演算ライブラリだけを準備して、徒手空拳でも使えることをアピールしよう。もちろん、コンテナ（自動的な生成／初期化／ワイヤリング）、シェル（対話的な操作環境）、デザインツールがあったほうが便利なんだけど手が回らん。

圏論としては、トレース付きモノイド圏とそのInt構成であるコンパクト閉圏が基本。ただし、多圏を使った方が見通しがいいことがわかったので、トレース付きモノイド多圏、コンパクト閉多圏を入れたい。Cがトレース付きモノイド圏だとして、D = Int(C)、さらに多圏Poly(C)、Poly(D) = Poly(Int(C)) = Int(Poly(C)) を考える。ひょっとすると、ステファネスクが構想する&lt;strong&gt;doubly-traced &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060817/1155783593&quot;&gt;semiringal&lt;/a&gt; category&lt;/strong&gt;が出てくるのかも知れない。

多圏化するときには、列（sequence, string）多圏だけでなくレコード多圏も必要で、対称亜群（symmetric groupoid）が働く対称多圏と同様に、改名亜群（renaming/permutation groupoid）が働く亜群作用付き多圏を定義しておくとよさそう。亜群作用の部分が、コネクター（と呼ばれるもの）になる。

論理計算は、基本的にPoly(Int(C))をモデルとするシーケント計算。最終的には、トレース付きモノイド圏／コンパクト閉圏での解釈をする。線形論理の部分系になるだろうが、どんな部分系かはよくわからん。

ラムダ計算は、コンパクト閉圏上のウエス（上江州）計算となるだろう。ベースとして、（CCCとは限らない）モノイド閉圏におけるラムダ計算が必要。閉性からf:A,B→Cのカリー化f^:A→[B,C]は定義できるが、変数を伴ったラムダ抽象をうまく定義するにはウエス・トリックが必要そうだ。

具体的なモデルは、ラベル付き遷移系の拡張である遷移変換系（トランスデューサ）の圏だ。これは、一種の対話圏（interaction category）だろう。この圏は、荷電境界付きグラフの圏と深く関係しているはずだ。それを拡張オートマトンとみなせば（例えばXMLの）構文論とも繋がると思われる。

*1159583471*[janus][用語法]暫定案

「フェース」じゃなくて「フェイス」にした。

- フェイス：コンパクト閉圏における域、余域
- フロントフェイス：域
- バックフェイス：余域
- ユーザーサイド： フロントフェイスと同じ
- クライアントサイド： ユーザーサイドと同じ
- プラットフォームサイド： バックフェイスと同じ
- サーバーサイド ：プラットフォームサイドと同じ
- データ（ボックス） ： 1→A の形の射（1はモノイド単位）
- サービス（ボックス） ： A→1 の形の射
- シンプルサービス（ボックス）: サービスであり、ポートがマイナス1個だけの射（ボックス）。
- レイヤー ： トゥラエフの輪切り（スライス）
- クラスター ：ワイヤリングされたボックスの集まり
- （クラスター／ワイヤリング）スキーム：ボックスのプレイスホルダー（記号的ボックス）を含むクラスター

*1159588376*[リンク]バカキリ本

Bojko Bakalov, Alexander Kirillov &quot;Lectures on Tensor Categories and Modular Functors&quot;

- http://www.amazon.co.jp/gp/product/0821826867

キリロフ（Kirillov）の講義がベース、バカロフ（Bakalov）は受講者だろう。

</body>
</day>
<day date="2006-10-02" title="">
<body>
*1159747780*[メモ法]守れていないこと

+ 「まとめ」を入れよう。
+ 出典を明らかに、特に非オンラインな文献。
+ 参照（リンク）には著者とコメント、印刷ページ数、印刷したかどうか、を入れる。
+ 過去の関連エントリーにはできるだけリンク。
+ ダイアリーブックでは画像が落ちることを意識したほうがいい。

*1159750282*[からみ系]トゥラエフ主移動とクロスオーバー公式

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031282&quot;&gt;トゥラエフ移動&lt;/a&gt;は、細かく分類すれば1ダースある。が、特有な移動は次の図で示すものだ。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/turaev-main.gif&quot; &gt;
&lt;/div&gt;

これを&lt;strong&gt;トゥラエフ主移動&lt;/strong&gt;と呼ぶことにする。極大点＋二重（交差）点という特異点の解消に対応する。

※ トゥラエフ→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%c8%a5%a5%a5%e9%a5%a8%a5%d5

一方、コンパクト閉圏で一般的に証明できるクロスオーバー公式がある（下）。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/crossover.gif&quot; &gt;
&lt;/div&gt;

この2つが同値であることを示す。

トゥラエフ主移動を仮定すると、次の図がクロスオーバー公式に対応している。左の図から中央の図に行くときにトゥラエフ主移動を使っている。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/turaev2crossover.gif&quot; &gt;
&lt;/div&gt;

クロスオーバー公式を使ってトゥラエフ主移動を示すにのは次。中央から右図に行くときにクロスオーバー公式。

&lt;div class=&quot;fig&quot;&gt;
  &lt;img src=&quot;http://www.chimaira.org/img/crossover2turaev.gif&quot; &gt;
&lt;/div&gt;

*1159781118*[課題]絵算関係

6月に書いていた以下のようなエントリー。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060614&quot;&gt;6月14日 絵算でゴー&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060616/1150425654&quot;&gt;6月16日 トレースの再現&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060620/1150785000&quot;&gt;6月20日 Kozen圏のスターとトレース&lt;/a&gt;

なんらかの形にまとめておいたほうがいいと思う。


</body>
</day>
<day date="2006-10-03" title="">
<body>
*1159847522*[トレース／コンパクト閉圏]トレース分解定理：概略

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060621/1150871144&quot;&gt;「繰り返しx*と強い繰り返しx+、長谷川の不動点補題」&lt;/a&gt;で言及した定理を&lt;strong&gt;トレース分解定理&lt;/strong&gt;と呼ぶことにする。かなり一般的／周知の事実なので、個人名を冠するのはふさわしくない、と思い直した。

さて、このトレース分解定理によれば、デカルト圏のトレースはトランスデューサであることが分かる。双対的に、余デカルト圏のトレースは余トランスデューサである。これから、Elgotダガー／ElgotオートマトンとConwayダガー／Conwayオートマトン（簡易トランスデューサ）の双対性も従う。トレース分解定理は、トレース付き（余）デカルト圏の構造を具体的に決定してしまう。

&lt;h5&gt;トレース付きデカルト圏の基本&lt;/h5&gt;

ここでいうデカルト圏とは、極限としての終対象／直積を持つ圏というよりは、等式的に定義されるΔ（対角射、重複器）と⊥（弱終射、放電器）を持つ対称モノイド圏である。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528&quot;&gt;セリンガーによるcategory with diagonals&lt;/a&gt;、あるいはGSモノイド圏などと同じ定式化だ。Δと⊥はコモノイドの族を定義して、さらにすべての射はコピー可能／破棄可能であるとする。

射影をπ&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;のように書くとして、f:X→A×Bに対して、f&lt;sup&gt;1&lt;/sup&gt; = f;π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;:X→A などと書く。デカルト圏では次の表現が得られる。

- f = &amp;lt;f&lt;sup&gt;1&lt;/sup&gt;, f&lt;sup&gt;2&lt;/sup&gt;&gt; = Δ;(f&lt;sup&gt;1&lt;/sup&gt;×f&lt;sup&gt;2&lt;/sup&gt;)

これを絵に描いてルーピングさせるとトレースの表現が得られる。

Conway不動点との関係を見るためには次の絵算を使う。ループ、分岐、交差を持つ図から、分岐をループに沿ってスライドさせて交差を取り除く操作である。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/sliding-diagonal.gif&quot; &gt;
&lt;/div&gt;

*1159883762*[トレース／コンパクト閉圏]トレース分解定理：詳細

&lt;h5&gt;定理の記述&lt;/h5&gt;

Cがトレース付きデカルト圏として、Cにおけるf:A×X→B×YのトレースTr(f)は、次のように分解した形で書ける。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/trace-decomposition.gif&quot; &gt;
&lt;/div&gt;

fの第一射影f&lt;sup&gt;1&lt;/sup&gt;をf&lt;sub&gt;out&lt;/sub&gt;（出力関数）、fの第二射影f&lt;sup&gt;2&lt;/sup&gt;をf&lt;sub&gt;tran&lt;/sub&gt;（遷移関数）とすると、Tr(f)は、f&lt;sub&gt;tran&lt;/sub&gt;の不動点であるf&lt;sub&gt;loop&lt;/sub&gt;とf&lt;sub&gt;out&lt;/sub&gt;の和（に近い形）で書ける。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/loop-and-out.gif&quot; &gt;
&lt;/div&gt;

&lt;h5&gt;証明&lt;/h5&gt;

fを、第一射影f&lt;sub&gt;out&lt;/sub&gt; = o と第二射影f&lt;sub&gt;tran&lt;/sub&gt; = tに分けて、多少変形しておく。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/out-tran-pair.gif&quot; &gt;
&lt;/div&gt;

この状態でトレースを取って、目的の形に変形する。

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/deforming-fixpoint.gif&quot; &gt;
&lt;/div&gt;

2番目から3番目への変形を詳細に述べれば：

&lt;div class=&quot;fig&quot;&gt;
 &lt;img src=&quot;http://www.chimaira.org/img/deformation-detail.gif&quot; &gt;
&lt;/div&gt;

+ 対角を、スライディングで移動する。
+ X×Xの（リボン状）ループをバニッシングで分割して、内側をタイトニングで縮める。
+ 点線で囲った箱を巻いている部分をほどく。→[http://d.hatena.ne.jp/m-hiyama-memo/20060617/1150515090:title]


</body>
</day>
<day date="2006-10-04" title="">
<body>
*1159920500*[トレース／コンパクト閉圏]f&lt;sup&gt;*&lt;/sup&gt;の展開公式

※ここでは、f∨g = Δ;(f + g);∇ とする。

f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt; を絵算で示すときに、どうも次の公式が必須なようだ。

- ∇;Δ =  (Δ+Δ);(1+σ+1);(∇+∇)

□≡(Δ+Δ);(1+σ+1);(∇+∇) と置けば、

- ∇;Δ =  □

∇;Δ = □は、双代数（Δと∇を持つ代数）の公理だったりもする。η、εが単位、余単位だとして、η;Δ = Δ;(η + η), ∇;ε = (ε + ε);∇ も双代数の公理だが（→http://arxiv.org/abs/q-alg/9510013）、他から出そうだ。ちなみに、ベキ等性は Δ;∇ = 1、フロベニウス代数の基本公理は、∇;Δ = (Δ + 1);(1 + ∇)。

それで：

- f&lt;sup&gt;*&lt;/sup&gt; = Tr[(1+Δ);(σ + f);(1 + ∇)]
- f&lt;sup&gt;*&lt;/sup&gt; = Tr[(1+f);□] = Tr[□;(1+f)]
- f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ Tr(∇;f;Δ) = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt;

∇;Δ =  □ を公理とすれば、これらはトレース付き双デカルト圏で示せるが、絵算は&lt;strong&gt;相当に面倒&lt;/strong&gt;だ。意外！なんか勘違いしてるのか？

f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt; とか f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ f&lt;sup&gt;*&lt;/sup&gt;;f、f&lt;sup&gt;+&lt;/sup&gt; = (1 ∨ f&lt;sup&gt;+&lt;/sup&gt;);f がけっこう難しいのは何故だろう？不思議だ。

*1159921018*[用語法][圏一般論]閉（closure）構造

(C, (※), 1)がモノイド圏だとする。モノイド閉の定義として、指数演算を関手として表面に出すスタイルがある。

[-, -]:C&lt;sup&gt;op&lt;/sup&gt;×C→Cという2変項関手（指数関手）があって、自然な集合の同型Ψ&lt;sub&gt;A,B,C&lt;/sub&gt;:C(A(※)B, C) = C(A, [B, C])が与えられているとき、[-, -]とΨの組を、(C, (※), 1)の&lt;strong&gt;閉（閉包）構造&lt;/strong&gt;と呼ぶ。（Ψは、C(-(※)-, -), C(-, [-, -])をC&lt;sup&gt;op&lt;/sup&gt;×C&lt;sup&gt;op&lt;/sup&gt;×C→Setの関手とみなしての自然変換である。）

閉構造を持つモノイド圏が閉圏である。モノイド積が対称でないと、指数が2つ必要になり面倒。とりあえずは対称のケースでいいだろう。コンパクト閉圏は、「[A, B] = B(※)A&lt;sup&gt;*&lt;/sup&gt;、ΨはKelly単位を使ったbending」で定義した閉構造を持つ。

*1159928661*[用語法]Equationally Cartesian / Equationally CoCartesian

対角Δと弱終射◇（重複と放電）、それらの等式で定義される圏を単にデカルト圏と呼ぶのはまずいな。等式的デカルト（Equationally Cartesian）圏かな。

セリンガーは、http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdfの12ページで、「等式的デカルトはデカルトだ」と言っていたが、僕は事情がよくわからない。
&gt;&gt;
The following observation is category-theoretical folklore:

&lt;b&gt;Lemma 3.3&lt;/b&gt; The focus is the largest subcategory on which the tensor product, together with Δ and ◇, restricts to a cartesian product. 

In particular, it follows that C = C&lt;sup&gt;#&lt;/sup&gt; iff the monoidal structure on C, with its diagonals, is given by a cartesian product. In this case, we also say C is cartesian.
&lt;&lt;

C&lt;sup&gt;#&lt;/sup&gt;は、対角付き圏の焦点部分圏で、焦点とは、コピー可能／破棄可能な射の全体。対角の条件は、すべての対象に対して対称コモノイドを定義すること。

Equationallyが効いてくるのは、Equationally BiCartesianのときかな。

</body>
</day>
<day date="2006-10-05" title="">
<body>
*1160006705*[トレース／コンパクト閉圏][圏一般論]等式的デカルト、余デカルト、双デカルトな圏

等式的デカルト圏＝デカルト圏であっても、等式的余デカルト、等式的双デカルトな圏を考えることに意味はある。

等式を使うと、極限のときとは双対性の使い勝手が違う。余デカルト性は即座に半線形性になる。双デカルトの定義には、∇;Δ = □ も入れた方がいいだろう。これにより、次の2つの&lt;strong&gt;定義&lt;/strong&gt;が整合する。

- f&lt;sup&gt;+&lt;/sup&gt; := Tr(∇;f;Δ)
- f&lt;sup&gt;*&lt;/sup&gt; := Tr[(1+Δ);(σ+f);(1+∇)]

この定義のもとで、f&lt;sup&gt;+&lt;/sup&gt; = (∇;f)&lt;sup&gt;†&lt;/sup&gt; （右はConwayダガー）は自明、f&lt;sup&gt;*&lt;/sup&gt; = Tr[□;(1 + f)] は割と簡単、f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt; は自明でない定理となる。

*1160039367*[トレース／コンパクト閉圏]Kozen圏みたび

Kozen圏の定義は二転三転しているが、最近はまたもとの定義に戻って：

+ 対称モイイド圏
+ 等式的デカルト（普通の意味でデカルトとなるようだ）
+ 等式的余デカルト（半線形性を持つ）
+ ∇;Δ = □（これを含めて等式的双デカルトと呼ぼう）
+ Δ;∇ = 1（ベキ等）
+ トレース付き

つまり、&lt;strong&gt;トレース付き・ベキ等・等式的双デカルト・モノイド圏&lt;/strong&gt;。


</body>
</day>
<day date="2006-10-06" title="">
<body>
*1160126861*[トレース／コンパクト閉圏]等式的双デカルト圏のための等式群

次の3つを比較する。
- コラディニ／ガダッチ（Andrea Corradini, Fabio Gadducci）http://citeseer.ist.psu.edu/corradini99algebraic.html の15ページ
- セリンガー http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf の11,12ページ、
- ベスパロフ http://arxiv.org/abs/q-alg/9510013 の5-8ページ

記号法は、これらのどれとも違うのだが、(Δ, !)、(∇, θ)を使う。(∇, θ)をaddition, (Δ, !)をcoaddtionと考え、(Δ, ∇, !, θ)を可換（アーベル）双モノイドとして定義する立場をとる。

やたらにモノグサな記法だが：

- id&lt;sub&gt;A&lt;/sub&gt; = 1&lt;sub&gt;A&lt;/sub&gt; = 1 = A （文脈依存）
- !&lt;sub&gt;A&lt;/sub&gt; = ! : A→0
- θ&lt;sub&gt;A&lt;/sub&gt; = θ : 0→A （いちおう、0とθは区別する）
- id&lt;sub&gt;0&lt;/sub&gt; = 1&lt;sub&gt;0&lt;/sub&gt; = 0 （混乱の心配がなければ）

&lt;h5&gt;コラディニ／ガダッチのGSモノイド圏の等式&lt;/h5&gt;

+ Δ;(1 + Δ) = Δ;(Δ + 1) 余結合律
+ Δ;(1 + !) = 1 余単位律1
+ Δ;(! + 1) = 1 余単位律2
+ Δ;σ = Δ 可換律

ここまでは、可換コモイノド。モノイド圏の+と0に関して、Δと!が協調的であること：

+ Δ&lt;sub&gt;A+B&lt;/sub&gt; = (Δ&lt;sub&gt;A&lt;/sub&gt; + Δ&lt;sub&gt;B&lt;/sub&gt;);(A + σ&lt;sub&gt;B,A&lt;/sub&gt; + B)
+ Δ&lt;sub&gt;0&lt;/sub&gt; = 0
+ !&lt;sub&gt;A+B&lt;/sub&gt; = !&lt;sub&gt;A&lt;/sub&gt; + !&lt;sub&gt;B&lt;/sub&gt;
+ !&lt;sub&gt;0&lt;/sub&gt; = 0

λ:0→0+0 をモノイド圏で定義できる同型、λ'をその逆とすると、次が正確な表現。

- Δ&lt;sub&gt;0&lt;/sub&gt;;λ' = 0 （または Δ&lt;sub&gt;0&lt;/sub&gt; = λ）
+ !&lt;sub&gt;A+B&lt;/sub&gt; = (!&lt;sub&gt;A&lt;/sub&gt; + !&lt;sub&gt;B&lt;/sub&gt;);λ'

&lt;h5&gt;セリンガーの対角付きモノイド圏&lt;/h5&gt;

GSモノイド圏とまったく同じ。ただし、セリンガーはΔ&lt;sub&gt;0&lt;/sub&gt;;λ' = 0 を忘れているようだ（他から出る？）。

&lt;h5&gt;ベスパロフの代数／余代数／双代数&lt;/h5&gt;

「モノイド圏の代数」「モノイド圏の余代数」の定義は、モイイド／コモノイドの定義そのもの。双代数では：

- ∇;Δ = □
- θ;Δ = λ;(θ + θ) : 0 → A + A
- ∇;! = (! + !);λ' : A + A → 0
- θ;! = 0

双デカルト圏の公理としては、∇;Δ = □だけがあればいいと思う。

*1160126862*[その他代数]双代数、フロベニウス代数も特異点解消？

∇;Δ = □、∇;Δ = (Δ + 1);(1 + ∇) は、高次の特異点（尖点の接触）を分岐特異点まで解消しているような絵になる。


</body>
</day>
<day date="2006-10-10" title="">
<body>
*1160459290*[トレース／コンパクト閉圏][XML]タプル、余タプル、マトリクス

f1:X→Y1, f2:X→Y2に対して、&amp;lt;f1, f2&gt;:X→Y1×Y2を、射のタプルと呼ぶ。一方、f1:X1→Y, f2:X2→Yに対する[f1, f2]:X2+X2→Yを余タプルと呼ぶことにする（この記法は、ステファネスクとは逆）。タプルと余タプルを等式的に定義するには、等式的デカルト圏、等式的余デカルト圏ならいいだろう。(a, b; c, d) = &amp;lt;[a, b], [c ,d]&gt; = [&amp;lt;a, c&gt;, &amp;lt;b, d&gt;]であるときはマトリクスを考えることができて、等式的双デカルト圏で意味を持つ。

そこで、等式的デカルト／等式的余デカルト／等式的双デカルト圏にモデルを持つような形式的理論を、タプル／余タプル／マトリクス・セオリーと呼ぶことにする。これらにトレースを入れれば、Conway／Elgot／Kozenセオリーと呼んでいいと思うが、これもステファネスクの用語とずれる気がする、調べてみよう。

僕としては、Conway不動点を持つデカルト圏、Elgotオートマトンの圏、コォゼン圏（Kozen圏）、クリーネ圏（Kleene圏）の関係をクリアにしたい。それが、ゴチャゴチャ考えてみる動機。

ついでに書いておくが；次の定義が公理的定義と実例を繋ぐ：

- 対称モノイド圏の対象Uが単純対象だとは、U≠0 で、U=U1+U2と分解できるなら、U1かU2のどちらかは0（に同型）。
- 対称モノイド圏が単純だとは、単純対象が同型を除いて1つしかなくて、すべての対象が単純対象の和（モノイド積）に同型。
- 対称モノイド圏が半単純だとは、単純対象が同型を除いて有限個しかなくて、すべての対象が単純対象の和（モノイド積）に同型。

特に興味深いのは、単純Kozen圏と半単純Conway圏だろう。半単純Conway圏の例は、ΩΟ圏として構成できて、これがXMLのモデルとなるはず。

*1160459709*[トレース／コンパクト閉圏][プログラム意味論][山勘]二重トレース付き半環圏

ステファネスクもセリンガーも、トレースには二種類あることを示唆している。iterational (またはlooping, additive) traceと existential (またはmultiplicative) trace。つまり、繰り返しや再帰に関するトレースと、論理の存在記号に似たトレースだ。2つのモノイド積とそれぞれの積に対する2つのトレースを備えた圏の実例がある。2つのトレースは、繰り返し的トレースと存在的トレースになる。

関係の圏に、集合の直和と直積を考えて、クリーネスターをベースに定義できるトレースと、存在記号で定義できるトレースを考えたものが典型的な二重トレース付き半環圏（doubly-traced semiringal category）となる。他に、ベクトル空間の圏に直和とテンソル積を入れて、直和に関するトレースとテンソル積に関するトレース（対角和、縮約）を考えると、これも二重トレース付き半環圏になる。（ステファネスクの用語では、Mixed Network Algebraと呼ぶ。）

2つのトレースをATrとMTr（AdditiveとMultiplicative）とすると、ATrとMTrの関係が問題になる。現状では、僕はMTr(A+B) = MTr(A) + MTr(B)くらいしかわからない。

二重トレース付き半環圏の実例や計算に関して、古典的なテンソル計算や代数的グラフ理論にヒントがありそうな気がする（山勘）。境界付き有向グラフの圏も事例になりそうな気がする。グラフの積が意外に考えにくいのだが、反射的グラフの圏で考えたほうがいいかもしれない。

ひょっとして、フル線形論理のモデルのなかに二重トレース付き半環圏が登場するかも知れない（さらに山勘）。

*1160462151*[リンク][その他代数]クリーネ代数（Kleene代数）、コンウェイ半環（Conway半環）

- Zoltan Esik / Hans Leiβ &quot;Greibach Normal Form in Algebraically Complete Semirings&quot; →http://www.brics.dk/RS/02/46/BRICS-RS-02-46.pdf (46P)
- Z. Esik &quot;The Equational Theory of Fixed Points with Applications to Generalized Language Theory&quot;→http://www.brics.dk/RS/01/22/BRICS-RS-01-22.pdf (24P)これは印刷した気がする。やっぱり→[http://d.hatena.ne.jp/m-hiyama-memo/20060705/1152086189:title]
- Dexter Kozen &quot;On Kleene Algebras and Closed Semirings&quot;→http://citeseer.ist.psu.edu/kozen90kleene.html (21P) これも印刷したかも？
- Luigi Santocanale &quot;μ-Bicomplete Categories and Parity Games&quot;→http://citeseer.ist.psu.edu/566440.html (45P)

EsikとKozenのモノはもはや定番に近い。Santocanale（サントカネイル？）は知らなかったが、このヒト面白い感じだ。

Luigi Santocanale &quot;From Parity Games to Circular Proofs (2002)&quot;→http://citeseer.ist.psu.edu/santocanale02from.html が短い(12P)の総論だったので、印刷した。

*1160473824*[課題]単純双デカルト圏の行列表現

Cが単純双デカルト圏として、Uを選ばれた（distinguished）単純対象だとする。このとき、U&lt;sup&gt;n&lt;/sup&gt;→U&lt;sup&gt;m&lt;/sup&gt;の形の射の全体は部分圏となる（U&lt;sup&gt;0&lt;/sup&gt;=0と約束する）。この部分圏は、骨格的（skeleton）部分圏となることを示せ。

これが示せれば、Cは、K = End(U)係数の行列圏と圏同値であることになる。

</body>
</day>
<day date="2006-10-11" title="">
<body>
*1160554010*[用語法][リンク]GS Monoidal categories

- [google:&quot;GS Monoidal categories&quot;]

けっこう引っかかる。やはり、コラディニ、ガダッチ、モンタナリ（Andrea Corradini / Fabio Gadducci / Ugo Montanari）あたり。ちなみに、セリンガーの用語&quot;category with diagonals&quot;はセリンガーしか使ってない感じだ。

- Roberto Bruni, Jose Luiz Fiadeiro, Ivan Lanese, Antonia Lopes, and Ugo Montanari &quot;New insights into the algebraic properties of architectural connectors&quot;→http://www.fiadeiro.org/jose/papers/CommTile.pdf (32P) 印刷した、たぶん重複印刷？。

これにco-GS monoidal categoryてのも出てくる。セリンガー流なら、&quot;category with codiagonals&quot;となるだろう。

*1160555227*[人物]Luigi Santocanale

- Luigi Santocanale →http://www.lif.univ-mrs.fr/~lsantoca/

2001年くらいから論文発表をはじめているので、まだ若いのかな？

μ-双完備圏(μ-bicomplete categories）を中心に、線形論理、巡回的証明、ゲーム・セマンティクスとかをやっている。注目のヒトですね。

μ-双完備圏は、μν完備圏と呼んだほうがいいと思うな。束の最小不動点とμ計算／最大不動点とν計算を一般化して、有限直和／直積を持つ圏Cの自己関手の族Ψ（F∈Ψ ⇒ F:C→C）に対して、始代数μ.Fと終余代数ν.F を持つような圏。

EsikのConway代数（μを使って表現される不動点を持つ代数）に近い、似た雰囲気がある→[http://d.hatena.ne.jp/m-hiyama-memo/20061010/1160462151:title]。巡回証明は証明ネットが関係するかも→[http://d.hatena.ne.jp/m-hiyama-memo/20060623/1151055999:title]。ゲーム・セマンティクスはアブラムスキーもやっていたし→http://citeseer.ist.psu.edu/abramsky99game.html。

</body>
</day>
<day date="2006-10-12" title="">
<body>
*1160626948*[課題]単純圏で次元はどう定義できるか？

- 対称モノイド圏が&lt;strong&gt;単純&lt;/strong&gt;だとは、単純対象が同型を除いて1つしかなくて、すべての対象が単純対象の和（モノイド積）に同型。 

と、定義した。特定された（distinguishedな）単純対象をUとして、モノイド積を+で書いて、U + U + ... + U = n・U と書くことにする。

どんな対象Xでも、適当なnに対して X=n・U （同型も=で書く）であることは定義から保証されるが、このnが一意的であることは全然保証されない。n・U = 0 とかも起こるかもしれない（起こらないことを示す必要がある）。

Dim(X) = {n∈&lt;b&gt;N&lt;/b&gt; | X = n・U} とすると、Dim(X)が空でないことは定義から保証される。dim(X) = min(Dim(X)) とすれば、一応「対象Xの次元」は定義できるが、これでいいのか？ 考え方としては：

- このdimでやってみる。
- 集合Dimを詳しく調べる。
- Dimが{n}の形（単元集合）になる条件を調べる。

などがある。Cが双デカルトのとき、C(U, U)をK、C(U, X)を[X]と略記すると、Kは半環、[X]はK上の半加群となることはわかる。さらに、Cが単純だから[X]=K&lt;sup&gt;n&lt;/sup&gt;とも書ける。これで、（双デカルトのケースに限れば）問題は半環と半加群の代数的な問題になり、「K&lt;sup&gt;n&lt;/sup&gt; = K&lt;sup&gt;m&lt;/sup&gt; なら n  = m か？」という形になる。

半加群では、核Ker(f) = f&lt;sup&gt;-1&lt;/sup&gt;(0)は定義できるが、ろくな情報を持たない。準同型定理も成立しない。マイナス（符号反転）による対蹠がないので、対称性／一様性を持たず、半加群の構造定理が得られない。

ベキ等なら少しマシで、f:X→Yに対して、y∈Im(f)に対してf&lt;sup&gt;-1&lt;/sup&gt;({0, y})が部分半加群となり、XはX&lt;sub&gt;y&lt;/sub&gt; = f&lt;sup&gt;-1&lt;/sup&gt;({0, y})達の和で書ける。が、X&lt;sub&gt;y&lt;/sub&gt;はyごとにバラバラで一様ではない。

「X+A = X+B ⇒ A = B」が成立すれば、それはそれでありがたい。極限による直積／直和ならOKか？ いや、なんか変だな。

… ダメだぁー。

やっぱり、「等式的にデカルト⇒極限によりデカルト」を示す必要があるのかも -- それがどうした？という気もするが。それと、Xに[X]を対応させる具象表現も調べる必要があるような … ？


</body>
</day>
<day date="2006-10-13" title="">
<body>
*1160700643*[課題]半環と単純双デカルト圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061012/1160626948&quot;&gt;単純圏における対象の次元の課題&lt;/a&gt;を少し別な見方で考える。

Kが半環のとき、行列圏Mat[K]を作れる。Mat[K]は&lt;b&gt;N&lt;/b&gt;を対象類、1を単純対象とする単純双デカルト圏となる。“単純対象が特定された単純双デカルト圏の圏”をSBCCとすると、Matは、SR（SemiRings圏）→SBCCの関手となる。

SBCCに属する圏C = (C, U)（Uは特定された単純対象）に対して、K[C] = C(U, U)として半環を対応させれば、Kは SBCC→SRの関手となる。Mat;K = Idは自明に成立。問題はK;Matなのだ。M = (K;Mat)(C) = Mat[K[C]&amp;#91; とすると、圏Mは圏Cに包含されるが、この包含が圏同値だとすると、SBCCを圏同値で分類した商と圏SRを同一視していいことになる。

楽観的にムシのいい希望を述べれば：

- 単純双デカルト圏は半環係数の行列圏に圏同値であり、係数半環のみで構造が決定される。

これは作業仮説だが、いくらなんでも都合が良すぎるという感じもするな。


</body>
</day>
<day date="2006-10-14" title="">
<body>
*1160817629*[課題][その他代数]半環と半加群の次元など

Kが半環（可換とは限らない）として「K&lt;sup&gt;n&lt;/sup&gt; = K&lt;sup&gt;m&lt;/sup&gt; ⇒ n = m」が、どんな条件でどの程度成立するか？が、シリアスな課題になっている。

半環Kと半加群Xに対して、Dim(X) = {k∈&lt;b&gt;N&lt;/b&gt; | K&lt;sup&gt;k&lt;/sup&gt; = X}として、Dim(X)が空でないX（有限で自由な半加群）だけを相手にする。dim(X) = min(Dim(X))とすれば次元が定義できるような気がするが、これだとdim(X + Y) = dim(X) + dim(Y)が保証できない。

例えば、X = K （i.e dim(X) = 1）, dim(Y) = 2 とそれば、X + Y = K&lt;sup&gt;3&lt;/sup&gt;（同型）となるが、もしK&lt;sup&gt;3&lt;/sup&gt; = K&lt;sup&gt;2&lt;/sup&gt;だったりすると、dim(X + Y) = 2 ≠ dim(X) + dim(Y) となってしまう。dimの条件としては：

- dim(X) = n ⇔ X ≒ K&lt;sup&gt;n&lt;/sup&gt;
- dim(X + Y) = dim(X) + dim(Y)

が必要になる。

可換環でさえ次元論は難しいから、非可換半環では絶望的だろう。考えられる付加的条件は：

- 乗法が可換
- 加法が省約的
- 加法がベキ等
- 半体（乗法が群）
- ダガーを持つ
- 繰り返し（iteration）を持つ

など。

次元がdifinableであれば、ある条件Pを満たす半環の圏 (P)-SR と、End(U, U)が(P)-SRに入るような単純双デカルト圏の圏 (P)-SBCC の間を行列圏で繋ぐことができる。半環の条件Pを圏の条件P'で言い換えることができると、(P)-SRと(P')-SBCCの関係を記述できる。例えば、環がベキ等であることは、圏として「Δ∇ = 1」と記述できる。

- Wagneur, E. &quot;Moduloids and Pseudomodules. I. Dimension theory.&quot; Discrete Mathematics, 98, 57-73, 1991

コレに、ベキ等半環の次元論があるらしい。

- M. Takahashi &quot;On the bordism categories II -- Elementary properties of semimodules -- &quot; Math. Sem. Notes, Kobe Univ., 9(1981), 495-530.

これは省約的半加群かもしれない。

もうひとつの見方は、&lt;strong&gt;マイヒル／ネロード型の理論が次元論を与える&lt;/strong&gt;、と考えることだ。純代数的に考えるより、こっちのほうが有望かもしれない。とある代数のスペクトルが実はオートマトンの状態空間（状態点集合）として実現されて、その空間の大きさ（基数）が代数の次元を与えると考える。この点は別エントリーで書こう。




</body>
</day>
<day date="2006-10-18" title="">
<body>
*1161163142*[圏一般論][その他代数]次元論はヤーメタ（ともいかないか）

半環／半加群の次元論は僕の手に負えない。これはもうスキップしよう。

で、公理化でごまかす。

(C, U)が単純モノイド圏だとする、Uは特定された単純対象。dim:|C|→&lt;b&gt;N&lt;/b&gt;+{∞}が次元であるとは：

+ dim(X) = 0 ⇔ X≒0 （右の0はモノイド単位対象で、≒は同型）
+ dim(X) = 1 ⇔ X≒U
+ dim(X + Y) = dim(X) + dim(Y)
+ dim(X) = n ⇔ f:n・U→X という同型fが在る

dimの値が∞にならないとき有界次元（bounded dimension）と呼ぶことにする。

有界次元を持つ単純モノイド圏（simple monoidal category with bounded dimension）が双デカルトなら、行列圏になることはほぼ自明になる。が、逆に、行列圏が実際に次元を持つかどうかは全然明らかでなくなるなー。

ウーム、次元論を止めようとしてもなかなかそうもいかないのか。次元論が大事なことが少しはわかりましたよ。


</body>
</day>
<day date="2006-10-19" title="">
<body>
*1161249587*[雑感]半環／半加群をどうしよう

うーん、双デカルト圏は半環上の半加群の圏と非常に密接に関係する。やっぱり、&lt;a href=&quot;http://math.haifa.ac.il/JSGOLAN/golan2.html&quot;&gt;Golan&lt;/a&gt;の本（[http://www.amazon.co.jp/gp/product/0792357868:title]）で半環の勉強しないとダメかしら。

</body>
</day>
<day date="2006-10-21" title="">
<body>
*1161412679*[山勘][形式言語理論]モノイド半環の双代数構造

群環にならってモノイド半環を作ってみる。二値ブール代数Ωをベキ等半体だと思って、モノイドMからΩへの写像の全体をΩ(M)と書く。Ω(M)は半環になるが、和は合併、積は共通部分の集合代数とみなせる。

群環のホップ代数に倣って、単位1→Mから余単位ε:Ω(M)→Ω(1) = Ωを作る。これは部分集合がMの単位を含むかどうかを判定する写像になる。部分集合が非空であることを判定するι:Ω(M)→Ωは群環の積分に対応しそうだ。通常の言語の積は畳み込み積になる。

余積（余乗法）Δは、Ω(M)→Ω(M)(※)Ω(M) = Ω(M×M) （テンソル積(※)はうまく定義できるとして）だが、これは部分集合の乗法的分解になる。つまり、Δ(A)⊆M×M と考えて、(x, y)∈Δ(A)とは、x・ｙ∈A のこと。

余単位／余積に関してΩ(M)が代数的余代数（モノイド圏のコモノイド）になっていて、代数的代数構造と共に代数的双代数になっていれば面白い。余単位、余積によってオートマトンを記述できないか。代数的余代数と圏論的余代数の接点が見いだされるとうれしい。

*1161414971*[雑記]衝動買い TQFT book

トーマス・カーラーのWebページ（http://www.math.ohio-state.edu/~kerler/）からたどって、リュウバシェンコ（Volodymyr V. Lyubashenko ）との著書&quot;Non-Semisimple Topological Quantum Field Theories for 3-Manifolds With Corners&quot; http://www.amazon.co.jp/exec/obidos/ASIN/3540424164/ を衝動買いしてしまった。

カーラー、リュウバシェンコ、ベスパロフ（Yu.N. Bespalov）あたりはTQFTの新世代つう感じだな。

買ってしまった理由は、TQFTをモノイド圏の代わりに二重圏（double categories）を使って定義しているらしいから。なんか、KQFT（Kleenean QFT）でも二重構造が必要そうな感じがしていたのですよ。

</body>
</day>
<day date="2006-10-24" title="">
<body>
*1161648695*[形式言語理論]クリーネ圏（Kleene圏）の定義

[http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715173:title]とか[http://d.hatena.ne.jp/m-hiyama-memo/20060619/1150676276:title]にも書いてあるが、もとネタから念のため引き写しておく。

&lt;hr&gt;
Kahl &quot;Refactoring Heterogeneous Relation Algebras around Ordered Categories and Converse&quot; Published on December 10, 2004→http://www.cosc.brocku.ca/Faculty/Winter/JoRMiCS/Vol1/PDF/v1n12.pdf 18p 4.2節

まず引用：
&gt;&gt;
Definition 34. An idempotent semiring category (ISR category) is an upper semilattice categories with zero morphisms.
&lt;&lt;

r:A→A, q:B→A、s:A→Cに対して：

+ ISR圏である。
+ End(X)には*が割り当ててある。
+ r* = 1 + r + r*;r*
+ q;r⊆q ⇒ q;r* ⊆q
+ r;s⊆s ⇒ r*;s ⊆s

&lt;hr&gt;
木下「不動点をめぐる代数構造たち」2001, 2004 →http://unit.aist.go.jp/cvs/tr-data/PS02-005.PDF

q:A→A, r, x:X→A、s, y:A→Yに対して：

+ homsetが半束である。
+ 結合（合成）が半束の射である。
+ q:A→A, r, x:A→Bに対して：1 + q*;q = q*
+ 1 + q;q* = q*
+ r + x;q ⊆x ⇒ r;q*⊆x
+ s + q;y ⊆y ⇒ q*;s⊆y

原論文では、q:A→A, r, x:A→Bに対して、r + x;q ⊆x ⇒ r;q*⊆x、r + q;x ⊆x ⇒ q*;r⊆x となっているが、間違いだろう。

&lt;hr&gt;
Hopkins &quot;Kleene Categories&quot; September, 2001→http://www.chimaira.org/archive/KleeneCat.txt

&lt;pre&gt;
A Kleene Category C is a category in which
(A) Every homset C(A,B) is partially ordered such that every finite
    subset has a least upper bound.
(B) If U1, U2 are finite subsets of C(A2,A3) and C(A1,A2) then
    sup(U1) sup(U2) = sup(U1 U2)
(C) There is an operation f |-&gt; f* defined over each homset C(A,A),
    such that:
                1_A + f f* &lt;= f*
                if u + xv + wx &lt;= x then w* u v* &lt;= x

where in the latter inequality, u: A -&gt; B, v: A -&gt; A, w: B -&gt; B, x: A -&gt; B.
&lt;/pre&gt;

&lt;hr&gt;
Kozen &quot;A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events (1994)&quot; →http://citeseer.ist.psu.edu/kozen94completeness.html

非自明な公理：

- 1 + a・a* ≦ a*
- 1 + a*・a ≦ a*

- b + a・x ≦ x ⇒ a*・b ≦ x
- b + x・a ≦ x ⇒ b・a* ≦ x

*1161648866*[雑記]ロス・ストリートはMacWrite Proで論文を書く

見た目がTeXとは思えないので覗いてみたら：

&lt;pre&gt;
%!PS-Adobe-3.0
%%Title: (N'western 97 for web)
%%Creator: (MacWrite Pro: LaserWriter 8 8.3.3)
%%CreationDate: (16:21 Thursday 20 March 1997)
%%For: (Ross Street)
&lt;/pre&gt;

というわけです。

*1161670281*[形式言語理論][プログラム意味論]ブール・クリーネ圏（Boole/Kleene Categories）

圏Cがクリーネ圏であって、さらに次を満たすとする。

- 対象はブール代数である（半環とみなす）
- homset C(A, B)を可換モノイドとみなして、左スカラー乗法L&lt;sub&gt;A,B&lt;/sub&gt;:A×C(A, B)→C(A, B)が左半加群構造を与える。
- 同じく、右スカラー乗法R&lt;sub&gt;A,B&lt;/sub&gt;:C(A, B)×B→C(A, B)が右半加群構造を与える。
- a∈A, x∈C(A, B), b∈Bに対して (a・x)・b = a・(x・b)。

ようするに、homsetが両側半加群構造を持つようになっている。a|→a・1 によって、ブール半環AをEnd(A)に埋め込める（かもしれない）が、End(A)はKleene代数構造を持つから、テスト付きクリーネ代数となる。

ブール・クリーネ圏は、テスト付きクリーネ代数と作用素付きブール代数を拡張したものになる。Kozen圏やプレKozen圏（Kozen圏からベキ等性を除いた圏）との関係が主な課題。

プログラムとの関係では：

- 対象A -- テスト、条件、状態空間の部分集合
- endo射 -- 状態遷移、動作
- 一般の射 -- 状態空間の変換／対応／翻訳。異なる状態空間への遷移
- スカラー乗法 -- 事前、事後条件でガードすること。
- 圏の結合 -- 順次実行
- homsetの和 -- 非決定性の選択
- 恒等射 -- nop, skip
- 零射 -- crash
- star -- 不定の任意繰り返し

*1161675440*[具体例][圏一般論]面白いモノイド圏（かな？）

対象が{0, 1}である圏を考える。id&lt;sub&gt;0&lt;/sub&gt;=0, id&lt;sub&gt;1&lt;/sub&gt;=1、id以外の射は：

- θ:0→1
- !:1→0
- z:1→1

関係は、θ;! = 0, !;θ = z。z;z = zは出る（z;z = !;θ;!;θ = !;0;θ = !;θ = z）。表にする。縦;横 と見る。

| ;   |* θ |* ! |* z|
|* θ | -   | 0  | θ|
|* !  | z   | -  | - |  
|* z  | -   | !  | z |

&lt;em&gt;2対象5射&lt;/em&gt;の圏になる。対象{0, 1}に、1+1 = 0として和（モノイド積）を入れる。次のように和を拡張する。

| +   |* 0 |* 1 |* θ |* ! |* z|
|* 0  |  0 | 1  | θ  | !  | z |
|* 1  |  1 | 0  | !   | θ | 0 |
|* θ | θ | !  |  0  | z  | ! |
|* !  | !  | θ | z   | 0  | θ|
|* z  | z  | 0  | !   | θ | 0 |

この和がモノイドになっているかな？ なっていればかなり面白い例になる。


</body>
</day>
<day date="2006-10-25" title="">
<body>
*1161765785*[形式言語理論][プログラム意味論][リンク]様相ブール・クリーネ圏

確か&lt;a target=&quot;_blank&quot; href=&quot;http://andrej.com/mathematicians/K/Kurz_Alexander.html&quot;&gt;カーツ（Kurz）&lt;/a&gt;が、状態空間の変換を様相オペレータとして解釈していた。ブール・クリーネ圏でも様相オペレータを入れたいのだが、&lt;a target=&quot;_blank&quot; href=&quot;http://arxiv.org/abs/cs.LO/0310054&quot;&gt;Kleene Algebra with Domain (KAD)&lt;/a&gt;を使えばよさそうだ。f:A→B がブール／クリーネ圏の射とする。つまり、fはA,B両側半加群C(A, B)の元となっている。δ(f)∈Aとρ(f)∈Bが決まって、しかるべき公理を満たす。

これは、δ&lt;sub&gt;A,B&lt;/sub&gt;:C(A, B)→A、ρ&lt;sub&gt;A,B&lt;/sub&gt;:C(A, B)→Bが割り当てられているってことだ。δとρを使って、様相オペレータを組み立てられればいいのだけど。

カーツといえば、これを見つけた。
- Clemens Kupke, Alexander Kurz, Yde Venema, &quot;Stone Coalgebras&quot; →http://www.illc.uva.nl/Publications/ResearchReports/PP-2003-15.text.pdf

他に、KAD関連：
- DEMONIC ALGEBRA WITH DOMAIN →http://www.ift.ulaval.ca/~Desharnais/Recherche/RR/DIUL-RR-0601.pdf
- Modal Kleene Algebra and Applications -- A Survey -- →http://www.cosc.brocku.ca/Faculty/Winter/JoRMiCS/Vol1/PDF/v1n5.pdf

*1161766721*[形式言語理論][TQFT]クリーネ・ファインマンの公式と呼んでいいのか？

本編に[http://d.hatena.ne.jp/m-hiyama/20061025/1161755157:title]なんてのを書いたけど、http://www.glocom.ac.jp/project/chijo/2004_04/2004_04_02.pdfを読んだ目的は：
&gt;&gt;
ラグランジュ力学と言いますと、ラグランジュ関数があると、アクション積分を考えて、その変分をとるとクラシカルな軌跡ができる。クラシカルな軌跡というのは、こうしてラグランジュ関数から一意的に決まりますが、量子力学になると、軌跡はゆらいでいます。ゆらぎでフラフラしているわけです。このゆらぎをどう理解するかが問題です。アクションに i と定数をつけて指数関数にしたものを可能な径路すべてについて平均してプロパゲータ（グリーン関数）を決めようというのが、ファインマンのアイデアです。このようにして量子力学を設定することを提案しました。
&lt;&lt;
とか。

Aがラベル（重み）付き有向グラフの行列表示、A&lt;sup&gt;*&lt;/sup&gt;をクリーネ・スターとして、そのa, b成分は次のように書ける。

- A&lt;sup&gt;*&lt;/sup&gt;[a, b] = Σ&lt;sub&gt;γ∈Path(a, b)&lt;/sub&gt;Π&lt;sub&gt;i&lt;/sub&gt;(γ)&lt;sub&gt;i&lt;/sub&gt;

Path(a, b)はグラフ上でaからbに至る全ての経路、(γ)&lt;sub&gt;i&lt;/sub&gt;は、経路γのi番目の辺に付けられたラベル（重み）、Πは総積、Σは総和。これってファインマンの経路積分の離散版だと思うのだけど、よくわからんのだ。



</body>
</day>
<day date="2006-10-26" title="">
<body>
*1161847087*[リンク]さまざまな半環、（ホーン）等式的理論など

半環関係：

- Esik/Kuich, Rationally Additive Semirings →http://www.brics.dk/RS/01/42/BRICS-RS-01-42.pdf 第2章を良く読んでまとめること。cf. →[http://d.hatena.ne.jp/m-hiyama-memo/20060623/1151031526:title]
- Esik/Kuich, Inductive *-Semirings →http://www.brics.dk/RS/00/27/BRICS-RS-00-27.pdf オ勉強用の教科書つう感じ！
- Bloom/Esik An Extension Theorem with an Application to Formal Tree Series→http://www.brics.dk/RS/02/19/BRICS-RS-02-19.pdf
- Kozen, On Kleene Algebras and Closed Semirings→http://citeseer.ist.psu.edu/39478.html
- Santocanale, On the Equational Definition of the Least Prefixed Point (2003) →http://citeseer.ist.psu.edu/santocanale03equational.html
- Robin Cockett / Luigi Santocanale, Induction, Coinduction, and Adjoints (2002) →http://citeseer.ist.psu.edu/687782.html
- Penn, Efficient Transitive Closure of Sparse Matrices over Closed Semiring→http://citeseer.ist.psu.edu/689131.html


</body>
</day>
<day date="2006-10-27" title="">
<body>
*1161914541*[用語法]ハイパー行列にしておくか、とりあえず

僕の好みの構造 -- 境界付き有向グラフに辺ラベリング（または重み付け）をしたもの、この構造には名前がない。ラベル（重み）の値を半環、さらには圏に拡張できて、次のような概念を包括する。

+ 半環係数の行列
+ オートマトン
+ (0+1)次元のTQFT

物理的には&lt;strong&gt;場&lt;/strong&gt;、幾何学的には&lt;strong&gt;接続&lt;/strong&gt;に対応するが、&lt;em&gt;素朴な事例は行列だから&lt;/em&gt;&lt;strong&gt;ハイパー行列&lt;/strong&gt;と呼ぶことにした。

&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;とりあえず&lt;/strong&gt;&lt;/span&gt;だけど。


</body>
</day>
<day date="2006-10-31" title="">
<body>
*1162254650*[用語法]やめました

用語造語&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061027/1161914541&quot;&gt;「ハイパー行列」&lt;/a&gt; -- やめました。

どうもシックリこない。代替案は&lt;strong&gt;カテグラフ&lt;/strong&gt;（categraph）。


</body>
</day>
<day date="2006-11-01" title="">
<body>
*1162367554*[用語法]カテグラフ、リグラフ

category-valued labeled(lebelled) directed graph から categ + graph = categoraph。

同様に、rig + graph = rigraph。rigは半環の別名だよ。

</body>
</day>
<day date="2006-11-02" title="">
<body>
*1162454156*[雑感]ホエーーー

もう本編に書くのもはばかられる（見てる人が少しいるから）くらいに、ストレス溜まりまくり。

ココ？ ココは誰も見てないからヘイキ。

*1162454387*[計算]乗法的ベキ等可換環とブール束

[http://d.hatena.ne.jp/m-hiyama/20061030/1162197817:title]をコピー。

+ MICR（乗法的ベキ等可換環）からBL（ブール束）がちゃんと作れること
+ BLからMICRがちゃんと作れること
+ MICR→BL→MICRでもとに戻ること
+ BL→MICR→BLでもとに戻ること

+ &lt;a href=&quot;http://www.chimaira.org/img/RingLatticeCalc-1.jpg&quot; &gt;計算用紙 1&lt;/a&gt;：MICR→BLの確認、うまくいった。BL側の∧ベキ等律を忘れているけど、x∧x := x + x + xx = x + x + x = x 。
+ &lt;a href=&quot;http://www.chimaira.org/img/RingLatticeCalc-2.jpg&quot; &gt;計算用紙 2&lt;/a&gt;：BL→MICRの確認、分配律のところで挫折。
+ &lt;a href=&quot;http://www.chimaira.org/img/RingLatticeCalc-3.jpg&quot; &gt;計算用紙 3&lt;/a&gt;：BL→MICRの分配律、なんとかなった。
+ &lt;a href=&quot;http://www.chimaira.org/img/RingLatticeCalc-4.jpg&quot; &gt;計算用紙 4&lt;/a&gt;：MICR→BL→MICRとBL→MICR→BLの確認、実際には一回失敗していて、&lt;em&gt;もう一枚の計算用紙で“練習”している。&lt;/em&gt;

ブール束から定義した可換環（となるはずの代数系）における分配律と、BL→MICR→BLでミート（∧）が再現することを確認するときにワケワカラナクなっています。で、“オリジナルの状況”に戻ってうまくいことを再確認して、オリジナル計算を真似てもう一度やり直し。

この“オリジナルの状況”とは：

- 普通の集合ブール束（ベキ集合）は、対称差 X△Y := (X＼Y)∪(Y＼X) = (X∩Y&lt;sup&gt;c&lt;/sup&gt;)∪(Y∩X&lt;sup&gt;c&lt;/sup&gt;) を加法、∩を乗法とすれば、乗法的ベキ等可換環となる

というものです。この事実は見やすく確認も容易です。これをもとに、双対原理により“ひっくり返した”定義が「古典論理は可換環論なんだよ」で紹介した定義です。人為的にひっくり返しているため、直観が働きにくくなってしまうんですよね。
&gt;&gt;
実は、Tを1に対応させることも出来て、そのほうが関手の構成は直観的で楽だったりします。
&lt;&lt;
とはそういう事情を言っています。

後で見て混乱しないように注意：

+ 記法は計算ごとに少しずつ変えています。
+ 束演算から定義された加法を#、乗法を・とか*で表しているところがあります。
+ 主に束演算を行うところでは、x∨y→x + y, x∧y→xy, ￢x→x'と書いています。この記法だと、加法が乗法に対して分配するところが&lt;em&gt;奇妙になる&lt;/em&gt;ので注意。
+ 環演算から定義された∧をΠで表しているところがあります。


</body>
</day>
<day date="2006-11-07" title="">
<body>
*1162860829*[雑記]Golan本

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061019/1161249587&quot;&gt;Golan本&lt;/a&gt;が届いた。パラパラ読んだ。

次元論は載ってないのでガックリ。だが、後半は面白そうな話題だから、内容的にはまーいい。&lt;em&gt;ブツとして、できの悪いハードカバーであることがひどく癪にさわる！ムカッ&lt;/em&gt;

*1162864073*[雑感][山勘][リンク][復習]論理、圏、空間、その他いろいろ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061102/c/&quot;&gt;本編コメント&lt;/a&gt;に答えるついでに、参照リンクやら戯言やらゴチャゴチャと。

&gt;&gt;
プログラムの集まりが「圏」になるというのは、どなたの発見か知りませんが、計算機科学において金字塔のような成果なのではないでしょうか。
&lt;&lt;
別に誰かの発見というわけではないような気がします。気が付いてみれば、みんなそんなふうに考えていた、というような状況かと。強いて人名を挙げれば、ゴグエン（Joseph Goguen→http://www.cs.ucsd.edu/users/goguen/）、&lt;del datetime=&quot;2010-06-29T23:41:20+09:00&quot;&gt;モッギ&lt;/del&gt;モッジ（Eugenio Moggi→http://www.disi.unige.it/person/MoggiE/）、アブラムスキー（Samson Abramsky→http://web.comlab.ox.ac.uk/oucl/people/samson.abramsky.html）あたりの貢献が大きいかな？ とはいえ、これも&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%2a%5b%bf%cd%ca%aa%a5%ea%a5%f3%a5%af%5d&quot;&gt;僕が知っている人々&lt;/a&gt;から選んだだけですが。

※ &lt;b&gt;あっ、人名はカタカナ表記しようと努めてますが、発音は全然アテになりませんので。&lt;/b&gt;→[http://d.hatena.ne.jp/m-hiyama/20060811/1155276617:title]

&gt;&gt;
もし「宇宙」というものを巨大なある種の計算機とみなせるならば、
&lt;&lt;
みなせるのか？ よくわかりませんね（強いてキーワードを挙げれば&quot;reversible computation/computing&quot;でしょうか）。

&gt;&gt;
物理系の時間発展などの集まりにも、圏論的な意味付けができるのではないか、などと想像します。
&lt;&lt;

ローベル（Lawvere→http://www.acsu.buffalo.edu/~wlawvere/）が、&quot;Categorical Dynamics&quot;（圏的力学）なんてことを言ってましたね、&quot;Categories in Continuum Physics&quot;（http://www.amazon.co.jp/gp/product/0387160965/）なんて本まで出してます、僕はよく知りませんが。

マーク・ホプキンス（Mark William Hopkins→[http://d.hatena.ne.jp/m-hiyama/20050614/1118708091:title]）は、場の量子論と形式言語理論が似てるなんて言ってまして、僕はけっこうホンキでマーク説を取り上げています。（→[http://d.hatena.ne.jp/m-hiyama-memo/20060516/1147823694:title]、[http://d.hatena.ne.jp/m-hiyama-memo/20060128/1138441388:title]）

ある程度抽象化すると、（位相的）場の量子論（TQFT)と形式言語理論が同じ定式化になるのは、間違いないようです。

それと、ジョン・バエズ（John C. Baez →http://math.ucr.edu/home/baez/）の周辺では、高次圏をバシバシ使って物理をやっているようですね。

&gt;&gt;
結局ストーン空間というのは、ブール代数を「可換環」とみなしたときのスペクトラムのことなんですね。
&lt;&lt;
はい、そうです。→[http://d.hatena.ne.jp/m-hiyama/20051207/1133937746:title]

&gt;&gt;
１９３０年代すでにこのような研究がなされていたというのは驚くべきことだと思います。
&lt;&lt;
確かにストーンの発想は凄いですね。でも、30年代は抽象代数やトポロジーが勃興してきた時期で、時代に勢いがあったのかも知れません（とか、歴史に無知な僕が言うことだから信用しないほうがいいけど）。

&gt;&gt;
通常の代数幾何は「論理」の美しい一般化になっています。
&lt;&lt;

同じことですが、論理が代数幾何の特殊事例というほうが適切な気がします。乗法的ベキ等体は{0, 1}の2元の可換環に限るのですが、一方、標数2の体も{0, 1}です。古典論理は標数2の体上の代数幾何という感じでしょう。標数0と正標数だと、違った代数幾何になりますが、正標数でも標数2は例外扱いのときが多いので、標数2だけはなんか特別な世界を形成している気がします。

&gt;&gt;
フレームとロカールの対応についても初めて知りました。論理の研究になぜトポス理論が関係してくるのかが、これでなんとなく納得できたしだいです。
&lt;&lt;
そういえば、フレーム／ロカールは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060213/1139819106&quot;&gt;「Setの反対圏からのimplication」&lt;/a&gt;でチョット触れましたね。

位相のほうから言えば、古典論理に対応するブール空間てのはかなり特殊です、全不連結ですから。開集合と閉集合の区別があまりなくて、clopen setsがすごくたくさんある空間です。もっと一般の位相まで考えると、直観主義論理が出てきます。

つまり、「ブール空間→普通(?)の位相空間」が、「古典論理→直観主義論理」。束論的には「ブール束→ハイティング束」でしょうね。それで、束論の側で「ブール束→ハイティング束→もっと一般の束（フレーム）」と調子にのって一般化する、「ブール空間→普通(?)の位相空間→点概念がなくてもいい空間（ロカール）」となるのでしょう、たぶん。

一方で、直観主義論理の圏論的対応物がCCCやトポスになるので、空間、束、圏などは、同じものを別な定式化で見てるだけのようです、どうも。

&gt;&gt;
また、「可換環」から「可換性」や「分配則」などの条件をはずせば、なにか新しい「論理」が得られるのでしょうか。
&lt;&lt;

非可換に関しては、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061019/1161231813&quot;&gt;「論理とはなにか？」&lt;/a&gt;で紹介したLutz Strassburgerが、&lt;a href=&quot;http://citeseer.ist.psu.edu/guglielmi04noncommutative.html&quot;&gt;A Non-commutative Extension of Multiplicative Exponential Linear Logic&lt;/a&gt;なんてのを書いてますし、他にもnoncommutative linear logicネタはあるようです。クオンテール／クオンタロイド（quantale/quantaloid）も一般には非可換なモノです。

分配律を変形したものでは、linearly distributive（以前はweakly distributive） lawなんてのがあります。Cockett, Seelyの&quot;Weakly Distributive Categories&quot;（http://citeseer.ist.psu.edu/cockett91weakly.html）あたりからでしょうか。線形分配律は、a×(b + c) = a×b + c  という形です。

もっとも、名前が分配でも、これは分配律とは別物だからdissociative law（解離法則）と呼ぼう、とかいうハナシもあるようですが。

*1162888657*[形式言語理論][その他代数]半環イロイロ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061026/1161847087&quot;&gt;Esik/Kuichの&quot;Inductive *-Semirings&quot;&lt;/a&gt;から定義などを抜き書き。

単項の演算*を持つ半環をスター半環と呼ぶ（それだけの話、他に特別な意味はない）。

&lt;hr&gt;
&lt;strong&gt;帰納的スター半環&lt;/strong&gt;（inductive *-semiring）は：

+ 順序半環（半環演算が単調）
+ a・a* + 1 ≦ a* [不動点不等式;the fixed point enequation]
+ a・x + b ≦ x  ⇒ a*・b≦x [不動点帰納法; the fixed point induction rule]

不動点等式 a・a* + 1 = a* は定理として出る。スターが単調なことも定理。不動点と帰納原理の半環による定式化。

&lt;hr&gt;
&lt;strong&gt;連続半環&lt;/strong&gt;（contiuous semiring）とは：

+ 順序半環
+ 0を最小元とするCPO（任意の族がsupを持つ）
+ 和と積はCPO構造に関して連続

Σa&lt;sub&gt;i&lt;/sub&gt;は、sup(a&lt;sub&gt;i&lt;/sub&gt;の有限和)で定義できる。

&lt;hr&gt;
&lt;strong&gt;連続スター半環&lt;/strong&gt;（continuous *-semiring）とは：

+ 連続半環である。
+ スターはクリーネ級数の総和で与えられる。

連続スター半環は帰納的スター半環になる。クオンテールは連続スター半環になるので、帰納的スター半環である。

&lt;hr&gt;
スターを持つ順序半環において、次を&lt;strong&gt;弱不動点帰納法&lt;/strong&gt;（weak fixed point induction rule）と呼ぶ。

- a・x + b = x ⇒ a*・b ≦ x （a*はどんな真の不動点よりも小さい）

不動点帰納法は、「a・x + b ≦ x  ⇒ a*・b≦x 」と少し強い。

&lt;hr&gt;
&lt;strong&gt;コンウェイ半環&lt;/strong&gt;（Conway semiring）とは：

+ 和スター等式 (a + b)* = (a*・b)*・a*
+ 積スター等式 (ab)* = 1 + a・(ba)*・b

帰納的スター半環はコンウェイ半環となる。

&lt;hr&gt;
&lt;strong&gt;弱帰納的スター半環&lt;/strong&gt;（weak inductive *-semiring）とは：

+ 順序半環
+ 不動点等式 a・a* + 1 = a*
+ 和スター等式 (a + b)* = (a*・b)*・a*
+ 弱不動点帰納法 a・x + b = x ⇒ a*・b ≦ x

弱帰納的スター半環もコンウェイ半環になる。

&lt;hr&gt;
順序半環が&lt;strong&gt;和順序&lt;/strong&gt;（sum-ordered）とは：

- a≦b ⇔ ∃c. a + c = b

和順序半環が弱帰納的スター半環であるときに、いくつかの定理がある。

&lt;hr&gt;
スター半環Sに関する次の条件は同値：

+ Sはコンウェイ半環
+ Sの2×2行列が不動点方程式（等式）を満たす
+ 任意のnにおいて、Sのn×n行列（n≧1）が不動点方程式（等式）を満たす
+ あるnにおいて、Sのn×n行列が不動点方程式（等式）を満たす
+ Sの下三角2×2行列が不動点方程式（等式）を満たす
+ Sの上三角2×2行列が不動点方程式（等式）を満たす

これはコンウェイ圏（コンウェイ／ベキック圏；圏的不動点オペレータを持つデカルト圏）における定理にできそうだ。

&lt;hr&gt;
コンウェイ半環が&lt;strong&gt;反復半環&lt;/strong&gt;（iteration semiring）とは：

- どんな有限群Gに対しても、Gの群等式を満たすこと。

群等式の定義は省略。

&lt;hr&gt;
次の双対性がある。

- Sがコンウェイ半環である⇔S&lt;sup&gt;op&lt;/sup&gt;がコンウェイ半環

&lt;hr&gt;
帰納的スター半環が&lt;strong&gt;対称帰納的スター半環&lt;/strong&gt;（symmetric - ）であるとは：

- 双対不動点帰納法 x・a + b ≦ x ⇒ b・a* ≦ x

連続スター半環は対称帰納的スター半環である。Sが対称なら行列半環も対称になる。

&lt;hr&gt;
&lt;strong&gt;コゥゼン半環&lt;/strong&gt;（Kozen semiring）とは：

+ 加法的ベキ等
+ 対称帰納的スター半環

コゥゼン半環は&lt;strong&gt;クリーネ代数&lt;/strong&gt;のことである。クリーネ／コゥゼン半環あたりが妥当な呼び方か？

&lt;hr&gt;
Sがスター半環、A⊆Sとして、A上の&lt;strong&gt;コンウェイ機構&lt;/strong&gt;（mechanism）とは：

- n≧0
- α∈{0, 1}&lt;sup&gt;1×n&lt;/sup&gt;
- β∈{0, 1}&lt;sup&gt;n×1&lt;/sup&gt;
- M∈(A∪{0, 1})&lt;sup&gt;n×n&lt;/sup&gt;
- (α, M, β)がコンウェイ機構

Dがコンウェイ機構のとき、Dの&lt;strong&gt;振る舞い&lt;/strong&gt;（behaviour）とは：

- 行列の積 αM*β ∈S

Sに関して次が成立するとき、Sはクリーネ型定理（Kleene-style, Kleene-type）を満たすと呼ぶことにする（これは檜山）。

- Aから生成されたSの部分スター半環と、あらゆるコンウェイ機構に関する振る舞いの全体が一致する。

コンウェイ半環はクリーネ型定理を満たす。

文法／正規表現／オートマトン受理の同等性が本来のクリーネ型定理である。


</body>
</day>
<day date="2006-11-09" title="">
<body>
*1163043589*[雑記]やっとわかった！デカルト圏

セリンガーが、「対角を持つ圏に、複製可能性と破棄可能性を入れたらデカルト圏だ」と言っていた。「そんなことはフォークロアだ」とも。が、僕はどうしていいものか方針が掴めなかった。

ランベックの定式化（演繹系としてのデカルト圏）をあいだにはさむと、結果は自明になる。次のような圏は同じものだ。

+ 有限離散完備な圏（&lt;em&gt;有限完備ではない！&lt;/em&gt;）
+ 終対象と二項直積（binary product）を持つ圏
+ 任意のA, Bに対して、A, Bを足に持つスパン(Y, p1:Y→A, p2:Y→B)で、スパンによる射の分解Hom(X, C)→Hom(X, A)×Hom(X, B)が双射となるものが存在する。
+ ランベック流の定式化による(a la Lambek)デカルト圏
+ セリンガー流の定式化による(a la Selinger)デカルト圏

標準的定義は「終対象＋二項直積」だろう。これからランベック流は難しくないが、スパンによる分解を中継すると自然に出来る。ランベック流とセリンガー流の同値性は、ひたすら計算すればいい。

モノイド単位1が終対象であることも：
- f:A→1があるとき、f= f;id&lt;sub&gt;1&lt;/sub&gt; = f;!&lt;sub&gt;1&lt;/sub&gt; = !&lt;sub&gt;A&lt;/sub&gt;
として等式的に出る。

Hom(X, C)≒Hom(X, A)×Hom(X, B) とか、次の最も基本的事実が効いていることがよくわかった。
- f = g ⇔ f;π&lt;sup&gt;i&lt;/sup&gt; = g;π&lt;sup&gt;i&lt;/sup&gt; for all i's

直積のup to isoでの一意性も、これから出るし。

*1163049291*[圏一般論][形式言語理論][山勘]コゥゼン圏（Kozen圏）とクリーネ圏（Kleene圏）

デカルト圏の理解が少し進んだので、ここでメモ：

&lt;b&gt;関連：&lt;/b&gt;
+ [http://d.hatena.ne.jp/m-hiyama-memo/20060619/1150676276:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20060705/1152068961:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20060706/1152164791:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20061005/1160039367:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20061024/1161648695:title]

+ [http://d.hatena.ne.jp/m-hiyama-memo/20060817/1155784617:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031283:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20061006/1160126861:title]

&lt;hr&gt;

(∇, η)が代数（モノイド圏上のglobal monoid structure）、(Δ, ε)が余代数のとき、Δが(∇, η)-半加法的になっていることを具体的に書いてみると、□=∇;Δ となる。εに関しては、Δ;ε = (ε×ε);δ'が出てくる。つまり、ベスパロフ式の双代数条件は、通常の「余代数演算が代数射」と同じ条件である。「(Δ, ε)が代数射」は分かりやすいが、ベスパロフ式のほうが対称性があってよいと思う。

さて、(∇, η)（僕はηよりθを使っていた）と(Δ, ε)（僕はεより!を使っていた）が同じモノイド圏上で双代数を定めるとき、任意の射に対して加法性／余加法性（複製法則）、単位性／余単位性（破棄法則）を要求すると、その圏は双デカルトになる。双デカルトは、デカルトかつ余デカルトだけではなくて、双代数法則（代数-余代数の協調法則）が必要になる。

双デカルト圏は必然的に、アーベル（可換）モノイドの圏をAbMonとしてのAbMon圏になる。ベキ等性 Δ;∇ = 1 を持てば、必然的にジョイン半束を経由して（局所）順序圏となる。双デカルト圏のモノイド積は、実は双積だから、双デカルトなら、「AbMonでエンリッチ（豊饒化）された零対象／双積付きの圏」となる。

加法圏が、「零対象と双積を持つAb圏」であることから、「零対象と双積を持つAbMon圏」は&lt;strong&gt;半加法圏&lt;/strong&gt;と呼んでよいだろう。半加法圏では、End(A)が必ず（0も1もある）半環となる。ケリーの結果を使うと、特にEnd(1)は可換半環である。

ここまで分かると、コゥゼン圏と半加法的クリーネ圏の違いは、スター帰納法「a;x≦x⇒a*;x≦x、x;b≦x⇒x;b*≦x」が使えるかどうかだけのような気がする。一様性原理「a;x = x;b ⇒a*;x = x;b*」 との関係がハッキリすると、一様性原理が成立するコゥゼン圏が半加法的クリーネ圏に一致するかもしれない。

すべての射が厳密射（酵素射）であるような圏を&lt;strong&gt;全一様圏&lt;/strong&gt;（totally uniform; 厳密圏はマズイ用語になるから）と呼ぶことにする。すると：

- &lt;span style=&quot;font-size:large;&quot;&gt;全一様コゥゼン圏と半加法的クリーネ圏は同じ&lt;/span&gt;

じゃなかろうか？ ？？

</body>
</day>
<day date="2006-11-10" title="">
<body>
*1163147851*[プログラム意味論][トレース／コンパクト閉圏][形式言語理論]一様性原理

長谷川の一様性原理：
&lt;pre&gt;
 f:A+X→B+X, g:A+Y→B+Y, ψ;X→Y,  f;(B+ψ) = (A+ψ);g
 -----------------------------------------------------[HU]
 Tr(f)  = Tr(g) : A→B
&lt;/pre&gt;

プロトキン（Plotkin）の一様性原理：
&lt;pre&gt;
 f:A+X→X, g:A+Y→Y, ψ;X→Y,  f;ψ = (A+ψ);g
 -----------------------------------------------------[PU]
 Fix(f);ψ = Fix(g) : A→Y
&lt;/pre&gt;

クリーネ／コゥゼン（Kleene/Kozen）の一様性原理：
&lt;pre&gt;
 f:X→X, g:Y→Y, ψ;X→Y,  f;ψ = ψ;g
 -----------------------------------------------------[KU]
 Rep(f);ψ  = ψ;Rep(g) : X→Y
&lt;/pre&gt;

クリーネ／コゥゼンの帰納原理（スター帰納法）：
&lt;pre&gt;
 f:X→X, ψ;X→Y,  f;ψ ≦ ψ
 -----------------------------------------------------[KI-1]
 Rep(f);ψ ≦ ψ : X→Y

 g:Y→Y, ψ;X→Y,  ψ;g ≦ ψ
 -----------------------------------------------------[KI-2]
 ψ;Rep(g) ≦ ψ : X→Y
&lt;/pre&gt;

*1163148024*[プログラム意味論][トレース／コンパクト閉圏][形式言語理論]一様性を持つ圏

Dは対称モノイド圏、CはDの部分対称モノイド圏で |C| = |D|。C上にトレースTrが存在する。SはDの射の族（必ずしも部分圏でなくともよい）として、Iso(D)⊆S だとする（Iso(D)はDのiso全体）。

+ k∈S、i∈Iso(D) ならば (i + k)∈S
+ f∈C, k∈S ならば、f;k, k;f∈C
+ 一様性原理を満たす。

(D, C, Tr, S)の組を、&lt;strong&gt;一様性を持つ部分トレース付き圏&lt;/strong&gt;（partially traced category with uniformity）と呼ぼう。


</body>
<comments>
<comment>
<username>ＭＭ</username>
<body>m-hiyamaさん、&lt;br&gt;先日はつたないコメントに注釈をいただきましてありがとうございました。&lt;br&gt;いろいろ教えてくださり感謝しておる次第です。あれから計算モデル論など&lt;br&gt;について勉強しているところです。計算のモデルにはいろいろなものがある&lt;br&gt;ことを知りました。自分の持っている本には書いてないのですが、それぞれ&lt;br&gt;のモデルのあいだの関係は、それらに対応して存在する圏の同値関係である、&lt;br&gt;と思ってよいのでしょうか。たとえば、ラムダ計算の圏を適当な関手により&lt;br&gt;抽象書換系の圏に埋め込んでやる、などといった意味です。この方面の何か&lt;br&gt;よい教科書をご存知でしたらご教示ください。</body>
<timestamp>1163779341</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>MMさん、&lt;br&gt;&gt; あれから計算モデル論など&lt;br&gt;&gt; について勉強しているところです。&lt;br&gt;勉強熱心ですね。学生さんですか？&lt;br&gt;僕は若い頃は全然勉強しなかったので（コンピュータとも無縁だったし）、いまごろ後悔してます。勉強はできるときにやっておけ -- と年寄りから忠告しておきましょう。&lt;br&gt;さて、&lt;br&gt;&gt; それぞれ&lt;br&gt;&gt; のモデルのあいだの関係は、それらに対応して存在する圏の同値関係である、&lt;br&gt;&gt; と思ってよいのでしょうか。&lt;br&gt;すべてがそのような定式化でカバーできるかどうかはわかりません。圏と相性がよくない計算モデルや計算現象があるかもしれませんから。&lt;br&gt;&gt; たとえば、ラムダ計算の圏を適当な関手により&lt;br&gt;&gt; 抽象書換系の圏に埋め込んでやる、などといった意味です。&lt;br&gt;そのテのことならできそうですね。&lt;br&gt;&gt; この方面の何か&lt;br&gt;&gt; よい教科書をご存知でしたらご教示ください。&lt;br&gt;本文エントリー http://d.hatena.ne.jp/m-hiyama-memo/20061118/1163803383 参照。</body>
<timestamp>1163803516</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>P.S.&lt;br&gt;&gt; 自分の持っている本には&lt;br&gt;これはどういう本ですか？</body>
<timestamp>1163803714</timestamp>
</comment>
<comment>
<username>ＭＭ</username>
<body>m-hiyama さん、&lt;br&gt;＞勉強熱心ですね。学生さんですか？&lt;br&gt;m-hiyama さんほどではないと思いますよ。自分は学生ではなく、子供の頃&lt;br&gt;から好きだった数学をひとりで学んでいます。計算機については教養として&lt;br&gt;やっておくべきではないか、と思っていました。実際はじめてみると、これは&lt;br&gt;数学の一種または一部であるとみなせるような気がしてきます。&lt;br&gt;＞これはどういう本ですか？&lt;br&gt;井田哲雄著「計算モデル論入門」（http://www.amazon.co.jp/gp/product/&lt;br&gt;4781911358）という本です。ページ数が少なく２色刷りで目にやさしい初学者&lt;br&gt;向けの本です。圏論やタイプ理論については何も書かれていません。&lt;br&gt;リンク先にご紹介されていた横内寛文著「プログラム意味論」を今月はじめ&lt;br&gt;に注文したのですが、在庫がないらしくしばらくかかるということです。&lt;br&gt;Lambek 氏の本は読みやすそうでね。２０年近く前すでにＣＣＣやタイプ理論&lt;br&gt;とトポス理論の関係についても書かれていたのですか。すこし驚きました。</body>
<timestamp>1163834243</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>ＭＭさん、&lt;br&gt;＞ m-hiyama さんほどではないと思いますよ。&lt;br&gt;いやっ、手遅れですよ→http://d.hatena.ne.jp/m-hiyama/20060426/1146014764 参照。&lt;br&gt;＞ 実際はじめてみると、これは数学の一種または一部であるとみなせるような気がしてきます。&lt;br&gt;そうですね。あんまり区別はないようです。数理物理学と普通の数学の境界が曖昧なのと同程度に（あるいはそれ以上に）境界は曖昧でしょう。&lt;br&gt;＞ 井田哲雄著「計算モデル論入門」&lt;br&gt;これは知りませんでした。&lt;br&gt;＞ Lambek 氏の本は読みやすそうでね。&lt;br&gt;いい本だと思います。が、最初に読むよりは、他で勉強した後で違った視点からの眺望を得るのに適切かと。最初に読むなら、http://d.hatena.ne.jp/m-hiyama/20060519/1148006565 で触れているWaltersの本なんか楽しいですね。</body>
<timestamp>1163838584</timestamp>
</comment>
</comments>
</day>
<day date="2006-11-18" title="">
<body>
*1163803383*[雑記][リンク]圏論とラムダ計算の参考書

次のエントリー内で書籍に触れています。

- [http://d.hatena.ne.jp/m-hiyama/20050510/1115684652:title]→プログラミング言語の基礎理論、プログラム意味論
- [http://d.hatena.ne.jp/m-hiyama/20050407/1112859321:title]→プログラミング言語の基礎理論
- [http://d.hatena.ne.jp/m-hiyama/20050331/1112232384:title]→Categorical Logic and Type Theory, Handbook of Categorical Algebra 2
- [http://d.hatena.ne.jp/m-hiyama/20060519/1148006565:title]→Categories and Computer Science

圏論、論理、計算論の関係については、&quot;Introduction to Higher-Order Categorical Logic&quot; by Lambek &amp;amp; Scott（http://www.amazon.co.jp/gp/product/0521356539）も面白い。


</body>
</day>
<day date="2006-11-25" title="">
<body>
*1164428200*[連絡的]分類タグ「連絡的」とは 

同名のエントリーが[http://d.hatena.ne.jp/m-hiyama/20061115/1163566253:title]にある。メモ編にも分類タグ「連絡的」を設けるが趣旨は同じ。本編をあまり連絡に使うと、どうも“雑音”になりそうなので、ある程度の一般性がある場合、まとめのとき以外はこのメモ編を使う。

*1164429543*[トレース／コンパクト閉圏][論理]部分トレース付き圏（Partially Traced Category）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163148024&quot;&gt;「一様性を持つ圏」&lt;/a&gt;において、部分的に定義されたトレースの概念を導入したが、僕よりずっと気が利いた定義が、&quot;Towards a Typed Geometry of Interaction&quot; by Esfandiar Haghverdi, Phillip J. Scott （http://www.site.uottawa.ca/~phil/papers/HS-APAL-05.pdf）にあった。

これは、&lt;a href=&quot;http://iml.univ-mrs.fr/~girard/&quot;&gt;ジラール&lt;/a&gt;のGoIの拡張であるMGoI（Multiobject GoI）を提唱している論文。部分トレース付き圏の定義はけっこう複雑。C = (C, ×, I, σ)が対称モノイド圏として、Cをベースとしてその上に構造を載せていく。

X, Y, U∈|C|ごとに、3パラメータの集合族T(X, Y; U)⊆C(X×U, Y×U)が指定される。Tが全体として部分圏となることは&lt;em&gt;要求しない&lt;/em&gt;。トレースの各公理に対応して、Tに要求される条件を決めていく。

+ タイトニング（自然性）g:X'→X, h:Y→Y' のとき、 f∈T(X, Y; U),  ⇒ (g×U);f;(h×U)∈T(X, Y;U)
+ スライディング（対角自然性） f:X×U→Y×U', g:U'→U のとき、f;(Y×g)∈T(X, Y; U) ⇔ (X×g);f ∈T(X, Y; U7)
+ バニッシング I T(X, Y; I) = C(X×I, Y×I)
+ バニッシング II g∈T(X×U, Y×U; V) のとき、g∈T(X, Y; U×V) ⇔ Tr&lt;sub&gt;X×U, Y×U&lt;/sub&gt;&lt;sup&gt;V&lt;/sup&gt;(g)∈T(X, Y; U)
+ スーパーポージング f∈T(X, Y; U), g:W→X ⇒ g×f∈T(W×X, Z×Y; U)
+ ヤンキング σ&lt;sub&gt;U, U&lt;/sub&gt;∈T(U, U; U)

定義域に関する条件を上のようにして、後は通常のトレース公理群をかんがえる。

トレースの定義域であるT⊆Morph(C)を&lt;strong&gt;トレースクラス&lt;/strong&gt;と呼ぶ。トレースクラスに属する射は&lt;strong&gt;トレーサブル射&lt;/strong&gt;、または（用語の濫用で）&lt;strong&gt;トレースクラス射&lt;/strong&gt;と呼ぶ。トレースクラス上で定義された部分トレースも含めて&lt;strong&gt;トレースクラス構造&lt;/strong&gt;と呼ぶこともある。

トレースクラス構造(T, Tr)を備えた対称モノイド圏が&lt;strong&gt;部分トレース付き圏&lt;/strong&gt;である。

印象的な例は、有限次元ベクトル空間と直和の圏で、X(+)U→Y(+)U を行列表示したときの2-2成分をd:U→Uとして、U - d:U→Uが可逆であるモノをT(X, Y; U)として、言語理論と同様に(U - d)&lt;sup&gt;-1&lt;/sup&gt; = d&lt;sup&gt;*&lt;/sup&gt; = 1 + d + d&lt;sup&gt;2&lt;/sup&gt; + ... を使ってトレースを定義した圏。

もうひとつの例は、完備距離空間の非拡張的（non-expansive）連続写像からなる圏にトレースクラス構造を定義したもの。fがトレースクラスであるのは、f:X×U→Y×U として、x∈Xごとに決まるπ2・λu.f(x, u):U→U が一意不動点を持つとき。

注意すべきは、π2・λu.f(x, u) が、どんなxに対しても縮小写像という定義では整合性に欠けること。スライディングとバニッシングIIが成立しない。

トレースクラス、部分トレース付き圏の定義はけっこう面倒だが、&lt;a href=&quot;http://cm.bell-labs.com/who/ajeffrey/&quot;&gt;アラン・ジェフリー&lt;/a&gt;の簡略化されたトレース公理により少し簡略化できるかもしれない→[http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031284:title]。プロトキン、長谷川などの一様性原理を考えるのも部分トレース付き圏がふさわしい気がする。

つまり、トレースクラス構造と厳密クラス（または酵素クラス）構造をもった圏を考えて、そこで一様性原理（ホーン等式で記述される）を導入することになる。→[http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163147851:title]、→[http://d.hatena.ne.jp/m-hiyama-memo/20061109/1163049291:title]。これは、証明論（カット消去）にも関係するらしい。


</body>
</day>
<day date="2006-12-01" title="">
<body>
*1164960302*[雑記][その他代数]半環／半加群の次元論は難しい

ショー君に頼んで、

- Wagneur, E. &quot;Moduloids and Pseudomodules. I. Dimension theory.&quot; Discrete Mathematics, 98, 57-73, 1991

を入手した。確かに次元論について書いてあるのだが、どうも仮定が強すぎる。一般論は絶望的だから、仮定が必要なのは当然だが、全順序は受け入れられないなー。ムグー。

*1164960303*[トレース／コンパクト閉圏]一様性を持つ部分トレース付き圏（partially traced category with uniformity）

今後、Haghverdi/Scott（ハグヴェルディ(?)／スコット）の意味で用語「部分トレース付き圏」を使う→http://www.site.uottawa.ca/~phil/papers/HS-APAL-05.pdf 。

一様性（uniformity）を持つ部分トレース付き圏を定義する； 対称モノイド圏C = (C, ×, 1, σ)にトレースクラスTと部分トレースTrがあるとする。さらに、厳密射のクラスS⊆Morph(C)を考える。長谷川に従って、Sには次の性質を要求する。

+ Iso(C)⊆S （Iso(C)はCの同型の全体）
+ Sはモノイド的（テンソル的）、つまり、f, g∈S ⇒ f×g∈S

Sが部分圏となるとは限らないことに注意。

トレースクラスTと厳密クラスSの関係は、次のように記述されるだろう。

- f∈T(A, B; X), h∈S(X, Y), (A×h);g = f;(B×h) ⇒ g∈T(A, B, Y)
- g∈T(A, B; Y), h∈S(X, Y), (A×h);g = f;(B×h) ⇒ f∈T(A, B, X)

同じ事だが、

- h∈S(X, Y), (A×h);g = f;(B×h) ⇒ [f∈T(A, B; X) ⇔ g∈T(A, B; Y)]

一様性原理（酵素ルール）は：

- f∈T(A, B; X), g∈T(A, B; Y), h∈S(X, Y), (A×h);g = f;(B×h) ⇒ Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f) = Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;Y&lt;/sup&gt;(g) : A→B

厳密クラスSを備え、一様性原理が成り立つ部分トレース付き圏が、&lt;strong&gt;一様性を持つ部分トレース付き圏&lt;/strong&gt;。どんな部分トレース付き圏でも、S = Iso(C)として自明に一様性を持つ。

とりあえず、不定元を対象として級数を射とする圏を考えてみたい。


</body>
</day>
<day date="2006-12-02" title="">
<body>
*1165029125*[論理]論理記号のいろいろ 

[http://d.hatena.ne.jp/m-hiyama/20061202/1165020456:title]にもあるけど、転記。

&lt;img src=&quot;http://www.chimaira.org/img/logical-symbols.gif&quot; &gt;

*1165029369*[トレース／コンパクト閉圏][プログラム意味論]一様性を持つ部分トレース付き圏の周辺

一様性を持つ部分トレース付き圏に関連すること。

- クリーネ圏（Kleene圏）におけるスター一様性原理 a;x = x;b ⇒ a*;x = x;b* の良い解釈
- クリーネ圏における再帰原理 a;x ≦ y ⇒ a*;x ≦ y の良い解釈
- 級数 1 + x + x^2 + ... の一般的な（発散するケースも含めた）取り扱い。
- 双模倣の抽象的定式化
- トレースを使って振る舞い関手を定義する方法
- マイヒル／ネロード型の定理
- 最小化モナド構造（notion of behaviour）の定式化→[http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943257:title]

一様性を弱めたものとして：
- a;x ≦ x;b ⇒ a*;x ≦ x;b*
がある。トレース付きの局所順序圏での定式化がなにかできないか？ &lt;em&gt;片側模倣を圏論的に定式化する&lt;/em&gt;のがヒントになるかもしれない。

</body>
</day>
<day date="2006-12-04" title="">
<body>
*1165193527*[山勘][プログラム意味論]一様性原理と模倣／双模倣

クリーネ圏（Kleene圏）では、スター帰納法が基本になる。
&lt;pre&gt;
 f:X→X, ψ;X→Y,  f;ψ ≦ ψ
 -----------------------------
 Rep(f);ψ ≦ ψ : X→Y

 g:Y→Y, ψ;X→Y,  ψ;g ≦ ψ
 -----------------------------
 ψ;Rep(g) ≦ ψ : X→Y
&lt;/pre&gt;

これから次の一様性原理が出る。
&lt;pre&gt;
 f:X→X, g:Y→Y, ψ;X→Y,  f;ψ = ψ;g
 --------------------------------------
 Rep(f);ψ  = ψ;Rep(g) : X→Y
&lt;/pre&gt;

よって、半加法的クリーネ圏は、全一様性を持つコゥゼン圏（Kozen圏）となる。問題はその逆だが、等式的な一様性原理から不等式である帰納法を出すのは困難な気がしてきた。それなら、トレースに関して、不等号で定式化される帰納原理を考えたほうがいいのではないか。 Tr(f)  ≦ Tr(g) となるようなヤツ。

山勘では、模倣／双模倣が事例になるような気がする。バーグストラ、ステファネスクとかに書いてあるか？

- &quot;Bisimulation is Two-Way Simulation&quot; (1994)  by Bergstra, Stefanescu （http://citeseer.ist.psu.edu/58109.html）
- &quot;Studying Equivalences of Transition Systems with Algebraic Tools&quot; (1995) by Pasquale Malacaria（http://citeseer.ist.psu.edu/489182.html）

を読んでみよう。


</body>
</day>
<day date="2006-12-05" title="">
<body>
*1165296597*[圏一般論][リンク][マンダラ]二重圏

二重圏（double categories）についての概要は、これがいいと思う。

- Tom Fioreのプレゼン資料&quot;Double Categories and Pseudo Algebras&quot;→http://www.math.uchicago.edu/~fiore/1/fiorefolding.pdf

*1165306116*[janus][プログラム意味論][マンダラ]コンポネントとマンダラ再論

以前、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060606/1149560697&quot;&gt;マンダラの話&lt;/a&gt;を書いたが、ついつい単純なものを求めたくなる。いかん、いかん。

&lt;span style=&quot;font-size:x-large;&quot;&gt;世界はどえらく複雑なのだ！&lt;/span&gt;

とりあえずコンポネントの圏がどれほどに複雑かを思い出しておこう。出力付きのリグラフ（rigraph）でコンポネントがモデル化されているとする。入力アルファベットはA、出力アルファベットがB、始（初期）状態がI、終状態がF、全状態がSだとする。
簡単のために入力ポートも出力ポートも常に1本だとすると、Iから状態遷移を初めてFに至る実行経路（ラン）により、A&lt;sup&gt;*&lt;/sup&gt;→L(B) = Pow(B&lt;sup&gt;*&lt;/sup&gt;) が決まる。

S上の遷移翻訳（トランスデュース；変換）規則をτとして、τ=(S, I, F, A, B, τ)のように略記する。すると：

- τは、I→F という射とみなせる。結合は境界のグルーイングτ#ρである。
- τは、A→B という射とみなせる。結合は入出力同期結合τ;ρである。
- 直和τ+ρも考えられる。
- 直積τ×ρも考えられる。
- グラフのマップまたは関係f:τ→ρは、2-射と考えられる。
- +, #に関して繰り返し型の（加法的）トレースATrが作れる
- ×, ;に関して存在型の（乗法的）トレースMTrが作れる
- +, #に関するトレースから時間逆行（または反粒子）を許すコンパクト閉圏が作れる
- ×, ;に関するトレースから双方向の対話圏（コンパクト閉圏）が作れる

相空間と力学法則のアナロジーも使えるし、線形代数、形式言語理論のアナロジーも使える。が、どれよりも&lt;em&gt;もっと複雑&lt;/em&gt;だ。単純化しないで、ガマン、そのまま定式化しないとね。


</body>
</day>
<day date="2006-12-06" title="">
<body>
*1165387989*[圏一般論][プログラム意味論][janus]モノイド二重圏

二重圏の定義としては、「“圏の圏Cat”のなかの圏対象（内部圏）」というのが一番スッキリしていると思う。だが、この定義だと、演算法則が露骨に表示されないので、具体性に乏しいし、実際の計算もやりにくい。それに巨大な（小さくない）二重圏の定義には不安がある。

それで、演算を具体的に書き下ろした初等的（1階述語論理ベースの）定義が欲しくなる。初等的定義は、例えば、ロベルト・ブルーニ、ウーゴ・モンタナリ（Roberto Bruni, Ugo Montanari）の&quot;Cartesian Closed Double Categories, ...&quot;（http://citeseer.ist.psu.edu/216729.html）にある、あまり形式的な定義ではないけど。

「圏の圏の圏対象」(苦笑)という定義と初等的定義は一長一短。だが、「圏の圏の圏対象」なら、イコールの代わりに圏同値を使えば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060208/1139386572&quot;&gt;弱二重圏&lt;/a&gt;（あるいは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060801/1154404268&quot;&gt;疑二重圏&lt;/a&gt;かな）を定義できる。それと、「モノイド圏の圏の圏対象」としてモノイド二重圏（monoidal double categories）もすぐさま定義できる。

適当なアンビエント圏（それ自体が構造を持つ圏でもよい）のなかで、内部構造（internal structure）を考えるのはうまい方法だ。ひょっとして、ステファネスクのMIX代数は、「トレース付き圏の圏の“トレース付き圏”対象」とか「モノイド二重圏の圏の“トレース付き圏”対象」とかにならないかな？

境界付きグラフの圏、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061101/1162367554&quot;&gt;リグラフ（rigraph）の圏&lt;/a&gt;はモノイド二重圏だし、遷移翻訳系（トランスデューサ）の圏は、モノイド二重圏にさらに別なモノイド構造とトレースが加わった構造になっている。モノイド積が2つあれば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060817/1155783593&quot;&gt;半環圏（semiringal categories）&lt;/a&gt;も自然に出てくるだろう、たぶん。

*1165391282*[リンク][圏一般論]二重圏の参考文献

実は、トーマス・カーラー（Thomas Kerler→http://www.math.ohio-state.edu/~kerler/）の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061021/1161414971&quot;&gt;本&lt;/a&gt;がいつまで待ってもこないのでイライラ。

とりあえず、二重圏について調べることにした。

- &quot;Double Categories and Pseudo Algebras&quot; by Tom Fiore →http://www.math.uchicago.edu/~fiore/1/fiorefolding.pdf 印刷してない
- &quot;Cartesian Closed Double Categories, their Lambda-Notation, and the Pi-Calculus&quot; by  Roberto Bruni, Ugo Montanari→http://citeseer.ist.psu.edu/216729.html 印刷済み
- &quot;A categorical construction of 2-dimensional extended Topological Quantum Field Theory&quot; by Vishvajit V. S. Gautam →http://arxiv.org/abs/math.QA/0308298 印刷済み
- &quot;Double Categories in Mathematical Physics&quot; by S.S. Moskaliuk,  A.T. Vlassov →http://citeseer.ist.psu.edu/371467.html 印刷済み
- &quot;Higher Algebra, Extended TQFT's, and 3D Quantum Gravity&quot; by Jeffrey Morton →http://math.ucr.edu/~morton/extendedtqft-talk.ps 印刷済み

Morton（http://math.ucr.edu/~morton/）はBaezの学生だそうで、http://math.ucr.edu/~morton/Mstuff.pdf に楽しそうなことが書いてある。

ついでに、これも面白い。

- &quot;Topology and Higher-Dimensional Category Theory: the Rough Idea&quot; by Tom Leinster →http://arxiv.org/abs/math.CT/0106240


</body>
</day>
<day date="2006-12-07" title="">
<body>
*1165461744*[山勘]いろいろな繋がり

境界付き（有向）グラフの圏が“モノイド二重圏＝モノイド圏の圏の圏対象”のになるのは明らかだし、水平方向（コボルディズムの時空時間方向といってもよい）の結合に関しては加法的（繰り返し的、時間的）トレース・オペレータが存在する。このトレース・オペレータは、到達可能性を表現する。

この状況から、二重圏よりもっと一般的な状況が推測できる。ベース二重圏の上により大きな二重圏が広がっていて、境界オペレータ関手δ&lt;sub&gt;0&lt;/sub&gt;, δ&lt;sub&gt;1&lt;/sub&gt;とトレースTrがファイブレーションを与えているようだ。そして、二重ファイブレーション(δ&lt;sub&gt;0&lt;/sub&gt;, δ&lt;sub&gt;1&lt;/sub&gt;, Tr)が振る舞い関手、あるいはTQFT関手を与えている（少なくともその一部を構成している）。

具体例では、ベース二重圏は二部グラフを境界付きグラフとみなした二重圏、全体二重圏は一般の境界付きグラフの圏。

山勘もいいところだが、トレース、低次元幾何トポロジーのハンドル体、結び目のマルコフの定理、証明の正規化は関連しそうだ。同じ構造を持っている。

コンポネントの圏は、hom-setが二重ファイブレーションの構造を持つ。よって、二重ファイブレーションの圏DoubleFibを定義して、コンポネント圏はDoubleFibエンリッチな圏となるのだろう。実際、これはやたらにリッチな圏となる。しかも単なる圏ではなくて、モノイド積を持ちトレース（乗法的トレース、むしろ隠蔽的／存在的トレース）も持つ。

&lt;span style=&quot;font-size:large;&quot;&gt;ジャングルのように複雑だ。だが、法則性と構造を持つ整合的ジャングルのはずだ。&lt;/span&gt;

*1165474736*[山勘][トレース／コンパクト閉圏][janus]トレース、振る舞い、TQFT

振る舞い関手は、加法的TQFT関手なのだろう、たぶん。物理のTQFTは、テンソル積と乗法的トレースを持つベクトル空間の圏を値圏にするが、振る舞い関手は、双積と加法的トレースを持つコゥゼン圏に値を取る。

1-in 1-outの入出力仕様がA→Bであるようなコンポネントc:A→Bの振る舞いは、β(c):β(A)→β(B)で記述されるが、ここで、β(A)=Lang(A)=(アルファベットAの言語半環)、β(c)は半環の射となる。この例では、半環の圏に値を持つが、より一般には半環の行列圏に値をとる。

コンポネントの入出力結合（パイプ結合）は、関手βにたいして β(c|d)=β(c);β(d) として計算できる。問題は、コボルディズム結合（グルーイング）c#dに対する法則。

c#dが計算できるのは、c:A→B, d:A→Bのときだから、β(c#d) : β(A)→β(B)でよい。β(A)は半環だから、半環の乗法・が存在する。f, g:K→Lが半環の射のとき、f・g(x) = f(x)・g(x)として射の乗法'・'を定義できる。この乗法を使って、β(c#d) = β(c)・β(d) : β(A)→β(B) が定義できる。

コンポネントの直和に関しては、c:A→B, d:C→Dとして、β(c+d) = β(c)×β(d) : β(A)×β(C)→β(C)×β(D)と考えていいだろう。

まとめると：

+ β(c|d) = β(c);β(d) -- 入出力結合（パイピング）
+ β(c#d) = β(c)・β(d) -- コボルディズム結合（グルーイング、順次）
+ β(c+d) = β(c)×β(d) -- 直和（同時並列）

このままでは（特にβ(c#d) = β(c)・β(d)が）整合性に欠けるが、なんとか細工して、行列圏に乗法'・'（アダマール積かもしれない）を定義したい。

アクションの集合は、ベクトルベンドルのアナロジーとして考えたほうがいいかもしれないな。観測可能な入出力に影響を与えるのは、空間の位相とその空間上に定義されている力学法則だが、力学法則はバンドルの（非決定性の）セクションとして与えられるはずだ。

*1165485058*[雑記][janus]“時間の空間”の圏

“時間の空間”つうのも変な言葉だが、時間のパラメータ領域となるべき多様体ということ。境界を許す有向コンパクト1次元多様体は、nI+ mCの形をしている。ここでIは有限区間でCは円周S&lt;sup&gt;1&lt;/sup&gt;のこと。nとmは自然数で成分の個数を表す。

境界を許す有向コンパクト1次元多様体の全体を射、有限点集合を対象とする対称モノイド圏を次のように定義する。

- dom(nI + mC) = n個の点（始点達）
- cod(nI + mC) = n個の点（終点達）
- 結合は、境界を接合した多様体。
- モノイド積は直和

この対称モノイド圏をTとする。nコボルディズムの圏をCとする。t∈Morph(T)に対して、f:t→M, M∈Morph(C)の形の連続写像を&lt;strong&gt;運動&lt;/strong&gt;と呼ぶことにする。ただし、境界は境界に移る写像だけを考える。運動fに対してδ&lt;sub&gt;0&lt;/sub&gt;(f) = (fの始点への制限), δ&lt;sub&gt;1&lt;/sub&gt;(f) = (fの終点への制限) とすると、δ&lt;sub&gt;0&lt;/sub&gt;, δ&lt;sub&gt;1&lt;/sub&gt;は運動に対して定義された境界オペレータになる。

δ&lt;sub&gt;1&lt;/sub&gt;(f) = δ&lt;sub&gt;0&lt;/sub&gt;(g)のとき運動の結合f;gが定義できる。運動の直和f + g : t + s → M + Nも定義できる。n個の点[n]に対して、[n]→Mは0次元運動だが、0次元運動を、停止という1次元運動に持ち上げることができる。

以上の状況を離散化して、プログラムの実行を運動として説明できないか？


</body>
</day>
<day date="2006-12-08" title="">
<body>
*1165553594*[雑記]ハードカバー本

[http://d.hatena.ne.jp/m-hiyama/20061204/1165192323:title]←だいぶ怒っている。

壊れた本とページが剥がれた本は：

ISBN:0521441781:detail
ISBN:0792357868:detail

</body>
</day>
<day date="2006-12-11" title="">
<body>
*1165805878*[山勘][プログラム意味論][トレース／コンパクト閉圏]CATOF xxx

[http://d.hatena.ne.jp/m-hiyama/20061211/1165797451:title]、という事情でヘロヘロ。それに、手首と肘を痛めているからキーボードが満足に打てないことが辛い！

それはそうと、最近の山勘はけっこういいセンかも知れない。次のことを考えよう。

- 事例としては、(0+1)-コボルディズム、(1+1)-コボルディズム。CW複体と多様体のケース。(0+1)-CWはグラフになる。
- 係数としては半環、または圏。典型的なのはブール半環、クリーネ代数（クリーネ・コゥゼン半環）、コンウェイ半環など。
- 二重圏ベースで考える。

二重圏は内部構造（internal structures）の例だが、これは使えそうだ。次のような記法を使うことにしよう。

- 構造の名前を小文字で書く。例えば、cat, mon-cat, semiring
- その構造の圏はキャメルケース Cat, MonCat Semiring
- 内部構造は in を使って表記する。cat in Cat, cat in MonCat
- 明示的に書きたいときは、CATOFを使う。Cat := CATOF(cat)
- 名前を定義するときは := を使う。DCat := CATOF(cat in Cat)

とりあえず面白そうなのは、cat in MonCat, mon-cat in Cat, mon-cat in MonCatの関係。cat in MonCat と mon-cat in Cat は対応するのか？ 直観的には、CATOF(cat in MonCat) と CATOF(mon-cat in Cat) は圏同値のようだ。MONCATOF(cat in MonCat) と MONCATOF(mon-cat in Cat) がMonCat同値かも（ウワーッ、頭山現象！）。

トレース付き対称モノイド圏を単にtr-catとすると、遷移翻訳系の圏は tr-cat in TrCat になっている気がするのだけど、確認は相当な労力がかかるな。しかし、もしホントなら、部分構造を大量生産できる。大量生産機構は大好きだな。



</body>
</day>
<day date="2006-12-15" title="">
<body>
*1166149798*[雑感][人物]ロシア風の名前

リュウバシェンコ（Volodymyr V. Lyubashenko ）、ベスパロフ（Yu.N. Bespalov）もすごいが、コバノフ（Mikhail Khovanov; http://www.math.columbia.edu/~khovanov/）も天才だなー。なんなんだこいつら。

ソ連は崩壊してしまったが、でもやっぱり、あそこらへんには天才・秀才がゴロゴロいるようだな。もっとも、名前がソ連でも、欧米の人もいるけど。

オーストラリ圏論グループのステフェン（スティーブ）・ラック（Stephen Lack; http://www.maths.usyd.edu.au/u/stevel/）も注目の人かな（あんまり若くない気もする）。

*1166150555*[高次圏論]k-tuply monoidal n-categories

バエズ（Baez）／ドーラン（Dolan）のhttp://arxiv.org/pdf/math/9802029 から：
&lt;img src=&quot;http://www.chimaira.org/img/nk-table-by-Baez-Dolan.gif&quot; &gt;

トム・レインスター（Tom Leinster）のhttp://arxiv.org/pdf/math/0106240 から：
&lt;img src=&quot;http://www.chimaira.org/img/nk-table-by-Leinster.gif&quot; &gt;

*1166163277*[雑記][高次圏論][気付いた]写像からグラフまで

昨日風呂に入っていて思いついた。

今まで、グラフの圏を(0+1)-コボルディズムで考えていたわけで、Gの始境界、終境界は0次元だとしてきた。が、この制限ははずせる。境界も一般のグラフだとしても別に問題ない。

一般的に、A, Bがなんらかの図形（多様体、複体、グラフなど）として、写像f:A→B、関係R:A→Bがあると写像柱M(f)、関係柱M(R)を図形として作ることができる。AとBが離散点集合のとき、M(f)、M(R)は二部グラフである。ブール値の行列と言っても同じ。

これは、ι&lt;sub&gt;0&lt;/sub&gt;:A→M, ι&lt;sub&gt;1&lt;/sub&gt;:B→M という埋め込み対だを考えれば、単射余スパンである。M上で経路和が作れるなら、Mに対してA×Bの行列を対応させることができる。

単射の条件をはずすと、一般の余スパンとなる。が、再び写像柱構成を使えば、単射の条件を回復できるから、「境界付き図形←→余スパン」の対応があると思ってよい。

このような方法だと、グラフの境界をグラフにすることができるので、「コボルディズムのあいだのコボルディズム」のような繰り返しがいくらでもできる。キュービカルな高次圏論と繋がる気がする。

*1166163494*[圏一般論]二項関手、偏関手、Cat偏豊饒化

はてな記法の関係(苦笑)で、丸括弧の代わりに適宜角括弧も使う。

F:C×C' → D が直積圏C×C'からDへの関手であることは、f:a→b, g:b→c in C； f':a'→b', g':b'→c' in C' だとして：

- F[(f f');(g, g')] = F[(f, f')];F[(g, g)]
- F[Id_(a, a')] = Id_(F[(a, a')]

書き換えると：

- F[(f;g, f';g')] = F[(f, f')];F[(g, g)]
- F[(Id_a, Id_a')] = Id_(F[(a, a')]

F[(f, f')]をf＊f'と二項演算で書くと：

- (f;g)＊(f';g') = (f＊f');(g＊g)
- Id_a＊Id_a' = Id_(a＊a')

となり、モノイド積の公理になる。

一方、Fが各変数ごとに関手であるとすると：

- F(f;f', g) = F(f, g);F(f', g)
- F(Id_a, g) = Id_F(a, g)

二項演算で書くと：

- (f;f')＊g = (f＊g);(f'＊g)
- (Id_a)＊g = Id_(a＊g)

あれれ、上は分配律だからいいとして、下の解釈はどうする？ 次元解析すると：

- Id_aはCの射、＊は射どうしの演算とすれば、(Id_a)＊g はDの射
- a＊gはId_a＊g と解釈すれば、自明な等式となる。

どうも、単位律は不要な気がする。変数ごとに関手になっている対応を&lt;strong&gt;偏関手&lt;/strong&gt;と呼ぼう。

一般に、対象類Xがあって、a, b∈Xに、Cの小さい圏hom(a, b)が対応していて、次の状況があるとする。
- a∈Xに、関手Id_a:1→hom(a, a) が割り当てられている。
- a, b, c∈Xに、二項偏関手 comp_(a, b, c):hom(a, b)×hom(b, c)→hom(a, c)が割り当てられている。

これは、通常のCat豊饒化とは違うが、加法圏などの構成法と似ている。&lt;strong&gt;Cat偏豊饒化&lt;/strong&gt;とでも呼んでおこう。(Id_a)＊g = Id_(a＊g)の意味を厳密に扱わないと一般化は難しそう。

</body>
</day>
<day date="2006-12-19" title="">
<body>
*1166513633*[オフトピック][リンク]お店

- http://r.gnavi.co.jp/a048700/ -- 京料理と焼酎 みな瀬


</body>
</day>
<day date="2006-12-20" title="">
<body>
*1166586786*[メモ法]定義を書け！

いかんいかん、このメモの主たる目的は、忘れがちな定義を書き留めて「&lt;em&gt;定義集&lt;/em&gt;」を作ることだった。が、なんか山勘とか雑感とかで、肝心の定義が書いてないケースが多い。そのときは、定義は自明の前提だったとしても&lt;br&gt;&lt;span style=&quot;font-size:x-large;&quot;&gt;しばらくすると忘れる！&lt;/span&gt;
忘れるから、書き留めておけよ、&lt;span style=&quot;font-size:x-large;&quot;&gt;&lt;strong&gt;定義&lt;/strong&gt;&lt;/span&gt;。

*1166599397*[圏一般論]Partially Additive Categories

部分加法的圏（partially additive categories）の定義は気に入らないのだけど、とりあえず、&quot;Types and Dynamics in Partially Additive Categories&quot; (1995) by Gianfranco Mascari, Marco Pedicini（http://citeseer.ist.psu.edu/mascari95types.html）から&lt;em&gt;引き写して&lt;/em&gt;おく。

&lt;hr&gt;
まず、&lt;strong&gt;partially additive monoid&lt;/strong&gt;の定義：

添字集合Iの族を(x&lt;sub&gt;i&lt;/sub&gt;:i∈I)という形で書くことにする。Iがたかだか可算のとき、可算族と呼ぶ。Mが集合だとして、M&lt;sup&gt;★&lt;/sup&gt;をMを値とする可算族の全体とする。今の用語法では、有限族も可算族に含まれる。また、M&lt;sup&gt;★&lt;/sup&gt;は普通の意味で集合にはならないが気にしないことにする。

部分写像Σ:M&lt;sup&gt;★&lt;/sup&gt;→Mが次の条件を満たすとき、&lt;strong&gt;summation&lt;/strong&gt;と呼ぶことにする（summationは檜山が追加した用語）。Σの定義域に属する属を&lt;strong&gt;summable&lt;/strong&gt;と呼ぶ。

&lt;h5&gt;1. 結合性（associative）&lt;/h5&gt;
(x&lt;sub&gt;i&lt;/sub&gt;:i∈I)が可算族で、(I&lt;sub&gt;j&lt;/sub&gt;:j∈J)がIの分割（partition）だとする。

(x&lt;sub&gt;i&lt;/sub&gt;:i∈I)がsummableである事と次の連言は同値。
+ 任意のj∈Jに対して、(x&lt;sub&gt;i&lt;/sub&gt;:i∈I&lt;sub&gt;j&lt;/sub&gt;)がsummable
+ (Σ(x&lt;sub&gt;i&lt;/sub&gt;:i∈I&lt;sub&gt;j&lt;/sub&gt;) : j∈J)がsummable

さらに、次の等式が成立する。

- Σ(x&lt;sub&gt;i&lt;/sub&gt;:i∈I) = Σ(Σ(x&lt;sub&gt;i&lt;/sub&gt;:i∈I&lt;sub&gt;j&lt;/sub&gt;) : j∈J)

&lt;h5&gt;2. 単元総和可能性（singleton smmability）&lt;/h5&gt;

I = {a}のとき、Σ(x&lt;sub&gt;i&lt;/sub&gt;:i∈I) = x&lt;sub&gt;a&lt;/sub&gt;

&lt;h5&gt;3. 連続性&lt;/h5&gt;

連続性は檜山の用語、もとはlimit sums。

次は同値。
+ (x&lt;sub&gt;i&lt;/sub&gt;:i∈I)がsummable
+ 任意の有限なF⊆I に対して(x&lt;sub&gt;i&lt;/sub&gt;:i∈F)がsummable

FとI＼Fという分割を使えば、有限なF⊆Iに対するsummableは出るから、同値ではなくて片方向含意でもよい。

&lt;hr&gt;
次は、&lt;strong&gt;partially preadditive category&lt;/strong&gt;の定義：

圏Cのhomsetがparitially additive monoidになっていて、圏の結合が総和Σに対して分配的なときに、その圏は&lt;strong&gt;partially preadditive&lt;/strong&gt;。詳しくは：

+ (f&lt;sub&gt;i&lt;/sub&gt;:i∈I)がa→bの射の可算族でsummableならば、任意のg:x→a, h:b→yに対して、Σ(g;f&lt;sub&gt;i&lt;/sub&gt;:i∈I) とΣ(f&lt;sub&gt;i&lt;/sub&gt;;h:i∈I) はsummabl。
+ g;(Σ(f&lt;sub&gt;i&lt;/sub&gt;:i∈I)) = Σ(g;f&lt;sub&gt;i&lt;/sub&gt;:i∈I) 
+ (Σ(f&lt;sub&gt;i&lt;/sub&gt;:i∈I));h = Σ(f&lt;sub&gt;i&lt;/sub&gt;;h:i∈I) 

&lt;hr&gt;
やっと、&lt;strong&gt;partially additive category&lt;/strong&gt;の定義、フーッ：

事前に零（zero）射と疑似射影の定義が要る。

- 特定された射の族 0&lt;sub&gt;a,b&lt;/sub&gt;:a→b が&lt;strong&gt;零射の族&lt;/strong&gt;だとは、f;0 = 0;g = 0 が成立すること。&lt;strong&gt;partially preadditive category&lt;/strong&gt;には零射の族がΣ(空)により定義できる。
- 零射の族を持ち、和（余積）を持つ圏において、J⊆Iのとき&lt;strong&gt;疑似射影&lt;/strong&gt;（quasi-projection）π&lt;sup&gt;I&lt;/sup&gt;&lt;sub&gt;J&lt;/sub&gt;は次のように定義される； π&lt;sup&gt;I&lt;/sup&gt;&lt;sub&gt;J&lt;/sub&gt; : (a&lt;sub&gt;i&lt;/sub&gt;:i∈I)の和→(a&lt;sub&gt;i&lt;/sub&gt;: i∈J)の和で、in&lt;sub&gt;i&lt;/sub&gt;;π&lt;sup&gt;I&lt;/sup&gt;&lt;sub&gt;J&lt;/sub&gt; = if i∈J then in&lt;sub&gt;i&lt;/sub&gt; else 0。

まず、圏Cは可算余積を持つ。そして、partially preadditive。さらに次の2つの条件を満たすときに&lt;strong&gt;partially additive&lt;/strong&gt;。

+ 互換和（Compatible Sum）公理：f&lt;sub&gt;i&lt;/sub&gt;∈Hom(a, b)であり、f:a→(bのi∈I分のコピーの和）で f;π&lt;sub&gt;i&lt;/sub&gt; = f&lt;sub&gt;i&lt;/sub&gt;となるfがあるなら、族(f&lt;sub&gt;i&lt;/sub&gt;:i∈I)はsummable。
+ アンタイ（Untying）公理：f, g:a→bで{f, b}がsummableのとき、{f;in&lt;sub&gt;1&lt;/sub&gt;, g;in&lt;sub&gt;2&lt;/sub&gt;}:a→b+b はsummableである。


</body>
</day>
<day date="2006-12-21" title="">
<body>
*1166660663*[雑記]summability

ゴランの本にも無限加法があったから、調べよう。

調べた→[http://d.hatena.ne.jp/m-hiyama-memo/20061221/1166668881:title]

*1166668881*[圏一般論][その他代数][用語法]Complete Semirings

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061220/1166599397&quot;&gt;部分加法的圏&lt;/a&gt;との比較で、完備半環（complete semirings）の定義を書き記す。これは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061208/1165553594&quot;&gt;ゴランの本（壊れた！）&lt;/a&gt;の22章&quot;Complete Semirings&quot;からの引用。

Rは半環で、Aはθ:Ω→Rという形の写像の集合。θ∈Aのとき、θは&lt;strong&gt;許容的（admissible）&lt;/strong&gt;と呼ぶ。A上で&lt;strong&gt;summation&lt;/strong&gt;Σが定義されるので、「許容的⇔summable」だと思ってよい。Σ:A→Rがsummationであるとは：

+ Ωが空なら、Σθ = 0
+ Ωが有限集合なら、Σθ = 普通の和
+ θが許容的なことは、次と同値； 任意のr∈Rに対してrθとθr（左右のスカラー倍）が許容的。さらに、分配律 Σ(rθ) = r(Σθ)、Σ(θr) = (Σθ)r が成立。
+ (Ω&lt;sub&gt;j&lt;/sub&gt; : j∈Λ)がΩの分割だとする。θが許容的なことは、次と同値； θのΩ&lt;sub&gt;j&lt;/sub&gt;への制限をθ&lt;sub&gt;j&lt;/sub&gt;とすると、すべてのθ&lt;sub&gt;j&lt;/sub&gt;が許容的であり、ψ(j) = Σθ&lt;sub&gt;j&lt;/sub&gt; で定義されるψ:Λ→Rも許容的。さらに、一般化された結合律 Σθ = Σψ が成立。

(1),(2)が通常の有限和との整合性を主張する。分配律は乗法が絡むから後にして、(4)が結合律。連続性に相当するものが直接はないのだけど、結合律から出るのか？ とにかく、partially additive monoidとの関係を調べるべき。それと、明示的な可換性はないのだけど、I→Jが双射のとき、総和が不変であることは示すべきだろう。

有限加法が定義されていない状況で総和Σを定義してもしょうがないので、有限加法を前提にする議論でいいと思う。つまり、モノイド上のadditionalな構造としてsummationを考えればそれでいい。

さて、許容的な写像（添字族）の類（集合にはならない）Aと、A上のsummationが与えられた状況で、(R, A, Σ)を&lt;strong&gt;A完備な半環&lt;/strong&gt;と呼ぶ。Aが「Ωが（たかだか）可算な集合」として与えられているとき、A完備性を&lt;strong&gt;可算完備性（countably complete）&lt;/strong&gt;と呼ぶ。またAが任意の添字族を含むとき、単に&lt;strong&gt;完備&lt;/strong&gt;、または&lt;strong&gt;全完備&lt;/strong&gt;(fully complete; これは檜山の用語）と呼ぶ。

用語「完備」は、「完備束」との用語的相性がいい。可算完備はω完備でもいいかな。partially additive monoidはヤダ、完備モノイド、可算完備モノイドのほうがいい。A完備モノイドもいいと思う。完備モノイドの圏は、summationを保存する写像を射とすれば定義できるだろう。この圏の直積やベキ（指数）がどうなるかな？


</body>
</day>
<day date="2006-12-22" title="">
<body>
*1166760416*[メモ法]URLだけのリンクは危険

URLだけだと、リンク先が失われると見られない。別なロケーションを探すキーも乏しい。ので、題名とかもちゃんとテキストで書いておく。


</body>
</day>
<day date="2006-12-23" title="">
<body>
*1166863091*[雑記][論理]モデル論的科学論なんて可能なんかい？

本編に書いた「[http://d.hatena.ne.jp/m-hiyama/20061222/1166758169:title]」だけど、あの内容はそれなりの意味があると思ってはいるが、よく考えてみると穴だらけ、というかフィクションのかたまりだな。批判的に検討（ヒトリ・ツッコミ）してみよう。

僕が背景にしているのはモデル論だ。モデル論が対象とする“理論”（形式理論、セオリー）は、形式言語上で定義される。だが、通常科学を形式言語で記述するのは無理だろう。絶対（原理的に）出来ないと言い切れないけど、現実的に出来ない。ましてや、江本理論の形式化ができる気はしない。だから、形式言語上のセオリー（形式理論）の議論を適用することが（適用可能性が）疑わしい。

それで僕は、仮にモデル論的議論が適用できたとして、というフィクションから出発している。このフィクションが荒唐無稽とは思ってないが（思っていたらやらない）、フィクションを正当化するメタな議論（論法）を持っているわけではない。

（これから先、フィクションを認める。）Nが通常科学のセオリー、Eが江本水伝のセオリーだとして、NとEを比べるには、同一の言語L上にセオリーを定義しなくてはならない。NがL上、EがL'上でも、適切な翻訳L'→L（またはL→L'）があれば比較できるが、結局は同じ言語上に載せる必要がある。さて、そもそもNとEを同じ言語L上に載せることができるのか？ よく分からない。

それでさらに、NとEが同じL上のセオリーというフィクションを導入。まずもって、N、Eをそれぞれ単独で考えたとき矛盾してないだろうか？ Nが矛盾しているとえらいことなので、矛盾してないと信じたい。信じる根拠は、今の科学がだいたいうまくいっているようだから。それ以上の根拠は見つからない（その割に信頼はしている）。Eが矛盾している可能性はたいへん高い。が、Eがそれ自身で矛盾していると、Nとの比較がナンセンス。よって、Eは矛盾してない、という&lt;em&gt;かなり苦しい&lt;/em&gt;フィクションを導入。

これだけ山盛りのフィクションのもとで、やっと形式的議論ができる。
&lt;hr&gt;

pが言語Lの文であることを、単にp∈Lと書いてしまう（記号の濫用）。Lには適切な演繹系がついているとして、N |- p, E |- p は普通の意味で使う。モデルとしては、唯1つのモデルRW（real world）を考え、RW |= p  は、文pが実験・観測的に正しいと確認できることを意味する。

A⊆L だとして、すべてのp∈Aが RW |= p のときValid(A)と書く。セオリー（の生成系）Aが正しい、という意味。Aが構文論的に矛盾してないときConsis(A)と書く。これは、A |- p, A |- ￢p となるpがないこと。

現実（モデルRW)が信頼できることの表現として、Valid(A)⇒Consis(A)を仮定する。もし、￢Consis(A)∧Valid(A)であるAがあるなら、現実RWは p∧￢p を許すことになる。矛盾したセオリーにモデルがあり、そのモデルが他ならぬ現実であるのは許し難い。よって、メタ命題 Valid(A)⇒Consis(A) は原理（現実の整合性）としていいだろう。

AとBが両立不可能とは、￢Consis(A∪B) のこと。特に、Consis(A)かつConsis(B)であるのに、￢Consis(A∪B) である状況が問題になる。現実が整合的であることから、￢Consis(A∪B)⇒￢Valid(A∪B)。つまり、合併したセオリーA∪Bは現実と比較して正しくない。A∪Bがvalidでないとしても、A、Bのvalidityの組み合わせが4つあるが、「Valid(A)かつValid(B)」が除外される。なぜなら、p∈Aならば RW |= p、p∈Bならば RW |= p が成立している。これはすぐに Valid(A∪B) を導くから、￢Valid(A∪B)とはならない。残る可能性は3つ：

+ Valid(A)かつ￢Valid(B)
+ ￢Valid(A)かつValid(B)
+ ￢Valid(A)かつ￢Valid(B)

つまり、「AとBが両立不可能」≡￢Consis(A∪B) から出発すると、「AもBも正しい」≡Valid(A)∧Valid(B) は&lt;em&gt;起こりえない&lt;/em&gt;。もし、（なんらかの理由で）￢Valid(A)∧￢Valid(B) も除外できるなら、&lt;em&gt;AとBのどちらか一方だけが正しい&lt;/em&gt;ことになる。

それで僕は、「NとEが両立不可能」≡￢Consis(N∪E) を示そうとした。p∧￢pとなる命題pは、「言葉のメッセージは、水の実験結果に影響を与えない」を使った。しかし、両立不可能性が純構文的に（証明論的に）出したかというと、そうじゃない。モデルRWとの照合（実験・観測）を使っているので、構文的じゃない。ただし、RW |= p であるようなpを最初から公理に入れておいたのだ、と言い訳できなくもない。

通常科学では、Consis(A)とValid(A)はあまり区別できないのじゃないか、という気もする。その他、問題点：

+ 言語やセオリーが更新されるときのダイナミズム
+ モデルが1つとは限らないとき
+ その他、僕がここで使っている仮定が使えない状況


</body>
</day>
<day date="2006-12-28" title="">
<body>
*1167286024*[圏一般論]デカルト圏の等式的定義

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061228/1167268932&quot;&gt;そういう事情&lt;/a&gt;で、今度は定義を書き写す。もう、二度手間じゃねーか、バカヤロ＞自分

- 参考：[http://d.hatena.ne.jp/m-hiyama-memo/20061006/1160126861:title]
- 参考：[http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528:title]

まずは、ランベック／スコット（J.Lambek, P.J.Scott）本P.52 &quot;Cartesian closed categories equationally presented&quot;から引用。さすがに、ランベックだけあって、次のように言っている（強調は檜山）：
&gt;&gt;
A category is &lt;strong&gt;a deductive system&lt;/strong&gt; in which the following equations hold between proofs:
&lt;&lt;

次の記法はオリジナル（ランベック／スコット）と違う。

- 終対象を1と書く。（オリジナルはT）
- Aから終対象への射を!&lt;sub&gt;A&lt;/sub&gt;と書く。（オリジナルは○&lt;sub&gt;A&lt;/sub&gt;）
- 結合はdiagrammatic order

で、デカルト圏の等式的な定義：

+ f = !&lt;sub&gt;A&lt;/sub&gt; , for all f:A→1
+ &amp;lt;f, g&gt;;π&lt;sub&gt;A,B&lt;/sub&gt; = f , for all f:C→A, g:C→B
+ &amp;lt;f, g&gt;;π'&lt;sub&gt;A,B&lt;/sub&gt; = g , for all f:C→A, g:C→B
+ &amp;lt;h;π&lt;sub&gt;A,B&lt;/sub&gt;, h;π&lt;sub&gt;A,B&lt;/sub&gt;&gt; = h , for all h:C→A×B

最初の主張を言い換えると：

- id&lt;sub&gt;1&lt;/sub&gt; = !&lt;sub&gt;1&lt;/sub&gt;, 
- f;!&lt;sub&gt;B&lt;/sub&gt; = !&lt;sub&gt;A&lt;/sub&gt; , for all f:A→B

これらから導かれるもの：

- 分配律 h;&amp;lt;f, g&gt; = &amp;lt;h;f h;g&gt;
- id&lt;sub&gt;A&lt;/sub&gt;×id&lt;sub&gt;C&lt;/sub&gt; = id&lt;sub&gt;A×C&lt;/sub&gt;

ここで、f×g の定義は：

- f×g := &amp;lt;π&lt;sub&gt;A,C&lt;/sub&gt;;f, π'&lt;sub&gt;A,C&lt;/sub&gt;;g&gt;

これらから、交替律が出る。

さて一方、&quot;The Maximality of Cartesian Categories&quot; by Kosta Dosen, Zoran Petric （http://arxiv.org/abs/math/9911059）では、次の公理化を採用している。

+ &amp;lt;f, g&gt;;π&lt;sub&gt;A,B&lt;/sub&gt; = f for all f:C→A, g:C→B
+ &amp;lt;f, g&gt;;π'&lt;sub&gt;A,B&lt;/sub&gt; = g for all f:C→A, g:C→B
+ h;&amp;lt;f, g&gt; = &amp;lt;h;f h;g&gt; （分配律）
+ &amp;lt;π&lt;sub&gt;A,B&lt;/sub&gt;, π'&lt;sub&gt;A,B&lt;/sub&gt;&gt; = id&lt;sub&gt;A×B&lt;/sub&gt;
+ f = !&lt;sub&gt;A&lt;/sub&gt; , for all f:A→1

同じ論文で、直積の結合性、対称性、単位性などを示すために、いろいろな自然変換を定義している。これも書き写す。オリジナルと記号法は違う（が、標準的かどうか自信はない）。

+ α&lt;sub&gt;A,B,C&lt;/sub&gt; := &amp;lt;&amp;lt;π&lt;sub&gt;A,B×C&lt;/sub&gt;, π'&lt;sub&gt;A,B×C&lt;/sub&gt;;π&lt;sub&gt;B,C&lt;/sub&gt;&gt;, π'&lt;sub&gt;A,B×C&lt;/sub&gt;;π'&lt;sub&gt;B,C&lt;/sub&gt;&gt; : A×(B×C) → (A×B)×C
+ α'&lt;sub&gt;A,B,C&lt;/sub&gt; := &amp;lt;π&lt;sub&gt;A×B,C&lt;/sub&gt;;π'&lt;sub&gt;A,B&lt;/sub&gt;, &amp;lt;π&lt;sub&gt;A×B,C&lt;/sub&gt;;π'&lt;sub&gt;A,B&lt;/sub&gt;, π'&lt;sub&gt;A×B, C&lt;/sub&gt;&gt;&gt; : (A×B)×C → A×(B×C)
+ σ&lt;sub&gt;A,B&lt;/sub&gt; := &amp;lt;π'&lt;sub&gt;A,B&lt;/sub&gt;, π&lt;sub&gt;A,B&lt;/sub&gt;&gt; : A×B → B×A
+ Δ&lt;sub&gt;A&lt;/sub&gt; := &amp;lt;id&lt;sub&gt;A&lt;/sub&gt;, id&lt;sub&gt;A&lt;/sub&gt;&gt; : A → A×A
+ λ&lt;sub&gt;A&lt;/sub&gt; := &amp;lt;!&lt;sub&gt;A&lt;/sub&gt;, id&lt;sub&gt;A&lt;/sub&gt;&gt; : A → 1×A
+ ρ&lt;sub&gt;A&lt;/sub&gt; := &amp;lt;id&lt;sub&gt;A&lt;/sub&gt;, !&lt;sub&gt;A&lt;/sub&gt;&gt; : A → A×1

これらを用いて、(A×B, π&lt;sub&gt;A,B&lt;/sub&gt;, π'&lt;sub&gt;A,B&lt;/sub&gt;) が直積対象、射影システムであること（普遍性）を示す。その他の自然変換（射の族）も使って、×がモノイド積であることを示す。


</body>
</day>
<day date="2006-12-29" title="">
<body>
*1167357163*[メモ法]定義と些細なこと

ウーム、自己批判（＝反省）せねば。

とにかく、&lt;strong&gt;後で読んで分からないとメモの意味がない！&lt;/strong&gt;

原典への参照も当然に必要ではあるが、イチイチ原典に戻らなくても済むようにメモを書いているのだから、最低限、用語の定義は書き写さないと。できれば、目的やめぼしい結果も（理解できないときはしょうがないが）。それと、些細なことでも引っかかりそうな（はまる）ポイントも書いておいてね＞自分

*1167361235*[圏一般論]デカルト圏の等式的定義 細かいこと色々

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061229/1167357163&quot;&gt;そういう事情&lt;/a&gt;で、デカルト圏の定義に関する細かいことまでメモするぞ、っと。

圏論の極限の立場では、「デカルト性＝離散有限完備＝離散有限図式の極限が常に存在」となる。一方で、コラディニ／ガダッチ／セリンガー（Corradini/Gaddacci/Selinger）は対角（余積、余乗法、余和）Δによる余モノイドを基本にしている。それらの中間にランベック／スコット（Lambek/Scott）のペアリング&amp;lt;-, -&gt;を使う流儀がある。

注意すべきは、離散有限完備では、極限（i.e. 有限直積）はup-to-isoでしか決まらない。それに対して等式的な（対角でもペアリングでも）定義では、特定された（distinguished, selected）終対象1と、特定された二項演算／余二項演算（ペアリング／対角）が確定的に与えられている点だ。

よって、等式的なデカルト圏と直接的に対応するのは、特定された極限を持つ離散有限完備圏である。つまり、Cの離散図式Dに対して、Lim(D)∈Cone(C, D)が一意的に定まる。Cone(C, D)は、圏C内の底面がDである錐の圏。数学的帰納法を使えば、Lim(2)（2 = {1, 2}）の存在から、Lim(n)（n≧2）の存在を言えるから、二項直積が本質ではある。つまり、次が同値：

+ 任意の離散有限図式Dに対してLim(D)が確定する。
+ Lim(0)とLim(2)が確定する。（0は空集合）
+ 終対象を特定でき、二項直積も特定できる。

さらに、「二項直積も特定できる」を言い換えると：

- 対象に対する二項直積対象と、対応する射影対（π、π'）を特定できる。

結局、対象の対A, Bで添字付けられた直積システム (P&lt;sub&gt;A,B&lt;/sub&gt;, π&lt;sub&gt;A,B&lt;/sub&gt;, π'&lt;sub&gt;A,B&lt;/sub&gt;)が特定できればいい。このスパンが、直積としての普遍性を持つために、ペアリング&amp;lt;-, -&gt;&lt;sub&gt;X,A,B&lt;/sub&gt; : Hom(X, A)×Hom(X, B) → Hom(X, A×B) も備える必要がある。これがランベック／スコット流の定義。

ランベック／スコット流の等式的定義は、「Lim(0)とLim(2)が確定している圏」の直接的なパラフレーズだから、相当に（心理的な）自然感がある。一方、コラディニ／ガダッチ／セリンガー流の、余モノイドから入るスタイルは、デカルト性が明白でなくて分かりにくい（僕は分からなかった）。しかし、コピー可能f;Δ = Δ;(f×f)、破棄可能 f;! = ! などの概念は使い勝手がよい。セリンガーが注意してるように、多値写像（関係）の圏では、コピー可能は単葉（univalent）であり、破棄可能は全域（total、exact）である。多値写像の圏の焦点圏は、集合と普通の写像の圏である。

*1167379022*[圏一般論][説明]デカルト圏の極限的定義 説明方法

とりあえず骨格：

+ 終対象の定義
+ 終対象が一意的でない、up-to-isoで決まることを説明
+ 圏Cの図式d:D→Cの定義
+ dを底辺とする錐の圏Cone(D, C)、頂点と側面射、側面三角形（可換）など
+ Cone(D, C)の終対象が極限、極限は一意的ではない。
+ Gをグラフの類としての、G完備性 :≡ Gの属するグラフの図式には極限が存在
+ 図式ごとに極限を特定する操作 Lim
+ G-complete category with distinguished limits
+ 離散有限完備
+ 0-完備と2-完備
+ 特定された二項直積と射のペアリング
+ Hom(X, A)×Hom(X, B) ≒ Hom(X, A×B)

これで、ランベック／スコット流の等式的定義の準備ができる。


</body>
</day>
<day date="2007-01-04" title="">
<body>
*1167881650*[高次圏論]次元が3の圏

遷移翻訳系（トランスデューサ）の圏を考えているのだが、これが二重圏（double category）の構造を持つのはかなりハッキリとしてきた。が、さらにもう1次元高い構造を持っている。

&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;オイ、1次元高い構造についてメモしておけよ！&lt;/em&gt; &lt;b&gt;[/追記]&lt;/b&gt;

次元が3である圏は、tricategoryというのがあるが、あまり調べてない。二重圏の圏をDCatとすると、DCat内の内部圏、あるいはDCatによる豊饒化が考えられる。他に、一般的n圏としての強3圏、弱3圏もある。いったいどれだろう？（3-forld categoryとかもあったな、たしか。）

現象論的事実としては：

- 結合は3種類ある。直列（順次）結合、入出力結合、書き換え対応（リファクタリング）
- モノイド積が2つある。並列結合、インターフェースの直和
- categorical general field theory (&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070104/1167881986&quot;&gt;CGFT&lt;/a&gt;)で定式化できるかも知れない。

*1167881986*[TQFT]CGFTs (Categorical General Field Theories)

モスカリウク＆ヴラソフの &quot;Double Categories in Mathematical Physics&quot; by S.S. Moskaliuk, A.T. Vlassov （http://citeseer.ist.psu.edu/371467.html）5.1節に場の理論（Field Theory）の圏論的構成（試論）が載っている。これは二重圏をベースとしている。多少の変形と整理をして以下にまとめる。

- 対象（対象圏の対象）は、(π:V→X, s∈Γ(V/X))。ここでXはd次元多様体、πはファイバー束、sは（ある条件を満たす）ファイバー束の（大域）切断（つまり、場）。
- 水平射（射圏の対象）は、(π:E→Y, D, s∈Γ(E/Y))。Yは(d+1)次元多様体。Dはセクションを制限する方程式系。sはDの解となっている切断。
- 境界関手δ&lt;sub&gt;i&lt;/sub&gt;（i = 0, 1）は、Yの境界δ&lt;sub&gt;i&lt;/sub&gt;Y = X&lt;sub&gt;i&lt;/sub&gt; を対応させる。ファイバー束と切断も境界に制限する。
- セル（射圏の射）は、多様体の射とファイバー束の引き戻し／ファイバー束の射を組み合わせた射。方程式系Dと切断sも適当な引き戻しで定義する。
- 作用積分Sが存在する。
- DはSのオイラー・ラグランジュ方程式となる。
- 多様体の境界貼り合わせにより水平結合が定義できる。
- 作用積分に関して、指数法則 S[ξ * ξ'] = S[ξ]  + S[ξ'] が成立する。

</body>
</day>
<day date="2007-01-10" title="">
<body>
*1168408202*[雑記]カーラー＆リュウバシェンコの本
&gt;&gt;
誠に申し訳ございませんが、大変残念なご報告があります。お客様のご注文内容のうち、&lt;br&gt;以下の商品については入手できないことが判明いたしました。
&lt;&lt;

なんだよもー。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061021/1161414971&quot;&gt;カーラー＆リュウバシェンコの本&lt;/a&gt;は入手できない。

それで、Kinokuniya BookWeb（http://bookweb.kinokuniya.co.jp/）で注文してみた。はたしてどうなるか？

Kinokuniya BookWebのIDは &lt;strong&gt;&lt;span style=&quot;font-size:large;&quot;&gt;mhiyama&lt;/span&gt;&lt;/strong&gt; だ。

*1168422137*[圏一般論][プログラム意味論]分断圏（segmented category）

どんな射fでもdom(f) = cod(f)である圏を&lt;strong&gt;分断圏&lt;/strong&gt;（segmented category）と呼ぼう。（分断された圏、被分断圏が正確な日本語だと思うが。）

対称群を集めた圏Symmとかアミダ図の圏Amidaとかがその例。これらの例にはモノイド積もある。通常は、対称モノイド分断圏（symmetric monoidal segmented category）として登場する。Cがモノイド分断圏なら、|C|上にモノイド積を制限するとモノイドになる。特に |C| = &lt;b&gt;N&lt;/b&gt; のときが典型的。

システムのインターフェース（ポートセット、アダプタ、ファセット）はたぶん、対称モノイド分断圏になる。

</body>
</day>
<day date="2007-01-11" title="">
<body>
*1168494004*[圏一般論][用語法]余りにも変な用語は変えよう：「生成」

圏Cの「生成系」とは、G⊆|C|であって、

+ Gは（小さい）集合である。
+ f, g:a→b で、f≠g ならば、x∈Gとk:x→aが存在して k;f ≠ k;g

この状況で、「GはCを生成する」とか「GはCの生成系」とか言うのは&lt;em&gt;言語道断&lt;/em&gt;。

「GはCを&lt;strong&gt;識別&lt;/strong&gt;（distinguish）する」とか「GはCの&lt;strong&gt;識別系&lt;/strong&gt;」と言うべきだろう。

また、A⊆|C|のとき、Aから決まる充満部分圏を「Aから生成される部分圏」というが、これも&lt;em&gt;よくない&lt;/em&gt;。グラフ理論の誘導部分グラフにならって「Aから&lt;strong&gt;誘導&lt;/strong&gt;（induce）される部分圏」と言うべきだろう。

*1168494231*[メモ法]ISBN記法には注意

はてなのISBN記法は便利だが、ISBN&amp;#58;***:title とか書くと、タイトルに関するテキスト情報がなくなる。検索にかからなくて不便！ 

- 『タイトルをテキストで書く』（ISBN&amp;#58;***）
のように書くのが良い。

</body>
</day>
<day date="2007-01-13" title="">
<body>
*1168670955*[janus][高次圏論]壁の圏の構造

全然説明してないが、システムの&lt;strong&gt;部屋モデル&lt;/strong&gt;を考えている。部屋というのが高次圏のセル（高次射）であって、境界セルとして部屋の壁がある。圏の次元は少なくとも3、もっと高いかもしれない。結合以外にモノイド積が入っているから演算の数はやたらに多い。

部屋の壁の向かい合う二面がIOインターフェースとなるのだが、この壁自体が圏になっている。だいたいの定式化を書いておく。

&lt;h5&gt;壁のモノイド圏&lt;/h5&gt;

対象類は自然数の全体&lt;b&gt;N&lt;/b&gt;であり、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070110/1168422137&quot;&gt;対称モイイド分断圏&lt;/a&gt;である。モノイド積の対象への制限は足し算となる。n∈&lt;b&gt;N&lt;/b&gt;に対する射（分断圏なので射は、n→nの形に限られる）は次のようなもの； Σ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)は、アルファベット（記号の集合）のn-列。記号は遷移系のアトミック・アクション（コマンド）と解釈する。AはΣ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;× ... ×Σ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;の部分集合である（つまり、Aは、列のn-タプルの集合）。これらの組(Σ, A)が射である。

(Σ, A)と(Γ, B)が、n→nの射のとき、結合(Σ, A);(Γ, B)は次のように定義する； Σ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)とΓ=(Γ&lt;sub&gt;1&lt;/sub&gt;, ..., Γ&lt;sub&gt;n&lt;/sub&gt;)に対して、Σ∪Γ = (Σ&lt;sub&gt;1&lt;/sub&gt;∪Γ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;∪Γ&lt;sub&gt;n&lt;/sub&gt;)とする。これも長さnの列となる。A⊆Σ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;× ... ×Σ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;は、A⊆(Σ&lt;sub&gt;1&lt;/sub&gt;∪Γ&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;× ... ×(Σ&lt;sub&gt;n&lt;/sub&gt;∪Γ&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;と考えてよい。同様に、B⊆(Σ&lt;sub&gt;1&lt;/sub&gt;∪Γ&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;× ... ×(Σ&lt;sub&gt;n&lt;/sub&gt;∪Γ&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;。この状況で、言語Aと言語Bの連接A;Bを作れる。(Σ, A);(Γ, B) := (Σ∪Γ, A;B) と定義する。

nに対するid&lt;sub&gt;n&lt;/sub&gt;は、&lt;b&gt;0&lt;/b&gt;&lt;sub&gt;n&lt;/sub&gt; = (&lt;b&gt;0&lt;/b&gt;, ..., &lt;b&gt;0&lt;/b&gt;)として、&lt;b&gt;0&lt;/b&gt;&lt;sup&gt;*&lt;/sup&gt;× ... ×&lt;b&gt;0&lt;/b&gt;&lt;sup&gt;*&lt;/sup&gt; = &lt;b&gt;E&lt;/b&gt;&lt;sub&gt;n&lt;/sub&gt; = 単元集合 として、(&lt;b&gt;0&lt;/b&gt;&lt;sub&gt;n&lt;/sub&gt;, &lt;b&gt;E&lt;/b&gt;&lt;sub&gt;n&lt;/sub&gt;)で与えられる。

モノイド積×は、(Σ, A)×(Γ, B) := (Σ・Γ, A×B)とする。・は列の連接、A×Bは言語集合の直積である。この定義から、対象&lt;b&gt;N&lt;/b&gt;の加法がモノイド積になることは明らか。

α=(Σ, A)、β=（Γ, B）などが壁の圏の射だとして、システムは部屋の壁をつなぐので、α→βのようなプロファイルを持つ。このとき、n→mのような射も必要になる(?)気もするが、ここがよくわからない。α×βにはシステム状態空間の直積が対応する。ここで、トレースに関する、f;g = Tr[(f×g);σ] は重要な指針を与える。

&lt;h5&gt;壁の二重圏&lt;/h5&gt;

壁の圏の射α、βに対して、セルf:α→βを考える。α=(Σ, A)、β=（Γ, B）だとして、fは、リボン（ストリングの束）集合AからPow(B)への写像である。PowモナドのKleisli圏を考えれば、fは射と考えてよい。リボン言語を対象として、その変換を射とする圏となる。

二重圏とするには、対象圏を壁の圏W（対象は自然数n, m、射はインターフェースα, β）として、射圏Mは次のようにする：

- Mの対象は、[n, m]のような自然数の順序対。
- Mの射[n, m]→[n, m]は、α:n→nからβ:m→mへのセルf::α→β
- Mの結合は、f::(α:n→n)→(β:m→m)とg::(γ:n→n)→(δ:m→m)に対して、f;g :: (α;γ:n→n)→(β;δ:m→m)。f;gはシステムのコボルディズム・グルーイングの観測的振る舞い（詳細な定義が必要）。
- Mは分断圏となる。Wも分断圏だから、分断圏の圏の内部圏となる。

境界関手：

- D&lt;sub&gt;0&lt;/sub&gt;([n, m]) = n
- D&lt;sub&gt;0&lt;/sub&gt;(f:α→β) = α
- D&lt;sub&gt;1&lt;/sub&gt;([n, m]) = m
- D&lt;sub&gt;1&lt;/sub&gt;(f:α→β) = β

スター結合（横結合、水平結合、内部圏としての結合関手）：

- セルf::(α:n→n)→(β:m→m)とセルg::β→γのスター結合は、システムのIO結合になる。f*g::(α:n→n)→(γ:k→k)


</body>
</day>
<day date="2007-01-16" title="">
<body>
*1168910807*[プログラム意味論][高次圏論][雑感]なんか、わかったかも

&lt;strong&gt;&lt;span style=&quot;font-size:large;&quot;&gt;あー、そうか、そうか。そういうことか。&lt;/span&gt;&lt;/strong&gt;

とか、感想だけを書いておくと忘れてしまうのだが、後で説明も補足することとして（大丈夫かぁ？）、とりあえずの感触と気分を。

二重圏を使うようになってだいぶ事情が見えてきた。とりあえず、遷移翻訳系（トランスデューサー）の圏を問題にしているのだが：

- 次元は3である。
- モノイド積は2つある。
- トレースも2つある。
- 次元、モノイド積、トレースは&lt;em&gt;もっと多い&lt;/em&gt;かも知れない。
- ひとつの方向は&lt;strong&gt;t-方向&lt;/strong&gt;（transition）と呼び、遷移、時間の方向で、始状態（エントリーポイント）から終状態（エグジットポイント）に向かう。
- ひとつの方向は&lt;strong&gt;c-方向&lt;/strong&gt;（communication）と呼び、メッセージング、IO、呼び出し、イベント、対話、信号などのコミュニケーションの方向である。
- ひとつの方向は&lt;strong&gt;r-方向&lt;/strong&gt;（rewriting）と呼び、書き換え、リファクタリング、シミュレーションなどの方向である。
- t-方向に対するモノイド積は状態空間の直和。
- c-方向に対するモノイド積は状態空間の直積。
- t-方向に対するトレースはルーピング。
- c-方向に対するトレースは（自己内部コミュニケーション＋）ハイディング。

この多次元圏をベースにして、

- コゥゼン（Kozen）圏（等式的コゥゼン圏、ホーン条件的コゥゼン圏）を作る→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%b3%a5%a5%a5%bc%a5%f3%b7%f7、http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Kozen%b7%f7
- 正規表現と列言語理論を再構成
- Int構成でコンパクト閉圏を作る
- モナドを探す
- TQFT構成を探す
- semiringal圏を構成する→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=semiringal
- Circ-Kleisli構成を探す→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Circ%2dKleisli
- インスティチューションを探す→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%a4%a5%f3%a5%b9%a5%c6%a5%a3%a5%c1%a5%e5%a1%bc%a5%b7%a5%e7%a5%f3
- ブール・クリーネ圏を探す→http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%d6%a1%bc%a5%eb%a1%a6%a5%af%a5%ea%a1%bc%a5%cd

とりあえずはコゥゼン圏をうまいこと抽出したい。これは出来そうな気がする。それと、適当な半環係数の古典テンソル計算（添字計算）の圏もトレースを2つ持つから、参考になりそうだ。線形でトレースを2つ持つ圏の典型例が古典テンソル計算圏のような気がする。

*1168911231*[圏一般論]圏の退化、脱圏論化

高次圏の次元が見えなくなったり、圏の構造の多様性が見えなくなったりすることがよくある。これは&lt;em&gt;退化現象&lt;/em&gt;とでも呼ぶべきものだが、どんなものがあるだろう。

- 厳密化： 同型を同一にする（定義を強くする）と、退化が起きる。
- 骨格化： 骨格部分圏を取ると退化が起きる。
- 合同： 圏論的合同により商を作ると退化が起きる。
- 単元縮退： 対象類を単元集合にする（定義を強くする）と退化が起きる。
- 恒等縮退： 射を恒等射に制限すると退化が起きる。二重圏から2-圏が例。
- 離散縮退： 圏を離散圏（事実上集合）に制限すると退化が起きる。
- 折り畳み： 多次元圏の2つの次元を重ねてしまうと退化が起きる。二重圏の垂直1射と水平1射から1-圏を生成するとか。

折り畳みがよくわかってない。

他に、適当な対象UのEnd(U)とかAut(U)を取ると、広義の脱圏論化（decategorification）になるときもありそうだ。


</body>
</day>
<day date="2007-01-17" title="">
<body>
*1168993359*[圏一般論]トラス（truss）圏構成

Cが小さい圏のとき、その&lt;strong&gt;トラス圏&lt;/strong&gt;Truss(C)を次のように定義できる。D = Truss(C)とする。trussは藁束＜わらたば＞の意味で解釈。

- Dの対象は、|C|の部分集合である。|D| = Pow(|C|)
- A, B⊆|C|として、Cの射の集合M⊆Cが、「f∈M⇒dom(f)∈A, cod(f)∈B」のとき、Mは(A, B)-トラスである、という。
- D(A, B)はすべての(A, B)-トラスの集合。
- A⊆|C|に対して、id&lt;sub&gt;A&lt;/sub&gt;は、{id&lt;sub&gt;a&lt;/sub&gt; | a∈A}
- M∈D(A, B), N∈D(B, C)に対して、{f;g | f∈M, g∈N}をM;Nとして結合を定義する。

以上の定義は、|D| = Pow(C)なので、Cのフル・トラス圏とも呼ぶ。適当な制限を課して|D|⊆Pow(C)としても同様な定義ができる。制限付きトラス圏構成はCのベキ圏構成を含む。

*1169005281*[プログラム意味論][janus]遷移変換系の具象的圏

具体的に遷移変換系を扱うために、記号法／用語法を固定したい。

&lt;b&gt;TD&lt;/b&gt;を、遷移変換系の圏に対する固有名詞として使う。Σ、Γなどはマルチアルファベット（マルチラベル）で、Σ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)など。書くΣ&lt;sub&gt;i&lt;/sub&gt;はアトミック・ラベル（基本記号）の集合。Σの列としての長さは|Σ|と書く。|Σ| = 0 ⇔ Σは空列() である。圏&lt;b&gt;TD&lt;/b&gt;のホムセットは&lt;b&gt;TD&lt;/b&gt;(Σ, Γ)の形である。

S, T, Uなどで、圏&lt;b&gt;TD&lt;/b&gt;の射＝遷移変換系を表す。ただし、遷移変換系が対象となる圏も当然に考えることになるが。以下、T∈&lt;b&gt;TD&lt;/b&gt;(Σ, Γ)について；

まず、マルチアルファベットΣ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)に対して、Σ&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;× ... ×Σ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;とする。上付きスターはクリーネ・スターで列を意味する。(Σ&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;、()&lt;sup&gt;#&lt;/sup&gt; = &lt;b&gt;0&lt;/b&gt;&lt;sup&gt;*&lt;/sup&gt; = {ε} = E。Σ&lt;sup&gt;#&lt;/sup&gt;の元をマルチアルファベットΣの&lt;strong&gt;リボン&lt;/strong&gt;、またはポートセットΣの&lt;strong&gt;（非同期）信号&lt;/strong&gt;と呼ぶ。

遷移翻訳系Tは、集合Xと、X×Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;×Xの部分集合R（遷移規則）の組(X, R)である。(x, a, b, x')∈Rのことを、x-(a/b)→x' と書く。記号を簡略化するため、RをTと書き、Xを|T|と書く。すると、T⊆|T|×Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;×|T|。

マルチアルファベットΣからΓへの遷移翻訳系T = (|T|, T)に対して、反射的推移的閉包T&lt;sup&gt;*&lt;/sup&gt;を次のように定義する；T&lt;sup&gt;(0)&lt;/sup&gt;は、x-(ε/ε)→x の形の規則の全体。T&lt;sup&gt;(1)&lt;/sup&gt; = T。T&lt;sup&gt;(2)&lt;/sup&gt; は x-(a/b)→x'、x'-(c/d)→x'' に対して、x-(ac/bd)→x'' の形の規則の全体。そして、T&lt;sup&gt;*&lt;/sup&gt; = T&lt;sup&gt;0&lt;/sup&gt;∪T&lt;sup&gt;(1)&lt;/sup&gt;∪T&lt;sup&gt;(2)&lt;/sup&gt;∪… 。

T=(|T|, T)がΣ→Γの遷移翻訳系、U=(|U|, U)がΓ→Δの遷移翻訳系のとき、結合T＊Uを次のように定義する。|T＊U| = |T|×|U|。Tの規則x-(a/b)→x'に対してU&lt;sup&gt;*&lt;/sup&gt;の規則y-(b/c)→y'があるとき、規則(x, y)-(a/c)→(x', y')があるとみなす。

マルチアルファベットΣ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)に対して、I=(|I|, I)を次のように定義する；|I| = {0}（単元）。0-(a/a)→0 （a∈Σ&lt;sup&gt;#&lt;/sup&gt;）をすべて規則とする。

Σに対するI = I&lt;sub&gt;Σ&lt;/sub&gt;を恒等として、結合＊により&lt;b&gt;TD&lt;/b&gt;は圏になる。マルチアルファベットΣ、Γを固定した&lt;b&gt;TD&lt;/b&gt;(Σ, Γ)は、状態空間の直和をモノイド積として、終状態、始状態のグルーイングを結合としてトレース付き圏となり、シミュレーションをセルとしておそらく2-圏となる。つまり、homsetが相当に複雑！

&lt;h5&gt;いろいろな性質&lt;/h5&gt;

遷移翻訳系に関して、いくつかの性質を考える。

- 任意のx∈|T|、a∈Σ&lt;sup&gt;#&lt;/sup&gt;に対して、x-(a/b)→x'という形の遷移規則が存在するとき、Tは&lt;strong&gt;完全&lt;/strong&gt;（exact）と呼ぶ。完全な系は、どんな状態からのどんな入力列にもそれなりに反応する。完全でなければ、破綻の危険がある。
- 任意のx∈|T|、a∈Σ&lt;sup&gt;#&lt;/sup&gt;に対して、x-(a/b)→x'という形の遷移規則がたかだか1個しか存在しないとき、Tは&lt;strong&gt;決定的&lt;/strong&gt;と呼ぶ。決定的な系は、入力列に対する遷移の結果が（もし在るなら）一意的に定まる。
- x≠x'またはb≠εで、x-(ε/b)→x' という形の遷移規則を持つ系は&lt;strong&gt;自発的&lt;/strong&gt;な系と呼ぶ。自発的な系では、外部刺激なしで、非自明な遷移が起こりえる。
- x≠x'またはa≠εで、x-(a/ε)→x' という形の遷移規則を持つ系は&lt;strong&gt;隠蔽的&lt;/strong&gt;な系と呼ぶ。隠蔽的な系では、イベントとして観測できない非自明な遷移が起こりえる。
- 自発的でない系は&lt;strong&gt;因果的&lt;/strong&gt;ともいう。自発的＝非因果的、動作主体の自由勝手が許される。
- 隠蔽的でない系は&lt;strong&gt;完全可視&lt;/strong&gt;ともいう。隠蔽的＝不完全可視、何が起こっているか外部からはうかがい知れない（こともある）。

&lt;h5&gt;系の“わからなさ”&lt;/h5&gt;

- 状態空間がわからない。
- 状態空間がわかっても、現在の状態がわからない。
- 現在の状態が計測的に観測可能かどうかわからない。
- 刺激に対してどう反応するか予測できない。
- 何もしなくても勝手に動く（変動、遷移する）かもしれない。
- 動いてもイベント（反応事象）が発生しないかもしれない。
- 現在の状態がわかっても、動作と反応が一意的ではない。
- 刺激によって系が壊れるかもしれない。
- 壊れているかどうか判断できないかもしれない。

どうやって“わからなさ”を減らすのか？

系の振る舞い（観測される行動）は、具体的な運動のたば（集合）となる。全然予測できないときは最大のタバになり、非常にシャープに予想できるときは単一の軌道からなる集合となる。運動が不可能（破綻した、ありえない）ときが空集合。

通常、シャープ（クリスプ）な予測はできない。確率的な予測もできない。できるのは、制限的予測、あるいは範囲的な予測。範囲的予測には集合（領域）的／位相的量（量＝範囲）を使うしかないような気もする。

結局、系はわからない。わからないままに残る。少しでも制限できれば、少しでも範囲をしぼれれば、それでよしとしよう。クリスプな予測は、所詮は理想論（イデアル）なのだ。

*1169012164*[プログラム意味論][形式言語理論]有限無限の列言語／リボン言語

Σが単なる集合として、Σ&lt;sup&gt;#&lt;/sup&gt;は次の定義にしよう。

- Σ&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sup&gt;*&lt;/sup&gt;∪Σ&lt;sup&gt;∞&lt;/sup&gt;

Σ&lt;sup&gt;∞&lt;/sup&gt;は長さが無限の列の集合で、Σ&lt;sup&gt;∞&lt;/sup&gt;=Map(&lt;b&gt;N&lt;/b&gt;, Σ)。

A⊆Σ&lt;sup&gt;#&lt;/sup&gt;とB⊆Γ&lt;sup&gt;#&lt;/sup&gt;に対して、A;Bを定義できる。A, Bを有限部分と無限部分に分けてA=(A&lt;sub&gt;f&lt;/sub&gt;|A&lt;sub&gt;∞&lt;/sub&gt;)、B=(B&lt;sub&gt;f&lt;/sub&gt;|B&lt;sub&gt;∞&lt;/sub&gt;)とすると、(A&lt;sub&gt;f&lt;/sub&gt;|A&lt;sub&gt;∞&lt;/sub&gt;);(B&lt;sub&gt;f&lt;/sub&gt;|B&lt;sub&gt;∞&lt;/sub&gt;) = (A&lt;sub&gt;f&lt;/sub&gt;;B&lt;sub&gt;f&lt;/sub&gt;|A&lt;sub&gt;∞&lt;/sub&gt;∪A&lt;sub&gt;f&lt;/sub&gt;;B&lt;sub&gt;∞&lt;/sub&gt;)となる。

マルチアルファベットになっても同じ。(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;#&lt;/sup&gt;× ... ×Σ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;#&lt;/sup&gt;。有限部分と無限部分への分割も同じ。

- ウィルケ代数も参照→[http://d.hatena.ne.jp/m-hiyama-memo/20060607/1149652184:title]

*1169022898*[その他代数] Boolean algebras with operators

http://math.chapman.edu/cgi-bin/structures.pl?Boolean_algebras_with_operators より：

Abbreviation: &lt;b&gt;BAO&lt;/b&gt;

&lt;b&gt;Definition:&lt;/b&gt; A Boolean algebra with operators is a structure A = (A,∨,0, ∧,1,￢,f&lt;sub&gt;i&lt;/sub&gt; (i ∈ I)) such that 

+ (A,∨,0,∧,1,￢) is a Boolean algebra,
+ f&lt;sub&gt;i&lt;/sub&gt; is join-preserving in each argument:   f&lt;sub&gt;i&lt;/sub&gt;( ..., x∨y, ...) = f&lt;sub&gt;i&lt;/sub&gt;(..., x, ...)∨f&lt;sub&gt;i&lt;/sub&gt;(..., y, ...), and
+ f&lt;sub&gt;i&lt;/sub&gt; is normal in each argument:   f&lt;sub&gt;i&lt;/sub&gt;(..., 0, ...) = 0 for each i ∈ I. 

&lt;b&gt;Morphisms:&lt;/b&gt; Let A and B be Boolean algebras with operators of the same signature. A morphism from A to B is a function h : A→B that is a Boolean homomorphism and preserves all the operators: h(f&lt;sub&gt;i&lt;/sub&gt;(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)) = f&lt;sub&gt;i&lt;/sub&gt;(h(x&lt;sub&gt;1&lt;/sub&gt;), ..., h(x&lt;sub&gt;n&lt;/sub&gt;)). 


</body>
</day>
<day date="2007-01-18" title="">
<body>
*1169087662*[課題]ラフ・ロードマップ -- 拡張版マイヒル／ネロード定理

遷移変換系を調べる手順（予定）をざっと書いておく。

まず、何を目標にするかというと、遷移変換系に関するマイヒル／ネロード定理。

- システムの圏（高次圏）Sysを定義する。
- 代数的な圏（高次圏）Algを定義する。
- 振る舞い関手B:Sys→Algを構成する。
- 実現関手（マイヒル／ネロード関手）N:Alg→Sysを構成する。

このとき：

- 振る舞い関手と実現関手は何らかの意味で随伴。
- 振る舞い関手はTQFT公理を満たす。
- M = B;N は最小化（正規化）モナドとなる。
- N;B は自明なモナドとなる。

上記の状況を、&lt;strong&gt;マイヒル／ネロード随伴&lt;/strong&gt;（Myhill/Nerode adjunction）と呼びたい。

道具立て、副産物に関して：

- 振る舞い関手の構成にクリーネ／ファインマン公式を使う。
- 実現関手の構成には余代数を使う。
- 最小化の関係で、可到達代数と可観測代数が登場する（といいが？）。
- 振る舞いの値の圏はコゥゼン圏？
- ストーン双対が使えるといいな。
- ビドゥイット／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）双対も使えるといいな。
- ゴールドブラッド（Goldblatt）双対も使えるといいな。
- 模倣（シミュレーション）、2方向模倣、双模倣が必要だろう。
- 一様性原理がどこかで登場しないか？
- ホーア論理に関するインスティチューションが登場するといいな。
- 超越的な方法だけでなく、具体的・構成的な方法が使えるといいのだが…

*1169087906*[プログラム意味論][その他代数]ドメイン作用素付きブール／クリーネ加群（BKMD）

A, Bがブール代数、Mが(A, B)両側半加群（加法的にベキ等；順序付き）、δ:M→A、ρ:M→B があって次を満たすとき、(A, B, M, δ, ρ)を&lt;strong&gt;ドメイン作用素付きブール／クリーネ加群&lt;/strong&gt;（BKMD; Boole/Kleene Module with Domain）と呼ぶ。

+ x≦δ(x)・x
+ x≦x・ρ(x)
+ δ(p・x)≦p
+ ρ(x・q)≦q
+ δ(x・δ(y))≦δ(x;y)
+ ρ(ρ(x)・y)≦ρ(x;y)

δ(0) = 0、δ(x + y) = δ(x) + δ(y) は定理として示せる（ρも同様）。
Mが(A, A)-半加群なら、p∈A、x∈Mに対して、x&lt;sup&gt;←&lt;/sup&gt;(p) を δ(x・p)、x&lt;sup&gt;→&lt;/sup&gt;(p) を ρ(p・t) で定義できそうだ。

- x&lt;sup&gt;←&lt;/sup&gt;(0) = δ(x・0) = δ(0) = 0
- x&lt;sup&gt;←&lt;/sup&gt;(p + q) = δ(x・(p + q)) = δ(x・p + x・q) = δ(x・p) + δ(x・q) = x&lt;sup&gt;←&lt;/sup&gt;(p) + x&lt;sup&gt;←&lt;/sup&gt;(q)

- Mが(A, A)-半加群なら、1&lt;sub&gt;A&lt;/sub&gt;∈Mがあるので、A×M→MによりAはMに作用する。これでテスト付きクリーネ代数（KAT）が実現できる。

- 参考→[http://d.hatena.ne.jp/m-hiyama-memo/20061025/1161765785:title]

*1169088000*[高次圏論][プログラム意味論]半加群の二重圏

A, Bが半環、Mが(A, B)-両側半加群であるとき、M:A→B と書く。M:A→B, N:B→Cに対して、Bに関するテンソル積をM※&lt;sub&gt;B&lt;/sub&gt;Nとすると、これは(A, C)-両側半加群になる。このテンソル積を結合として、半環上の両側半加群の圏ができる。半環Aの恒等射は、A:A→A とA自身を(A, A)上の両側半加群とみなしたものである。

半加群(A, B, M)と(C, D, N)に対して、φ:A→C, ψ:B→D、f:M→N が適切な条件を満たすとき、半加群の準同型とする。準同型f:M⇒Nは、2-セルと考える。
境界関手D0, D1:Semimod→Semiringを、D0(M)=A（左係数半環）, D1(M)=B（右係数半環）として、半環から半加群への持ち上げをI(A)=(A:A→A)とすると、二重圏が定義できる。二重圏のスター結合はテンソル積。二重圏には、半環と半加群の直積でモノイド積が入る。

半環をブール代数、半加群を加法的ベキ等として、さらに次の構造を入れる。

- クリーネ・スター、またはトレース
- ドメイン作用素δ、ρ

このとき、次の対応があるだろう。

- 状態空間 ： ブール代数
- 状態空間の領域 ： ブール代数の元
- プログラム ： 半加群
- プログラムの実行 ： 半加群の元
- プレガード ： 左スカラー乗法
- ポストガード ： 右スカラー乗法
- 非決定性選択 ： 加法
- 順次結合 ： テンソル積
- 状態空間の直和 ： 半加群の直積

乗法を反対にした反対半環A&lt;sup&gt;○&lt;/sup&gt;を利用して、dualizer反変関手を定義できる。homsetであるSMod(A, A)をSMod[A]と書くと、indexed categoryが作れる。係数半環の制限や拡張も定義できる。このへんの事はいずれ書く。

*1169088545*[説明]ホーア式

- 「釣りはフナに始まり、フナに終わる」
- 「料理はオムレツに始まり、オムレツに終わる」

じゃ、

- 「形式手法はホーア式に始まり、ホーア式に終わる」

※ [http://d.hatena.ne.jp/m-hiyama/20070118/1169089250:title]にインスパイアされた。
</body>
</day>
<day date="2007-01-19" title="">
<body>
*1169192008*[高次圏論][具体例]二重圏

次が構成しやすい例だろう：

+ 境界付きグラフの二重圏、セルは写像でも関係でもいい。
+ 両側半加群の圏、基底変換、indexed categoryなどの例にもなる。

これから調べる例：

- 古典テンソル計算の圏

2つの積、2つのトレースが入る。セルとしては変形（書き換え）アルゴリズムを考えればいいか。

現実的な例：

+ 遷移翻訳系の圏（次元は3）
+ TQFT、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070104/1167881986&quot;&gt;CGFT&lt;/a&gt;

*1169194153*[高次圏論]二重圏から2-圏を作る手順

Mを射圏、Oを対象圏とする二重圏を考える。D0, D1:M→Oが境界関手（dom, codのこと）、I:O→Mが持ち上げ関手（idのこと）だとする。M[D0,O,D1]M = M[O]Mは、圏のファイバー積（バンドル積）を表す便宜的な記号。＊:M[O]M→Mが二重圏のスター結合（スター積、セルの横結合／水平結合）

(M, O) = (M, O, D0, D1, I, ＊)から2-圏を作ることができる。それをCとする。

- |C| = |O|
- A, B∈|C|に対して、C&lt;sub&gt;0&lt;/sub&gt;(A, B)⊆|M|
- A, B∈|C|に対して、C&lt;sub&gt;1&lt;/sub&gt;(A, B)⊆M
- C = Morph(C) は一切使わない。

ここで、C(A, B)を2-圏Cのhomcatだとして、C&lt;sub&gt;0&lt;/sub&gt;(A, B) = Obj(C(A, B)), C&lt;sub&gt;1&lt;/sub&gt;(A, B) = Morph(C(A, B))。

- C&lt;sub&gt;0&lt;/sub&gt;(A, B) = {X∈|M| | D0(X) = A, D1(X) = B}
- (C&lt;sub&gt;1&lt;/sub&gt;(A, B))(X, Y) = {f∈M | f:X→Y in M}

homcatは、Mの構造をほぼそのまま受け継いでいる。homecat内の射を2セルと見なして、f::X⇒Y:A→Y のように書いてよい。homcat内の結合（縦結合／垂直結合）は、Mの結合をそのまま使う。X:A→B、Y:B→Cの横結合／水平結合、f::X⇒X':A→Bとg::Y⇒Y7:B→Cの横結合／水平結合は、二重圏(M, O)のスター結合を使う。

この構成だと、対象圏Oの射は消えてしまう。もし、圏O×Oをbaseとするindexed categoryの構造を持つなら、二重圏を構成することができる。しかし、それがもとの二重圏を再現するかどうかはわからない。再現するには何らかの条件が必要だろう。

</body>
</day>
<day date="2007-01-20" title="">
<body>
*1169259674*[山勘][課題]遷移翻訳系の圏構造を考える

発見的な議論をしてみる。

Tが遷移翻訳系のとき、T⊆X×Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;×X としていいだろう。ここで：

- Xは状態空間
- Σ=(Σ&lt;sub&gt;1&lt;/sub&gt;, ..., Σ&lt;sub&gt;n&lt;/sub&gt;)はマルチアルファベットで、Σ&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;× ... ×Σ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;はΣ上のリボンの全体（全リボン集合）。

Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;をAと置いてみると、T⊆X×A×Xなので、通常のラベル付き遷移系とみなせる。Tを、XとA×Aの二項関係とみなすと、関係圏で T:X→A×X。関係はベキへの写像だから、集合圏で T:X→Pow(A×X)。Pow(A×-)は集合圏上の自己関手なので、Tは集合圏上の余代数となる。F=Pow(Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;×-)として、圏Coalg&lt;sub&gt;F&lt;/sub&gt;を考えることができる。

圏Coalg&lt;sub&gt;F&lt;/sub&gt;が、圏&lt;b&gt;TD&lt;/b&gt;(Σ, Γ)と一致するので、&lt;b&gt;TD&lt;/b&gt;は、圏で豊饒化（enrich）されているというよりは、余代数圏で豊饒化されている（→[http://d.hatena.ne.jp/m-hiyama-memo/20060603/1149299169:title]、[http://d.hatena.ne.jp/m-hiyama-memo/20060518/1147943110:title]）。

&lt;b&gt;TD&lt;/b&gt;をトレース付き圏と考えているとどうもうまくない。コンパクト閉圏にしたほうがいいだろう。そうすれば、&lt;b&gt;TD&lt;/b&gt;(Σ, Γ)≒&lt;b&gt;TD&lt;/b&gt;(1×Σ, Γ) ≒&lt;b&gt;TD&lt;/b&gt;(1, Γ×Σ&lt;sup&gt;*&lt;/sup&gt;) （ここでの上付きスターはクリーネ・スターではなくて、圏のdualizer）となって、翻訳系が遷移系に還元できる様が分かりやすくなる。

という次第で：

- 圏&lt;b&gt;TD&lt;/b&gt;は、とりあえず2-圏と考える（後で&lt;em&gt;二重圏構造も入れる&lt;/em&gt;）。
- 圏&lt;b&gt;TD&lt;/b&gt;を&lt;em&gt;コンパクト閉圏と考える&lt;/em&gt;。そのため、マルチアルファベットに極性と双対(-)&lt;sup&gt;*&lt;/sup&gt;を入れる。
- homcat &lt;b&gt;TD&lt;/b&gt;(Σ, Γ)を余代数の圏と考える。このとき、余代数の構造関手（指標関手）はΣとΓでパラメトライズされている。
- スター結合（横結合）は、終余代数にも適用できるはず。終余代数だけ取り出して圏が作れるってことか？

*1169267385*[プログラム意味論][形式言語理論]言語関係は言語族になる。

Σ、Γはマルチアルファベットだとして、Σ×Γは、列の連接で定義される積だとする。空列を1とすると、1×Σ = Σ×1 = Σ。Σ&lt;sup&gt;#&lt;/sup&gt;を全リボン集合だとする。定義から、(Σ×Γ)&lt;sup&gt;#&lt;/sup&gt; = Σ&lt;sup&gt;#&lt;/sup&gt;×Γ&lt;sup&gt;#&lt;/sup&gt;、ただし、右側の×は集合の直積。

L(Σ) = Pow(Σ&lt;sup&gt;#&lt;/sup&gt;)とすると、L(Σ)×L(Γ) ⊆ L(Σ×Γ) とみなす標準的な埋め込みができる。なぜなら、A = Σ&lt;sup&gt;#&lt;/sup&gt;、B = Γ&lt;sup&gt;#&lt;/sup&gt;とすれば、Pow(A)×Pow(B) ⊆ Pow(A×B) だから。

R⊆L(Σ)×L(Γ)だとすると、L(Σ)×L(Γ) ⊆ L(Σ×Γ) と組み合わせて、R⊆L(Σ×Γ)。これより、Rel[L(Σ), L(Γ)] ⊆ Pow(L(Σ×Γ)) となり、言語のあいだの関係は、言語族だとみなしていいことになる。

言語関係は、言語係数行列の拡張概念だが、それが言語族に還元できるのは、扱いを簡略化するのに使えそうだ。

</body>
</day>
<day date="2007-01-22" title="">
<body>
*1169453774*[形式言語理論][プログラム意味論]双ラベル付き関係（bilabelled relations）の圏

ラベル付き遷移系Tは、T⊆X×A×X だが、T⊆X×A×Y として、T:X→Yの射と考えて圏を作れる。この圏は、集合と関係の圏の拡張になる。（Aを単元に限定すると関係圏。）S∨T = S∪T、0は空集合として、ホムセットはジョイン半束＝ベキ等可換モノイドにできるので、order-enrichedになる。T:X→Xに対しては反射的・推移的閉包を対応させるとクリーネ圏になる。

T⊆X×(A×B)×Y とすると、T:X→Yと同時にT:A→Bとも考えられて二重圏となる。この二重圏をベースに、状態空間のペキ集合のブール代数を一緒に考えると、ブール代数上の両側半加群の二重圏と近い。しかし、コボルディズム的なTQFTとは少し違うな。

次の4つは（かなり似ているんだが）どう関係している？

+ 遷移翻訳系＝双ラベル付き遷移系の2-圏
+ ブール代数係数の両側半加群の二重圏
+ TQFTスタイルで定義したコンポネントの二重圏
+ 双ラベル付き関係の二重圏

*1169454064*[形式言語理論][トレース／コンパクト閉圏]しつこくKozen圏

また、ふとコゥゼン（Kozen）圏について考えた。最近、定義はほぼ安定していて：

- &lt;em&gt;トレース付き・ベキ等・双デカルト 圏&lt;/em&gt;

である。デカルト性は、対称モノイド構造×, 1と対角（余加法）Δ、放電（discharger；余単位）!で決まる。これは、すべての対象Aに可換余モノイド構造(A, Δ&lt;sub&gt;A&lt;/sub&gt;, !&lt;sub&gt;A&lt;/sub&gt;)を与える。余デカルト性はその双対で、余対角（加法）∇、単位（零）θで決まる。すべての対象Aに可換モノイド構造(A, ∇&lt;sub&gt;A&lt;/sub&gt;, θ&lt;sub&gt;A&lt;/sub&gt;)を与える。

デカルトかつ余デカルトであり双代数条件（bialgebra condition）∇;Δ = □ を満たすとき、双デカルトと呼ぶ。すべての対象Aが双モノイド（双代数）となる。さらに、Δ;∇ = 1 のとき（加法的）ベキ等と呼ぶ。以上で、ベキ等・双デカルト圏が定義できる。定義より、当然に対称モノイド圏である。定義より、双デカルト圏のモノイド積は双積である。

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20061006/1160126861:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528:title]

ベキ等・双デカルト圏が、その対称モノイド積＝双積に関してトレースを持っていると、これが&lt;strong&gt;コゥゼン（Kozen）圏&lt;/strong&gt;である。コゥゼン圏の定義から、どれだけの事実が引き出せるか？ が課題。

とりあえず、&lt;em&gt;コゥゼン圏のなかで行列スター公式を示したい。&lt;/em&gt;あと、トレースを使って、f&lt;sup&gt;†&lt;/sup&gt;、f&lt;sup&gt;+&lt;/sup&gt;、f&lt;sup&gt;*&lt;/sup&gt;などに関する等式群を示したい。

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20060623/1151031526:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148523219:title]

クリーネ・スターを*、第1行が(a, b)、第2行が(c, d)である2×2行列を[a b / c d]で示すことにする。行列A = [a b / c d]に対するスターの定義は、A* = [α β / γ δ] として：

- α = (a + bd*c)* 
- β = αbd* 
- γ = δca* 
- δ = (d + ca*b)* 

で与えられる。これが行列スター公式。


</body>
</day>
<day date="2007-01-23" title="">
<body>
*1169510502*[メモ法]いまさらながら

言ってみるが、&lt;br&gt;&lt;strong&gt;&lt;span style=&quot;font-size:x-large;&quot;&gt;人にわかるように書いてみると、自分もわかる！&lt;/span&gt;&lt;/strong&gt;

*1169510881*[プログラム意味論][トレース／コンパクト閉圏]セリンガーのND補題

セリンガー（Peter Selinger）が&quot;Categorical Structure of Asynchrony&quot;（→http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf）で示しているのだが、面白い補題がある。

(C, ×, Tr, Δ)を対角付きトレース付き（対称モノイド）圏だとして、そのベキ構成（木下の定義と同じだが、空集合は除く）をC&lt;sup&gt;nd&lt;/sup&gt;とする。ndは非決定性を表す。×、Tr、Δを自明に拡張する。その結果である(C, ×, Tr, Δ)もまたC&lt;sup&gt;nd&lt;/sup&gt;と書く。

- F×G = {f×g | f∈F, g∈G}
- Tr(F) = {Tr(f) | f∈F}
- Δ&lt;sub&gt;X&lt;/sub&gt; = {Δ&lt;sub&gt;X&lt;/sub&gt;}

セリンガー曰く：
&gt;&gt;
Surprisingly, this simple-minded construction actually preserves the structure of C.
&lt;&lt;

次が成立する。

+ C&lt;sup&gt;nd&lt;/sup&gt;は対角付きトレース付き圏である。
+ 標準的な埋め込みC→C&lt;sup&gt;nd&lt;/sup&gt;によりC⊆C&lt;sup&gt;nd&lt;/sup&gt;と考えるとして、(C&lt;sup&gt;nd&lt;/sup&gt;)&lt;sup&gt;#&lt;/sup&gt; = C&lt;sup&gt;#&lt;/sup&gt; である。(-)&lt;sup&gt;#&lt;/sup&gt;は焦点部分圏。つまり、焦点は不変となる。
+ Cがデカルトのとき、C&lt;sup&gt;nd&lt;/sup&gt;の射はすべてトータル射（破棄可能）となる。
+ Cがデカルトであり一様性を持つ（uniformly traced）のとき、C&lt;sup&gt;nd&lt;/sup&gt;も一様性を持ち、一様射のクラスはCのそれと一致する。

一様トレース（trace with uniformity, uniform trace）を持つデカルト圏（Uniformly traced Cartesian category）Cでは、ベキ構成をしても、焦点（C自身）は不変で、一様射（uniform morphism）のクラスも不変であり、非決定性（コピー不可）が導入されるが全域性（トータリティ）は保存される。

ついでに、引用によってセリンガーの用語法を示す。
&gt;&gt;
For a given traced monoidal category C, fix a monoidal subcategory of &lt;em&gt;uniform morphisms&lt;/em&gt;. This subcategory should include at least all isomorphisms, the diagonals, and the weak initial and terminal morphisms. &lt;em&gt;Uniformity of the trace operator&lt;/em&gt; is defined with respect to this notion of uniform morphism:

Definition 3.8 (Hasegawa [7]) Given a traced monoidal category with diagonals, we say that &lt;em&gt;the trace is uniform&lt;/em&gt; if for all morphisms f ...[省略]

... &lt;em&gt;uniform traces&lt;/em&gt; correspond to &lt;em&gt;uniform fixpoint operators&lt;/em&gt;. 
&lt;&lt;

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031284:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060818/1155894528:title]

*1169511179*[形式言語理論][プログラム意味論]木下のμ圏

何度か引用している&quot;不動点をめぐる代数構造たち&quot; by 木下佳樹（http://unit.aist.go.jp/cvs/tr-data/PS02-005.PDF）のP.2に次の定義がある。

&lt;strong&gt;μ圏&lt;/strong&gt;とは，局所順序圏C，C の対象の二つ組(a, b)に対して hom集合C(a, b) の可算列の上限演算子∨&lt;sub&gt;a,b&lt;/sub&gt;: C(a, b)&lt;sup&gt;ω&lt;/sup&gt; → C(a, b) を与える∨，およびC(a, b) の最小元⊥&lt;sub&gt;a,b&lt;/sub&gt; を与える⊥の三つ組(C,∨,⊥)で，上限および最小限が射の合成に関して分配されるようなもの，つまり

- (∨&lt;sub&gt;a,b&lt;/sub&gt;(q0, q1, ...));(∨&lt;sub&gt;b,c&lt;/sub&gt;(r0, r1, ...)) = ∨&lt;sub&gt;a,c&lt;/sub&gt;(q0;r0, q1;r0, ... , q0;r1, q1;r1, ...) 
- ⊥&lt;sub&gt;a,b&lt;/sub&gt;;⊥&lt;sub&gt;b,c&lt;/sub&gt;  = ⊥&lt;sub&gt;a,c&lt;/sub&gt;

が成り立つようなものである。

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20061024/1161648695:title]

*1169543367*[その他代数][具体例]ベキ等半環の利用例

ローランド・バックハウス（ロランかもしれない；Roland Backhouse）が、加法的ベキ等半環について簡単なメモ（たぶん教材）を書いている。そのなかで例にしている半環は：

+ 言語の集合（例：正規集合の半環）
+ プログラムの二項関係モデル
+ ブール代数と可達性（Reachability）判定
+ Shortest Paths問題
+ Bottlenecks問題

Reachability、Shortest Paths、Bottlenecksはグラフ上の問題のようだが、よく知らない。

(&lt;b&gt;N&lt;/b&gt;∪{+∞}, min, +)が狭義のtropical半環（min-plus代数）、これを実数にした(&lt;b&gt;R&lt;/b&gt;∪{+∞}, min, +)（順序は普通と逆）はoptimization代数というのだそうだが、Shortest Paths問題に使うのだそうだ。Bottlenecks問題には、(&lt;b&gt;R&lt;/b&gt;∪{+∞}, max, min)（順序は普通）を使うのだとか。そもそも、ボトルネックの解析ってどうやるんだ？

- →[http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733:title]


</body>
</day>
<day date="2007-01-24" title="">
<body>
*1169612934*[雑感]ウゲッ、やっぱConway圏かぁ?!

ベントンとハイランドのトレース付きプレモノイド（premonoidal, ときにpromonoidal）圏の論文で、Conway（不動点）作用素（Conway operator）が出てくる。それと、積スター公式、和スター公式というConway公式群（等式群；identities）を満たすConway半環つうものがある。

この状況では、Conway作用素を持つ圏（他に条件があるが）をConway圏と呼び、C内のEnd(U)がConway半環になる、つまり、「Conway圏とConway半環が（ある程度）対応する」という用語法が自然だろう。

ウーム、Kozen圏→Conway圏 とリネームしたほうがいいのかも。

- [google:&quot;Conway category&quot; functor] -- Wed Jan 24 2007現在、該当無し

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20061107/1162888657:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060527/1148715176:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060525/1148539204:title]

*1169614527*[雑記][人物]キリロフとカジュダン

アレクサンドル・キリロフ（Alexandre Kirillov; http://www.math.upenn.edu/~kirillov/、http://en.wikipedia.org/wiki/Alexandre_Kirillov）は、&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%83%89%E3%83%9F%E3%83%88%E3%83%AA%E3%83%BC%E3%83%BB%E3%82%AB%E3%82%B8%E3%83%A5%E3%83%80%E3%83%B3&quot;&gt;カジュダン&lt;/a&gt;の先生だったのか。

その息子（http://en.wikipedia.org/wiki/Alexander_Kirillov_Jr）も同じ名前らしい。紛らわしいぞ。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060930/1159588376&quot;&gt;バカキリ本&lt;/a&gt;のキリロフはどっちだ？

んっ、んん、息子は http://www.math.sunysb.edu/~kirillov/、Alexand&lt;em&gt;re&lt;/em&gt;とAlexand&lt;em&gt;er&lt;/em&gt;の違いがあるのか？


</body>
</day>
<day date="2007-01-26" title="">
<body>
*1169774917*[雑記]データ集合のあいだの関係（被リンク用） 

「[http://d.hatena.ne.jp/m-hiyama/20070125/1169702291:title]」にて：
&gt;&gt;
+ &lt;b&gt;T&lt;/b&gt;⊆Templ(A)⊆Nest(A)
+ A⊆B ならば、Templ(A)⊆Templ(B)、Nest(A)⊆Nest(B)
+ &lt;b&gt;0&lt;/b&gt;が空集合なら、Templ(&lt;b&gt;0&lt;/b&gt;)＝&lt;b&gt;T&lt;/b&gt;、Nest(&lt;b&gt;0&lt;/b&gt;)＝&lt;b&gt;T&lt;/b&gt;
+ Templ(&lt;b&gt;T&lt;/b&gt;)＝&lt;b&gt;TT&lt;/b&gt;、Nest(&lt;b&gt;T&lt;/b&gt;)＝&lt;b&gt;NT&lt;/b&gt;
&lt;&lt;

これらを明白に示そう。まず、&lt;b&gt;T&lt;/b&gt;と&lt;b&gt;TT&lt;/b&gt;のnestLevelによる特徴付け。

- t∈&lt;b&gt;T&lt;/b&gt; ⇔ nestLevel(t) = 0
- t∈&lt;b&gt;TT&lt;/b&gt; ⇔ nestLevel(t) ≦ 1

BBC(t)を、t∈&lt;b&gt;NT&lt;/b&gt;の末端ブロック内容（Bottom Block Content でBBC）をかき集めた集合とする。BBC(t)は、&lt;b&gt;プログラミング課題4&lt;/b&gt;のプログラムから簡単に作れる集合値関数。BBCを使うと、次の特徴付けができる。

- t∈&lt;b&gt;T&lt;/b&gt; ⇔ BBC(t) = &lt;b&gt;0&lt;/b&gt;
- t∈Nest(A) ⇔ BBC(t)⊆A

Templ(A)の特徴付けは（∧はandの意味）：

- t∈Templ(A) ⇔ (nestLevel(t)≦1 ∧ BBC(t)⊆A)

さて、問題の等式群を示そう。1番目と2番目は直感的にも分かりやすいから省略して、最初に、Templ(&lt;b&gt;0&lt;/b&gt;)＝&lt;b&gt;T&lt;/b&gt;を示す； t∈Templ(&lt;b&gt;0&lt;/b&gt;) は、上の特徴付けから、nestLevel(t)≦1 ∧ BBC(t)⊆&lt;b&gt;0&lt;/b&gt;。ところが、BBC(t)⊆&lt;b&gt;0&lt;/b&gt;から BBC(t) = &lt;b&gt;0&lt;/b&gt;、これからt∈&lt;b&gt;T&lt;/b&gt;。t∈&lt;b&gt;T&lt;/b&gt; ⇒ t∈Templ(&lt;b&gt;0&lt;/b&gt;) も明らか（だって、&lt;b&gt;T&lt;/b&gt;⊆Templ(A)だったもん）。これで示せた。

次、Nest(&lt;b&gt;0&lt;/b&gt;)＝&lt;b&gt;T&lt;/b&gt;； t∈Nest(&lt;b&gt;0&lt;/b&gt;) ⇔ BBC(t)⊆&lt;b&gt;0&lt;/b&gt;、これから t∈Nest(&lt;b&gt;0&lt;/b&gt;) ⇔ BBC(t) = &lt;b&gt;0&lt;/b&gt; だけど、BBC(t) = &lt;b&gt;0&lt;/b&gt; は t∈&lt;b&gt;T&lt;/b&gt; を意味する。

その次、Templ(&lt;b&gt;T&lt;/b&gt;)＝&lt;b&gt;TT&lt;/b&gt;； Templ(A)の特徴付けを使うと、t∈Templ(&lt;b&gt;T&lt;/b&gt;) ⇔ (nestLevel(t)≦1 ∧ BBC(t)⊆&lt;b&gt;T&lt;/b&gt;)。だけど、BBC(t)⊆&lt;b&gt;T&lt;/b&gt;は当たり前（常に成立）だから落として、t∈Templ(&lt;b&gt;T&lt;/b&gt;) ⇔ nestLevel(t)≦1 。nestLevle(t)≦1 ってことは、t∈&lt;b&gt;TT&lt;/b&gt;に他ならない。

最後に、Nest(&lt;b&gt;T&lt;/b&gt;)＝&lt;b&gt;NT&lt;/b&gt;； Nest(A)の特徴付けを使うと、t∈Nest(&lt;b&gt;T&lt;/b&gt;) ⇔ BBC(t)⊆&lt;b&gt;T&lt;/b&gt;。BBC(t)⊆&lt;b&gt;T&lt;/b&gt; は当たり前だから、tには何の条件も付いてない。つまり、tは任意のネストしたテキスト。

</body>
</day>
<day date="2007-01-30" title="">
<body>
*1170115942*[雑記]モナド法則の3番目を確認する（被リンク用）

fとgの関数合成（結合）を、g・f（&lt;em&gt;順序に注意&lt;/em&gt;）とナカグロ記号を使いましたが、このナカグロに対応する高階関数compを書いておきましょう。

&lt;pre class=&quot;code&quot;&gt;
function comp(g, f) {
 return function (x) {return g(f(x));}
}
&lt;/pre&gt;

さて、モナド法則の3番目は、

- ext(&amp;#40;ext(con2))・con1) = ext(con2)・ext(con1) 

ナカグロ「・」をcompに置き換えて、変数lhsとrhs（left hand side、right hand sideのつもり）にセットしておきます。templ-test.jsの環境を使うことにして：

&lt;pre class=&quot;out&quot;&gt;
js&gt; var lhs = ext(comp(ext(confun2), confun1))
js&gt; var rhs = comp(ext(confun2), ext(confun1))
js&gt; 
&lt;/pre&gt;

具体例で lhs = rhs を確認。
&lt;pre class=&quot;out&quot;&gt;
js&gt; lhs(message)
Hello, Tonkichi.
It's a Good News, ...
--
Hanako

js&gt; rhs(message)
Hello, Tonkichi.
It's a Good News, ...
--
Hanako

js&gt; 
&lt;/pre&gt;

</body>
</day>
<day date="2007-01-31" title="">
<body>
*1170236559*[リンク][圏一般論]テンソル圏／オペラッドの資料

- http://arxiv.org/abs/math.QA/9909027
Title: Planar algebras, I&lt;br&gt;Author: Vaughan F. R. Jones &lt;br&gt;122ページ、長いテキスト。

- http://arxiv.org/abs/math.CT/0401347
Title: Tensor categories (after P. Deligne)&lt;br&gt;Authors: Victor Ostrik&lt;br&gt;7ページだったので印刷した。

- ボロノフ（Voronov）の講義資料： http://math.umn.edu/~voronov/8390/
小さい文書がイッパイ。まとめてくれればいいのに。


</body>
</day>
<day date="2007-02-01" title="">
<body>
*1170308213*[プログラム意味論][トレース／コンパクト閉圏][形式言語理論]一様性原理と帰納原理

[http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163147851:title]を別な記号法で書いてみる。

- [HU]  f;(B+ψ) = (A+ψ);g ⇒  f↑ = g↑
- [PU]  f;ψ = (A+ψ);g ⇒ f&lt;sup&gt;†&lt;/sup&gt;;ψ = g&lt;sup&gt;†&lt;/sup&gt;
- [KU]  f;ψ = ψ;g ⇒ f&lt;sup&gt;*&lt;/sup&gt;;ψ = ψ;g&lt;sup&gt;*&lt;/sup&gt;
- [KI-1] f;ψ ≦ ψ ⇒ f&lt;sup&gt;*&lt;/sup&gt;;ψ ≦ ψ
- [KI-2] ψ;g ≦ ψ⇒ ψ;g&lt;sup&gt;*&lt;/sup&gt; ≦ ψ 

*1170308864*[プログラム意味論][形式言語理論][リンク]Kozenのマイヒル／ネロード関係の論文

- &quot;Myhill-Nerode Relations on Automatic Systems and the Completeness of Kleene Algebra&quot; by Dexter Kozen（http://techreports.library.cornell.edu:8081/Dienst/UI/1.0/Display/cul.cs/TR2000-1826?abstract=）

このURLからフリーダウンロード可能。

*1170319368*[用語法][圏一般論]テンソル圏に関する概念と用語法

岩波『数学』Vol.59 No.1（2007年1月号）に、山上滋「作用素環とテンソル圏」が載っていた。作用素環やら群の表現論の部分（それが実質的な内容だけど^^;）はサッパリわからんが、テンソル圏（tensor categories）に関する用語法が滅茶苦茶なのはよくわかった。

&lt;h4&gt;●テンソル圏の定義&lt;/h4&gt;

いろいろな定義（というか習慣）があるようで、列挙しておくと：

+ 対称性を仮定しないモノイド圏をテンソル圏と呼ぶ。
+ 対称モノイド圏をテンソル圏と呼ぶ。
+ k-線形圏でありモノイド圏でもあるものをテンソル圏と呼ぶ（対称性は仮定しない）。
+ k-線形な対称モノイド圏をテンソル圏と呼ぶ。
+ 剛性を持つ（「堅い」「硬い」とも言う）k-線形な対称モノイド圏をテンソル圏と呼ぶ。

&lt;strong&gt;k-線形&lt;/strong&gt;（k-linear）とは、kが （普通は標数0の）体だとして、homsetがk-ベクトル空間で、射の結合が双線形写像になっていること。k-線形性の仮定があるときは、公理的テンソル積（モノイド積）双関手※は、(C×C)[(X, Y), (U, V)]→C(X※U, Y※V)を定義する。これは、C(X, U)×C(Y,V)→C(X※U, Y※V) の写像である（ここで×は集合の直積）が、双線形であることを仮定する。結果的に、普通のベクトル空間テンソル積を(×)として、C(X, U)(×)C(Y,V)→C(X※U, Y※V) がベクトル空間の圏に入る写像となる。

k-線形性の代わりに、&lt;strong&gt;アーベル圏&lt;/strong&gt;であることを仮定することもある。例えば、「k-線形な対称モノイド圏」の代わりに、「アーベル圏でもある対称モノイド圏」。アーベル圏では、&lt;strong&gt;双積&lt;/strong&gt;（普通、直和と言っている）があるから、単なるk-線形圏より強い条件となるが、それほどの差ではない。

さて、用語法に関するコメントだが； まず、単なるモノイド圏／対称モノイド圏をテンソル圏と呼ぶのは論外だろう。用語が重複する（同義語が増える）だけで良くない。

山上さんは、「k-線形モノイド圏＝テンソル圏」を採用しており、X※YとY※Xはまったく無関係（対称性はない）としている。&lt;strong&gt;ブレイディング&lt;/strong&gt;（山上さんの訳語は「組紐構造」）との関係でいえば、対称性まで仮定するのは強すぎて、ブレイド付き（braided）テンソル圏の特殊ケースとして対称テンソル圏があるほうが自然。なお、&lt;strong&gt;対称ブレイディング&lt;/strong&gt;（symmetric braiding; β&lt;sub&gt;Y,X&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;=β&lt;sub&gt;X,Y&lt;/sub&gt;）を、山上さんの論説では&lt;strong&gt;置換対称性&lt;/strong&gt;（permutation symmetry）と言っている。

&lt;h4&gt;●剛性&lt;/h4&gt;

&lt;strong&gt;剛性&lt;/strong&gt;（rigidity）は、かなり一般的に使われている用語のようだ。剛性はコンパクト閉圏の定義と同じものだ。しかし、「コンパクト閉テンソル圏」なんて言葉は誰も使ってないので、もはやしょうがない。「コンパクト閉圏」の代わりに「堅い対称モノイド圏」なんてことになるかも？

剛性は双対で定義されるが、山上論説から引用すると：

- 2つの対象X, Yに対して、ε:X×Y→I、δ:I→Y×X が存在して…

省略した部分はジグザグ恒等式である。Xが“Yの&lt;strong&gt;左双対&lt;/strong&gt;”、Yが“Xの&lt;strong&gt;右双対&lt;/strong&gt;”と呼び、次のように書くことがある。

- X = Y&lt;sup&gt;*&lt;/sup&gt;
- Y = &lt;sup&gt;*&lt;/sup&gt;X

&lt;em&gt;大変不幸なこと&lt;/em&gt;に、この記法では、星の位置が用語法と左右逆になる。（池袋東口に西部、西口に東部みたいなもんか。）また、「双対」の代わりに「随伴」（adjoint）と呼ぶこともある（さらに&lt;em&gt;不幸&lt;/em&gt;）。それに、ε、δの取り方が一意でないので、右双対、左双対も一意対応ではない。言えることは：

- ε、X、Yに対して、δが存在すれば一意的に決まる。
- δ、X、Yに対して、εが存在すれば一意的に決まる。
- 対象に左双対があれば、どれも同型。
- 対象に右双対があれば、どれも同型。

剛性は次の条件：

- すべての対象に、その左双対も右双対も存在する。

左双対、右双対、ε、δなどを識別（選択、特定）してしまったほうが話が楽になる。

「左右の双対とモノイド積で随伴性が定義できる」ことは、&lt;strong&gt;フロベニウス相互律&lt;/strong&gt;（Frobenius reciprocity）と呼ぶそうだ。

- C(X×Z, Y)≒C(X, Y×Z&lt;sup&gt;*&lt;/sup&gt;)
- C(X, Z×Y)≒C(Z&lt;sup&gt;*&lt;/sup&gt;×X, Y)
- C(Z×X, Y)≒C(X, &lt;sup&gt;*&lt;/sup&gt;Z×Y)
- C(X, Y×Z)≒C(X×&lt;sup&gt;*&lt;/sup&gt;Z, Y)

山上論説では、f:X→Yに対してε、δを使って作られる射の双対f&lt;sup&gt;*&lt;/sup&gt;:Y&lt;sup&gt;*&lt;/sup&gt;→X&lt;sup&gt;*&lt;/sup&gt;を（左）&lt;strong&gt;転置射&lt;/strong&gt;（transposed morphism）と呼び、f&lt;sup&gt;t&lt;/sup&gt;と書いている。左右を逆にした&lt;strong&gt;右転置&lt;/strong&gt; &lt;sup&gt;t&lt;/sup&gt;f も定義している。ただし、左転置と右転置は、反変関手として自然同値。

用語的には、剛性を表す等式を&lt;strong&gt;三角恒等式&lt;/strong&gt;（triangular identities）と呼ぶこともあるが、これは（厳密でない）モノイド圏の定義で出てくるマックレーン一貫性の等式（五角形恒等式と三角形恒等式；pentagonal/triangular equation）にも出てくる。やっぱり、&lt;strong&gt;ジグザグ恒等式&lt;/strong&gt;と呼ぶのがいいような気がする。

&lt;h4&gt;●テンソル関手とテンソル自然変換&lt;/h4&gt;

念のため、山上さんが採用している&lt;strong&gt;テンソル圏&lt;/strong&gt;の定義を再掲：

+ Cは、k-線形（線型）圏である。
+ 双関手 ※:C×C→C がある。これもk-線形である。別な言い方をすると、k-ベクトル空間とテンソル積のモノイダル圏により豊饒化されている。(C×C)[(X, Y), (U, V)] = C(X, U)(×)C(Y, V)。
+ 特別な対象I∈|C|がある。
+ 自然同型 α&lt;sub&gt;X,Y,Z&lt;/sub&gt;:(X※Y)※Z → X※(Y※Z)がある。
+ 自然同型 λ&lt;sub&gt;X&lt;/sub&gt;:I※X→X がある。
+ 自然同型 ρ&lt;sub&gt;X&lt;/sub&gt;:X※I→X がある。

α、λ、ρは、マックレーンの一貫性（五角形、三角形等式）を満たす。

CとDがテンソル圏のとき、F:C→Dが&lt;strong&gt;テンソル関手&lt;/strong&gt;であるとは、homsetごとにk-線形写像を誘導する、という意味でk-線形。さらに、Fに付随する自然同型ν=ν&lt;sup&gt;F&lt;/sup&gt;、δ=δ&lt;sup&gt;F&lt;/sup&gt;がある； ν&lt;sup&gt;X,Y&lt;/sup&gt;:F(X※Y)→F(X)※F(Y)、δ:F(I)→I。ν、δはしかるべき可換図式を満たす。

αは結合性、λは左単位性、ρは右単位性、νはFの分配性（和or積の保存性）、δはFの単位保存性を表す自然変換。なお、アーベル圏により線形性が定義されるときは、公理的テンソル積※は双完全（biexact）を要求する。

テンソル関手FとGのあいだのテンソル積を保存する自然変換（&lt;strong&gt;テンソル自然変換&lt;/strong&gt;と呼んでいいだろう）とは、自然変換φ::F⇒G:C→Dであって、次を可換にするもの。
&lt;pre&gt;
 F(X※Y) -[ν&lt;sub&gt;X,Y&lt;/sub&gt;]→F(X)※F(Y)
　|　　　　　　　　　|
φ&lt;sub&gt;X※Y&lt;/sub&gt;　　　　　φ&lt;sub&gt;X&lt;/sub&gt;※φ&lt;sub&gt;Y&lt;/sub&gt;
　↓　　　　　　　　　↓
 G(X※Y) -[ν&lt;sub&gt;X,Y&lt;/sub&gt;]→G(X)※F(Y)

 F(I) -[δ]→ I
　|
φ&lt;sub&gt;I&lt;/sub&gt;
　↓
 G(I) -[δ]→ I
&lt;/pre&gt;

&lt;h4&gt;●単純性とグロタンディーク環&lt;/h4&gt;

k-テンソル圏（k-線形なテンソル圏）の対象Xが&lt;strong&gt;単純&lt;/strong&gt;とは、End(X)≒k であること。単純対象の全体をSimp⊆|C|とする。

テンソル圏Cが&lt;strong&gt;半単純&lt;/strong&gt;とは、

+ Iは単純。
+ すべての対象は、単純対象の有限直和と同型。

Cが半単純のとき、S = Simp/iso （単純対象の同値類）とする。Sは集合だとして、Sの形式的非負整数係数線形結合の全体を半加法群とみなして、さらに積・を次のようにして導入する。

- x・y = Σ&lt;sub&gt;z∈S&lt;/sub&gt;(N&lt;sup&gt;z&lt;/sup&gt;&lt;sub&gt;x,y&lt;/sub&gt;)
- N&lt;sup&gt;z&lt;/sup&gt;&lt;sub&gt;x,y&lt;/sub&gt; = dim C(Z, X※Y) = dim C(X※Y, Z)

これがテンソル圏Cのグロタンディーク（Grothendieck）環（実際には半環）。

*1170321053*[圏一般論]V-豊饒テンソル圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170319368&quot;&gt;テンソル圏&lt;/a&gt;の定義を見てると、少し一般化してみたくなる。

Vを必ずしも対称ではないモノイド圏として、そのモノイド積を○とする。CがVで豊饒化（enrich）されているとする。事例としては、Vが可換（アーベル）モノイドの圏で、○が可換モノイドの具体的テンソル積。V-豊饒(enriched）圏Cに対して、V-豊饒圏 C□C を次のように定義する。

- |C□C| = |C|×|C| （×は集合の直積）
- (C□C)[(X, Y), (U, V)] = C(X, U)○C(Y, V)

□は○から決まるので、記号の濫用で C○C と書いてもよい。V-関手 C○C→C を、C上のV-双関手だと定義する。V-双関手※:C○C→C があって、モノイド積を定義する自然同型α、λ、ρを備え、マックレーン一貫性を満たすとき、※を&lt;strong&gt;V-テンソル積（双関手）&lt;/strong&gt;と呼ぶ。

V-テンソル積（α、λ、ρを含める）を持つV-圏Cを、&lt;strong&gt;V-豊饒テンソル圏&lt;/strong&gt;、あるいは単に&lt;strong&gt;V-テンソル圏&lt;/strong&gt;と呼ぶ。

本来のk-線形テンソル圏は、Vをk-ベクトル空間の圏にすれば得られる。アーベル群の圏、環Rに対する(R,R)両側加群の圏、アーベル半群の圏、アーベルモノイドの圏などをVとすることもできる。

V-テンソル圏の単純対象と半単純テンソル圏の定義は、k-線形のときより複雑になると思う。


</body>
</day>
<day date="2007-02-02" title="">
<body>
*1170397559*[リンク]KozenのKleene代数講義テキスト

本編[http://d.hatena.ne.jp/m-hiyama/20050621/1119335604:title]からのコピー。
&gt;&gt;
Dexter Kozenの&quot;Introduction to Kleene Algebra&quot;という、一連の講義テキストが入手可能。

No.1は、http://www.cs.cornell.edu/Courses/cs786/2004sp/Lectures/l01-intro.pdf 。$Mを適当な番号だとして、www.cs.cornell.edu/Courses/cs786/2004sp/Lectures/l$M-*.pdf というネーミングパターン。ただし、*の部分がわからないから、googleで &quot;Introduction to Kleene Algebra&quot; &quot;lecture $N&quot; として探すほうがいいかも。$Nのところがプレイスホルダーで、1, 2, ...と入れる。現在、$N=1から15、17, 19とあるようだ。なぜか、$Mと$Nは一致しないから注意。
&lt;&lt;

もう見つからなかった(泣く)。

が、http://www.cs.cornell.edu/courses/cs786/2002sp/Lectures/lectures.htm というページから2002年版の講義資料(PDFではなくてPSだが）をたどれることが判明。急いで、全部ダウンロードした。
&lt;pre&gt;
2002sp_l1.ps
2002sp_l2.ps
2002sp_l3.ps
2002sp_l4.ps
2002sp_l5.ps
2002sp_l6.ps
2002sp_l7.ps
2002sp_l8.ps
2002sp_l9.ps
2002sp_l10.ps
2002sp_l11.ps
2002sp_l15.ps
2002sp_l16.ps
2002sp_l19.ps
2002sp_l20.ps
2002sp_l21.ps
2002sp_l22.ps
2002sp_l23.ps
2002sp_l24.ps
2002sp_l25.ps
2002sp_l26.ps
2002sp_l27.ps
&lt;/pre&gt;
欠番があるのは元々資料がなかった。

それと、http://www.cs.cornell.edu/Courses/cs786/2004sp/Homework/h1.pdf などは残っていた、2004sp/Homework/*.pdfをKozen_*.pdfにリネームして保存。
&lt;pre&gt;
Kozen_h1.pdf
Kozen_h1s.pdf
Kozen_h2.pdf
Kozen_h2s.pdf
Kozen_h3.pdf
Kozen_h3s.pdf
Kozen_h4.pdf
Kozen_h4s.pdf
&lt;/pre&gt;
sが付いているのは解答（一部）。

それと、コゥゼン先生お勧めの John Horton Conway, &quot;Regular Algebra and Finite Machines&quot; はもう品切れ（or 絶版）です(泣く)。

*1170405334*[圏一般論][用語法]テンソル圏に関する補足

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170319368&quot;&gt;昨日&lt;/a&gt;、「モノイド圏をテンソル圏と呼ぶのはよくない」と言ったが、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170321053&quot;&gt;V-豊饒の場合&lt;/a&gt;を考えると、結局モノイド圏とテンソル圏の区別はなくなってしまう。なんだよ、やっぱり同意語か？

それと、堅い対称テンソル圏の&lt;strong&gt;共役&lt;/strong&gt;（conjugate）の定義を引き写しておく； Xの左双対をX&lt;sup&gt;*&lt;/sup&gt;としして、右ベントε:X&lt;sup&gt;*&lt;/sup&gt;×X→I, 左ベントδ:I→X×X&lt;sup&gt;*&lt;/sup&gt; が、δ&lt;sup&gt;*&lt;/sup&gt; = σ&lt;sub&gt;X,X*&lt;/sub&gt;;ε （σは対称）であるとき、左双対X&lt;sup&gt;*&lt;/sup&gt;は&lt;strong&gt;（左）共役&lt;/strong&gt;であると呼ぶ。共役は複素共役に関係していることが多いようだ。

*1170405964*[圏一般論][課題]双デカルト圏に関する補足

同一の台（対象）の上に代数（モノイド）と余代数（余モノイド）構造があり、余乗法（対角、余積、余和）Δ:A→A×Aが代数の準同型（モノイド射）になっているとき&lt;strong&gt;双代数&lt;/strong&gt;（圏論的により適切な呼び名は&lt;strong&gt;双モノイド&lt;/strong&gt;）と呼び、余乗法が代数準同型であることを&lt;strong&gt;双代数条件&lt;/strong&gt;（bialgebra condition）と呼ぶことにする。

双代数条件は、双対的に、乗法（和）が余代数の準同型（余モノイド射）であることでもある。そしておそらく、次の&lt;strong&gt;行列条件&lt;/strong&gt;（matrix/matricial condition）とも同値だろう。

- &lt;[a, b], [c, d]&gt; = [&lt;a, c&gt;, &lt;b, d&gt;]

さらに別な、しかし同値（と思われる）条件として、双積（biproduct）の&lt;strong&gt;直交条件（直交関係式）&lt;/strong&gt;がある。以下に述べる。

始対象でもあり終対象でもある対象を&lt;strong&gt;零対象&lt;/strong&gt;と呼ぶ。零対象を持ち、1つの零対象が特定されているとき、&lt;strong&gt;零付き圏&lt;/strong&gt;（category with zero）または&lt;strong&gt;点付き圏&lt;/strong&gt;（pointed category）と呼ぶ。

Cが零付き圏で、X, Y∈|C|に対して、(X, Y; Z, ι&lt;sup&gt;1&lt;/sup&gt;:X→Z, ι&lt;sup&gt;2&lt;/sup&gt;:Y→Z, π&lt;sup&gt;1&lt;/sup&gt;:Z→X, π&lt;sup&gt;2&lt;/sup&gt;:Z→Y)が、(X, Y; Z, ι&lt;sup&gt;1&lt;/sup&gt;:X→Z, ι&lt;sup&gt;2&lt;/sup&gt;:Y→Z)が直和系、(X, Y; Z, π&lt;sup&gt;1&lt;/sup&gt;:Z→X, π&lt;sup&gt;2&lt;/sup&gt;:Z→Y)が直積系になっていて、さらに：

- ι&lt;sup&gt;i&lt;/sup&gt;;π&lt;sup&gt;j&lt;/sup&gt; = δ&lt;sub&gt;ij&lt;/sub&gt; （クロネッカー・デルタ）

を満たすとき、&lt;strong&gt;双積系&lt;/strong&gt;と呼ぶ。Zは、XとYの（この順の）双積対象である。δ&lt;sub&gt;ij&lt;/sub&gt;の解釈には零射と恒等射を使う。

任意の対象X, Y∈|C|に対して、対象X+Yが一意的に対応していて、(X, Y; X+Y, ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;X,Y&lt;/sub&gt;, ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;X,Y&lt;/sub&gt;, π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;X,Y&lt;/sub&gt;, π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;X,Y&lt;/sub&gt;)が双積系になるようなιとπが備わっているとき、(C, 0, ι, π)を&lt;strong&gt;双積付き圏&lt;/strong&gt;と呼ぶ。

さて、双デカルト圏を特徴付ける条件は：

+ 等式的デカルト性／余デカルト性で定義が与えられているときは、&lt;em&gt;双代数条件&lt;/em&gt;
+ ランベック／スコット流のペアリング&amp;lt;-, -&gt;と余ペアリング[-, -]で定義が与えられているときは、&lt;em&gt;行列条件&lt;/em&gt;
+ 双積付き（零はもちろん付いている）圏として定義が与えられているときは、&lt;em&gt;直交条件&lt;/em&gt;

さらに別な条件として、Cが可換モノイドで豊饒化されているとして、その&lt;strong&gt;行列圏&lt;/strong&gt;Mat(C)を次のように定義できる。

- |Mat(C)| = |C|&lt;sup&gt;*&lt;/sup&gt; （Cの対象列が対象）
- Mat(C)[(A&lt;sub&gt;i&lt;/sub&gt;), (B&lt;sub&gt;j&lt;/sub&gt;)] = {(A&lt;sub&gt;i&lt;/sub&gt;)→(B&lt;sub&gt;j&lt;/sub&gt;)の形の形式的行列}

形式的行列は、成分f&lt;sub&gt;i→j&lt;/sub&gt;:A&lt;sub&gt;i&lt;/sub&gt;→B&lt;sub&gt;j&lt;/sub&gt; で決まる方陣図形である。行列の和と積（結合）は（豊饒化による）可換モノイド構造から定義可能。

Mat(C)からCへの解釈関手は一般には定義できない。Cが可換モノイド豊饒なモノイド圏(C, +, 0)で、Mat(C)→Cで次の条件を満たす関手Mが存在するとする。

+ 対象に関しては、M[()] = 0, M[(A)] = A, M[(A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;)] = A&lt;sub&gt;1&lt;/sub&gt; +  ... + A&lt;sub&gt;n&lt;/sub&gt;
+ Mは和を保存する（加法的）。
+ Mは充満忠実関手。

このとき、モノイド積+は双積で、モノイド単位0は零であろう。Mに関する条件はもっと&lt;em&gt;ゆるく&lt;/em&gt;できるかもしれない。

これが成立すれば、

- 双デカルト圏は、行列でうまく表現できる。
- 行列でうまく表現できる圏は、双デカルトである。

これで、&lt;strong&gt;圏の行列論&lt;/strong&gt;の第一歩にはなる。

でも、&lt;em&gt;以上のことは未確認、確認してね。&lt;/em&gt;

</body>
</day>
<day date="2007-02-05" title="">
<body>
*1170635104*[雑感][TQFT]なんでもCGFT

アミダ図やブレイド図に対して置換群（対称群）やブレイド群の元を対応させるのも、TQFTつうかCGFT（Categorical General Field Theories）とも言えるな。構文図にクリーネ代数の行列を対応させるのもCGFTだし。

シェープとか台と呼べる図形があり、図形のコボルディズム構造（グルーイングと直和）があって、図形に対して代数的な対象物を対応させる関手があれば、それが振る舞い関手／（物理的には）状態関手であり、関手の値が図形のトポロジーだけで決まればTQFT、図形上の“場”によって決まるならCGFTってこと。

振る舞いから図形や場を構成する逆問題が実現（realizetion）、あるいは構成の問題。なんらかの意味で極小な実現を構成するのがマイヒル／ネロード問題。


</body>
</day>
<day date="2007-02-07" title="">
<body>
*1170806281*[形式言語理論]二項クリーネ・スター

二項演算としてのクリーネ・スターを調べている。以下a*bは、(a&lt;sup&gt;*&lt;/sup&gt;)・bのことでは&lt;em&gt;なくて&lt;/em&gt;、aとbに二項演算*を施した結果。感じとしては、不定の述語pに対して、while(p){a};b のこと。

不動点帰納法による定式化は次のようだろう。

+ b + a(a*b) = a*b （または b + a(a*b) ≦ a*b）
+ b + ay ≦ y ⇒ y≦a*b

CWIのワン・フォッキンク（Wan Fokkink）が等式的な公理化を2種類提案していて、簡単なほうは、

+ a(a*b) + b = a*b
+ a*(a*b) = a*b

もうひとつは：

+ x(x*y) + y = x*y
+ (x*y)z = x*(yz)
+ x*(y（(x+y)*z） + z) = (x+y)*z

下の複雑な公理系から a*(a*b) = a*b を導くには：
&lt;pre&gt;
   a*b
 ↓ ベキ等性より a = a + a
 = (a + a)*b
 ↓ 公理3で展開
 = a*[a（(a+a)*b） + b]
 ↓ ベキ等性より a + a = a
 = a*[a(a*b) + b]
 ↓ 公理1
 = a*[a*b]
&lt;/pre&gt;

*1170825893*[形式言語理論][XML]ツリーの二項クリーネ・スターもどき

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070207/1170806281&quot;&gt;二項クリーネ・スター&lt;/a&gt;を調べている理由：

クリーネ代数Kとジョイン半束（ベキ等可換モノイド）Aがあって、Aによる片側作用(-)^(-):A×K→Kが、次を満たすとする。

+ (a + b)^x = a^x + b^x
+ 0^x = 0, a^0 = 0

ただし、a^(x + y) = a^x + a^y は&lt;em&gt;全然成り立たない&lt;/em&gt;。

で、二項クリーネ・スター☆:A×K→Kは次を満たすとする。

- a^(s + a☆s) = a☆s
- a^(s + y) ≦ y ⇒ y≦a☆s

この状況で、Aを固定してA作用を持つクリーネ代数の圏を考える。直積や行列構成を考えることもできるし、後からAを動かすこともできるだろう。この圏はあまり調べてないのだが、ヘッジ言語の代数的定式化の1つになる。

*1170826403*[XML][雑感]多少は進化したかもしれない

XMLの形式言語理論は、トレース付きデカルト圏でやればいいのだ、と今では確信している。一時期（2001年くらいかな？）半年くらいも、Tr(f)とTr(g)の結合Tr(f);Tr(g)の明示公式（具体的な計算方法）が見つからなくて悩んでいたが、次で解決されている。

- http://www.chimaira.org/docs/CompositionInTMC.htm
- http://www.chimaira.org/docs/TraceAndProductComposition.htm

構文的モジュールは、その定義射f:A+X→B+XのトレースTr&lt;sup&gt;X&lt;/sup&gt;(f):A→Bとして書ける。モジュールのモノイド積（テンソル積）と結合は次で与えられる。

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;(f)+Tr&lt;sup&gt;Y&lt;/sup&gt;&lt;sub&gt;C,D&lt;/sub&gt;(g) ≒ Tr&lt;sup&gt;X+Y&lt;/sup&gt;&lt;sub&gt;A+C,B+D&lt;/sub&gt;[(A+σ&lt;sub&gt;C,X&lt;/sub&gt;+Y);(f+g);(B+σ&lt;sub&gt;X,D&lt;/sub&gt;+Y)] 
- (Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;(f));(Tr&lt;sup&gt;Y&lt;/sup&gt;&lt;sub&gt;B,C&lt;/sub&gt;(g)) ≒ Tr&lt;sup&gt;B+X+Y&lt;/sup&gt;&lt;sub&gt;A,C&lt;/sub&gt;[(A+σ&lt;sub&gt;B,X&lt;/sub&gt;+Y);(f+g);(σ&lt;sub&gt;B+X,C&lt;/sub&gt;+Y)] 

圏が、厳密モノイダルであり可換（対称性も厳密）なら；

- (Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;(f));(Tr&lt;sup&gt;Y&lt;/sup&gt;&lt;sub&gt;B,C&lt;/sub&gt;(g)) = Tr&lt;sup&gt;B+X+Y&lt;/sup&gt;&lt;sub&gt;A,C&lt;/sub&gt;[(A+B+X+Y);f+g;(C+B+X+Y)] 

簡略に書けば Tr&lt;sup&gt;X&lt;/sup&gt;(f);Tr&lt;sup&gt;Y&lt;/sup&gt;(g) = Tr&lt;sup&gt;B+X+Y&lt;/sup&gt;(f+g)。

ただし実際には、可換厳密モノイド圏というよりは、可換厳密部分モノイド圏で考えていた -- 直交性（無共分性）X⊥Yがあり、X⊥Yのときに限ってX+Yが定義できる。

必要なら、トレースの代わりにConway不動点作用素＝μ記法を使って公式を書き下すこともできる。

※ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060626/1151280740&quot;&gt;「XMLに戻ろう」&lt;/a&gt;も参照。

*1170827276*[XML][形式言語理論]一般形式言語理論のアンビアント・モデル圏

リボン言語やツリー言語（ひょっとしてグラフ言語も）含むような一般的な形式言語理論を展開するためのアンビアント（あるいはユニバーサルな）モデル圏は何だろう？ と探していたが、余対角を持つ（あるいは余GS）デカルト圏（cartesian category with codiagonals / co-GS cartesian category）がいいような気がする。実際にはさらに、“余対角＝加法”にベキ等性を要求し、射は、&lt;em&gt;加法や零を保存する必要がない&lt;/em&gt;、とする。実際の例ではデカルト閉になるが、デカルト閉性はそれほど使わない。もちろん、トレースも要求する。

上の条件を満たす具象的な圏としては、ω完備な順序集合（ω-complete partial order; ωCPO）がいいと思う。ここで、ω完備とは次の意味：

- Aが順序集合（PO set）、Xが基数≦ωであるAの部分集合のとき、Xには上限が存在する。

この定義なら、

+ ∨{} = 最小限
+ V{a, b} = a∨b
+ ∨{a, b, c} = a∨b∨c

のように、最小元と有限ジョインの存在が自動的に保証される。ちなみに、ω完備の意味が

- a&lt;sub&gt;0&lt;/sub&gt;≦a&lt;sub&gt;1&lt;/sub&gt;≦ ... ≦a&lt;sub&gt;n&lt;/sub&gt;≦ ... が無限列のとき、上限（極限）が存在する。

のときは、別に最小元と有限ジョインの存在を要求する。このときは、ωCPPOJ（ω-complete pointed partial order with joins）とでも呼ぶべき。だが、めんどくさいからωCPOはpointedかつwith joinsだとする。

射は単調でω連続（連続性から単調は出るから、実質は順序的な連続写像）。最小不動点が存在してコンウェイ作用素（conway operator）が作れる。よって、カザネスク／ステファネスク／ハイランド／長谷川の定理から、ωCPO（定義によってはωCPPOJ）はトレース付きデカルト圏。

項がωCPO（より一般には、トレース付きベキ等余対角付きデカルト圏）で意味付けできるようなセオリー（構文的セオリーと意味関手の組）が“形式的な形式言語理論”（CFLT; categorical formal language theory）。特定のアンビアント・モデル圏Aを固定して、A上のCFLTを対象として、CFLTの変換（または翻訳）を射とする圏ができる。Aを動かせば、indexed categoryになりそうだ。

ところで、トレース付きベキ等余対角付きデカルト圏はコゥゼン圏（Kozen圏）にかなり近い。概コゥゼン圏（almost Kozen category）がいいかな？

*1170829887*[圏一般論][TQFT]モノイド圏のシードセット

(C, +, 0)が対称モノイド圏だとする。S⊆|C|が次の性質を持つとき&lt;strong&gt;モノイド的に独立&lt;/strong&gt;（monoidally independent）と呼ぶ。

+ 0はSに含まれない。
+ s, t1, ..., tn∈S、s≒t1+ ... + tn という関係が存在しない。

Sがモノイド的に独立なら、どの2つの元（対象）も同型ではなく、Sの元から和（モノイド積）を作っても、Sの元と同型なものは作れない。

A∈|C|を任意の集合だとする。X∈|C|がAの元の有限直和と同型なら、XはAから&lt;strong&gt;収穫される&lt;/strong&gt;（harvested）と呼ぶ。Aから収穫される対象全体から誘導されるCの部分圏をAの&lt;strong&gt;収穫部分圏&lt;/strong&gt;（harvested subcategory）と呼びHarv(A, C)と書く。

S∈|C|が、実際に集合であり、モノイド的に独立、かつHarv(S, C)=C であるとき、SをCの&lt;strong&gt;シードセット&lt;/strong&gt;（seed set）と呼ぶ。シードセットの存在、シードセットが単元、有限集合、可算集合などの条件は、圏の半単純性の代わりに使えるだろう。

</body>
</day>
<day date="2007-02-08" title="">
<body>
*1170893104*[リンク][多圏]多圏に関する最近の文献

- &quot;Polycategories via pseudo-distributive laws&quot; by Richard Garner （http://arxiv.org/abs/math.CT/0606735）44ページ
-  &quot;MORPHISMS AND MODULES FOR POLY-BICATEGORIES&quot; J.R.B. COCKETT, J. KOSLOWSKI, AND R.A.G. SEELY （http://www.emis.ams.org/journals/TAC/volumes/11/2/11-02.pdf）61ページ

*1170893105*[用語法][圏一般論]まだテンソル圏にこだわる

Vがモノイド圏だとして、V-圏（豊饒化）がV-モノイド積構造を持てば「V-モノイド圏」と呼ぶのは自然。Vがk-ベクトル空間のときが（とりあえずは）テンソル圏だが、アーベル（可換）モノイドの圏AbMonをVとして採用したAbMon-モノイド圏も面白いと思う。

AbMonは、半環&lt;b&gt;N&lt;/b&gt;上の半加群という事実を考えると：

- 一般的なモノイド圏Vに対しては、&lt;strong&gt;V-モノイド圏&lt;/strong&gt;
- Vが&lt;b&gt;Set&lt;/b&gt;であるときは、単に&lt;strong&gt;モノイド圏&lt;/strong&gt;
- Vが環上の加群（または双加群）圏＋具体的テンソル積であるときは、&lt;strong&gt;テンソル圏&lt;/strong&gt;（係数環をRとすれば、R-テンソル圏）
- Vが半環上の半加群（または両側半加群）圏＋具体的テンソル積であるときは、&lt;strong&gt;半テンソル圏&lt;/strong&gt;（係数半環をKとすれば、K-半テンソル圏）

とかにしよう、&lt;em&gt;個人的には&lt;/em&gt;。

*1170909875*[圏一般論][形式言語理論]AbMon-圏からの行列圏構成

AbMonをアーベル（可換）モノイドの圏として、演算は(+, 0)で表記する。AbMonに具体的テンソル積を入れて、双半線形写像をテンソル積からの半線形写像とみなす。AbMonで豊饒化された圏は&lt;strong&gt;AbMon-圏&lt;/strong&gt;と呼ぶ。

「[http://d.hatena.ne.jp/m-hiyama-memo/20070202/1170405964:title]」で述べたようにして、AbMon-圏Cの行列圏Mat(C)を定義できる。さらに：

- Mat(C)は双積を持ち、したがって双デカルト圏である。

これから、Mat(-)は、AbMon-Cat → BicartCat という関手を定義する。Matは一種の自由生成関手で、忘却関手と随伴になる。したがって、MatはAbMon-Cat上のモナドになる。Mat(Mat(C))は、レベル1の入れ子列とブロック行列の圏であり、モナド乗法は入れ子のフラット化である。

Mat構成の特別な例を挙げる。Kを半環として、Kを単一対象上のAbMon-圏とみなす。こうして出来上がった圏をK&lt;sup&gt;(AbMon-cat)&lt;/sup&gt;とする。K&lt;sup&gt;(AbMon-cat)&lt;/sup&gt;のただ1つの対象を1とすると、Mat(K&lt;sup&gt;(AbMon-cat)&lt;/sup&gt;)の対象は1の有限列で、その長さである整数と同一視できる。したがって、K係数の普通の行列全体をMat[K]とすると、Mat(K&lt;sup&gt;(AbMon-cat)&lt;/sup&gt;)とMat[K]は同型である。

このことから、AbMon-圏は半環の一般化であり、行列圏構成は半環の行列の一般化であることがわかる。

*1170909876*[圏一般論][形式言語理論]行列圏構成とカテグラフ

CがAbMon-圏であるとき、双デカルト圏Mat(C)を構成できるのだが、Mat(C)は、有限点集合と完全二部グラフからなるコボルディズム圏上で定義されてたC-カテグラフの圏とみなせる。よって、より一般のC-カテグラフ圏を問題にする。

Gが有向グラフで、頂点集合I, Fと埋め込みi:I→|G|, f:F→|G|があるとき、(G, i, f)を境界付きグラフと呼ぶ。I=δ&lt;sub&gt;0&lt;/sub&gt;(G)=G&lt;sub&gt;0&lt;/sub&gt;, F=δ&lt;sub&gt;1&lt;/sub&gt;(G)=G&lt;sub&gt;1&lt;/sub&gt;のようにも書く。Gの頂点にCの対象を、Gの辺にCの射を対応させたものを（G上の）&lt;strong&gt;C-カテグラフ&lt;/strong&gt;と呼ぶ。これは、半環係数の行列の拡張概念である。

有向グラフによる(0+1)コボルディズム圏（直和でモノイド圏になる）Sを考える。Sの0次元対象I（点の離散集合）に|C|の元を割り当てたものを対象として、Sの射であるコボルディズム・グラフ上のカテグラフを射とする圏を、&lt;strong&gt;S上のC-カテグラフの圏&lt;/strong&gt;と呼ぶ。カテグラフ圏の対象や射に、圏Sの対象や射を一意的に対応させることができる。これをShape(X), Shape(f)などで表し、&lt;strong&gt;シェープ&lt;/strong&gt;と呼ぶ。Shapeは関手となる。カテグラフの圏Dに対して、SはDの&lt;strong&gt;シェープ圏&lt;/strong&gt;とも呼ぶ。

シェープ圏である(0+1)コボルディズム圏Sの0次元対象の全体は点集合の族となる。これをS&lt;sub&gt;0&lt;/sub&gt;とする（|S|のことだけど）。S&lt;sub&gt;0&lt;/sub&gt;を添字集合とするC係数行列の圏をMat(C; S&lt;sub&gt;0&lt;/sub&gt;)とする。特に、S&lt;sub&gt;0&lt;/sub&gt;が&lt;b&gt;N&lt;/b&gt;と同一視できるときは、Mat(C; S&lt;sub&gt;0&lt;/sub&gt;) = Mat(C)。

&lt;hr&gt;

形式言語理論に使うためには、係数圏CがAbMon-圏では不足で、ω総和可能なアーベルモノイドAbMon&lt;sup&gt;ω&lt;/sup&gt;で豊饒化する。CがAbMon&lt;sup&gt;ω&lt;/sup&gt;-圏だとする。Sは(0+1)コボルディズム圏だとして、DがS上のC-カテグラフの圏であるとき、振る舞い関手B:D→Mat(C; S&lt;sub&gt;0&lt;/sub&gt;)を定義したい。

Bはクリーネ／ファインマン総和を使って具体的に構成できる。この振る舞い関手Bのセクションとなる埋め込みJ:Mat(C; S&lt;sub&gt;0&lt;/sub&gt;)→D は自明に存在する。しかし、これだけでは、マイヒル／ネロード関手にはならない。双模倣、マルコフ移動、行列の変形に対応する高次射が必要だ。

*1170917577*[XML][課題][雑感]圏論的形式言語理論の問題

+ アーキテクチャルフォームやデザインパターンはどのように定式化できるか。
+ フォームやらパターンやら（パターンフォームと呼ぶのがいいかも）の“意味”を米田埋め込みで解釈せよ。
+ フォームやらパターンやらの“意味”をテンプレートで解釈せよ。
+ なぜ、バリデータはノーマライザに見えるのか。
+ インスタンス、インスタンスの集合（ほんとの集合）とは何なのか。
+ 異なるスキーマ言語を併用するにはどうしたらよいか
+ 役割／守備範囲の異なるスキーマ言語を組み合わせるにはどうしたらよいか。
+ スキーマモジュール＝スキーマ項＝射 をハッキリと定義せよ。
+ テンプレートモナドのようなモナドはなぜ出現するのか？
+ 構文に対する項圏（term category, category of terms）とセオリーTのリンデンバウム圏Lind(T)をちゃんと定義せよ。|- 's=t' のときに s≡t と定義した同値関係≡が、圏論的合同である必要がある。
+ 構文がグラフであるときは、項圏はグラフの圏（コボルディズム圏）であるし、リンデンバウム圏は、グラフ書き換え系を使ったグラフ同値類であり、アイソトピーなどの幾何学的な概念のアルゴリズム的実現になるだろう -- と、そんなことをハッキリとせよ。

結局、&lt;strong&gt;項＝抽象図形＝具象図形の同値類&lt;/strong&gt;だな。ここで図形 -- シェマと呼ぶのがいいかもしれないが -- は、トポロジカルな図形（台空間）にラベルとか値が乗ったもので、物理的には“場”と言ってもいいだろう。台空間のほうは、&lt;strong&gt;項のシェープ&lt;/strong&gt;って概念だ。物理的には、シェープ＝配位空間だろう。

回路素子も結局は項と同じ概念だ。記号回路素子がテンプレートだが、これはモナドになる。回路圏に、記号集合（ラベル）の圏上のモナドとしての記号回路を付加して拡張できる。この拡張は多次元拡張ではないか？


</body>
</day>
<day date="2007-02-09" title="">
<body>
*1170999925*[圏一般論]忘却関手、具象圏、構成関手

相対的な具象圏（relatively concrete category）を考える必要がある。CがBに対して具象的って概念ね。これは、忘却関手U:C→Bがあればいい。が、忘却関手ってナニ？

まず、なんかのセオリー（形式理論）Baseを考える。Baseを満たす集合論的構造をBaseのモデルとして、モデルの全体を考える。準同型の概念をBaseから、またはBaseに追加する形で定義して、圏Bを作る。Bの対象は台集合（underlying set）を持つ構造だとする。このようなBは十分具象的だと思える。

Baseに何かを追加したセオリーMyTheory=Base+Somethingを考え、MyTheoryのモデルと準同型からなる圏をCとする。Cのモデルは同じ台集合上のBのモデルと解釈できるし、準同型も集合間の写像としては同じものを対応させることができる。こうして&lt;strong&gt;忘却関手&lt;/strong&gt;が定義できる。

忘却関手は忠実関手だが、対象類上で単射とは限らない。モノイド(&lt;b&gt;N&lt;/b&gt;, +, 0)と(&lt;b&gt;N&lt;/b&gt;, ×, 1)は、構造を忘却すると&lt;b&gt;N&lt;/b&gt;になる。空集合に点付き空間の構造が入るわけはないし、有限集合は標数0の体にならないし、可算集合に実ベクトル空間の構造も入らない。よって、忘却関手が対象類で全射とも限らない。

C、Bが対象の台集合を持つ圏であり、U:C→Bが忘却関手であるとき、Cは（忘却関手Uを前提に）&lt;strong&gt;Bに対して具象的&lt;/strong&gt;、&lt;strong&gt;B上の具象圏&lt;/strong&gt;などと呼ぶ。C、Bは&lt;b&gt;Set&lt;/b&gt;への忘却関手（標準忘却関手）を持ち、関手の可換三角形が成立する。CがB上の具象圏、BがA上の具象圏なら、CはA上の具象圏にもなる（忘却関手の結合）。

U:C→Bが忘却関手のとき、G:B→Cを&lt;strong&gt;構成関手&lt;/strong&gt;（construction functor）と呼ぶ。G;U = Id&lt;sub&gt;B&lt;/sub&gt;ならUの全射性が示せる。UとGが随伴対なら、Gは&lt;strong&gt;自由構成関手&lt;/strong&gt;（自由生成関手）となる。自由構成関手はときに&lt;strong&gt;完備化関手&lt;/strong&gt;（completion functor）とも呼ばれる。

*1171000917*[圏一般論][課題][インスティチューション]一般忘却関手

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070209/1170999925&quot;&gt;あっと忘れた、忘却関手概念をもう少し広くしておかないとダメだ。&lt;/a&gt;JSLat（ジョイン半束）とAbMon（アーベルモノイド）のように、セオリーが事実上同じってことがあるので、セオリー間の射（翻訳）を定義しないとダメだわ。インスティチューションを使わないとうまく定義できない。

後で考えて書く。

</body>
</day>
<day date="2007-02-10" title="">
<body>
*1171078373*[圏一般論][課題][インスティチューション]一般忘却関手 続き

[http://d.hatena.ne.jp/m-hiyama-memo/20070209/1170999925:title]、[http://d.hatena.ne.jp/m-hiyama-memo/20070209/1171000917:title] の続き。

普遍的な忘却先(?)として&lt;b&gt;Set&lt;/b&gt;を考える（これも相対化できるが、キリがないから止める）。圏BとCは、標準的（canonical）な忘却関手U&lt;sub&gt;B&lt;/sub&gt;:B→&lt;b&gt;Set&lt;/b&gt;、U&lt;sub&gt;C&lt;/sub&gt;:C→&lt;b&gt;Set&lt;/b&gt;を持つ。この段階では、忘却関手の定義はなくて、単に、U&lt;sub&gt;B&lt;/sub&gt;、U&lt;sub&gt;C&lt;/sub&gt;が&lt;em&gt;天下り&lt;/em&gt;に与えられているだけ。ただし、これらは忠実関手（それ以上の条件は仮定しない）。

さて、さらにBとC上には、充足構造が与えられているとする。これは本質的にはインスティチューション構造のこと。以下に充足構造を説明するが、Bが“（部分）順序集合の圏”&lt;b&gt;PO&lt;/b&gt;、Cが“ベキ等半環の圏”&lt;b&gt;ISR&lt;/b&gt;だとして読むとよい。

Σ、Γが指標（記号の集合）だとして、等号を前もって備えた一階述語論理に指標を加えて論理式を作り、閉じた論理式全体をSen(Σ)などとする。Σ上の&lt;strong&gt;セオリー&lt;/strong&gt;とは、Sen(Σ)の演繹で閉じた部分集合のことである。SがΣ上のセオリー（例：ISRの等式的セオリー）、TがΓ上のセオリー（例：POのホーン式のセオリー）だとする。

圏C上の&lt;strong&gt;充足構造&lt;/strong&gt;とは、|C|とSen(Σ)の関係|=のこと。A |= ψは、対象Aが文（命題）ψを満たす（充足する）と読む。Sが任意の文の集合のとき、A |= S は、∀ψ∈S.[A |= ψ]の略記だとする。圏Cの任意の対象Aが、A |= S なとき、圏CはSを満たすという。Sがセオリーなら、圏CはセオリーSを満たす圏、あるいは単に&lt;strong&gt;セオリーSの圏&lt;/strong&gt;などと呼ぶ。セオリーと圏を関係付けるためには、充足構造が必須である。

(C, Σ, |=)、(B, Γ, |=)が充足構造のとき、写像t:Sen(Γ)→Sen(Σ)と関手R:C→Bの組が次を満たすとき、充足構造のあいだの射（準同型）と定義する。

- X |= t(ψ) ⇔ R(X) |= ψ

tを&lt;strong&gt;翻訳写像&lt;/strong&gt;、Rを&lt;strong&gt;還元（reduct）関手&lt;/strong&gt;と呼ぶ。（ここらへんは、そっくりインスティチューションの定義だけど、個人的にはなんかイマイチしっくりこない。いずれまた考えよう。）

SがΣ上のセオリーで、CはSの圏になっている、同様にBはセオリーTの圏になっているとする（例：SがISRセオリー、TがPOセオリー）。翻訳t:Sen(Γ)→Sen(Σ）が、t(T)⊆S の性質を持つとする。ψ∈T を |-&lt;sub&gt;T&lt;/sub&gt;ψ と書けば：

- |-&lt;sub&gt;T&lt;/sub&gt;ψ ⇒ |-&lt;sub&gt;S&lt;/sub&gt;t(ψ) 

のこと。例えば、|-&lt;sub&gt;PO&lt;/sub&gt;ψ ⇒ |-&lt;sub&gt;ISR&lt;/sub&gt;t(ψ) のようなこと。このような翻訳は、セオリーTからセオリーSへの翻訳と呼ぶ。

やっと準備ができた。ΓセオリーT、ΣセオリーS、Tの圏B、Sの圏C、翻訳t:Sen(Γ)→Sen(Σ)、関手U:C→Bがあるとき、Uが&lt;strong&gt;忘却関手&lt;/strong&gt;とは：

+ tはセオリーTからセオリーSへの翻訳である。
+ tとUの組は充足構造の射になっている。X |= t(ψ) ⇔ U(X) |= ψ
+ U;U&lt;sub&gt;B&lt;/sub&gt; = U&lt;sub&gt;C&lt;/sub&gt;

この定義でいちおう、JSLat（ジョイン半束の圏）がIAbMon（ベキ等アーベルモノイド）への忘却関手を持ち、IAbMonがAbMonへの忘却関手を持ち、したがって、JSLatもAbMonに忘却関手を持つことが示せる。C→Bの（相対的）忘却関手を持つなら、CはB上の&lt;strong&gt;具象圏&lt;/strong&gt;と呼ぶ。

以上の議論、使えなくはないが、&lt;em&gt;かなり不満が残る。&lt;/em&gt;後でもう少し整理・一般化しよう。

*1171083963*[TQFT][形式言語理論][用語法][課題]半テンソル圏

なんで、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070210/1171078373&quot;&gt;忘却関手や具象圏の定義&lt;/a&gt;が必要だったかというと、半テンソル圏を定義するため。

まず、V-モノイド圏からはじめる。Vが普通の意味でのモノイド圏だとして、CがVで豊饒化された圏、つまり、V-圏だとして、V-圏としてのテンソル積C×C -- i.e. (C×C)[(A, B), (C, D)] = C(A, C)×C(B, D) in V -- からの双V-関手としてモノイド積（V-モノイド積）が与えられているとき、これを&lt;strong&gt;V-モノイド圏&lt;/strong&gt;と呼ぶ。

モノイド圏VがAb（アーベル群の圏に具体的テンソル積）上の具象圏であり、忘却関手U:V→Abがモノイド積を保存するモノイド関手だとする。このとき、V-モノイド圏を&lt;strong&gt;テンソル圏&lt;/strong&gt;と呼ぶ。Vはテンソル圏の背景（background）圏と呼ぼう。忘却関手V→Abの存在から、テンソル圏は必然的にAb-モノイド圏になる。

モノイド圏VをAbからAbMon（アーベルモノイドの圏に具体的テンソル積）に取り替えて&lt;strong&gt;半テンソル圏&lt;/strong&gt;が定義できる。すべての半テンソル圏CはAbMon-モノイド圏である。V→AbMonから誘導される標準的な忘却関手C=C&lt;sup&gt;(V-cat)&lt;/sup&gt;→C&lt;sup&gt;(AbMon-cat)&lt;/sup&gt;を持つ。

AbMon-モノイド圏Cは当然にAbMon-圏なので行列構成ができてMat(C)を作れる。問題はここからで、AbMon-モノイド圏＝半テンソル圏に対して、Matを拡張して古典テンソル計算を行うこと。Matの拡張を「テンソル」と呼ぶと混乱するので&lt;strong&gt;複行列&lt;/strong&gt;（multimatrix）と呼ぶ。

課題：半テンソル圏Cに対して、複行列構成 MulMat(C) を構成せよ。圏（むしろ多圏？）MulMat(C)の性質を調べよ。


</body>
</day>
<day date="2007-02-13" title="">
<body>
*1171350209*[雑記][リンク]Fatgraphs

- &quot;Intersections of Cycles in the Combinatorial Moduli Space&quot; by Alex James Bene （http://www-rcf.usc.edu/~bene/papers/thesis.pdf）

これの第5章がFatgraphs。なんかワクワクするぞー。

</body>
</day>
<day date="2007-02-14" title="">
<body>
*1171412086*[人物]Ulrike Tillmann

ティルマン（Ulrike Tillmann）教授は女性です。→http://www.ma.hw.ac.uk/~ndg/fom/tillmann.html


</body>
</day>
<day date="2007-02-15" title="">
<body>
*1171517716*[人物][リンク][TQFT]Graeme Segal

TQFT関係で、シーガル（Graeme Segal）つう人がよく登場する。

&quot;Time to celebrate&quot;（http://www.maths.ox.ac.uk/news/newsletters/200303/html/newsletter-3.html）にティルマンが出てたりするが、ここに、シーガル（Graeme Segal）の名も登場する。

The Mathematics Genealogy Project（http://genealogy.math.ndsu.nodak.edu/）によると、シーガルはアティヤ（Michael Atiyah）の弟子らしい。ティルマンの直接の先生はRalph Louis Cohenらしいが、コーエン（Cohen）もティルマンもシーガルをよく引き合いに出している。

- シーガルの講義録→http://www.cgtp.duke.edu/ITP99/segal/
- シーガル予想→http://en.wikipedia.org/wiki/Segal_conjecture

*1171518089*[リンク][TQFT][お絵描き]フロベニウス代数と絵算

フロベニウス代数を調べてたら、絵算（graphical/pictorial calculus）がキレイな論文を見つけた。

- http://arxiv.org/abs/math.CT/0309465
- &quot;Correspondences of ribbon categories&quot;
- Authors: J&quot;urg Fr&quot;ohlich, J&quot;urgen Fuchs, Ingo Runkel, Christoph Schweigert
- 129 pages
リボン・テンソル圏の話、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060930/1159588376&quot;&gt;バカキリ本&lt;/a&gt;と一緒に読むといいような気がする。P.123 -- P.127の&quot;Appendix A. Graphical calculus&quot; にフロベニウス代数の絵算がまとめてある。

- http://arxiv.org/abs/math/0502550
- &quot;Frobenius algebras and ambidextrous adjunctions&quot;
- Authors: Aaron D. Lauda
- 35 pages

最初のほうにストリング図が解説されている。ちなみに、ambidextrous は、「両手利きの、両手が同じように使える」という意味。両側（two-sided）より気が利いているかもしれない。訳語は「もろ手随伴」かな？

*1171518866*[用語法]ambient

ambientに関して、本日のgoogle：
- アンビエント 1,020,000件
- アンビアント 557件

*1171520355*[形式言語理論][TQFT][XML][課題]Categorical Formal Language Theories

TQFTつうか、TQFTの一般化であるCategorical General Field Theoriesにならって、Categorical Formal Language Theoriesを定義したい。

&lt;h5&gt;準備&lt;/h5&gt;

まず、アンビエント（ユニバーサル）なモデル圏としてはωCPOを採用。しかし、枠組みとしてはトレース付きベキ等余対角付きデカルト圏なら何でもいい。もうひとつのアンビエント圏として、ソート付き集合（sorted sets）の圏が必要。ソート付き集合の圏は余インデックスされた圏（coindexed category）となる；以下に定義。

集合Sを固定してSorted[S]は、集合Xとσ:X→Sの組(X, σ)を対象として、ソート割り当てσを保存する写像の圏。f:S→Tがソート集合の写像とする。(X, σ)がS-ソート付き集合のとき、T-ソート割り当てτ:X→Tを τ:=σ;f で定義できる。これにより、共変関手 f&lt;sub&gt;*&lt;/sub&gt;=Sorted[f]:Sorted[S]→Sorted[T]が定義できる。よって、Sorted[-]は&lt;b&gt;Set&lt;/b&gt;上に余インデックスされた圏となる。余インデックス構造を使わずに、最初から平坦な圏を定義をすることもできる。

別な見方として、集合Sを離散圏とみなして、関手圏&lt;b&gt;Set&lt;/b&gt;&lt;sup&gt;S&lt;/sup&gt;を作るとS-集合の圏になる。S |→ &lt;b&gt;Set&lt;/b&gt;&lt;sup&gt;S&lt;/sup&gt; は、圏の圏の上の&lt;b&gt;Set&lt;/b&gt;前層の圏だと思えばよい。（一般的な話題としても、“圏の圏の上の前層の圏”は面白そう。）

&lt;h5&gt;CFLTの定義&lt;/h5&gt;

アンビエント・モデル圏はωCPOに固定するとして、CFLT（Categorical Formal Language Theory）を定義するには、指標Σの概念が必要。指標Σはソート集合Sとソート付き演算子の集合Oを持つ。固有指標Σ以外に共通指標Γは前もって固定しておく。Γには、対角、余対角、終対象、対称などの“ジャンクション”が含まれる。固有指標Σに共通指標（実はメタ指標、指標構成子、指標生成関手だが）Γを作用させてΓ(Σ)を作り、絶対指標Γ(Σ)から&lt;strong&gt;構文圏&lt;/strong&gt;（syntactic category）を作る。

指標から構文圏を作る方法は2通りある。1つは自由構成（free construction）を行う方法。もう１つは項モナドを使う方法。自由構成では、例えば、指標から自由双デカルト圏などを作る。モナドを使う場合は、モナドが作用するアンビエント圏としてソート付き集合全体の圏を使い、変数圏Vも使う。Vは余デカルト圏でSorted[S]上の具象圏（直和を保存する忘却関手を持つ）である。

項モナドTerm&lt;sub&gt;Σ&lt;/sub&gt;(X) （X∈|V|）は、Sorted[S]=&lt;b&gt;Set&lt;/b&gt;&lt;sup&gt;S&lt;/sup&gt;上で定義される（直和に関する）可換モナドで、Kleisli圏に直和モノイド構造（つまり余デカルト構造）が入る。このKleisli圏に、直和に関するトレースを入れて、トレース付き余デカルト圏とする。反対圏ならば、トレース付きデカルト圏となる。

項モナドを使う方法は、自由構成よりはるかに一般的（そのぶん複雑）で、自由構成で作った圏は、項モナド構成の特殊なケースと圏同値になる（はず）。さらに、指標Σから構文圏Syn(Γ(Σ))=Syn&lt;sub&gt;Γ&lt;/sub&gt;(Σ)=Syn(Σ)を作る操作がおそらくはモナドで、このSynモナドのKleisli圏が、構文圏のあいだの変換を定義する。

&lt;h5&gt;CFLT間の射と同値性&lt;/h5&gt;

アンビエント・モデル圏をωCPOとして、関手M:Syn(Σ)→ωCPO が&lt;strong&gt;意味関手&lt;/strong&gt;（semantic functor）だとは、トレース付きベキ等余対角付き圏としての（共変または反変の）関手のこと。M:Syn(Σ)→ωCPO、N:Syn(Δ)→ωCPO が2つの「構文圏＋意味関手＝CFLT」だとして、構文圏の変換Φ:Σ→Δ（SynのKleisli圏の射）とする。CFLTの射を次のように定義する。

- Φの持ち上げSyn(Σ)→Syn(Δ)を同じ記号Φで表すとして、MとΦ;Nが、Syn(Σ)→ωCPOの関手となる。別に自然変換α::M⇒Φ;N : Syn(Σ)→ωCPO があるとき、Φとαの組をCFLTの射とする。

特に、(Φ, α):M→N、(Ψ, β):N→M で、ΦとΨが構文圏の圏同値を与え、β=α&lt;sup&gt;-1&lt;/sup&gt;となり、αが（同時にβが）意味関手の自然同値になっているとき、2つのCFLT MとNは同値と呼ぶ。

&lt;h5&gt;インデックスされた圏としてのCFLT圏&lt;/h5&gt;

固有指標の全体を対象類として、適当なSynモナドのKleisli射を射とする圏をベース圏と考えて、インデックスされた圏（indexed category）を作れる。指標Σに対して、関手圏ωCPO&lt;sup&gt;Syn(Σ)&lt;/sup&gt;を考える。構文圏のあいだの構文翻訳関手F:Σ→Δがあると、ωCPO&lt;sup&gt;Syn(Δ)&lt;/sup&gt;→ωCPO&lt;sup&gt;Syn(Σ)&lt;/sup&gt; が誘導される。

以上の状況は、固有指標の圏Signの上に&lt;b&gt;CFLT&lt;/b&gt;[-] = ωCPO&lt;sup&gt;Syn(-)&lt;/sup&gt;がインデックスされた圏となることを示す。ΣごとにSen(Σ)をうまく定義できれば、インスティチューションになる（はず）。

&lt;h5&gt;課題&lt;/h5&gt;

すべてのCFLTからなる圏&lt;b&gt;CFLT&lt;/b&gt;、あるいは&lt;b&gt;CFLT&lt;/b&gt;[-]を考察の対象とする。始対象、終対象はなんだろう。指標Σ（圏だと解釈できる）と変数圏Vをなにか固定したときを詳しく調べる。指標の種類による違い／影響、Vの影響など。


</body>
</day>
<day date="2007-02-16" title="">
<body>
*1171584163*[雑記][TQFT]またダメかな？

カーラー（Thomas Kerler）＆リュウバシェンコ（Volodymyr V. Lyubashenko ）の本：
&gt;&gt;
紀伊國屋書店インターネット店ＢｏｏｋＷｅｂです。

注文日付：2007-01-08 注文番号： 37728801 Non-SemisimpleTopologicalQuantumFieldTheoriesfor3-ManifoldswithCorners(LectureNotesinMathematics) SpringerVe \9,532(税込)
申し訳ございませんが、入荷が遅れております。もう暫くお待ちください。
&lt;&lt;

- 参考：[http://d.hatena.ne.jp/m-hiyama-memo/20070110/1168408202:title]

先頭部分はコレで読める→http://www.math.ohio-state.edu/~kerler/papers/tqft/intro00.ps

*1171584878*[TQFT][リンク]絵がキレイ

- http://arxiv.org/abs/math.QA/0508349
- Frobenius algebras and planar open string topological field theories
- Authors: Aaron D. Lauda
- 66 pages

絵が非常に豊富だし、よいテキストのような気がする。

- http://arxiv.org/abs/hep-th/0607247
-  Duality and defects in rational conformal field theory
- Authors: Jurg Frohlich, Jurgen Fuchs, Ingo Runkel, Christoph Schweigert
- 78 pages

これも絵がキレイ。カラーだし。

絵がキレイといえば、次も参照。
- [http://d.hatena.ne.jp/m-hiyama-memo/20070215/1171518089:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060902/1157182581:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060907/1157599403:title]

特に、カウフマンの&quot;Knots&quot;、手書き風のロープの絵が味があってとてもよいぞ、82ページ→http://citeseer.ist.psu.edu/497874.html

*1171585780*[人物][リンク]続・Graeme Segal

[http://d.hatena.ne.jp/m-hiyama-memo/20070215/1171517716:title]の続き； Web上での本人のプレゼンスはあまりない（“ホームページ”もないようだし）。どうも、シーガルは論文を書いたり資料を作ったりするのが嫌いらしい。手書きのモノがいくつかあった。

- Notes on Quantum Field Theory （http://www.cgtp.duke.edu/ITP99/segal/segal1_n.pdf）
- Notes on Symplectic Manifolds and Quantization （http://www.cgtp.duke.edu/ITP99/segal/segal2_n.pdf）
- Conformal field theory and noncommutative geometry （http://www.math.ucsb.edu/~wei/meeting/geoconf/segal/01.html）
- 同じく Notes on QUANTUM FIELD THEORY 閲覧は便利（http://online.kitp.ucsb.edu/online/geom99/segal1_n/）

2002年、シーガルの還暦祝いのカンフェレンスがあったらしい。ティルマンが編者となっている論文集
- Topology, Geometry and Quantum Field Theory →http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521540490、→http://www.amazon.co.jp/Topology-Geometry-Quantum-Field-Theory/dp/0521540496/sr=1-3/qid=1171571143/ref=sr_1_3/250-2925753-9543409

この本の一部がオンラインで読める。
- アティヤによる序→http://assets.cambridge.org/97805215/40490/excerpt/9780521540490_excerpt.pdf
- 最初の部分（K理論の論文含む）→http://assets.cambridge.org/97805215/40490/sample/9780521540490ws.pdf（コピー／印刷不可）

あとは、これぐらいか？
- Loop groups and equations of KdV type →http://www.numdam.org/item?h=nc&amp;id=PMIHES_1985__61__5_0 フリーダウンロード

ちなみに、
- http://owpdb.mfo.de:4579/detail?photoID=5947 （1982, 若い頃の写真）

なんか、謎の人物。

*1171585961*[インスティチューション]復習

- [http://d.hatena.ne.jp/m-hiyama-memo/20060629/1151547767:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060606/1149562049:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060523/1148367773:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060408/1144475364:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060407/1144403920:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060123/1138003844:title]

*1171605963*[プログラム意味論][圏一般論]可逆計算、亜群、分断圏

- 参考：&quot;From reversible to irreversible computations&quot; by Green, Altenkirch（http://www.mscs.dal.ca/~selinger/qpl2006/PDFS/05-Green-Altenkirch.pdf あるいは http://sneezy.cs.nott.ac.uk/qml/pub/GreenAlten06/GA06qpl.pdf）

可逆計算（reversible computations）のモデルは、亜群となる。亜群が骨格的、つまり、同型の対象は等しいとき、それは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070110/1168422137&quot;&gt;分断圏&lt;/a&gt;となる。よって、骨格的亜群は実質的に群の離散的な集まりに過ぎない。しかし、&lt;em&gt;モノイド構造を持つ。&lt;/em&gt;

対称モノイド亜群にトレースを持たせることができる（こともある）。このトレースで繰り返し計算を行えるだろうか？もしできれば、トレース付き圏（対称モノイド圏）の枠組みで可逆計算もモデル化できる。

不可逆計算は、f:X→X を可逆計算として、X=A+H、X=B+G という分解を使って、(f, A, B)として定義できる。ここで、Hは初期化してないヒープ、Gは捨て去るゴミを意味している。X=A+Y+H、X=B+Y+Gとして、f:(A+H)+Y → (B+G)+Y としてからYでトレースを取ることで普通のトレースは実現できるのだろうか？

*1171606102*[山勘][TQFT][圏一般論]圏のテンソル積

んで、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070216/1171585780&quot;&gt;そのシーガル&lt;/a&gt;が講義録&quot;Lecture 3 Braided tensor categories&quot;（http://www.cgtp.duke.edu/ITP99/segal/stanford/lect3.pdf）で、category-valued field theoryを定義している。TQFTの値をヒルベルト空間から複素線形圏に置き換えたもの。

リー群のループ群の表現が動機付けに使われている。Gに、Loop(G)の複素線形表現の全体の圏を対応させる状況が典型例として使われている。直積群G×Hに対して、Gの表現とHの表現のテンソル積表現が作れるので、これをモデルにしてテンソル圏のテンソル積が使われている。

一般に、空間Xの構造が、なんらかのK値関数環C(X)で記述できるなら、X上のK-ベクトル束の圏は、C(X)上の加群の圏Mod&lt;sub&gt;C(X)&lt;/sub&gt;（の部分圏）と考えてよいだろう。加群の圏は直和（双積）を持つ線形圏（あるいはアーベル圏）となる。

これで、(空間X |→ 線形圏)という対応ができる。線形圏が同値なら、空間も似ていると言える。圏も一種の位相不変量のようなもの。空間=関数環と考えれば、森田同値ってやつではないだろうか。

空間X×Yに対応する圏を作るために、圏のテンソル積が必要になる。圏の双対、指数、ペアリングなどもベクトル空間と類似に構成できて、圏の圏が一個のテンソル圏のようになるのだろう。&lt;em&gt;テンソル圏のテンソル積&lt;/em&gt; -- これはアヤシイ（＝ステキな）概念だ！

*1171606171*[TQFT]反射的グラフとグラフの積

有向グラフ、あるいは境界付き有向グラフの圏（0+1のコボルディズムの圏）に対して、直和だけでなく直積を入れたい。このとき、次元が上がらない定義が欲しい。状態遷移の「状態空間＋遷移規則」をグラフで表現するときもやはり積が欲しい。

次元を上げないようにするには、グラフの定義を最初から反射的にしておく。つまり、頂点Aごとに特定の辺id&lt;sub&gt;A&lt;/sub&gt;を決めておく。こうすると、Edge(G×H)=Edge(G)×Edge(H)と定義できる。

*1171606393*[プログラム意味論][形式言語理論]変数の圏

変数、つまり、後から意味を割り当てられる名前のことだが、その集合達は圏をなす。どういう圏であるかを調べておく。

まず、たかだか可算の集合を対象として、単射を射とする圏を&lt;b&gt;ωInj&lt;/b&gt;とする。変数の圏は&lt;b&gt;ωInj&lt;/b&gt;上の&lt;em&gt;具象圏&lt;/em&gt;でなくてはならない。一般的にVが変数の圏だとは：

+ 始対象を持つ。（具象性から、始対象は空集合）
+ コファイバー和（融合和、貼り合わせ）を持つ。
+ ファイバー積を持つ。

ファイバー積は、埋め込みの共通部分で与えられる。始対象とコファイバー和から、直和を持つ。しかし、終対象を持つとは限らないので直積は保証されない（使わない）。

一般に、A∈Cが概終対象（almost final object）だとは：

+ 任意のXからAへの射が存在する。
+ f, g:X→A があるとき、fとgはAut(A)の違いしかない。

つまり、AのAut群を法として、X→Aは一意的と言える。変数の圏に概終対象の存在を要求することもあるが、必須ではない。むしろ、ある種の有向性のほうが大事：

+ A, Bに対して、A→C, A→C が存在し、ファイバー積A∧Bが0になるCがある。

指標Σに対して、アンビエント・モデル圏Aへの意味関手（の生成系）F:Σ→Aがあるとき、S=Sort(Σ)としてのS-ソート付き変数集合Xに対して、[X]&lt;sup&gt;F&lt;/sup&gt;∈|A| が決まる。[-]&lt;sup&gt;F&lt;/sup&gt;は、変数圏VからAへの関手となる。

VとΣを一緒にして扱うにはウエス計算。Vの対象XごとにXとソート列を繋ぐ形式的な同型を1個ずつ作って、ΣにVをアタッチする。Σ∪&lt;sub&gt;f&lt;/sub&gt;V（fはアタッチメント）を作って、もう一度自由圏を作る。→[http://d.hatena.ne.jp/m-hiyama-memo/20060702/1151833180:title]

具体的にVを作るには、名前の不変集合Uを準備して、Pow(U×&lt;b&gt;N&lt;/b&gt;) のなかで、高さ有限で単葉（Uへの射影が埋め込み）な集合を使うのがいいだろう。

</body>
<comments>
<comment>
<username>sakesnare</username>
<body>TQFTというキーワードで、日記に検索をかけて読んでます。&lt;br&gt;&lt;br&gt;2点のコメントです。&lt;br&gt;&lt;br&gt;1. Edge(G)の定義について&lt;br&gt;これはグラフGが与えられた時のグラフGの辺集合ということでよろしいでしょうか？&lt;br&gt;同様に、グラフGの頂点集合をVertex(G)とするのでしょうか？&lt;br&gt;&lt;br&gt;2. Edge(G×H)=Edge(G)×Edge(H)について&lt;br&gt;1. の表記に従い、&lt;br&gt;・Vertex(G)をグラフGの頂点集合&lt;br&gt;・Edge(G)をグラフGの辺集合&lt;br&gt;とした場合、Edge(G)はVertex(G)の直積集合の部分集合となると思うんですが、&lt;br&gt;&lt;br&gt;＞次元を上げないようにするには、グラフの定義を最初から反射的にしておく。&lt;br&gt;&lt;br&gt;この文脈での「次元」とはどういう意味でしょうか？</body>
<timestamp>1208924570</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&gt;  Edge(G)&lt;br&gt;&gt; これはグラフGが与えられた時のグラフGの辺集合ということでよろしいでしょうか？&lt;br&gt;そうです。&lt;br&gt;&lt;br&gt;&gt; 同様に、グラフGの頂点集合をVertex(G)とするのでしょうか？&lt;br&gt;僕はその場その場で記法をテキトウに変えているので、意味がわかれば何でもいいと思います、Vertex(G)でもNode(G)でも。&lt;br&gt;&lt;br&gt;&gt; Edge(G)はVertex(G)の直積集合の部分集合となると思うんですが、&lt;br&gt;ん？ Edge(G×H)⊆Vertex(G)×Vertex(H) って意味ですか？&lt;br&gt;もしそういう意味の質問なら、そうはなりません。&lt;br&gt;まず、Vertex(G×H) = Vertex(H)×vertex(G) です。a, a’∈Vertex(G), b, b’∈Vertex(H) としましょう。多重辺も考えるので、G×Hの頂点(a, b), (a’, b’) を結ぶ有向辺の集合は Edge((a, b), (a’, b’)) = Edge(a, a’)×Edge(b, b’)です。Edge(G×H)は、Edge(a, a’)×Edge(b, b’) 達の寄せ集めで、Edge(G)×Edge(H)です。&lt;br&gt;多重辺を許す有向グラフを、演算がない圏のように考えます。圏の直積と同じ定義です。&lt;br&gt;&lt;br&gt;&gt; この文脈での「次元」とはどういう意味でしょうか？&lt;br&gt;図形としての次元です。グラフは幾何学的には1-複体なので、掛けると2-複体だとも考えられます。2-複体だと考えるのが便利なときもあるのですが、用途により、0次元（頂点）と1次元（辺）だけの図形にしておきたいこともあります。</body>
<timestamp>1208934951</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>返信ありがとうございます。&lt;br&gt;&lt;br&gt;＞ん？ Edge(G×H)⊆Vertex(G)×Vertex(H) って意味ですか？&lt;br&gt;いえ、Edge(G)⊆Vertex(G)×Vertex(G)っていう意味です。Edge(G)×Edge(H)をこれで、考えたときに「次元」という言葉との対応が分からなかったので質問しました。&lt;br&gt;&lt;br&gt;＞まず、Vertex(G×H) = Vertex(H)×vertex(G) です。a, a’∈Vertex(G), b, b’∈Vertex(H) としましょう。多重辺も考えるので、G×Hの頂点(a, b), (a’, b’) を結ぶ有向辺の集合は Edge((a, b), (a’, b’)) = Edge(a, a’)×Edge(b, b’)です。Edge(G×H)は、Edge(a, a’)×Edge(b, b’) 達の寄せ集めで、Edge(G)×Edge(H)です。&lt;br&gt;多重辺を許す有向グラフを、演算がない圏のように考えます。圏の直積と同じ定義です。&lt;br&gt;&lt;br&gt;了解しました。多重辺を許した有向グラフで考えていらっしゃるんですね。&lt;br&gt;&lt;br&gt;＞ 図形としての次元です。グラフは幾何学的には1-複体なので、掛けると2-複体だとも考えられます。2-複体だと考えるのが便利なときもあるのですが、用途により、0次元（頂点）と1次元（辺）だけの図形にしておきたいこともあります。&lt;br&gt;&lt;br&gt;了解しました。</body>
<timestamp>1208940231</timestamp>
</comment>
</comments>
</day>
<day date="2007-02-17" title="">
<body>
*1171696709*[人物][リンク]まだGraeme Segal

ジョン・バエズ（John Baez）は頻繁にグレアム・シーガル（Graeme Segal）に言及している。
バエズの&quot;This Week's Finds in Mathematical Physics (Week **) &quot;にシーガルやその論文が登場するのは：
+ 不明 (Week 42) 
+ September 23, 1995 (Week 64) 
+ May 17, 1996 (Week 82) 
+ February 1, 1998 (Week 115)
+ February 14, 1998 (Week 117) 
+ April 2, 1999 (Week 132) 
+ June 12, 2000 (Week 149) 
+ July 15, 2000 (Week 153) 
+ March 30, 2002(Week 179)
+ July 30, 2002 (Week 183) 
+ August 4, 2002 (Week 184) 
+ August 8, 2003 (Week 197) 
+ December 8, 2003 (Week 199) 
+ December 31, 2003 (Week 200)
+ March 26, 2005 (Week 212) 

実際にはもっとありそうだ。(Week 149)（http://math.ucr.edu/home/baez/week149.html）で曰く（all these subjects = homotopy theory, string theory, elliptic curves, modular forms）：
&gt;&gt;
Is anyone actually an expert on all these subjects? Perhaps Graeme Segal is! 

  ...

I'm sure he mastered the theory of elliptic curves one weekend when he was a kid. 
&lt;&lt;
超人バエズをしてこう言わせしめるとは…

バエズは、
- Graeme Segal, Elliptic cohomology, Asterisque 161-162 (1988), 187-201. 
に感激しているようだ。


*1171696624*[形式言語理論][圏一般論]ベキのKleisli圏とKleisli圏のベキは違う

過去のエントリーを読み直した。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060630/1151632158:title]

指標Σの項モナドをT&lt;sub&gt;Σ&lt;/sub&gt;(-)とする（もともとはTI&lt;sub&gt;Σ&lt;/sub&gt;と書いてあった）。L&lt;sub&gt;Σ&lt;/sub&gt;(-) := Pow(T&lt;sub&gt;Σ&lt;/sub&gt;(-))と定義する。ここで、Powは共変ベキ・モナドである。一方、圏Cに対する木下ベキ構成をPOW(C)とする。

C上のモナドFのKleisli圏をKl(C, F) = Kl(F) と書くことにする。モナドT&lt;sub&gt;Σ&lt;/sub&gt;(-)とL&lt;sub&gt;Σ&lt;/sub&gt;(-) を十分に大きな圏（アンビエント圏）A上で考える。そのとき、POW(Kl(A, T&lt;sub&gt;Σ&lt;/sub&gt;(-))) と Kl(A, L&lt;sub&gt;Σ&lt;/sub&gt;(-)) が一致する（圏同値）と言ったが、これは&lt;em&gt;間違い&lt;/em&gt;。

実際は、POW(Kl(A, T&lt;sub&gt;Σ&lt;/sub&gt;(-)))のほうが大きくて、Kl(A, L&lt;sub&gt;Σ&lt;/sub&gt;(-)) からの埋め込み（忠実関手）が存在する。

まず、Kleisli射を{y&lt;sub&gt;j&lt;/sub&gt; ::= e&lt;sub&gt;j&lt;/sub&gt;(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;) } の形の方程式系として表す。Kl(A, L&lt;sub&gt;Σ&lt;/sub&gt;(-)) の射は、{y&lt;sub&gt;j&lt;/sub&gt; ::= E&lt;sub&gt;j&lt;/sub&gt;(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;) | E&lt;sub&gt;j&lt;/sub&gt; ∈L&lt;sub&gt;Σ&lt;/sub&gt;(X)} の形に書ける。E&lt;sub&gt;j&lt;/sub&gt; は、E&lt;sub&gt;j&lt;/sub&gt;⊆T&lt;sub&gt;Σ&lt;/sub&gt;(X) である（定義より）。jが1からmまで動くとすると、この方程式系は、(Pow(T&lt;sub&gt;Σ&lt;/sub&gt;(X)))&lt;sup&gt;m&lt;/sup&gt; （m個の直積）でエンコードできる。

一方、POW(Kl(A, T&lt;sub&gt;Σ&lt;/sub&gt;(-)))の射は、方程式系 Y→T&lt;sub&gt;Σ&lt;/sub&gt;(X)))の集まりなので、Pow[(T&lt;sub&gt;Σ&lt;/sub&gt;(X))&lt;sup&gt;m&lt;/sup&gt;]でエンコードできる。明らかに、標準的な埋め込み (Pow(T&lt;sub&gt;Σ&lt;/sub&gt;(X)))&lt;sup&gt;m&lt;/sup&gt;→Pow[(T&lt;sub&gt;Σ&lt;/sub&gt;(X))&lt;sup&gt;m&lt;/sup&gt;]が存在する。

テンプレートとコンテキストの用語で言えば：

- POW(Kl(A, T&lt;sub&gt;Σ&lt;/sub&gt;(-))) -- コンテキストセットの圏
- Kl(A, L&lt;sub&gt;Σ&lt;/sub&gt;(-)) -- セット値コンテキストの圏

セット値コンテキストから導かれるあらゆるインスタンス・コンテキストの集まりは、コンテキストセットになっている。これが標準的な埋め込み。POW(Kl(A, T&lt;sub&gt;Σ&lt;/sub&gt;(-)))を使うことがホントにあるかどうか？ よく分からない。

ほとんど（すべて？）のスキーマ言語は、Kl(A, L&lt;sub&gt;Σ&lt;/sub&gt;(-))しか使わないだろう。別にスキーマ・メタ項のモナドM&lt;sub&gt;Σ'&lt;/sub&gt;があると、Y→M&lt;sub&gt;Σ'&lt;/sub&gt;(X)とKleisli射（セット値コンテキスト） X→L&lt;sub&gt;Σ&lt;/sub&gt;(S) があると、Y→L&lt;sub&gt;Σ&lt;/sub&gt;(S) という新しいセット値コンテキストが作れる。この“代入”を可能とするには、M&lt;sub&gt;Σ'&lt;/sub&gt;(X)に含まれる項を、X→L&lt;sub&gt;Σ&lt;/sub&gt;(S)のコンテキスト（むしろ環境）により評価する意味写像が必要になる。この“メタ項の意味写像”が、2つのモナドを接着することになる。

いま書いたようなことが次にも書いてある。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561239:title]

*1171696754*[モノイド圏]V-豊饒圏をV上のモナドで拡張する

Vが対称モノイド圏で、FがV上の性質のいいモナド（たぶん可換モナド）とする。CがV-圏のとき、hom-object C(a, b)∈|V|に対して、F(C(a, b))を新しいhom-objectとするような圏を作れそうだ。このF構成をF(C)と書いてもいいかも。


</body>
</day>
<day date="2007-02-19" title="">
<body>
*1171877321*[雑感]楕円コホモロジー（Elliptic Cohomology）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061017/1161073390&quot;&gt;右手首&lt;/a&gt;が急に悪化！ キーボードを打てないわけではないが、ものすごくミスタイプが多くて、とってもストレスがたまる。

それはそうとして；&lt;br&gt;バエズがしばしば引き合いに出すところの、グレアム・シーガル（Graeme Segal）による楕円コホモロジー（Elliptic Cohomology）とはなんじゃいな？ と少し探ってみた。

- http://sarah-whitehouse.staff.shef.ac.uk/elliptic.pdf
- Title: Elliptic Cohomology - Prospects in Mathematics -
- Date: December 2006
- Author: Sarah Whitehouse (University of Sheffield)

↑これは、プレゼンテーションのスライド。紹介としてはいいような。ここで気になったのが次のような表。

|*レベル |*コホモロジー |* 幾何 |
| 0      | 普通の&lt;b&gt;Q&lt;/b&gt;コホモロジー| 点 |
| 1      | K理論 |ベクトル束|
| 2      | 楕円理論 |？|

「？」の部分はまだ謎、候補は2-ベクトル束やループ群だそうだ。

次↓のような報告もあるのだが、こりゃ読めそうにない。

- http://www.math.harvard.edu/~lurie/papers/survey.pdf
- A Survey of Elliptic Cohomology
- Jacob Lurie
- January 30, 2006
- 42ページ

が、この著者Lurie（ルーリエ）には驚いた。次のエントリーで述べる。

*1171877487*[人物]21世紀のスーパースター（かも知れない）Jacob Lurie

グレアム・シーガル（Graeme Segal）の楕円コホモロジー（Elliptic Cohomology）ってなんじゃい？ と調べていたら、Jacob Lurie（とりあえず「ヤコブ・ルーリエ」と表記）なる人物を知った。↓

- http://www.math.harvard.edu/~lurie/

学位取り立てくらいの若者らしいのだが、&lt;em&gt;まったくもって尋常ではない&lt;/em&gt;。将来のスーパースター候補だろう。

- http://www.math.harvard.edu/~lurie/papers/highertopoi.pdf

↑これは書籍&quot;Higher Topos Theory&quot;のドラフトらしいが、なんと614ページ！（ダウンロード済み）

もっと短いのはコレ↓。
- http://arxiv.org/abs/math.CT/0306109
- Title: On Infinity Topoi
- Authors: Jacob Lurie
- 60 pages

僕が&lt;em&gt;かすかに&lt;/em&gt;わかるところだけでも、とにかく独特の感性とアイディアに充ち満ちている。ナンデモ屋みたいだが、たぶん大きなビジョンを持っているのだろう。もうスゲー、ヤバイね、彼は。

バエズなら、ルーリエに関して何か言ってるだろうと思ったが、次の講義録で言及しているくらい。

- http://math.ucr.edu/home/baez/cohomology.pdf
- LECTURES ON n-CATEGORIES AND COHOMOLOGY 
- TALKS BY JOHN BAEZ, NOTES BY MICHAEL SHULMAN
- 68ページ

知名度はまだまだってことか？ それにしても、バエズも実際のところ尋常じゃないな。

※ 2007 02-19のgoogle検索結果：
|Jacob ヤコブ   |85,200 |
|Jacob ジャコブ |20,800 |
|Jacobs ヤコブ   |463|
|Jacobs ジャコブ |140|

</body>
</day>
<day date="2007-02-20" title="">
<body>
*1171940971*[雑感][圏一般論][0]断面と懸垂

うーん、手首の状態が&lt;em&gt;酷い&lt;/em&gt;。キーボードも辛いが、手書きが壊滅的だし。ハァー。
それはそうと；&lt;br&gt;昨日の晩、布団のなかで思いついた。

まず、圏のホムセットの絵を描く。

&lt;img src=&quot;http://www.chimaira.org/img2/hom-section.gif&quot; &gt;

射を矢印（線）で描くと、なんか筋繊維がむき出しのカエルの足みたいになる。これをまんなかへん(?)でスパッと切ると、断面は（離散的な）点集合に見える。もし、もとの圏が2-圏／双圏であれば、この断面に圏が現れる。

以上の状況の逆を考える。点集合Xに対して、懸垂を作る。ただし、0から1への向きを付ける。と、矢印の束ができるから、これで点集合から射集合ができる。0と1を同一視すると、約懸垂というヤツだが、これでループ集合ができる。モノイド圏を単対象の双圏とみなすのは、この約懸垂を作る操作だ。

&lt;img src=&quot;http://www.chimaira.org/img2/morph-suspension.gif&quot; &gt;

*1171946724*[プログラム意味論][TQFT]信号構造と運動シート

これも、昨日の晩、布団のなかで思いついた。

まず、アルファベット（アトミックアクションのラベル集合）Aを考えて、A&lt;sup&gt;*&lt;/sup&gt;は、時間に沿って発生（送信や受信）される信号列（時系列）だとする。各信号は時区間のどこかで発生し、0, 1, 2のタイムチックは時点として刻まれている。ただし、タイムチックが物理的時間とどう関係しているかは未知・未定。

&lt;img src=&quot;http://www.chimaira.org/img2/signal-structure.gif&quot; &gt;

2つのチャネル（アルファベットはそれぞれAとB）から（or への）信号列は、完全非同期なら、単に2本の紐で表す。信号（2本の紐）の全体はA&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt;になる。一方、完全同期なら、各タイムチックが横棒で結ばれたハシゴのような図形で表す。信号（ハシゴ）の全体は(A×B)&lt;sup&gt;*&lt;/sup&gt;になる。

非同期と同期が混じったのが下側の図で、2本の紐のところどころに同期の横棒が入っている。これを2次元の膜のように考える。ある状態空間を動く膜は、不定形のリボン、あるいはシートのような形になる。信号の全体は(A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;になる。

さて、このモデルで双模倣を考える。下の図で、A, Bはアルファベットじゃなくて、遷移系（記号法がまったくまずかったのだけど）。

&lt;img src=&quot;http://www.chimaira.org/img2/motion-sheet.gif&quot; &gt;

Mは、AとBを結ぶコボルディズム。ただしMは、関係R⊆|A|×|B|から関係柱（写像柱と同じ、あるいは二部グラフとも同じ）として作った図形。遷移系AとBのアルファベットが違っても、ハシゴのような信号図形からの写像があれば、両端の1次元運動の対応を与える。これは、双模倣と同じことだろう。

両端を境界内に固定された運動シート（motion sheet）があるとき、このシートから、両境界内の運動を取り出すことができる。一方、境界内での運動を結ぶシートがあれば、これは運動のコボルディズムまたはホモトピーとなる。

遷移系に割り当てられる「振る舞い」という“量”はコボルディズム（ホモトピー）不変な量となる。


</body>
</day>
<day date="2007-02-21" title="">
<body>
*1172049792*[用語法]結合性自然同型

結合性自然同型（the associativity natural equivalence / natural isomorphism）は、(A×B)×C → A×(B×C) じゃなくて、A×(B×C) → (A×B)×C でした。勘違いしていた。

(A×B)×Cを正規形だと考えると、非正規形の正規化がα&lt;sub&gt;A,B,C&lt;/sub&gt;:A×(B×C) → (A×B)×C って考えればいいな。λ:I×A→A、ρ:A×I→A はこれでいい。

*1172049793*[雑感]モノイド：モノイド作用 ＝ 代数：加群

K-ベクトル空間の圏におけるモノイドはK-代数（多元環）。モノイド作用A×X→X、つまり、AをX自己変換（Endo(X)）として表現する方法は、代数Aの加群となる。集合圏では、普通のモノイドとモノイドが作用する集合。

C上のモナドFがあるとき、別なC自己関手Gに対して、作用α:F;G⇒GをF-（左）加群と考えることができるかもしれない。


</body>
</day>
<day date="2007-02-22" title="">
<body>
*1172121728*[人物][リンク][TQFT]ロス・ダンカンのthesis

アブラムスキー（Samson Abramsky）、ボブ・クック（Bob Coecke ）などのグループのロス・ダンカンのthesis：

- &quot;Types for Quantum Computing&quot; by Ross Duncan→http://web.comlab.ox.ac.uk/oucl/work/ross.duncan/thesis.pdf 175ページ
- 同じ内容（概略）のスライド→http://web.comlab.ox.ac.uk/oucl/work/ross.duncan/q-day-ii-slides.pdf

シーケント計算、proof net、多圏などの必要な道具立てが解説されている。よくまとまっていると思う。特に第6章（P.87-144）が面白そう。
&lt;pre&gt;
6 Generalised mCQL
6.1 Polycategories
6.2 Graphs and Circuits
6.2.1 Graphs
6.2.2 Circuits
6.3 The Free Compact Closed Category on a Polycategory
6.4 Scalars
6.5 Homotopy
6.5.1 Extended Labellings
6.5.2 Homotopy Equivalence
6.5.3 Circuits under Homotopy
6.5.4 Quotients of the Free Structure
&lt;/pre&gt;


</body>
</day>
<day date="2007-02-23" title="">
<body>
*1172190748*[リンク][復習]時間に関する復習

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070220/1171946724&quot;&gt;信号構造と運動シート&lt;/a&gt; 
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061207/1165485058&quot;&gt;“時間の空間”の圏&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060902/1157178847&quot;&gt;時間と走行&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060630/1151637344&quot;&gt;状態遷移とは、時間たしあげと空間たしあげ&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060127/1138324282&quot;&gt;因果性、自発性、法則性&lt;/a&gt;

*1172190951*[リンク][プログラム意味論][形式言語理論][高次圏論]高次遷移系とコボルディズム／ホモトピー

どうも、双模倣というのはある種のホモトピー同値（ないしはコボルディズム／コボルダント）のような気がしてきた。

AとBが（ラベル付き）遷移系だとして、|A|、|B|を状態空間とする。関係R⊆|A|×|B|があると、Rの関係柱A∪&lt;sub&gt;R&lt;/sub&gt;Bを、写像柱と同じように構成できる。柱を構成する縦線（仮に柱線とか茎線とでも呼ぼう）をグラフの辺とする。柱線に無音記号（沈黙記号、時間推進、タイムフィラー）を割り当てて、新しい遷移系を作れる。

問題は、直積遷移系A×Bの部分系Cを作って、「双模倣の運動対：Motion(A)×Motion(B) ≒ Motion(C)：Motion(A×B)」としたい。「双模倣の運動対≒DiagonalMotion(A∪&lt;sub&gt;R&lt;/sub&gt;B)＝Map({ハシゴ形信号}, A∪&lt;sub&gt;R&lt;/sub&gt;B)」。…、んっ、これ簡単かも。でも、C⊆A×Bを、適当な射の対の等値核（イコライザー）で表現しないとね。

関係柱A∪&lt;sub&gt;R&lt;/sub&gt;Bは、AとBを両端の境界としたコボルディズムと思えるし、これは、AとBのホモトピー同値概念に近い感じがする。

トム・レインスターが&quot;Up-to-Homotopy Monoids&quot;という論説で、一般的文脈におけるホモトピーを定義している。

- http://arxiv.org/abs/math/9912084
- Title: Up-to-Homotopy Monoids
- Authors: Tom Leinster
- 8 pages

多圏の文脈でも、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070222/1172121728&quot;&gt;ロス・ダンカンのthesis&lt;/a&gt;のなかでホモトピーが登場する。

&lt;pre&gt;
6.5 Homotopy
6.5.1 Extended Labellings
6.5.2 Homotopy Equivalence
6.5.3 Circuits under Homotopy
6.5.4 Quotients of the Free Structure
&lt;/pre&gt;

セリンガーの一様射（長谷川の厳密射、ステファネスクの酵素射）の概念も、レインスターが定義している公理的ホモトピー同値で理解できないだろうか。

高次遷移規則（まずは2-遷移規則）を備えた高次遷移系を考える必要がありそうだ。通常の遷移系＝1-遷移系を理解するためにも、2-遷移系に埋め込んだり持ち上げたりする必要がある。2-遷移規則は、遷移規則のあいだの関係だから、遷移変形規則（transition deformation rules）とでも呼ぶのが適切か。2-遷移系は、「状態空間（点）＋遷移規則（線）＋遷移変形規則（面）」で構成される。

2-遷移系Xを“空間”と考えると、Xの基本圏（1次元ホモトピー圏＝ホモトピー1-圏）Γ(X)を考えることができる。Xを可逆化したモノをY（|X|=|Y|）として、基本亜群Π(Y)を作ることができる。Π(Y)の集合圏への表現がルッテン流の巨大オートマトンを与える気がするが、よくわからんなー。


</body>
</day>
<day date="2007-02-24" title="">
<body>
*1172291886*[リンク][プログラム意味論]Simulations as Homotopies
&gt;&gt;
どうも、双模倣というのはある種のホモトピー同値（ないしはコボルディズム／コボルダント）のような気がしてきた。
&lt;&lt;

そんなこと考えている人は他にもいます！

- http://www.math.uwo.ca/~kworytki/getco2.pdf
- Simulations as Homotopies
- Kathryn Hess, Paul-Eug`ene Parent, Andrew Tonks, Krzysztof Worytkiewicz
- 27ページ（印刷済み）

*1172300644*[雑感]小ネタ達

&quot;Simulations as Homotopies&quot;とか&quot;Bisimulation of enrichments&quot;（arXiv:cs.LO/0602077 v1）とかを読んでみようとしたが、&lt;em&gt;よくわからんわ。&lt;/em&gt;

でも、いくつか小ネタを、個別のエントリーにする。

*1172300728*[圏一般論]Obj(-)の右随伴関手

Obj(-):Cat→Setを、（小さい）圏の対象集合を取り出す一種の忘却関手とする。バエズに従えば、これは構造を忘れる忘却関手ではなくて、構成素（スタッフ）の一部を捨て去るタイプの忘却関手。

Obj(-)=|-|の随伴は存在してK(-)と書く。Kは、集合Xに、Xを対象集合とする一番簡単な（トリビアルな）亜群を作る関手。完全有向グラフと似ているのでKを使った。実際、Cat(C, K(X)) ≒ Set(|C|, X) となる。

*1172300996*[高次圏論][形式言語理論]2-豊饒化（2-enrichments）とベッチ・オートマトン

Vが対称モノイド圏であるとき、V-豊饒圏が定義できる。モノイド圏は、2-圏の特別な場合で、単一対象を新たに加えて、対象→射、射→2-セルと次元を格上げするとモノイド圏→2-圏となる。これは、約懸垂構成といえる。

モノイド圏が2-圏であることに注目して、2-圏Vに対する豊饒化を定義できる。Xが対象(0-セル）の集合だとして、h0:X→Obj(V)、h1:X×X→Arr(V)を対応させる。h0(a)をa+、h1(a, b)をhom(a, b)と書く。* はVの1-水平結合だとする。

+ hom(a, b):a+ →b+ in V
+ hom(a, b)*hom(b, c):a+ → c+ とhom(a, c):a+ → c+ のあいだに、2- セルγ&lt;sub&gt;a, b, c&lt;/sub&gt;:: hom(a, b)*hom(b, c)⇒hom(a, c) がある。
+ id&lt;sub&gt;a+&lt;/sub&gt;:a+ →a+ とhom(a, a):a+ → a+ を結ぶ2-セルλ&lt;sub&gt;a&lt;/sub&gt;::id&lt;sub&gt;a+&lt;/sub&gt;⇒hom(a, a) がある。

これらがup-to-iso, up-to-equivで結合律と単位律を満たす。2-圏が局所順序（またはプレ順序）圏のときは定義がずっと簡単になる。

さて、Mを任意のモノイドだとして、C(M)を、Pow(M)に2-圏構造を与えたものとする。C(M)の0-セルは一点、1-セルはPow(M)の要素（Mの部分集合）、2セルはPow(M)の順序を使う。Xを任意の集合として、X上のC(M)-豊饒圏は、(-)+は決まってしまうので、hom(-, -)で決まる。

- hom(a, b)*hom(b, c)⊆hom(a, c)
- {1}⊆hom(a, a)

こうして決まる構造を、状態空間Xのベッチ（Betti）・オートマトンと呼ぶ。

*1172301147*[高次圏論][形式言語理論]遷移系と模倣の定義

Σをアルファベット集合として、Relを関係の圏とする。Σを約懸垂してモノイド＝単対象圏Σ&lt;sup&gt;*&lt;/sup&gt;を作る。T:Σ&lt;sub&gt;*&lt;/sub&gt;→Rel という関手が遷移系となる。単一の対象のTによる像が状態空間となる。

a∈Σに対して、T(a) = a&lt;sup&gt;→&lt;/sup&gt;と略記すると、関係R⊆|S|×|T|（|S|, |T|は状態空間）が模倣であるのは：

- a∈Σについて、R&lt;sup&gt;op&lt;/sup&gt;;a&lt;sup&gt;→&lt;/sup&gt; ⊆ a&lt;sup&gt;→&lt;/sup&gt;;R&lt;sup&gt;op&lt;/sup&gt;

圏Relは局所順序的なので、2-圏とみなす。T、SはΣ&lt;sup&gt;*&lt;/sup&gt;を自明な2-圏とみなしての2関手とみなす。2関手T, S間のoplax変換 T⇒S があることと、T→Sという模倣が存在することは同値である。

</body>
</day>
<day date="2007-02-27" title="">
<body>
*1172565008*[雑感][人物]Jacob Lurie 続報

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070219/1171877487&quot;&gt;ヤコブ・ルーリエ（Jacob Lurie）&lt;/a&gt;はやっぱり普通じゃない。選ばれた&lt;em&gt;特別な人間&lt;/em&gt;なんですね。

- http://www.ams.org/notices/199607/comm-conway.pdf&quot;

1996年に18歳だから、1978年くらいの生まれ。今は30少し前か。

論理、数論、代数幾何、代数トポロジー、数理物理とか、すべてを視野に入れているみたい。高次圏論とホモトピーを統合した道具（とりあえずは無限次のトポスかな）を使って、非可換幾何をやろうとしているように思える。うーん、スーパースターの王道ですなぁ。


</body>
</day>
<day date="2007-02-28" title="">
<body>
*1172654240*[用語法][モノイド圏]テンソル積

モノイド圏のモノイド積を「テンソル積」と呼ぶ人は随分多いんだなぁ。対称でないときでさえ「テンソル積」と言ったりしているし。

僕は、2-圏／双圏の横結合をスター積と呼ぶことがある。が、テンソル積とは言わない。別にこれといって主義はないが、普通のテンソル積（加群とか）と紛らわしいもの。


</body>
<comments>
<comment>
<username>_</username>
<body>テンソル積って線型空間の間の積に対して使う用語だと思います。&lt;br&gt;線型空間の構造があるわけではないと思いますし、普通にカルテシアン積を使えばいいかと。</body>
<timestamp>1172937123</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>モノイド積はカルテシアン積（直積）とは限らないです。それと、Ab（アーベル群の圏）でenrichされているときは、線型な構造があるともいえるし、、、</body>
<timestamp>1173054049</timestamp>
</comment>
</comments>
</day>
<day date="2007-03-01" title="">
<body>
*1172717001*[プログラム意味論][圏一般論][計算]モノイド閉圏でウエス（上江州）計算

本編に次のエントリーを書いた。

- [http://d.hatena.ne.jp/m-hiyama/20070226/1172451671:title]
- [http://d.hatena.ne.jp/m-hiyama/20070228/1172650840:title]

で、上江州＜うえす＞流ラムダ計算ならモノイド閉圏でも定式化できるだろうと思ったので、やってみた。どうやらうまくいく。概略とポイント（注意点）だけを書く。上江州抽象（後述）から自然に型付きオペラッド（後述）が出てくる。

以下で、&lt;i&gt;C&lt;/i&gt;=(&lt;i&gt;C&lt;/i&gt;, ×, I, [-, -])は選択され固定されたモノイド閉圏とする。

&lt;h5&gt;変数集合&lt;/h5&gt;

Vを変数集合とする。type:V→|&lt;i&gt;C&lt;/i&gt;| が前もって定義されていて、Vには&lt;em&gt;全順序&lt;/em&gt;（辞書順と考えるとよい）が入っている。この全順序のおかげで、議論がだいぶ簡略化される。V&lt;sup&gt;*&lt;/sup&gt;は変数列の全体、V&lt;sup&gt;→*&lt;/sup&gt;は、整列している（互いに異なる）変数列の全体。「整列した変数タプル」と言えば、V&lt;sup&gt;→*&lt;/sup&gt;の要素のこと。

PowFin(V)は有限ベキ集合、X∈PowFin(V)に対して、X&lt;sup&gt;→&lt;/sup&gt;∈V&lt;sup&gt;→*&lt;/sup&gt;は、Xの要素を整列して並べたものである。一般の重複出現のない列&lt;b&gt;x&lt;/b&gt;∈V&lt;sup&gt;*&lt;/sup&gt;でも、&lt;b&gt;x&lt;/b&gt;&lt;sup&gt;→&lt;/sup&gt;で整列を示すことがある。

また、type(x) = A であることを、x::A と表記する。

&lt;h5&gt;変数による圏の拡張&lt;/h5&gt;

&lt;i&gt;C&lt;/i&gt;[V]は、モノイド閉圏&lt;i&gt;C&lt;/i&gt;に、x∈Vごとの変域[x]と同型射x:[x]→type(x) を添加して作った最小のモノイド閉圏。これを僕は上江州拡張とか上江州アタッチメントと呼んでいたが、&lt;i&gt;C&lt;/i&gt;を係数圏、Vを変数集合とする多項式圏と呼ぶこともあるようだ。

&lt;i&gt;C&lt;/i&gt;[V]のだいたいの雰囲気； 変数xごとに、対象[x]を&lt;i&gt;C&lt;/i&gt;に付け加え、[x]を&lt;strong&gt;xの変域&lt;/strong&gt;と呼ぶ。x::A だとして、[x]とは：

+ [x]とAは同一ではないが、同型である。
+ [x]とAは同型なので、[x]→A という同型射が存在する。そのような同型射が1つだけ特定されている。
+ 特定された同型射 [x]→A を変数xの“意味”だとする。
+ xとyが異なる変数なら、[x]と[y]は異なる対象である。

おおざっぱに言えば、&lt;i&gt;C&lt;/i&gt;[V]の対象は、|&lt;i&gt;C&lt;/i&gt;|に、{[x] | x∈V}を付け加えて、さらに{x:[x]→type(x) | x∈V}という同型射達も加え、その他必要な諸々も加えて整理して再び閉圏になるように仕上げたもの。

&lt;i&gt;C&lt;/i&gt;[V]の作り方は技術的にめんどうなところなので、詳細は省略。

&lt;h5&gt;構文論&lt;/h5&gt;

&lt;i&gt;C&lt;/i&gt;を固定しているので、ソート（型記号）とは|&lt;i&gt;C&lt;/i&gt;|のことだとする。定数記号とは単に&lt;i&gt;C&lt;/i&gt;の射のことだとする。定数fに対して、type(f) = cod(f)。

項（式）、自由変数集合、項の型を次のように定義する。

+ 変数xは項。FV(x) = {x}、type(x)は前もって定義されている。
+ E, Fを項として、FV(E)∩FV(F)が空のときに限って、ペア(E, F)は項である。FV[(E, F)] = FV(E)∪FV(F)。type[(E, F)] = type(E)×type(F)。
+ (), (E), (E, F, G)などの任意の長さのタプルも項である。変数条件などはペアと同様。
+ Eが項、type(E) = cod(f) のとき、f・E は項である。FV(f・E) = FV(E)、type(f・E) = type(f)。f・EをfEと略記してもよい。
+ Eが項、X⊆FV(E)のとき、λX&lt;sup&gt;→&lt;/sup&gt;.E は項である。FV(λX&lt;sup&gt;→&lt;/sup&gt;.E) = FV(E)＼X。type(λX&lt;sup&gt;→&lt;/sup&gt;.E) = type(E)
+ E, Fが項、type(E) = [A, B], type(F) = A、FV(E)∩FV(F)が空のときに限って、E△F は項である。記号△を使っているが、これは&lt;em&gt;適用&lt;/em&gt;である。FV(E△F)=FV(E)∪FV(F)、type(E△F) = B。

項を作るときの変数や型に関する条件は重要である。ラムダ変数を整列するルールも人為的で実用上は困るが、議論の単純化の効果は大きい。

項Eが、FV(E)=X、type(E)=A であることを、E:X⇒A と書く。例えば、E:{x, a, t}⇒A。集合Xを必ず整列させる約束で、波括弧をはずしても書いてもよい； E:a, t, x ⇒A。

&lt;h5&gt;意味論&lt;/h5&gt;

Eの意味は【E】のように書くべきだろうが、同じ記号で書いてしまう（ヒドイ！）。変数集合X={x1, ..., xn}に対して、その変域は、[X]=[X&lt;sup&gt;→&lt;/sup&gt;]=[x1]×...×[xn]（ただし、x1, ..., xnは整列しているとして）と定義される。Eの意味は常に、[FV(E)]→type(E)という&lt;i&gt;C&lt;/i&gt;[V]の射。

+ 変数xの意味は、x:[x]→type(x) である。
+ ペア(E, F)の意味は、E×Fである。
+ (), (E), (E, F, G)などのタプルは意味は、id&lt;sub&gt;I&lt;/sub&gt;, E, E×F×G など。
+ f・E の意味は、E;f である。
+ λX&lt;sup&gt;→&lt;/sup&gt;.E の意味は、モノイド閉圏のカリー化（随伴の自然変換）を適用したものである。
+ 適用E△Fの意味は、(E×F);ev である。

&lt;h5&gt;上江州抽象&lt;/h5&gt;

Xを変数集合として、(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)をXを適当に並べた列（&lt;em&gt;整列して無くてよい&lt;/em&gt;）とする。並びを置換する射と各x&lt;sub&gt;i&lt;/sub&gt;の逆射を組み合わせると、type(x&lt;sub&gt;i&lt;/sub&gt;)×...×type(x&lt;sub&gt;n&lt;/sub&gt;)から[X]への同型ができる。これを(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;#&lt;/sup&gt;:type(x&lt;sub&gt;i&lt;/sub&gt;)×...×type(x&lt;sub&gt;n&lt;/sub&gt;) → [X] と書く。

E:X⇒A が項、その意味を同じ記号E:[X]→Aで書いて、(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;#&lt;/sup&gt;;E を &amp;lt;x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; | E&gt;と書く。正確には、&amp;lt;x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; | E&gt; は新しい構文で、その意味は今言ったとおり。

項Eから、構文的に&amp;lt;x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; | E&gt;を作る操作を上江州抽象と呼ぶ。その意味は上で述べたが、&lt;i&gt;C&lt;/i&gt;の射と解釈するより、&lt;i&gt;C&lt;/i&gt;から作った複圏の上で解釈するほうが自然。複圏の射は型付きオペラッドと呼んでもいいだろう（マズイからしら？）。

&lt;h5&gt;計算&lt;/h5&gt;

β変換、α変換、η変換は、意味論と整合する。変換による合同を≡と書くと。E≡Fならば、【E】= 【F】 in &lt;i&gt;C&lt;/i&gt; ってこと。逆向きは難しそうだな。でも、たぶん成立する。

上江州抽象とラムダ項には次の関係がある。簡単のために変数は1つだとする。構文と意味をゴッチャにして書くけど：

- &amp;lt;y | F&gt;・&amp;lt;x | E&gt; = &amp;lt;x | (λy.F)△E&gt;
- &amp;lt;x | E&gt;×&amp;lt;y | F&gt; = &amp;lt;x, y | (E, F)&gt;

β変換を考慮すると、

- &amp;lt;y | F&gt;・&amp;lt;x | E&gt; = &amp;lt;x | F[E/y]&gt;

上江州抽象を最初から構文論に入れておくと、オペラッドが混じった計算になる。これで計算力が上がるわけではないが、ラムダ項だけだと、[X]→A （A∈|&lt;i&gt;C&lt;/i&gt;）の形の射（上江州さんの用語ではv→射）しか表現できないが、上江州抽象を使ったオペラッドなら、A→Bの形の射も自由に表せる。例えば、f:A→B として、変数x::Aを使って、&amp;lt;x | f(x)&gt; と書けばfそのものになる。

&amp;lt;x | E&gt; は、インフォーマル・ラムダに近くて、&amp;lt;y | F&gt;・&amp;lt;x | E&gt; = &amp;lt;x | F[E/y]&gt; は、インフォーマル・ラムダの計算でもβ変換が使えることを示す。上江州抽象とオペラッド形式は、通常のラムダとは微妙に異なる“インフォーマル・ラムダのフォーマライズ”になっている。

&lt;h5&gt;注意&lt;/h5&gt;

E(x)の意味が、E・(x) = E・x なのかE△xの意味か混乱することがあるから注意。例えば、高階関数fのf(a)(x)の解釈はf(a)△x = (f・a)△x である。

上江州計算では、変数との適用が、E・x と E△x で区別される。また、ラムダ抽象λx.E と上江州抽象 &amp;lt;x | E&gt; も区別される。Eがxしか変数を含まないときは、λx.E : I→[A, B]、&amp;lt;x | E&gt; : A→B の違いがある。&amp;lt;x | E&gt;をfとするなら、λx.E はfのネーム（ゲーデル・コード）を与えると言ってよい。

</body>
</day>
<day date="2007-03-02" title="">
<body>
*1172809885*[用語法]随伴相方 adjoint mate

F -| G が随伴対のとき、Fに対するG（＝Fの右随伴）、Gに対するF（＝Gの左随伴）を、随伴相方（adjoint mate）と呼ぶことがあるようだ。これはいい！ が、「あいかた」って訳語はどうかな。相棒、連れ -- よけいマズイ。配偶者 -- 関係が強すぎ。

カタカナ語で「メイト」か？

</body>
</day>
<day date="2007-03-03" title="">
<body>
*1172888964*[用語法]続・随伴相方

うーん、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070302/1172809885&quot;&gt;随伴相方（adjoint mate）&lt;/a&gt;の解釈が間違っていたかも。

F:C→D, G:D→Cで、D(F(A), Y)≒C(A, G(Y)) のとき、(f:F(A)→Y in D) と (g:A→G(Y) in C)が対応しているとして、fとgを相方（mate）と呼んでいるようだ。つまり、関手のあいだの関係ではなくて、圏Dの射と圏Cの射が互いに相方関係になるみたい。

例えばベクトル空間と忘却関手Uで考えると、Vect(F(A), Y)≒Set(A, U(Y)) だから、“自由ベクトル空間からの線形写像”と“集合からベクトル空間の台集合への写像”が互いに相方になる。

これはこれで便利な用語法だが、F -| G のときの用語が欠けたままだ、、、

*1172890390*[プログラム意味論][形式言語理論]観測子とは何であるか

面白いことに気が付いた。

Σをアルファベット（アトミック・アクションのラベル集合）とする遷移系Tがあったとする。それに、観測子（オブザーバー）φが付いているとする。φは|S|→V という写像。ここで、|T|はTの内部状態空間、Vは観測値（量）の空間である。

a∈Σに対して、x-(a)→y の遷移があるとき、φ(x) → φ(y) という遷移がVに引き起こされる。このようにすると、Vを状態空間とするΣ遷移系Sを定義できる。すると、観測子φは、T→SというΣ遷移系の準同型となる。

よって、観測子がついたΣ遷移系は、遷移系のあいだの射φと同一視できる。観測量の空間を固定したいなら、φ:T→S、ただし|S|=Vであるものだけを考えればよい。観測的に区別できない系の全体は、Sをベースにした相対圏（カンマ圏、スラント圏）により定式化できる。

観測量の空間Vがブール代数のとき、V上の遷移系とは、作用素付きブール代数の構造を持つだろう。Σから作った自由モノイドもブール代数に作用することになる。

ともかくも、&lt;em&gt;観測子を遷移系の射として認識できる&lt;/em&gt;ことはわかった。&lt;b&gt;[追記]&lt;/b&gt;いやっ、これ少し違うわ。&lt;b&gt;[/追記]&lt;/b&gt;

*1172895775*[論理][計算]型宣言と型判定

変数xと型記号（ソート）Aに対して、x::A （普通はx:A）を変数の型宣言と呼ぶことにする。型宣言の集合を型環境と呼びΔ、Γなどで表す。型環境には、同じ変数の宣言が2回以上は登場しないとする。型環境に登場する変数の集合をVar(Δ)と書く。Var(Δ)とΔは同じ基数で、標準的な1：1対応を持つ。

Eを式（項）だとして、E::B も型宣言と呼ぶ。型環境Δと式の型宣言E::Bの組を、Δ |- E::B と書いて型判定と呼ぶ。上江州計算を仮定すると、型環境Δは、Var(Δ)上の型割り当てだから、Δは型付き変数集合に他ならない。モノイド閉圏&lt;i&gt;C&lt;/i&gt;に対して、上江州変数拡張&lt;i&gt;C&lt;/i&gt;[Δ]が定義できる。

式Eに上江州流の解釈をすれば、E:[Δ]→B という&lt;i&gt;C&lt;/i&gt;[Δ]の射が対応する。つまり、意味論は、(Δ |- E::B) |→ E in &lt;i&gt;C&lt;/i&gt;[Δ] として与えられる。Eから大きなラムダ式&amp;lt;x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; | E&gt;を作れば、これは&lt;i&gt;C&lt;/i&gt;の射となる。

問題は型推論。推論規則の意味はどこに求めるべきだろう？


</body>
</day>
<day date="2007-03-05" title="">
<body>
*1173096537*[計算][論理][リンク]let式、上江州計算、カリー／ハワード対応

- Nick Benton他 A Term calculus for Intuitionistic Linear Logic →http://research.microsoft.com/~nick/tlca93.ps
- Masahito Hasegawa, Logical Predicates for Intuitionistic Linear Type Theories (1999) → http://citeseer.ist.psu.edu/hasegawa99logical.html

この2つで、let式の構文が違う（つうか逆）。ベントン達は &lt;code&gt;let 式 be タプル変数&lt;/code&gt;、長谷川さんは &lt;code&gt;let タプル変数 be 式&lt;/code&gt;。

&lt;code&gt;let タプル変数:= 式&lt;/code&gt;として、&lt;code&gt;タプル変数:= 式&lt;/code&gt;の部分を上江州方式で解釈すると、変数（変域の積）への射となる。これなら、&lt;code&gt;let (x, y):= E in F&lt;/code&gt;は、F・[(x, y):= E]という結合なので、(let g in f) ＝ f・g という&lt;em&gt;やたらに単純&lt;/em&gt;な解釈となる。「タプル変数:= 式」と「式 =:タプル変数」を同じ意味だとすれば（f:=g ≡ g=:f ≡ g;f）、と、構文の違いを吸収できる。素晴らしい！ 上江州計算イケてるぜ。

ラムダ項の構文図（λは箱でなくノードとして束縛線を明示的に描く）と自然演繹の証明グラフをよく比べると、これも面白いこと（カリー／ハワード対応とか）が分かる。（カウフマンの言う）抽象テンソル計算、多圏の計算とかも関係しそうだし。

*1173096758*[説明][論理]シーケント計算、書き換え／正規化構造

証明は自然演繹とする。

+ 仮定と結論を持つ証明図（ペトリネット風グラフ）
+ グラフ書き換え規則としての推論規則、書き換え過程としての証明行為
+ 仮定を除く（含意導入）規則
+ 公理は仮定と考えない
+ 特殊ケースとしての仮定のない証明図
+ 非形式的なシーケント＝証明図の仕様
+ 正しい証明図とは
+ シーケントに対する証明図、命題に対する証明図
+ シーケント、命題の証明可能性
+ 推論規則がシーケント表現ではどのように書けるか？
+ シーケントを最も簡単な証明図で意味付ける
+ 証明図の書き換え規則とシーケントの（ワンステップ）推論図

正規化構造（あるいは簡約構造、書き換え構造）を持つ集合でenrichされたグラフ（圏の素材）があるとき、グラフからの自由圏／自由複圏／自由多圏にも正規化構造を入れることができて、「自由結合＋正規化」がうまくできるなら、正規な射だけからなる目的の圏を作れる、って筋書きだな。

*1173096825*[雑感][高次圏論]結局は図形の組み合わせ論では？

高次圏まで含めた圏とは、“なんらかの意味で「きれい」な”多面体分割を与えられた図形（CW複体とか）じゃなかろうか。その図形に代数演算がたくさん含まれている。代数的な法則は up-to-homotopy、または up-to-isotopy でしか成立しない。

up-to-homo/iso-topyなので、次元が異なる圏が同型（ホモトピー同値）だったりするわけだろう、たぶん。

</body>
</day>
<day date="2007-03-06" title="">
<body>
*1173140351*[雑感][人物]Jacob Lurie ファンクラブ

ヤコブ・ルーリエは、「神様は才能を公平に分けない、極端な偏りがある」証拠となる人物だな。亜細亜の片隅のあなぐらから応援しよう、っと。

田舎のオッサンが、「北島サブちゃんも凄いけど、氷川きよしね、アイツも演歌の天才だね、いいよー、きよし君」とか言っている感じだ。氷川きよしとヤコブ・ルーリエ、だいたい同じくらいの歳だし。

&lt;img src=&quot;http://www.chimaira.org/img2/kiyoshi.jpg&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/jacob.jpg&quot;&gt;

ところで北島サブちゃんにあたるのは誰？ グロタンディークか。

*1173141072*[雑記][モノイド圏]小ネタ：単位対象は終対象じゃないこと

モノイド圏で、×、1とかの記号を使っていると、ついつい1を終対象だと思ってしまうことがある。そんときは、K-ベクトル空間とK-テンソル積の圏を思い出してみる。Kは終対象じゃない！ A→Kはイッパイあって、双対空間ができるよ。

*1173141073*[雑記]小ネタ：1次元空間とテンソル積

ベクトル空間の直和（むしろ、双積と呼びたいが）は、1次元空間に制限しようとしても無理だ。1 + 1 = 2 だから。しかし、テンソル積は1次元空間だけに制限できる（0次元空間を入れても大丈夫）。

考えてみると、テンソル積は小学校から出てくるんだよな。速さの単位は、メートル/秒とかだけど、これは1次元空間の基底“メートル”と時間の双対空間の基底&quot;/秒&quot;のテンソル積だし。

*1173141729*[雑感][論理]線型論理とエコ経済

避けて通っていた線形論理をほんの少しいじってみた。で、線形論理がresource sensitive/awareだって意味が&lt;em&gt;なんとなく&lt;/em&gt;わかった。

縮約規則は対角＝コピーだし、水増し規則は射影＝要るほうを抽出＝要らないほうを破棄すること。&lt;em&gt;コピーもゴミ捨ても有料なのだ。&lt;/em&gt;それが、リソース敏感ってことだろう。エコ経済意識とも言えそうだ。

コピーと破棄がいくらでもできるのが古典直観主義論理＝デカルト閉圏なわけだ。そう考えると、古典論理ってのは、直観主義であってもやっぱり“資源の無限性＝コスト意識不要”を仮定してるわけで、人間的／現実世界的とは言えないな。

ところで僕は、「線型」と「線形」の使い分けにまったく無頓着だな。

*1173154060*[プログラム意味論][形式言語理論]観測者側の系

[http://d.hatena.ne.jp/m-hiyama-memo/20070303/1172890390:title]は少し変だった。次のように考えるべき。

実験観測をする側に、刺激（または信号）の履歴（または記憶）を蓄積しているデータHと、観測量または観測命題Pがある。新しい刺激・アクションaを投入すると、履歴Hにaを追加して、Pを新しい観測命題P'に置き換える。H→H+a、P→P' をaによる遷移と考えた系が観測者側で構成できる。

対象系に対して、対応する観測者側の系が（原理的には）構成できる。対象系のモデルを、観測者側の系から（超越的にでもいいから）構成する手法を与えるのがマイヒル／ネロード型の定理ってことだろう。

対象系Sと状態xに対して、刺激履歴Hの後でPが成立することを S, x |= {H}P と書いて、充足構造が定義できる。観測者側の系では、観測の初期状態（対象系の初期状態ではない！）が&lt;em&gt;必ず特定&lt;/em&gt;されているので、点付きの系となる。たくさんの点付き系で対象系を近似し、覆っていくことが、「対象系を調べる」ことなのだろう。

*1173168162*[リンク][からみ系][論理]アブラムスキーがテンパリー／リーブ代数を語る

The n-Category Cafe'（http://golem.ph.utexas.edu/category/）の記事 http://golem.ph.utexas.edu/category/2007/03/computer_science_and_physics.html 経由で知った：

Abramsky &quot;Temperley-Lieb Algebra: From Knot Theory to Logic and Computation via Quantum Mechanics&quot;（http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/tambook.pdf）

テンパリー／リーブ代数は、以前から「なにやらよくわかんないもの」だったので、43ページもあるだが、&lt;em&gt;思わず&lt;/em&gt;印刷してしまった。

カウフマン図やテンパリー／リーブ代数の不思議な演算が少しでもわかるだろうか？

*1173168163*[雑感]シミジミそうだよね、資源とエコロジー

- [http://d.hatena.ne.jp/m-hiyama-memo/20070306/1173141729:title]

&lt;span style=&quot;font-size:large;&quot;&gt;&lt;em&gt;コピーもゴミ捨ても有料&lt;/em&gt;&lt;/span&gt; -- 我ながらじつにまったく実感がこもった言葉だ。いずれは対称（置換）もコストがかかるのかも。こうして、コスト意識から非可換線形論理に導かれるのかもしれない。

*1173173030*[からみ系]テンパリー／リーブ圏、キターッ

- [http://d.hatena.ne.jp/m-hiyama-memo/20070306/1173168162:title]

&lt;span style=&quot;font-size:large;&quot;&gt;&lt;b&gt;ウギャギャギャギャ、すっげー、テンパリー／リーブ圏（Temperley-Lieb categories）、モノイド閉圏だー！ しかも可換環Rに関してR加群でenrichだしぃ。こっ、これは遊べる！！&lt;/b&gt;&lt;/span&gt;


</body>
</day>
<day date="2007-03-07" title="">
<body>
*1173237907*[雑感][論理][プログラム意味論]離散物理としてのペトリネット by アブラムスキー

アブラムスキーの示唆は面白い。

The n-Category Cafe'（http://golem.ph.utexas.edu/category/）の記事 http://golem.ph.utexas.edu/category/2007/03/computer_science_and_physics.html に、次の参照があった。

-  What are the fundamental structures of concurrency? We still don't know! （http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/bertinoro05.pdf）

このなかでアブラムスキーはペトリネットは &lt;strong&gt;a kind of discrete physics&lt;/strong&gt;と言っている：

+ &lt;strong&gt;lines&lt;/strong&gt; are &lt;em&gt;time&lt;/em&gt;-like causal flows,
+ &lt;strong&gt;cuts&lt;/strong&gt; are &lt;em&gt;space&lt;/em&gt;-like regions,
+ &lt;strong&gt;process unfolding of a marked net&lt;/strong&gt; are like the &lt;em&gt;solution trajectories&lt;/em&gt; of a differential equation.

他に、対話の幾何学（Geometry of Interaction）は証明過程の力学（the dynamics of logical proof）でもある、とも言っている。そして（おそらくは）、結び目やTQFTと絵算の関係も示唆している（ようだ）。

最後に次の言葉を出している。process calculus = &lt;em&gt;the&lt;/em&gt; calculus of a fundamental science of information dynamics.

*1173238168*[からみ系]テンパリー／リーブ圏とその周辺

アブラムスキーの&quot;Temperley-Lieb Algebra: From Knot Theory to Logic and Computation via Quantum Mechanics&quot;（http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/tambook.pdf）をチラチラと眺めて思ったことを記す。

&lt;h5&gt;The TL&lt;/h5&gt;

&lt;b&gt;TL&lt;/b&gt;は&lt;em&gt;固有名詞&lt;/em&gt;で、&lt;b&gt;the&lt;/b&gt; Temperley-Lieb categoryのこと。&lt;b&gt;TL&lt;/b&gt;は自然数&lt;b&gt;N&lt;/b&gt;を対象集合とする圏で、pivotal categoryに分類されている。pivotal圏てのは知らないが、コンパクト閉圏や堅いテンソル圏に近いものだ。

&lt;b&gt;TL&lt;/b&gt;は非常に具体的で、カウフマン図で射を絵に描ける。対称（置換）の圏や組み紐圏に似ている。対称圏のように、交差＝入れ替えを許さないがループ（輪）を持っている。物理的なモデルとしては、衝突すり抜けを&lt;em&gt;許さない&lt;/em&gt;粒子の1次元運動の圏で、粒子の対発生と対消滅を許す。時間の向きを上から下（物理の慣例とは逆）とすれば、∩が対発生、∪が対消滅。○がid&lt;sub&gt;0&lt;/sub&gt;とはならないわけだけど、これの物理的意味は僕にはわからない。残念。

たぶん、○≠id&lt;sub&gt;0&lt;/sub&gt; がテンパリー／リーブ代数のキモなんだろうが、実感がわかない点が僕のダメなところで、スケイン関係式もあいかわらず謎だ。対発生と対消滅により、時空全体（2次元）に領域区分ができるけど、発生消滅の痕跡としての領域が“運動の計算”にどう影響するんだ？

しばらく手計算してみよう。

&lt;h5&gt;The oriented TL&lt;/h5&gt;

点（dots）に向き（orientation）を持たせて有向テンパリー／リーブ圏ができるが、これのほうが僕には扱いやすいかも。有向だとdirectedと勘違いするから、「偏極」または「荷電」がいいな。

&lt;h5&gt;スターとダガー&lt;/h5&gt;

アブラムスキーの記法とは違うけど、fの双対をf&lt;sup&gt;*&lt;/sup&gt;として、2つのダガーf&lt;sup&gt;†&lt;/sup&gt;とf&lt;sub&gt;†&lt;/sub&gt;を導入する（アブラムスキーはf&lt;sub&gt;†&lt;/sub&gt;じゃなくてf&lt;sub&gt;*&lt;/sub&gt;）。すると、f&lt;sup&gt;*&lt;/sup&gt; = (f&lt;sup&gt;†&lt;/sup&gt;)&lt;sub&gt;†&lt;/sub&gt; = (f&lt;sub&gt;†&lt;/sub&gt;)&lt;sup&gt;†&lt;/sup&gt; 。

これは、σとτで生成された群で、σσ = σ、ττ = τ、τσ = στ  という関係がある4元群と同じ構造を持つ。4元群は平面のx軸／ｙ軸対称で生成される群であり、スターとダガーを持つ圏Cは、4元群のEnd(C)表現を持つ。つまり、群の線形表現ではなくて、圏（と関手による）表現。群を単一対象の亜群だとみれば、圏表現は“圏の圏”への関手となる。

対称群や組み紐群の圏表現から対称モノイド圏や組み紐（ブレイド）モノイド圏の概念が出てくるのと同じ理屈で、スター圏やダガー圏を考えることができる。ということは、群やモノイドの圏表現（CとEnd(C)に表現する）から、新しい×××圏の概念が作れるってことだな。

&lt;h5&gt;geometric simplification!&lt;/h5&gt;

幾何的単純化 -- この概念はいいね。キャッチフレーズは、&lt;strong&gt;Yanking Lines Straight!&lt;/strong&gt;

タイトニング、ヤンキング、ストレッチングなどを含む概念。ラムダ式などの項の還元／簡約（reduction）、証明の正規化（mormalization）も幾何学的単純化に含まれる。証明に関してはカット消去も単純化と解釈できる。ジラールの実行公式（execution formula）ってのもそうかな？ -- よくわからん。

まっすぐに伸ばす、最短経路を取るってことから、変分法、モース理論、測地線、最小作用の原理とかを連想する。計算や証明が離散物理なのだとすれば、なにかしら変分的概念が出てこないとおかしいわけだから、幾何的単純化はとても重要な気がする（山勘）。


</body>
</day>
<day date="2007-03-08" title="">
<body>
*1173335854*[論理][トレース／コンパクト閉圏]コンパクト乗法的線形論理

白旗さんのアレ（例えば、http://www.fbc.keio.ac.jp/~sirahata/Research/cmll.pdf）から推論規則を抜き出しておこう。

公理は、コンパクト閉圏&lt;i&gt;C&lt;/i&gt;（モデルの圏）から適当に選んだ射達、ただしidは全部入れる。それと、|- I（Iは単位）。CがΣから生成されているなら、idとIとΣ（固有な公理に相当）を入れるといいだろう。

&lt;pre&gt;
 Γ,A,B,Δ |- Σ
 ----------------[×導入 左]
 Γ,A×B,Δ |- Σ


 Γ |- Δ,A,B,Σ
 ----------------[×導入 右]
 Γ |- Δ,A×B,Σ

 Γ |- A,Δ
 ------------[￢導入 左]
 Γ,￢A |- Δ

 Γ,A |- Δ
 ------------[￢導入 右]
 Γ |- Δ,￢A
&lt;/pre&gt;

構造規則は、左右の換（exchange）、混合（mix）、カット。カットは、 Γ |- A,Δ と Σ,A |- Π からAを&lt;em&gt;シングルカット&lt;/em&gt;する。Iに関してだけ右水増しができる。

&lt;pre&gt;
 Γ |- Δ
 -----------[I水増し]
 I,Γ |- Δ
&lt;/pre&gt;

以上がCMLLのシーケント計算体系。結論がイッパイあるので、多圏で考えたほうがいいだろう。この計算は、自然演繹に対応する証明グラフとは相性がいいだろうが、ラムダ計算とはどうも相性が悪そうだ。右側を単一命題にすればいいのだが、対称性は崩れるな。

*1173336053*[山勘][からみ系][TQFT]テンパリー／リーブ圏

テンパリー／リーブ圏で遊ぶのは、もう単なる趣味だわな。なんか僕は、針金細工（ワイヤークラフト、ワイヤーワーク、ワイヤーアート）みたいんが好きなんだよね（http://www.d1.dion.ne.jp/~phantaz/frhow.htm 面白い）。

カウフマンのブラケット関係式（一種のスケイン関係式と考えていい？）を使うと、組み紐（ブレイド）がカウフマン図（Kauffman diagram）のローラン多項式係数の1次結合で書けてしまう。ここが、一番納得できない不思議なところなんだけど、、、

まーともかく、組み紐圏が係数付きテンパリー／リーブ圏と同値になる（たぶん）。結び目は、組み紐からマルコフ・トレースで得られる（アレクサンダー定理）から、絡み目（結び目と組み紐の一般化）の圏は係数付きテンパリー／リーブ圏と同値（か？）になるのだろう。特に、特定の結び目（射）をテンパリー／リーブ圏に関手で送ると、テンパリー／リーブ圏の基本図形（カウフマン図とか輪とか）の1次結合になり、その係数がジョーンズ多項式のような不変量を提供するようになる、って筋書きみたいだ。いやっ、よく分かってないけど。

&lt;hr&gt;
テンパリー／リーブ圏をTQFTの文脈で考えるのはたぶん重要だ。ただし、普通の無条件のコボルディズムではなくて、枠付きコボルディズムとか箱入りコボルディズムを考える必要がある。一般的には、図形に法バンドルのような構造を入れて、それ（バンドルの全空間）のn次元の箱への埋め込み（境界は保存）を考えて、その埋め込みを、枠も一緒に箱ごとウニャウニャ変形するアンビエント・アイソトピーで同一視した商集合をコボルディズム（コボルディズム圏の&lt;em&gt;射&lt;/em&gt;）と呼ぶ。

このコボルディズムの定義にはパラメータがあって：

+ 箱の次元
+ 埋め込みもとの図形の性質（多様体かCW複体か、とか）
+ バンドルのファイバー次元
+ バンドルの性質（複体のとき、繋ぎ方とか）
+ アイソトピーに使っていい写像の種類

で、コボルディズム概念を選択・固定して、その上でTQFTを考える。

さて、テンパリー／リーブ代数＝テンパリー／リーブ圏のEnd環を決定しているのは、輪（サークル、ループ）に対する値だが、これはつまり、輪の値がテンパリー／リーブ圏上のTQFT関手を決定するってことではないのか？ 

あんまりよくわかってないが、&lt;em&gt;テンパリー／リーブ圏はいくらでも手で触れる&lt;/em&gt;から、遊んでみよう。

*1173337548*[からみ系][TQFT]テンパリー／リーブ圏のスカラー

テンパリー／リーブ圏のスカラーのことを書いておく。

&lt;b&gt;TL&lt;/b&gt;(0, 0)を、アブラムスキーは（抽象）スカラーと呼んでいる。スカラーは可換モノイド（可換性はケリーによる）になる。もし、圏がAb-豊饒なら可換環になることがわかる。

係数なしの純幾何学的には、&lt;b&gt;TL&lt;/b&gt;(0, 0)の元は{◇&lt;sup&gt;n&lt;/sup&gt; | n = 0, 1, 2, ...}と書ける。◇はループ（サークル）を表す。◇&lt;sup&gt;n&lt;/sup&gt;を(n)と書くことにすると、(0) = id&lt;sub&gt;0&lt;/sub&gt;。&lt;b&gt;TL&lt;/b&gt;(0, 0)の&lt;em&gt;もの凄く特殊&lt;/em&gt;な点は、結合と積（モノイド積／テンソル積）が一致していること。つまり、(n);(m) = (n + m)、(n)×(m) = (n + m)。結合と積が単一演算に退化しているので、スカラー環の乗法は結合とも積とも解釈できる。

kがスカラーのとき、f:X→Y とのスカラー乗法k・f を k×f:1×X→1×Yの前後を、λ'&lt;sub&gt;X&lt;/sub&gt;:X→1×Xとλ&lt;sub&gt;Y&lt;/sub&gt;:1×Y→Yではさむ形で定義していたような気がする。ジョーンズ基底U&lt;sub&gt;i&lt;/sub&gt;に関するU&lt;sub&gt;i&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = τU&lt;sub&gt;i&lt;/sub&gt;という関係は、スカラー乗法で説明できないかな？

係数なし&lt;b&gt;TL&lt;/b&gt;のスカラーは、自然数の足し算モノイドになり、係数を入れると1変数の多項式環になる。不定元をXとすると、準同型f:R[X]→Rはf(X)∈Rで決まる。これが、ジョーンズ関係式で出てくる乗数τのような気がする。

*1173338255*[からみ系]テンパリー／リーブ圏の生成元

ジョーンズ関係式による定義では、恒等I:1→1、「上に∪、下に∩」であるX:2→2、ループ◇:0→0の3つが生成元になる。

それに対して、恒等I:1→1、Λ:0→2、V:2→0を生成元にする方法もある。X=V;Λ、◇=Λ;V。これを逆に解こうとすると係数が必要になりそう。ん？ どうなっているんだ？？

*1173342107*[雑感][からみ系][プログラム意味論]テンパリー／リーブ圏と図式代数

テンパリー／リーブ代数のように、図式（diagram）の同値類を基底（生成系）にして、図形の演算（境界結合、直和など）と係数の演算（主に足し算とスカラー乗法）を組み合わせてできる代数を&lt;strong&gt;図式代数&lt;/strong&gt;（diagram/diagrammatic algebras）と呼ぼう。

特に次元が1の図式（紐、ロープ、ワイヤー）を考えたとき、ワイヤリングあるいはジャンクションには次のものがある。

+ 生成 -- 途中で紐が生まれる
+ 消滅 -- 途中で紐が消える
+ ブレイディング（非接触交差）
+ 交差（対称ブレイディング、すり抜け交差）
+ 対生成
+ 対消滅
+ 分岐（ブランチ）
+ 合流（マージ）

圏論的な概念と次の対応がある。
|* 紐 |* 圏論 |
|生成| 始対象、入射 |
|消滅| 終対象、射影 |
|ブレイディング| ブレイディング |
|交差| 対称 |
|対生成| ケリー単位、coev |
|対消滅| ケリー余単位、ev |
|分岐| 対角、余積、余乗法 |
|合流| 余対角、積、乗法 |

ここらへんは、元祖・不変量ジョーンズの次のテキストでも読めばいいのかな。

- URL: http://arxiv.org/abs/math.QA/9909027 
- Title: Planar algebras, I
- Author: Vaughan F. R. Jones 
- 122ページ 印刷してない

*1173343628*[山勘][プログラム意味論][リンク]λとμは親戚か？

- Luigi Santocanale &quot;From Parity Games to Circular Proofs (2002)&quot;→http://citeseer.ist.psu.edu/santocanale02from.html (12P)

にμ項の絵が在るのだが、これがまた、僕がカリー／ハワード対応をでっちあげるために描いたλ項の絵と同じなんだわ。どういうこと？

サントカネイル（Luigi Santocanale ）は他に：
- &quot;μ-Bicomplete Categories and Parity Games&quot;→http://citeseer.ist.psu.edu/566440.html (45P) 
- &quot;On the Equational Definition of the Least Prefixed Point (2003)&quot;→ http://citeseer.ist.psu.edu/santocanale03equational.html (33P)

それと、次に出てくる絵もアヤシサたっぷり。

- Raphael Montelatici &quot;Polarized Proof Nets with Cycles and Fixpoints Semantics&quot;→http://www.pps.jussieu.fr/~montela/papers/tlca03.pdf (15P)

アブラムスキーのアレを読んでから、なんでも図式代数（diagram algebras）と幾何単純化（geometric simplification）に見えてしょうがないな。

ケリー／マックレーン・グラフのHughesなんて人もいるぞ。

- Dominic Hughes→http://boole.stanford.edu/~dominic/papers/


</body>
</day>
<day date="2007-03-09" title="">
<body>
*1173406796*[リンク][計算][復習]少し変わったラムダ計算

「カリーをもっと -- ラムダで考えるカリー化」（http://d.hatena.ne.jp/m-hiyama/20051215/1134614762）って面白いな。自分のエントリーだけど。

*1173409043*[雑記]小ネタ：順序構造の含意

アブラムスキー（http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/tambook.pdf）で、面白い小ネタ。AとBを順序集合として、直和A+Bに普通に順序構造が入る。A+Bと同じ台集合に、a∈A、b∈Bならば a &lt; b として構造を入れてこれを A＜|Bとする（＜| は横向き△のつもり）。

A, Bが全順序のとき、A＜|B も全順序。A→B := A&lt;sup&gt;op&lt;/sup&gt;＜|B と定義すると、含意に似た性質を持つ。また、テンパリー／リーブ圏のぶら下がり∪の構成にも使える。つまり、(↑)→(↑) = (↑)&lt;sup&gt;op&lt;/sup&gt;＜|(↑) = (↓)＜|(↑) = ∪ なのだ。

*1173413171*[メモ法]URLはテキストで

URLの一部を検索したいことが多いから、URLは文字列検索の対象になったほうがいい。ただし、自分のエントリーではURL文字列は不要だな。自分のエントリーは同じウィンドウ内で遷移したほうがいいと思う。

*1173415078*[論理]CMLLとMILL

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070308/1173335854&quot;&gt;「コンパクト乗法的線形論理」&lt;/a&gt;でCMLL（Compact Multiplicative Linear Logic）の推論規則を出したが、MILL（Multiplicative Intuitionistic Linear Logic）も記しておこう。CMLLは意外と古典論理（∧と￢）に近くて、MILLと感じが違う。

CMLLとMILLを比較する； 構造規則に換（exchange）とカットがあるのは同じ。ただし、

+ MILLでは換は左（仮定、前件）のみ。
+ カットの形もMILLでは制限される。

公理がA |- A と |- I である点も同じ。ただし、|- I は、Iの右導入規則と位置づけられる（まー、どうでもいいけど）。

&lt;pre&gt;
 Γ |- A
 -----------[I水増し, I導入 左]
 I,Γ |- A

  (なし)
 --------[I導入 右]
  |- I
&lt;/pre&gt;

MILLの×と⊃に関する論理的な推論規則。

&lt;pre&gt;
 Γ,A,B |- C
 ----------------[×導入 左]
 Γ,A×B |- C

 Γ |- A   Δ |- B
 --------------------[×導入 右]
 Γ,Δ |- A×B

 Γ |- A   Δ,B |- C
 ---------------------[⊃導入 左]
 Γ,Δ,A⊃B |- C

 Γ,A |- B
 ------------[⊃導入 右]
 Γ |- A⊃B
&lt;/pre&gt;

自然演繹風な別な流儀。

&lt;pre&gt;
 Γ |- A   Δ |- I
 --------------------[I消去]
 Γ,Δ |- A

 Γ |- A  Δ |- B
 ----------------[×導入]
 Γ,Δ |- A×B

 Γ |- A×B   Δ,A,B |- C
 -------------------------[×消去]
 Γ,Δ |- C

 Γ,A |- B
 ---------------------[⊃導入]
 Γ |- A⊃B

 Γ |- A⊃B   Δ |- A
 ---------------------[⊃消去]
 Γ,Δ |- B
&lt;/pre&gt;

念のため、CMLLを再掲。

&lt;pre&gt;
 Γ |- Δ
 -----------[I導入 左]
 I,Γ |- Δ

 Γ,A,B,Δ |- Σ
 ----------------[×導入 左]
 Γ,A×B,Δ |- Σ

 Γ |- Δ,A,B,Σ
 ----------------[×導入 右]
 Γ |- Δ,A×B,Σ

 Γ |- A,Δ
 ------------[￢導入 左]
 Γ,￢A |- Δ

 Γ,A |- Δ
 ------------[￢導入 右]
 Γ |- Δ,￢A
&lt;/pre&gt;

この話題に関しては、

- Samson Abramsky, Ross Duncan &quot;A categorical quantum logic&quot; →http://www.mathstat.dal.ca/~selinger/qpl2004/PDFS/02Abramsky-Duncan.pdf （ローカルにも落とした）

*1173422939*[圏一般論][計算]上江州計算の応用範囲

&lt;i&gt;C&lt;/i&gt;が対称モノイド圏なら、ある程度上江州計算ができる。Xが全順序が入った型付き変数集合＝型環境（型宣言の順序リスト）なら、上江州拡張&lt;i&gt;C&lt;/i&gt;⊆&lt;i&gt;C&lt;/i&gt;[X]が作れるから、
+ from-v射（上江州さんのv→射）としての変数を含む式
+ 式のタプル
+ to-v射（上江州さんのv←射）としての複数変数への同時代入文
+ FreeVar(E)とちょうど同じ変数からなる変数リスト(x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)による上江州抽象 &amp;lt;x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; | E&gt;
+ 同時代入文と変数を含む式を組み合わせたlet式
などが使える。さらに、&lt;i&gt;C&lt;/i&gt;が閉圏であれば、通常のラムダ抽象と適用が行える。

ふと気が付いたのだが、λは圏上のオペレータ（射に射を対応させる写像の族）だが、他のオペレータでも上江州計算が使える。具体的には、最小不動点オペレータμ、最大不動点オペレータν、トレース・オペレータτなどだ。

μx.f(a, x) とかτ(x, y).(u(x, y, t), v(x, u, t))などの表現に、射として直接的な意味を与えることができる。式の等式的な書き換え（変形）の健全性は、射の等しさや同型で定義できる。等式、不等式も、射のあいだの関係、さらには2-射として意味を与えることができるだろう。

&lt;i&gt;C&lt;/i&gt;がωCPOなら、λもμもτも全部使える。λa.μx.f(a, x) とかも、I→[A, X]の射として直接解釈ができる（f:A×X→X, μx.f(a, x):[a]→X）。上江州計算を使えば、もっと具体的な計算が楽にできそうだ。

上江州拡張&lt;i&gt;C&lt;/i&gt;[X]内では、from-v to-v射も定義できる。form-v to-v射は、[x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;]→[y&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;m&lt;/sub&gt;]のような射で、上江州抽象すると基礎（自由変数を含まない）代入文になる。

*1173424521*[XML][計算][課題]XMLで上江州計算

なんでXMLに上江州計算を使わなかったんだろう。ばかだなー。アンビエント・モデル圏がωCPOなんだから、使い放題なのに。

式（正規表現とか）はfrom-v射だし、非再帰方程式系はfrom-v to-v射だし、トレース・オペレータτのスコープとかもλと同じだし、上江州抽象はエクスポート（提供、出力）部から名前を奪う操作だし、&lt;em&gt;とっても使いやすい&lt;/em&gt;じゃないか！！

&lt;span style=&quot;font-size:large;&quot;&gt;&lt;b&gt;課題：今すぐ使え！&lt;/b&gt;&lt;/span&gt;

*1173425512*[課題][計算]モナドと上江州拡張

&lt;em&gt;あれれっ、あれ？&lt;/em&gt; 型付き変数集合の圏の上で項モナドや項集合モナドを考えると、[x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;]→[y&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;m&lt;/sub&gt;]のような射がKleisli射として得られる。ところが、上江州拡張でも同じ射が得られる。

ということは、モナドのKleisli圏と上江州拡張はなんらかの関係があるってことだな。これは初耳だ。しばらく、上江州計算と対応するKleisli射を比べてみよう。

</body>
</day>
<day date="2007-03-10" title="">
<body>
*1173504261*[課題][計算]上江州計算の課題

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070309/1173425512&quot;&gt;「モナドと上江州拡張」&lt;/a&gt;にて：
&gt;&gt;
モナドのKleisli圏と上江州拡張はなんらかの関係があるってことだな。
&lt;&lt;

&lt;b&gt;項(Term)モナドと上江州拡張の関係をハッキリさせる&lt;/b&gt; -- これ課題。

方針としては、まず、項モナド（実際は、モナドのKleisli圏）を、[0]={}, [1]={1}, [n]={1, ..., n}に制限する。T([n]) = T(n)とすると、モナドは&lt;b&gt;N&lt;/b&gt;上で定義されたように見える。&lt;b&gt;N&lt;/b&gt;を対象類とする圏はPROだかPROPだかと呼ぶようだ（オペラッドの説明でこの用語見たことがある）。Klesili圏は&lt;b&gt;N&lt;/b&gt;上に定義されるPRO(だか?)だな。

変数集合とみなした[n]に、&lt;i&gt;C&lt;/i&gt;による型付けを与えることは、写像[n]→|&lt;i&gt;C&lt;/i&gt;|を与えることになる。シェープ圏としてのPROを、&lt;strong&gt;ワイヤーフレーム圏&lt;/strong&gt;とか&lt;strong&gt;ワイヤークラフト圏&lt;/strong&gt;と呼ぶといいような気がする。指標Σはワイヤーフレーム圏を装飾する。ワイヤーだけを修飾すると変数なしの項、頂点／ドット（ワイヤーの接合点）も修飾すると変数ありの項、ってことだろう。記号回路（シンボリック・サーキット）って概念とも整合しそうだ。

変数なしの項の圏は、多圏＝構文的圏とも見なせる。構文的多圏から値／実体の圏&lt;i&gt;C&lt;/i&gt;への意味写像は“&lt;i&gt;C&lt;/i&gt;上での、計算（の意味）”を与えるのだろう。

うーん、まだ&lt;em&gt;曖昧、混沌&lt;/em&gt;だ。ともかく、キモは、&lt;b&gt;N&lt;/b&gt;上に制限されたモナド／Kleisli圏だと思う。変数の圏Vに&lt;b&gt;N&lt;/b&gt;を埋め込めば、それが上江州拡張と対応しそうだ。位置引数とか番号（無名）変数とかde Bruijnインデックスとかも関係するはず。

他の課題も列挙：

- ωCPOの上で、λ、μ、τを含む上江州計算を実行する。
- XMLの構文モジュールの計算にλμτ（ラムダ／ミュー／タウ）を含んだ上江州計算を使ってみる。大きなラムダ＝上江州抽象も使ってみる。この計算のなかで固有指標Σの意味を考える。
- ωCPOでは不等式が意味を持つので、不等式を使ってみる。
- ωCPOの等式的な側面は、トレース付きデカルト閉圏（TrCCC）として定式化できるから、TrCCC上で上江州計算をしてみる。
- ωCPOの不等式的側面は、次元2以上の圏のlax/oplax計算になるだろうから、それを探る。

*1173504330*[用語法]pivotal category

pivotalを辞書で引くと：「回転の軸となる」、「中枢の」

中枢圏はいかにもマズイし、回転軸圏は長いし、軸圏か軸的圏か？ カタカナでピボット圏、ピボタル圏。うーん、&lt;em&gt;どれもよくない&lt;/em&gt;。

*1173504467*[論理][からみ系]ループを無視していいのか？

Samson Abramsky, Ross Duncan &quot;A categorical quantum logic&quot;（http://www.mathstat.dal.ca/~selinger/qpl2004/PDFS/02Abramsky-Duncan.pdf）に次のように書いてある。
&lt;pre&gt;
An LCCB2 sequent is of the form

 Γ |- Δ; [L]

where Γ, Δ are lists of formulae and L is a multiset of loops.

The inclusion of the loops in the definition of sequent is slightly
misleading: strictly the loop sets are a proof decoration rather than
a property of the sequents themselves. For this reason two sequents
are defined to be equal if they differ only by loops.
&lt;/pre&gt;

しかし、コンパクト閉圏でもテンパリー／リーブ圏でも、これは違う気がする。つまり、ループも証明図の一部と考えたほうがいいだろう。少なくとも幾何学的には意味がある。&lt;em&gt;論理が幾何の一部を捨てている&lt;/em&gt;ってことだろう、たぶん。

*1173509305*[XML]縦トレースと横トレース？

あれれ、連接を非可換モノイド積と考えて、さらに、このモノイド積を横結合と考え、2つのトレースを持つ圏を考えればいいのか？ 連接＝横結合とするなら、もうひとつ縦連接とでも呼ぶべきモノイド積が必要になるな。

なんだ、よくわからんけど、再帰が二方向あるなら、トレースも２つだろう、やっぱり。いやっ、トレースは1つで、トレースの運用法が2つか？

</body>
</day>
<day date="2007-03-12" title="">
<body>
*1173659158*[からみ系]粒子個数の保存

記号法：Λ（キャップ；上から下に見て対生成）、V（カップ；対消滅）、I（何もおきない）、◇（ループ）。

テンパリー／リーブ圏は、1次元上の多粒子系（の一瞬の状態）の位相的同値類を対象として、位相的運動（これも同値類）を射とする圏だと思える。ジョーンズ基底 X（Λ;V）、I、◇（ループ）から生成すると、対消滅と対生成が必ず一緒に（閉じ込められて）出現するので、単独でΛ（∩；キャップ）やV（∪；カップ）を取り出すことは不可能。これにより粒子数が保存する。

一方、トゥラエフ流の基底Λ、V、Iで生成すると単独（単極）でのΛ、Vが最初から存在するので、粒子数は保存せず、任意のn→mという射を作れる。よって、テンパリー／リーブ圏はより一般的な圏（なんと呼ぶか不明）に埋め込み可能であり、そのなかで粒子数の保存で特徴付けできる。

粒子数が保存しない運動の圏で、粒子が減る運動が単射、粒子数が増える運動が上射となる。エピモノ分解は、任意の運動を粒子数が減る部分と増える部分に分けて表現する。


</body>
</day>
<day date="2007-03-13" title="">
<body>
*1173753730*[リンク][からみ系]タングルの双圏とコバノフ・コホモロジー

スペイン語らしい。が、絵がいいのだ。

- URL: http://www.usergioarboleda.edu.co/matematicas/memorias/memorias13/Cohomolog%C3%ADa%20de%20Khovanov.pdf
- Title: BICATEGOR'IAS DE TANGLES Y LA COHOMOLOG'IA DE KHOVANOV
- Authors: Stella Huerfano, Carlos Wilson Rodriguez

*1173753930*[からみ系][人物]Dror Bar-Natan

絵や写真が好き／得意な人らしい。なんか楽しげ。

- http://www.math.toronto.edu/~drorbn/

Wikiで論文（いやっ、paperlet）書いてるし→http://katlas.math.toronto.edu/drorbn/index.php?title=Paperlet


</body>
</day>
<day date="2007-03-15" title="">
<body>
*1173938471*[説明][具体例][モノイド圏]重ね合わせるだけのモノイド

集合と直和のモノイド圏で、コピーを重ねる（フォールド）写像 A+A→A は、このモノイド圏内のモノイドになっている。

*1173938704*[からみ系][リンク]テンパリー／リーブ圏が役に立つようには思えないが

アブラムスキーが取り上げているのだから、テンパリー／リーブ圏が計算や証明と関係するのは確かなのだろう。が、僕が興味(?)を持っていたところで、ほんとに役立つかはすごく疑問。なんかもう、これは単なるオモチャ（面白いだけの遊び道具）じゃなかろうか？

そんなことでいいのか！ ま、いいや。

- URL: http://www-mi.sci.ibaraki.ac.jp/~yamagami/cda.pdf
- Title: A CATEGORICAL AND DIAGRAMMATICAL APPROACH TO TEMPERLEY-LIEB ALGEBRAS
- Author: YAMAGAMI SHIGERU
- 27P 印刷した。

山上さんは、岩波『数学』でテンソル圏の記事を書いていた人。

*1173939448*[雑記][からみ系]ドメインusergioarboleda.edu.coはコロンビア

http://www.usergioarboleda.edu.co/matematicas/memorias/memorias13/Cohomolog%C3%ADa%20de%20Khovanov.pdf のcoドメインはコロンビアでした。公用語はスペイン語。

</body>
</day>
<day date="2007-03-20" title="">
<body>
*1174385623*[説明][論理]型宣言とカリー／ハワード対応、上江州アタッチメント

項tに対する型宣言 t:A を、「tはA（のひとつ）を具体的に構成する方法である」と読むと、構成的な感じがする。さらに、「tはAという命題の具体的な証明である」と読めば、証明論的な真偽解釈（に関する主張）だとも思える。

型環境（変数の型宣言のリスト）Δにより、Δ⇒t:A と書ける型判断は、「Δを仮定すれば、tによりAの証明が与えられる」というメタ論理的な主張の形式化と捉えられる。

一方、上江州計算（上江州式ラムダ計算）では、型環境Δは、上江州アタッチメントだと解釈できる。tの自由変数がVar(Δ)に含まれるなら、tの意味は上江州拡張&lt;i&gt;C&lt;/i&gt;[Δ]のなかで解釈できる。Var(Δ)を x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; とすると、t: x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt; ⇒A と書ける、これは x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;の変域からAへの射（&lt;i&gt;C&lt;/i&gt;[Δ]内）である。

ついでに書いておくと、上江州アタッチメント（添加）は、圏&lt;i&gt;C&lt;/i&gt;をいったん反射的グラフと考えて、頂点集合Vを直和で加え、Vから|C|への辺、逆向きの辺、恒等（同一）辺を加えて新しいグラフを作る。x:[x]→Aとx':A→[x]に関して、x;x' = [x], x';x = A という関係を入れて圏を生成する。自由生成と関係で商を作る手順となる。


</body>
</day>
<day date="2007-03-24" title="">
<body>
*1174727224*[説明][からみ系][計算][具体例]δε代数

インフルエンザで高熱（39.5度）を出して脳細胞は大量死滅したであろう。まーた、よりバカになった。とりあえずリハビリしておくか（無駄だろうけど）。

うーんと、諸般の事情でコレ：

- URL: http://academics.hamilton.edu/physics/smajor/Papers/AJP00972.pdf
- Title: A Spin network primer
- Author: Seth A. Major 
- 9P(印刷した）

絵算（graphical/pictorial/diagrammatic calculus/calculation）が、ここまで具体的に書いてある例はあまりないと思う。具体例は、 0-1コボルディズムの代数（の一例）を2次元を基本とした古典テンソル計算（スピノールなのか？）で表現するもの。著者はδε代数と呼んでいるが、この計算法自体がTQFTの事例になっている。

僕がprimerから学んだtipsは、

- 実際の計算では、双対性のスターは使わない方がいい。添字の上下で区別する。
- 点に名前を付け、それを添字変数に使う。名前＝添字の規則は古典テンソル計算に従う。
- 添字変数のあいだには、順序（通常は辞書順）が設定されている。実はそれを各所で使う。
- ブレイドの横木は通常描かないが、はっきりと意識したほうがいい。（ニュートン的に）現在と未来を区切る境界になっている。
- 点の極性は、そこを通過する線を一方通行にするような効果を持つ。実際には空間の点の属性ではなくて、運動実体(?)である粒子の属性だろう。つまり、空間的（同時）部分空間である横木を粒子が通り抜けるときに生じる量が極性なのだろう。

しかし、ループ（閉じた軌跡）の存在と挙動は謎だな。交差（クロス、対称ブレイディング）を解消してしまうスケイン関係式（skein relations）も出てくるが、“計算の結果”以上の納得感は得られない。足し算の意味がサッパリわからん。ベントのときは横木（カーテンレールみたいなもの；境界条件）にガチガチに縛られているのに、ループになると全く自由になる。この自由になる理由と事情がサッパリわからん。

ともかく、ベントを反対称テンソルに対応させる計算練習します。
</body>
</day>
<day date="2007-03-27" title="">
<body>
*1174972738*[からみ系][トレース／コンパクト閉圏]ヤンキング公式とフリップターン公式

以前、コンパクト閉圏における σ&lt;sub&gt;A*,A&lt;/sub&gt;;ε&lt;sub&gt;A&lt;/sub&gt; = ε&lt;sub&gt;A*&lt;/sub&gt; のような等式をツイスト公式（twisting formula）と呼んでいたが、ツイスト（ひねり、ねじれ、よじれ）は、別な意味で使うのでどうもマズイ。とりあえず、フリップターン公式（flip turn formula）にしておく。

ジグザグ公式、フリップターン公式（旧・ツイスト公式）、ヤンキング公式は互いに独立ではない。ヤンキングとフリップターンからジグザグを出す、という方針を採用したこともあったが、ジグザグは非対称モノイド圏でも意味があるので、ジグザグをより基本的だと考えるのがスジだろう。

ジグザグを仮定すると、組紐モノイド圏（braided monoidal category）でも、フリップターンとヤンキングが同値であることを示せる。次の形で理解するのがいいと思う。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/flip-yanking.gif&quot; &gt;

これは次のようにして示せる。1番の点線内を、クロスオーバー公式で変形。2番の点線内はライデマイスターIIに対応するブレイド群の計算。

&lt;img src=&quot;http://www.chimaira.org/img2/flip-yanking-deformation.gif&quot; &gt;

今示した同値性を使うと、「フリップターン→ヤンキング」は明か。「ヤンキング→フリップターン」は、下の図の点線内をヤンキングで直線に置き換えればよい。

&lt;img src=&quot;http://www.chimaira.org/img2/flip-elimination.gif&quot; &gt;

dualizer on objectsを持つモノイド圏でジグザグ公式が成り立つと、対称性がなくてもそれなりのことができる（軸的圏；pivotal category）。ジグザグに加えるべき性質にはフリップターンがいいような気がするこの頃。


</body>
</day>
<day date="2007-03-28" title="">
<body>
*1175046365*[雑感][からみ系][計算][具体例]δε代数の計算

古典テンソル計算って、かなり&lt;em&gt;綱渡り&lt;/em&gt;だなー。

アインシュタイン規約、添字の上げ下げ、縮約は、トリッキーだがよく出来たマシナリーだなー、と感心する。が、合理化は面倒。

昔、トレース付き圏の計算をそれと知らずにやっていたが、変数の扱いで散々に混乱していた。同様に、古典テンソル計算でも添字の扱いは職人的だし、ちゃんとできるには修行が必要だし。

*1175047516*[トレース／コンパクト閉圏][からみ系][計算]六角（ヘキサゴン）等式

対称、または組紐が作用する圏で、ブレイディング（クロッシング、トランスポジション）と結合性（associativity）との一貫性は六角等式で示せるが、これは、ABC→CAB、ABC→BCA という左右のローテーションに関する手順独立性だとみなせる。

&lt;pre&gt;
右ローテーション、Cを移動

 A, BC
 -----[α]
 AB, C
 -----[σ]
 C, AB
 -----[α]
 CA, B

 A, BC
 -----[σ]
 A, CB
 -----[α]
 AC, B
 -----[σ]
 CA, B
&lt;/pre&gt;

&lt;pre&gt;
左ローテーション、Aを移動

 AB, C
 -----[α]
 A, BC
 -----[σ]
 BC, A
 -----[α]
 B, CA

 AB, C
 -----[σ]
 BA, C
 -----[α]
 B, AC
 -----[σ]
 B, CA
&lt;/pre&gt;

</body>
</day>
<day date="2007-03-29" title="">
<body>
*1175136261*[モノイド圏][説明]五角形等式

厳密とは限らないモノイド圏における五角形等式を絵に描いてみた。4つの対象の積の作り方は実際5種類ある。結合性（associativity）で直接に（1ステップで）移れるものは五角形の辺で結ばれる。隣り合ってない頂点は、2つの辺、または3つの辺を経由して移るのだが、その移り方の経路によらずに同じ結果を与える。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/pentagon-condition.gif&quot; &gt;

*1175136327*[からみ系]スケイン関係式

εをエディントンのイプシロン（ただし、添字が2つの変形バージョン）として、

- ε&lt;sup&gt;AB&lt;/sup&gt;ε&lt;sub&gt;CD&lt;/sub&gt; = δ&lt;sup&gt;A&lt;/sup&gt;&lt;sub&gt;C&lt;/sub&gt;δ&lt;sup&gt;B&lt;/sup&gt;&lt;sub&gt;D&lt;/sub&gt; - δ&lt;sup&gt;A&lt;/sup&gt;&lt;sub&gt;D&lt;/sub&gt;δ&lt;sup&gt;B&lt;/sup&gt;&lt;sub&gt;C&lt;/sub&gt;

がスケイン関係式（スピノール関係式ともいうのかな？）だが、成分ごとに愚直に全部計算してみた。

やっぱり、点になんらかの量（状態ベクトル？）がくっついいていて、その量が辺や遷移ノードにより変換を受ける、と考えるといいのだろうか。量がベクトルなら足し算（重ね合わせ）ができるのだから、足したり引いたりで等号が成立するのもアリだ。

しかしそれにしても、対消滅に引き続く対生成が、「何も起こらないこと」と「交換する（入れ替える）こと」の重ね合わせか、、、不思議過ぎるな。

*1175143271*[トレース／コンパクト閉圏]ヤンキングはさほど一般的ではない

ヤンキング等式とフリップターン等式、どちらかが成立すればもう一方も成立する（ただし、ジグザグは大前提）という意味で同値だが、ヤンキング（したがってフリップターン）が必ず成立するわけではない。

2次元から外にでないで紐のヤンキングをしようとすると、ねじれ（twist、よじれ、ひねり）がダマになって紐に残ってしまう。フリップターンでもモチロン同様でダマをほぐすことはできない。ねじれを考慮すればリボン圏になる。ねじれ付きヤンキング等式は Tr(σ) = θ となる。ここで、θ=θ&lt;sub&gt;X&lt;/sub&gt;はツイスト同型と呼ばれる射で、End(X)内で&lt;b&gt;Z&lt;/b&gt;と同型な群をなす。ツイストの群を自由群以外に取ると何か面白いのか？ わからない。

一方、バッファの半圏を考えると、フィードバック遅れが生じる。ヤンキングを成立させるには無限バッファが必要で、結果的にIdも無限バッファとなり、完全非同期な圏ができる。

一方で、非対称圏ではヤンキングを定式化できないので、もとよりヤンキングは無意味となる。

ヤンキングはそれほど必然性があるわけではなくて、むしろ、特殊なケースで成立している。

*1175144493*[トレース／コンパクト閉圏]軸的圏（pivotal categories）

定義を述べておく。

(&lt;i&gt;C&lt;/i&gt;, ×, I)がモノイド圏（対称性は仮定しない！）。(-)&lt;sup&gt;*&lt;/sup&gt;:|&lt;i&gt;C&lt;/i&gt;|→|&lt;i&gt;C&lt;/i&gt;|、η、ε:|&lt;i&gt;C&lt;/i&gt;|→Cが次の条件を満たすとき(&lt;i&gt;C&lt;/i&gt;, ×, I, (-)&lt;sup&gt;*&lt;/sup&gt;, η, ε)を&lt;strong&gt;軸的圏&lt;/strong&gt;と呼ぶ。

&lt;hr&gt;
(-)&lt;sup&gt;*&lt;/sup&gt; はモノイド圏上の対象上双対作用（dualizer on objects）だとする。つまり、

+ A&lt;sup&gt;**&lt;/sup&gt; = A （対合性）
+ (A×B)&lt;sup&gt;*&lt;/sup&gt; = B&lt;sup&gt;*&lt;/sup&gt;×A&lt;sup&gt;*&lt;/sup&gt;
+ I&lt;sup&gt;*&lt;/sup&gt; = I

射の族η、εは、対象Aごとに(A, η&lt;sub&gt;A&lt;/sub&gt;, ε&lt;sub&gt;A&lt;/sub&gt;)が（左）双対系を定める。つまり、S字とZ字のジグザグ等式を満たす。さらに：

+ η&lt;sub&gt;I&lt;/sub&gt; = I
+ η&lt;sub&gt;A×B&lt;/sub&gt; = η&lt;sub&gt;B&lt;/sub&gt;;(B&lt;sup&gt;*&lt;/sup&gt;×η&lt;sub&gt;A&lt;/sub&gt;×B)

射fに対してその双対の定義が二種類生じるが、それらが等しい。コンパクト閉圏では、二種類の双対が等しいことを示せるが、軸的圏では公理として仮定する。


</body>
</day>
<day date="2007-03-30" title="">
<body>
*1175232124*[雑記]お絵描きノート

が紛失しているのだけど。

僕にとっては相当に大事なシロモノだからな、探さないと。

&lt;b&gt;ToDo&lt;/b&gt;のかなりの部分は&lt;b&gt;ToFind&lt;/b&gt;。アホじゃ＞自分。

</body>
</day>
<day date="2007-03-31" title="">
<body>
*1175308305*[用語法][トレース／コンパクト閉圏]ケリー双対

ジグザグ（あるいは三角、あるいは剛性）等式で定義される双対概念があるけど、これが一般的な双対と混同しがちで&lt;em&gt;非常に困る&lt;/em&gt;。

以前、「ケリー単位／ケリー余単位」という言葉を使ったことがあるので、もういっそのこと「ケリー双対」と呼ぶことにしよう（&lt;em&gt;勝手に&lt;/em&gt;）。

- &lt;strong&gt;ケリー双対系：&lt;/strong&gt; (A, X, η, ε)、η:I→X×A, ε:A×X→I、ジグザグ等式を満たす。
- &lt;strong&gt;右ケリー双対：&lt;/strong&gt; Aに対するXのこと。XはAの右ケリー双対。
- &lt;strong&gt;左ケリー双対：&lt;/strong&gt; Xに対するAのこと。AはXの左ケリー双対。
- &lt;strong&gt;ケリー双対：&lt;/strong&gt; 文脈により右または左のどちらか一方を単にケリー双対と呼ぶ。また、右と左が一致するときは単にケリー双対といってよい。
- &lt;strong&gt;ケリーペア：&lt;/strong&gt; ケリー双対系を構成するAとX。随伴の記法を借りて、A -| X （Xが右、Aが左）と書いてもよいだろう。
- &lt;strong&gt;ケリー形式：&lt;/strong&gt; εのこと。Iをスカラーと解釈できる線形圏のとき、εはケリーペア上の双線形形式だと思える。ηの存在は、εが&lt;strong&gt;非退化&lt;/strong&gt;（非自明、つぶれてない）であることを意味する。
- &lt;strong&gt;ケリー単位：&lt;/strong&gt; ηのこと。
- &lt;strong&gt;ケリー余単位：&lt;/strong&gt; εのこと。ケリー形式。

*1175309435*[トレース／コンパクト閉圏][からみ系]右（左）ケリー双対の一意性

用語法は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070331/1175308305&quot;&gt;「ケリー双対」&lt;/a&gt;に従う。

(A, X, η, ε)、(A, Y, η', ε')を2つのケリー双対系だとする。つまり、対象Aに対して2つの右ケリー双対がある。このとき、2つの右ケリー双対XとYは同型であることを示す。

状況（settings）を絵に描くと：

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/two-duals.gif&quot; &gt;

モノイド積を+で書くとして（しかし対称とは限らない）、ジグザグは次のとおり。

- (η+X);(X+ε) = X
- (A+η);(ε+A) = A
- (η'+Y);(X+ε') = Y
- (A+η');(ε'+A) = A

φ:X→Yとψ:Y→Xを次のように定義する。

- φ:= (η'+X);(Y+ε) :X→Y
- ψ:= (η+Y);(X+ε') :Y→X

このφ、ψがXとYの同型を与える。つまり、

- φ;ψ = X, ψ;φ = Y

絵算を使えば、ズラシ（shift）を使って、“引き伸ばし可能”なジグザグを作り、2回引き伸ばせばよい。しかし、等式的計算だけだと、この計算でもけっこう大変。絵算では、プライム（ダッシュ）が付いたベントがη'、ε'に対応する。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/unique-right-dual.gif&quot; &gt;

*1175310243*[トレース／コンパクト閉圏][からみ系]ヤンキング風の便利な公式

次はなかかな便利だ。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/deformed-yanking.gif&quot; &gt;

これを示すには、クロスオーバーを一回、ブレイド（または対称）計算を1回使うだけ。クロスオーバーは、スライディングスワップ（(f+g);σ = σ;(g+f)）の特殊ケースだが、スライディングスワップはブレイディングが自然変換であることの表現に過ぎない（ブレイディング::恒等関手⇒フリップ関手）。つまり、上の公式は、ブレイドが作用している圏で成立する。

利用法：まず、ボックスfがIdのときは、（ジグザグを大前提として）フリップターン公式とヤンキング公式の同値性を示せる。ツイストがあり、ダマ（シコリ）が残るケースでもやはり同値性は成立する。

fに対する双対の作り方が2つあるが、対称モノイド圏では2つの双対が一致することをただちに示せる。ブレイド圏では、ブレイドのアッパーとローワーに応じて2つの双対があることが分かる。

*1175325278*[トレース／コンパクト閉圏][からみ系]右ケリー双対と左ケリー双対が一致する圏：等方的剛性

任意のAに対してケリー双対系(A, R, η, ε)、(L, A, δ, γ)が存在するような圏は&lt;strong&gt;堅い圏&lt;/strong&gt;と呼ぶ。A|→R、A|→L が写像として与えられているとして、R=A&lt;sup&gt;#&lt;/sup&gt;、L=A&lt;sup&gt;*&lt;/sup&gt;とする。η, ε（右双対）、δ, γ（左双対）もAをパラメータとして与えられる。

以下、イコールは同型を意味する、とする。

まず、一般的に、

- (A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = A
- (A&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;#&lt;/sup&gt; = A

定義から自明にちかいが、あからさまな同型の表示は次のようにして得られる。

- η:O→A&lt;sup&gt;#&lt;/sup&gt;+A
- ε:A+A&lt;sup&gt;#&lt;/sup&gt;→O
- δ:O→A&lt;sup&gt;#&lt;/sup&gt;+(A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;
- γ:(A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;+A&lt;sup&gt;#&lt;/sup&gt;→O

具体的な同型φ、ψは：

- φ:= [(A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;+η];(γ+A)
- ψ:= (A+δ);[ε+(A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;]

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070331/1175309435&quot;&gt;「右（左）ケリー双対の一意性」&lt;/a&gt;とまったく同様にして、これが同型であることを示せる。

さて、いまの状況で以下の命題は同値。

+ A&lt;sup&gt;#&lt;/sup&gt; = A&lt;sup&gt;*&lt;/sup&gt;
+ A&lt;sup&gt;##&lt;/sup&gt; = A
+ A&lt;sup&gt;**&lt;/sup&gt; = A

これらを言い換えると、

+ 右双対と左双対が定義されていて、その対象が一致する。（同一、または同型対象で右双対と左双対を実現できる。）
+ 右双対が定義されていて、その写像が包合的。
+ 左双対が定義されていて、その写像が包合的。

まず、(1)⇒(2)；A&lt;sup&gt;#&lt;/sup&gt; = A&lt;sup&gt;*&lt;/sup&gt; の両辺に#を作用させると、
A&lt;sup&gt;##&lt;/sup&gt; = (A&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;#&lt;/sup&gt;、ところが右辺はAだから、A&lt;sup&gt;##&lt;/sup&gt; = A。

(2)⇒(1)；A&lt;sup&gt;##&lt;/sup&gt; = A の両辺に*を作用させると、(A&lt;sup&gt;##&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = A&lt;sup&gt;*&lt;/sup&gt;、ところが左辺は(A&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;#*&lt;/sup&gt;なのでA&lt;sup&gt;#&lt;/sup&gt;。したがって、A&lt;sup&gt;#&lt;/sup&gt; = A&lt;sup&gt;*&lt;/sup&gt;。

(1)⇔(3)も同様。

η,εとδ,γに関しても議論の必要があるが、右と左が一致するような圏では、(-)&lt;sup&gt;#&lt;/sup&gt;,η,ε、または (-)&lt;sup&gt;*&lt;/sup&gt;,δ,γだけで議論を進めることができる。

右と左の区別が不要な堅い圏は、&lt;strong&gt;等方的に堅い圏&lt;/strong&gt;（isotropically rigid category）と呼ぶことにする。

</body>
</day>
<day date="2007-04-03" title="">
<body>
*1175569568*[トレース／コンパクト閉圏]コンパクト閉圏と関係する圏：系統図

コンパクト閉圏と関係する圏の系統図を描いてみた。ほんとにチラシのウラに描いたもの。あまり洗練されてない。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/compactcc-and-related.gif&quot; &gt;

- コンパクト閉圏に最も近い圏は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070329/1175144493&quot;&gt;軸的圏&lt;/a&gt;、軸的圏は対称性を持たないが、射の双対（転置）が一意的に決まる。
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070331/1175325278&quot;&gt;等方的に堅い圏&lt;/a&gt;は、包合的（involutive）なスターとη、εだけで右双対も左双対も定義できる。射の双対に関しては未調査。
- 堅い圏は右双対と左双対を持つが、別々の（同型でさえない）対象かもしれない。

*1175569680*[課題][トレース／コンパクト閉圏]2つの双対

(#, η, ε)が（大域的に定義された）右ケリー双対構造、(*, δ, γ)が左ケリー双対構造だとする（包合性は厳密だと仮定）。f:A→Bに対して、

- f&lt;sup&gt;#&lt;/sup&gt; := (η×B&lt;sup&gt;#&lt;/sup&gt;);(A&lt;sup&gt;#&lt;/sup&gt;×ε)
- f&lt;sup&gt;*&lt;/sup&gt; := (B&lt;sup&gt;*&lt;/sup&gt;×δ);(γ×A&lt;sup&gt;*&lt;/sup&gt;)

これに対して、

- #は&lt;del datetime=&quot;2007-04-04T12:12:49+09:00&quot;&gt;包合的&lt;/del&gt;反変関手
- *は&lt;del datetime=&quot;2007-04-04T12:12:49+09:00&quot;&gt;包合的&lt;/del&gt;反変関手
- #と*は関手として同値（自然変換がが存在する）

を示せ。さらに、

- #, *はモノイド積とモノイド単位に対してどう振る舞うか？

*1175569775*[課題][トレース／コンパクト閉圏]ケリー単位／余単位の一意性

(A, X, η, ε)と(A, X, η, ε')がケリー双対系として、εとε'が同一であることを示せ。

*1175569848*[課題][トレース／コンパクト閉圏]ケリー双対系の圏

Cがモノイド圏として、C上のケリー双対系(A, X, ε, δ)の全体をKD(C)とする。KD(C)の射を次のように定義して圏になる。

- (A, X, ε, δ), (B, Y, ε, δ)のあいだの射は、φ:A→B、ψ:X→Y の組。
- η;(φ×ψ) = η、(φ×ψ);ε = ε

KD(C)の性質を調べよ。

*1175570014*[トレース／コンパクト閉圏]平面的フィードバック

等方的に堅い圏を考えると、ここでは普通のトレースは定義できない。しかし、ヤンキングを除いたトレース公理を満たす作用素であるフィードバックは定義できる。しかも左右のフィードバックが定義できる。

モノイド積を左から右、圏結合を上から下に図示するとして、

- 右フィードバック (A×Y→B×Y)|→(A→B)
- 左フィードバック (X×A→X×B)|→(A→B)

左右のフィードバックをL, Rで表すと：

- Rはフィードバックの公理を満たす。
- Lはフィードバックの公理を満たす。
- RとLは可換である。つまり、R&lt;sup&gt;Y&lt;/sup&gt;(L&lt;sup&gt;X&lt;/sup&gt;(f)) = L&lt;sup&gt;X&lt;/sup&gt;(R&lt;sup&gt;Y&lt;/sup&gt;(f))

平面的なので、X×A×Y のAに関してはフィードバックを取ることができない。右端か左端しかフィードバックを取れない。

2つのフィードバックR, Lを備えた圏はなんか意味があるか？

*1175571356*[トレース／コンパクト閉圏][雑感]コンパクト閉圏の定義

ここんところ、コンパクト閉圏の基本的な部分を少し考えてみた。

対象上に包合的（up-to-isoでもよい）なA |→ A&lt;sup&gt;*&lt;/sup&gt;があり。割り当てη,εに関してケリー双対系になっているような対象モノイド圏はコンパクト閉圏になっているのはどうも確からしい。

- I&lt;sup&gt;*&lt;/sup&gt; = I
- (A×B)&lt;sup&gt;*&lt;/sup&gt; = B&lt;sup&gt;*&lt;/sup&gt;×A&lt;sup&gt;*&lt;/sup&gt;

は証明できるといえばできる。ただし、イコールはup-to-isoになる。また、フリップターンも証明できるといえばできる。これもup-to-iso。歯切れ悪い表現をしているのは、証明がそれほどスッキリしないからだ。up-to-isoな議論を重ねているので、なんかヨワーイ感じの等式になってしまう。

以上の証明の根拠は、対象Aに対する右（左）ケリー双対系が存在するとき、up-to-isoで一意的なことである。この一意性が弱いので、全体が弱い主張になってしまう。

ケリー＆ラプラザをちゃんと読んでみようか。

</body>
</day>
<day date="2007-04-04" title="">
<body>
*1175657101*[リンク][人物]Paul-Andre Mellies

- Title: Double Categories: a modular model of multiplicative linear logic
- Author: Paul-Andre Mellies
- URL: http://citeseer.ist.psu.edu/723469.html

- Title: Categorical Models Of Linear Logic Revisited (2002)
- Author: Paul-Andre Mellies
- URL: http://citeseer.ist.psu.edu/mellies02categorical.html

ニックベントン（Nick Benton）の線形非線形圏（linear non-linear category）というワケワカラン概念が説明されている。

*1175659244*[トレース／コンパクト閉圏]ケリー双対系のあいだの射は同型だけ

(A, X, η, ε), (B, Y, η', ε')が2つの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070331/1175308305&quot;&gt;ケリー双対系&lt;/a&gt;のとき、このあいだの射は同型しか定義できない（少なくとも、&lt;em&gt;しにくい&lt;/em&gt;）し、同型しか考える必要もないようだ。したがって、KD(C)は亜群となる。亜群の連結成分から対象の代表元を取れば、群の離散的な集まりになるんじゃなかったかな？

まーともかく、再定義しておく。

- (A, X, η, ε)から(B, Y, η', ε')への射は、φ:A→B, ψ:X→Yの組。
- &lt;em&gt;φもψも可逆（同型射）&lt;/em&gt;
- η;(φ×ψ) = η'
- (φ&lt;sup&gt;-1&lt;/sup&gt;×ψ&lt;sup&gt;-1&lt;/sup&gt;);ε = ε'

次の定理が最も重要。

- (A, X, η, ε)から(A, Y, η', ε')への同型が存在する。
- その同型は、Aに対して恒等、X→Yは(η'×X);(ε×Y)で具体的に与えることができる。

系として、

- (A, X, η, ε)から(A, X, η', ε')への同型が存在する。
- その同型は、Aに対して恒等、X→Xは(η'×X);(ε×X)で具体的に与えることができる。

これより、次のようなある種の（up-to-isoでの）一意性が出る。

- Aに対する右ケリー双対系(A, X, η, ε)はすべて同型である。
- Aに対する左ケリー双対系(Y, A, δ, γ)はすべて同型である。
- ペア(A, X)上のケリー双対系はすべて同型である。

対象A、またはペア(A, X)を固定して、その上で2種のケリー双対系が作れれば、それらが同型であることは自動的に出る。

*1175659350*[モノイド圏]基本的事実と一貫性がわからん

モノイド圏(C, ×, I, α, λ, ρ)では、次のような事実が成立するはず。

- λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt;

この手の等式はどこから来るのだろう。一貫性から導けるはずだが、一貫性の使い方がよくわからん。

*1175659945*[トレース／コンパクト閉圏]モノイド単位対象上のケリー双対系

モノイド圏Cのモノイド単位をIとする。×はモノイド積は、α、λ、ρは結合性、左単位、右単位の自然変換だとする。

単位Iに対する右ケリー双対系を具体的に構成する。(I, I, ρ&lt;sub&gt;I&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;, λ&lt;sub&gt;I&lt;/sub&gt;)がIの右ケリー双対系になる。これは同時にIの左ケリー双対系でもある。理由は次の手書きメモ（等式が間違っているわ、絵のほうを信用して）：

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/dual-for-unit.gif&quot; &gt;

モノイド圏の三角一貫性条件を単位に適用すると、α;Iλ;ρ&lt;sup&gt;-1&lt;/sup&gt;I = II という厳密な等式が得られる。これを図示するとZ字ジグザグの精密なバージョンが得られる。S字ジグザグは、&lt;em&gt;λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt;を仮定すれば&lt;/em&gt;同様に出る。

でも、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070404/1175659350&quot;&gt;λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt;がわからん。&lt;/a&gt;

*1175661441*[圏一般論]ケリーの可換性定理

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070404/1175659350&quot;&gt;λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt;&lt;/a&gt;から、ケリーによる「End(I)が可換モノイド」という素敵な結果が導ける。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/kelly-commutativity.gif&quot; &gt;

λもρも自然変換なので自然性から、f = λ&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;;(I×f);λ&lt;sub&gt;B&lt;/sub&gt;, g = ρ&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;;(g×I);ρ&lt;sub&gt;B&lt;/sub&gt;が出る。

ここで&lt;em&gt;A = B = I と置くと、λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt; なので&lt;/em&gt;、λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt; = s として、

- f = s&lt;sup&gt;-1&lt;/sup&gt;;(I×f);s
- g = s&lt;sup&gt;-1&lt;/sup&gt;;(g×I);s

- f;g = [s&lt;sup&gt;-1&lt;/sup&gt;;(I×f);s];[s&lt;sup&gt;-1&lt;/sup&gt;;(g×I);s] = s&lt;sup&gt;-1&lt;/sup&gt;;(I×f);(g×I);s
- g;f = [s&lt;sup&gt;-1&lt;/sup&gt;;(g×I);s];[s&lt;sup&gt;-1&lt;/sup&gt;;(I×f);s] = s&lt;sup&gt;-1&lt;/sup&gt;;(g×I);(I×f);s

ところが、(I×f);(g×I) = (I;g)×(f;I) = g×f、(g×I);(I×f) = (g;I)×(I;f) = g×f なので、f;g = g;f = s&lt;sup&gt;-1&lt;/sup&gt;;(g×f);s 。

この事実は、アブラムスキー／クックの抽象スカラー概念の基礎。
&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170319368&quot;&gt;k-テンソル圏&lt;/a&gt;で、End(X) = k であるXを単純と呼ぶことにも注意。

*1175674247*[モノイド圏][トレース／コンパクト閉圏]コレは難しい！

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070404/1175659350&quot;&gt;λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt;&lt;/a&gt;だが： http://arxiv.org/abs/math/0004160を経由して、http://www.mathematik.uni-muenchen.de/~pareigis/pa_schft.htmlからアクセスできる次を発見。

- http://www.mathematik.uni-muenchen.de/~pareigis/Vorlesungen/QuantGrp/ln3_2.pdf (&quot;Quantum Groups and Noncommutative Geometry&quot; CHAPTER 3 2. Monoidal Categories)

この論説のP.79に λ&lt;sub&gt;I&lt;/sub&gt; = ρ&lt;sub&gt;I&lt;/sub&gt; の証明があった。が、&lt;em&gt;これ難しいじゃんかよ！！&lt;/em&gt;

</body>
<comments>
<comment>
<username>msakai</username>
<body>&gt; 線形非線形圏（linear non-linear category）というワケワカラン概念&lt;br&gt;&lt;br&gt;実際には素直で単純な概念だと思いますよ。&lt;br&gt;MILLはSMCCで解釈可能なので、これに「!」を加えることを考えるのですが、「!A」は直観主義論理の命題のように振舞うので、CCCとSMCCの間の随伴を加えて解釈します。</body>
<timestamp>1175911641</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>＞ 実際には素直で単純な概念だと思いますよ。&lt;br&gt;えっ、そうなの？&lt;br&gt;「linearなnon-linearってなによ、それ」と思ってしまいました。linear圏とnon-linear（デカルト）な圏を一緒に考えるから linear non-linear ってこと？</body>
<timestamp>1175914581</timestamp>
</comment>
<comment>
<username>msakai</username>
<body>そうです。</body>
<timestamp>1175917890</timestamp>
</comment>
</comments>
</day>
<day date="2007-04-06" title="">
<body>
*1175839633*[リンク] www.emis.de というサイト

- [google: site:www.emis.de &quot;monoidal categories&quot;]

トップは http://www.emis.de/

*1175839634*[モノイド圏]モノイド圏の単位

ヨアヒム・コックがモノイド圏の単位について書いている。

- Title: Elementary remarks on units in monoidal categories
- Author: JOACHIM KOCK
- URL: http://mat.uab.es/~kock/cat/units1.pdf
- 最初の18Pを印刷した。

*1175839635*[人物]Bodo Pareigis

ボゥドゥ・パレイジスかな？？

- http://www.mathematik.uni-muenchen.de/~pareigis/

論文や解説などは：

- http://www.mathematik.uni-muenchen.de/~pareigis/pa_schft.html


</body>
</day>
<day date="2007-04-07" title="">
<body>
*1175917932*[リンク]バエズ／ドーラン（Baez / Dolan）のTQFT論文

- Title: Higher-dimensional Algebra and Topological Quantum Field Theory
- Authors: John C. Baez, James Dolan
- URL: http://www.arxiv.org/abs/q-alg/9503002
- 36ページ

これは以前に印刷したような。The Eckmann-Hilton argumentが記憶にある。

セリンガーが&quot;Idempotents in dagger categories&quot; (by Peter Selinger)のなかで、アブラムスキーより早くダガーコンパクト閉圏を導入したのは、バエズ／ドーランのこの論文（1995）だ、と言っていた。

*1175919685*[圏一般論]無限のベクトルと行列

ケリー双対の話で、左双対を持つが右双対を持たない（逆かも？）例とかあるらしい。それで、少し考えた。

&lt;b&gt;R&lt;/b&gt;の無限列(x&lt;sub&gt;1&lt;/sub&gt;, x&lt;sub&gt;2&lt;/sub&gt;, ...)を考える。その全体を&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;、有限個の成分を除いて0なものを&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;とする。同じように、無限行列を&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞×∞&lt;/sup&gt;、有限個の成分を除いて0な行列を&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞×∞)&lt;/sup&gt;とする。

A∈&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞×∞&lt;/sup&gt;、x∈&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;に対して、Axは計算できるから、Aは&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;→&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;を定義する。特に、対角行列は&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;⊆&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;の埋め込みになる。

B∈&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞×∞)&lt;/sup&gt;、y∈&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;に対して、Byは計算できるから、Bは&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;→&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;を定義する。が、対角行列は定義できない。これは、&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;∞&lt;/sup&gt;⊆&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;(∞)&lt;/sup&gt;とはならないせいだろう。

この状況から、双対を片方しか持たない例が構成できそうだけど。

</body>
</day>
<day date="2007-04-10" title="">
<body>
*1176177141*[プログラム意味論][雑感]マラソンゴール問題

時間的に一連の事象（信号）が発生している状況で、それらの&lt;em&gt;終わり&lt;/em&gt;はどうやって判断するのだろうか。これは非常に難しい問題だ。

例えとして、マラソンのゴール係になったとしよう。ランナーが次々とゴールするのだが、&lt;em&gt;いったいいつ&lt;/em&gt;ゴールを片づけてもいいのだろうか？ 出場者の数がわかっていても、脱落・棄権があるからゴールした人数を確認してもわからない。出場ランナーの完全なリストを持っていても、問題は解決できない。

解決策は：

+ タイムアウト。例えば午後5時でゴールを片づける。
+ 終端指示子。常にランナーの後から走るスタッフを付けて、そのスタッフのゴールをもって終了とする。

これでも完全な解決ではない。

*1176193592*[リンク][からみ系]Carter/Kauffman/Saito

- Title: Diagrammatics, Singularities, and Their Algebraic Interpretations (1996)
- Authors: J. Scott Carter, Louis H. Kauffman, Masahico Saito
- URL: http://citeseer.ist.psu.edu/318992.html
- 80ページ

*1176193943*[プログラム意味論][トレース／コンパクト閉圏]遷移翻訳系モデルに細かい工夫をする

遷移翻訳系（トランスデューサ;transducer, XDCR）を圏を考える際に、細かい工夫をすると議論がスムーズになることに気が付いた。それらの工夫とは：

+ アルファベット（基本記号集合）を点付き集合（pointed set）と考え、クリーネスター・モナドを点付き集合の圏&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt;上で考える。
+ ラベル付き遷移系の拡張として定義した入出力遷移系 X:A→B （X⊆S×(A×B)×S）の圏の上にクリーネスター・モナドを構成する。そのKleisli圏を考える。
+ マルチポート、マルチアルファベットに対してマクロ記号（マクロ信号）という概念を使う。
+ エルゴット（Elgot）遷移パスによるトレース

&lt;h5&gt;点付き集合上のクリーネスター&lt;/h5&gt;

&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt;を点付き集合の圏とする。基点は常にτと書く。τは、インフォーマルには&lt;strong&gt;無音記号&lt;/strong&gt;と解釈する。A∈|&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt;|に対して、A＼{τ} = A' と書くことにする。A&lt;sup&gt;(*)&lt;/sup&gt; = {τ}∪(A')&lt;sup&gt;+&lt;/sup&gt;と定義して、モノイド演算・を次のように定義する。α、β∈(A')&lt;sup&gt;+&lt;/sup&gt;：

+ τ・τ = τ
+ τ・α = α
+ α・τ = α
+ α・β = αβ （連接）

定義から、モノイドとして A&lt;sup&gt;(*)&lt;/sup&gt; ≒ (A')&lt;sup&gt;*&lt;/sup&gt;である。

この定義のメリットは、&lt;b&gt;1&lt;/b&gt; = {τ} が始対象兼終対象（つまり零対象）となり、&lt;b&gt;1&lt;/b&gt;が×と＋の単位にもなる点である。(f:A→B)∈&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt; にもf&lt;sup&gt;(*)&lt;/sup&gt;を定義できる。普通のクリーネスターと同様に、(-)&lt;sup&gt;(*)&lt;/sup&gt;もモナドになる。

&lt;h5&gt;入出力付き遷移系のクリーネスター&lt;/h5&gt;

A, Bが点付き集合として、特別なラベル付き遷移系 X⊆S×(A×B)×S が入出力付き遷移系である。X:A→B と書く。状態空間を明示したいときは X:A→B (S) とする。Xを頂点集合がSであるグラフと考え、グラフXから生成されたパス圏（自由圏）をX&lt;sup&gt;(*)&lt;/sup&gt;とする。ただし、次の点は注意を要する。

+ すべての頂点sに対して、τ/τ（入力τ、出力τ） でラベルされたループ辺s→sを付け加える。（あるいは最初から付いていると仮定する。）
+ このループ辺をid&lt;sub&gt;s&lt;/sub&gt;として扱う。

(-)&lt;sup&gt;(*)&lt;/sup&gt;で定義されたモナドでKleisli圏を考えることができる。その射は、A→B&lt;sup&gt;(*)&lt;/sup&gt;という入出力遷移系である。

&lt;h5&gt;マルチアルファベットとマクロ記号&lt;/h5&gt;

A&lt;sub&gt;i&lt;/sub&gt;∈|&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt;|として、列[A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;]をマルチアルファベットと呼び、マルチアルファベットで型付けされたポートセットを（型付き）マルチポートと呼ぶ。

列[A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;]に対して、[A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;]&lt;sup&gt;#&lt;/sup&gt; := (A&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;(*)&lt;/sup&gt;×...×(A&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;(*)&lt;/sup&gt; と定義する。空列に対しては、[]&lt;sup&gt;#&lt;/sup&gt; := {τ} とする。空列の場合も含めて、マルチアルファベットに対する(-)&lt;sup&gt;#&lt;/sup&gt;の値は|&lt;b&gt;Set&lt;sub&gt;●&lt;/sub&gt;&lt;/b&gt;|に入ることが重要。（実際には、マルチアルファベットのモノイド圏が定義できて、(-)&lt;sup&gt;#&lt;/sup&gt;は関手となるはず。）

Σ = [A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;]がマルチアルファベットのとき、Σ&lt;sup&gt;#&lt;/sup&gt; = [A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;]&lt;sup&gt;#&lt;/sup&gt; := (A&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;(*)&lt;/sup&gt;×...×(A&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;(*)&lt;/sup&gt;を、マルチアルファベットΣの&lt;strong&gt;マクロアルファベット&lt;/strong&gt;と呼び、その元は&lt;strong&gt;マクロ記号&lt;/strong&gt;と呼ぶ。マクロアルファベットは定義より点付き集合となるので、マクロアルファベットに対する入出力付き遷移系が考えられる。

&lt;h5&gt;エルゴット（Elgot）遷移パス&lt;/h5&gt;

T:A×X→B×X が入出力付き遷移系だとする。Tの状態空間を|T|として、T⊆|T|×[(A×X)×(B×X)]×|T| である。Tの元を遷移規則または遷移ステップと呼ぶ。遷移ステップの連続した列を遷移パスと呼ぶ。入出力を in/out で書くとして、次の形の遷移パスを&lt;strong&gt;エルゴット遷移パス&lt;/strong&gt;と呼ぶ。

+ (a, τ) / (b&lt;sub&gt;1&lt;/sub&gt;, x&lt;sub&gt;1&lt;/sub&gt;) a∈A, b&lt;sub&gt;1&lt;/sub&gt;∈B, x&lt;sub&gt;1&lt;/sub&gt;∈X
+ (τ、x&lt;sub&gt;1&lt;/sub&gt;) /  (b&lt;sub&gt;2&lt;/sub&gt;, x&lt;sub&gt;2&lt;/sub&gt;)
+ (τ、x&lt;sub&gt;2&lt;/sub&gt;) /  (b&lt;sub&gt;3&lt;/sub&gt;, x&lt;sub&gt;3&lt;/sub&gt;)
+ 以下同様

エルゴットパスは無限パスだが、終局的に (τ, τ) / (τ, τ) の連続となるパスは&lt;strong&gt;安定エルゴットパス&lt;/strong&gt;と呼ぶ。

(a, τ)の入力の前に、(τ, τ)という入力がn回続いた形をしたエルゴットパスは、遅れnのエルゴットパスと呼ぶ。一般には、すべての遅れを持ったエルゴットパスを考える必要がある。入力がa∈Aであるエルゴットパスとは、ある遅れを持った(a, τ)を入力とするエルゴットパスのことである。エルゴットパスの各遷移で出力されるBの記号をすべて連接したものは、このエルゴットパスの出力と呼ばれる。

エルゴットパスによる入出力は、Tのコピーの長い列を使ってエミュレートできる。


</body>
</day>
<day date="2007-04-11" title="">
<body>
*1176255906*[用語法][圏一般論]Sylleptic category

って何だろう？

- [google:Sylleptic category functor]

*1176256019*[プログラム意味論][トレース／コンパクト閉圏]無音記号と翻訳系の安定性／反射性

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070410/1176193943&quot;&gt;エルゴット・パス&lt;/a&gt;はフィードバック入力を扱うために有効な道具だと思う。が、無限パスになる可能性があるので、このままでは扱いが困難。エルゴット・パスが扱いやすくなる条件を考える。

まず、無音記号の入出力から考える。「入力/出力」という記法を用いる。a≠τとして、a/τ の形の遷移を&lt;strong&gt;受理遷移&lt;/strong&gt;、τ/a の形の遷移を&lt;strong&gt;生成遷移&lt;/strong&gt;、τ/τ は&lt;strong&gt;隠蔽（hidden）遷移&lt;/strong&gt;と呼ぶ。ループの形をした隠蔽遷移は&lt;strong&gt;自明な隠蔽遷移&lt;/strong&gt;、そうでなければ&lt;strong&gt;非自明な隠蔽遷移&lt;/strong&gt;である。

隠蔽遷移が自明なものに限られる系は&lt;strong&gt;安定&lt;/strong&gt;（stable）と呼ぶ。不安定な系では、異なる状態点への遷移が起きてもまったく観測できないことがある。安定な系では、無音記号の入出力があっても、受理または生成として観測にかかる。

すべての状態点に対して自明な隠蔽遷移がある系は&lt;strong&gt;反射的&lt;/strong&gt;と呼ぶ。これは、単に遷移グラフがτ/τラベルで反射的になるということを述べている。

当面、安定かつ反射的な系だけを考えるべきだと思う。その理由は：

- （安定性から）観測不可能な遷移が生じないので、観測的振る舞いで系の構造の推測が容易。
- （反射性から）無音入力により（つまり何もしないのに勝手に）壊れる（未定義状態に陥る）ことがない。ほっておいても壊れない保証がある。
- 結局、観測可能なことが何もおきなければ、内部状態も停留／アイドリングしているだけで、内部的にも何も起きてない。
- 圏論と相性がいい。

安定かつ反射的な系は、（ある程度は）可視／観測可能で（ある程度は）リーズナブルだと言ってよい。

*1176261409*[計算][トレース／コンパクト閉圏][リンク]可逆計算、不可逆計算

これって、メモしておいたっけ？

- Title: QPL 2006 : From reversible to irreversible computations
- Authors: Alexander S. Green, Thorsten Altenkirch
- URL: http://www.mscs.dal.ca/~selinger/qpl2006/PDFS/05-Green-Altenkirch.pdf
- URL (2): http://sneezy.cs.nott.ac.uk/qml/pub/GreenAlten06/GA06qpl.pdf

</body>
</day>
<day date="2007-04-12" title="">
<body>
*1176364385*[からみ系][リンク]カーター／さいとう移動

※「さいとう」を漢字で書けないのは、字がいろいろあるから。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070410/1176193592&quot;&gt;Carter/Kauffman/Saito&lt;/a&gt;とも関係あるのだが、Carter-Saito（あるいはCarter-Rieger-Saito）movie movesというのがある。

- Title: On the Combinatorics of Carter-Rieger-Saito Movies in the Theory of Smoothly Knotted Surfaces in R4 (November 13, 2004)
- Authors: Glenn Lancaster, Richard Larson, Jacob Towber
- URL: http://tigger.uic.edu/~rgl/shrtknots.pdf
- 33ページ

これが一番わかりやすそうかな。ともかくも、手書き風の絵がイッパイあるし(苦笑)。しかしこれは短縮版で、完全版は↓

- Title: Some combinatorial aspects of movies and movie-moves in the theory of smoothly knotted surfaces in R4
- Authors: Glenn Lancaster, Richard Larson, Jacob Towber
- URL: http://arxiv.org/abs/math/0412226
- こっちは100ページ！

うげ、100ページもあるよ。なんか計算機プログラムでの実装を意図しているみたいだ。

- Title: KNOT HOMOLOGY VIA DERIVED CATEGORIES OF COHERENT SHEAVES I, SL(2) CASE
- Authors: SABIN CAUTIS AND JOEL KAMNITZER
- URL: http://www.math.harvard.edu/~scautis/papers/knothomology.pdf
- 52ページ

ウーム、↑わからん。&quot;DERIVED CATEGORIES OF COHERENT SHEAVES&quot;ってことは、代数幾何の割と新しい概念を使っているのだろう、たぶん。

- Title: An invariant of tangle cobordisms (July 30, 2002)
- Authors: Mikhail Khovanov
- URL: http://arxiv.org/math/0207264
- 18ページ

コバノフさんです。18ページだから読んでみるか。↓はよく似た話題を扱っている。

- Title: An invariant of link cobordisms from Khovanov homology
- Authors: Magnus Jacobsson
- URL: http://www.emis.de/journals/UW/agt/ftp/main/2004/agt-4-53.pdf
- 41ページ

*1176370347*[プログラム意味論][トレース／コンパクト閉圏]エルゴット・パス

エルゴット・パスの絵を描いた。
&lt;img src=&quot;http://www.chimaira.org/img2/elgot-path.gif&quot; &gt;
スナップショット1枚のなかで、1回の入力とそれに伴う出力が描いてある。時間は上から下へと経過する。最初のaが入力され、外部への出力b&lt;sub&gt;1&lt;/sub&gt;とフィードバック出力x&lt;sub&gt;1&lt;/sub&gt;が出力される。次は、フィードバックだけが入力へとループする。これを繰り返して、安定（入力も出力も観測されない）状態になる。

以上の時間的過程を空間的構成（configuration）に展開してみると：
&lt;img src=&quot;http://www.chimaira.org/img2/elgot-path2.gif&quot; &gt;
このチェーンの長さが無限なら安心(?)だが、普通の代数的に定義される圏のなかでは無限の構成ができない。極限（圏論の極限）操作が必要だ。必要なチェーン長の限界が前もってわかるなら有限の範囲だけでも構成できるだろうが。


</body>
</day>
<day date="2007-04-14" title="">
<body>
*1176524041*[からみ系][トレース／コンパクト閉圏]絵の描き方とテンソル計算

絵の描き方と対応するテンソル計算について、ザット述べる。まずはこの図。

&lt;img src=&quot;http://www.chimaira.org/img2/diagrams-tensor-notation.gif&quot; &gt;

モノイド圏におけるf:A×B→Cの絵だが、左上はスタック図（サンチャゴ・ダイアグラム）。射が領域で、対象は領域の境界の一部、テンソル積は境界片の直和。この図とポアンカレ双対なのがストリング図。射が点、対象は辺となる。

boxes-and-wires図は中途半端な折衷で、射が箱、対象が辺。テンソル記法は、これらの図（どれでもいいが、ストリング図がいいだろう）をもとに、各対象（型ではなくてインスタンス）を区別できるインデックスを付けて、対象を上下添字で表現。暗黙にインデックスと対象（型）の対応が必要。

いまの図は、上から下の方向だったが、下から上の方向にした図。

&lt;img src=&quot;http://www.chimaira.org/img2/tensor-example.gif&quot; &gt;

記法a&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;ij&lt;/sub&gt;x&lt;sup&gt;i&lt;/sup&gt;y&lt;sup&gt;j&lt;/sup&gt;の解釈はイッパイアルのだが、そのうちの2つを描いておいた。(x×y);a と (η×I×I);(a×(B×A)×(x×y));(C×ε)。この2つの図を簡略化して点と線だけにしたものも描いた。これは、自然演繹証明図やラムダ計算でも出てくる図だ。

&lt;img src=&quot;http://www.chimaira.org/img2/tensor-index-up.gif&quot; &gt;

これ（↑）は、a&lt;sub&gt;ij&lt;/sub&gt;の添字を2つとも上げる例。絵では、双対対象に対するインデックスに星を付けているが、線に向きをつければ星は不要だろう。添字を上げた結果もいろいろな組み合わせがある。それらが同値であることは、コンパクト閉圏やダガーコンパクト閉圏で証明できるが、けっこう面倒。
&lt;hr&gt;

代表的な（って、他にもイッパイあるが）図式法をまとめておく。A/Cはアブラムスキー／クック、Fはファインマン。どちらも方向は&lt;em&gt;下から上&lt;/em&gt;。

&lt;img src=&quot;http://www.chimaira.org/img2/diagram-styles.gif&quot; &gt;

*1176524042*[トレース／コンパクト閉圏]フリップしたケリー双対系

(A&lt;sup&gt;*&lt;/sup&gt;, A, η:I→A&lt;sup&gt;*&lt;/sup&gt;×A, ε:A×A&lt;sup&gt;*&lt;/sup&gt;→I)がケリー双対系になっているとき、(A, A&lt;sup&gt;*&lt;/sup&gt;, η;σ:I→A×A&lt;sup&gt;*&lt;/sup&gt;, σ;ε:A&lt;sup&gt;*&lt;/sup&gt;×A→I)もまたケリー双対系となることは次の図でわかる。

&lt;img src=&quot;http://www.chimaira.org/img2/flip-dual-system.gif&quot; &gt;

クロスオーバーと対称計算だけなので、対称モノイド圏ならOK。


</body>
</day>
<day date="2007-04-17" title="">
<body>
*1176776829*[からみ系][まとめ]さまざまな移動（moves）たち

組み合わせ幾何学的な簡約・変形を移動（move）と呼ぶ習慣がある。で、いろいろな移動をまとめてみる。

中心になるのは、&lt;strong&gt;ライデマイスター（Reidemeister）移動I, II, III&lt;/strong&gt;である。

&lt;img src=&quot;http://www.chimaira.org/img/singulars-and-moves.gif&quot; &gt;

カウフマン（Kauffman）はジグザグ等式を&lt;strong&gt;移動0&lt;/strong&gt;として追加している。&lt;strong&gt;アルチン（Artin）のブレイド関係式&lt;/strong&gt;（ヤン／バクスター関係式）と正負ブレイドの逆関係（β&lt;sub&gt;+&lt;/sub&gt;・β&lt;sub&gt;-&lt;/sub&gt; = 1）は、ライデマイスター移動に含まれる。また、トゥラエフ（Turaev）はライデマイスター移動を拡張した&lt;strong&gt;トゥラエフ移動&lt;/strong&gt;を定義している。イエッター（P.N. Yetter）もトゥラエフと同様な移動を定義している。

- →&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031282&quot;&gt;ライデマイスター、トゥラエフ、マルコフの移動&lt;/a&gt;

結局、アルチン⊆ライデマイスター⊆トゥラエフ／イエッターという増加列ができる。他に、やや傾向が違うが&lt;strong&gt;マルコフ（Markov）移動&lt;/strong&gt;がある。

以下の表にこれらの移動をまとめる。アルチンとマルコフは“一般的呼称”欄に含める。イエッターは“トゥラエフ”欄に含める。他にバエズ／ラングフォード（J.C. Baez, L. Langford）の呼称も“バエズ”欄として記す。

|*特異点 |*一般的呼称|*ライデマイスター|*トゥラエフ|*バエズ|
|変曲点  | ジグザグ等式       | 移動0 |スイッチバック移動 | T-移動|
|尖点    | ヤンキング／マルコフII | 移動I | - | - |
|接触点  | 逆関係／マルコフI      | 移動II | - | - |
|三重点  | ブレイド関係式     | 移動III | - | - |
|極点＋二重点| -              | -    | Ψ移動 | H-移動|

特異点に関しては、上のライデマイスター移動の図を参照。トゥラエフ／イエッターの&lt;strong&gt;Ψ（プサイ）移動&lt;/strong&gt;は以下の図。

&lt;img src=&quot;http://www.chimaira.org/img/proper-turaev-move.gif&quot; &gt;

Ψ移動とクロスオーバー公式の関係は：

&lt;img src=&quot;http://www.chimaira.org/img/turaev2crossover.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img/crossover2turaev.gif&quot; &gt;

- →&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061002/1159750282&quot;&gt;トゥラエフ主移動とクロスオーバー公式&lt;/a&gt;

マルコフ移動は、xとx'が互いに逆なブレイドだとして：

+ b ⇔ x;b;x' （スライディングでキャンセル）
+ b ⇔ (b+1);[(n-1)+σ] （ヤンキングでキャンセル）

トゥラエフ移動では、モノイド圏の公理がそのまま図形的変形のかたちで入ってくる。ただし、交替律は次の形：

- f+g = (f+1);(1+g) = (1+g);(f+1)

この形は便利なので憶えておくとよい（&quot;Introducing categories to the practicing physicist&quot; by Bob Coecke, http://web.comlab.ox.ac.uk/oucl/work/bob.coecke/Cats.pdf に詳しい）。図形的には、横並びの箱の高さを上下にシフトさせる（トゥラエフの&lt;strong&gt;垂直スライド&lt;/strong&gt;）変形になっている。

イブ・ラフォン（Yves Lafont）はこのテの上下シフトを&lt;strong&gt;構文的アイソトピー&lt;/strong&gt;（syntactical isotopy）と呼んでいる（&quot;Equational Reasoning with 2-dimensional Diagrams (1995)&quot; http://citeseer.ist.psu.edu/56012.html）。バエズ／ラングフォードの呼び名は&lt;strong&gt;N-移動&lt;/strong&gt;、コバノフ（Mikhail Khovanov）は&quot;&lt;strong&gt;The height shifting morphism&lt;/strong&gt;&quot;と呼んでいる。

*1176798055*[リンク][からみ系]Pachner移動

[google:&quot;Pachner moves&quot;]で見つかったもの。

- Title: Structures and Diagrammatics of Four Dimensional Topological Lattice Field Theories
- Authors: J. Scott Carter, Louis H. Kauffman, Masahico Saito
- URL: http://www.math.uic.edu/~kauffman/SD4D.pdf
- 62ページ、ダウンロードした

別なCarter-Kauffman-Saitoモノ。ワープロで書いたようだ。絵がイッパイ。

- Title: Discrete quantum gravity
- Author: Ruth M Williams
- Journal: Journal of Physics: Conference Series 33 (2006) 38-48
- URL: http://ej.iop.org/links/r9uhQdH0F/qqiX1bHs2xGusE5-av5vpA/jpconf6_33_004.pdf
- 11ページ、印刷した。

物理はわからん、が、わかりやすいサーベイなんだろう（僕にはわからないけど）。

それにしても、Pachnerって、パッチナー？、パシェナ？？ 見当付かん。

</body>
</day>
<day date="2007-04-18" title="">
<body>
*1176881401*[からみ系]移動（moves）と組み合わせ圏論

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070417/1176776829&quot;&gt;「さまざまな移動（moves）たち」&lt;/a&gt;で移動をまとめたが、移動を主たる手段として&lt;strong&gt;組み合わせ圏論&lt;/strong&gt;とでも呼ぶべきアプローチが考えられるだろう。ちなみに、移動には、4次元内の2-タングルに関するカーター／リーガー／さいとう（Carter-Reiger-Saito）移動や、三角分割を変形するパチナー（Pachner）移動なんてのもある。

組み合わせ圏論は、組み合わせ幾何に圏論を使うことでもあり、圏論を組み合わせ的手法で調べることでもある。高次圏でも有効そうだ。

ラフォン（Lafont）の図式的レイヤー／図式的等式という概念と、LLTの3人のスチル／フリッカー／ムービー（CRSムービー）という概念も組み合わせ圏論の文脈で考えることができそうだ。

- Title: Equational Reasoning with 2-dimensional Diagrams (1995)
- Authors: Yves Lafont
- URL: http://citeseer.ist.psu.edu/56012.html

- Title: On the Combinatorics of Carter-Rieger-Saito Movies in the Theory of Smoothly Knotted Surfaces in R4 (November 13, 2004)
- Authors: Glenn Lancaster, Richard Larson, Jacob Towber
- URL: http://tigger.uic.edu/~rgl/shrtknots.pdf

*1176881492*[からみ系]タングルの圏

トゥラエフ流のタングル（3次元のなかで1次元横木／0次元ペグを持つ1次元ストランドのタングル）の圏は、X&lt;sub&gt;+&lt;/sub&gt;、X&lt;sub&gt;-&lt;/sub&gt;、∪、∩で生成される（&lt;em&gt;I=id&lt;sub&gt;1&lt;/sub&gt;は生成元には入れない！&lt;/em&gt;）。以下、LLT（Glenn Lancaster, Richard Larson, Jacob Towber）の用語法「トランジション」を使うことにする。

&lt;b&gt;N&lt;/b&gt;を対象として生成元{X&lt;sub&gt;+&lt;/sub&gt;、X&lt;sub&gt;-&lt;/sub&gt;、∪、∩}で生成された自由圏に、トゥラエフ移動により同値関係（合同；categorical congruence）を入れる。その商圏がタングルの圏になる。同値関係の基本となるトゥラエフ／イエッター移動は、基本トランジションとみなす。これらの基本トランジションは、特異点をまたいだdeformation（特異点を許すコボルディズム）のbefore/afterを与える。

基本トランジションは：

+ ジグザク等式＝スイッチバック移動
+ Ψ（プサイ）移動
+ フリップターン等式＝ライデマイスター移動I

の3種となる。&lt;em&gt;フリップターンはヤンキングと同値&lt;/em&gt;である。
フリップターン≒ヤンキングはライデマイスター移動Iでもあるが、ライデマイスター移動Iは、&lt;em&gt;絵の描き方によりフリップターンにもヤンキングにも見える。&lt;/em&gt;

Ψ移動がクロスオーバーと同値であることはすぐわかる（→&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061002/1159750282&quot;&gt;「トゥラエフ主移動とクロスオーバー公式」&lt;/a&gt;）。ところが、クロスーオーバーは、(f+1);σ = σ;(f+1)、(1+f);σ = σ;(f+1) という等式に対応する。これは、一般のスライディングスワップ (f+g);σ = σ(g+f)の特殊ケースだが、この特殊ケースからスライディングスワップも導ける。よって、適当な前提のもとでは：

- Ψ移動＝クロスオーバー＝スライディングスワップ

トゥラエフのタングルの圏の部分圏や商圏として次のものが得られる。

+ ブレイドの圏（亜群）
+ 対称（置換）の圏（亜群）
+ 結び目の圏（結合もテンソル積も直和）
+ ループの圏（結合もテンソル積も直和）
+ テンパリー／リーブ圏
+ ジョーンズ代数
+ コバノフが定義した偶数点（ペグが偶数個）からなり、交差を許さず電荷は保存する圏

少し一般化すれば、コンパクト閉圏、軸的圏、堅い圏などにもなる。

*1176882013*[リンク][からみ系]Pachner移動に関連して

Pachner移動を理解するには、次の3つを読めばいいような気がするが、読んでる気力も余裕もまったくない、残念。

- Title: A History of n-Categorical Physics (April 2, 2005)
- Authors: John C. Baez, Aaron D. Lauda
- URL: http://math.ucr.edu/home/baez/qg-winter2005/history.pdf
- 44ページ、印刷してない

- Title: Diagrammatics, Singularities, and Their Algebraic Interpretations (1996)
- Authors: J. Scott Carter, Louis H. Kauffman, Masahico Saito
- URL: http://citeseer.ist.psu.edu/318992.html
- 80ページ、最初の数ページを印刷。

- Title: Structures and Diagrammatics of Four Dimensional Topological Lattice Field Theories
- Authors: J. Scott Carter, Louis H. Kauffman, Masahico Saito
- URL: http://www.math.uic.edu/~kauffman/SD4D.pdf
- 62ページ、31ページ分を印刷

</body>
</day>
<day date="2007-04-20" title="">
<body>
*1177025950*[課題][プログラム意味論](仮称)一様性二重圏

トレース、隠蔽（hiding）、模倣、関数性、内部意味論などの定式化のために二重圏を使うことを考えている。とりあえず、二重圏の用語法を固定しておく。D = (D&lt;sub&gt;0&lt;/sub&gt;, D&lt;sub&gt;1&lt;/sub&gt;, ι:D&lt;sub&gt;0&lt;/sub&gt;→D&lt;sub&gt;1&lt;/sub&gt;, δ, γ:D&lt;sub&gt;1&lt;/sub&gt;→D&lt;sub&gt;0&lt;/sub&gt;)が二重圏として：

| Obj(D&lt;sub&gt;0&lt;/sub&gt;) | 対象 |
| Mor(D&lt;sub&gt;0&lt;/sub&gt;) | 垂直射 |
| Obj(D&lt;sub&gt;1&lt;/sub&gt;) | 水平射 |
| Mor(D&lt;sub&gt;1&lt;/sub&gt;) | セル |
| comp(D&lt;sub&gt;0&lt;/sub&gt;) | 垂直射の垂直結合 |
| comp(D&lt;sub&gt;1&lt;/sub&gt;) | セルの垂直結合 |
| comp(D) | 水平射／セルの水平結合 |

Dの垂直射の圏（D&lt;sub&gt;0&lt;/sub&gt;）をDの垂直圏と呼び V&lt;sub&gt;D&lt;/sub&gt;と書く。単にVとも書く（V=D&lt;sub&gt;0&lt;/sub&gt;である）。Dの水平射の圏（Obj(D&lt;sub&gt;0&lt;/sub&gt;)とObj(D&lt;sub&gt;1&lt;/sub&gt;)からなる圏）をH&lt;sub&gt;D&lt;/sub&gt;と書く。単にHとも書く。

次の状況を考える。

+ V, Hにはモノイド構造が入っている。|V|=|H|でモノイド積は共通。
+ 閉包トレースtrは、H(A, B)→H(A, B)という写像である。
+ 隠蔽hd&lt;sub&gt;X&lt;/sub&gt;は、H(A×X, B×X)→H(A, B)である。
+ tr;tr = tr, hd;tr = tr;hd;trなどを満たす。
+ tr(f) = f であるfを関数射と呼ぶ。
+ trもhdもトレースのように振る舞う。特に、関数射に対するhd;trは通常のトレースTrを再現する。
+ i:A→A', j:B→B'が垂直射、α::(f:A→B)⇒(g:A'→B') がi, jを境界とするセルのとき、tr(f);j = i;tr(g) : A→B' in H が成立する。

最後の条件は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b0%ec%cd%cd%c0%ad&quot;&gt;一様性&lt;/a&gt;原理で、セルαが模倣であることを定式化している。i, jは入出力の変換である。α::f→g があるとき、fとgはあまり区別できないことを意味する。

D全体を公理化するのは難しい。一様トレース圏（Uniformly traced category）Cから作ったDで調べよう。Cの一様性（uniformity, uniform class, the class of uniform morphisms）をUとする。

+ Dの対象はCの対象。
+ Dの垂直射はCの射。
+ Dの水平射f:A→Bは、Cの射f:A×X→B×X。Xをfの状態対象または隠蔽対象（hidden object）と呼び、f:A→B /X のように書く。
+ Dのセルα::(f:A→B /X)⇒(g:C→D /Y)は、(i:A→C, j:B→D in C; u:X→Y in U)のこと。ただし、(i×u);g = f;(j×u) : A×X→D×Y が成立している。

Dのセルの定義（Cの一様性原理）から、Dで一様性「α::f→g ⇒ tr(f);j = i;tr(g)」が成立する。

&lt;b&gt;課題：&lt;/b&gt; 知られているCから二重圏Dを作れ。Cは、エルゴット・オートマトンの圏、有限ラベル付き遷移系の圏、コンポネントの圏など。


</body>
</day>
<day date="2007-04-24" title="">
<body>
*1177401384*[リンク][からみ系]Fukuma-Hosono-Kawai

バエズがしばしば引用するFukuma-Hosono-Kawaiは次：

- Title: Lattice Topological Field Theory in Two Dimensions
- Authors: M.Fukuma, S.Hosono, H.Kawai (Submitted on 28 Dec 1992)
- URL: http://arxiv.org/abs/hep-th/9212154

いろいろ調べて、Fukuma-Hosono-Kawaiは次の人だと推測。

- M.Fukuma 京都大学 福間将文(FUKUMA Masafumi)助教授
- S.Hosono 東京大学 細野忍(HOSONO Shinobu)助教授
- H.Kawai 理化学研究所 川合光(KAWAI Hikaru)主任研究員

所属と肩書きは&lt;em&gt;あやしい&lt;/em&gt;が、固有名詞は間違いないだろう。


</body>
</day>
<day date="2007-04-25" title="">
<body>
*1177460181*[リンク][雑感][課題][復習]たまには振り返る

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=notion%20of%20process&quot;&gt;notion of process&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b6%af%a5%e2%a5%ca%a5%c9&quot;&gt;強モナド&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b2%c4%b4%b9%a5%e2%a5%ca%a5%c9&quot;&gt;可換モナド&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b2%c4%b4%b9%b6%af%c5%d9&quot;&gt;可換強度（テンソル強度）&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%bd%c5%be%f6%a5%e2%a5%ca%a5%c9&quot;&gt;重畳モナド&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Circ%20Kleisli&quot;&gt;Circ Kleisli&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%e2%a5%ca%a5%c9%20%ca%ac%c7%db&quot;&gt;モナド 分配&lt;/a&gt;

</body>
</day>
<day date="2007-04-26" title="">
<body>
*1177558963*[プログラム意味論][からみ系][課題]インターリーブ定理とTuraevゲーム

X, Yが状態空間（圏論的には単に対象）として、A, Bを遷移（つまり、endomorphism）の集合とする。A∪{id&lt;sub&gt;X&lt;/sub&gt;} = A&lt;sub&gt;+&lt;/sub&gt;, B∪{id&lt;sub&gt;Y&lt;/sub&gt;} = B&lt;sub&gt;+&lt;/sub&gt;とする。A, A&lt;sub&gt;+&lt;/sub&gt;, B, B&lt;sub&gt;+&lt;/sub&gt; などを構文的存在（ラベル、名前）と同一視して、議論を構文領域に持ってくる。

それで、次の3者は全然違う（星印はクリーネスター）。

+ A&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;×B&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;
+ (A&lt;sub&gt;+&lt;/sub&gt;×B&lt;sub&gt;+&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;
+ (A&lt;sub&gt;+&lt;/sub&gt;+B&lt;sub&gt;+&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;

しかし、適当な同値関係≡&lt;sub&gt;1&lt;/sub&gt;, ≡&lt;sub&gt;2&lt;/sub&gt;, ≡&lt;sub&gt;3&lt;/sub&gt;を入れると、

- (A&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;×B&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;)/≡&lt;sub&gt;1&lt;/sub&gt; = (A&lt;sub&gt;+&lt;/sub&gt;×B&lt;sub&gt;+&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;/≡&lt;sub&gt;2&lt;/sub&gt; = (A&lt;sub&gt;+&lt;/sub&gt;+B&lt;sub&gt;+&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;/≡&lt;sub&gt;3&lt;/sub&gt;

となる。このテの主張が&lt;strong&gt;インターリーブ定理&lt;/strong&gt;。

インターリーブ（interleave, interleaving）定理は、コンピューティング・サイエンス的解釈も圏論的解釈も&lt;em&gt;素朴・自然&lt;/em&gt;に行える。そのときの鍵は次の&lt;strong&gt;シフト可換律&lt;/strong&gt;（スライディング可換律）。

- (f×Y);(X×g) = (X×g);(f×Y)

f&lt;sup&gt;-&lt;/sup&gt; := (f×Y), &lt;sup&gt;-&lt;/sup&gt;g := (X×g) と略記すれば、

- (f&lt;sup&gt;-&lt;/sup&gt;)(&lt;sup&gt;-&lt;/sup&gt;g) = (&lt;sup&gt;-&lt;/sup&gt;g)(f&lt;sup&gt;-&lt;/sup&gt;)

と、確かに可換律の形をしている。

コンピューティング・サイエンス的には、次の3者の同値性を主張している。

+ マルチ（とりあえず2つ）プログラムの分離2CPU完全並列実行による効果
+ マルチプログラムのクロック同期2CPU完全並列実行による効果
+ マルチプログラムの1CPU時分割直列（順次）実行による効果

圏論的には、シフト可換律を、

- f×g = (f×Y);(X×g) = (X×g);(f×Y)

と書き換えると、これは交替律と同値な等式となる。つまり、&lt;em&gt;シフト可換律≒交替律≒双関手性&lt;/em&gt;（なお、単位に関する双関手性は、2CPUにおけるnop, idle, time-fillerの定義となる）。

インターリーブ定理の圏論的解釈は、（対称とは限らない）モノイド圏の計算法則を与える。f&lt;sub&gt;1&lt;/sub&gt;, ..., f&lt;sub&gt;n&lt;/sub&gt;∈End(X) とg&lt;sub&gt;1&lt;/sub&gt;, ..., g&lt;sub&gt;m&lt;/sub&gt;∈End(Y)に対して、次の3つの表現が同じ射を与える。（便宜上、n &lt; m として書く。）

+ (f&lt;sub&gt;1&lt;/sub&gt;; ...;f&lt;sub&gt;n&lt;/sub&gt;)×(g&lt;sub&gt;1&lt;/sub&gt;; ...;g&lt;sub&gt;m&lt;/sub&gt;)
+ (f&lt;sub&gt;1&lt;/sub&gt;×g&lt;sub&gt;1&lt;/sub&gt;); ...;(f&lt;sub&gt;n&lt;/sub&gt;×g&lt;sub&gt;n&lt;/sub&gt;);(X×g&lt;sub&gt;n+1&lt;/sub&gt;); ...;(X×g&lt;sub&gt;m&lt;/sub&gt;)
+ (f&lt;sub&gt;i&lt;/sub&gt;&lt;sup&gt;-&lt;/sup&gt;)と(&lt;sup&gt;-&lt;/sup&gt;g&lt;sub&gt;j&lt;/sub&gt;)を適当にインターリーブして結合した列

n≠m のときでもid（nop）を挟んで調整できる点に注目（この点は圏論的計算ではありまり&lt;em&gt;意識されてない&lt;/em&gt;）。f&lt;sub&gt;i&lt;/sub&gt;, g&lt;sub&gt;j&lt;/sub&gt; がendomorphismであることは実は本質ではなく、ずっと一般的な状況でもOK。
&lt;hr&gt;
さて、&lt;span style=&quot;font-size:large;&quot;&gt;&lt;em&gt;問題はここから&lt;/em&gt;&lt;/span&gt;で、同値関係≡&lt;sub&gt;1&lt;/sub&gt;, ≡&lt;sub&gt;2&lt;/sub&gt;, ≡&lt;sub&gt;3&lt;/sub&gt;をどう定式化するか？ もちろん、代数的／組み合わせ的な定義はできるが、それじゃつまらないし、わかりやすくない。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070418/1176881401&quot;&gt;組み合わせ圏論&lt;/a&gt;を使いたい。

トゥラエフの輪切り（スライス）とトゥラエフ移動（ライデマイスター＋ジグザグ（スイッチバック）＋Ψ（プサイ））、ラフォン（Lafont）の図式的レイヤー／図式的等式、ランカスター／ラーソン／タウバー（Lancaster, Larson, Towber）のイベント／トランジション／スチル／フリッカー／ムービーなどを、ゲーム風に仕立てる。

&lt;a target=&quot;_blank&quot; href=&quot;http://www.chimaira.org/docs/PictorialCategoryTheory.htm&quot;&gt;『お絵描き圏論』&lt;/a&gt;でも、コンパクト閉圏の計算はゲーム風だと言ったが、それをチャント定式化するってわけ。そのゲームを&lt;strong&gt;Turaevゲーム&lt;/strong&gt;と呼ぼう。

Turaevゲームは矩形のゲーム盤にコマ（ブロック）を置いて／動かして&lt;em&gt;一人で&lt;/em&gt;行う。盤は横の行（段）に区切られていて、1つの行には（通常は）1個のコマしか置けない。空白部分はidと解釈する。盤の矩形部分をリージョンと呼ぶことにする（ストリング図ではチャンバーと呼んでいた）。ゲームは次の操作で進行する。

- 盤上のリージョンに注目（フォーカス）して、ルール（トランジション・ルール）に従って別なリージョンに置き換える。

ゲーム盤自体が変形（縮小拡大）することもある。盤自体と盤面状況（コマの配置）の変化列がゲームの履歴となる。2つの盤面状況（シーン？ スチル？）が、とあるTuraevaゲームで繋げるとき同値として同値関係が入る（ゲームは可逆）。

&lt;span style=&quot;font-size:large;&quot;&gt;&lt;b&gt;やること：&lt;/b&gt;&lt;/span&gt;

+ &lt;b&gt;TODO:&lt;/b&gt; Turaevゲームをもっとチャント定義。
+ &lt;b&gt;TODO:&lt;/b&gt; Turaevゲームの実例（トランジション・ルール）を作る。
+ &lt;b&gt;TODO:&lt;/b&gt; Turaevゲームと、ラフォンの定式化、ランカスター／ラーソン／タウバーの定式化との対応関係／用語法の違いをまとめる。
+ &lt;b&gt;TODO:&lt;/b&gt; Turaevゲームを使ってインターリーブ型の定理（異なる表現の同値類の同一性）を示す。
+ &lt;b&gt;TODO:&lt;/b&gt; インターリーブ定理の比喩的な分かりやすい／面白い説明を考える。
+ &lt;b&gt;TODO:&lt;/b&gt; Turaevゲームの幾何学的な合理化を考える。

幾何学的な合理化とは、Turaevゲームにより幾何学的変形や&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070307/1173238168&quot;&gt;幾何学的単純化&lt;/a&gt;（正規化）が実際に行えることを示す -- ホントにやると難しいから、まー、直感的な納得感があればいい。

*1177562726*[からみ系][トレース／コンパクト閉圏]対蹠作用、直進圏、最小自由生成

伝統的な用語法ではどうも整理がつかないので、新しい用語法を導入してみる。

まず、対象上双対作用（dualizer on objects）と呼んでいたモノを&lt;strong&gt;対蹠作用(素)&lt;/strong&gt;（antipode/antipodal operator）または単に対蹠（antipode）と呼ぶことにする。双対、対合、共役、随伴、スター、ダガーなどの言い方もあるが、対象上でのみ定義されている点を強調して、別な呼び方を選んだ((Hopf代数では対蹠を使っているけど。))。

原則的に、対蹠(-)&lt;sup&gt;*&lt;/sup&gt;はモノイド圏で定義され：

+ A&lt;sup&gt;**&lt;/sup&gt; = A （対合性）
+ (A×B)&lt;sup&gt;*&lt;/sup&gt; = B&lt;sup&gt;*&lt;/sup&gt;×A&lt;sup&gt;*&lt;/sup&gt;
+  I&lt;sup&gt;*&lt;/sup&gt; = I

ほんとのイコールなら厳密な対蹠、自然同型なら弱対蹠。対蹠が指定された圏を&lt;strong&gt;対蹠圏&lt;/strong&gt;（antipodal category）と呼ぶことにする。

対蹠圏(C, ×, I, -&lt;sup&gt;*&lt;/sup&gt;)に、さらにケリー単位／余単位η、εが付いてジグザグ等式を満たすとき、&lt;strong&gt;直進圏&lt;/strong&gt;（straight/straightening category）と呼ぶことにする（剛性と同じく、曲がったモノがまっすぐになることから命名）。直進圏はほとんど&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070329/1175144493&quot;&gt;軸的圏&lt;/a&gt;だが、射の双対は考えない。直進圏は&lt;em&gt;いずれ不要になる概念&lt;/em&gt;かもしれないが、暫定的にでも整理のために導入する。

実は、最小の直進圏と、その直進圏にブレイディング／対称ブレイディングをいれたものを考えたい。表にすると：

|*関係する人名 |*（固有の）生成元 |*圏の種類 |
|コバノフ      |∪,∩| 直進圏 |
|トゥラエフ    |X&lt;sub&gt;+&lt;/sub&gt;, X&lt;sub&gt;-&lt;/sub&gt;, ∪,∩| ブレイド直進圏 |
|トゥラエフ    |X, ∪,∩| 対称直進圏 |
|テンパリー／リーブ |H       | テンパリー／リーブ圏 |

Hは(∪;∩)を表す。テンパリー／リーブ圏では、∩と∪はHのなかに閉じ込められているので、ジグザグ等式を直接は書き下せない。が、例えば次のような等式が示せる。

- [(H+1);(1+H)];[(1+H);(H+1)] = ○・H

○=(∩;∪)はループで、抽象スカラーなので、スカラー乗法“・”が定義できる。テンパリー／リーブ圏の適当なテンソル圏Cへの表現Ψがあるとき、Ψ(○)はCのスカラーで、ループの（存在が導く）乗法因子を定義する。
&lt;hr&gt;
それで、単一の対象A（single generating object）に対してA&lt;sup&gt;*&lt;/sup&gt; = A （自己双対、自明対蹠）とした最小直進圏、最小ブレイド直進圏、最小対称直進圏を&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177558963&quot;&gt;Turaevゲーム&lt;/a&gt;で定義したい。

*1177580259*[からみ系][計算]レイヤーとかフリッカーとか

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177558963&quot;&gt;Turaevゲーム&lt;/a&gt;のために、参考：

ラフォンは次の形をレイヤーと呼んでいる。αは基本記号で、レイヤーは最小なスライスと同じこと。
&lt;img src=&quot;http://www.chimaira.org/img2/lafont-layer.gif&quot; &gt;
リージョンwをw'を入れ替える操作は次の図：
&lt;img src=&quot;http://www.chimaira.org/img2/lafont-equation.gif&quot; &gt;
この操作は可逆で等式に対応。

一方、LLT（ランカスター／ラーソン／タウバー）のフリッカーは次：
&lt;img src=&quot;http://www.chimaira.org/img2/LLT-flicker.gif&quot; &gt;
フリッカーは2つのスチル（beforeとafter）から構成され、スチル内のリージョンUをVに置き換える（U→Vはトランジションと呼ぶ）。なお、フリッカーの連続をムービーと呼ぶ。

</body>
</day>
<day date="2007-04-27" title="">
<body>
*1177637759*[リンク][プログラム意味論][圏一般論]A. Kurz, B. Jacobs, P.J. Scott, Ruttenの教科書

カーツが練習問題などが付いた教科書風論説を書いている。

- Title: Coalgebras, Stone Duality, Modal Logic (26th June 2006)
- Author: Alexander Kurz
- URL: http://www.cogsci.uni-osnabrueck.de/CL/conferences/ESSLLI2006/courses/Kurz.CoalgebrasStoneDualityModalLogic.pdf
- 110ページ

バート・ヤコブスは次の本を出版予定。現在、ドラフトがダウンロード可能。

- Title: Introduction to Coalgebra -- Towards Mathematics of States and Observations
- Author: B. Jacobs, 
- URL: http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf
- 2upで81ページ

教科書的なものといえば：

- Title: Some Aspects of Categories in Computer Science (1998)
- Author: P.J. Scott
- URL: http://linear.di.fc.ul.pt/handbook.ps
- 71ページ

- Title: Universal Coalgebra: a Theory of Systems (1996)
- Author: J.J.M.M. Rutten
- URL: http://citeseer.ist.psu.edu/rutten96universal.html
- 57ページ

*1177644022*[プログラム意味論][余代数]余代数とプロセス

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070427/1177637759&quot;&gt;カーツの教科書&lt;/a&gt;の最初（9ページ）に面白い表があった。

|* X上の余代数    |* プロセス |
| X→1 | 停止（事実上何も起きない） |
| X→A | a∈Aを1回だけ出力（繰り返しはない） |
| id: X→X | 無限に動き続けるメトロノーム |
| X→A×X | Aのストリーム（無限リスト） |
| X→A×X + 1 | Aの有限／無限リスト(1は停止） |

状態空間Xへの出力値が時間(next)を生成している。X以外への出力値だけなら、それは時間を止めて（継続を中断して）いる。

*1177656071*[からみ系][トレース／コンパクト閉圏]直進圏とその変種

昨日の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177562726&quot;&gt;「対蹠作用、直進圏、最小自由生成」&lt;/a&gt;の補足。ライデマイスター／トゥラエフ移動の関係式を次のように番号付ける。

- 0 -- ジグザグ（カウフマンによる番号）
- I -- フリップターン
- II -- ブレイド逆元
- III -- ブレイド関係式（アルチン）
- IV -- トェラエフ／イエッターのΨ移動

I', II', III'は、対応する対称ブレイドのバージョン。

使用する（固有の）生成元などを表にまとめる。×は両立不可能を示す。

|*∪ |* ∩|* X&lt;sub&gt;+&lt;/sub&gt; |* X&lt;sub&gt;-&lt;/sub&gt; |* X |* 圏 |* 関係 |
| -  | -  | ○             | ○             | × |ブレイド亜群|II, III |
| -  | -  | ×             | ×             | ○ |置換亜群|II', III' |
| ○ | ○  | -             | -             | -  |直進圏  | 0 |
| ○ | ○  | ○            | ○           | ×  |ブレイド直進圏  | 0からIV |
| ○ | ○  | ×            | ×         | ○  |対称直進圏  | 0, I'からIV' |

テンパリー／リーブ圏やコバノフの偶数個数・電荷保存の圏なども変種として考えることができる。対蹠（荷電、極性、符号、向き、双対、随伴、共役）を考えるとさらに変種が増える。

*1177658550*[リンク][圏一般論][TQFT]Yetterの線形代数と行列計算

- Title: Categorical Linear Algebra -- A Setting for Questions from Physics and Low-Dimensional Topology
- Author: David N. Yetter
- URL: http://math.ucr.edu/home/baez/yetter.pdf
- 19ページ、印刷済み

これ、実はムジュカシイのだけど、いつも使っている行列の絵（片方向二部グラフ）&lt;em&gt;だけ&lt;/em&gt;は理解できる。この二部グラフの図示に関して、イエッターは次のように言っている。

+ 辺ラベル（係数）が0なら、その&lt;em&gt;辺を取り除く&lt;/em&gt;。
+ 両端が同じ辺が複数あるなら、ラベル（係数）を足して&lt;em&gt;辺を1本に集約する&lt;/em&gt;。

これは、グラフの簡約（正規化、execution）ルールになっている。このルールと、頂点形状が同じグラフの重ね合わせ、境界グルーイングを組み合わせると、行列の和と積の計算になる。特に、たくさん（実は少数でもいいが）のグラフを重ね合わせ／グルーイングしたとき、その簡約形は経路和で与えられることが素直に納得できる。

片方向二部グラフを平面ではなくて、3次元（以上の）空間で考えたほうが自然かもしれない。たとえば、f∨g = Δ;(f×g);∇ というタイプの等式を「右辺で左辺を定義」と見るのではなくて、f∨g を前もって定義された重ね合わせとみるなら、空間内で考えたほうが直接的な理解ができる。

一般の境界付き有向グラフでは：

- 始境界点から到達不可能／通行不可能な頂点と辺は取り除いていい（ゴミ集め、ゴミ捨て）。
- 辺ラベルがid（恒等）である辺1本だけが出てる頂点、その辺1本だけが入る頂点があるとき、両端の2頂点を同一視して1頂点に集約する。
- 辺ラベルがidである2辺で双方向に結ばれた2頂点は1頂点に集約する。
- (他にあるかな？)

などのルールも適用できる。

</body>
</day>
<day date="2007-05-01" title="">
<body>
*1177989371*[圏一般論][説明][お絵描き]結合律をお絵描き

&lt;img width=&quot;544&quot;  src=&quot;http://www.chimaira.org/img2/assoc-diagram.gif&quot;&gt;

+ まず、平面をV字形に折ります。
+ 折り目の直線に、下に延びる半平面（壁）を接着します。
+ 絵を描きやすいように、V字を平らに近いくらいに拡げておきます。
+ 別な平面を、3点α、β、γが交点になるように、上からグサッと突き立てます。
+ 向こう側（点αのところ）、まん中へん（点βのところ）、手前側（点γのところ）で、包丁(?)を入れて図形をサクッと切ります。

3箇所の断面の絵（角度は再び鋭くなるように調整）は、結合律：(a+b)+c = a+b+c = a+(b+c) 。

さて、まだ続きがあります。&lt;b&gt;[追記]&lt;/b&gt;床に書いてあるDAは、&lt;b&gt;DB&lt;/b&gt;の間違い。ウーン、どこか間違うな、僕は。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;img width=&quot;544&quot; src=&quot;http://www.chimaira.org/img2/assoc-diagram-2.gif&quot;&gt;

+ 角度や長さなどは本質的ではないので、思い切ってV字形を平らにしました（描きやすいので）。
+ 空間全体が平面／半平面により4つの部屋（領域）に区切られるので、それにA, B, C, Dと名前を付けます。床の下がAとD、床の上がBとC。
+ 部屋Aと部屋Bを仕切る壁にはABという具合に、壁にも名前を付けます。壁は&lt;em&gt;6面&lt;/em&gt;あります。
+ 点βから出る&lt;em&gt;4本&lt;/em&gt;の半直線（直線ではありません！）にも名前を付けます。部屋A, B, Cから見える（部屋Dからは見えない）線ならABCと名付けます。

念のため、向こう側、まん中へん、手前側の断面も描いてあります。

こうやって作った図形のポアンカレ双対を取ります。次のような対応：

- 部屋 ⇔ 頂点
- 2部屋を仕切る壁 ⇔ 2頂点を結ぶ辺
- 3部屋から見える半直線 ⇔ 3頂点からなる3角形の面

すると、4面体ABCDとなり、点βが4面体の内部領域に対応します。この4面体を一種の計算デバイスと考えます。

+ 辺（双対的には壁）が入出力を行う。AB, BC, CDを入力、ADを出力に使う。
+ 面（双対的には半直線）が処理を行う。

このとき、辺ACを内部入出力（計算の中継）に使った結果と辺BCを内部入出力に使った結果が等しいことを図示すると、結果的に矢印を使った (f;g);h = f;(g;h) の絵が再現します。これのポアンカレ双対を取れば、最初のツリー状の結合律の絵に戻ります。

*1177989443*[TQFT][説明][お絵描き]三角形を細分しても計算結果は同じにできる

コピー（のようなもの；Δと書かれることが多い）と足し算（のようなもの；∇と書かれることが多い）のあいだに、フロベニウス代数の法則（(Δ×1);(1×∇) = ∇;Δ、ズボン2本を逆さまに繋いだ図形の性質）とベキ等法則（Δ;∇ = 1、輪が生まれたり消えたり）が成立しているなら、三角形の星状細分に対して不変な計算ネットワークを構成可能なことは、次の絵からわかります((実際には、∇は足し算というより掛け算として現れます。ベキ等性（に対応する性質）は「特殊」（special）というショウモナイ形容詞で表現されることもあります。no-hole条件、バブル変換に対応すると思われる。))。

&lt;img width=&quot;544&quot; src=&quot;http://www.chimaira.org/img2/triangulation.gif&quot;&gt;

絵算って便利でしょ :-)

</body>
</day>
<day date="2007-05-06" title="">
<body>
*1178446182*[用語法][トレース／コンパクト閉圏]ソブリン（sovereign）圏

やっと連休が明ける（あしたが月曜）。ハー。リハビリしとこう。

右ケリー双対と左ケリー双対が一致することを、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070331/1175325278&quot;&gt;「等方的に堅い」&lt;/a&gt;（isotropically rigid）とか呼んでみたのだけど、既存の用語があった -- &lt;em&gt;ソブリン（sovereign）圏&lt;/em&gt;。

双対性を持つ圏を、一般的に堅い圏（rigid category）と呼ぶが、&lt;strong&gt;自律圏&lt;/strong&gt;（autonomous category）とも呼ぶ。スター自律圏は自律圏の特殊ケースだからマー辻褄はあう。それで、ソブリンは「主権を有する、独立した、最高権力を有する」とかの意味。これはおそらく自律（autonomous）よりさらに強く&lt;em&gt;自己完結&lt;/em&gt;している、ということなのだろう。

文字通り“こなれてない”かたい言葉「堅い圏」はもうやめて、これから「自律圏」を使おうかと思う。

- 左自律圏 -- 任意の対象に左双対が存在する。
- 右自律圏 -- 任意の対象に右双対が存在する。
- （両側）自立権 -- 右自律かつ左自律

ソブリン圏は、両側自律圏であり、右双対と左双対が一致するもの。カタカナを使うのは癪にさわるので&lt;strong&gt;自足圏&lt;/strong&gt;と呼んでおこう((「ソブリン」も語感は悪くないと思う。))。自律性（autonomy）、自足性（sovereingnty）なんて言葉も使う。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070403/1175569568&quot;&gt;系統図&lt;/a&gt;もこの用語法で描き替えたほうがいいな。

面白いことに、リボン圏はブレイドとねじれ（ツイスト）を持つので、ブレイド／ねじれの性質から、右双対から左双対を定義できて、それが一致することが証明できる(たぶん、やってないけど）。よって、リボン圏は自足圏の例となる（はず）。
</body>
</day>
<day date="2007-05-09" title="">
<body>
*1178673698*[課題][モナド][モノイド圏]モノイドとベック・スワッパー

P. Eklund, M.A. Galan, J.Medina, M. Ojeda-Aciego, A. Valverde &quot;Powersets of Terms and Composite Monads&quot; ( http://www.cs.umu.se/research/reports/2004/007/part1.pdf) にあるモナドと分配法則の議論は、非ブレイド・モノイド圏（&lt;em&gt;対称性がまったくない&lt;/em&gt;圏）内のモノイドの議論で置き換えられる。

M=(M, m, e)とN=(N, n, f)がモノイド圏Cのモノイドのとき、s:N×M→M×Nがベック（Beck）スワッパーであるとは、ベックの法則（4つの等式）を満たすことだとする。2つのモノイドM, Nとスワッパーsの組 (M, N, s)とM×N上のモノイド構造に関して次が成立する。

+ スワッパーsがあれば、M×N上にモノイド構造を作れる。
+ M×N上のモノイド構造が、M×f:M→M×N、e×N:N→M×Nがモノイド射で中間単位律（middle unitary law）を満たすならスワッパーを持つ。
+ M×N上のモノイド構造が、左M作用（に近いもの）M×(M×N)→M×Nと右N作用(M×N)×N→M×Nを許すなら、スワッパーを持つ。

だいたいのところ、「M×N上の“良い”モノイド構造⇔ベック・スワッパーの存在」となる。Eklund等の論文の当該部分をモナドから切り離して書き直すといいと思う。

*1178673728*[課題][圏一般論]豊饒圏を関手で拡張すること

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070217/1171696754&quot;&gt;「V-豊饒圏をV上のモナドで拡張する」&lt;/a&gt;の件。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060912/1158031284&quot;&gt;「セリンガーの論文」&lt;/a&gt;で紹介しているhttp://www.mathstat.dal.ca/~selinger/papers/catasynch.pdfの20ページあたりに、T構成として書いてあるのだった。ただし、セリンガーの用語法はあまりよくないので、もっと一般的な概念／用語を使うべきだろう。

*1178675482*[雑記]檜山の状況

体調が悪い。のだけど、メモ編に書きたいことがある。少し休んでから書こうかな、書けたらエライ＞俺

*1178698225*[モノイド圏]さまざまなモノイド関手の定義

モノイド関手（monoidal functor）といっても色々ある。まとめておく。CとDがモノイド圏で、モノイド積／モノイド単位は×とIで表す。関手Fと、自然変換φ::(F×F);×⇒×;Fと、Dの射j:I→F(I)の組(F, φ, j)がモノイド関手である定義を述べる。

おおよそ、次のような等式もどきが成立すればいい。

+ F(A)×(F(B)×F(C)) ≒ F[(A×B)×C] 
+ I×F(A) ≒ F(A)
+ F(A)×I ≒ F(A)

ここで、左から右に見た≒の解釈が3通りあって：

+ →方向の射
+ 同型射
+ 恒等射

さらに、φとjの向きを逆転して、

+ F[(A×B)×C] → F(A)×(F(B)×F(C))
+ F(A) → I×F(A)
+ F(A) → F(A)×I

と考えることもある。それぞれの場合の呼び名は：

+ →方向の射 &lt;strong&gt;ラックス・モノイド関手&lt;/strong&gt;
+ 同型射 &lt;strong&gt;強モノイド関手&lt;/strong&gt;
+ 恒等射 &lt;strong&gt;厳密モノイド関手&lt;/strong&gt;
+ ←方向（逆向き）の射 &lt;strong&gt;オプラックス・モノイド関手&lt;/strong&gt;

ただし、呼び名は人により相当な揺れがある。

&lt;h5&gt;モノイド関手の公理（一貫性）&lt;/h5&gt;

一貫性の条件を記す。使う記法の説明：

+ A×B を A B のように並べるだけで表す。積の順序は縦棒（|）区切りや括弧で示す。
+ 射は↓φのように書く。
+ 恒等射は名前なしの矢印↓で書く。
+ 従って、↓↓φ は id&lt;sub&gt;A&lt;/sub&gt;×φ&lt;sub&gt;B,C&lt;/sub&gt;の意味になる。

α、λ、ρはモノイド圏の構造射（法則）だとする。

&lt;pre&gt;
F(A) | F(B) F(C)
   ↓α
F(A)  F(B) | F(C)
   ↓φ↓
F(A×B) F(C)
  ↓φ
F[(A×B)×C]

 equals

F(A) | F(B) F(C)
    ↓↓φ
F(A) | F(B×C)
  ↓φ
F[A×(B×C)]
 ↓F(α)
F[(A×B)×C]
&lt;/pre&gt;

&lt;pre&gt;
I F(A)
↓j ↓
F(I) F(A)
↓φ
F(I×A)
↓F(λ)
F(A)

 equals

I×F(A)
↓λ
F(A)
&lt;/pre&gt;

&lt;pre&gt;
F(A) I
↓ ↓j
F(A) F(I)
↓φ
F(A×I)
↓F(ρ)
F(A)

 equals 

F(A) I
↓ρ
F(A)
&lt;/pre&gt;

&lt;h5&gt;モノイド自然変換&lt;/h5&gt;

θ::F→G:C→D がモノイド自然変換だとは、
&lt;pre&gt;
F(A) F(B)
↓θ ↓θ
G(A) G(B)
 ↓ψ
G(A×B)

 equals

F(A) F(B)
 ↓φ
F(A×B)
↓θ
G(A×B)
&lt;/pre&gt;

&lt;pre&gt;
 I
↓j
F(I)
↓θ
G(I)

 equals

 I
↓k
G(I)
&lt;/pre&gt;

ブレイドβがあるときは、
&lt;pre&gt;
F(A) F(B)
 ↓β
F(B) F(A)
 ↓φ
F(B×B)

 equals

F(A) F(B)
 ↓φ
F(A×B)
 ↓F(β)
F(B×A)
&lt;/pre&gt;
</body>
</day>
<day date="2007-05-10" title="">
<body>
*1178755183*[リンク][高次圏論]フットボールの絵

S.E. Crans &quot;Higher-dimensional Mac Lane's pentagon and Zamolodchikov equations&quot; （http://citeseer.ist.psu.edu/crans99higherdimensional.html）のPDF版p.15にこんな絵があった。

&lt;img src=&quot;http://www.chimaira.org/img2/footballs.gif&quot; &gt;

*1178756107*[リンク][用語法][トレース／コンパクト閉圏]compactの意味

The n-Category Cafe'（http://golem.ph.utexas.edu/category/）の&quot;Traces in Ottawa&quot;（http://golem.ph.utexas.edu/category/2007/01/traces_in_ottawa.html）という記事を読んだ。
&gt;&gt;
In a braided monoidal category, an object has a left dual iff it has a right dual, thanks to the braiding.  So, we say a braided monoidal category is &lt;strong&gt;compact&lt;/strong&gt; if every object has a left (or right) dual.
&lt;&lt;

つまり、

- ブレイドがあれば、右自律性 ⇔ 左自律性
- 言い換えれば：ブレイディングを仮定して、片側自律圏 ⇒ 自足圏

注目すべきは、「コンパクト」という形容詞を、ブレイド付きモノイド圏のなかで「右（または左）の双対を持つ」の意味で使っていることだ。つまり、ブレイド付きモノイド圏を語る文脈において、

- 片側自律性 ⇔ コンパクト性
- つまり、ブレイド付き片側自律圏＝コンパクト（モノイド）圏

という用語法であること。片側自律性＝コンパクト性＝自足性は必然的に閉性を導くだろうか？（いけそうだ）

*1178777707*[リンク][プログラム意味論]あった！遷移系のストーン双対

以前に見た記憶があって、でも、みつからなかった。が、[google:&quot;stone duality&quot; &quot;transition systems&quot;] でやっと見つけた。

- Title: Studying Equivalences of Transition Systems with Algebraic Tools (1995) 
- Author: Pasquale Malacaria
- URL: http://citeseer.ist.psu.edu/489182.html

チラリと見て定式化があまり好きではないので、読むのをやめたのだが、今になって気になりだしたのだった。

*1178777708*[リンク][TQFT][からみ系]6j記号

- Title: S_4-symmetry of 6j-symbols and Frobenius-Schur indicators in rigid monoidal C^*-categories
- Authors: J. Fuchs, A.Ch. Ganchev, K. Szlachanyi, P. Vecsernyes
- http://arxiv.org/abs/physics/9803038

全部で37ページだが、本文は21ページ。残りは絵。絵だけ抽出して2ページで印刷できるようにした。

- &lt;a href=&quot;http://www.chimaira.org/img2/s46j-fig1to8.gif&quot;&gt;図その1&lt;/a&gt;
- &lt;a href=&quot;http://www.chimaira.org/img2/s46j-fig9to16.gif&quot;&gt;図その2&lt;/a&gt;
- &lt;a href=&quot;http://www.chimaira.org/img2/s46j-fig1to16.gif&quot;&gt;図全部&lt;/a&gt;


</body>
</day>
<day date="2007-05-11" title="">
<body>
*1178841890*[課題][プログラム意味論]TODO: 模倣、双模倣の定義を列挙整理

なんか、いろんな立場からいろんな定義があるな。これから定義を収集して、まとめよう。

*1178842309*[課題][プログラム意味論][圏一般論]圏の多項式的拡張と記号回路の圏

圏Cと指標Σに対して、ΣからC係数で自由生成した圏C[Σ]がとても使えそうな気がしている。が、現状、おぼろげな定義以外に何もわからない。

まず、Σ=(Σ&lt;sub&gt;0&lt;/sub&gt;, Σ&lt;sub&gt;1&lt;/sub&gt;)という集合の組を考える。記号の濫用で、Σ&lt;sub&gt;1&lt;/sub&gt;を単にΣと書き、Σ&lt;sub&gt;0&lt;/sub&gt;のほうは|Σ|と書くことにする。Σ、|Σ|が空であってもかまわない。Cはモノイド圏とする。実はCが単なる圏でもいいのだが、モノイド圏のほうが面白い。

さて、部分写像a:|Σ|→|C|があり、aを使って|Σ|&lt;sup&gt;*&lt;/sup&gt;と|C|を貼り合わせたものを|Σ|&lt;sup&gt;*&lt;/sup&gt;∪&lt;sub&gt;a&lt;/sub&gt;|C|とする。さらに、s, t:Σ→(|Σ|&lt;sup&gt;*&lt;/sup&gt;∪&lt;sub&gt;a&lt;/sub&gt;|C|)という写像があるとする。(-)&lt;sup&gt;*&lt;/sup&gt;はクリーネ・スターで、s, tはsource, targetのつもり（dom, codでもいい）。今まで出てきたΣ, |Σ|, a, s, tの全体もまとめて再びΣと呼んでしまう（記号の濫用）。そして、そのようなΣ（諸々含む）を&lt;strong&gt;C上のモノイド指標&lt;/strong&gt;と呼ぶことにする。

C上のモノイド指標の例として、Σ=Mor(C)、|Σ|=空として、aは自明な写像、s(f):=dom(f), t(f):=cod(f)として定義できる指標がある。また、Σ=|Σ|=空 としても指標が定義できる。

ΣとΓがC上のモノイド指標のとき、Σ→Γ、|Σ|→|Γ|という写像の組が、a, s, tの構造を保つとき指標の射とする。

a, s, tを使って、頂点集合|Σ|∪&lt;sub&gt;a&lt;/sub&gt;|C|、辺集合Σ+Cのグラフができる。これを基に生成した圏をC[Σ]とする。C[Σ]は、C-モノイド指標の圏の上のインデックス圏でもあり、グラフの圏の上のモナドにもなる。さらに、Cを動かすと、C[Σ]→D[Γ]のような射を考えることもできる。

C[Σ]の全体は非常に複雑になるが、記号回路の圏が実例となる。また、次の意味で多項式に似ている。

|* 多項式 |* 指標による拡張 |
| 変数集合X | 指標Σ |
| 係数体／環R | 圏C |
| 多項式環R[X] | 圏C[Σ] |
| 代入置換y:=f(x)  | 置換 Kleisli射 |

さらにイデアルによる商構成と圏論的合同を使った商にも類似がある。

以上の状況をもう少し調べたい。

*1178857844*[具体例][説明][トレース／コンパクト閉圏]ヘッジの圏は面白い

ノードや辺にラベルがない穴（プレイスホルダ）付きツリー（空ツリーは考えないほうが楽）を0個以上並べた列を考える。これはヘッジ。長さがmで穴が（正確にそのまま勘定して）n個あるヘッジの全体をH(n, m)とすると、これは対象類&lt;b&gt;N&lt;/b&gt;上の圏となる。さらに、モノイド積が入り（単位は空ヘッジ）、モノイド圏となる。

ここにジャンクションとしてブランチング（対角作用、データ構造としてはシェアリング、エイリアシング）とクロッシング（対称）をいれると、対称モノイド圏となる。展開ヘッジ（表示(display)ヘッジ）が同じなら同じという同値を入れると、ほぼ対角付き対称モノイド圏（放電を入れればカンペキ）。

ルーピング・トレースでトレース付き圏になる。ループしたヘッジ（もはやヘッジではないが）の展開ヘッジは有理ツリーの列となる。有理ツリーの無限列まで含めた圏は、対象類がωよりおおきな順序数となるだろう。たぶん、nω+k という形の順序数だろう。

この例はえらく単純だが、けっこう遊ぶべる。面白い！
</body>
</day>
<day date="2007-05-19" title="">
<body>
*1179562343*[プログラム意味論][高次圏論][リンク]高次オートマトンのホモロジー

- Title: Homology of Higher Dimensional Automata (1992)
- Authors: Eric Goubault, Thomas P. Jensen
- URL: http://citeseer.ist.psu.edu/goubault92homology.html

ザッと読んだ。だいぶ古いので、その後の発展があるんだが、それにしてもイマイチな感じ。

+ ホモロジーの係数が&lt;b&gt;Z&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;で、&lt;b&gt;Z&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;の特殊事情に依存している感じ。
+ 双復体（bicomplex）という用語も概念も気に入らない。
+ 方体（cube）ベースだが、これは使いやすくない。

並列処理の幾何学は、directed polygonal complex（polygonにはbigonも入る）の（幾何学的実現に対する）幾何学となるのではないかと思う。

ヒントになるかも知れないもの：

- Title: Cubical Sets And Their Site (2003) 
- Marco Grandis, Luca Mauri
- URL: http://citeseer.ist.psu.edu/grandis03cubical.html
- 28ページ

- Title: Crossed Complexes And Homotopy Groupoids As Non Commutative Tools For Higher Dimensional Local-To-Global Problems
- Author: Ronald Brown
- URL: http://citeseer.ist.psu.edu/618111.html
- 31ページ

- Title: Multiple Categories: The Equivalence of a Globular and a Cubical Approach (2002) 
- Authors: Fahd Ali Al-Agl, Ronald Brown, Richard Steiner
- URL: http://citeseer.ist.psu.edu/600095.html
- PDF: http://www.bangor.ac.uk/%7Emas010/multcat.pdf
- 48ページ

Gaubalt、Gaucher、Grandisあたりが中心人物か。


</body>
</day>
<day date="2007-05-22" title="">
<body>
*1179802392*[論理]伝統的エルブラン理論

伝統的エルブラン理論を定義し直したいのだけど、とりあえず伝統的エルブラン理論の概念・用語をまとめておく。

構文は、変数、定数、関数、述語（記号達）で構成する。関数と述語を&lt;em&gt;最初から明白に区別&lt;/em&gt;するのが特徴。変数、定数、関数で項を作り、それと述語と論理結合子（例えば∧、⊃、￢）で論理式を作る。ソート（型記号）はあってもなくてもよいが、ソート付きを考える。

変数を含まない項を&lt;strong&gt;基礎項&lt;/strong&gt;（ground term）、論理結合子を含まない（述語だけ）の論理式は&lt;strong&gt;原子論理式&lt;/strong&gt;（atomic formula）と呼ぶ。論理式の集まりを公理系と呼ぶことにする。

ソートがsの基礎項の全体をソートsの&lt;strong&gt;エルブラン空間&lt;/strong&gt;または&lt;strong&gt;エルブラン宇宙&lt;/strong&gt;（Herbrand universe）と呼ぶ。ソートsのの基礎項に述語を適用した形である原子論理式の全体をソートsの&lt;strong&gt;エルブラン基底&lt;/strong&gt;（Herbrand base）と呼ぶ。エルブラン基底をエルブラン領域と訳すこともあるが、良くないと思うので使わない。

各ソートに集合を対応させ、各ソートの基礎項に集合の要素を対応させ、関数記号に写像を、述語記号に集合の部分集合を対応させることを&lt;strong&gt;解釈&lt;/strong&gt;（intepretation）と呼ぶ。ソートsにそのエルブラン空間を対応させ、基礎項や関数も自明nに拡張して対応付ける解釈を&lt;strong&gt;エルブラン解釈&lt;/strong&gt;と呼ぶ。

Aが公理系であるとき、Aに含まれる論理式が真になるような解釈で、しかもエルブラン解釈であるものをAの&lt;strong&gt;エルブラン・モデル&lt;/strong&gt;と呼ぶ。Aが空のときは、Aのエルブラン・モデルは単なるエルブラン解釈なので、エルブラン解釈とエルブラン・モデルを神経質に区別する必要はない。

ソートsごとにエルブラン基底の部分集合を与えることと、エルブラン解釈は１：１に対応する。公理系Aに対して、論理式pが妥当であることは、すべてのモデルを検査する必要はなくて、Aのエルブラン・モデルだけを調べればいいことが知られている。

*1179805421*[雑記][課題]後で書く

- エルブラン・モデルから考えた圏の始類（initial class）、または図形的な印象からは始面（initial facet）。
- 単純対象と半単純圏
- 圏合同とエルブラン／リンデンバウム構成

*1179811620*[形式言語理論]pre-automaton, quasi-automaton

pre-automatonとは、始状態も終状態も持たない(Σ, S, δ)のことらしい。これはラベル付き遷移系と同じだと思う。
&lt;hr&gt;
&quot;Monadic SecondOrder Logic, Graphs and Unfoldings of Transition Systems&quot;から：
&gt;&gt;
Let n, m ∈N and m ≧ 1. A &lt;b&gt;transition system&lt;/b&gt; of type (n, m) is a tuple R = (G, x, P1, ...,Pn, Q1, ...,Qm), where G is a directed graph, x is a vertex called the root of R from which all other vertices are accessible by a directed path, P1, ...,Pn are sets of vertices and Q1, ...,Qm is a partition of the set of edges.

A vertex of G is called a state of R and an edge is called a transition. A transition in Qi is said to be of type i.
&lt;&lt;
&gt;&gt;
A &lt;b&gt;quasi-automaton&lt;/b&gt; is a pair A = (A, Ω) where A is a (possibly infinite) transition system of type (n, 2), for some n, and Ω is a function assigning a natural number from a finite set to every node of A. We require that the image of Ω is finite.
&lt;&lt;
いまいちわからん。

*1179812681*[形式言語理論]グラフの被覆木

Gがグラフで、aがその頂点。aから出る辺で隣接している頂点集合をNo(a)として、aのout近傍頂点集合と呼ぶ。{a}∪No(a)の誘導部分グラフを、aの&lt;strong&gt;out近傍&lt;/strong&gt;（グラフ）と呼ぶ。aのin近傍Ni(a)も同様に定義できる。

f:G→Hがグラフの準同型として、aはGの頂点。このとき、fがaのout近傍とf(a)のout近傍の有向グラフとしての同型を与えるとき、aで&lt;strong&gt;局所out同型&lt;/strong&gt;と呼ぶ。局所in同型も同様。

f:G→Hが、頂点のあいだの全射であり、すべての点で局所out同型のとき、&lt;strong&gt;out被覆&lt;/strong&gt;と呼ぶ。in被覆も同様。GもHも付点グラフ（pointed graph）であり、fが識別された頂点を保存するとき、&lt;strong&gt;付点out被覆&lt;/strong&gt;。

任意の付点（有向）グラフGに対して、そのout被覆木（木のルートで付点する）が普遍的に存在する。被覆写像をp:T→Gとする。Gが有限なら、Tは有理木となる。Gが無輪状ならTは有限木になる。Gに輪があれば、Tは有理無限木となる。

これらの事実と、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070511/1178857844&quot;&gt;穴あきヘッジ圏&lt;/a&gt;との関係がわかると面白い。
</body>
</day>
<day date="2007-05-23" title="">
<body>
*1179878286*[メモ法][その他代数]アルチンじゃなくて誰だっけ？ 小ネタこそメモすべし！

ブレイド関係式は「アルチン（Artin）の関係式」と呼んでいいと思う。間違いのはずはない。それに対応する対称（置換）の関係式も僕はアルチンの関係式と呼んでいたが、誰だか別の人の名前が付いていた。どこかで見た、比較的最近見た。が、思い出せない。誰だったか、どこで見たかも思い出せない、、、グググ。

こういう小ネタこそ&lt;span style=&quot;font-size:large&quot;&gt;&lt;strong&gt;メモすべき&lt;/strong&gt;&lt;/span&gt;なんだ。悔しい！

*1179889032*[圏一般論]自律圏（旧称：堅い圏）には自明なモノイドがある

小ネタ。左自律圏のM×M&lt;sup&gt;*&lt;/sup&gt;（または、右自律圏の&lt;sup&gt;*&lt;/sup&gt;M×M）にはモノイド構造が入る。乗法と単位は次で与える。

&lt;img src=&quot;http://www.chimaira.org/img2/trivial-monoid.gif&quot; &gt;
</body>
</day>
<day date="2007-05-24" title="">
<body>
*1179972975*[圏一般論][リンク]一般化合同（generalized congruence）

- [google:&quot;generalized congruence&quot; category functor]

で探してみると：

- Title: GENERALIZED CONGRUENCES. EPIMORPHISMS IN Cat
- Authors: MAREK A. BEDNARCZYK, ANDRZEJ M. BORZYSZKOWSKI, WIESLAW PAWLOWSKI
- URL: http://www.tac.mta.ca/tac/volumes/1999/n11/n11.pdf
- 16ページ

これ↑はもろに一般化合同についてだ。

- Title: CATEGORIES OF COMPONENTS AND LOOP-FREE CATEGORIES 
- Author: EMMANUEL HAUCOURT
- URL: http://www.tac.mta.ca/tac/volumes/16/27/16-27.pdf
- 36ページ

どうも有向（directed）な代数トポロジーみたい。

- Title: Components of the Fundamental Category II
- Authors: E. Goubault,  E. Haucourt
- URL: http://www.di.ens.fr/~goubault/papers/apcsII.pdf
- 32ページ

「並列性の幾何」のゴウバウルト（Goubault）と、1つ前の論文の著者だ。やっぱりどうも、一般化合同は有向トポロジーに関係して、並列性に使うらしい。

次の2つのスライドはきれいで楽しい。

- Title: スライド：Invariants of directed spaces and persistence
- Author: Martin Raussen
- URL: http://www.math.aau.dk/~raussen/TALKS/transinvdirspa.pdf
- 27ページ

- Title: スライド：Directed topology. An introduction
- Author: Martin Raussen
- URL: http://www.math.aau.dk/~raussen/TALKS/ditopt.pdf
- 26ページ

*1179986676*[圏一般論][課題]指標に対してCの代数を定義する

すごくラフに書くけど、後でチャント書くべし（&lt;b&gt;TODO&lt;/b&gt;）。

古典的なΣ代数の圏、ローヴェル（Lawvere）の代数セオリー、Monoid(C) = C&lt;sup&gt;Δ&lt;/sup&gt;という事実などの拡張を論じる。

Σを指標（&lt;span style=&quot;font-size:large&quot;&gt;&lt;em&gt;単に何の制限もない有向グラフと見る！&lt;/em&gt;&lt;/span&gt;）として、グラフΣから自由生成された圏FreeCat(Σ)を&amp;lt;Σ&gt;と略記。&lt;strong&gt;部分関手&lt;/strong&gt;という概念を適切に定義したとして、圏Cに対してK:&amp;lt;Σ&gt;→Cは部分関手とする。

この状況で、関手（と自然変換）の圏C&lt;sup&gt;&amp;lt;Σ&gt;&lt;/sup&gt;は普通に定義できる。関手F:&amp;lt;Σ&gt;→Cのなかで部分関手Kの延長になっているもの（Fを制限するとK)だけに制限した全体をC&lt;sup&gt;&amp;lt;Σ&gt;&lt;/sup&gt;[K] と書くことにする。C&lt;sup&gt;&amp;lt;Σ&gt;&lt;/sup&gt;[K]も圏になる。

指標Σに対して、その上の一般化合同をEとする。一般化合同は圏だけでなくグラフに対しても定義できる（むしろグラフに適している）。Eにより&amp;lt;Σ&gt;にも一般化合同が入り、その商圏&amp;lt;Σ&gt;/Eが定義できる。圏&amp;lt;Σ&gt;/Eを&amp;lt;Σ, E&gt;とも書く。合同Eは（無限かもしれない）等式系と思ってもよいので、(Σ, E)は生成系と関係に他ならない。

C&lt;sup&gt;&amp;lt;Σ&gt;/E&lt;/sup&gt;[K]は、“固定部分Kを持つCにおける(Σ, E)代数”の全体とその準同型からなる圏である。

&lt;b&gt;TODO&lt;/b&gt;：&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070511/1178842309&quot;&gt;「圏の多項式的拡張と記号回路の圏」&lt;/a&gt;の議論を整理して、(Σ, E)代数の話と結びつける。

&lt;b&gt;TODO&lt;/b&gt;：指標をモノイド指標とかデカルト指標とかにしてみる。

&lt;b&gt;TODO&lt;/b&gt;：インスティチューション、上江州理論との関係は？


</body>
</day>
<day date="2007-05-25" title="">
<body>
*1180062755*[論理][リンク]もうひとつの「論理とは何か」

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061019/1161231813&quot;&gt;本編&lt;/a&gt;で、&quot;What is a logic, and what is a proof?&quot; (April 8, 2005) by Lutz Strassburger（http://citeseer.ist.psu.edu/723320.html）を紹介したことがある（けっこう良く書けている）のだけど、（ほぼ）同じ題名の論文：

- Title: What is a Logic?
- Authors: Till Mossakowski, Joseph Goguen, Razvan Diaconescu, Andrzej Tarlecki
- URL: http://www.tzi.de/~till/papers/nel05.pdf
- 21ページ、印刷した

執筆陣が豪華！

*1180062918*[論理]リンデンバウム代数とエルブラン・モデル

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060712/1152682948&quot;&gt;「セオリーと証明の圏」&lt;/a&gt;とか&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070208/1170917577&quot;&gt;「圏論的形式言語理論の問題」&lt;/a&gt;とかに謎なことが書いてある。今読むと分からん！ 解釈し直さないと。

命題論理の場合のリンデンバウム（Lindenbaum）代数はハッキリしている。ブール代数（束）とかハイティング代数（束）だ。この場合、真偽値の代数だけど、値を対象、順序を射とすれば圏だから、リンデンバウム圏といってもよい。つまり、意味付与すべき世界（セマンティクス）を構文と演繹系だけから絞り出している。

白旗さんが、論理系CMLL(A)（Aはベースとする圏）に対してコンパクト閉圏を構成しているけど、これもリンデンバウム構成といえるだろう。やはり演繹系から圏を絞り出している。

エルブラン（Herbrand）・モデルがリンデンバウム構成とは微妙に異なるのは、真偽値が古典ブール束だと決めつけている点だろう。エルブラン基底の部分集合をモデルと同一視する所でこのこと（古典2値なこと）は明らか。ほんとのリンデンバウム構成をするなら、閉原子論理式の集合＝エルブラン基底に、演繹に基づいた同値関係（p≡q とは |- p⇔q）を入れるべきだろう。

エルブラン・モデルは、リンデンバウム・モデルの真偽値の部分を無理矢理ブール代数にしてしまったようなものかな？ となると、真偽値のリンデンバウム代数からブール代数への写像とエルブラン・モデルが1：1対応するはず。

ん？ なんかの論理代数（束）から古典ブール代数への準同型の全体って、ストーン双対みたいなもんじゃないのか？ 論理代数Aに対してA&lt;sup&gt;*&lt;/sup&gt; = hom(A, &lt;b&gt;B&lt;/b&gt;)（&lt;b&gt;B&lt;/b&gt;が古典ブール代数）。「&lt;em&gt;エルブラン・モデルの全体＝リンデンバウム代数の双対&lt;/em&gt;」かな？ そうだとカッコイイ。

*1180063464*[論理][圏一般論]圏の定義

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070524/1179970746&quot;&gt;本編のコレ&lt;/a&gt;だけど、部分関数／部分演算を等式的一階述語論理でどう扱うかの例題として面白いかもしれない。次のような体系も考えるといいかも。

- domu（id(dom(-))に対応）とcoduを持つ体系
- 「…が存在する」を意味する述語E(-)を持つ体系

*1180066244*[論理][インスティチューション][プログラム意味論]指標と枠

指標を&lt;em&gt;単なる有向グラフ&lt;/em&gt;と考えるのは&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;とてもいい&lt;/b&gt;&lt;/span&gt;とわかってきた。

&lt;h5&gt;等式的セオリー&lt;/h5&gt;

まず、等式的セオリーとグラフのあいだには次の関係がある。

|指標    | 圏の生成グラフ |
|ソート  | 対象の生成集合 |
|関数記号| 射の生成集合 |
|項形成規則| 自由構成 |
|項      | 射 |
|等式系  | グラフの（一般化）合同|
|リンデンバウム構成 | 商圏 |
|モデル／代数  | 商圏からの射 |

※「商圏」（quotient category）つったら、ビジネス用語と間違われるな。

&lt;h5&gt;C-枠&lt;/h5&gt;

圏Cを固定して、グラフとみなした指標Σと部分関手 K:FreeCat(Σ)→C の組(Σ, K)を&lt;strong&gt;C-枠&lt;/strong&gt;と呼ぶ。部分関手とは、単に部分圏でのみ定義された関手のこと。Kは空部分関手でも全体で定義された普通の関手でもよい。

C-枠(Σ, K)に対して、その代数とは、Kの拡張（延長）になっている関手 F:FreeCat(Σ)→C のこと。(Σ, K)代数の全体をAlg&lt;sub&gt;Σ,K&lt;/sub&gt;とすると、Alg&lt;sub&gt;Σ,K&lt;/sub&gt;は圏となる。

C-枠(Σ, K)と(Σ', K')のあいだの準同型は、部分関手T:FreeCat(Σ)→FreeCat(Σ')で、T;K' = K を満たすもの。この準同型でC-枠の全体は圏となる。

指標ΔとΔ上の関手K:FreeCat(Δ)→Cを固定する。Δの拡張となっている指標の全体をSign↑Δとして、Σ∈(Sing↑Δ)とKを一緒に考えるとC-枠となる。Sign↑ΔにC-枠の準同型を考えて圏となる。この圏をSign↑Δ[K]とする。より詳しくはSign↑Δ[K:Δ→C]。

&lt;h5&gt;プログラミング言語としてのC-枠&lt;/h5&gt;

C-枠はプログラミング言語機構と解釈できる。Δは言語組み込みの型／関数／演算などの記号（名前）集合。K:Δ→Cはその意味である。圏Cはこの言語を解釈する場となるアンビエント圏。Sign↑Δ[K]に入る指標はユーザー定義の記号集合。ただし、組み込み記号は前もって意味が定まっている。Σ∈|Sign↑Δ[K]|に対してΣ代数（Cに値をとる）を考えれば、それはユーザーによるΣの実装になる。Σ代数F:Σ→CがKの拡張でなければいけないのは、組み込み記号の意味を変えることができない（protected）ことを意味する。

C-枠ΣごとにΣ代数の圏Alg&lt;sub&gt;Σ,K&lt;/sub&gt;が対応するので、インスティチューションとなる。ただし、Sen(Σ, K)は別に考えなくてはならない。

*1180066737*[雑記][課題]あとで書く

- Sをソート集合、Vを変数記号の集合で、V→Sでソート付き変数が定義されているとする。ρ:S→|C|がSの圏Cでの解釈として、ρによりVを圏Cに上江州アタッチできる。これを詳しく記述。
- 終状態セットが複数あるオートマトン。

*1180081962*[論理][インスティチューション]リンデンバウム代数のスペクトルとモデル

待てよ、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070525/1180062918&quot;&gt;前のエントリー&lt;/a&gt;と同じこと、スペクトルとモデルの関係について以前書いたのだった。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20051207/1133937746&quot;&gt;「コンパクト空間と論理／モデル論」&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20051208/1134018263&quot;&gt;「仕様技術への道 -- インスティチューションを縮めてみる」&lt;/a&gt;

ある形式系が採用している論理が古典論理なら、そのリンデンバウム代数はブール代数になる。ブール代数の極大イデアル（極大フィルター）の空間＝スペクトルはモデルの同値類の空間と同じになる。次は同じことだ。

- 命題pがスペクトル上で一定値trueを取る定数関数と見なせる。
- 命題pがどのモデル（の同値類）でも真である。
- 命題pが妥当である。

ところが、リンデンバウム代数の双対＝スペクトルとエルブラン・モデルが1:1に対応する。このことから：

- リンデンバウム代数のスペクトル＝エルブラン・モデルの全体＝モデルの同値類の全体

となる。別な言い方をすると、モデルの各同値類にエルブラン・モデルが1個ずつあるので、すべてのエルブラン・モデルで正しいなら、すべてのモデルで正しいことになる。

うーん、割と当たり前のことだったか、、、チェ。
</body>
</day>
<day date="2007-05-29" title="">
<body>
*1180404655*[リンク][プログラム意味論]Bidoit/Hennicker/Kurz双対性

ビドォイト／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）双対性に関して：

- Title: On the Duality between Observability and Reachability (2001) 
- Authors: M. Bidoit, R. Hennicker, A. Kurz
- URL: http://citeseer.ist.psu.edu/bidoit01duality.html
- 26ページ、印刷したような気もするが忘れた

- Title: On the Integration of Observability and Reachability Concepts (2002)
- Authors: M. Bidoit, R. Hennicker
- URL: http://citeseer.ist.psu.edu/bidoit02integration.html
- 19ページ

以上の2つを読めばいいと思う。

論理的な観点からは↓

- Title: Observational Logic, Constructor-Based Logic, and their Duality (2002) 
- Authors: M. Bidoit, R. Hennicker, A. Kurz
- URL: http://citeseer.ist.psu.edu/bidoit02observational.html
- 35ページ

初期の短くわかりやすいもの↓：

- Title: On Observability and Reachability 
- Authors: Michel Bidoit, Rolf Hennicker, Alexander Kurz
- URL: http://citeseer.ist.psu.edu/500492.html
- 17ページ

最後の短いのを読んでみたが、後半がはしょってあってワカラン！ 35ページのヤツの16ページ以降を印刷してみた（読んでないが）。

*1180405196*[XML][プログラム意味論]XMLとBidoit/Hennicker/Kurz双対／Goldblatt双対

ビドォイト／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）双対性を調べてみたい理由は、これがXMLにモロに適用できそうだから。XMLを順序付き多ソート代数とそのモデルで定式化することは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060706/1152177847&quot;&gt;以前から考えている&lt;/a&gt;ことだが、構文定義文法とオブジェクト指向風APIの双対性は、BHK双対そのものだろう。

ウルトラフィルターを使うGoldblatt双対も関係しそうだが、よくわからない。

*1180405345*[リンク][プログラム意味論]Goldblatt/Stone双対性

- Title: Duality for Some Categories of Coalgebras (2001)
- Author: Robert Goldblatt
- URL: http://citeseer.ist.psu.edu/482873.html
- 20ページ、印刷したような気もするが忘れた

- Title: What is the Coalgebraic Analogue of Birkhoff's Variety Theorem? (2000) 
- Author: Robert Goldblatt
- URL: http://citeseer.ist.psu.edu/493931.html
- 37ページ

- Title: Observational Ultrapowers of Polynomial Coalgebras (2001)  
- Author: Robert Goldblatt
- URL: http://citeseer.ist.psu.edu/goldblatt01observational.html
- 37ページ

- Title: Coalgebras, Stone Duality, Modal Logic (26th June 2006)
- Author: Alexander Kurz
- URL: http://www.cogsci.uni-osnabrueck.de/CL/conferences/ESSLLI2006/courses/Kurz.CoalgebrasStoneDualityModalLogic.pdf
- 110ページ

- Title: Studying Equivalences of Transition Systems with Algebraic Tools (1995) 
- Author: Pasquale Malacaria
- URL: http://citeseer.ist.psu.edu/489182.html
- 21ページ、印刷したはず

それと、Paul Taylor の Abstract Stone Duality は：

- http://www.cs.man.ac.uk/~pt/ASD/

*1180425585*[形式言語理論][プログラム意味論]指標から作られる関手

ビドォイト／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）に従うとして、指標Σが観測的なら、余代数を定義する関手 Θ:Set&lt;sup&gt;S&lt;/sup&gt;→Set&lt;sup&gt;S&lt;/sup&gt;が定義される。指標Σが構成的（constructor-based）なら代数を定義する関手Ω:Set&lt;sup&gt;S&lt;/sup&gt;→Set&lt;sup&gt;S&lt;/sup&gt;も定義される。それに項関手Term&lt;sub&gt;Σ&lt;/sub&gt;:Set&lt;sup&gt;S&lt;/sup&gt;→Set&lt;sup&gt;S&lt;/sup&gt;もある。

Σから作られる構造から、Θ余代数の圏、Ω代数の圏が作られ、項関手からはKleisli圏が作れる。一方、単純にΣ代数は関手FreeCat(Σ)→Setという見方もできるから、関手圏も作れる。これらの派生した圏のあいだの関係はどうなっているんだろう？
</body>
</day>
<day date="2007-05-30" title="">
<body>
*1180486533*[リンク][形式言語理論][プログラム意味論]拡張版エルブランの定理

ゴグエン（Goguen）達がエルブラン定理について書いているのだが：

- Title: A Hidden Herbrand Theorem (1998)
- Authors: Joseph Goguen, Grant Malcolm, Tom Kemp
- URL: http://citeseer.ist.psu.edu/293075.html
- 18ページ

- Title: A Hidden Herbrand Theorem: Combining the Object, Logic and Functional Paradigms ()
- Authors:  Joseph Goguen, Grant Malcolm, Tom Kemp
- URL: http://citeseer.ist.psu.edu/48960.html
- 29ページ

- Title: A Hidden Herbrand Theorem: Combining the Object and Logic Paradigms 
- Authors: Joseph Goguen, Grant Malcolm, Tom Kemp
- URL: http://citeseer.ist.psu.edu/443339.html
- 34ページ

似たようなもんだけど、どれを読んだらいいかわからない。


</body>
</day>
<day date="2007-05-31" title="">
<body>
*1180580601*[用語法]BHKはBidoit/Hennicker/Kurz

Bidoit/Hennicker/Kurzはさすがに書くのに長すぎるからBHKと略記する。

*1180581197*[形式言語理論][プログラム意味論]境界付き指標

指標は単なる有向グラフと考えてよい（そう考えるべき！）。境界付きグラフがあるんだから境界付き指標があってもいい。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070531/1180580601&quot;&gt;BHK&lt;/a&gt;のconstructor-based指標Σを考える。ソートにはlooseとconstrainedがあるが、これをbasicとdefinedと呼び替える。basicソートとbasicオペレータの部分指標をΦとして、defined sortとconstractor symbolからなる部分指標をΨとする。Φを始境界（部分グラフ）δ&lt;sub&gt;0&lt;/sub&gt;(Σ)、Ψを終境界δ&lt;sub&gt;1&lt;/sub&gt;(Σ)として境界付き指標ができる。

*1180581978*[形式言語理論][プログラム意味論]境界付き指標もっと

もう少し考えよう。有向グラフとしての指標Σ（有限に限らない！）、部分有向グラフΦ、Ψを一緒に考える。|Φ| = B を基本(basic)ソート、|Ψ| = D を公開定義（public defined）ソートと呼ぶ。

別な部分グラフΔ⊆Σがあるとして、Δの辺&lt;strong&gt;はコンストラクタ演算記号&lt;/strong&gt;と呼ばれる。Σがconstructor-based指標であるとは、|Δ|∩D = D であること。つまり、すべての公開定義ソートがΔに含まれること。ただし、Δ∩Ψ = Ψ である必要はない。

b∈B、d∈Dに対してPath&lt;sub&gt;Δ&lt;/sub&gt;(b, d)が&lt;strong&gt;コンストラクタ項&lt;/strong&gt;となる。

*1180583587*[形式言語理論][プログラム意味論]境界付き指標もっともっと

有向グラフとしての指標Σと部分有向グラフΦ、Ψを一緒にした(Σ, Φ, Ψ)を射とするコボルディズム圏を考えることができる。このコボルディズムでは次元概念は役割を演じない。

圏Cに対してΣ代数圏 C-Alg&lt;sub&gt;Σ&lt;/sub&gt;は、関手圏C&lt;sup&gt;&amp;lt;Σ&gt;&lt;/sup&gt;として定義する。コボルディズム指標(Σ, Φ, Ψ)があると、C-Alg&lt;sub&gt;Φ&lt;/sub&gt;、C-Alg&lt;sub&gt;Σ&lt;/sub&gt;、C-Alg&lt;sub&gt;Ψ&lt;/sub&gt;を考えることができる。始境界Φに対する代数K（つまり圏C-Alg&lt;sub&gt;Φ&lt;/sub&gt;の対象K）を固定すると、K上のΣ代数の圏C-Alg&lt;sub&gt;Σ&lt;/sub&gt;/K（C&lt;sup&gt;&amp;lt;Σ&gt;&lt;/sup&gt;/K）が定義される。ここからΣ/K代数Aを一つ選ぶと、自動的にΨ代数Lが定まる。

Φ代数が基本型／基本演算の実装、Σ代数が基本の上でのプログラム実装、Ψ代数が結果として得られるインターフェースΨの実装ということになる。Σがconstructor-basedのとき、Σは&lt;em&gt;ほぼ文法と考えてよい&lt;/em&gt;だろう。各ソートd∈Dに対して、Kのvaluationで具体化したコンストラクタ項Path&lt;sub&gt;Δ&lt;/sub&gt;(b, d)が構成できる。

*1180586006*[XML][インスティチューション]二重圏上のインスティチューション

指標圏に境界概念とグルーイングを導入して、コボルディズム的な二重圏だと考える。インスティチューションをこの二重圏の上で定義する。すると、Mod、Sen、Spec、Theo（Sen上に作る順序集合）なども拡張されるだろう。

さらに、証明系ProofやプログラムProgも拡張する。それで、プログラミング行為全般を説明できるんじゃないか？ （まだ足りないかもしれないが。）BHKのコンストラクタ項とかエルブラン空間の概念により、XML（データ代数）の構文論も取り込みたい。

*1180594965*[プログラム意味論][インスティチューション]プログラミング言語概念の定義

プログラミング言語をひとつ与えることは、結局は指標を与えることと同じで、問題は指標から自由圏を作る一種の閉包演算&amp;lt;-&gt;のほうだな。どのような種類の自由圏（エルブラン圏、項集合）を与えるかがプログラミング言語構文の特徴付けになる。

閉包演算&amp;lt;-&gt;はモナドだが、&amp;lt;-&gt;自体がプログラミング言語なのではなくて、プログラミング言語のメタ規則だから、一連のプログラミング言語族を定義する機構。1つのプログラミング言語はメタ構文モナド&amp;lt;-&gt;と指標Σの対で決まる。意味論の値の圏をCとすると、Σ→U(C) （Uは忘却）と &amp;lt;Σ&gt;→C が随伴となるのだから、指標圏Signと意味圏の圏Semのあいだの随伴対がメタ構文規則を与えることになる。

となると、Sign上の自由生成圏関手F:Sign→Semと忘却関手U:Sem→Signの対がプログラミング言語族概念に対応するのだろう。意味論sは、s:F(Σ)→C in Sem という射。だから、Σのすべての意味論は Sem＼F(Σ) という余スラント圏をなす。

同じSign上に別な対F':Sign→Sem'、U':Sem'→Signがあると、別なプログラミング言語概念ができる。異なるプログラミング言語概念を繋ぐには、Sem→Sem'という関手が必要になる。あるいはSemもSem'も含むような大きな意味圏の圏SEMを使うとか。

通常、指標圏Signはグラフの圏として定義するが、プレ圏（precategory）の圏としてもいい。そうすれば、忘却関手は&lt;em&gt;実は何も忘却しない&lt;/em&gt;で、埋め込み関手となる。忘却／自由生成の対が、埋め込みとレトラクトになっている。事情は簡単になる。Sign⊆Precat、Sem⊆Cat。プレ圏上の合同も使えるな、ウン。
</body>
</day>
<day date="2007-06-02" title="">
<body>
*1180759386*[形式言語理論][プログラム意味論]形式言語系の定義

フー、ここ2,3日四苦八苦していた問題にやっと目星がついた。プログラム言語をはじめとする形式言語の一般的定式化。とりあえず目標は：

+ インスティチューション・フレンドリ
+ 十分な一般性

&lt;hr&gt;

形式言語系とは、組(Sign, Mod, T, ξ)であって：

- SignとModはインスティチューションと同様。Modを、Mod:Sign→&lt;b&gt;Cat&lt;/b&gt;という反変関手だと考えるとindexed圏。Σ∈|Sign|に対するModの値をMod[Σ]と書く。σ:Σ→Σ'に対するMod(σ)（reduct; リダクト）はσ&lt;sup&gt;*&lt;/sup&gt;と書く。
- TはSign上のモナドで、実用的な多くのケースでベキ等モナド。正確には、T=(T, μ, η)。Tを&lt;strong&gt;構文生成モナド&lt;/strong&gt;（syntax/sytactic production monad）、&lt;strong&gt;項形成モナド&lt;/strong&gt;（term forming monad）と呼ぶ。
- ξは、Mod⇒Mod・T : Sign→&lt;b&gt;Cat&lt;/b&gt; とう自然変換。つまり、ξ&lt;sub&gt;Σ&lt;/sub&gt;:Mod[Σ]→Mod[T(Σ)] の集まり。ξを&lt;strong&gt;モデル拡張自然変換&lt;/strong&gt;または（モデルの）&lt;strong&gt;自然拡張&lt;/strong&gt;と呼ぶ。

Modの値の圏を&lt;b&gt;Cat&lt;/b&gt;ではなくて&lt;b&gt;Set&lt;/b&gt;や&lt;b&gt;Ord&lt;/b&gt;にすることもある。そのときも、離散圏、やせた圏と考えれば、&lt;b&gt;Cat&lt;/b&gt;の場合の議論が通用する。

形式言語系の具体例は後で出す。

Lが形式言語系のとき、L=(Sign&lt;sup&gt;L&lt;/sup&gt;, Mod&lt;sup&gt;L&lt;/sup&gt;, T&lt;sup&gt;L&lt;/sup&gt;, ξ&lt;sup&gt;L&lt;/sup&gt;)のように書く。また、モナドの乗法と単位を明示するときは、（μ&lt;sup&gt;T&lt;/sup&gt;、η&lt;sup&gt;T&lt;/sup&gt;ではなく）μ&lt;sup&gt;L&lt;/sup&gt;、η&lt;sup&gt;L&lt;/sup&gt;と記すことにする。

形式言語系Lがプログラミング言語の形式化だとして、プログラム（単純プログラム）と実装の概念を定義する。（モジュール概念は考え中、まだイマイチ。）

&lt;strong&gt;プログラム&lt;/strong&gt;（単純プログラム）とは、モナドTによるKleisli圏の反対圏の射である。Kleisli圏の反対圏を&lt;strong&gt;プログラムの圏&lt;/strong&gt;と呼び、Prog&lt;sup&gt;L&lt;/sup&gt;と書く。つまり、p:Δ→Σ in Prog&lt;sup&gt;L&lt;/sup&gt; ⇔ p:Σ→T(Δ) in Sign&lt;sup&gt;L&lt;/sup&gt;である。

指標Δに対して、その実装（実現モデル）とは圏Mod[Δ]の対象のことである。プログラムp:Σ→T[Δ]（Prog内ではΔ→Σ）があると、Δの実装A∈Mod[Δ]に対して、自然拡張ξを使ってξ(A)∈Mod[T(Δ)]が確定する。射pをreductすると、p&lt;sup&gt;*&lt;/sup&gt;:Mod[T(Δ)]→Mod[Σ]が決まる。このreduct関手p&lt;sup&gt;*&lt;/sup&gt;で、実装ξ(A)をMod[Σ]に送るとΣの実装が1つ定まる。この過程による、Mod[Δ]→Mod[Σ]は関手となる。この関手をプログラムpの&lt;strong&gt;意味&lt;/strong&gt;だとする。

|ModTr| = |Sign|、ModTr(Σ, Δ) = Functor(Mod(Σ), Mod(Δ))で定義される圏を&lt;strong&gt;モデル変換子（model transformer）の圏&lt;/strong&gt;と呼ぶ。プログラムの意味Semは、Porg→ModTrという共変関手を定義する。ひとつのプログラムはモデル圏のあいだのひとつの関手を定義する。

今までの記号法だと、モナドTに対するT(Σ)がTerm&lt;sub&gt;Σ&lt;/sub&gt;、System(Σ, Γ)は、ProgにもModTrにも使っていたかもしれない。

それにつけても、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060712/1152682948&quot;&gt;「セオリーと証明の圏」&lt;/a&gt;とか、ほとんど正しいこと言っているようだな。

*1180760919*[用語法][プログラム意味論]隠蔽エルブラン定理とか

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070530/1180486533&quot;&gt;エルブラン定理関係&lt;/a&gt;で、結局一番短い、

- Title: A Hidden Herbrand Theorem (1998)
- Authors: Joseph Goguen, Grant Malcolm, Tom Kemp
- URL: http://citeseer.ist.psu.edu/293075.html
- 18ページ

これにした。

まず、隠蔽ソートって用語はよくないと思った。これは状態（state）ソートと呼ぶべきだろう。&lt;em&gt;隠蔽だとprivateと間違われる。情報隠蔽とは無関係だ！&lt;/em&gt;

- 隠蔽ソート： 状態ソート、観測不可能ソート、オブジェクト・ソート
- 可視ソート： 値ソート、観測可能ソート、基本ソート

状態ソートと値ソートがいいような気もする。オブジェクト・ソートと基本ソートも馴染みがあっていいかな。

*1180760920*[用語法][インスティチューション]指標について色々

普通、指標はグラフとみなせる。グラフや圏の用語と記法を拝借しよう。

指標Σに対して、ソートsからソートtへの演算記号の全体をΣ(s, t)と書く。Σ(s, t)は集合。ただし、(s, t)≠(s', t')でもΣ(s, t)∩Σ(s', t') = 空 は仮定しない（オーバーロード許可）。Σ(s, t)の要素を&lt;strong&gt;演算の記号または名前&lt;/strong&gt;と呼び、3つ組(s, f, t)を&lt;strong&gt;演算の識別子&lt;/strong&gt;（ID）と呼ぶことにする。演算識別子を改めてΣ(s, t)の元だと考えれば、オーバーロードの多義性は解決される。

部分指標Γ⊆Σがあるとき、圏論と同様に&lt;strong&gt;充満部分指標&lt;/strong&gt;という概念を使う。また、X⊆|Σ|であるとき、Xで誘導された充満部分指標が一意的に決まる。これはXの&lt;strong&gt;誘導部分指標&lt;/strong&gt;と呼ぼう。

*1180763246*[用語法][プログラム意味論][インスティチューション]観測可能論理と隠蔽論理

ゴグエン／マルコルム／ケンプ（Joseph Goguen, Grant Malcolm, Tom Kemp）の&quot;A Hidden Herbrand Theorem&quot;(1998)とビドォイト／ヘンニッカー／カーツ（Bidoit/Hennicker/Kurz）の&quot;On Observability and Reachability &quot;を読み比べてみた。

|* Observational Logic Inst. |* Hidden Logic Inst. |
| S : all sorts | S : all sorts |
| S&lt;sub&gt;Obs&lt;/sub&gt; : observable sorts | V : visible sorts |
| S&lt;sub&gt;NonObs&lt;/sub&gt; : non observable sorts | H : hidden sorts |
| S&lt;sub&gt;NonObs&lt;/sub&gt; = S＼S&lt;sub&gt;Obs&lt;/sub&gt; | H = S＼V |
| -  | Ψ : visible operators |
| -  | ΨはVによる誘導部分指標 |
| -  | op:s1, ..., sn→sで、si∈Hとなるiは高々1つ |
| observer (op, i) | - |
| s1, ..., sn→s、si∈S&lt;sub&gt;NonObs&lt;/sub&gt; | s1, ..., sn→s、si∈H |
| s1, ..., sn→s、si∈S&lt;sub&gt;NonObs&lt;/sub&gt; | s1, ..., sn→s、si∈H |
| s∈S&lt;sub&gt;Obs&lt;/sub&gt;なら direct observer | s∈V ならばattribute |
| s∈S&lt;sub&gt;NonObs&lt;/sub&gt;なら indirect observer | s∈H ならばmethod |
| モデルはobservational algebras | モデルはhidden algebras |

hiddenでは、可視ソートをimportすることを前提としており、ΨはΣ内で一切変更できない。また、Ψのモデルはデータ（値の）代数とも呼ばれ、固定して話を進めている。すべのて演算は、可視演算（固定されている）、メソッド、属性のどれかに分類される。

一方のobservationalでは、可視ソートに相当する概念（観測可能ソート）があるが、特にΨのような部分指標を特定してなく、指標の階層化（相対化）はされていない。すべのて演算は、観測演算とそれ以外に分類される。観測演算は直接と間接に分類される。直接観測演算＝属性、間接観測演算＝メソッドであるが、その他の演算が可視演算に相当するとは限らない。単に、観測演算に注目するだけのこと。

現実的には、(1)観測演算（ミューテータを含む、テストをする必要があるもの）、(2)基本演算（値の計算、可視演算と同じ）、(3)便宜演算に分けるといいと思う。便宜演算はなくてもいいがあれば便利、短くて簡単な実装。

ところで、隠蔽指標の射は定義されていたが観測可能指標の射の定義がなかった、探そう。
あった、http://citeseer.ist.psu.edu/hennicker98observational.html より：
&gt;&gt;
Definition 5.1 (Observational signature morphism) 

Let Σ&lt;sub&gt;Obs&lt;/sub&gt; = (Σ, S&lt;sub&gt;Obs&lt;/sub&gt;, OP&lt;sub&gt;Obs&lt;/sub&gt;) and Σ’&lt;sub&gt;Obs&lt;/sub&gt; = (Σ’, S’&lt;sub&gt;Obs&lt;/sub&gt;, OP’&lt;sub&gt;Obs&lt;/sub&gt;) be two observational signatures with Σ = (S, OP) and Σ’= (S’, OP’). An &lt;b&gt;observational signature morphism&lt;/b&gt; σ&lt;sub&gt;Obs&lt;/sub&gt;: Σ&lt;sub&gt;Obs&lt;/sub&gt; → Σ’&lt;sub&gt;Obs&lt;/sub&gt; is a signature morphism σ: Σ → Σ’ such that the following conditions are satisfied:

(1) σ(S&lt;sub&gt;Obs&lt;/sub&gt;) = σ(S) ∩ S’&lt;sub&gt;Obs&lt;/sub&gt;.
(2) If (op, i) ∈ OP&lt;sub&gt;Obs&lt;/sub&gt; then (σ(op), i) ∈ OP’&lt;sub&gt;Obs&lt;/sub&gt;,
(3) If (op’, i) ∈ OP’&lt;sub&gt;Obs&lt;/sub&gt; such that op’: s1’,…,sn’ → s’ and si’∈ σ(S) then there exists op ∈ OP such that (op, i) ∈ OP&lt;sub&gt;Obs&lt;/sub&gt; and op’ = σ(op). 
&lt;&lt;


*1180767567*[用語法][リンク]Observational Truth
だって。

- Title: Observational Truth as a Categorical Modality (2002)
- Author: Grant Malcolm
- URL: http://citeseer.ist.psu.edu/573401.html
- 11ページ
</body>
<comments>
<comment>
<username>M. Juppa</username>
<body>よくわかりませんが、隠蔽ソートを状態ソートと呼ぶべし、&lt;br&gt;というのは大賛成です。&lt;br&gt;しかし、オブジェクトソートではないのではないでしょうか？&lt;br&gt;オブジェクトも、オブジェクトIdという値をもつ値ソート&lt;br&gt;の一つでしょうから。&lt;br&gt;隠蔽ソートは、もっと特定(明示)できないものを扱おうと&lt;br&gt;しているのですよね？</body>
<timestamp>1195004187</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>M. Juppaさん、&lt;br&gt;&gt; しかし、オブジェクトソートではないのではないでしょうか？&lt;br&gt;&gt; オブジェクトも、オブジェクトIdという値をもつ値ソート&lt;br&gt;&gt; の一つでしょうから。&lt;br&gt;なるほど、「オブジェクト＝オブジェクトId」という解釈をされると具合が悪いですね。僕は、オブジェクトIdが指し示すところの状態のほうを「オブジェクト」と呼んだつもりですが、確かに誤解されそうです。&lt;br&gt;オブジェクトIdというのは、代数的な定式化ではあまり表だっては出てきません。オブジェクトIdは、状態空間Sの直積S×S×...×Sを作ったときの添数（あるいはその一般化）みたいなもんです。ですから、「値」とは呼びにくい気もします。&lt;br&gt;&lt;br&gt;&gt; 隠蔽ソートは、もっと特定(明示)できないものを扱おうと&lt;br&gt;&gt; しているのですよね？&lt;br&gt;そうです。観測の総体からしか把握できない、あるいは把握しているかどうかも定かでないようなナニカです。</body>
<timestamp>1195092462</timestamp>
</comment>
</comments>
</day>
<day date="2007-06-05" title="">
<body>
*1181010530*[用語法][課題]ObservationalとBihavioural

どう違う？ 同じような気もするが。

*1181010531*[インスティチューション]パラメータ付きモジュールとインポート

パラメータ付き指標／セオリー（仕様モジュール）とCafeOBJのprotected importって同じような気がする。インポートって余スパンで説明されるような。

*1181014022*[インスティチューション]指標の圏はだいたいこれでOKだろう

プレ圏（グラフ上に部分的な圏構造）の圏をPrecatとする。さらに、プレ圏に同値関係（一般化合同）が与えられたものを(P, E)として、その全体をEPrecatとする。EPrecatは有限余完備だと期待している。

EPrecatが有限余完備ならその上の余スパンの圏が作れる。余スパンの圏は二重圏だろうから、これが十分に一般的な指標圏を与えると思う。記号を含む境界付きグラフ＝記号回路の圏、その上にモナドがたくさん載っている構造、かな。


</body>
</day>
<day date="2007-06-06" title="">
<body>
*1181108727*[インスティチューション]CafeOBJのimport

- protecting 演算（記号）も法則（等式）も追加できない。 
- extending 演算は追加できるが法則は追加できない。
- using 自由

*1181111463*[インスティチューション][プログラム意味論]昔から言っていたことだった

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050716/1121499351&quot;&gt;余完備性をKleisli圏に持ち上げたい&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050719/1121756022&quot;&gt;open programs&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050720/1121825875&quot;&gt;open programs 再び&lt;/a&gt;

2005年の夏、&lt;em&gt;えー&lt;/em&gt;、こんな昔からTermモナドがプログラムだって知っていたの、僕？ Cospan構成にも言及しているし。

以上をふまえて書いた記事：
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060120/1137724144&quot;&gt;ソースコードの形式化 &lt;/a&gt;

これ↑で、「&lt;em&gt;コンポネントの圏を定義したーい！！&lt;/em&gt;」なんて言っている。まったくだ！ &lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;初心忘るるべからず。&lt;/b&gt;&lt;/span&gt;

以下も読むと参考になる（って、自分で書いたのに）：

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060123/1138003844&quot;&gt;Pインスティチューション&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060124/1138069991&quot;&gt;仕様証明とプログラム証明 &lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060216/1140078947&quot;&gt;リファクタリングとPインスティチューション&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060407/1144403920&quot;&gt;System(Γ, Σ) &lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060408/1144475364&quot;&gt;System(Γ, Σ)の具体例：翻訳系&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070215/1171520355&quot;&gt;Categorical Formal Language Theories&lt;/a&gt;

</body>
</day>
<day date="2007-06-21" title="">
<body>
*1182392814*[インスティチューション][具体例]平坦レコードのインスティチューション

本編&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20070620/1182301330&quot;&gt;「レコードの型階層を合理的に説明できるか」&lt;/a&gt;の設定でインスティチューションを作ってみる。用語や記号は本編記事に従う。

&lt;h5&gt;指標圏&lt;/h5&gt;

フィールド名として許されるすべての名前の集合をName（無限集合と仮定）とする。Nameの有限部分集合を&lt;strong&gt;指標&lt;/strong&gt;と呼ぶ。例えば、{name, age}や{name, age, married}は指標である。2つの指標Σ、Σ'のあいだに包含関係 Σ⊆Σ' があるとき、Σ→Σ'の射があるとみなす。{name, age}⊆{name, age, married}だから、射が存在する。この定義で&lt;strong&gt;指標圏&lt;/strong&gt;Signができる。

別な言い方をすると、Powf(Name)をNameの有限ベキ集合とすると、これは順序集合。順序集合はやせた圏なので、圏とみなしたものが指標圏Sign。Signには始対象があるが、終対象はない。Powfの代わりにPowを使えばNameが終対象となる。

&lt;h5&gt;モデル圏&lt;/h5&gt;

指標Σに対して、Record(Σ)を本編と同じ意味で用いる。Σ={name, age}のときは Record(Σ) = Record({name, age}) = Record{name, age}。Mod(Σ) = Pow(Record(Σ))とする。Mod(Σ)は順序集合なので、やはり圏とみなす。

射σ:Σ→Σ'があるとき、関手σ&lt;sup&gt;*&lt;/sup&gt;:Mod(Σ')→Mod(Σ)を次のように定義する； 定義よりΣ⊆Σ'なので、射影Record(Σ')→Record(Σ)が定義できる。この射影を自然に共変拡張してσ&lt;sup&gt;*&lt;/sup&gt;が得られる。y∈Record(Σ')を射影したΣレコードをy|&lt;sub&gt;Σ&lt;/sub&gt;と書くことにして、具体的には：

- Y⊆Record(Σ')に対して、σ&lt;sup&gt;*&lt;/sup&gt;(Y) = { x∈Record(Σ) | x = y|&lt;sub&gt;Σ&lt;/sub&gt; となるy∈Yがある}
- Y⊆Y' のとき、σ&lt;sup&gt;*&lt;/sup&gt;(Y)⊆σ&lt;sup&gt;*&lt;/sup&gt;(Y') である。

以上から、Modが指標圏Sign上のインデックス付き圏であることがわかる。σ&lt;sup&gt;*&lt;/sup&gt;は、インスティチューション用語で&lt;strong&gt;リダクト関手&lt;/strong&gt;である。

&lt;h5&gt;文集合と充足関係&lt;/h5&gt;

値の型（ソート）を S = {Never, Void, Null, Boolean, Number, String, AnyValue}とする。記号と対応する値の集合を同一視（記号の濫用）する。

指標Σに対して、a∈Σ、s∈S による a : s という形を&lt;strong&gt;文&lt;/strong&gt;と呼ぶ。Σに対する文の全体をSen(Σ)とする。Σ⊆Σ'なら、Sen(Σ)⊆Sen(Σ')なので、Senは指標圏から集合（包含）圏への関手となる。

XをMod(Σ)の対象とする。つまり、XはRecord(Σ)の部分集合。このとき、X |= 'a : s' とは：

- すべてのx∈Xに対して、x.a ∈ s （sは集合とみなして）

文の集合は {a : s, b : t}のような形に書ける。これをレコードの&lt;strong&gt;仕様&lt;/strong&gt;または&lt;strong&gt;スキーマ&lt;/strong&gt;と呼ぶ。充足関係は、モデル（レコード集合）とスキーマのあいだにまで自然に拡張することができる。

Σ⊆Σ' 、a∈Σ、Y⊆Record(Σ') のとき、σをΣ→Σ'の包含写像だとして：

- σ&lt;sup&gt;*&lt;/sup&gt;Y |= 'a : s'  ⇔ Y |= 'a : s'

これはインスティチューションの&lt;strong&gt;充足条件&lt;/strong&gt;である。

&lt;h5&gt;スキーマ／セオリーの圏&lt;/h5&gt;

ソートs, tなどを集合とみなして（記号の濫用をしている）s⊆tのとき、「a : s ならば a : t」のような推論ができる。適当な方法で“レコード論理”（演繹系）を構成したとして、演繹で閉じている文の集合（無限集合許す）を&lt;strong&gt;セオリー&lt;/strong&gt;と呼ぶ。レコードのスキーマ（文の任意の有限集合）が与えられたとき、演繹閉包としてセオリーが定まる。スキーマαのセオリーを[α]と書くことにする。

2つのスキーマα、βに対して、[α]⊆[β]のとき、α≦β とすると、この順序でSch(Σ)（指標Σ上のスキーマ）はプレ順序集合となる。セオリーの集合Theo(Σ)に関しても同様に（むしろより簡単に）順序を定義できる。

&lt;h5&gt;2つの型階層&lt;/h5&gt;

以上で、指標圏Sign上にMod、Sch、Theoのインデックス付き圏の構造が入った。Sch、Theoは同じようなものなので、MoｄとSchを考える。

インデックス付き圏ModとSchの平坦化により、2つの圏ができるが、これが外延的型階層と内包的型階層を与える。具体的には、X⊆Record(Σ)、Y⊆Record(Σ')、α⊆Sen((Σ)、β⊆Sen(Σ')として：

- (Σ, X)、(Σ', Y)が、Σ⊆Σ' であり、Y|&lt;sub&gt;Σ&lt;/sub&gt;⊆X のとき、(Σ', Y)は(Σ, X)のサブタイプである。

- (Σ, α)、(Σ', β)が、Σ⊆Σ' であり、[α]⊆[β] のとき、(Σ', β)は(Σ, α)のサブタイプ（派生スキーマ）である。

この2つの階層は、内包外延双対性により対応する。


</body>
</day>
<day date="2007-08-11" title="">
<body>
*1186795683*[プログラム意味論]大局的プログラミング：現状と対策

なんらかの、プログラミングに有用な概念なり発想は、

+ 言語機能として取り入れられるのが最善、
+ ライブラリ／開発ツールでサポートするのが次善、
+ 手法、規約で実践するのは、それしかできないとき。

さて、&lt;strong&gt;大局的プログラミング&lt;/strong&gt;（programming in the large）とは、モジュールを組み合わせることをプログラミング行為と位置づけたものだが、通常、設計とかアーキテクチャ策定とか呼ばれている行為と同じと考えてよい。同じではあるが、&lt;em&gt;一種のプログラミングなのだ&lt;/em&gt;、という立場から大局的“プログラミング”と呼ぶ。

大局的プログラミングに関して

+ 言語機能
+ ライブラリ／開発ツール
+ 手法／規約

によるサポート状況は? というと：

+ import, require, use などと呼ばれる機能だけ。きわめて貧弱。
+ いろいろなツールがあるが、通常のプログラミング行為とギャップがあり、使いやすくはない。使われていない。
+ 一番利用されているのはデザインパターン・カタログだろうか。

プログラミング言語が、大局的プログラミングをサポートするのは当面期待できないので、手法／規約を中心として、開発現場に応じてライブラリ／ツール・サポートを追加していくことになるのだろう。

*1186795751*[プログラム意味論]大局的プログラミング：必要性と定義

大局的プログラミング（programming in the large）は必要か？ この問は、設計（デザイン）やアーキテクチャが必要か？ という問と同じだから、答はYESに決まっている。

とはいえ、大局的プログラミングの定義や捉え方は人によりかなり異なる。僕自身は、設計と同義ではあるが、通常プログラミング（programming in the small）と同列に、かつ相似的に扱いたい、という意図がある。

多くの人が（専門家も含めて）、&quot;large&quot;をシステムや開発チームが大規模であると解釈しているようだが、Goguenは「そうではない」と言っている（と思う）。programming in the smallとprogramming in the largeの違いは、一個のモジュールの中身を作ることに注目するか、複数のモジュールの組み合わせに注目するかの違いであり、サイズの問題ではない、と。ただし、システム／開発チームの規模が大きくなれば大局的プログラミングの重要性が増すのは明らかである。

Goguenは、モジュール（あるいはソフトウェア・コンポネント）の組み合わせ方を整理している。それは、通常プログラミング（programming in the small）のデータ型や制御構造に相当する。

*1186795903*[プログラム意味論]大局的プログラミング：プログラミング言語／ツール

大局的プログラミング（programming in the large）もプログラミングなのだから、当然にプログラミング言語が必要である。が、通常のプログラミング言語に大局的プログラミングが統合された言語は存在しない。

仕様記述言語は、GoguenのOBJファミリーをはじめ山のようにあるが、どれも広く使われてはいない。仕様記述専門の言語を使え、というのはどうも無理があるのかもしれない。代替案は：

- 自然言語による記述 -- 従来型の仕様書
- 現存するプログラミング言語を使った仕様記述ツール
- 図形（グラフ）による仕様記述

僕は、現存するプログラミング言語と図形の組み合わせが有望かと思っている。もちろん、すでにグラフィカルな仕様記述ツールは存在するのだが、これがまたけっこう精密に出来ていて、相当に複雑なグラフを描くことができる -- ここが&lt;em&gt;間違い&lt;/em&gt;だと僕は思うのだ。

システム構造は複雑だから、ツールは複雑なレイアウトやレンダリングの能力を持つべき -- というのが間違い。そうじゃなくて、ツールは複雑なレイアウトやレンダリングの能力を持ってはいけないのだ。単純な構造を&lt;em&gt;強制する&lt;/em&gt;ことに意義があるのだから。

「いかに単純化するか」が努力目標なのであって、複雑なレイアウトに対応することには弊害しかない。複雑なレイアウトでしか描けない構造は、その構造のほうがダメなのだ。

*1186796578*[リンク][プログラム意味論]大局的プログラミング：参照

まず、Goguen（とTracz）の論文

- &quot;An Implementation-Oriented Semantics for Module Composition&quot; (1997) →http://citeseer.ist.psu.edu/539931.html

Implementation-Orientedという題名から、現場的かと思ったが、今見たらそうでもない、相当な予備知識が必要だったわ :-&amp;lt; 。1.5節と1.6節にモジュールの複合（composition）について書かれている。

大局的プログラミング一般については、

- http://www-adele.imag.fr/~jmfavre/ENSEIGNEMENT/TRANSPARENTS/ProgrammingInTheLarge/19/ProgrammingInTheLarge-19.pdf

↑のスライドがなかなかいい。スライドなので説明は十分ではないが、絵を眺めながら自分で行間を埋めると、色々な知見やヒントを得られるだろう。


</body>
</day>
<day date="2007-09-06" title="">
<body>
*1189058959*[リンク][圏一般論]A CONCRETE INTRODUCTION TO CATEGORIES

- Title: A CONCRETE INTRODUCTION TO CATEGORIES
- Author: WILLIAM R. SCHMITT
- URL: http://home.gwu.edu/~wschmitt/papers/cat.pdf
- 60ページ

タイトル通りに具体的。随伴の紹介がゴール。

*1189065514*[計算]無名ラムダ変数とセクション記法

混乱を招くこともあるが、Haskellのセクション記法が便利なこと気付いた。

- (△b) = λx.(x△b)
- (a△) = λx.(a△x)

特に、関数結合;に対して使うと：

- (;f)(u) = u;f 後結合＝前送り
- (f;)(u) = f;u 前結合＝引き戻し

*1189070407*[リンク][プログラム意味論][圏一般論]Normalization and the Yoneda Embedding

- スライド -- http://www.cs.chalmers.se/~peterd/slides/Uppsala.ps
- 論文 -- http://www.site.uottawa.ca/~phil/papers/paper_final.pub.ps


</body>
</day>
<day date="2007-09-07" title="">
<body>
*1189132181*[課題][リンク][物理っぽい][DFD]離散物理としてのグラフ理論

有本さんの本は、深谷さんとの対談だけ読んでほっておいたが、すごく面白いことが書いてある。第2章「最適化とアルゴリズム」の最初を読んで「ホエーッ」と感心。しばらく、このあたり（以下に書く）を調べて考えてもいいと思った。

光の粒子性と波動性という話は、量子力学を持ち出さなくても、古典幾何光学のレベルでもモノスゴク面白い。有本さんによると、フェルマーの原理（変分原理）とホイヘンスの原理に対して、ベルマン（Bellman）の原理（最適性の原理; Principal of Optimality）とダイクストラのアルゴリズムが対応するそうだ。

ダイクストラのアルゴリズムは、波頭集合（ウェーブフロント）を追いかける方式になっている。測地線を求めるときなどは距離の三角不等式が成立しているから「急がば回れ」があり得ないが、局所距離とは限らない一般的コスト関数では「急がば回れ」がある。そのため、波頭が目的地に到着しても“回り込んで（遠回りして）”伝搬する別な波頭とのコスト比較がありえる。

局所三角不等式、測地線、ほんとの最短経路、距離などの意味を再認識できる。

光や音の場合、衝撃による球面波を一種のアトム（基本要素）と考えて、球面波の重ね合わせで一般の波（特に平面波）が合成できる。ある一点での波の影響は、すべての波源（衝撃の発生地点）の影響を積分するばよい。

この“積分”の対応物は、フロイド／ウォーシャル・アルゴリズムになっている。僕が以前から興味を持っていた、行列絵算（pictorial matrix calculation）がフロイド／ウォーシャル計算と同じだ（絵を使うが）。これは、ファインマンの経路積分と似ているし、クリーニ（クリーネ）・スターの計算にも使える（僕は、ファインマン／クリーネの経路和公式と呼んでいる）。

波頭集合は、媒質空間内で超局面（の族）となる。この超局面族に直交する曲線族をとると、それが（粒子的な）光の進行経路となる。ホイヘンスの原理で局所的に積み上げた波頭集合に対する直交経路が、結果的に変分原理を満たすってところが面白い。さらに、経路に沿った総和が遠隔作用を与える。

光や音のモデルは、競争（ゲーム）やウィルスの感染などとも通じる。コストとなるスカラーをマックス・プラス代数を取ると、最適化に便利。これがまたトロピカル幾何に繋がったりする。ここらのことは『差分と超離散』にも少し出ていた。

- ホイヘンス（Huygens; ハイゲンス）「光についての論考」（ライデン, 1690年, 初版）http://www.kanazawa-it.ac.jp/dawn/169001.html
- Vaughan Pratt, ENRICHED CATEGORIES AND THE FLOYD-WARSHALL CONNECTION (April, 1989) - http://boole.stanford.edu/pub/am4.pdf
- ワーシャル-フロイド法 - Wikipedia - http://ja.wikipedia.org/wiki/%E3%83%AF%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%AB-%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E6%B3%95
- C++によるFLOYD-WARSHALL法の記述 http://www.prefield.com/algorithm/graph/floyd_warshall.html
- Exotic Semirings - http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733
- Yetterの線形代数と行列計算 - http://d.hatena.ne.jp/m-hiyama-memo/20070427/1177658550

*1189138007*[物理っぽい][雑感][DFD]光、音、熱

とかの本を持っているかな、と思ったら、ないな。フーリエ解析とか関係するだろうが、それもないし。

古典的で露骨な計算がたくさん出てくる物理数学の本があればいいのかな。最近みかけないなー。

*1189152250*[TQFT][形式言語理論][計算][DFD]フロイド／ウォーシャル法とダイクストラのアルゴリズム

ちょっと考えてわかったこと： フロイド／ウォーシャル法は半環係数で考えても非常に一般的な方法だ。境界付きグラフ（リグラフ）の始境界であたえられた初期値が無限の未来に終境界にどのような影響を与えるかを計算する。

ダイクストラのアルゴリズムは、始境界も終境界も1点である場合のフロイド／ウォーシャル法と同等である。例えば、点光源から出た球面波の別な一点への影響とか。積分（総和）する量（重さ、コスト、長さなど）が比較可能なとき、重ね合わせの代わりに比較を用いると、変分原理との関係が出てくる。

離散的な場合の比較は、マックス・プラス代数またはミニ・プラス代数を用いた定式化となり、変分原理の局所版としてベルマンの原理が使える。ベルマン方程式は、次の形に書ける。ここで、aは基点、N&lt;sub&gt;+&lt;/sub&gt;(x) は、点xに入る隣接点の集合、Lは基点からの大域的最適値（距離など）、a(y, x)はyからxに至る辺に与えられたコスト。

- L(a) = 0
- L(x) = min{y∈N&lt;sub&gt;+&lt;/sub&gt;(x) | L(y) + a(y, x)}

記法を変えて、和を積、minを和の形にして、A(y, x)を辺に割り当てられた接続係数だとすると、

- L(a) = e
- L(x) = Σ{y∈N&lt;sub&gt;+&lt;/sub&gt;(x) | A(y, x)・L(y)}

のように書けるが、これは点xでの値を基点aからの経路和（経路積の重ね合わせ）で求める公式に他ならない。


</body>
<comments>
<comment>
<username>sakesnare</username>
<body>はじめまして。1年くらい前からこの日記を読ませていただいています。&lt;br&gt;大学院でグラフアルゴリズムについて研究しています。あと、圏論とXMLに興味があって、少しずつ勉強してます。&lt;br&gt;&lt;br&gt;この話、非常にためになりました。深さ優先探索のバックトラックを光の道筋としてとらえたらどうなるだろうか？とか考えさせられました。&lt;br&gt;&lt;br&gt;今後ともよろしくお願いします。</body>
<timestamp>1190717957</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>sakesnareさん、&lt;br&gt;＞ 1年くらい前からこの日記を読ませていただいています。&lt;br&gt;メモ編にも読者がいるんですねぇ… プライベートメモを晒しておくのも少しは意味があるのかな？&lt;br&gt;&lt;br&gt;＞ 大学院でグラフアルゴリズムについて研究しています。あと、圏論とXMLに興味があって、少しずつ勉強してます。&lt;br&gt;&lt;br&gt;グラフ、圏論、XML、それと物理的な概念は、たぶん内在的・必然的に繋がっているんだと思います。形式言語理論（オートマトンの絵を描けばグラフですよね）が、場の理論のような物理的な定式化を許すこと（http://www.chimaira.org/docs/FLT-Questions.htm参照）は、その状況証拠のひとつでしょう。&lt;br&gt;形式言語理論のときは、グラフ（離散的空間）に乗る“場の量”がクリーネ代数という非可換半環なのですが、エキゾチック半環（http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733）にすれば最適化問題になります。&lt;br&gt;いずれの場合でも、波（に比喩できる伝搬現象）の時間発展半群を追いかけた解が経路積分（総和）の形式でも書ける、という意味で変分原理とか双対原理を満たしているように見えます。&lt;br&gt;&lt;br&gt;ある抽象レベルでは、連続的時空の物理も離散空間（グラフや複体）上の物理も同じような定式化を持っていて、離散物理のほうは計算やアルゴリズムの説明に使えるのではないか -- というのが僕の妄想です。</body>
<timestamp>1190772947</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>返信ありがとうございます。&lt;br&gt;通常の日記も、キマイラのサイトも読ませていただいてます。&lt;br&gt;&lt;br&gt;＞ある抽象レベルでは、連続的時空の物理も離散空間（グラフや複体）上の物理も同じような定式化を持っていて、離散物理のほうは計算やアルゴリズムの説明に使えるのではないか -- というのが僕の妄想です。&lt;br&gt;&lt;br&gt;これは、納得です。私はまだそんなに勉強していないんで直感的なことしか言えないんですが、&lt;br&gt;&lt;br&gt;「視覚」という感覚に依存しているような気がするんです。&lt;br&gt;&lt;br&gt;物理的なイメージも、計算過程のイメージも、言語を認識するときも脳内で「視覚」を用いた（？）イメージとして変換されることで統合されていると思うんです。&lt;br&gt;&lt;br&gt;仮想的な光を制御する「場」を脳内に作り出して、&lt;br&gt;&lt;br&gt;・その中で図（グラフ等）を変形さしたりなぞったり&lt;br&gt;・計算するための記号（文字も辺に向きや長さや曲がり具合（トメ、ハネ、ハライとか）をつけた、ある種のグラフのような気がして。）を印字したり&lt;br&gt;&lt;br&gt;しているんじゃないかなあとか思ったりします。それを他の人と通信するために本にしたりネットに流したり会話したりしてるのかなあとも思ったりします。</body>
<timestamp>1190776214</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>グラフアルゴリズムについて研究していく過程で、マトロイドという概念と出会いました。グラフの閉路、木、補木、カットセットと非常に関係が深いです。とても、おもしろい構造を持ってます。&lt;br&gt;&lt;br&gt;参考となるようなリンクを貼っておきます。&lt;br&gt;&lt;br&gt;もし、ご存知でしたらすいません。&lt;br&gt;&lt;br&gt;独立性と従属性について, 辻下 徹&lt;br&gt;http://www.ritsumei.ac.jp/se/~tjst/doc/tjst/962-cs.pdf&lt;br&gt;&lt;br&gt;この資料の最後の方に、高次元圏論についてもふれられていました。</body>
<timestamp>1206883865</timestamp>
</comment>
</comments>
</day>
<day date="2007-09-08" title="">
<body>
*1189220609*[物理っぽい]熱伝導のフラストレーション

昨日：
&gt;&gt;
光、音、熱とかの本を持っているかな、と思ったら、ないな。フーリエ解析とか関係するだろうが、それもないし。
&lt;&lt;

探したら一冊出てきた。 小出昭一郎『物理現象のフーリエ解析』 -- 存在さえ忘れていたけど、なかなか良さそうな本です。

で、熱伝導のところを読んでみたら、えらいフラストレーションがぁ、、、

+ 次元解析がされてない。ようするに単位を外した計算になっている。
+ 普通のことではあるが、微分形式とベクトルの区別がない。
+ 純幾何学的ベクトルと、なんらかの意味での速度ベクトルの区別がない。
+ アフィン空間と付随するベクトル空間の区別がない。

結局、1次元のベクトル量、アフィン的点とベクトル、平行移動、外微分、共変微分とかをキッチリ導入しないと僕にはわからない、ってことらしい。とりあえず、キッチリ次元解析してみるかな。

*1189227077*[物理っぽい]ベクトル解析／テンソル解析

本編&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070809/1186622706&quot;&gt;「テンソル：なぜ難しいのか」&lt;/a&gt;とかでも書いたけど、ベクトル解析／テンソル解析って不満だよなー。&lt;em&gt;実に不満。&lt;/em&gt;

熱伝導のフラストレーションも、ベクトル解析／テンソル解析のフラストレーションなんだろう。ちょっと再定式化してみようか。って「ちょっと」で&lt;em&gt;済まない&lt;/em&gt;のだけど…、せめて用語法を整理してみるか。

普通の用語法と食い違うのだけど、1次元のベクトル空間をスカラーと呼ぶ。空間X上のスカラー場ってのは、スカラー（1次元のベクトル空間！）のバンドルLのセクションだけど、もう少し一般化して、X上の開集合の族U&lt;sub&gt;i&lt;/sub&gt;と、Γ(U&lt;sub&gt;i&lt;/sub&gt;)の元（局所セクション）f&lt;sub&gt;i&lt;/sub&gt;の組(U&lt;sub&gt;i&lt;/sub&gt;, f&lt;sub&gt;i&lt;/sub&gt;)の族とでもするといいかもしれない。単一の(U, f)でもいいけど、ものすごくデカイ族でもいい。関数というのは、End(L)のセクションとして出てくるのが自然だろう。0にならない関数の掛け算はAut(L)として群作用する（伸縮作用）。

1次元のアフィン空間はスカラーポテンシャルと呼ぶ。高さとか温度とかね。スカラーポテンシャルの場と基準ゼロを与えるセクションを決めると、ポテンシャルはスカラーにより表現できる。これはファイバーの次元が増えても同じで、なんらかのポテンシャル場にゼロ・セクションを決めるとベクトル場になる。

（話が飛ぶが）接続の代数的な定式化って共変微分だよな、確か。Vがベクトルバンドル、Tが接バンドルとして、D:Γ(V)→Γ(V(×)T&lt;sup&gt;*&lt;/sup&gt;)という微分作用素が共変微分。V(×)T&lt;sup&gt;*&lt;/sup&gt;は、Vに値を取る微分形式Ω[V]と同じことだから、D:Γ(V)→Γ(Ω[V])でもいい。Γ(V)もΓ(Ω[V])も関数環（可換代数）R上の加群で、f∈Rにはdf∈Ωが前もって定義されている。

共変微分とは、上の設定でライプニッツ法則を満たすような微分作用素。共変微分の空間はアフィン空間になるようだ。α、βをα+β=1となる定数とすると、aD+βD' も共変微分になる。これ、昔、みつけたこと。だが、その意義は分からない。

ポテンシャルのバンドルはアフィン空間のバンドルでいいのか？というと、実際は局所アフィンなだけだろう。接続の幾何学的な意味は、アフィン空間の開集合の直積U×Vでバンドルの局所座標を入れられて、水平葉層構造みたいなスライスが存在することだろう。このスライスのなかに接続（平行移動）や共変微分が潜んでいるのだと思うけど、いまいちわからない。


</body>
<comments>
<comment>
<username>oto-oto-oto</username>
<body>&gt; だが、その意義は分からない。&lt;br&gt;森田茂之「微分形式の幾何学」に同じと思しき定理が載ってました。曰く、&lt;br&gt;「有限個の接続を接続全体の空間の中でそれぞれ点とみなせば, それらを頂点とする多面体の生成する&quot;まっすぐな空間&quot;がこの空間の中にすっぽり含まれているということである。」&lt;br&gt;だそうです。&lt;br&gt;最近では接続全体の空間を考えることが重要になっているともありました。</body>
<timestamp>1333716091</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&lt;br&gt;&gt; 有限個の接続を接続全体の空間の中でそれぞれ点とみなせば, &lt;br&gt;&gt; それらを頂点とする多面体の生成する&quot;まっすぐな空間&quot;がこの空間の中にすっぽり含まれているということである。&lt;br&gt;&lt;br&gt;アフィン空間の凸領域なのでそういうことになります。けれど、なんかに使えるのかな？ &lt;br&gt;計算したらそうなった、という以上に何にも思いつきませんでしね。&lt;br&gt;&lt;br&gt;&gt; 最近では接続全体の空間を考えることが重要になっているともありました。&lt;br&gt;&lt;br&gt;そうなんですか。&lt;br&gt;幾何学的／物理的な量が接続の空間の上の関数になっていることはあるようです。&lt;br&gt;接続の空間がアフィン凸だとすると、端点での値には意味があるのかも。</body>
<timestamp>1333785799</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&lt;br&gt;&gt; でしね。&lt;br&gt;で、死ね。&lt;br&gt;ウソッ。「ですね」のタイポ。</body>
<timestamp>1333786226</timestamp>
</comment>
</comments>
</day>
<day date="2007-09-11" title="">
<body>
*1189481990*[計算]絵算から等式への翻訳結果

本編&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070911/1189474950&quot;&gt;「デカルト閉圏における絵算 詳細編」&lt;/a&gt;に対する等式的計算。
&lt;pre&gt;
○○○ = (b&lt;sup&gt;a&lt;/sup&gt;×out&lt;sub&gt;a&lt;/sub&gt;);eval;in&lt;sub&gt;b&lt;/sub&gt;

△△△ = Λ&lt;sub&gt;a'&lt;/sub&gt;[○○○]
　　　 = Λ&lt;sub&gt;a'&lt;/sub&gt;[(b&lt;sup&gt;a&lt;/sup&gt;×out&lt;sub&gt;a&lt;/sub&gt;);eval;in&lt;sub&gt;b&lt;/sub&gt;]
&lt;/pre&gt;
とする。

&lt;pre&gt;
(Λ&lt;sub&gt;a'&lt;/sub&gt;[(b&lt;sup&gt;a&lt;/sup&gt;×out&lt;sub&gt;a&lt;/sub&gt;);eval;in&lt;sub&gt;b&lt;/sub&gt;]×a);[(b'&lt;sup&gt;a'&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);eval;out&lt;sub&gt;b&lt;/sub&gt;]
 
 = // Step1 △△△の導入と括弧の付け替え
(△△△×a);(b'&lt;sup&gt;a'&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);(eval;out&lt;sub&gt;b&lt;/sub&gt;)

 = // Step2 Shift（交替律）
(b&lt;sup&gt;a&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);(△△△×a');(eval;out&lt;sub&gt;b&lt;/sub&gt;)

 = // Step3 △△△の展開と括弧の付け替え
(b&lt;sup&gt;a&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);[(Λ&lt;sub&gt;a'&lt;/sub&gt;[○○○]×a');eval];out&lt;sub&gt;b&lt;/sub&gt;

 = // Step4 β変換
(b&lt;sup&gt;a&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);[○○○];out&lt;sub&gt;b&lt;/sub&gt;

 = // Step4.5 ○○○の展開
(b&lt;sup&gt;a&lt;/sup&gt;×in&lt;sub&gt;a&lt;/sub&gt;);[(b&lt;sup&gt;a&lt;/sup&gt;×out&lt;sub&gt;a&lt;/sub&gt;);eval;in&lt;sub&gt;b&lt;/sub&gt;];out&lt;sub&gt;b&lt;/sub&gt;

 = // Step5 交替律とid;id = id
[(b&lt;sup&gt;a&lt;/sup&gt;×(in&lt;sub&gt;a&lt;/sub&gt;;out&lt;sub&gt;a&lt;/sub&gt;)];eval;(in&lt;sub&gt;b&lt;/sub&gt;;out&lt;sub&gt;b&lt;/sub&gt;)

 = // Step6 in;out = id
(b&lt;sup&gt;a&lt;/sup&gt;×a);eval;b

 = // Step7 f;id = f, id;f = id
eval
&lt;/pre&gt;

</body>
</day>
<day date="2007-09-12" title="">
<body>
*1189584129*[トレース／コンパクト閉圏][計算]トレースとラムダが部分的に自然変換であること

トレースを Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;:&lt;i&gt;C&lt;/i&gt;(A×X, B×X)→&lt;i&gt;C&lt;/i&gt;(A, B)と書くことにして、Xを固定して、A, Bを動かす。すると、Trが、&lt;i&gt;C&lt;/i&gt;(-×X, -×X)⇒&lt;i&gt;C&lt;/i&gt;(-, -):&lt;i&gt;C&lt;/i&gt;&lt;sup&gt;op&lt;/sup&gt;×&lt;i&gt;C&lt;/i&gt;→&lt;b&gt;Set&lt;/b&gt;という自然変換になっている。この事実を書き下すと、両側タイトニング公式となる。

同じようにラムダ抽象 Λ&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;:&lt;i&gt;C&lt;/i&gt;(A×X, B)→&lt;i&gt;C&lt;/i&gt;(A, B&lt;sup&gt;X&lt;/sup&gt;)は、&lt;i&gt;C&lt;/i&gt;(-×X, -)⇒&lt;i&gt;C&lt;/i&gt;(-, -&lt;sup&gt;X&lt;/sup&gt;):&lt;i&gt;C&lt;/i&gt;&lt;sup&gt;op&lt;/sup&gt;×&lt;i&gt;C&lt;/i&gt;→&lt;b&gt;Set&lt;/b&gt;の&lt;em&gt;自然同型&lt;/em&gt;になっている。この事実を書き下すと、デカルト閉圏の公式はすべて出る。


</body>
</day>
<day date="2007-09-13" title="">
<body>
*1189640319*[雑記][説明]半完成品の例

本日は朝から疲れている。

それはそれとして、半完成品＝未完成品のようなもの：

+ テキストのテンプレート
+ 抽象クラス
+ ジェネリックス（パラメータ）
+ DI
+ ビヘイビア（Erlang用語）
+ 一般的フレームワーク

*1189669892*[説明][論理][計算]カリー／ハワード対応の簡単な例

なんでこんなにだるいんだ？

それはともかく：

|* 自然演繹 |* ラムダ計算 |* デカルト閉圏 |
|∧導入     |タプリング   | 直積 |
|∧消去     |射影         | 射影 |
|⊃導入     |ラムダ抽象   | Λと指数 |
|⊃消去     |適用         | eval |
|T（真）    |ユニット型   | 終対象 |


</body>
</day>
<day date="2007-10-24" title="">
<body>
*1193191763*[圏一般論][雑記]Catはデカルト閉圏だが…

最近、メモ編は全然書いてないな。なにしろ、HTMLだの&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20071023/1193128102&quot;&gt;Makefile&lt;/a&gt;だの書いているからな、ダハハハハハ。

Catがデカルト閉圏であることは周知のことだが、自分で確認してみた。が、これをキーボードで記述するのは&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;エライ大変！&lt;/b&gt;&lt;/span&gt; 紙に描いた絵をスキャンして貼り付けようか、、、

とっ、紙がどっかにいった。ゴミになったかもな。

</body>
<comments>
<comment>
<username>sakesnare</username>
<body>Diaっていう描画ソフトものすごい使いやすいですよ！オススメです。&lt;br&gt;http://www.gnome.org/projects/dia/</body>
<timestamp>1193831836</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>sakesnareさん、&lt;br&gt;情報ありがとうございます。&lt;br&gt;でも横着な僕は、スタバの紙ナプキンに描き続けそう。</body>
<timestamp>1193832201</timestamp>
</comment>
</comments>
</day>
<day date="2007-10-31" title="">
<body>
*1193832528*[からみ系]大槻さんの本、壊れそう

最近もっぱら実務家（って何だ？）の僕。ついカッとなって（って何だ？）、古本屋で大槻さんの QUANTUM INVARIANTS を衝動買い。

しかしこれは、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20061204/1165192323&quot;&gt;僕の嫌いなハードカバー&lt;/a&gt;。もう既に背表紙から紙がはがれかかっている。なんかすぐにバラバラになりそう、、、トホホホホ。


</body>
<comments>
<comment>
<username>sakesnare</username>
<body>ハードカバーの利点は、おそらく水と汚れに強いことだと思います。それ以外はよく分かりません。&lt;br&gt;&lt;br&gt;「僕の嫌いなハードカバー」のリンク先読みましたけど、その通りだと思います。&lt;br&gt;&lt;br&gt;話は飛ぶんですが、RELAX NGを知って、そこから繋がって生け垣オートマトンというものについて勉強を始めました。&lt;br&gt;&lt;br&gt;今、これ読んでます。&lt;br&gt;http://www.xml.gr.jp/relax/hedge_nice_ja.html&lt;br&gt;&lt;br&gt;この次に読むのなら難易度的にこれがオススメだよっていう論文や書物がいくつかあれば教えていただけませんか？</body>
<timestamp>1193837767</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>sakesnareさん、&lt;br&gt;TATAでしょ → http://tata.gforge.inria.fr/&lt;br&gt;守屋悦郎『形式言語とオートマトン』にも、ツリー関係が少しのっています。&lt;br&gt;&lt;br&gt;圏論ファンの僕としては、いずれの定式化も多少不満。カテゴリカルに整理するともっとキレイで整合的になるのに、と残念な気がします。</body>
<timestamp>1193880643</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>返信ありがとうございます。早速読んでます。&lt;br&gt;&lt;br&gt;僕は圏論とXML好きで２年前からchimaira.orgを読んでるんですが、まだこのサイトを理解できるまでの基礎勉強が足りてません。ただ、このサイトを見てると「いつか自分がこれに貢献できたら！！」と思うものがあったんで必死に勉強してます。&lt;br&gt;&lt;br&gt;m-hiyamaさんがその定式化に不満を持たれてるというので、その不満を本当に理解するためには僕自身がm-hiyamaさんが不満にもたれてる定式化を一通り勉強する必要があると思います。&lt;br&gt;&lt;br&gt;とりあえず、がんばってみます。ありがとうございます。</body>
<timestamp>1193886951</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>sakesnareさん、&lt;br&gt;＞ このサイトを見てると「いつか自分がこれに貢献できたら！！」と思うものがあったんで&lt;br&gt;おっ、貢献してくれるの。それはうれしい！ 一緒に考えてください。&lt;br&gt;&lt;br&gt;＞ m-hiyamaさんがその定式化に不満を持たれてるというので、&lt;br&gt;不満つうか、TATAみたいなスタイルが苦手なんですよ。ようするに横着なんですが、細かく調べる前に、自由な大枠を作ってからのほうが楽だと思うわけで。&lt;br&gt;&lt;br&gt;気が向いたら、ヘッジがかなり良い性質も持つ圏であることをどっかに書きましょう（気が向いたらだけど^^;）。</body>
<timestamp>1193890799</timestamp>
</comment>
</comments>
</day>
<day date="2007-11-02" title="">
<body>
*1193977645*[連絡的][WCC]Simple EL = Simplel

&quot;Simple EL = Simplel&quot; は、実用性を損なわない範囲内で、&lt;em&gt;できるだけ単純&lt;/em&gt;にした式言語である。テンプレート内での使用を想定しているが他の目的でも使えるだろう。JavaScript, JSONの構文の影響を受けている。

&lt;h5&gt;悩んでいる点&lt;/h5&gt;

参照を表す目印に'$'を使うべきか？ Smartyな人にはドルがあったほうがいいだろうが、個人的にはうるさくて嫌い。

とりあえずドルなしでいってみる。

&lt;h5&gt;構文基本要素&lt;/h5&gt;

トークン：

+ 整数リテラル
+ 文字列リテラル
+ 名前
+ '.'
+ '['
+ ']'
+ '('
+ ')'
+ ','

丸括弧には、単なるまとまりと関数呼び出しの2つの使用法がある。

- 整数リテラルは普通、JSON仕様参照
- 文字列リテラルも普通、二重引用符のみ使用。JSON仕様参照。UnicodeはUTF-8を前提。
- 名前開始文字 ::= 英字、名前文字 ::= 英字|数字|アンダスコア

&lt;b&gt;[追記]&lt;/b&gt;'|', '$', '@'は予約。'|'はすぐに使うことになるだろう。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;構文定義&lt;/h5&gt;

すべての空白は無視される。

+ パス ::= 名前 | パス '.' 名前 | パス '[' 式 ']'
+ 関数呼び出し ::= パス '(' 引数並び ')
+ 引数並び ::= 空 |  式 (',' 式)*
+ 式 ::= リテラル | パス | 関数呼び出し | '(' 式 ')'

&lt;h5&gt;データ型&lt;/h5&gt;

+ 整数 integer
+ 文字列 string
+ 関数 （関数も値） function
+ 配列
+ マップ（プロパティリスト）

配列は整数インデックス（0以上）でアクセスされ、マップは名前キーでアクセスされる。ただし、foo.bar ≡ foo[&quot;bar&quot;]、foo.1 は構文上許されないが、意味的には foo.1 ≡ foo[1]。

&lt;h5&gt;環境と評価&lt;/h5&gt;

環境（またはコンテキスト）は、式が評価されるときに名前の実体を与えるマップ。環境をE、環境へのアクセスを get_by_key/2, get_by_index/2 とすると、評価規則は、

+ 【名前】= get_by_key(E, 名前)
+ 【パス.名前】= get_by_key(【パス】, 名前)
+ 【パス[式]】= get_by_index(【パス】, 【式】) OR get_by_key(【パス】, 【式】)
+ 【関数呼び出し】 = apply(【パス】, 【引数並び】)
+ 【引数並び】 = [【式1】, 【式2】, ...] （右辺はリスト）

*1193986959*[メモ]Emacsメニューを消す

&lt;pre class=&quot;code&quot;&gt;
(menu-bar-mode 0)
(tool-bar-mode 0)
&lt;/pre&gt;

値 0, -1, 1を試してみよう。

</body>
</day>
<day date="2007-11-07" title="">
<body>
*1194398243*[連絡的][WCC]Simple ELの構文ポリシー

Smartyは割と中立的な構文だが、それでもPHP臭さが若干はある。Smarty完全互換は苦しい。とは言っても、中途半端な独自構文は避けたい！

それで、JavaScriptのサブセットになるようにしようと思う（JSONと同じポリシー）。制限されたJavaScript式ということだね。互換性はJavaScriptのインタプリタで確認すればいい。


</body>
</day>
<day date="2007-11-09" title="">
<body>
*1194580906*[からみ系][雑感]Functorial Knot Theory

makeは一段落、次はbashとEmacsを勉強し直して、GNU autotoolsもやんなきゃね。それとActionScript3ですか、、、って、なんでまた俺がいまさらぁ？ なわけだ。

&quot;Quantum Invariants&quot;に引き続き、イエッター（David N. Yetter；ほんとはどう発音するか知らない）の&quot;Functorial Knot Theory&quot;を買った。前後半の2部に別れているのだけど、パート1だけでも少しは分かりたいな。

前半の目標はシャム（Shum；確か女性）の定理で、単一対象で自由生成されたリボン圏が、枠付きタングルの圏と同値だということ。この主張は、直感的には理解しやすい。が、かなり複雑な代数構造と低次元の幾何学的対象の総体（あるいは社会）が事実上同じだと行っているのだから、なかなかに凄まじい。

このイエッター本は、カウフマンが監修するKnots and Everythingシリーズの第26巻なんだが、このシリーズには、他にもなんだか奇妙で面白そうなタイトルがある。autotoolsだActionScriptだとかにかまっていると、一生読めそうにないな。かなしい。


</body>
</day>
<day date="2007-11-24" title="">
<body>
*1195891174*[連絡的][WCC]Simplelの論理式

Simplelの基本データ型は、整数（integer）と文字列（string）である。浮動小数点型（IEEE 754型）を入れるかどうかは考慮中、基本的には「必要性が判明するまで&lt;em&gt;入れない&lt;/em&gt;」。整数はJavaScript仕様と合わせるため、

- 絶対値が2の53乗までのデータは正確に扱えなくてはならない。絶対値が2^53を超えるときは、仕様では何も定めない。

さて、整数、文字列以外の基本データとして論理値を入れる。そのリテラル（トークン）はtrueとfalse。新しい演算記号（これもトークン）は、

- 比較： '==', '!=&quot;, '&lt;', '&lt;=', '&gt;', '&gt;=' （'==='は入れない）
- 論理： '&amp;&amp;', '||', '!'

JavaScriptとは異なり、柔軟な型変換は&lt;em&gt;当面は行わない&lt;/em&gt;。

- 整数の比較は自明。
- 文字列の s == t は、同じ長さですべてのiに関してs[i]とt[i]が同じ文字。
- != は == の否定。s != t ⇔ !(s == t)
- 文字列に対する不等号はエラー（許容しない）。
- 論理値以外に対する論理演算はエラー。（将来、仕様変更の可能性はあるが。）

Unicode文字に関する等値性は問題があるが、とりあえずUTF-8、バイトレベルでの比較でよいとする。

</body>
</day>
<day date="2007-12-01" title="">
<body>
*1196488708*[メモ法]紙のメモはなくなる！

紙にメモしてもいいが、半日以内に転記して捨てること。

*1196488907*[janus][雑記]コンポネント概念とコンパクト閉圏

実務作業の8割くらいは雑用、でへこむ。が2割くらいエッセンシャルな部分がある。

janusコンポネント概念は、具体的なプログラミング言語を固定して考えると割と具体的。なんだが、複数言語による分散アプリケーションとかを考えると、実装との距離が広がり、抽象的な感じがしてくる。

しかしその分、適用範囲が広がる。今まであまり意識しなかったのだが、プロセス、媒体（メディア）、バッファ／キュー（チャネル）などもコンポネントの特殊なケースとして記述できる。

プロセスはスレッドを持ったコンポネントだが、スレッドはメッセージ（またはメソッド）のソースとシンクという力学的な概念で記述できる。メッセージソースまたはメッセージシンクがスレッドにあたる。ソースとシンクはある主の双対だから、プロセスも双対的定式化を持つと思われる。

それと、コンポネントの圏がコンパクト閉圏なのはほぼ確信していたが、そのコンパクト閉圏がトレース付き圏（traced symmetric monoidal cat）からInt構成で作られたものかそうでないかがわからなかった。分散アプリケーションを考えると、Int構成じゃない圏の例が出てくるような気がする、たぶん。

</body>
</day>
<day date="2007-12-06" title="">
<body>
*1196930700*[雑記][説明]時間の空間 再論

以前、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061207/1165485058&quot;&gt;「“時間の空間”の圏」&lt;/a&gt;で、「時間の空間」という&lt;em&gt;変な言葉&lt;/em&gt;を使ったのだが、僕のなかでは（あくまで個人レベルで）「時間の空間」が変じゃなくなってきた。本編でも&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20071128/1196231202&quot;&gt;「時間を加工する」&lt;/a&gt;なんて書いてる。

時間の総体（totality）は、なんらかの構造を持つ幾何学的な実体、つまりは空間なんだね。

伝統的な線形時間は、全順序を持つ連続的な1次元空間。並行する（しかし無関係な）時間は、線形時間（ほぼ直線）の直和みたいな図形。分岐する時間ならツリーになるし、分岐と合流がある時間は有向グラフになる。未来が過去に影響しないという意味で因果的なら、アサイクリック・グラフ。が、サイクリック・グラフも考えていい。サイクルがあっても被覆を取ればアサイクリックにできるし。

時間の空間の次元を1次元に限定する理由もない。並列処理の幾何学的モデルでは、局所的に方向がついた（未来錐を持った）空間みたいなものを考えて、ダイホモトピーを使ったりする。

“時間の空間”から“空間の空間”への写像として運動を考えるとか、時間の空間をベースとするバンドルの切断として、時間的に分布した場（これも運動の定式化）を考えるとかできるだろう。

</body>
</day>
<day date="2007-12-07" title="">
<body>
*1197000853*[雑記]おいぼれて

昨夜、NHK木曜時代劇を見ていた。いや、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20070724/1185242221&quot;&gt;次男が好き&lt;/a&gt;なんで、僕はハナシもよくわからんままに眺めていたのだけど。

で、主人公が&lt;br&gt;&lt;b&gt;おいぼれて、おいぼれてなお、春の夢&lt;/b&gt;&lt;br&gt;とか俳句(?)を詠んでいるわけよ。

なんか、それは俺の気分だよ、と思った。

春の夢を、これからやりたいことのプランとでも解釈すると、それは&lt;em&gt;イッパイ&lt;/em&gt;ある。が、おいぼれていると問題が2つある。

+ 残された時間があまりない。
+ 体力と気力が落ちるばかり。

って、すっげー深刻な問題だぁーー。

まーまー、それはそうとして。時間と体力／気力がないなら、春の夢を追いかけるにも戦略的にならなくちゃいけない。もし仮に僕に十分な時間・体力・気力があるなら、例えば、実験も含めた物理を系統的に学んでみたいと思うのだが、現実的にはもう無理だ。

じゃぁ、実際的にどういう戦略があるのかなー？ わからんわ ＜バカじゃ

*1197011140*[メモ][課題]Generic Wikiパーザー

ってのを、今ふと思いついたんだが：

+ SAX2のXMLReaderの形にしておけばいい。
+ このReaderが返すXML文書は単純、固定的。
+ ホントの入力はもちろんXML文書じゃない。
+ Wiki構文→XMLの規則はWiki構文定義で書く。
+ 別にプラッガブルなパーザーキットが必要。
+ genericパーザーの実体はパーザードライバー。
+ Wiki構文定義はXMLじゃなくて、Wiki構文 :-)

genericパーザーが返す文書は、なじみ深いようにHTMLもどきとして：

+ &lt;del datetime=&quot;2007-12-07T17:45:52+09:00&quot;&gt;body&lt;/del&gt;doc要素：これが文書要素。メタ情報はない。
+ div要素：ブロック。
+ span要素：インライン。
+ spot要素：空内容、マイルストーンタグとか。

class属性は必ずある。その他の属性はパーザーが補助的に付加する。

*1197017152*[XML][メモ][課題]Minimal content model

そういえば、minimal content modelってあやしい概念を合理化するのをすっかり忘れていた。

</body>
<comments>
<comment>
<username>sakesnare</username>
<body>今の樋山さんのペースで、日記に記事を書いていれば自然に「春の夢」の協力者が増えると思います。&lt;br&gt;&lt;br&gt;（哲学、心理学、論理学、数学、物理学、計算機科学、プログラミング、XML、それらをまとめるマネジメント能力のある人）&lt;br&gt;&lt;br&gt;っていう分類を考えて、それぞれに特化したできるフォロワーを待つのが適策だと思います。で、それぞれの知的好奇心を刺激するような記事を書いたらよいと思います。&lt;br&gt;&lt;br&gt;XMLについて、調べていたら色んなところで樋山さんの名前をみます。XMLについて僕は素人ですが、樋山さんがかなりすごい人っていうのは、なんとなく分かりました。これからどんどんフォロワーが増えていくはずです。&lt;br&gt;&lt;br&gt;あと、「春の夢」の具体的なリストを系統的に分類して一度リストとして日記に書いたらよいと思います。&lt;br&gt;&lt;br&gt;僕は樋山さんのフォロワーですけれども、「できる人」ではありません。徐々に力をつけて、強力していきたい意志はあります。が、まだ能力が追いついていないです。</body>
<timestamp>1197036949</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>sakesnareさん、&lt;br&gt;おいぼれをencourageしていただき、ありがとうございます。&lt;br&gt;&lt;br&gt;&gt; 樋山さん&lt;br&gt;「檜山」です(^^:&lt;br&gt;他人の名前の字や読みを間違えると、あわてふためくもしれませんが（僕はそうです）、気にしなくてけっこうですよ。僕も http://d.hatena.ne.jp/m-hiyama/20071128/1196211326 なんてことやってるし。&lt;br&gt;&lt;br&gt;&gt; 自然に「春の夢」の協力者が増えると思います。&lt;br&gt;だといいんですけどね :-)&lt;br&gt;&lt;br&gt;&gt; 哲学、心理学、論理学、数学、物理学、計算機科学、プログラミング、XML、&lt;br&gt;ウワッ、僕、そんなにジャンル広くないですよ！ 南堂久史さんじゃないんだから。&lt;br&gt;&lt;br&gt;&gt; あと、「春の夢」の具体的なリストを系統的に分類して一度リストとして日記に書いたらよいと思います。&lt;br&gt;あー、それはありますね。&lt;br&gt;だいたいのところは； コンピューティングサイエンスと形式言語理論の多くの部分（と論理の一部）は、幾何学的な定式化を持ち、それは Generalized Topological Quantum Field Theory (gTQFT) の形をしているはずで、背後にはコンパクト閉圏（または類似の圏）があるのだ、てなところです。&lt;br&gt;なんでそうなのか? の内在的理由はわかりませんが、計算現象も物理現象の一種であり、物理現象の記述にはコンパクト閉圏や類似の圏が便利なのだ、と楽観的に信じいます。当然ながら、実用的な意味もあります（僕の出発点は実用ですから）。&lt;br&gt;&lt;br&gt;&gt; 徐々に力をつけて、強力していきたい意志はあります。が、まだ能力が追いついていないです。&lt;br&gt;僕’が’encourageされたのだけど、僕も若い人（まー年齢はどうでもいいのだけど）’を’encourageできればいいな、とは思っています。</body>
<timestamp>1197103002</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>檜山さん、&lt;br&gt;&lt;br&gt;返信ありがとうございます。漢字間違って申し訳ないです。m(_ _)m&lt;br&gt;&lt;br&gt;「春の夢」の概要、了解しました。&lt;br&gt;&lt;br&gt;圏論や幾何学、場の量子論を勉強してみようと思います。&lt;br&gt;&lt;br&gt;それでは。</body>
<timestamp>1197104477</timestamp>
</comment>
</comments>
</day>
<day date="2007-12-12" title="">
<body>
*1197439609*[雑記]ブックマークウィジェット

まずはこっちで試してみよう。


</body>
</day>
<day date="2007-12-14" title="">
<body>
*1197623168*[雑感][プログラム意味論]無音記号

まったくダレた一日。あー、バカみたいだ。だが、ひとつだけ考えたことがある。無音、無音記号だ。

今までも無音記号については意識していた。

- &lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%cc%b5%b2%bb&quot;&gt;「無音」で日記内検索&lt;/a&gt;

自発性とか時間の経過などが無音記号に関係しそうだ、という感じ。

無音記号は&lt;span style=&quot;font-size:x-large;&quot;&gt;ものすごく大事&lt;/span&gt;だと思えてきたぞ。

対象がアルファベット集合で、射が遷移翻訳形（トランスデューサー）の圏を考える。この圏は、あまりに一般的で複雑なんで、解析するのは大変なんだけど、まー考えることはできる。アルファベット集合は必ず無音記号を含むとすると、付点集合（pointed set）だと思ってよい。

無音記号を含まないアルファベットAがあると、A+{τ}として無音記号を付加したり、その逆で削除したりできる。が、そのとき圏の演算や構造はあまり保存しないような気がする。なんか歪みがあるんだよな。その歪みをちゃんと見ないといけない。

遷移翻訳形に無音遷移がたくさんあると、それだけ不定性（非決定性）や自発性が大きくなる。極端な例として、無音記号だけを入力として、任意の出力を作るような系がある。外からみると、これはランダム生産者（random producer）になるだろう。

なんかとりとめもないが、無音記号、無音遷移をよーく考えると、ほぼ確実に面白い。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177558963&quot;&gt;インターリーブ定理&lt;/a&gt;をなんらかの形で一般化できるかもしれない。


</body>
</day>
<day date="2007-12-15" title="">
<body>
*1197688692*[雑感][プログラム意味論]時間ってなんだ？

時間ってのは何だろう？ -- いやっ、別に宇宙論とか哲学的な問ではなくて、もっと普通の現実的な意味で、なんだけど。

プログラムが「動く」のは時間が流れるからだよね。時間が流れなければ動けない。けど、時間が流れたと認識するには時計が必要で、時計は動くもの。もし時計もプログラムだとするなら、特定の（たまたま「時計」と呼ばれた）プログラムが動くことが、時間が流れることと等価ってこと？

そうすると、「プログラムが動く」が「時間が流れる」に依存していて、「時間が流れる」が「プログラムが動く」に依存している。プログラムの世界では、どのプログラムを「時計」と呼ぶか、だけの問題なのかな？ それにしても「時計」としてふさわしい条件があるだろう。となると、時間の定義は「時計と呼ばれるにふさわしい条件」の定義になるのか。

</body>
</day>
<day date="2007-12-17" title="">
<body>
*1197884680*[雑感]視力

本編とメモ編の使い分けがわからなくなってきたが、、、、まーいい。

メガネ＋コンタクトにするしかないのかなぁ。眼の疲労がだいぶきついな。


</body>
</day>
<day date="2007-12-18" title="">
<body>
*1197977350*[雑感]お勉強お勉強、、、、って、なにをだ！

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071109/1194580906&quot;&gt;Functorial Knot Theory&lt;/a&gt;は前書きだけ、そしてついにbashの勉強はじめちゃいましたよ、トホホホホ。（ActionScriptも少し触ったしな。）


</body>
</day>
<day date="2007-12-20" title="">
<body>
*1198131652*[モナド][山勘]リストモナドの連続版

Aが任意の集合だとして、List(A)が定義できる。モナドになる。

なめらかな多様体の圏で考えるとして、任意の多様体Xに、List(X)のようなものを考える。[0, t]の形の区間の全体をSとする。必要なら∞を付けて考える。Sは包含順序で順序集合だから圏とみなせる。各I∈Sに対して、Map(I, X)を対応させ、制限写像を考えると前層になる。実際は層になっている。

この層はX上を時間に沿って動く運動の層とみなせるから、Motion(X)とする。「なめらかな多様体」の条件をゆるめるか拡大解釈するとMotion(X)が再び多様体にならないだろうか？ それができれば、Motion(Motin(X))が定義できる。ただし、Motion(Motion(X))をflattenしようとすると、とんでもなく長い直線（長い時間）が必要になってしまう。

最初からいくらでも長い直線（順序数の連続版のようなもの）を許す状況で考えればよさそうだが、そうするとコンパクト性とか可算性とかが壊滅するし、基礎論的な困難も出てきそうだし。

ウーム、無理があるか？

</body>
</day>
<day date="2007-12-26" title="">
<body>
*1198671111*[janus][雑記]新しい絵の描き方

本編 http://d.hatena.ne.jp/m-hiyama/20071214/1197598785 に書いたように、JavaのBlocking Queueを使うとスレッドをあまり気にしなくていいようになる。で、パイプラインの幾何学的形状（トポロジ）に集中できるから、パイプラインを表現する式から、動作するデータ（って変な日本語）を作り出してみようと思う。

ここ2，3日は子供の相手をしなくてもいいようだから、少し夜更かししてゴニョゴニョすべ、と思ったら、&lt;em&gt;この時間で既に眠くなる。&lt;/em&gt; だめだなー。

パイプラインを意味付ける圏は、ちゃんと考えると複雑な定式化になるのだけど、エエカガンに考えると、自然数を対象集合とする圏だと思ってよい。射は n→m の形。実は、フィルターどうしは結合できなくて、フィルターの片側にパイプを付けたものを結合する。ファイル、スレッド、副作用とかも考えると、相当に複雑な圏だが、データストリームの部分だけを取り出すとけっこう単純。外側にでかくて複雑な圏があって、そのなかに単純な圏を構成している。

フィルター、ファイル、パイプ、副作用とかをうまく表す絵の描き方を考えたほうがいいようだ。基本はコンパクト閉圏だが、符丁（アイコン）を工夫したほうがいい。呼び出し弧とデータ流が違う向きだったりするので、両方をうまく表現しないと。

*1198674752*[雑記]早寝の人

ウーム、ふだん早寝の人は夜は眠くてダメだね。

もう僕は意識が朦朧としているわ。やんなっちまうなー。

「新しい絵の描き方」は明日（以降に）考えよう。っと。


</body>
</day>
<day date="2007-12-27" title="">
<body>
*1198736903*[メモ]インフルエンザ

1月中旬に第2回予防接種行くこと。

cf. http://d.hatena.ne.jp/m-hiyama/20070324/1174723620

*1198744006*[janus][トレース／コンパクト閉圏][お絵描き]In-Outコンポネントとパイプライン

http://d.hatena.ne.jp/m-hiyama/20071226/1198629573
&gt;&gt;
年末年始にたいした予定があるわけでもないので、そこらでゴニョゴニョしているかもしれません。
&lt;&lt;

ゴニョゴニュしている。まー、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071226/1198674752&quot;&gt;早寝&lt;/a&gt;しちゃうんで時間が取れないのだが、、、

&lt;h5&gt;In-Outコンポネント図&lt;/h5&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071226/1198671111&quot;&gt;絵の描き方&lt;/a&gt;を考えた。まずは絵：

&lt;img src=&quot;http://www.chimaira.org/img2/inout-component.gif&quot; &gt;

これは、Janusのコンポネントの特殊なもの。少し説明しておく； 箱fは射、射の向きは左から右。対象は、InとOutという記号（その実体はインターフェース）から生成される荷電自由モノイド（charged free monoid）であり、モノイド積がモノイド圏構造を与える。荷電（charged）は、偏極（polarized）とか符号付き（signed）といってもよい。要するに+, -が付くこと。

今回の絵ではプラスが黒丸、マイナスが白丸にした。絵記号をまとめると：

|*絵記号   |* 意味   |* 呼び名など |
|疑問符'?' | 指標In |in, input, receive|
|感嘆符'!' | 指標Out |out, output, send|
|黒丸      | 符号+   |provide, call-in |
|白丸      | 符号-   |require, use, call-out |
|棒（ロリポップ）| ポート  | |
| 箱       | 射      | |

アルファベット{?, !}に電荷を与えた荷電アルファベット（偏極アルファベット）{+?, -?, +!, -!}上の列を [+?, -?, -!]のように書いて、この列をdomain/codomainの表現に使う。[]がモノイド単位、並置がモノイド積になる。荷電反転は単に+と-の入れ替え。

箱fの左側のポート列をarity(f)、右側のポート列をcoarity(f)とする。dom/codはarity/coarityと少し違って、

- dom(f) = arity(f)&lt;sup&gt;*&lt;/sup&gt;
- cod(f) = coarity(f)

となる。上付き星は荷電反転。

ジャンクション（Id, σとか）を導入して、図形の操作に適当な同値関係を入れるとコンパクト閉圏になる。状態遷移系で意味を与えることもできる（だろう）。今回は深入りしない。

&lt;h5&gt;伝統的なフィルターなど&lt;/h5&gt;

コンポネントのなかでプロファイルが [-?]→[-!] (require in; require out) であるものは伝統的なフィルターになる。その他に、[ ]→[+?] (none; provide in) が入力ファイル、[+!]→[ ] (provide out; none) が出力ファイル、[+!]→[+?] がパイプとなる。

&lt;img src=&quot;http://www.chimaira.org/img2/simple-inout-components.gif&quot; &gt;

パイプをpとして、フィルターf, gに対して f|g = f;p;g としてフィルターの圏が作れる。この圏はモノイダルでもないし、荷電もない。つまらん。

古典的フィルターの拡張として、arityがすべて'?'記号、coarityがすべて'!'記号からなる射を考えて、これを一般化フィルターと呼ぶ。

&lt;img src=&quot;http://www.chimaira.org/img2/generalized-filter.gif&quot; &gt;

一般化フィルターの全体は圏となり、モノイド構造が入る。が、射の双対（ベント・ジャンクション）をうまく定義できないからコンパクト閉にはならない。

&lt;h5&gt;パイプ結合演算とモノイド・プレ圏&lt;/h5&gt;

一般化フィルターに対して、cod(f) = dom(g) でなくても、ポートの本数が等しいとき、パイプ結合が定義できる。

+ 圏の意味で結合可能ならそのまま結合
+ -?と-! はパイプを挿入して結合。
+ +?と+! はポンプ（コピーフィルター）を挿入して結合。
+ その他は結合不可能とする。

こうすると、一般化フィルターの全体は、dom, codをポート本数（自然数）として圏モドキとなる。cod(f) = dom(g)でもf|gが定義できないときもあるし、明白な恒等もない。が、同値関係を入れれば、パイプやポンプが恒等を表すし、結合律もOK。ただし、結合できない事態は残るから、対象が自然数である対称モノイド・プレ圏（symmetric monoidal precategory）となる。

</body>
</day>
<day date="2007-12-28" title="">
<body>
*1198818945*[janus][トレース／コンパクト閉圏]コンポネント・ポートの極性

http://www.chimaira.org/docs/JanusIntro-2.htm#s4 より：
&gt;&gt;
ところで、use、provideのどちらをプラス（もう一方がマイナス）にするかは、まったく恣意的（どっちでもいい）なのだ。必然的、絶対的な理由や根拠なんてなくて、エイヤッと決めればいいことだ。だが、どっちでもいいことだと、かえって悩む。僕はすごく悩んでしまった。今も悩んでいる。ある日気が変わって、プラスとマイナスを逆にしたくなる、ってこともあるかもしれない。useをプラスにした理由は、下のノートに書いておく。 
&lt;&lt;

use (require) と provideに関して、引用記事では「useがプラス」。だが、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071227/1198744006&quot;&gt;昨日書いたエントリー&lt;/a&gt;では：

|*絵記号   |* 意味   |* 呼び名など |
|黒丸      | 符号+   |provide, call-in |
|白丸      | 符号-   |require, use, call-out |

useじゃなくてprovideがプラスになっている。ワハハハハッ。

&gt;&gt;
結局、日常的な感覚では、useがプラスでprovideがマイナスなのが自然な気がしてきた。それで、「use=プラス=positive=active」、「provide=マイナス=negative=passive」という対応を選んだ。 
&lt;&lt;

と、当該ノートに書いてあるが、provideはみんなに提供するんだから積極的positiveとも言えるよね、しかもprovide positive plusとPで始まって憶えやすいし。

まー、極性反転に関して理論が不変だから（これも一種の対称性）、ほんとにどうでもいいことだけど、、、

*1198819562*[説明][お絵描き][計算][具体例][セミナー][DFD]氷運搬問題

グラフ上に半環の値を付与して最適問題を解くのは、行列計算とお絵描きをつなぐ良い例題だ。

係数をmax-plus代数にすると、時間的／空間的移動に伴い累積する値を大小比較で判定される（少ないと負け）状況を表現できる。実数区間[0, 1]のmax-times代数の場合は、移動に伴い減衰する非負値を大小比較で判定される状況を表現できる。

例えば、あるノードから全員同じ重さの氷を運ぶとして、変ごとに70%とか50%とかで重さが減る（解ける）とする。各ノードでは誰の氷が一番重いかを判定して、負けた人は脱落する。この設定では、どうしたら氷を解かさないで運べるか、目的地到着時の氷の重さの最大値とかを云々できる。

*1198823595*[説明][お絵描き][具体例][セミナー][DFD]行列計算とグラフ上の物理

お絵描きお稽古会をやりたいなー、と思っている、来年。

入り口は行列計算かな。{0, 1}とか自然数係数で2×2とか2×3くらいから入る。係数をmax-plusやmax-timesにしてみると面白い（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071228/1198819562&quot;&gt;氷運搬問題&lt;/a&gt;）。行列＝二部グラフとして、まずは基本計算を示す。

行列積は、二部グラフの単純結合（境界の同一視）の後で図形的縮約をし、係数を計算しえ付け替える。実は和のほうがむずかしくて、直和してから重複器と可算器を繋げる。このとき、トーラスとかチューブ（円筒）とか、曲面の例も一緒に出すといい。境界概念がはっきりする。

行列の積の図形化から、積和の公式が、経路総和（ファインマン和）であることを納得する。

- (B・A)[i, j] = Ωi,j(A;B) 左は代数的、右は幾何的に解釈する

Ωi,j(G) というのは、半環係数で付値されたグラフGの始境界点iから終境界点jに至るすべて経路の関して、経路値（経路積）を総和したものである。さらに、境界点iを動かすとΣi(Ωi,j(G))として、点jへの始境界全体からの影響が求まる。

正方行列Aの両境界をつないで円筒状にする。円筒の測線となった部分（これも境界と呼ぶ、内部境界だね）に注目する。境界に初期値を与えて、円筒に沿った伝搬の影響を時間的に全部累積したときどうなるか？ 図形的には、0回、1回、2回のループの影響を全部足す。この影響の累積を求めるオペレータは、行列Aに対するクリーネ級数の形になる。

以上の事実と、経路総和公式を組み合わせると、クリーネ級数を経路総和の形で表す クリーネ／ファインマン公式がでる。

より一般に、正方とか限らない行列の境界の一部を輪（円筒）にして貼り合わせる。今度は、貼り合わせた境界には初期値を与えないで、貼り合わせてない部分から初期値を与えるとどうなるか？ 実はクリーネ級数と普通の行列計算で書き下せる。これは、行列圏のトレースの明示公式を与える。このトレース公式は、入力変換、出力変換を伴うオートマトンの行列表現を与える。

これらから、行列とは限らず、ループも持つようなグラフに対しても、一般化されたクリーネ／ファインマン公式が成立することがわかる。

応用というか具体例としては、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070907/1189132181&quot;&gt;「離散物理としてのグラフ理論」&lt;/a&gt;で述べたように、ホイヘンスの原理とフェルマーの原理の同値性を示すとか、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070907/1189152250&quot;&gt;「フロイド／ウォーシャル法とダイクストラのアルゴリズム」&lt;/a&gt;の関係を示すとか：

&gt;&gt;
フロイド／ウォーシャル法は半環係数で考えても非常に一般的な方法だ。境界付きグラフ（リグラフ）の始境界であたえられた初期値が無限の未来に終境界にどのような影響を与えるかを計算する。
&lt;hr&gt;
ダイクストラのアルゴリズムは、始境界も終境界も1点である場合のフロイド／ウォーシャル法と同等である。
&lt;&lt;

とにかく、具体例がたくさんたくさん必要だな。プログラム意味論と流れ図とかも入れたい。

*1198825868*[janus][課題][プログラム意味論]一般化フィルターの圏を真面目にやってみればぁ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071227/1198744006&quot;&gt;「In-Outコンポネントとパイプライン」&lt;/a&gt;の一般化フィルターの圏は、In-Outコンポネントの圏の部分圏。制限を付けているので、スター（双対）やトレースを定義できない。単にモノイド圏の構造を持つだけ。

それでも、まーまー面白い。対象類は、{+, -}から作った自由モノイド。状態遷移を副作用と思って、副作用付きの変換で意味を構成できそうだ。いや、構成すべきだ。

</body>
</day>
<day date="2007-12-29" title="">
<body>
*1198900423*[janus][トレース／コンパクト閉圏][具体例]一般化フィルターの圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071228/1198825868&quot;&gt;「一般化フィルターの圏を真面目にやってみればぁ」&lt;/a&gt;をかすかに考えた。

In-Outコンポネントの圏は、外側にあるコンポネントの圏の部分圏に過ぎない。しかし、一般化フィルター（以下では単にフィルター）の圏は部分圏ではない。特殊なIn-Outコンポネントから&lt;em&gt;構成する&lt;/em&gt;。その結果、もとの圏とはだいぶ違った圏ができる。

フィルターの圏にも極性（荷電）概念は残るが、極性反転はできない。面白いのは、arityがdomに一致することだ。普通は、arityを反転してdomを定義するが、arityが最初からdomになっている。極性反転ができないのだから、arity&lt;sup&gt;*&lt;/sup&gt; = dom と言われても困るから、まー、当たり前なんだが面白い。

arityとdomが一致することから、パイプ結合、ポンプ結合以外の結合が自然に排除される。人為的に切り落とすんじゃなくて、必然的にダメになるところがまた面白い。

</body>
</day>
<day date="2007-12-30" title="">
<body>
*1199004771*[雑記][物理っぽい]年末年始と解析力学

年末年始のどさくさに紛れてなんかしよう、っと。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20071023/1193128102&quot;&gt;make&lt;/a&gt;や&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20071221/1198221671&quot;&gt;bash&lt;/a&gt;の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071218/1197977350&quot;&gt;勉強&lt;/a&gt;はもういいや。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071207/1197000853&quot;&gt;物理でもやるか、やっぱり。&lt;/a&gt;

何年か前、Yが東京に来てたとき、一緒に物理の勉強をしようというハナシだったのだが、Yの学位準備と重なってお流れになってしまった。あのときは、「せめて、古典解析力学が何であるか」くらいは知りたい、と思ったのだが、当然にいまだにわからない。

年末年始でどうにかなる？ なるまいねぇー。たいして時間があるわけでもないし。でも、ジタバタしてみる。

*1199005738*[雑感][計算][物理っぽい]乗積分or積積分

総和Σの掛け算バージョンが総積Π。Σの連続版が積分となるが、Πの連続版もある。product integralという。

- http://en.wikipedia.org/wiki/Product_Integrals

日本語では「積積分」か「乗積分」。積積分は積の積分（公式）の意味にも使われるし、乗積分は二乗積分とかの語の一部に埋没するので、検索しずらい。そもそも、ほとんど話題にのぼらない。が、僕は概念的に重要だと思っている。

無限級数の掛け算バージョンは無限乗積(infinite product)あるいは単に無限積と呼ばれる。オイラー積が有名だな。でも、無限級数ほどには使われない。

無限積や（連続無限積としての）乗積分が表面に出ないのは、普通の級数／積分の値を指数として肩に乗せるとたいてい済んでしまうから。でも、肩に乗るせいで事情が複雑になるし定式化が間接的にもなる。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070807/1186455383&quot;&gt;ネルソン&lt;/a&gt;の力学の本に作用素の乗積分が出てきたような記憶があるが、ハッキリしない。ところでネルソン、えらい人だけどちょっと異端っぽい、つまりカッコイイ。

&lt;hr&gt;

なんで乗積分が重要かというと、ラグラジアンを積分してeの肩に乗せるが、あれは乗積分だと考えたほうが自然だから。exp(A(t)dt)のような無限小の変換（でもリー代数のベクトルではない変換）を全部掛け合わせる。積分をΣで代用すると、Π(exp(A(t)dt) = exp(ΣA(t)dt) という指数公式があるので、結局ΣA(t)dtさえ計算できればいいことになるけど、乗積分がほんとはプライマリな気がする。

ところで、A(t)dtってリー代数（リー群の接空間）に値を取る微分形式だよね。それじゃ接続ってことか、、、ラグラジアンって接続なの？

&lt;hr&gt;

product integralで見つかったのは、
- PRODUCT INTEGRAL IN A FRECHET ALGEBRA -- http://www.emis.de/journals/UIAM/PDF/39-281-298.pdf

これはラグラジアンとは関係ないかも。 


</body>
</day>
<day date="2007-12-31" title="">
<body>
*1199053327*[雑記]早起きの人

やっぱり&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071226/1198674752&quot;&gt;早寝&lt;/a&gt;して早起きで&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071230/1199004771&quot;&gt;ゴニョゴニュする&lt;/a&gt;ことにした。

*1199053530*[DFD]離散的場の力学

TQFTのQは量子なんだが、僕は量子なんてよくわからんし、当面必要でもないような気がする。それで、Qを取り除いてTFTにしようかとふと思った。が、お尻のTheoryもなんか気にいらなくなった。やりたいことは力学（dynamics）なんだから、Topological Field Dynamicsだろう、と。

が、topologicalってのも漠然としている。僕が考えたいのは組み合わせ的離散的（combinatorial discrete）な空間、ブラフとか復体の上の力学。となると、Combinatorial Discrete Field Dynamicsか。長いな、&lt;strong&gt;Discrete Field Dynamics&lt;/strong&gt; でいいか。

ちなみに、field dynamicsはマーケティングとかの用語らしい。一方、thermo field dynamicsとかは物理の分野で、なぜか「量子熱力学」と訳されている。直訳すれば、熱場力学だが、これは「『熱場』の力学」だろうか、「熱の『場の力学』」だろうか？

Discrete Field Dynamicsも、「『離散場』の力学」か「離散系の『場の力学』」かわからんが、どっちでもいいや。以下、&lt;strong&gt;DFD&lt;/strong&gt;と略記して、分類カテゴリー[DFD]も新設。

*1199054280*[TQFT][DFD][課題]TQFT関手は必要なのか

DFDは、TQFTの枠組みを採用する。のだが、TQFTもどうも変に思えるところがある。

TQFT関手というのは、コボルディズムのモノイド圏からヒルベルト空間のモノイド圏（積はテンソル積）への関手。離散有限化すると、ベクトルと行列だからわかりやすい。が、境界なしの多様体の値は単なるスカラーになる。これだと情報が足りない気がする。

実際にはTQFT関手は不要で、力学の圏だけで間に合うのじゃないか。つまり、空間Xとその上の力学Aの組を考えて、indexed圏のようなものを考える。(X, A)から(Y, B)への射は、f:X→Yなる写像と、A→f&lt;sup&gt;*&lt;/sup&gt;(B) というX上の力学のあいだの写像の組となる。

となると、X上の力学の圏Dyn(X)が問題だ。X上の接ベクトルが力学だと考えると簡単だが、そうすると、引き戻しf&lt;sup&gt;*&lt;/sup&gt;(B) がうまく定義できない。XとXの無限小近傍を集めたようなもの（バンドルで表現できそう）を考えて、その無限小近傍上のベクトル場で、Xの近くで一致するものを同一視したもの（芽ってやつかな？）を使えばなんとかなりそうだ。

力学の変換とは、各点でベクトル空間の変換が与えられて、力学を定義するベクトル場をベクトル場に移すようなものだろう。変換として包含だけを考えても間に合うかもしれない。というか、包含以外はむずかしくて扱えないかも。

以上の話を連続的空間でやれば、技術的な細部がやたらにむずかしくなりそうだが、離散空間なら扱えなくもないだろう。で、DFDの課題となる。

*1199055475*[DFD]連続-離散 対応

ウェイトとは、有向グラフの有向辺に（非可換かもしれない）半環の値を対応させる割り当てで、ウェイト付きグラフとはすなわち&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%ea%a5%b0%a5%e9%a5%d5&quot;&gt;リグラフ&lt;/a&gt;。道に関する計算を、足し算にするか掛け算にするかで加法的、乗法的と区別する。

|*連続 |* 離散 |
| dx/dt = ax | Δx = ax |
|ラグランジュ関数 | 対数型加法的ウェイト |
| 経路の作用積分S     | 道の加法的総ウェイトS |
| exp(S)              | exp(S) = 道の乗法的総ウェイト |
| 力学の生成演算子H   | グラフのウェイト行列H |
| E(H, t) = exp(Ht)   | K(H, n) = (1+H)&lt;sup&gt;n&lt;/sup&gt; |


</body>
</day>
<day date="2008-01-04" title="">
<body>
*1199431728*[メモ法]はてなの自動トラックバック

失敗した。メモ編も自動トラックバックを有効にしておくべきだった（今した）。理由：自分へのトラックバックにより参照をたどれるから。

*1199433463*[雑記][メモ][課題]年末年始で考えたこと：記号回路とか両側半加群とか

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20071230/1199004771&quot;&gt;解析力学&lt;/a&gt;は案の定進んでない(苦笑)。が、年末年始でわかったこと：

+ トレース付き双デカルト圏のお絵描き
+ 記号回路の重要さ
+ 両側半加群と離散力学系

&lt;hr&gt;

トレース付き圏で、3次元的な回転を使った変形で計算できることがわかった。この計算は、コンパクト閉圏なら合理化できるがトレース付き圏だけだと合理化できない。それに、実は計算が簡単になるわけでもなく、むしろ計算過程が増えたりする。

それにもかかわらず、この計算法は直感的で面白い。計算の途中で現れる図形が珍しかったりして発見的な意味もある。

&lt;hr&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b5%ad%b9%e6%b2%f3%cf%a9&quot;&gt;記号回路&lt;/a&gt;って概念は重要だと思っていた。多項式や行列の拡張になっているし、入れ子のオートマトンを考える上でも必要。カテグラフの計算にも使えるだろう。特殊な事例でいいからきちっと定式化すべきだと思った。思っただけでやってない。

&lt;hr&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070118/1169088000&quot;&gt;半環上の半加群&lt;/a&gt;と、離散力学系（＝リグラフ）の関係がわからなかったが、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061215/1166163277&quot;&gt;関係柱&lt;/a&gt;を使えば結びつけられる。

S, Tが離散状態空間として、S, Tを両端とする完全二部グラフ上にブール値の辺ウェイトを考える。これはS×T上の部分集合だから関係と同一視できるし、図形としては関係柱になる。S, T上の部分集合（＝述語）の代数が係数半環となり、辺ウェイトが加群の元となる。この述語とブール値辺ウェイト＝遷移＝ブール値リグラフの計算がブール／クリーネ半加群の計算になる。係数半環をブール代数以外に一般化できる。

ようするに、両側半加群は二部グラフ＝行列計算から出てきたわけで、一般的なリグラフの非常に特殊なケース。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061024/1161670281&quot;&gt;ブール／クリーネ圏&lt;/a&gt;はリグラフの圏に埋め込める。あるいは、リグラフの圏からの振る舞い関手の値が両側半加群となるべき、なのだろう。

*1199433925*[メモ]買わなかった本

+ スワンソンの経路積分の本 -- 買っても無駄かも知れないので。
+ アーノルドの古典力学の本（岩波） -- 高すぎる！ 理不尽な値段。
+ 題名も著者も忘れたが、コンピューティングサイエンスの本 -- かなり高い。分厚い。だがソフトカバーなのがいい、後で買うかも。
+ 微分形式を使った解析力学の本 -- 同じ本を持ってるような気がした。（が、なかった、たぶん勘違い）。
</body>
</day>
<day date="2008-01-05" title="">
<body>
*1199501795*[雑感][お絵描き][課題]お絵描きはやっぱり楽しい

ここ2日ほど、子供に「&lt;em&gt;変な落書きばっかりしてる&lt;/em&gt;」とか言われながら絵算をしていた。

絵算はしばらくしないとできなくなる。が、勘が戻ると非常に楽しい。いきなりだと複雑そうにみえる和スター公式 (a + b)&lt;sup&gt;*&lt;/sup&gt; = (a&lt;sup&gt;*&lt;/sup&gt;b)&lt;sup&gt;*&lt;/sup&gt;a&lt;sup&gt;*&lt;/sup&gt; とかも自明に思えてくる。

できれば今日中に絵をスキャンして説明を付けよう。それが&lt;em&gt;課題&lt;/em&gt;。&lt;b&gt;[追記]&lt;/b&gt;課題はなんとか完了。&lt;b&gt;[/追記]&lt;/b&gt;

*1199505152*[お絵描き]基本変形：角度変形、アンワインド、スライディング、回転

&lt;h5&gt;角度変形&lt;/h5&gt;

まずは、3本以上の線（ワイヤー）が1点で交わっているときにその角度を変える変形。（&lt;em&gt;ウギャ、上の段の左、矢印が間違っているがね、いいや、脳内修正して！&lt;/em&gt;）

&lt;img src=&quot;http://www.chimaira.org/img2/angle-deformation.gif&quot; &gt;

なんでもないようだが、平面上に自由に描かれた構文図を双デカルト圏で解釈するときなどに必要。3本の線はΔや∇になっている。例えば次の3つの図は、黒丸をfだとして、f&lt;sup&gt;+&lt;/sup&gt; = Tr[∇;f;Δ] を表現している。

&lt;img src=&quot;http://www.chimaira.org/img2/three-variants.gif&quot; &gt;

線4本以上が1点で交わっているとき、それをΔと∇で表現するときも、角度の変形を行って見やすくする。

&lt;img src=&quot;http://www.chimaira.org/img2/four-lines.gif&quot; &gt;

&lt;h5&gt;アンワインド&lt;/h5&gt;

次は、巻き付いたワイヤーをほどく操作。

箱の回りに時計回りまたは反時計回りにワイヤーが巻き付いているとき、この巻き糸をほどくことをアンワインドと呼ぶことにする。交差（クロス）を3次元的にブレイドと考えれば、交差の上側を引っ張り上げて回転させればほどける。

&lt;img src=&quot;http://www.chimaira.org/img2/unwind.gif&quot; &gt;

2次元内で変形するときは、箱を交差（クロス、対称）スライディングで動かして、残った巻いてる輪をヤンキングで解消する。

&lt;h5&gt;ループスライディング&lt;/h5&gt;

次の図は、単にトレース付き圏のスライディングである。

&lt;img src=&quot;http://www.chimaira.org/img2/loop-sliding.gif&quot; &gt;

ただし、黒丸（fとする）がループの中央に位置する絵はトレース付き圏では合理化できない。コンパクト閉圏ではじめて意味を持つ。しかし、計算がトレース付き圏で行われていても、便宜上、ループ中央にfを置くとなにかと便利。必要になった時点で、左または右までスライドさせればいい。

&lt;h5&gt;上下または左右の回転&lt;/h5&gt;

3次元的な回転を使ってもよい状況がある。

&lt;img src=&quot;http://www.chimaira.org/img2/rotations.gif&quot; &gt;

上下の回転は、対称性／可換性があるときに使える。左右の回転は、ループに沿ったスライディング、交差に沿ったスライディング、それとタイトニングで合理化できる。

*1199506247*[お絵描き][計算][具体例]練習問題：2種類のスターの同値性

f&lt;sup&gt;*&lt;/sup&gt;には、次の2つの代表的表現がある。

+ Tr[(1+Δ);(σ + f);(1 + ∇)]
+ Tr[(1+f);∇;Δ]

参考：
- [http://d.hatena.ne.jp/m-hiyama-memo/20061005/1160006705:title] (http://d.hatena.ne.jp/m-hiyama-memo/20061005/1160006705)
- [http://d.hatena.ne.jp/m-hiyama-memo/20061004/1159920500:title] (http://d.hatena.ne.jp/m-hiyama-memo/20061004/1159920500)

この2つが同値であることを示してみる。

&lt;img src=&quot;http://www.chimaira.org/img2/rotation-example.gif&quot; &gt;

+ まず、左右の回転で交差を解消する。
+ 角度変形で全体の形を整える。
+ 上下の回転でfと1を入れ替える。
+ 角度変形で全体の形を整える。

実は、回転を使わないほうが計算は楽。

&lt;img src=&quot;http://www.chimaira.org/img2/without-rotation.gif&quot; &gt;

+ 右の∇をループに沿ってスライディングする。
+ ループの外側のワイヤーはアンワインドできるので、ほどく。
+ もし必要なら、fもループに沿ってスライディングする。

[http://d.hatena.ne.jp/m-hiyama-memo/20080104/1199433463:title]（http://d.hatena.ne.jp/m-hiyama-memo/20080104/1199433463）より引用：
&gt;&gt;
トレース付き圏で、3次元的な回転を使った変形で計算できることがわかった。この計算は、コンパクト閉圏なら合理化できるがトレース付き圏だけだと合理化できない。それに、実は計算が簡単になるわけでもなく、むしろ計算過程が増えたりする。

それにもかかわらず、この計算法は直感的で面白い。計算の途中で現れる図形が珍しかったりして発見的な意味もある。
&lt;&lt;

*1199513786*[お絵描き][計算][具体例]f&lt;sup&gt;*&lt;/sup&gt; = 1∨f&lt;sup&gt;+&lt;/sup&gt; の計算

背景は次を参照：

- [http://d.hatena.ne.jp/m-hiyama-memo/20061005/1160006705:title] (http://d.hatena.ne.jp/m-hiyama-memo/20061005/1160006705)
- [http://d.hatena.ne.jp/m-hiyama-memo/20061004/1159920500:title] (http://d.hatena.ne.jp/m-hiyama-memo/20061004/1159920500)

f&lt;sup&gt;*&lt;/sup&gt;の定義は、Tr[(1+Δ);(σ + f);(1 + ∇)] で与えるとする。これが、Tr[(1+f);∇;Δ] と同じであることは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080105/1199506247&quot;&gt;既に示した。&lt;/a&gt;f∨g = Δ;(f+g);∇、f&lt;sup&gt;+&lt;/sup&gt; = Tr[∇;f;Δ] として、f&lt;sup&gt;*&lt;/sup&gt; = 1∨f&lt;sup&gt;+&lt;/sup&gt; の計算は意外に面倒。

左右、上下の回転を使って示してみる。

&lt;img src=&quot;http://www.chimaira.org/img2/star-and-plus.gif&quot; &gt;

双代数法則とは、∇;Δ = □ という法則。これについては&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080105/1199515129&quot;&gt;後で詳述&lt;/a&gt;する。この双代数法則以外は、角度の変形と左右回転（交差ねじれの解消）と上下回転（和の可換律）だけしか使ってない。

双代数法則の後は、右下の∇をループに沿ってスライディングして、巻いているワイヤーをほどいたほうが計算は速い。

*1199513787*[お絵描き][計算][具体例]積スター公式と和スター公式

コンウェイ半環（Conway半環）で次が成立する。

+ (ab)&lt;sup&gt;*&lt;/sup&gt; = 1 + a(ba)&lt;sup&gt;*&lt;/sup&gt;b
+ (a + b)&lt;sup&gt;*&lt;/sup&gt; = (b + a)&lt;sup&gt;*&lt;/sup&gt; = (a&lt;sup&gt;*&lt;/sup&gt;b)&lt;sup&gt;*&lt;/sup&gt;a&lt;sup&gt;*&lt;/sup&gt;

これをトレース付き双デカルト圏に持ってくると、

+ (f;g)&lt;sup&gt;*&lt;/sup&gt; = 1 + f;(g;f)&lt;sup&gt;*&lt;/sup&gt;;g
+ (f∨g)&lt;sup&gt;*&lt;/sup&gt; = (g∨f)&lt;sup&gt;*&lt;/sup&gt; = (f&lt;sup&gt;*&lt;/sup&gt;;g)&lt;sup&gt;*&lt;/sup&gt;;f&lt;sup&gt;*&lt;/sup&gt;

これらを示す。まずは積スター公式：fが黒丸、gが黒四角とする。

&lt;img src=&quot;http://www.chimaira.org/img2/product-star.gif&quot; &gt;

スターの定義としては 1∨f&lt;sup&gt;+&lt;/sup&gt;を採用する。f&lt;sup&gt;*&lt;/sup&gt; = 1∨f&lt;sup&gt;+&lt;/sup&gt; の計算でむずかしい部分は既に終わっている。∇、Δに沿ってコピースライディング（重複化）して、その後右下のgをループに沿ってスライディングする。ワイヤーの長さをタイトニングとシフトで調整しておしまい。

&lt;hr&gt;
次は和スター公式：

&lt;img src=&quot;http://www.chimaira.org/img2/sum-star.gif&quot; &gt;

+ f&lt;sup&gt;*&lt;/sup&gt; = Tr[(1+f)∇;Δ] を箱（xとする）に入れておく。
+ (f&lt;sup&gt;*&lt;/sup&gt;;g)&lt;sup&gt;*&lt;/sup&gt;;f&lt;sup&gt;*&lt;/sup&gt; = (x;g)&lt;sup&gt;*&lt;/sup&gt;;x からスタート。
+ 左のxをループに沿ってスライディング。
+ コピースライディングの逆でxを1つにまとめる。
+ 箱xを開く。
+ 加法∇と対角Δの結合律。
+ 左下のΔをループに沿ってスライディング。
+ (g∨f)&lt;sup&gt;*&lt;/sup&gt; = (f∨g)&lt;sup&gt;*&lt;/sup&gt;の出来上がり。

図の描き方によってはもっと簡単になる、それは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080105/1199516424&quot;&gt;後述する。&lt;/a&gt;

*1199515129*[お絵描き][圏一般論][その他代数]双代数法則

双代数法則（双代数条件）とは、1つの圏にデカルト構造、余デカルト構造が載っているとき、それらが&lt;em&gt;協調している&lt;/em&gt;ことを示す条件である。∇;Δ = □ という等式で示せる。

双代数法則は、対角Δがモノイド射（加法的）であること、また、加法∇がコモノイド射（余加法的）であることを主張している。このことは、行列の絵算で容易に確認できる。

双代数法則を絵算で使うとき、位相的同位変形ではなくて、ある領域（チャンバー、ボックス）を置換することになる。これは2次元で計算（絵の変形）しているせいで、3次元なら特異点を通る変形、4次元ならおそらく特異性が表れない変形となるだろう。

絵算の外部空間（背景）の次元が低いと、同値変形で特異性が出現する。加法の交換法則やヤンキングを2次元内で遂行しようとすると、特異性が避けられない。

&lt;img src=&quot;http://www.chimaira.org/img2/singularities.gif&quot; &gt;

3次元を使って変形すれば、特異性は出ないが、2次元では変形の途中で捻れやシコリ、ダマを無理に潰すことになる。

さて、双代数法則を3次元内で表現すると次のようになる。

&lt;img src=&quot;http://www.chimaira.org/img2/bialgebra-deformation.gif&quot; &gt;

4つの穴が開いた球面が、4つの穴が開いたトーラスに変わる瞬間がある。そこが変形の特異点になっている。その他は連続変形である。

*1199516424*[お絵描き]結合律の表現とより簡便な絵算

加法∇の結合律、対角Δの余結合律は次の形にも図示できる。

&lt;img src=&quot;http://www.chimaira.org/img2/assoc-alt-form.gif&quot; &gt;

この図示方式で次が示せる。

&lt;img src=&quot;http://www.chimaira.org/img2/double-trace.gif&quot; &gt;

これはトレースの2回繰り返しからΔ;∇という小さな穴（川の中州; hole, sandbar）が生じることを示している。加法がベキ等なら、Δ;∇ = 1 なので穴は消える。図の横線の中央にfを置けば、ベキ等圏における(f&lt;sup&gt;+&lt;/sup&gt;)&lt;sup&gt;+&lt;/sup&gt; = f&lt;sup&gt;+&lt;/sup&gt; が得られる。

この結合律の図式法は、和スター公式の証明にも効果的に使える。影のかかった箱x、黒丸f、黒四角gの意味は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080105/1199513787&quot;&gt;前のエントリー&lt;/a&gt;と同じとして、和スター公式は次のように短く示せる。

&lt;img src=&quot;http://www.chimaira.org/img2/sum-star2.gif&quot; &gt;

</body>
</day>
<day date="2008-01-07" title="">
<body>
*1199664030*[メモ]とりあえずメモ；後で書く

+ 1&lt;sup&gt;*&lt;/sup&gt; = 1 なのか？
+ ベキ等なトレース付き双デカルト圏で、(f&lt;sup&gt;+&lt;/sup&gt;)&lt;sup&gt;+&lt;/sup&gt; = f&lt;sup&gt;+&lt;/sup&gt; と (f&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt; の計算
+ 力学系と作用素半環として解釈したときの、クリーネ一様性の意味
+ クリーネ・スターを生成作用素の片側S行列として解釈 →[http://d.hatena.ne.jp/m-hiyama-memo/20080108/1199779752:title]
+ コンウェイ半環と一様写像の圏は不動点またはトレースを持つだろうか？

*1199699078*[メモ][課題]これも後で書く

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180759386&quot;&gt;「形式言語系の定義」&lt;/a&gt;に、
&gt;&gt;
形式言語系の具体例は後で出す。
&lt;&lt;
って、出してねー。

具体例を書かなくちゃ。

</body>
</day>
<day date="2008-01-08" title="">
<body>
*1199779752*[DFD][形式言語理論]クリーネ・スターと片側S行列

次の対応を考える。

|*力学 |*幾何学 |*状態遷移系 |*DFD |
|配位空間 | 多様体 | 状態空間 |離散空間|
|相空間 |接バンドル | 仮想遷移の全体  |完全グラフ＝直積 |
|力の場 |接ベクトル場|ラベル付き遷移   |辺ラベル|
|ラグランジュ関数|接バンドル上の適切な関数 |?|対数型加法的辺ラベル|

状態空間の点は状態点だが、状態空間で定義されたスカラー値関数を状態関数と呼ぶことにする。スカラーは状況に応じて適切に選ぶが、離散系のときは二値ブール代数をスカラーとすることが多い。

「状態点→状態関数」への一般化は、「質点→波や熱」、「決定性遷移→非決定性遷移」といった拡張に対応する。点をδ関数と同一視し、それをδ以外の関数（分布）にすることだな。質点の軌道（運動経路）は、分布（例えば波）の時間的な変化（伝搬現象）になる。

力の場は状態点だけでなく状態関数にも作用する。これは、状態関数の全体を表現空間と考えて、作用素環（半環）の表現になっている。Aが力の場なら、それは力学系の生成作用素であり、時間を進める駆動力でもある。Aを作用素環の元と見て、指数関数E(A, t) = exp(γAt)を作る（γは適当な定数）と、E(A, t)がAで生成された力学系の時間発展を与えることになる。E(A, t)はtに関して半群になっており、作用素の空間内で線形力学系を定める。

E(A, t)のtを∞にしたE(A, ∞)をS(A)と書くことにする（S行列のつもり）。S行列は、無限の過去と無限の未来を結ぶ変換らしいが、ここでは過去を考えないので、初期時点0と無限の未来を結ぶ変換とする。S(A)は、定義から、作用素の空間における吸引点、安定点になる。ただし、S(A)が存在するかどうかはAに依存する。

S(A)は、状態空間に作用する作用素で、状態関数φに対して S(A)φ はAの不動点である。なぜなら、A(S(A)φ) = [A・E(A, ∞)]φ = [E(A, ∞ + 1)]φ = E(A, ∞)φ = S(A)φ 。よって、S(-)は不動点演算子になっている。

以上の状況を離散空間／離散時間で考えると、半環値のラベル付き隣接行列Aに対して、それを力学系の生成作用素とみなせば、Aのクリーネ・スターが片側（未来のみ）のS行列に対応する。状態関数φにS(A) = A&lt;sup&gt;*&lt;/sup&gt; を作用させた A&lt;sup&gt;*&lt;/sup&gt;φ が 1+A の不動点となる。つまり、力学系Aにおいて、初期状態φから出発しての無限の未来＝安定状態を与える作用素がクリーネ・スターとなる。

</body>
</day>
<day date="2008-01-09" title="">
<body>
*1199839346*[計算][課題](f&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt; の計算

ベキ等性を仮定しても (f&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt; の計算ができない、エーン。

(f&lt;sup&gt;+&lt;/sup&gt;)&lt;sup&gt;+&lt;/sup&gt; = f&lt;sup&gt;+&lt;/sup&gt; なら簡単にできるのに、なんでだ？ 

ベキ等じゃないのときは、例えば&lt;b&gt;N&lt;/b&gt;係数の形式無限級数の半環とかで反例を作れる。

*1199840821*[お絵描き][計算][具体例](1+Δ);(∇+1);(Δ+1);(1+∇) = □

(f&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt; をやっているうちに、なんかのはずみで次に気がついた。

- (1+Δ);(∇+1);(Δ+1);(1+∇) = ∇;Δ = □

フロベニウス代数なら、(1+Δ);(∇+1) = (Δ + 1);(1 + ∇) =  ∇;Δ だから、(1+Δ);(∇+1);(Δ+1);(1+∇) = ∇;Δ;∇;Δ、ベキ等ならΔ;∇が消えて∇;Δとなるが、いまはフロベニウス代数の話じゃないのだった(苦笑)。

んじゃ、ベキ等双デカルト圏での計算： 左辺は交替律から(1+Δ);(∇;Δ+1);(1+∇)となるが、∇;Δに双代数法則を適用すれば、(1+Δ);[(Δ+Δ);(1+σ+1);(∇+∇) + 1];(1+∇) 、、、、ウーン、これから先は絵算に頼る。

&lt;img src=&quot;http://www.chimaira.org/img2/idempotent-1.gif&quot; &gt;

二番目の絵の下半分に余結合律／結合律を適用すると、穴ができて、この穴がベキ等性により消える。

双対な形 (Δ+1);(1+∇);(1+Δ);(∇+1) = □ もある。

&lt;img src=&quot;http://www.chimaira.org/img2/idempotent-2.gif&quot; &gt;

*1199874831*[メモ]既にある本

+ シェルマンの「ファインマン経路積分」という本がある。読みやすいと思ったがそうでもない。スワンソンのほうが読みやすいかも。
+ メンスキーの本もあるはずだが、見つからない。と思ったら、トイレから出てきた。はぁー、出てきてよかった。

</body>
</day>
<day date="2008-01-11" title="">
<body>
*1200019375*[物理っぽい][計算]いいかげんな計算が好き

(f&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt; ができないのがフラストレーションなんだけど、まー、しばらくこれはあきらめよう。

物理の計算もサッパリできない。のだが、もともと僕はこうるさい厳密な計算が好きじゃないから、物理の計算に意外と向いているかもしれない。（さらに）のだが、いまさら練習しても進歩向上しないかもしれない。

*1200038324*[物理っぽい][形式言語理論][DFD]質点と場

とりとめもなく書く。

運動を記述するにあたって、位置xを独立パラメータtの関数 x = x(t) とする方法と、xとtに対してなんかの量の分布 f(x, t) の形にするスタイルがある。

f(x, t)が質量分布（密度）だとして、tを固定してのx方向積分が保存していて（時間によらずに定数）、fの値が0でない所（台）が十分小さいなら、f(x, t)をx(t)の形で書き換えられる。ということであれば、f(x, t)のスタイルのほうが一般性があるだろう。

さらに、xの時間微分を独立量と考えて、f(x, v, t)とかf(p, q, t)とかにすれば扱いやすい。幾何学的には、配位空間の接バンドルか余接バンドル上で考えることになる。

といったことを離散化して、DFD（離散場の力学）の定式化としたいわけだが、離散化した状況では、最初から接バンドル上の場の形式をしていて、むしろ&lt;em&gt;質点描像がむずかしい。&lt;/em&gt;オートマトンの状態遷移関数δ(s, a)は、接バンドル上のベクトル場＝運動方程式に近いものである。最適化問題などでは、ラグランジュ関数のようなものが先に与えられるし。

力学では、配位空間や相空間の関数を道の空間に持ち上げることができ、もとの空間と道の空間との関係を云々できる。同様に、離散状態空間上に終状態かどうかを調べる真偽値関数を、語（列）の空間に持ち上げることができて、それが言語（語の空間の部分集合）の特性関数になったりする。もっと自由にかつ一般的に、状態空間（または相空間＝状態空間×アルファベット）上の関数と、語の空間の上の関数の関係を議論すると面白そうだ。

*1200038418*[物理っぽい][形式言語理論][DFD]逆問題？

形式言語の「生成と認識」の関係は、双対とか随伴ではどうもうまく説明できない。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060803/1154581552&quot;&gt;斜随伴&lt;/a&gt;なんて言葉を造ったりもしたが、自信はない。

生成のほうは、初期値を与えて時間発展の半群を考えて、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080108/1199779752&quot;&gt;片側S行列&lt;/a&gt;を求めるようなハナシだと思う。片側S行列は、グリーン関数（プロパゲータ）をU(t1, t0) とすれば、S = U(∞, 0) と書ける。S行列やプロパゲータが可逆なら、認識問題は逆行列で解ける。

しかし、可逆なんてことはないわけで、近似的逆元あるいは片側逆元を求めるようなハナシなんだろうか。だとすると、認識問題は一種の逆問題ってことになるのか？


</body>
</day>
<day date="2008-01-12" title="">
<body>
*1200107562*[メモ][DFD]伝搬現象と境界

昨日、絵描いた。が、なんだか曖昧で朦朧としたイメージで、うまく説明できない。

まず、僕が考えていることの多くは、空間になんかの量の分布があり、その分布の時間発展を追う形をしている。これを、空間的に分布された量の伝搬を追いかけると考えると、波や熱みたいな定式化になる。一方、伝搬の経路を個別に見ていくと質点の古典経路（軌道）の話になる。

多くのケースで、空間には、始境界、終境界という部分集合が指定されている。これは、多様体の意味の境界ではなくて、単なる部分集合だと考えたほうがいい。それで、始境界上で与えられた初期分布の伝搬、あるいは始境界から出発する古典軌道を追いかけることになる。そして、有限時間または無限時間後の終境界での値を求めることが課題。始境界、終境界以外の部分に与えられた場は、外部環境と考える。

&lt;img src=&quot;http://www.chimaira.org/img2/dynamics-figs.gif&quot; &gt;

絵を切り刻むの面倒だったから一枚。

これ、何の絵か？ 空間と始境界、終境界、それと古典軌道とか。曖昧模糊だけど。

形式言語理論のときは、始境界が一点で、終境界が広がった（広がってもいい）集合に取ることが多い。が、基本は、一点が一点にどう影響するか。一般的には、始境界も終境界も広がっていい集合。

実際にグリーン関数（伝搬関数、伝搬子、プロパゲータ）を計算するときは、状態空間または相空間全体に対して使える行列（作用素）を求めることが多い。これは、雰囲気としては、縦も横もS（空間の広がり）の正方行列Aとなる。一点xが一点yにどう影響するかを見たいなら、Aにxを台とするδ関数を入力してyでの値を計算する。逆に、「xからyへの影響」を全ての点で計算できればAが構成できる。

始境界Xから終境界Yへの影響を計算する行列は、正方行列に埋め込みと射影を組み合わせればいい。S行列＝無限時間後へのプロパゲータの計算は、正方行列でないとできないから全空間のグリーン関数は必要になる。

それでは、「境界を考えない全空間でのグリーン関数が基本なのか」というと、そうともいえない。U(t1, t0)の形のプロパゲータは、全空間と時間区間の直積を取った柱状領域で、始境界から終境界への伝搬を計算してることになるから。

*1200107952*[物理っぽい][説明]束縛ベクトルと自由ベクトル

って分からなかったが、分かるわけないよ！

ユークリッドアフィン空間で考えるとして、束縛ベクトルは接バンドル（直積でOK）の元、自由ベクトルは束縛ベクトルの同値類だもん。自由ベクトルは、典型ファイバーの元と考えてもいい。任意に原点をとって、原点上のファイバーを典型ファイバーとすればいい。

が、そうすると、自由ベクトルは束縛ベクトルの特別なものになってしまう。

分かんないよなーー。

*1200109237*[物理っぽい][DFD]状態のリフト、重ね合わせ

量子化の処方箋の一部に、質点を状態関数に置き換えるってのがある。

一般に、状態空間、相空間上の点を関数にすることを状態のリフトと呼ぶことにしよう。「状態点→状態関数」と状態概念を一般化すること。

状態関数は適当なスカラーKに値をとる。物理なら複素数体&lt;b&gt;C&lt;/b&gt;がスカラー、形式言語理論なら真偽値がスカラー。状態関数の空間は、ゼロ概念と足し算がある。点より有利なのは、状態の重ね合わせができるし、ゼロ状態を考えることができること。

*1200109828*[形式言語理論][DFD]形式言語理論における状態のリフト

Σをアルファベットとして、Σで生成された自由モノイドを考えると、これは語（列）の全体。M = (Σの列の全体）とする。モノイドMの表現とは、集合Xに対するM作用だとする。End(X)にMが表現される。Xは、まー表現空間といっていいだろう。

Mの表現として、X=Mとしての右移動、左移動がある。これでとりあえず、表現の存在が示せる。次に、モノイド表現があるとき、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080112/1200109237&quot;&gt;状態のリフト&lt;/a&gt;をして、状態関数の空間を新しい状態空間に取れる。これは、モノイド作用を「決定性→非決定性」にしたことと同じ。

ここで、a∈Σにたいして、aが定義する作用素a&lt;sub&gt;*&lt;/sub&gt;がどんなものかというと、

- Σ上の言語Aに対して、a&lt;sub&gt;*&lt;/sub&gt;A = {aα | α∈A }

状態をリフトしてうれしいのは、a&lt;sup&gt;*&lt;/sup&gt;という作用素が次のように定義できること。

- Σ上の言語Bに対して、a&lt;sup&gt;*&lt;/sup&gt;B = {β | aβ∈B }

次が成立する。（1は恒等作用素）

- a&lt;sup&gt;*&lt;/sup&gt;・a&lt;sub&gt;*&lt;/sub&gt; = 1
- a&lt;sub&gt;*&lt;/sub&gt;・a&lt;sup&gt;*&lt;/sup&gt; ⊆ 1

この関係が、生成と認識の基本事項だと思う。

*1200112605*[形式言語理論][DFD]概可逆なISRと概逆力学系

形式言語理論では、生成系と認識系（あるいは分解系）が出てくる。これを定式化するにあたって、係数べき等半環（ISR）が概可逆という性質を持つことが重要だと思われる。

RがISRだとして、a∈Rに対して、bがaの概逆元とは：

- b・a = 1, a・b ≦ 1

のこと。特定された一部のaに対して、aの概逆元を一意的に対応させる部分写像(-)'があるとき、(R, ')を概可逆なISRと呼ぶことにする。R内で概可逆な元を概単元と呼ぶことにする。Rが概単元で生成されていることを要求する。

Rが概可逆なISRで、R係数の境界付きのリグラフAがあるとする。Aのシェープである有効グラフの向きを逆にして、始境界と終境界を入れ替える。さらに、辺ラベルの値を、その概逆元の置き換えたものをAの&lt;strong&gt;概逆なリグラフ&lt;/strong&gt;と呼ぶ。リグラフは力学系と解釈できるので、同様にして概逆な力学系も定義できる。

もちろん、リグラフに概逆が存在するためには、辺ラベルがすべて概単元である必要がある。

Aがリグラフで定義される力学系として、そのS行列（つまりクリーネ・スター）をSとする。Aの概逆をA'、そのS行列をS'とする。φがAの始境界（A'の終境界）で与えられる状態、ξがAの終境界（A'の始境界）で与えらる状態のとき、次の2つは同値だろう。

+ A上で、ξ⊆Sφ
+ A'上で、φ⊆S'ξ

Aを生成系とみなすと「ξが、φから生成される安定状態より小さい」ことは、対応する分解系A'において「φが、ξを分解した安定状態より小さい」ことで示せる。

*1200112638*[形式言語理論][DFD][メモ]等速古典軌道とホドグラフ変換

形式言語の力学では、速度の大きさは考えなくていい。つまり、等速運動だけを考える。運動の時間パラメータは弧長パラメータと一致する。速度ベクトルは常に長さ1だから、ホドグラフ（hodograph）変換すると単位球内を動く。この状況のアナロジーを考えれば十分。

軌道はホドグラフ像で与えられる。ホドグラフ像に対応するのが語（列）になる。ホドグラフ像の全体＝古典軌道の全体が与えられたときに、対応する相空間と運動方程式を再現せよ、ってのがマイヒル・ネロードの問題設定となるだろう。

*1200119774*[雑記][論理]様相実在論

様相論理のモデルに、クリプキ構造を使った可能世界（多世界）モデルがあるが、可能世界がほんとに存在していると信じている人達がいるらしい。

*1200122123*[形式言語理論][DFD][その他代数]概可逆ISR

加法的ベキ等な半環（ISR）Rと、U⊆Rで定義された写像(-)':U→Rの組(R, ')で、

+ 1∈U
+ 1' = 1
+ a∈Uに対して、a'はaの概逆元
+ UはRを生成する

最後の条件は、Rに極限操作があるときは、極限も含めて生成することだとする（このへんの定義はむずかしい）。

以上の条件を満たすIRSを、概可逆なISRと呼ぶことにする。

概可逆ISR Rを係数とする行列が、すべての成分が概可逆なら概可逆と呼ぶ。転置して、成分を概可逆元で置き換えた行列が、行列の概逆行列とする。概逆行列は、そのままでは行列乗法で概逆元になるわけではない（ネーミングが悪いかも）。

*1200123997*[形式言語理論][DFD][その他代数]概逆元と概反行列

うーんと、行列を転置して成分を概逆元（almost inverse）で置き換えた行列は、概反行列（almost opposite）と呼んだほうがいいかもな。

Aの概反行列を#Aとすると、たぶん、

- exp(-A) = (exp(A))&lt;sup&gt;-1&lt;/sup&gt;

と類似の

- exp(#A) = (exp(A))'

が成立しそう。もちろん、expは片側S行列の意味で解釈し、'は概逆元を表すとする。

</body>
</day>
<day date="2008-01-14" title="">
<body>
*1200293620*[DFD][その他代数][具体例]熱帯はやっぱり熱い！ （tropical半環おもしれー）

&lt;b&gt;N&lt;/b&gt;∪{+∞}に、minを加法、+を乗法として演算を入れたISRをトロピカル（tropical）半環と呼ぶ（Exotic Semirings, http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733を参照）。&lt;b&gt;R&lt;/b&gt;∪{+∞}のほうは正確にはoptimization代数と呼ぶらしいが、普通は&lt;b&gt;R&lt;/b&gt;であってもトロピカル半環、トロピカル代数とか呼ぶ。&lt;b&gt;R&lt;/b&gt;の正の部分、非負の部分だけを考えてもいい。

DFDでは、グラフ辺に半環の値を付けるが、これにトロピカル半環を使うと面白い。もっと正確にいうと、トロピカル半環の加法（つまりmin）だけを考えた半加群を考える。この半加群を頂点にくっつける。そして、半加群に値を取るセクション（ねじれがないから関数と考えてよい）を状態関数とする。辺には、半加群の半加群自己準同型の半環の値を付置する。

これは、1つの半加群だけを対象とする圏を考えて、その圏を係数圏とするカテグラフを考えていることになる。カテグラフとしては最も簡単なもので、容易にリグラフに還元できる。が、あえて還元しないのがミソ。

半加群の半加群自己準同型の半環を、以下、気分を出すため作用素半環と呼ぶ。もとのトロピカル半環は、作用素半環内にスカラー乗法作用として標準的に埋め込める。つまり、作用素半環は、トロピカル半環の拡張とみなせる。

注目すべきは、作用素半環に埋め込んだトロピカル半環には概逆元（almost inverse）が存在すること。任意のn∈T（Tはトロピカル半環）に対して、n'・n = 1, n・n' ⊆ 1 となるn'が&lt;em&gt;作用素として&lt;/em&gt;見つかる（⊆はトロピカル半環としての順序）。具体的にn'は、nによる制限引き算である。

概逆元の存在は、DFDにおける逆問題（って呼んでいいのか？）にとって決定的で、力学系の生成作用素（たぶんハミルトン作用素に対応する行列）の概反行列（almost opposite matrix; AOM）を作れる。概反行列のS行列を作れば、それが概逆伝搬関数（順方向の伝搬関数の概逆）を与え、逆問題（概逆問題と呼ぶべきか）の解を与える。

トロピカル半環を係数としたDFDは、移動コスト（交通費、運送料金）の最小化問題や計画（制御）問題そのものなので、非常に具体的。計算は数値的・算術的なので（小規模なら）手でも容易。

面白いのは、トロピカル半環はクリーネ半環（クリーネ代数）としては自明（つまらない！）のに、作用素を係数とする行列代数におけるクリーネスター＝S行列＝指数が意味もあるし、面白い存在物になっている。

とにかく、&lt;strong&gt;トロピカルDFD&lt;/strong&gt;は、&lt;em&gt;ものすごく適切な具体例&lt;/em&gt;だという気がする。計算が簡単にキッチリできる点が気に入った！

*1200293829*[DFD][その他代数]トロピカル半環の順序と随伴もどき

トロピカル半環の順序は、普通の自然数の順序とは逆になり、∞が最小元で、0が最大元になる。これは、少し考えれば当たり前（minが加法なので）なのだが、誤解と混乱をしやすい。

普通の順序を使っていると、制限引き算が概逆元を与えることがいえなくなってしまう。

一方、自然数全体を、順序を射として足し算をモノイド積としたモノイド圏と考えたときに、特定のnによる足し算の随伴が制限引き算で与えられる。

制限引き算が、かたや随伴を与え、かたは概逆を与える。このことが、僕が概逆の関係を&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060803/1154581552&quot;&gt;斜随伴&lt;/a&gt;と呼んだ理由。

*1200293894*[DFD][その他代数]概反行列の定義

概逆元や概可逆ISRについては、ある程度は公理的な定義ができるが、概反行列は、具体的な行列表示に対してしか定義できない。しかも、どんな行列に対してなら定義できるかもよくわからない。

exp(-A) = exp(A)&lt;sup&gt;-1&lt;/sup&gt; の類似が成立することが目安。

*1200301657*[DFD][その他代数][説明]トロピカル半環は笑えるな

- 掛け算は、足し算です。
- より大きいは、より小さいです。
- ゼロは、無限大です。
- イチは、ゼロです。

</body>
</day>
<day date="2008-01-15" title="">
<body>
*1200385416*[DFD]離散ファインマン和

僕は、マーク・ウィリアム・ホプキンスの観察と示唆に触発されて、形式言語理論と（物理の）場の理論の類似をマジメに定式化しようと思ってきたわけで、スカラーとしてはクリーネ代数（言語や関係のベキ等半環）が念頭にあった。が、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080114/1200293620&quot;&gt;トロピカル半環&lt;/a&gt;もクリーネ代数と同様に興味深い。

となると、ファインマン型（あるいはファインマン風）の総和公式をクリーネ／ファインマンの公式とか呼ぶのはどうか？とも思える。経路積分が有限和になってしまうケースを一般に、&lt;strong&gt;離散ファインマン和&lt;/strong&gt;とでも呼ぼうかと思う。

ある程度の一般的な定式化を以下に：

まずは記号の準備； 1 + 1/2 + 1/3 + ... + 1/100 のような和を Σ(n=1, n=100; 1/n)のように書く。添字を使わなくて済むので便利。Π(n=1, n=100; 1 + n/100) も和が積に変わるだけで同様。

グラフ（空間）Gの2頂点をP, Qとする。PからQに至る長さnの経路の全体をΩ&lt;sub&gt;=n&lt;/sub&gt;(P, Q)と書くことにする。長さn以下の経路の全体はΩ&lt;sub&gt;≦n&lt;/sub&gt;(P, Q)、任意の長さの経路全体ならΩ&lt;sub&gt;＜∞&lt;/sub&gt;(P, Q)とする。Ω&lt;sub&gt;=n&lt;/sub&gt;(P, Q) を単に Ω&lt;sub&gt;n&lt;/sub&gt;(P, Q)、Ω&lt;sub&gt;＜∞&lt;/sub&gt;(P, Q) は Ω(P, Q) と略記してもよい。

AをG上の力学系（の生成作用素）とする。Aは辺に対して、なにか乗法的な量（モノイドの元）を対応させているとする。α∈Ω&lt;sub&gt;n&lt;/sub&gt;(P, Q)が通過する頂点を、P=α&lt;sub&gt;0&lt;/sub&gt;, α&lt;sub&gt;1&lt;/sub&gt;, ..., α&lt;sub&gt;n&lt;/sub&gt;=Q とする。αが渡っていく辺は、α&lt;sub&gt;0,1&lt;/sub&gt;, α&lt;sub&gt;1,2&lt;/sub&gt;, ..., α&lt;sub&gt;n-1,n&lt;/sub&gt; のように書こう。

α∈Ω&lt;sub&gt;n&lt;/sub&gt;(P, Q)に対して、Π(α; A)とは、Π(i=0, i=n-1; A(α&lt;sub&gt;i,i+1&lt;/sub&gt;))のことだとする。要するに、n本の辺に対する値を全部掛け算すること。掛け算が非可換だと順序に注意が必要。

Ω&lt;sub&gt;●&lt;/sub&gt;(P, Q)は、黒丸ところに =n、≦n、＜∞ のどれかが入ることを意味する。

さて、離散ファインマン和だが、スカラーは掛け算だけでなく足し算もできると仮定して、α∈Ω&lt;sub&gt;●&lt;/sub&gt;(P, Q)に対するΠ(α; A) を、すべてのαに渡って足し上げた値、つまり：

- Σ(α∈Ω&lt;sub&gt;●&lt;/sub&gt;(P, Q); Π(α; A))

のことである。

離散ファインマン公式（群）は、離散ファインマン和が、他のなにかの量と等しいことを主張する等式。例えば、

- Σ(α∈Ω&lt;sub&gt;n&lt;/sub&gt;(P, Q); Π(α; A)) = (A&lt;sup&gt;n&lt;/sup&gt;)[P, Q]

右辺は、行列としてのAのn乗の成分。

</body>
</day>
<day date="2008-01-16" title="">
<body>
*1200451670*[メモ][DFD][形式言語理論]あー勘違い！ 概逆の定義

概逆や斜随伴の定義には、どうも勘違いがあった。概逆って概念はいいのだけど、もっと強い定義ができる。

正錐（positive cone）を持つ半加群を考えて、正元を正元に移す線形（加法的）作用素を正作用素と呼ぶことにする。正作用素Aに対して、正元に限れば完全な逆元となるA'を、Aの概逆と呼ぶ。

と、これでいい。これだと、正元の世界では、逆問題が完全に解けてしまう。もちろん、すべての正作用素が概逆を持つわけではないが、実用的な作用素は概逆を持ち、問題が解ける。

ただし、この概逆概念は一般化しにくくて、正錐や正作用素を考えられない状況だと使えなくなる。そういう意味では、以前のようなスタイルも捨てるべきではないかもしれない。


</body>
</day>
<day date="2008-01-18" title="">
<body>
*1200627678*[メモ][DFD][その他代数]マスロフ和と離散ファインマン和

マスロフ和という演算があって面白い。のだけど、これは単なる遊び／コジツケなのか、物理的・現実的な意味があるのか、よくわからない。

a &gt; 0 , b &gt; 0 だとして、実数の定数hに対するマスロフ和 a [+]&lt;sub&gt;h&lt;/sub&gt; b = [a + b]&lt;sub&gt;h&lt;/sub&gt; は、

- (a&lt;sup&gt;h&lt;/sup&gt; + b&lt;sup&gt;h&lt;/sup&gt;)&lt;sup&gt;1/h&lt;/sup&gt;

h = 0 のときはうまく定義できない。a, bが0以下のときは、何とか定義できるかもしれない。

定数hはプランク定数と呼ばれるが、ほんとの（物理の）プランク定数と区別してマスロフ／プランク定数とでも呼ぼう。マスロフ和 [+]&lt;sub&gt;h&lt;/sub&gt;は、h = 1 では普通の和、h→+∞ でmax、h→-∞でminになる。

マスロフ和を使うと、パラメータhを持つエキゾチック代数の連続族を定義できる。hの値を動かして、その代数の振る舞いがどう変わるかをウンヌンできる。

離散ファインマン和にマスロフ和を使うと、h = 1 ではすべての経路の寄与が公平に勘案され、h→+∞ ではコスト最大値、h→-∞ではコスト最小値の経路が支配的になる。h = 0 で特異性があることは何か意味があるのか？ サッパリわからん。が、経路のコストには無関係に伝搬してきた値を集約するのが h = 1 のときであり、hが正負の無限大では、コストが極値的な経路の影響しか効いてこなくなる、ということはわかる。

hをプランク定数なんて呼んでいるのは、hの値の変化で古典／量子対応を説明する気持ちがあるのだろうが、現象と対応するのかな？ 計算上のトリックのような気もするけど。

*1200639800*[メモ][DFD][その他代数][説明]マスロフ半環と対数マスロフ半環

マスロフ和の定義：

- a [+]&lt;sub&gt;h&lt;/sub&gt; b = (a&lt;sup&gt;h&lt;/sup&gt; + b&lt;sup&gt;h&lt;/sup&gt;)&lt;sup&gt;1/h&lt;/sup&gt;

これだと、hがオリジナルの定義の逆数になっている。つまり、もともとは、

- (a&lt;sup&gt;1/h&lt;/sup&gt; + b&lt;sup&gt;1/h&lt;/sup&gt;)&lt;sup&gt;h&lt;/sup&gt;

これらは h ←→ 1/h で移りあうからどっちでもいい。オリジナルでは、h = 0 で古典系にいくので、物理との対応がいい。しかし、h →+0 と h→-0を区別するから、h→+∞、h→-∞としたほうがいいような気もする。

僕の定義を採用するとして、次が成立する。

- (x [+]&lt;sub&gt;h&lt;/sub&gt; y)&lt;sup&gt;-1&lt;/sup&gt; = x&lt;sup&gt;-1&lt;/sup&gt; [+]&lt;sub&gt;-h&lt;/sub&gt; y&lt;sup&gt;-1&lt;/sup&gt;

これは、大小のスケールを反転したときに、hマスロフ和が(-h)マスロフ和に移ることを示している。この設定では、量の逆数写像とマスロフ／プランク定数の符号反転が対応している。

もうひとつ面白い事実。

- x△&lt;sub&gt;h&lt;/sub&gt;y = log(exp(x) [+]&lt;sub&gt;h&lt;/sub&gt; exp(y))

と定義する。△&lt;sub&gt;h&lt;/sub&gt;を対数マスロフ和と呼ぶことにする。(&lt;b&gt;R&lt;/b&gt;, △&lt;sub&gt;h&lt;/sub&gt;, +) は半環になる。対数h-マスロフ半環と呼ぼう。普通のh-マスロフ半環(&lt;b&gt;P&lt;/b&gt;, [+]&lt;sub&gt;h&lt;/sub&gt;, ・) と対数h-マスロフ半環は、exp, logで完全に移りあうので、代数系としては区別できない。が、max-plus代数（極地半環）やmin-plus代数（熱帯半環）が出現するのは対数h-マスロフ半環の古典極限（h→+∞、h→-∞）としてである。

h = 0 のとき（もともとののプランク定数が無限大にいくとき）、マスロフ和は定義できないが、hが正で0に近いときの状況を見ると、h-マスロフ和のサマンドが、大小に関係なく平準化され（民主主義？いや共産主義？）、その後で大きなベキにより発散してしまう。

hを複素球面で動かすとすると、0と∞に特異性が残るだろうが、他は定義されてしまうのだろうか？ だとすると、複素プランク定数の意味は何だろう？ 

*1200645363*[雑感][山勘][DFD][その他代数]マスロフ和とパラメータ付き代数族

ちょっとマスロフ和&lt;em&gt;萌え&lt;/em&gt;状態になっている。

逆プランク定数h（h以外の文字を使ったほうがいいかも）に対するマスロフ半環をM&lt;sub&gt;h&lt;/sub&gt; = (&lt;b&gt;P&lt;/b&gt;, [+]&lt;sub&gt;h&lt;/sub&gt;, ・) とすると、これはhでパラメータ付けられた代数の族になる。台集合は同じだ。対数マスロフ半環L&lt;sub&gt;h&lt;/sub&gt;の場合も同じ。

hが動く空間は一種のモジュライ空間みたいなもんだろう。M&lt;sub&gt;h&lt;/sub&gt;でhを動かすことは、同じ台集合&lt;b&gt;P&lt;/b&gt;上の代数構造を連続変形していくことになる。もし、M&lt;sub&gt;h&lt;/sub&gt;に対して圏&lt;i&gt;C&lt;/i&gt;[M&lt;sub&gt;h&lt;/sub&gt;] = &lt;i&gt;C&lt;/i&gt;&lt;sub&gt;h&lt;/sub&gt;が対応しているなら、圏＝世界をパラメータに沿って連続変形していくわけだ。

具体的には、マスロフ半環係数の行列の圏とかリグラフの圏が考えられる。圏のなかで１つの対象や射を選んで、パラメータにそって動かすと、同一(?)物を異なる世界に旅しながら見ていくことになる。なんつうか、多世界を串刺しにする感じか。

現象と関係あるかどうかは棚上げにするにしても、マスロフ半環の世界では、hを+∞、-∞へ飛ばす古典極限操作が定義できる。古典系から、hを正の有限値、負の有限値にもってくる事が、マスロフの世界での量子化ってことになるのだろう。

話は変わるが、確率分布φがあるとき、φ&lt;sup&gt;1/h&lt;/sup&gt;を作って、hを大きくすると、正値（非ゼロ値）は1に近づいて、φは「φの台の特性関数」に近づく。これは、確率的な図形を古典図形（部分集合）へと極限を取っていることだが、1/hベキのhを大きくするって点は同じだ。

マスロフ和の単項バージョンは (a&lt;sup&gt;h&lt;/sup&gt;)&lt;sup&gt;1/h&lt;/sup&gt; で自明だが、2つのパラメータh, kを導入して、(a&lt;sup&gt;h&lt;/sup&gt;)&lt;sup&gt;k&lt;/sup&gt; としたらどうだろう？ マスロフ和は、k = 1/h（あるいはh = 1/k）のときだ。hはサマンドを平準化するか差別化（格差社会）するかのパラメータ、kは総和の最終値を調整するパラメータ。

(k, h)拡張マスロフ和は、

- (a&lt;sup&gt;k&lt;/sup&gt; + b&lt;sup&gt;k&lt;/sup&gt;)&lt;sup&gt;h&lt;/sup&gt;

代数的には全然ダメなものが出来上がるが、“n項の総和”さえできれば結合法則はいらない、というのであれば、ある程度は使える。どの程度使えるかはまったく不明。

いずれにしても、「代数法則は壊れてもいいから、離散ファインマン和が計算できればいい」という立場は意味を持ちそうだ。

</body>
</day>
<day date="2008-01-19" title="">
<body>
*1200707728*[用語法][DFD][その他代数]逆プランク定数k

マスロフ和、マスロフ代数で、オリジナルのhの代わりに1/hを使い、それをおなじ文字hで表してきたが、これはさすがに混乱のもと。k = 1/h として逆プランク定数kを使うことにする。

*1200707850*[DFD][その他代数]対数マスロフ和

kは逆プランク定数として、kをパラメータに使う。kマスロフ和[+]&lt;sub&gt;k&lt;/sub&gt;の対数バージョンとして a△&lt;sub&gt;k&lt;/sub&gt;b = log(exp(a) [+]&lt;sub&gt;k&lt;/sub&gt; exp(b)) を使ったが、これは、log&lt;sub&gt;t&lt;/sub&gt;(t&lt;sup&gt;a&lt;/sup&gt; + t&lt;sup&gt;b&lt;/sup&gt;) と[+]&lt;sub&gt;k&lt;/sub&gt;なしの形に書き換えられる。このとき、t = exp(k) となる。

これを示すとき、対数の底の変換公式を使うが、人生ではじめてこの公式を使ったよ。

逆プランク定数kをパラメータとするマスロフ代数をM&lt;sub&gt;k&lt;/sub&gt;として、t = exp(k)をパラメータとする対数マスロフ代数をL&lt;sub&gt;t&lt;/sub&gt;とすると、自然対数log:&lt;b&gt;P&lt;/b&gt;→&lt;b&gt;R&lt;/b&gt;は、M&lt;sub&gt;k&lt;/sub&gt;とL&lt;sub&gt;exp(k)&lt;/sub&gt;の半環同型を与える。任意の底の対数／指数が半環同型となるが、基準として自然対数を選ぶ。

tに対する対数マスロフ和を□&lt;sub&gt;t&lt;/sub&gt;とすると、
- log(a [+]&lt;sub&gt;k&lt;/sub&gt; b)  = log(a) □&lt;sub&gt;t&lt;/sub&gt; log(b)

t≦0と、t = 1 では対数マスロフ和は定義できない。t→+∞でmax古典極限、t→+0でmin古典極限になる。t→1+0、t→1-0 は、それぞれ k→+0、k→-0とおなじ状況となり、代数が発散崩壊する。

*1200708563*[DFD][その他代数]マスロフ代数の発散崩壊

逆プランク定数kをパラメータとするマスロフ代数M&lt;sub&gt;k&lt;/sub&gt;を考える。k &gt; 0 で動かすとして、k = +∞ ではmax古典極限で質点ぽい動き、k = 1 では波の伝搬のような現象が観測される、k→+0 と極限を取ると、空間の位置の差がだんだんなくなるし、量の差もなくなる。「どこをどう通ってどれだけ（量を）稼ぐか」の違いがなくなる。

それでいて、最終的な価格・価値は高騰するので、空間と量が無意味化して、各点での値は巨大な値になる。

「空間の位置の差がだんだんなくなる」とは、結局、空間が縮退してしまうことだろうし、「各点での値は巨大な値となる」とは、空間に広がって散らばっていた値が、“縮退して&lt;em&gt;一点と区別がつかなくなった各点&lt;/em&gt;”に集約されて爆発・発散することだろう。

これが現象のモデルとなるかどうかはともかくも、イメージが描きやすいし、面白いなー。

*1200709119*[DFD][その他代数]マスロフ和とp乗ノルム

成分が全部正実数のベクトル(x1, x2, ..., xn)を考える。そのp乗ノルムは、

- (x1&lt;sup&gt;p&lt;/sup&gt; + x2&lt;sup&gt;p&lt;/sup&gt; +  ... +  xn&lt;sup&gt;p&lt;/sup&gt;)&lt;sup&gt;1/p&lt;/sup&gt;

だけど、これは、n個の数のマスロフ総和と同じ。マスロフ和のときは、0 &lt; p &lt; 1 でも定義できる。

マスロフ和（総和）とp乗ノルムは何か関係あるかもしれない。ノルムのときは、ノルム球が凸でないと具合が悪いが、マスロフ和のときはその制限はない。ノルム球はひっこんでとんがった形になるが、これはトロピカル幾何のアメーバの例じゃなかろうか。

*1200710078*[DFD][その他代数][まとめ]エキゾチック半環の再整理

[http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733:title]にある表を再掲。


|*台集合        |*加法 |*乗法 |* 名称 |
|&lt;b&gt;N&lt;/b&gt;∪{+∞} |min|+ |tropical半環 |
|&lt;b&gt;N&lt;/b&gt;∪{-∞} |max|+ |polar半環 |
|&lt;b&gt;N&lt;/b&gt;∪{+∞} |min|max|fuzzy半環 |
|&lt;b&gt;R&lt;/b&gt;∪{+∞} |min|+ |optimization代数 |
|&lt;b&gt;R&lt;/b&gt;∪{-∞} |max|+ |schedule代数|

fuzzy半環を除いて、名称を整理してみる。

|*台集合        |* 加法-乗法 |* 新名称 |
|&lt;b&gt;N&lt;/b&gt;∪{+∞} |min-plus |離散熱帯半環 |
|&lt;b&gt;N&lt;/b&gt;∪{-∞} |max-plus |離散極地半環 |
|&lt;b&gt;R&lt;/b&gt;∪{+∞} |min-plus |連続熱帯半環 |
|&lt;b&gt;R&lt;/b&gt;∪{-∞} |max-plus |連続極地半環|

それとマスロフ代数／対数マスロフ代数の族（kは逆プランク定数、t = exp(k)）：

|*台集合        |* 加法-乗法 |* パラメータ |
|&lt;b&gt;P&lt;/b&gt;∪{+∞}   |min-times | k = -∞ |
|&lt;b&gt;P&lt;/b&gt;∪{0} |max-times | k = +∞ |
|&lt;b&gt;R&lt;/b&gt;∪{+∞} |min-plus | t = +0 |
|&lt;b&gt;R&lt;/b&gt;∪{-∞} |max-plus | t = +∞ |

*1200725845*[メモ][その他代数]対数マスロフ和の反転公式

当たり前といえば当たり前だが

- -(a □&lt;sub&gt;t&lt;/sub&gt; b) = (-a) □&lt;sub&gt;1/t&lt;/sub&gt; (-b)

が成立する。

人生で初めて使う対数の底の変換は：

- log&lt;sub&gt;a&lt;/sub&gt; x = (log&lt;sub&gt;b&lt;/sub&gt; a)&lt;sup&gt;-1&lt;/sup&gt; log&lt;sub&gt;b&lt;/sub&gt; x

なのだが、これにより、

- log&lt;sub&gt;1/t&lt;/sub&gt; x = (log&lt;sub&gt;t&lt;/sub&gt;(1/t))&lt;sup&gt;-1&lt;/sup&gt; log&lt;sub&gt;t&lt;/sub&gt; x

つまり、

- log&lt;sub&gt;1/t&lt;/sub&gt; x = (-1)(log&lt;sub&gt;t&lt;/sub&gt; x)

これがあれば、上の等式は出る。

対数マスロフ代数の場合は、過去と未来の反転のようなことだろうか。直感的意味がよくわからない。

*1200725940*[DFD][TQFT]指数的関手と加法的関手

TQFTとDFDは似てるがどうも違う。TQFT関手では、値の圏がテンソル圏で、F(A + B) = F(A)×F(B) と足し算が掛け算に移る、その意味で指数的。一方、DFDの関手は、アーベル圏類似の圏に値を取り、F(A + B) = F(A) + F(B) と加法的だ。

TQFTではA:φ→φに対するF(A)がMのスカラー不変量を定義したが、DFDではそうならないような気がする。A:1 → 1 に対してスカラー不変量が定義される感じだ。

*1200726064*[DFD][その他代数]力学が崩壊しないとき

k→+0でマスロフ代数が崩壊するといったが、代数が崩壊しても力学が崩壊するとは限らない。グラフが一直線の形をしているときは、和を取らないので代数が崩壊していても影響がでない。つまり次元が1なら、代数が崩壊しようが力学は定義できる。

より正確に言うと、合流がないグラフならいい。ツリーとか、サイクルを持つが被覆空間がツリーになるようなグラフ。

*1200726912*[DFD][その他代数]離散力学の古典極限と非古典力学

マスロフ代数上のDFDを考える。k &gt; 0 だとして、k→+∞でmax古典極限になる。このとき、&lt;em&gt;比喩的&lt;/em&gt;には次が成立する。

- 点光源から出た光は放射状に広がる。
- 放射状の各射線は“直線”である。
- 光線は二点間を直進する。

これは、変分原理（フェルマーの原理）で支配されるともいえる。

しかし、k = 1 の付近は非古典的で、光が直進するとも光が軌道を持つとも考えにくい。k→+0では、古典軌道概念がどんどん曖昧になる。フェルマーの原理も意味がなくなる。

面白いことに、kの値に関わらずホイヘンスの原理は成立する。ホイヘンスの原理は場の伝搬描像だから。kが無限でないときは、「ホイヘンス原理⇒フェルマー原理」という推論の根拠（最適経路＝古典軌道が支配的）がなくなってしまうだけだ。

最適経路、最短経路、可達性などの問題も古典極限における設定といえる。波頭集合（波頭線、波頭面）、掃過域、未掃過域などの概念は非古典でも通用する。

典型例として、距離概念の定義が、古典、非古典で次のように違う。

- 最短経路（古典軌道）の長さ
- 空間を単純に伝搬する波頭が到着するまでの時間

*1200727472*[雑記][課題][復習]細かい工夫を適用せよ

- [http://d.hatena.ne.jp/m-hiyama-memo/20070410/1176193943:title]

ここに書いてある細かい工夫を実際に適用して、ちゃんとすべきだ。

*1200730744*[説明][メモ][具体例]マスロフ代数をうまく説明できないか？

マスロフ代数関係を&lt;em&gt;いっぱい&lt;/em&gt;書いたけど。これを一般向けにうまく説明できないかな？

h（あるいはその逆数のk）がプランク定数の類似物だとわかるには、DFD（グラフ上の離散物理）をやらないとしょうがないのだけど、単に計算だけも面白い気がするが、、、やっぱり面白くないか？

対数マスロフ代数は熱帯半環（トロピカル代数）を含むから面白いかな。が、熱帯半環、極地半環も最適問題をからめないと面白くないのか？ ウーム。

最適問題としては、「氷運搬問題」とか「道に金貨が落ちている、稼ぎが良くないと通行禁止」とかの例を考えたが、他にうまい例がないか？


</body>
</day>
<day date="2008-01-23" title="">
<body>
*1201082682*[説明][雑記]マスロフ代数を説明できたのかな？

[http://d.hatena.ne.jp/m-hiyama-memo/20080119/1200730744:title]：
&gt;&gt;
マスロフ代数関係を&lt;em&gt;いっぱい&lt;/em&gt;書いたけど。これを一般向けにうまく説明できないかな？
&lt;&lt;
書いてみた→[http://d.hatena.ne.jp/m-hiyama/20080121/1200892274:title]。けっこうなブックマークを集めたのでビックリした。
調子にのって続編書いた→[http://d.hatena.ne.jp/m-hiyama/20080123/1201051152:title]、そしたら反応ナシ。あーやっぱりねぇ。

*1201082757*[圏一般論][DFD]quiverの表現＝カテグラフ

quiver（えびら；箙）って、有向グラフとまったく同じ概念。なんで別な用語を導入する必要があるのか？ 疑問だ。
これが箙↓
&lt;img src=&quot;http://www.chimaira.org/img2/ebira_deluxe72.jpg&quot; &gt;

だが、quiverの表現って概念は、ズバリ！ カテグラフ。quiver表現は、k加群の圏k-Modへのグラフ写像。これはk-Modを係数圏とするカテグラフと同じ。よって、quiver表現論をカテグラフに適用できるかもね。

とりあえず、quiverの道代数って概念はおいしそうだ。

</body>
</day>
<day date="2008-01-24" title="">
<body>
*1201124422*[用語法][物理っぽい]区別／使い分けがわからない

早起き (see timestamp)：

- フェルマーの原理
- ハミルトンの原理
- 最小作用の原理
- 変分原理

フェルマーは幾何光学で、ハミルトンは（解析）力学か。変分原理はかなり一般的な文脈で使うのかもしれない。が、ハミルトンの原理と最小作用の原理って同じようだが？

*1201134176*[メモ][課題]後で考える／調べる／書く

- 「古典的」とは？
- quiverの道代数、道余代数
- ホップquiverの道ホップ代数
- ブラフの隣接行列と道代数の関係は？
- 総称は必然なのか？

*1201143377*[メモ][その他代数]Sweedler記法

スウィードラー（Sweedler）が始めたとされる書き方 α = α&lt;sub&gt;(1)&lt;/sub&gt;α&lt;sub&gt;(2)&lt;/sub&gt; がなぜ便利なのか、やっとわかった。

*1201154761*[用語法][物理っぽい][まとめ]最小作用の原理、変分原理

[http://d.hatena.ne.jp/m-hiyama-memo/20080124/1201124422:title]にて：
&gt;&gt;
ハミルトンの原理と最小作用の原理って同じようだが？
&lt;&lt;

準備： s = s(t)（t = t0からt1）を運動のパラメータ表示とする（配位空間を動く）。(s, s')（s' = ds/dt）は相空間上での軌道（相軌道）となる。必要に応じて、sを相空間に持ち上げて考える。接ベクトルds/dtをVとしてv = |V|。

最小作用の原理は、解析力学と幾何光学に渡る一般原理だと思ってよいだろう（若干の拡大解釈をしてるが）。相空間または配位空間に微分形式ωがって、ωを軌道（相軌道かもしれない）sにそって積分した∫(s; ω) を、sに対する汎関数I[s]と考え、I[s]の停留条件を法則とすることが最小作用の原理。

力学的なエネルギーKから、Kdt = (1/2)mv&lt;sup&gt;2&lt;/sup&gt;dt = (1/2)mv(ds/dt)dt = (1/2)mvds をωとして、∫(s; ω) = ∫(s; Kdt) を使い、δI[s] = δ∫(s; Kdt) = 0 を法則とするのが&lt;strong&gt;モーペルチュイの最小作用原理&lt;/strong&gt;。

ラグランジュ関数L = L(q, q', t)から、ω = Ldt として、∫(s; ω) = ∫(s; Ldt) を使い、δI[s] = δ∫(s; Ldt) = 0 を法則とするのが&lt;strong&gt;ハミルトンの最小作用原理&lt;/strong&gt;。

屈折率分布n = n(x, y, z)から、ω=ndsとして、∫(s; ω) = ∫(s; nds) を使い、δI[s] = δ∫(s; ndt) = 0 を法則とするのが&lt;strong&gt;フェルマーの原理&lt;/strong&gt;。

ハミルトンの原理で出てくるラグランジュ関数の積分は、作用積分または&lt;strong&gt;ハミルトンの積分&lt;/strong&gt;と呼ばれる。なぜか、ラグランジュの積分じゃない。作用積分＝ハミルトン積分の時間微分 dI/dt（偏微分）がハミルトン関数。ラグランジュ関数を経由せずにハミルトン関数から出発しても力学はできる。

変分原理は、なんらかの法則が変分の停留点で与えられるっていうスタイル。これは、最短経路のような最適経路、あるいは石けん膜のようなものが自然のなかで実現する、という信仰とも解釈できる。

*1201155001*[メモ]総称は必然なのか？

[http://d.hatena.ne.jp/m-hiyama-memo/20080124/1201134176:title]にて：
&gt;&gt;
総称は必然なのか？
&lt;&lt;

必然だと思うが、型クラス、C++のコンセプト（という概念）、型制約、種、スラント圏、インデックスされた圏、インスティチューションなどを考慮して考えるべきだ。

*1201155546*[DFD]集計構造と行列計算

行列計算には結合的な加法が必須ではない。すべてのn ≧0 に対して、長さnの列a = a[i] に対して集計値を対応させる写像Γがあればよい。Γ&lt;sub&gt;n&lt;/sub&gt;:A&lt;sup&gt;n&lt;/sup&gt;→A であって、

+ 可換： a'がaを置換したものなら、Γ(i; a[i]) = Γ(i, a'[i])
+ ゼロ： aが長さ0の列のとき Γ(a) = 0
+ イチ： aが長さ1の列のとき Γ(a) = a[1]
+ 分配： b・Γ(i; a[i]) = Γ(i; b・a[i])
+ 集計性：Γ(j; Γ(i; a[j, i])) = Γ(i; Γ(j; a[j, i]))

非結合的Γの例としては、平均値がある。

*1201158496*[リンク]C++のconcepts

- Title: Specifying C++ Concepts
- Authors: Gabriel Dos Reis, Bjarne Stroustrup
- URL: http://www.research.att.com/~bs/popl06.pdf
- 14ページ

後で調べる。

*1201160566*[お絵描き][計算]とある展開公式

&lt;em&gt;ベキ等な&lt;/em&gt;双デカルト圏において、[http://d.hatena.ne.jp/m-hiyama-memo/20080109/1199840821:title] の公式から次が示せる。

□ = ∇;Δ として、

- □ = (1 + Δ);□;(∇ + 1)

さらに、[f] = ∇;f;Δ として、

- [f] = (1 + Δ);([f] + f);(∇ + 1)

これは、再帰的な（入れ子の）展開公式だ。

*1201161090*[お絵描き][計算][課題] f&lt;sup&gt;+&lt;/sup&gt; = f;f&lt;sup&gt;*&lt;/sup&gt; = f&lt;sup&gt;*&lt;/sup&gt;;f 

示せるはずだよね。

</body>
</day>
<day date="2008-01-25" title="">
<body>
*1201220162*[リンク]そのうち目を通すかも

- Title: Strict 2-toposes (Submitted on 16 Jun 2006)
- Author:  M. Weber
- URL: http://arxiv.org/abs/math/0606393
- 53ページ

- Title: A BRIEF INTRODUCTION TO COALGEBRA REPRESENTATION THEORY
- Author: William Chin
- URL: http://condor.depaul.edu/~wchin/crt.pdf
- 18ページ

- Title: Chain and Distributive Coalgebras (2007)
- Authors: Christian Lomp and Alveri Sant'Ana
- URL: http://www.mpim-bonn.mpg.de/digitalAssets/2759_lomp.pdf
- 3ページ　独特なレイアウト

- Title: Hopf quivers (Submitted on 11 Sep 2000)
- Authors: Claude Cibils, Marc Rosso
- URL: http://arxiv.org/abs/math/0009106
- 12ページ

- Title: QUIVER の表現とAUSLANDER-REITEN 理論
- Author: 浅芝秀人
- URL: http://www.ipc.shizuoka.ac.jp/~shasash/papers/ebira.pdf
- 37ページ

*1201221253*[雑記]行列は行列、たかが行列、されど行列

僕は長いあいだ、行列は（基底を選んでの）線形写像の表現だと理解していた。これは&lt;em&gt;よろしくない&lt;/em&gt;。線形写像の表現と思うのは行列の解釈の一例に過ぎず、それが行列の定義や本性というわけではない。

要するに行列は、数を正方形、長方形、三角形、立体などに並べたものなのだ。それ以上でも以下でもない。たまたま、線形写像と解釈するとうまくいくときもあるが、それが全てではない。行列をそのまま図形的対象として扱うこともできるし、意味を無視して計算アルゴリズムを考えることもできる。

カウフマンの抽象テンソルとか、圏論的な行列であるprofunctor（bimodule, distributor）とかの概念は線形写像からは出てこない。カテグラフ＝箙の表現も図形としての行列の一般化になっている。

まず線形写像（機能）ありきではなくて、まず行列（図形）ありきなのだ。

*1201222175*[圏一般論][復習]トラス（藁束）圏構成

- [http://d.hatena.ne.jp/m-hiyama-memo/20070117/1168993359:title]

使えそうな気がしている。

</body>
</day>
<day date="2008-01-30" title="">
<body>
*1201667694*[トレース／コンパクト閉圏][まとめ][説明]モノイド閉園、デカルト閉圏、コンパクト閉圏

対称モノイド閉圏があり、モノイド積による関手の随伴により内部ホムを定義して、自己豊饒化されている状況を考える。モノイド積を×、内部ホム（ホム積）を[-, -]で書くとする。デカルト閉圏やコンパクト閉圏で成立している同型と、それに類似の算術公式をまとめる。

| [B, [A, X&amp;#93;]≒[A×B, X]  |(x&lt;sup&gt;a&lt;/sup&gt;)&lt;sup&gt;b&lt;/sup&gt; = x&lt;sup&gt;a・b&lt;/sup&gt; | (x/a)/b = x/(a・b) |
| [A, X]≒X×A&lt;sup&gt;*&lt;/sup&gt;| - | x/a = x・a&lt;sup&gt;-1&lt;/sup&gt; |
| [A, X]×[A, Y]≒[A, X×Y]| x&lt;sup&gt;a&lt;/sup&gt;・y&lt;sup&gt;a&lt;/sup&gt; = (x・y)&lt;sup&gt;a&lt;/sup&gt; | - |
| [1, X]≒X               | x&lt;sup&gt;1&lt;/sup&gt; = x | x/1 = x・1&lt;sup&gt;-1&lt;/sup&gt; = x|
| [0, X]≒1               | x&lt;sup&gt;0&lt;/sup&gt; = 1 | - |
| [A, 1]≒1               | 1&lt;sup&gt;a&lt;/sup&gt; = 1 | - |

*1201668662*[圏一般論][具体例][説明]内部ホムと豊饒圏の具体的構成

Setへの忘却関手U:C→Setを持っている圏を具象圏と呼ぶ。Uは忠実な関手なので、C(A, B)⊆Set(U(A), U(B))と考えてよい。U(A)は「Aの台集合」と解釈してよいだろう。

この状況で、[-, -]:|C|×|C|→|C|と、comp:[A, B]×[B, C]→[A, C] in C、 id:1→[A, A] in Cがホム対象の公理を満たすなら、忘却関手を使って、新しいhomを hom(-, -) = U([-, -]) として定義して、homによる圏を再定義できる。

</body>
</day>
<day date="2008-01-31" title="">
<body>
*1201751900*[DFD][具体例][説明][計算]氷運搬問題の例

以下は、氷運搬問題の例（説明は下）：

&lt;img src=&quot;http://www.chimaira.org/img2/propagation-exam.gif&quot; &gt;

- A,B,C,Dの4頂点と、それを拡張した6頂点のグラフ上の力学系。重み付き隣接行列をKとする。
- 頂点に分布された氷の量φが状態関数＝波動関数＝コスト関数となる。φ' = Kφ が系の発展方程式。
- 頂点Aにだけ分布しているδ関数の状態から出発して、伝搬をペトリネットのトークン（コイン）のように図示した。φに対する掛け算は実行し、足し算は保留している。
- Aから出発した“波”が、step 2でFまで届き（第一波）、step 3でも次の波（第二波）が届いているのがわかる。

</body>
</day>
<day date="2008-02-01" title="">
<body>
*1201827053*[圏一般論][説明]行列の圏と行列レトラクタブルな圏

- [http://d.hatena.ne.jp/m-hiyama-memo/20061109/1163049291:title]

あたりの話に決着を付けたい。

前からなんとなくは知っていたことだが、昨日寝てたらまとまった（ような気がした）ので書いておく。

&lt;h5&gt;用語：近加法圏&lt;/h5&gt;

- 加法圏 ： 零対象と双積を持つAb圏 （一般的）
- 半加法圏 ： 零対象と双積を持つAbMon圏（by 檜山）

さらに、零対象を持つAbMon圏を&lt;strong&gt;近加法圏&lt;/strong&gt;（nearly additive category）と呼ぶことにする。（nearlyのほうがalmostより接近度が弱いそうだ）

&lt;h5&gt;C行列の圏と行列レトラクション&lt;/h5&gt;

Cが近加法圏として、C係数行列の圏MAT(C)を次のように定義する。

- MAT(C)の対象は|C|&lt;sup&gt;*&lt;/sup&gt;（クリーネスター）
- MAT(C)の射は行列、結合と恒等射は行列掛け算と単位行列

C→MAT(C)という&lt;em&gt;標準的な&lt;/em&gt;埋め込みがあるから、これをIとする。

関手R:MAT(C)→Cと自然変換β::MAT(C)⇒R;I が次を満たすとき&lt;strong&gt;行列レトラクション関手&lt;/strong&gt;と呼ぶ。

- I;R = C
- βは自然同型

行列レトラクションがあれば、定義よりただちに、CとMAT(C)が圏同値となる。自然同型変換βを行列の&lt;strong&gt;コントラクション（contraction）変換&lt;/strong&gt;と呼ぶ。

MAT(C)のなかで、長さが1の列と1×1行列の全体は部分圏をなすので、それをMAT&lt;sub&gt;1&lt;/sub&gt;(C)とする。CとMAT&lt;sub&gt;1&lt;/sub&gt;(C)は自明に同型である。R;Iの像はMAT&lt;sub&gt;1&lt;/sub&gt;(C)である。コントラクション変換βは、MAT&lt;sub&gt;&lt;/sub&gt;(C)をMAT&lt;sub&gt;1&lt;/sub&gt;(C)に縮める操作となっている。

（コントラクション変換を伴う）行列レトラクションを持つ近加法圏を&lt;strong&gt;行列レトラクタブルな圏&lt;/strong&gt;と呼ぶ。

&lt;h5&gt;近加法圏の双積構造&lt;/h5&gt;

零対象と双積を持つ圏は、自動的に（必然的に）近加法構造を持つと思うが確認してない。おそらくは、「双積を持つ近加法圏」という定義は冗長だろう。が、ここでは、双積を持つ近加法圏で考える。

近加法圏Cが行列レトラクタブルであるなら、そのレトラクション関手Rが、実は双積を与えるはず。つまり、A×B := R([A, B])。射影や入射は行列で定義すればよい。

逆に、近加法圏が双積を持つなら、その双積を使って行列レトラクタブルであることを示せる。

&lt;h5&gt;等式的双デカルト圏との関係&lt;/h5&gt;

等式的双デカルト圏が零対象と双積を持つことは計算だけで示せる。逆に、零対象と双積から双デカルト構造を作れれば、次の3者が同じものだということになる。

+ （選ばれた）零対象と（選ばれた）双積を持つ圏
+ 等式的双デカルト圏
+ 行列レトラクタブルな近加法圏

さらに、S⊆|C|を選んで、MAT(S;C)を定義できる。MAT(S;C)は、対象をS&lt;sup&gt;*&lt;/sup&gt;に制限した行列の圏である。MAT(S;C)が行列レトラクション関手を持ち、したがってCと圏同値であるとき、SはCを生成すると言ってよい。Sがどのような集合（例えば有限集合）に取れるかによって、Cの複雑性を計ることができる。

いずれにしても、MAT(C), MAT(S;C)は道具に使えるし、近加法圏の圏NACの上のendofunctor MAT:NAC→NAC としても興味深い。

*1201843235*[圏一般論][計算]双積から加法は出る

[http://d.hatena.ne.jp/m-hiyama-memo/20080201/1201827053:title]より：
&gt;&gt;
零対象と双積を持つ圏は、自動的に（必然的に）近加法構造を持つと思うが確認してない。おそらくは、「双積を持つ近加法圏」という定義は冗長だろう。
&lt;&lt;
&lt;hr&gt;

A×Bを直積、A+Bを直和、A※Bを双積とする。米（※）じゃなくて、×と+を重ねた記号があると意味的にピッタリだと思うが、まー、米でもいいや。

射影をπ&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;、入射をι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;と書く。零射は0&lt;sub&gt;A,B&lt;/sub&gt;。

(A, B, A※B; π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;)が双積系であるとは、

- (A, B, A※B; π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;)が直積系
- (A, B, A※B; ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;, ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;)が直和系

になっていて、さらに次の等式が成立：&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;ウワーッ、結合の順序が逆だ！！！ 以下、π;ι を ι;π の直して読んでね。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

+ π&lt;sup&gt;1&lt;/sup&gt;;ι&lt;sup&gt;1&lt;/sup&gt; = 1&lt;sub&gt;A&lt;/sub&gt;
+ π&lt;sup&gt;1&lt;/sup&gt;;ι&lt;sup&gt;2&lt;/sup&gt; = 0&lt;sub&gt;A,B&lt;/sub&gt;
+ π&lt;sup&gt;2&lt;/sup&gt;;ι&lt;sup&gt;1&lt;/sup&gt; = 0&lt;sub&gt;B,A&lt;/sub&gt;
+ π&lt;sup&gt;2&lt;/sup&gt;;ι&lt;sup&gt;2&lt;/sup&gt; = 1&lt;sub&gt;B&lt;/sub&gt;

これは、δ&lt;sup&gt;i,j&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;（i,j = 1 or 2）をそれなりに定義して、

- π&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;;ι&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = δ&lt;sup&gt;i,j&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;

とも書ける。

双積を定義するには、前もって零対象0と零射0&lt;sub&gt;A,B&lt;/sub&gt;の存在が必須なので、双積を持つ圏（category with biproducts）は必然的に零を持つ圏（category with zero）である。

さて、双積を持つ圏では次が成立する。f:A→P, g:B→Qとして；

- &amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt; = [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;] : A※B→P※Q

これを確認するには、&amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt;;π&lt;sup&gt;i&lt;/sup&gt; と [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;];π&lt;sup&gt;i&lt;/sup&gt; を比較すればいい。実際にπ&lt;sup&gt;1&lt;/sup&gt;でやってみると：

- π&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;1&lt;/sup&gt;;f = [f, 0&lt;sub&gt;B,Q&lt;/sub&gt;] : A※B→P

という等式が必要になるのだが、それは次の2つの等式から出る。

+ ι&lt;sup&gt;1&lt;/sup&gt;;π&lt;sup&gt;1&lt;/sup&gt;;f = ι&lt;sup&gt;1&lt;/sup&gt;;[f, 0&lt;sub&gt;B,Q&lt;/sub&gt;]
+ ι&lt;sup&gt;2&lt;/sup&gt;;π&lt;sup&gt;1&lt;/sup&gt;;f = ι&lt;sup&gt;2&lt;/sup&gt;;[f, 0&lt;sub&gt;B,Q&lt;/sub&gt;]

双積の定義 π&lt;sup&gt;i&lt;/sup&gt;;ι&lt;sup&gt;j&lt;/sup&gt; = δ&lt;sup&gt;i,j&lt;/sup&gt; からすぐにわかる。

それで、

- f※g = &amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt; = [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;] : A※B→P※Q

と定義して、当該の圏が※に関してモノイド圏になることが示せる。このモノイド積※と、前もって持っている直積構造／直和構造から、双積を持つ圏が（等式的）双デカルト圏であることがわかる。双デカルト圏には、対角Δと余対角∇から近加法的構造（nearly additive structure）が入るから、双積を持つなら自動的・必然的に近加法的であることになる。

やっぱりね。

実はまだ、双積を持つ近加法圏の加法（事前に定義されている）が、双積から誘導された（induced）加法かどうかはわからない。双積と協調する加法がイッパイあるとは思えないが、確認してはいない。

*1201852881*[圏一般論][課題]加法から双積は出るのか？

[http://d.hatena.ne.jp/m-hiyama-memo/20080201/1201843235:title]より：
&gt;&gt;
実はまだ、双積を持つ近加法圏の加法（事前に定義されている）が、双積から誘導された（induced）加法かどうかはわからない。双積と協調する加法がイッパイあるとは思えないが、確認してはいない。
&lt;&lt;

これ、どうやって確認するのか、よくわからんな。

とりあえず、Cはある程度小さい近加法圏だとして、共変米田埋め込み（CoYoneda embedding）をすると、直積がホントの直積（集合前層の意味での直積だが）であり、対角もホントの対角で表現することができる。ホムセット上の加法から余対角∇&lt;sub&gt;+&lt;/sub&gt;:A&lt;sup&gt;*&lt;/sup&gt;×A&lt;sup&gt;*&lt;/sup&gt;→A&lt;sup&gt;*&lt;/sup&gt;も作れる。

この加法的余対角∇&lt;sub&gt;+&lt;/sub&gt;が、双積（つうか、直和）から導かれる余対角∇ = [1, 1]と同じになることを示せばいいのか？ 話は完全に集合部分圏（具象圏）になるが、それでいいのか？ いいような気もするが。

とりあえず、集合部分圏で試してみる価値はあるだろう（それでいいかどうかは棚上げ）。

- 対象は集合
- 双積の台集合は集合の直積
- 入射は直積への埋め込み写像
- 余対角は二項演算と考えてよい。
- そのとき、余対角と近加法構造はどう関係してるか／してないか？

うーむ、情勢が完全に把握できてない感じだ、、、、

*1201853492*[用語法]レトラクションとかコントラクションとか

[http://d.hatena.ne.jp/m-hiyama-memo/20080201/1201827053:title]の用語法を整理するために、幾何学（ホモトピー）の用語法と定義を抜粋。

A⊆X、f:X→A の状況で：

- f|&lt;sub&gt;A&lt;/sub&gt; = id&lt;sub&gt;A&lt;/sub&gt; なら、fは&lt;strong&gt;レトラクション&lt;/strong&gt;
- レトラクションがあるなら、AはXの&lt;strong&gt;レトラクト&lt;/strong&gt;
- レトラクションfをX→Xと考えてid&lt;sub&gt;X&lt;/sub&gt;とホモトープなら、AはXの&lt;strong&gt;変位レトラクト&lt;/strong&gt;（deformation retract）。
- fとid&lt;sub&gt;X&lt;/sub&gt;がAに関して相対ホモトープ f～id&lt;sub&gt;X&lt;/sub&gt; (rel A)ならば、Aは&lt;strong&gt;Xの強変位レトラクト&lt;/strong&gt;
- Xの一点pがあり、{p}がXの変位レトラクトなら、Xは&lt;strong&gt;可縮&lt;/strong&gt;

f～id&lt;sub&gt;X&lt;/sub&gt; (rel A) とは、任意の時刻tに対してf&lt;sub&gt;t&lt;/sub&gt;:X→Xが、f&lt;sub&gt;t&lt;/sub&gt;|&lt;sub&gt;A&lt;/sub&gt; = id&lt;sub&gt;A&lt;/sub&gt;となっていること。つまり、ホモトピーの最中にでもA上ではまったく定常的で、時刻による変動がない。Aの外でしかホモトピーが動かないこと。

</body>
</day>
<day date="2008-02-02" title="">
<body>
*1201940434*[圏一般論][課題]双積と加法の関係 -- まだわかってない

[http://d.hatena.ne.jp/m-hiyama-memo/20080201/1201852881:title]の話。

復習； 双積に関して重要なのは、それが直積かつ直和であるだけでなく、次が成立することだろう。

- ι&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;;π&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = δ&lt;sup&gt;i,j&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;

δは次のように定義する：

- δ&lt;sup&gt;1,1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = 1&lt;sub&gt;A&lt;/sub&gt;
- δ&lt;sup&gt;1,2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = 0&lt;sub&gt;A,B&lt;/sub&gt;
- δ&lt;sup&gt;2,1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = 0&lt;sub&gt;B,A&lt;/sub&gt;
- δ&lt;sup&gt;2,2&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; = 1&lt;sub&gt;B&lt;/sub&gt;

これは直交性条件といってもいい。

f:A→P, g:B→Qとして；

- &amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt; = [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;] : A※B→P※Q

を示す際にも直交性が重要だ。

双積があれば、そこから対角Δ&lt;sub&gt;A&lt;/sub&gt; = &amp;lt;1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;&gt;, 余対角∇&lt;sub&gt;A&lt;/sub&gt; = [1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;]が定義できる。加法は、f, g:A→Bに対して、

- &amp;lt;1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;&gt;;&amp;lt;π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,A&lt;/sub&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,A&lt;/sub&gt;;g&gt;;[1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;]

または、

- &amp;lt;1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;&gt;;[f;ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;B,B&lt;/sub&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;B,B&lt;/sub&gt;];[1&lt;sub&gt;A&lt;/sub&gt;, 1&lt;sub&gt;A&lt;/sub&gt;]

として定義できる。ここまでの議論は等式的計算だけ。

&lt;hr&gt;
それに対して、近加法的圏から出発すると、米田埋め込みを使うしか方法がないように思える。Cが近加法圏なら、その米田埋め込み像C&lt;sub&gt;^&lt;/sub&gt;が、可換モノイドの前層の圏だと思ってよい。つまり、「C（かC&lt;sup&gt;op&lt;/sup&gt;）から集合論的可換モノイドの圏AbMonへの関手の圏」のなかにCの良い表現（実現）を作れる。

可換モノイドの前層（or 余前層）の圏[C&lt;sup&gt;op&lt;/sup&gt;, AbMon]の部分圏において、加法と双積がどのくらい堅く結びついているか？ どのくらい相互規定しているのか？ を調べればいいってことかな？

</body>
</day>
<day date="2008-02-04" title="">
<body>
*1202117567*[圏一般論][課題]双積と加法の関係 -- だいたいわかった

[http://d.hatena.ne.jp/m-hiyama-memo/20080201/1201852881:title]と[http://d.hatena.ne.jp/m-hiyama-memo/20080202/1201940434:title]の話。

発端は：
&gt;&gt;
- 半加法圏 ： 零対象と双積を持つAbMon圏（by 檜山）
&lt;&lt;

この定義が冗長だろう、ということ。双積を持てば加法は一意的に定義されるだろう、ということ。

双積から加法の定義は、f + g := Δ;(f※g);∇ となる。だから、半加法圏のなかで成立する等式として f + g = Δ;(f※g);∇ が示せればOK。

f + g = Δ;(f※g);∇ は普通の線形代数でも示せるのだから、半加法圏で線形代数をやって、この等式を示せばいいことになる。例えば、準備として次のような等式を示したい。

- &amp;lt;f, f'&gt; + &amp;lt;g, g'&gt; = &amp;lt;f + f', g + g'&gt;
- &amp;lt;f, 0&gt; + &amp;lt;0, g&gt; = &amp;lt;f, g&gt;
- &amp;lt;f, g&gt;;[1, 1] = f + g

</body>
</day>
<day date="2008-02-05" title="">
<body>
*1202184323*[圏一般論]双積と加法の関係 -- よくわかった

半加法圏では次が成立する。

+ &amp;lt;f, g&gt;;[1, 1] = f + g
+ &amp;lt;1, 1&gt;;[f, g] = f + g
+ &amp;lt;1, 1&gt;;(f※g);[1, 1] = f + g

f※gの定義（&amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt; = [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;]）から、

+ &amp;lt;f, g&gt;;[1, 1] = &amp;lt;1, 1&gt;;f※g;[1, 1] （&amp;lt;f, g&gt; = &amp;lt;1, 1&gt;;f※g）
+ &amp;lt;1, 1&gt;;[f, g] = &amp;lt;1, 1&gt;;f※g;[1, 1] （[f, g] = f※g;[1, 1]）

がすぐ出るので、どれか1つを示せばよい。&amp;lt;f, g&gt;;[1, 1] = f + g を示すことにして、次のように計算する（説明は下）。&lt;a target=&quot;_blank&quot; href=&quot;http://www.chimaira.org/img2/addition-in-semiadditivecat.gif&quot;&gt;画像だけ&lt;/a&gt;

&lt;img src=&quot;http://www.chimaira.org/img2/addition-in-semiadditivecat.gif&quot; &gt;

考えるときは上から下へと考えたが、論理の流れは下から上。

一番下の命題は、零とのペアリング、コペアリングは結合で書ける、ということ。零が相手ならペアリングしても実質的にはペアになってないこと。成分（余成分）ごとに等式を示せばよい。双積の直交性が効いている。

その他は別に問題ないだろう。線形代数の基本的な計算を使っている。

+ 縦ベクトルの足し算：&amp;lt;f, f'&gt; + &amp;lt;g, g'&gt; = &amp;lt;f + g, f' + g'&gt;
+ 横ベクトルの足し算：[f, f']+ [g, g'] = [f + g, f' + g']
+ ベクトルの分解：&amp;lt;f, g&gt; = &amp;lt;f, 0&gt;  + &amp;lt;0, g&gt;

ここでは使ってないが、

+ &amp;lt;f, 0&gt; = f;&amp;lt;1, 0&gt;
+ [f, 0] = [1, 0];f

なども重宝する。
&lt;hr&gt;

この程度の計算でも動悸息切れがする。ハァーー。それにしても、計算はまったく体力だな。

*1202184865*[圏一般論]双積と加法の関係 -- おまけ

計算の途中でいくつか気がついたことを書く。

射f:A→P, g:B→Q の双積は次の4つのどれで定義しても同じ。

+ &amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt;
+ [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;]
+ 図式1を可換にする普遍射
+ 図式2を可換にする普遍射

図式1
&lt;pre&gt;
  A-(f)--→ P
 ↑        ↓
A※B - - -&gt;A※B
 ↓        ↑
  B-(g)--→ Q
&lt;/pre&gt;

図式2
&lt;pre&gt;
  A-(f)--→ P
 ↓        ↑
A※B - - -&gt;A※B
 ↑        ↓
  B-(g)--→ Q
&lt;/pre&gt;

それと、直接の関係はないのだけど、A※0 ≒ A を示すのに次が使える。

- f:A※B→A※B、ι&lt;sup&gt;1&lt;/sup&gt;;f;π&lt;sup&gt;1&lt;/sup&gt; = A かつ ι&lt;sup&gt;2&lt;/sup&gt;;f;π&lt;sup&gt;2&lt;/sup&gt; = B ならば、f = A※B。

これはもう少し一般化して成分による射の比較に使えそう。

*1202185489*[圏一般論]MAT関手はべき等モナド

MAT関手を分類して、対象の空列を認めるものをMAT&lt;sup&gt;*&lt;/sup&gt;、空列は認めないものをMAT&lt;sup&gt;+&lt;/sup&gt; とする。近加法圏の上の関手としては、MAT&lt;sup&gt;+&lt;/sup&gt;のほうが扱いやすい。

実は、MATは、半加法圏を作り出す関手だが、単なるAbMon圏に作用させるときはMAT&lt;sup&gt;*&lt;/sup&gt;、近加法圏に作用させるときはMAT&lt;sup&gt;+&lt;/sup&gt;が便利なのだ。AbMon圏では、零対象、零射が存在するとは限らないので、サイズが0の列や行列で零を表現する。零の存在が保証されている近加法圏ではサイズ0は邪魔になる。

いずれにしてもMATはモナドであり、MAT(C)は半加法圏となる。双積は、対象列の連接と行列のブロック対角行列によって与えられる。CがAbMon圏または近加法圏なら、MAT(C)は半加法圏となり、MAT(MAT(C))は潰れる（同値コントラションを持つ）。よって、圏同値の意味で、MATはベキ等モナドになる。

*1202186204*[圏一般論][用語法]レトラクションと同値コントラクション

I:C→Dが埋め込み、R:D→Cがレトラクション関手（I;R = C）のとき、γ::D⇒R;I が自然同型のとき、γを&lt;strong&gt;同値コントラクション（同値縮退）&lt;/strong&gt;、または&lt;strong&gt;同値デフォメーション（同値変位）&lt;/strong&gt;と呼ぶことにする。それで、CはDの&lt;strong&gt;同値レトラクト&lt;/strong&gt;だと呼ぶ。

明らかに、CとDは圏同値。この「同値」を強調するために、同値レトラクトと呼ぶことにした。γにより、Dが同値のままCに潰れるので、同値コントラクションも割と適切かと。


</body>
</day>
<day date="2008-02-06" title="">
<body>
*1202263028*[課題][TQFT][DFD][形式言語理論][復習][マンダラ]マンダラ、半テンソル圏、行列圏関手

標語は、「複雑さを抱擁せよ」かな。

&lt;h5&gt;マンダラな圏&lt;/h5&gt;

- マンダラ -[http://d.hatena.ne.jp/m-hiyama-memo/20060606/1149560697:title]
- マンダラ -[http://d.hatena.ne.jp/m-hiyama-memo/20061205/1165306116:title]
- 壁の圏 [http://d.hatena.ne.jp/m-hiyama-memo/20070113/1168670955:title]
- CGFT [http://d.hatena.ne.jp/m-hiyama-memo/20070104/1167881986:title]
- 次元が3の圏 [http://d.hatena.ne.jp/m-hiyama-memo/20070104/1167881650:title]

&lt;h5&gt;半テンソル圏&lt;/h5&gt;

- [http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170319368:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070201/1170321053:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070208/1170893105:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070210/1171083963:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20061228/1167286024:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20061006/1160126861:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060621/1150873298:title]

&lt;h5&gt;行列圏関手&lt;/h5&gt;

- [http://d.hatena.ne.jp/m-hiyama-memo/20070202/1170405964:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070208/1170909876:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070208/1170909875:title]

*1202281641*[課題][圏一般論][計算]同値コントラクション、要らないかも

近加法圏に対するMAT&lt;sup&gt;+&lt;/sup&gt;関手だが、レトラクション関手R:MAT&lt;sup&gt;+&lt;/sup&gt;(C)→C があれば、別に同値コントラクションという自然変換は要らないのかも（勘違いしてたっぽい）。

Cに対して、

- M ： MAT&lt;sup&gt;+&lt;/sup&gt;(C)
- M&lt;sub&gt;1&lt;/sub&gt; ： 1×1 行列の全体
- M&lt;sub&gt;d&lt;/sub&gt; ： 対角行列の全体
- M&lt;sub&gt;d2&lt;/sub&gt; ： 2×2対角行列の全体

とすると、Cは自明にM&lt;sub&gt;1&lt;/sub&gt;と同型、直積圏C×CはM&lt;sub&gt;d2&lt;/sub&gt;と同型になる。
RをM&lt;sub&gt;d2&lt;/sub&gt;に制限して R:M&lt;sub&gt;d2&lt;/sub&gt;→Cとすると、これはC×C→Cと見なせる。制限したRがC双関手であることを示せれば、RによりC上にモノイド構造（monoidal structure）が作れる。

このモノイド構造に関して、零対象、対角、余対角、双代数条件などを示して、双GSモノイダルであることを示せそうだ。あるいは、直接的に、&lt;em&gt;ランベック／スコットの意味での&lt;/em&gt;等式的デカルト構造、等式的余デカルト構造を作ってもいいかもしれない。

そのとき、レトラクション関手Rしか必要ないような気がする。Rは「零と足し算を保存する」という意味で近加法的だが、近加法的レトラクションF:D→Cがあり、Dに双積があれば、一般論として、Cにも双積がinduceできるのかもしれない。

だとすれば、M = MAT&lt;sup&gt;+&lt;/sup&gt;が半加法圏であることを示せば、レトラクトであるCも半加法的であることは自動的に出る。
&lt;hr&gt;
そういえば、次の条件のあいだの関係は？

+ 双代数条件 ∇;Δ  = □
+ 行列条件 [&amp;lt;f, g&gt;, &amp;lt;f', g'&gt;] = &amp;lt;[f, f'], [g, g']&gt;
+ 対角行列条件 [&amp;lt;f, 0&gt;, &amp;lt;0, g&gt;] = &amp;lt;[f, 0], [0, g]&gt;
+ 双積の直交性 ι;π = δ
+ 射のモノイド積条件 &amp;lt;π&lt;sup&gt;1&lt;/sup&gt;;f, π&lt;sup&gt;2&lt;/sup&gt;;g&gt; =  [f;ι&lt;sup&gt;1&lt;/sup&gt;, g;ι&lt;sup&gt;2&lt;/sup&gt;]

*1202284837*[TQFT][DFD][物理っぽい][用語法]ゲージ理論はじめるかも

とりあえず、例によって用語が気になる。

茂木／伊藤『微分幾何とゲージ理論』のまえがき(P.2)に翻訳表が載っているのが非常に助かる。

特に注意すべきは：

+ ゲージ群とゲージ変換群が違うものであること。
+ ゲージ場という用語が、ゲージポテンシャル（の場）と場の強さ（フィールド・ストレングス）のどっちか曖昧なこと。
+ 位相因子が接続の平行移動であることにはビックリ。

|* 物理              |*微分幾何|
|ゲージタイプ        |主ファイバーバンドル（主束）|
|ゲージ              |主束の局所自明化（主束座標）|
|ゲージ群            |主束の構造群|
|ゲージ変換（群）    |束自己同型写像、（束座標の）変換関数|
|ゲージポテンシャル  |主束の接続（係数）|
|フィールド・ストレングス|主束の曲率（形式）|
|波動関数、状態関数  |同伴ベクトル束の切断|
|位相因子            |平行移動|

ゲージ群＝構造群は、たとえばU(1), SO(3)などが考えられる。ゲージ群は行列群の部分群だと思ってよいことが多い。よって、ゲージは底空間の局所座標（の領域）と行列の直積と、主束のチャンク（π&lt;sup&gt;-1&lt;/sup&gt;(U)の形の部分空間）との対応を与える。

フィールド・ストレングスをゲージ場と呼ぶと、ゲージ場はゲージポテンシャルから微分操作で作られる。ゲージ場は、ゲージ（主束座標）の場ではない！ 曲率形式の場である。ゲージ変換は、主束の自己同型束の切断のことで、主束に作用し、無限次元リー群を構成する。ゲージ群は有限次元で、ゲージ変換群は無限次元。

ゲージポテンシャルは、無限次元リー群であるゲージ変換群の接空間となる無限次元リー代数（自己同型束の無限小版である随伴束）に値を持つ1-形式となる。フィールド・ストレングスは2-形式である。電磁気の場合、電磁ポテンシャルがゲージポテンシャル（1形式）、電磁場がフィールド・ストレングス（2形式）となる。たぶん。

*1202294966*[リンク]semi-additive category

表記のキーワードによる検索結果；arxiv.orgのみ。

前にも見たか印刷したか、今度こそ読もう。
- Title: Finite Products are Biproducts in a Compact Closed Category
- Author: Robin Houston
- URL: http://arxiv.org/abs/math/0604542
- 9ページ、印刷した。

けっこう役に立つかも。
- Title: Automorphisms of Categories of Free Modules, Free Semimodules, and Free Lie Modules
- Authors: Yefim Katsov, Ruvim Lipyanski, Boris Plotkin
- URL: http://arxiv.org/abs/math/0505151
- 25ページ

以下はアブラムスキー一派のアレ。

- Title: A Categorical Quantum Logic
- Authors: Samson Abramsky, Ross Duncan
- URL: http://arxiv.org/abs/quant-ph//0512114
- 23ページ

- Title: De-linearizing Linearity: Projective Quantum Axiomatics from Strong Compact Closure
- Author: Bob Coecke
- URL: http://arxiv.org/abs/quant-ph/0506134
- 22ページ

- Title: A categorical semantics of quantum protocols
- Authors: Samson Abramsky, Bob Coecke
- URL: http://arxiv.org/abs/quant-ph/0402130
- 21ページ

一部で有名なイシャム、面白そうだが、、、、
- Title: Some Reflections on the Status of Conventional Quantum Theory when Applied to Quantum Gravity
- Author: C.J. Isham
- URL: http://arxiv.org/abs/quant-ph/0206090
- 29ページ

以下の２つはなんか不思議な論文。哲学か？計算か？

- Title: Universal Dynamics, a Unified Theory of Complex Systems. Emergence, Life and Death
- Author: Gerhard Mack
- URL: http://arxiv.org/abs/hep-th/0011074
- 57ページ

- Title: Life in Silico - Simulation of Complex Systems by Enzymatic Computation
- Authors: Gerhard Mack, Jan Wuerthner
- URL: http://arxiv.org/abs/physics/0011020
- 35ページ


</body>
</day>
<day date="2008-02-07" title="">
<body>
*1202354276*[圏一般論][計算]双積、積、余積、加法

次のような関係がある。

- 双積⇒積 は当たり前
- 双積⇒余積 は当たり前
- 双積⇒加法
- 加法+積⇒双積
- 加法+余積⇒双積

次のような定義ができる。

- ∇&lt;sub&gt;A&lt;/sub&gt; := π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,A&lt;/sub&gt; + π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,A&lt;/sub&gt;
- ι&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt; := &amp;lt;1&lt;sub&gt;A&lt;/sub&gt;, 0&lt;sub&gt;A,A&lt;/sub&gt;&gt;

*1202355652*[圏一般論][用語法]プレ半加法圏、近半加法圏

加法圏の定義は確定している。これはよい。

プレ加法圏（http://en.wikipedia.org/wiki/Preadditive_category）とは、

- every hom-set Hom(A,B) in C has the structure of an abelian group, and composition of morphisms is bilinear over the integers.

ってこと。つまりAb-圏と同じ。

半加法圏を加法圏と類似に定義するなら、プレ半加法圏（pre-semiadditive category）はAbMon-圏てことになる。ただし、プレ加法圏もプレ半加法圏も零対象は仮定してない。

プレ半加法圏＋零対象を近加法圏と呼んだのだが、むしろ近半加法圏（nearly semiadditive category）だな。弱半加法圏（weak(ly) semiadditive category）もあるかな。

- pre-semiadditive → nearly semiadditive → semiadditive

*1202355931*[リンク][人物]ゲルハルト・マック

Gerhard Mack:

- Title: Universal Dynamics, a Unified Theory of Complex Systems. Emergence, Life and Death
- Author: Gerhard Mack
- URL: http://arxiv.org/abs/hep-th/0011074
- 57ページ

- Title: Life in Silico - Simulation of Complex Systems by Enzymatic Computation
- Authors: Gerhard Mack, Jan Wuerthner
- URL: http://arxiv.org/abs/physics/0011020
- 35ページ

- Title: Gauge theory of things alive and universal dynamics
- Author: Gerhard Mack
- URL: http://arxiv.org/abs/hep-lat/9411059
- 13ページ

- Title: Gauge Theory of Things Alive: Universal Dynamics as a Tool in Parallel Computing (1996)
- Author: Gerhard Mack
- URL: http://citeseer.ist.psu.edu/206331.html
- 12ページ

</body>
</day>
<day date="2008-02-08" title="">
<body>
*1202438332*[TQFT][DFD][物理っぽい][用語法]ゲージ理論と電磁気

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080206/1202284837&quot;&gt;「はじめるかも」&lt;/a&gt;に追加して、さらに注意：

+ 枠（標構）の場はゲージだと思ってもよい。
+ だが、ゲージ（枠）の場はゲージ場ではない。そんなふうに呼ばない！
+ ゲージ（枠）の場は単にゲージと呼ぶ。
+ ゲージ場は接続1-形式、または曲率2-形式のこと。
+ ゲージ場が接続か曲率かは文脈依存。
+ つまり、ゲージ場とは、&lt;em&gt;ゲージ理論に出てくる主要な場&lt;/em&gt;、って程度の意味。
+ ゲージ変換群（無限次元リー群）のリー代数（の元）もゲージ変換と呼ぶ。
+ ゲージ変換は、群の元（有限な変換）かリー代数のベクトル（無限小変換）かハッキリしない。曖昧、文脈依存。
+ ゲージ変換群のリー代数（接空間、無限小変換の空間）は、ゲージポテンシャル＝接続に作用するベクトル空間になっている。
+ ゲージポテンシャル＝接続の空間は、無限小ゲージ変換をベクトル空間とするアフィン空間。

電磁気学だとまた用語が少し違うような（よくわかってない、調べてない）：

|* 物理              |*微分幾何|* 電磁気 |
|ゲージ群            |主束の構造群|複素位相の変換群U(1)？ |
|ゲージ変換（群）    |束自己同型写像| 複素波動関数の位相変換関数？|
|ゲージポテンシャル  |接続 1-形式| 電磁ポテンシャル、ゲージ場|
|ゲージポテンシャルのゲージ変換 |接続の無限小変換|ゲージ変換 |
|フィールド・ストレングス|曲率 2-形式 | 電磁場テンソル、ファラデーテンソル|
|波動関数、状態関数  |同伴ベクトル束の切断|複素波動関数|

「ゲージ」「ゲージ場」は使わないほうがいいな。枠（標構）場、ゲージポテンシャル（＝接続）、ストレングス（＝曲率2-形式）と言えば混乱は比較的少ない。「ゲージ変換」の多義性は、どう区別するべきかよくわからん。

*1202442696*[小咄]分類タグ「小咄」を追加

今までも、[説明]、[メモ]、[具体例]なんてタグを使ってきたが、比較的予備知識が少なくとも理解できて、一般的にも楽しい・面白いトピックには[小咄]を付けることにした。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080119/1200730744&quot;&gt;「マスロフ算数」&lt;/a&gt;なんかが小咄の例かな。

</body>
</day>
<day date="2008-02-12" title="">
<body>
*1202786263*[メモ][物理っぽい]シンガー／ソープのベクトル解析へのコメント

シンガー／ソープ本（翻訳）のP.127に「ベクトル解析に関する余談」が載っている。数ページだが、さすがに示唆に富む。

*1202786305*[メモ][用語法]ホドグラフ変換＝球面写像＝ガウス写像

ホドグラフは運動学の言葉。幾何学では球面写像またはガウス写像。（シンガー／ソープ本を眺めていて。）

*1202786351*[物理っぽい][メモ][リンク][説明]ファイバーバンドルの図

- Title: 単粒子力学上級編
- Author: 平田光司
- URL: http://beam-physics.kek.jp/bpc/winter.pdf
- 21ページ、印刷した

ファイバーバンドルの説明図にビックリ（カルチャーショック）。なるほど。こんな考え方もあるのかぁーーーー。新鮮。

&lt;img src=&quot;http://www.chimaira.org/img2/bundle.gif&quot; &gt;

普通は、束座標系＝束局所自明化は重ねて取るが、これは重なりなしでキッチリ並べている。繋げるときは、重なり＝糊代で貼り合わせるのではなくて、共通の接合面（厚さ0の繋ぎ）でズラシをほどこす。このズラシが変換関数に対応するのだろう。

面白い。


</body>
</day>
<day date="2008-02-13" title="">
<body>
*1202878380*[メモ][お絵描き]多面体と曲率とか

なんだか自分でもよくわからんが、絵を描いた。

多面体のカドとか接合している線とかは、曲率が集中しちゃったところだよね。ってな感じのこと。適当になめらかにして曲率を定義できるし、逆にカドやらツナギやらで考えることもできる。っと。

&lt;img src=&quot;http://www.chimaira.org/img2/corner-curve.gif&quot; &gt;

*1202891760*[メモ][用語法]マックのSYSTEM

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080207/1202355931&quot;&gt;ゲルハルト・マック&lt;/a&gt;はSYSTEM（大文字）という言葉を使っているが、あまりにも一般的な言葉過ぎるよ。

うーん、「マック・システム」か？


</body>
</day>
<day date="2008-02-14" title="">
<body>
*1202979151*[小咄]クラトフスキー・グラフの非平面性

埋め込めたと仮定して、頂点、辺、面の関係がオイラーの公式と矛盾することを示す。（『幾何学的グラフ理論』P.29）

*1202979152*[小咄][メモ]ストークスの定理

アーノルドのバカ高い教科書（岩波翻訳本、持ってない）では、
- Newton-Leibniz-Gauss-Green-Ostrogradskii-Stokes-Poincare の定理
なんだとか。長！

</body>
</day>
<day date="2008-02-15" title="">
<body>
*1203053833*[用語法][物理っぽい]ゲージポテンシャルがポテンシャルなわけ

ゲージポテンシャルとは接続のことらしい。接続の空間はアフィン空間なので、原点を固定しないとベクトル表示（位置ベクトルの決定）はできない。差にはベクトル的意味があるが、値にはベクトル的意味がない。

アフィン空間の量をポテンシャルと呼ぶのは普通のことだから、接続をポテンシャルと呼ぶのは納得がいく。

*1203069540*[用語法][物理っぽい][説明]切断≒要素

数と関数、ベクトル空間とベクトル束、群と群束などをあまり区別する必要はない気がしてきた。

Mが底空間、Eが束（ファイバーバンドル）のとき、A∈Γ(E)のことを、A∈&lt;sub&gt;M&lt;/sub&gt;E とか、いっそ A∈E と書くと具合がいい。ただし、これはいくらなんでもマズイこともあるので、A∈:&lt;sub&gt;M&lt;/sub&gt;E 、 A∈:E と少し区別する。

また積束（自明束）のときは、束M×Fを単にFと書いてもいいだろう。すると、f∈:&lt;b&gt;R&lt;/b&gt; は、f∈C&lt;sup&gt;∞&lt;/sup&gt;(M) の意味になる。Tが接束なら、X∈:T はXが接ベクトル場の意味になる。

「∈」が意味する「要素」という概念は、切断によってだいたい実現されるだろう。例えば、（大域）切断が存在しない束は、点を持たない集合に当たる。ただし、点を持たないから空というわけではない！ 大域的「点」の存在に対する障害があるのかもしれない。

</body>
</day>
<day date="2008-02-16" title="">
<body>
*1203130144*[用語法][物理っぽい]位相って言葉

物理的な用語法に慣れようとしている。だけど、phaseの訳語が位相なのが困るなー。ほんとに紛らわしい。ナントカ位相と言われてもトポロジーの話なのかフェイズの話なのかサッパリわからん！

位相＝フェイズだとしても、フェイズの意味がわからんよ。だいたいは、状態（ステイト）と同じようなもんかな？ -- 系の全体的または局所的な状態を表現する空間を「位相の空間」と呼ぶらしい。もちろん、トポロジカル空間ではない。いやっ、位相（フェイズ）の空間に位相（トポロジー）が入っているかもしれないが、、、（はぁー、カンベンしてくれ）

ファイバー束でモデル化するなら、位相の空間とは、局所的な状態の意味ならファイバー、大局的な状態の意味なら全空間のことだろう。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080206/1202284837&quot;&gt;「はじめるかも」&lt;/a&gt;によると、波動関数が切断なのだから、切断の値（一点、または全体）は位相で、一点でのファイバーかファイバー全体が「位相の空間」だろう。（ツジツマはあっているのかも）

さて、「位相因子」が、なんで「平行移動」なのか考えてみる。位相＝ファイバーだとすると、異なる点での位相（ファイバーね）をつなぐのが平行移動。平行移動は、群による掛け算（無限小なら足し算）として作用する。掛け算、つまり乗法、乗法により作用するモノは因子と呼ぶ。だから、「位相（の空間に作用する）因子」とはファイバーへの群作用のことで、平行移動のことだよね、、、、くっ、苦しい！

*1203130506*[雑記][その他代数]4元数とクリフォード代数

4元数とかクリフォード代数とかにはまったく興味がなかったが、いくつかの理由で少し興味が湧いた。

+ コンピュータグラフィックスで4元数を使うらしい。
+ カウフマンが4元数の空間を扱っていた。
+ コンウェイが4元数の本を書いている。
+ マクスウェル方程式は、最初は4元数で書かれていたらしい。
+ 初期のベクトル解析も4元数を使っていたようだ。
+ スピン構造を定義するときにクリフォード代数を使うらしい。
+ クリフォード代数の幾何学的解釈は趣味的に面白いかも。

追記：「4元数」より「四元数」と書くべきらしい。

*1203131641*[メモ][説明][小咄][その他代数]違っている度合いと似ている度合い

超距離（普通の距離でもだが）って、だいたいは違っている度合い。距離と同伴する感じで似ている度合いを表す量が存在することもある。似ている度合いの例：

+ ハミング信号空間で、「違っている文字の数」；ハミング距離と同伴
+ 有理数と素数pで、「xに因子として含まれるpの個数」；p進ノルムと同伴
+ 有限記号の無限列の空間で、「最初の食い違いまでの長さ」；記号力学系の距離に同伴
+ 多項式で、次数；なんだか知らんがノルムがあると思う

*1203136721*[雑記][説明][物理っぽい][課題]接続のマクロな記述と圏論的解釈

接続＝平行移動を代数的に記述するなら共変微分作用素になる。Vがベクトル束、Tが接束のとき、∇:Γ(V)→Γ(V(×)T&lt;sup&gt;*&lt;/sup&gt;)で、次のライプニッツ法則を満たすものが共変微分。

-  ∇(Af) = (∇A)f + df・A

f∈:&lt;b&gt;R&lt;/b&gt;、X∈:V、・はテンソル積（かける順序は適当に調整）。

この定義は微分を使っているので、結局はミクロ構造を定義することになる。

そうじゃなくて、マクロな構造として記述するとどうなるか？ 考えてみた； まず、多様体Mの道の全体を圏と考えてM&lt;sup&gt;~&lt;/sup&gt;とする。Ob(M&lt;sup&gt;~&lt;/sup&gt;) = Mで、M&lt;sup&gt;~&lt;/sup&gt;(p, q) = {pからqに至る道} となる。道は、実数区間[0, a]でパラメータ付けされているとして、正数aを道の長さと呼び、|γ| = (道γの長さ) とする。雰囲気としては、接束Tの元が生成グラフで、道の圏は自由生成された圏Cat(T)みたいなもの。

道の圏M&lt;sup&gt;~&lt;/sup&gt;から、ベクトル空間Vectへの関手を接続（または平行移動）と呼ぶ。道γに対して逆行する道をγ&lt;sup&gt;*&lt;/sup&gt;とする。逆行は一種のスター作用素なので、M&lt;sup&gt;~&lt;/sup&gt;はある主の双対構造（共役構造）を持つ。このスター作用素も考慮に入れて接続Fを定義すると：

+ F(γ;δ) = F(γ);F(δ)
+ F(id&lt;sub&gt;p&lt;/sub&gt;) = id&lt;sub&gt;F(p)&lt;/sub&gt;
+ F(γ&lt;sup&gt;*&lt;/sup&gt;) = F(γ)&lt;sup&gt;-1&lt;/sup&gt;

3番目の条件から、接続は線形同型の圏に値を取る。よって、Vectの代わりに亜群Iso(Vect)を値としてもよい。（M&lt;sup&gt;~&lt;/sup&gt;は亜群ではない。）

接続は関手なので、自然変換により「接続の射」を定義する。と、M上の接続の全体Conn(M)は関手圏として圏となる。接続の同型は、この圏での同型（関手の自然同値）で定義する。値がVectなので、双対、直和、テンソル積も定義できて、線形代数ができる。

Conn(1点)はVectのことで、Conn(M)もVectとほとんど同じ。内部ホムも定義できる。全体として見れば、可換環Γ(&lt;b&gt;R&lt;/b&gt;)上の加群の圏に埋め込める。

接続Fが、任意のp∈Mに対してF(p) = V ならば、V-単純接続と呼ぶ。このときは、道はすべてIso(V, V) = Auto(V) に写る。 V-単純接続が積束M×V上の接続に対応する。すべての道がid&lt;sub&gt;V&lt;/sub&gt;に写る自明な接続が自明束（の標準的接続）に対応する。

こうやって、道と関手を使って定義した接続から、最初の微分作用素が出せるか？

&lt;hr&gt;
言い忘れた：道の長さ|γ|は、圏M&lt;sup&gt;~&lt;/sup&gt;から、非負実数の足し算の圏への関手になる。あと、ループの集合M&lt;sup&gt;~&lt;/sup&gt;(p, p)からAuto(F(p))への写像は、ホロノミーを定義する。

*1203146542*[雑記][物理っぽい]接続と局所自明化

接続をマクロに書いてみると、束の局所自明化がどんなことか少し理解できる。

どんな接続でも、局所的には単純接続＝積束上の接続として書ける必要がある。そうでないと関数概念で記述できないからね。積束上の接続は、適当なゲージ変換で自明接続に直せる。

接続＝平行移動は、「変化しない」「静止している」などを規定するものだから、局所的に「変化しない」ことが自明接続で記述できることを要求する。これは、局所慣性系とか静止系とかの要請と同じだろう。つまり、「変化しないこと＝定数＝微分してゼロ」と考えていいわけだ、あくまでも局所的には。

ただし、「変化しない」とか「静止」とかは相対的な概念だから、他の系を「静止しない」とみなせば、別な系は「動いている」と見える。それが、接続が相対的にしか定義でいない理由。「標準的な接続＝標準的な静止系」は取れない！ 接続の差だけがベクトル量として意味があるのはそういう事情だろう。

「接続＝平行移動＝不変性＝静止性＝定数性」は相対的概念だが、「変化の変化＝曲率＝加速度＝力」は接続によらずに定義できる。この「曲率＝力」がエネルギー概念につながるのだと思う。力から計算される総エネルギー（積分値）が最小にする変分問題の解が例えば古典軌道を与える。

*1203146543*[雑記][物理っぽい]ゲージ理論としての解析力学

少しだけわかった気分。

配位空間の接束である相空間を、基本の空間Mとする。この相空間Mの勝手な運動が配位空間の運動に対応はしないが、そのへんはどうでもいいとする。M上にアフィン直線束を考えて、これの切断がスカラーポテンシャルだと思う。1次元アフィン変換で向きを変えないものを考える。この変換群から平行移動（原点のシフト）を除いたものは正実数の掛け算の群になる。そのリー環は実数直線。

この束の構造群＝ゲージ群は正実数、よって接続は実数値関数で与えられる。この接続関数がたぶんラグランジュ関数。ラグランジュ関数の積分である作用＝作用積分＝ハミルトン積分は、expに入れるとゲージ群の元となるから、接続による有限変換（無限小ではない変換）となる。この有限変換は、ラグランジュ関数の指数関数の積積分と一致する。

作用αが正で最小なら、exp(α)は1に近くなる。exp(α)による変化ができるだけ小さいように道を選ぶと、それが古典軌道。

おそらく一般には、ゲージ群のリー環の空間にうまいノルムが入って、そのノルムの積分が小さくなる道を選ぶことが問題となるのだろう。運動の代わりに写像を考えても同じ。

*1203150852*[用語法][物理っぽい]ゲージ群って言葉

あー、やっぱり。ゲージ群とゲージ変換群を区別してない用例発見。

ゲージ群は束の構造群であり、リー群として前もって定まる抽象群（必ずしも作用じゃなくてもいい）。それに対して、ゲージ変換は与えられた束の自己同型束＝ファイバーごとのファイバー自己同型群をたばねた束の切断。これは束への作用。

局所自明化を使うと、自己同型束は積束の自己同型束だから群の積束となり、定義より U×G→U×Auto(F) という束の射が存在する。これにより、U×Gの切断はU×Fに作用し、結果的に元の束にも局所的に作用する。

局所自明化を固定すれば、U×Gの切断は関数U→Gなので、「ゲージ群への関数＝ゲージ変換」となる。関数と値を区別しない流儀だと、「ゲージ群＝ゲージ変換群」となるが、区別すべきだと思う。

ゲージ群は、座標系＝局所自明化を経由して使うのに対して、ゲージ変換群（束の圏の自己同型対象）は束だけで定義可能だ。抽象群としてのゲージ群が、ゲージ変換群により表現される感じ。ただし、大域的には表現できない（作用できない）ので、局所表現の寄せ集め（貼り合わせ）が表現の代わりとなる。


</body>
</day>
<day date="2008-02-18" title="">
<body>
*1203296125*[雑記][メモ][山勘]チェック・コホモロジー

必ずしも可換ではない群Gに値を取るチェック・コホモロジーって、接続を離散近似していることになるんじゃなかろうか。被覆を頂点集合と考えた双方向有向グラフ（可逆箙か？）を考えて、そこに接続を入れれば、それってチェック・コホモロジーのような？

ただし、グラフ上の接続が値をとる圏は自明な束の圏だが。


</body>
</day>
<day date="2008-02-19" title="">
<body>
*1203396430*[気付いた]接アフィン空間

また新しい分類タグ。ふと気付いたことをメモする「気付いた」。

接空間をベクトル空間じゃなくてアフィン空間にしたらどうだろう？ 普通、接空間は原点が自然に決まるが、あえて決めない。すると、「ここ」という概念がなくなる。近似的に平らな空間に&lt;em&gt;いる&lt;/em&gt;のだが、どこも一様で、別にもとの空間との接点が定まるわけでもない。

アフィン空間のバンドルのほうが実は面白いような気がする。移動ベクトルの加群（作用としてのベクトル空間）が作用する主バンドルになるし。

*1203397337*[気付いた][物理っぽい]加速度

平行移動＝接続は、「静止」「変化しない」などを表現する手段だが、かといって、すべての接続が静止しているわけではない。どんな滅茶苦茶な接続でも定義はできる。接続が静止性／不変性を表現しているのは曲率がないときだけど、曲率＝強さ＝力だった。

ところで、接続の曲率は、その接続による平行移動に&lt;em&gt;乗って動く&lt;/em&gt;ときに加わる加速度のようなもの。となると、曲率＝加速度＝力となり。結局はニュートンの主張：「力とは加速度を引き起こすもの」が再現。

枠（標構、矢倉）の運動は、枠に作用する群の1パラメータ系で表現できるが、その1パラメータ系の無限小はリー環に入る。運動は運動を支配する群の元だから、運動の一瞬の変動は、そのリー環＝接空間の元。

</body>
</day>
<day date="2008-02-20" title="">
<body>
*1203481618*[気付いた][具体例][プログラム意味論][説明]簡単で有用な半加法圏の実例(Rel, 0, +)

ウーン、なんで気付かなかったんだろう！ アホッ＞俺

いやっ、まー、知ってはいたのだけど、あんまり注目してなかった。

Setと同じ対象を持ち、射は関係である圏Rel。集合直和をモノイド積としてモノイド圏、空集合が単位で、ホムセット内に合併演算で和が入るので近半加法圏（nearly semiadditive）。近半可能圏に直和（余直積）があればそれは双積だから、半加法圏（semiadditive）。

特に単元集合だけで双デカルト的に生成される半加法圏は、ブール係数行列の圏。

さらに直積に関しては、ダガーを（関係または行列の）転置で定義すると、このダガーを双対スター作用素とみなして、コンパクト閉圏。Rel(A×B, C)＝Rel(A, C×B*)（B* = B）。

ケリー双対η、εは次のように与えられる。

- η = {(*, (a, b))∈1×(A×A) | a = b} : 1→A×A
- ε = {(&amp;#40;a, b), *)∈(A×A)×1 | a = b} : A×A→1

集合直和が双積、集合直積がテンソル積として、双積を持つダガー・コンパクト閉圏になる。さらに、半環圏（semiringal category / semiring category）。コンパクト閉性からの標準トレース以外に、双積に関するトレースも持つので、双トレース付き圏とでも呼ぶべき構造も持っている。

有限次元複素ヒルベルト空間FdHilbとものすごく似ている。半環構造を利用して多項式関手、Fock空間構成なんてのができると思う。

双積（直和）に関してInt構成ができるが、できあがる双コンパクト閉圏は何なのだろう。環圏（ringal/ring category）になると思うが。

*1203485134*[課題]Fock空間構成

そういえば、Fock空間構成って結局わかんないままだった。

*1203486857*[説明][お絵描き][DFD]ゲージ場の例と印象の図

2次元格子上に、ファイバーがS&lt;sup&gt;1&lt;/sup&gt;、構造群がU(1)のバンドル。

&lt;img src=&quot;http://www.chimaira.org/img2/tokei-lattice.gif&quot;&gt;

*1203493361*[課題]Rel -- このよく整った圏を…

+ 半加法圏である。これは双デカルト性と同じ。
+ （半体上の半環）上の両側半加群の圏である。
+ 加法的トレースを持つ
+ コンパクト閉である。（従って乗法的トレースを持つ）
+ 半環の構造を持つ（たぶん）

行列テンソル計算と、単体複体による図示。

</body>
</day>
<day date="2008-02-21" title="">
<body>
*1203567363*[お絵描き][具体例][説明][DFD][セミナー]圏FinRelが面白い

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080220/1203481618&quot;&gt;FdHilbとRelが似てること&lt;/a&gt;は、ボブ・クックが「物理系実務者…」のなかで指摘している。と、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070405/1175748511&quot;&gt;自分で書いているよ&lt;/a&gt;(苦笑)。実際、クック論文「4.Quantum?」のところ（P.4からP.6）に記述がある。

特に、対象を有限集合だけに制限したRel＝FinRelは手で簡単に触れる。むずかしいことはやっぱり分からんから、こういう簡単な例をいじることにしよう。で、絵を描いた。絵の下に、思い付きをゴタゴタダラダラ書く。

&lt;img src=&quot;http://www.chimaira.org/img2/rel-cat-adjoint.gif&quot; &gt;
&lt;hr&gt;
まず、直積をモノイド積としてRel（もちろんFinRelも）はコンパクト閉圏なのだが、A&lt;sup&gt;*&lt;/sup&gt; = A というところが特徴的。双対化スターが恒等に退化している。この状況は、内積があれば双対空間が要らなくなるのと似てる。

随伴は、Rel(A×B, C) ≒ Rel(A, B×C)で与えられる。(-)×X の随伴が X×(-) となる。積（掛け算関手）と指数（ベキ関手）が一致してしまう。という状況を効果的に描くために考えたこと；（以下）

圏論とはまったく離れて、古典的／集合ベースの関係を考える。単項、二項、三項の関係の全体を Rel(A), Rel(A, B), Rel(A, B, C)のように書く。r∈Rel(A, B, C) ⇔ r⊆A×B×C のように考える。rの要素を関係要素と呼ぶことにする。

便宜上、無項関係 Rle() = {0} と約束する。無項関係が１つだけ&lt;em&gt;存在する&lt;/em&gt;ことに注意。定義から、Rel(A) = Pow(A) となる。また、Pow(A) = Rel(A, 1) = Rel(1, A)なども（同型の意味で）成立する。

上の絵で言いたいことは、関係要素がどう図示されるか。まず、r∈Rel(A, B, C)なら、rに含まれる関係要素(a, b, c)はA×B×Cの&lt;em&gt;点&lt;/em&gt;となる。が、二項関係を二部グラフで描くことにすると、A×B→C、A→B×C の辺となる。さらに、直和 A + B + C の上で関係要素を表現すると三角形になる。まとめると：

|* 外の空間 |* 関係要素 |
|A×B×C    | 点（0-単体） |
|A×B + C   | 辺（1-単体） |
|A + B + C  | 三角形（2-単体）|

これから、次の3者が対応する。

+ A×B×C 内の点の集まり＝部分集合
+ A×B + C 内の辺の集まり＝二部グラフ
+ A + B + C 内の三角形群

他にも面白いことがあるが別エントリーにする。

*1203569630*[説明][DFD][具体例]圏FdHilbと圏Relの比較

|* FdHilb   |* Rel |
| 零空間    | 空集合 |
|&lt;b&gt;C&lt;/b&gt;   | &lt;b&gt;B&lt;/b&gt;（真偽値）|
|&lt;b&gt;C&lt;/b&gt;&lt;sup&gt;n&lt;/sup&gt; | &lt;b&gt;n&lt;/b&gt; = {1, 2, ...,n} | 
|ベクトル   | 1変数述語（性質） |
|行列       |関係 |
|直和       |直和（集合論的） |
|テンソル積  |直積（集合論的） |
|内積      | 共通部分があるか |
|直交      |無共分|
|変換      |自己関係 |
|射影変換  | 推移的関係 |
|変換の指数 | 反射的推移的閉包 |
|固有空間 | 関係で閉じた部分集合 |
|固有ベクトル | 不動点 |
|複素共役     | - |
|転置     | 転置 |
|随伴     | 転置 |
|部分空間族 |部分集合族|
|1次元部分空間 | 単元集合 |
|生成的部分空間族 | 被覆 |
|基底的部分空間族 | 分割 |

</body>
</day>
<day date="2008-02-22" title="">
<body>
*1203663269*[気付いた][物理っぽい][プログラム意味論]なんでテンソル積か？ どうも勘違いしていた！

物理で、2粒子A, Bがあるとき、Aの状態空間（ヒルベルト空間）とBの状態空間のテンソル積をとるのはなんでだろう？ 直和じゃなんでダメ？ とずっと思っていたが、これは、「物理的時空 ⇔ 遷移系の状態空間」という対応で考えるからで、&lt;em&gt;この対応がそもそもオカシイ&lt;/em&gt;、と気付いた。

状態遷移系だと、選択的な遷移は直和で、同時並列実行だと直積（テンソル積）。同時並列の和（むしろ積）のときは、メモリ領域は確かに直和になっている。つうことは、次のような対応なんだろう。

|* 物理             |* 計算 |
| 空間自由度の空間 | メモリ領域 |
| 状態（波動関数） | メモリの状態（付値） |
| 空間の直和 | メモリ領域の直和 |
| 状態のテンソル積 | 状態空間の直積 |

となると、場の量子論と直接対応が取れるのはライフゲームとかセルオートマトン、箱玉系とかだな。普通の計算機ハードとか、高級言語の計算モデルだと、格納領域のトポロジーが問題になることは少ないから（それに、メモリの変化に局所法則がまったくないから）、最初から状態空間のほうが出てきたしまうわけか。

いずれにしても、物理と遷移系の&lt;em&gt;状態概念にズレがある&lt;/em&gt;のは確からしい。空間的空間（spacial space）の直和とメモリ領域の直和を対応させるか、それとも状態空間の直和を対応させるかで事情は異なる。また、遷移系では状態空間上での波動（伝搬現象）が意味を持つが、物理的状態空間（ヒルベルト空間）上で伝搬現象を考えると何になるかサッパリわからん。相互作用するものすごくたくさん、しかし同種の場を同時に考えることか？

遷移系では、状態空間の直和は選択的遷移として意味を持つが、物理的な状態空間の直和のほうは、確率の議論に吸収されてしまっているのかも知れない。離散力学では、確率じゃなくて可能性（あり得るかどうか possibility）を問題にするから、ここもズレの原因かもしれない。

*1203663990*[気付いた][プログラム意味論][山勘] 時間＝粒子＝CPU

かな？

- cf. [http://d.hatena.ne.jp/m-hiyama-memo/20071215/1197688692:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20071206/1196930700:title]


</body>
</day>
<day date="2008-02-23" title="">
<body>
*1203733311*[プログラム意味論][DFD]Fock空間構成のヒント

次のようなことを考えていた：

J = {xは実数 | 0≦x≦1} 、Jは長さ1で両端を含む線分。

- e&lt;sup&gt;J&lt;/sup&gt; = Δ&lt;sub&gt;0&lt;/sub&gt; + Δ&lt;sub&gt;1&lt;/sub&gt; + Δ&lt;sub&gt;2&lt;/sub&gt; + Δ&lt;sub&gt;3&lt;/sub&gt; + …

ここで、Δ&lt;sub&gt;0&lt;/sub&gt;は1点、Δ&lt;sub&gt;1&lt;/sub&gt;は線分（Jと同じ）、Δ&lt;sub&gt;2&lt;/sub&gt;は三角形、Δ&lt;sub&gt;3&lt;/sub&gt;は四面体。その後に続くΔ&lt;sub&gt;4&lt;/sub&gt;、Δ&lt;sub&gt;5&lt;/sub&gt;などは高次元の単体。

このこと自体は、別にオモシロ・クレイジー計算に過ぎない。しかし、Fock空間構成にヒントを与える気もする。

ベースを“関係＝遷移の圏Rel”とする。A={A[1], ..., A[n]} は、集合（Relの対象）の長さnの配列だとする。A(×)A を、[n]×[n] = {1, ...n}×{1, ...n} = {(1, 1), ..., (n, n)}という格子集合をインデックスとする族

- (A(×)A)[i, j] = A[i]×A[j]

として定義できる。同様に、A(×)A(×)A = A&lt;sup&gt;(×)3&lt;/sup&gt; は3次元格子をインデックスとする族として定義できる。これを一種のテンソル積、テンソルベキと考える。

クリーネ級数

- I + A + A(×)A + ... + A&lt;sup&gt;(×)n&lt;/sup&gt; + ...

を考えることができる。これをK(A) = K({A[1], ..., A[n]})とする。f:A[i]→B[j] を行列（イイカゲンな記法を使った）とすると、fの拡張としてK(f)が定義できるだろう。

このKがFock空間の原型になると思われる。が、イマイチ曖昧なので、&lt;em&gt;テンソルグラフの圏&lt;/em&gt;と、&lt;em&gt;形式テンソル形成関手（formal-tensor-forming functor）TENS&lt;/em&gt;について考えないといけない。

以前、XMLの連載記事で、多項式or級数 a&lt;sub&gt;0&lt;/sub&gt; + a&lt;sub&gt;1&lt;/sub&gt;X + a&lt;sub&gt;2&lt;/sub&gt;X&lt;sup&gt;2&lt;/sup&gt; + ... とか、その多変数版に触れたことがあるが、これへ係数達a&lt;sub&gt;i&lt;/sub&gt;で決まる形式級数となる。係数とは、プレイスホルダーを持つデータ構造＝テンプレート・データとなる。

つまり、テンプレート・データを係数とする多変数の形式級数の代数計算（クレイジー計算）によって関手の計算ができるってことだと思う。この計算をうまく行う舞台は、ω-semiadditive、またはω-summableな圏だろう。特殊ケースとして、ω-summableな半環の議論がある。

まーとにかく、Fock空間構成を含む形式級数で定義される関手（解析関手？）を定義する手段を準備することだな。

*1203745151*[プログラム意味論]時間、同期、直積

2つの状態空間S, T上を走る2つの軌道があるとき、それを直積S×T上の単一の軌道だとみなすには、2つの軌道を描くプロセッサの時間が同期してないといけない。これは、2つの時間区間をI, Jとすると、IとJの同型が前もって指定されているか、I→T, J→Tという2つの同型を通して、共通時間Tが使えるって前提。

もし2つの時間区間に同型がなければ、時間の空間の形状は I+Jだから、I+J→I+Jだけで、直積は出てこない。直積は、「異なる空間でも同じ時間が流れている」という状況でしか使えない。

別な言い方をすると、直積を作っていいのは、同じ時間を共有している2つの空間だけ、となる。では、１つの空間は1つの時間を所有するのだろうか？ そうとも言い切れない。仮に1つの時間を持つ空間を考えても、直和をとればすぐに仮定が壊れる。

2つのオートマトンが通信するには、アルファベットの一部に通信語がなくてはならない。A, Bが2つのアルファベットとして、通信語は、単射スパン A←C→B で指定されるだろう。例えば C = {*}として、*|→sendIt∈A、*|→receiveIt∈B とすると、sendItの実行がreceiveItの実行と同期して、結果的に通信ができる。

すると、語＝遷移は、内部遷移、通信入力語、通信出力語にわけて考えるといいのかもしれない。こうすると、通信語だけが同期して、内部遷移は非同期となる。通信語を別に考える方式と無音記号を考える方式は、同値な気がする、いやっ、微妙に違うか？

*1203745462*[プログラム意味論][復習][課題]プログラミング言語の定式化

- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180759386:title]

これを詳細かつ具合的に！

*1203749152*[雑感]息が苦しい感じ

考えるのは、マスクもシュノーケルもなしの潜水と似ている。


</body>
</day>
<day date="2008-02-25" title="">
<body>
*1203933535*[プログラム意味論][課題][気付いた]同期通信による結合

以前からなんか釈然としないことがあった。

僕は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070122/1169453774&quot;&gt;双ラベル付き関係／遷移系&lt;/a&gt;（bilabelled relation/transition system）で、入出力を持つシステムをモデル化しようとしていた。2つのラベル集合A, Bに対して、f:A→B というプロファイルの射を考える。が、なーーんかこれが&lt;em&gt;うまくない&lt;/em&gt;。

Lをラベルの集合として、単射の余スパン A→L←B を考えて、普通のLラベル付き遷移系を考える。これを f:A→B と考える。こう考えると、Lの不定性、状態空間の不定性から、Hom(A, B)が巨大な圏になってしまう問題があるのだが、より自然なモデル化ができると思う。

f:A→B, g:B→C の結合は、L←B→M というスパンにより貼り合わせたラベルがf;gのラベル集合となる。何度も出会っている構成法だから違和感はない。セリンガーが使っていたin/outの方法とも整合しそうだし。

あと、同期／非同期を空間化する「時間の空間」概念をもっとはっきりさせる必要がある。

</body>
</day>
<day date="2008-02-26" title="">
<body>
*1204005710*[プログラム意味論]時間の空間 再々論

- [http://d.hatena.ne.jp/m-hiyama-memo/20061207/1165485058:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20071206/1196930700:title]

基本的な連続時間は、境界があってもなくてもよい1次元の多様体の形をしている。基本的な離散時間は、たかだか可算個の頂点と、頂点を結ぶ辺からなるグラフだが、すべての頂点でin-degree, out-degreeが1以下、そして連結。基本的な時間の直和とファイバー和（スパンによる貼り合わせ）からできるものはまた時間。

片側線型な離散時間をTとする。Tの頂点は0, 1, 2, ...。Gをグラフとして、G×Tに、2複体の構造を入れたものが古典時空。同期しながら動く2点の軌道は、{・←→・｝という図形とTの直積をとり（2複体）、それから古典時空への写像。

{・←→・｝内の同期弧（両方向辺）は、G×T内のG×{k}の内部に入らないといけない。その意味で、同期する2点が許される配位を記述する辺をG内に付け加えた方がいいだろう。空間配位の許容範囲を記述する辺。

一般に、時間の空間には、時間発展を記述する辺と、同期を記述する辺がありそうだ。また、状態空間側には時間発展の可換性を記述する面もありそうだ。可換であることを補修する面がなければ、一般には異なる状態点に到着する。

同期弧を時間方向にも伸びてもいいとすると、また別な定式になるかもしれない。ε遷移や無音記号も何か別の面白い解釈ができないか？

*1204025662*[プログラム意味論]ラベル付き遷移系：3つのモノイド演算

ラベル付き遷移系αをラベル集合AからRel(X, Y)への写像として定義する。X = Y でないと、a, b∈Aに対するa;bは意味がない。しかし、a | b または a + b は意味がある。Aを指標とみると、ラベル付き遷移系とは、指標AのRelにおけるモデルである。

α:A→Rel(X, Y)、β:B→Rel(V, W)に対して、α+β:A+B→Rel(X+V, Y+W)とα×β:A×B→Rel(X×V, Y×W)は自然に定義でき、（分岐ではない）選択的実行と同時実行のモデルとなる。

A←K→B という単射スパンがあると、このスパンによりα*βという第三の積を定義できる。AへのKの埋め込み像をL、BへのKの埋め込み像をMとして、L→Mの同型をφとする。このとき、A×Bの部分集合 A*B = A*&lt;sub&gt;L,M&lt;/sub&gt;B を次のように定義する。

- (a, b)∈A*B ⇔ a∈Lならばb = φ(a)、b∈Mならばa=φ&lt;sup&gt;-1&lt;/sup&gt;(b)

要するに、L×Mの部分はKと同一視され潰れる。aとφ(a)は同時アトミックに働くとみなされる。この演算A*Bを使い、他はα×βと同じに作ったラベル付き遷移系をα*βと書く。

α*βは、H→A←K のようなラベルの余スパンを伴うラベル付き遷移の圏における結合を与える。もちろん、Relの結合に対応する結合も定義できる。

</body>
</day>
<day date="2008-02-27" title="">
<body>
*1204097273*[プログラム意味論][インスティチューション][復習]確認しよう、指標とモデル

- [http://d.hatena.ne.jp/m-hiyama-memo/20070605/1181014022:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070606/1181111463:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180759386:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180760920:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180763246:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070531/1180594965:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070525/1180066244:title]

インスティチューションの枠内で、具体的な指標から具体的にモデルを作る話。

+ 指標はグラフ、またはプレ圏。
+ グラフから自由生成された圏（道の圏）の合同がセオリーになる。
+ 指標が前もってプレ圏（圏でもよい）なら、セオリーは一般化合同。
+ グラフに境界概念を入れると、隠蔽ソート＝内部ノードができる。
+ 指標の圏には、直和、直積、境界でのグルーイングが入る。
+ グラフのファイバー和（貼り合わせ）が必要。上江州アタッチメントも貼り合わせ。
+ 指標の圏に、構文生成モナドが働いている。
+ 指標の圏をKleisli拡張できる。
+ モデルの圏は関手圏である。モデル射は自然変換。
+ 圏Cごとに、C-モデルが考えられる。ただし、Cは指標圏のセオリーと整合するとき。
+ モデルを作るとき値となる圏Cをアンビアント圏（または背景圏）と呼ぶ。
+ 指標Σから自由生成した圏Σ&lt;sup&gt;~&lt;/sup&gt;をセオリー（一般化合同）で割った圏は、アンビアント圏と同じ種類の圏である。

圏的セオリー（categorical theory）とは、一般化合同のことだとすると、セオリーのモデルは、商圏からの関手となる。モデルの全体は圏の圏であり、セオリーのモデル圏と呼ぶべきものとなる。「デカルト圏のセオリー」「双デカルト圏のセオリー」「CCCのセオリー」「コンパクト閉圏のセオリー」などが考えられる。


</body>
</day>
<day date="2008-02-28" title="">
<body>
*1204158123*[プログラム意味論][圏一般論][用語法]セオリーのレルム

圏的セオリー（指標＋一般化合同）を考えると、そのセオリーのモデルとなる圏の圏ができる。多くの圏の圏がこうして出現する。で、「圏の圏」と書くとtypoと勘違いされるし、セオリーで定義された圏の圏を的確に表現する言葉はないものか、と。

で、パラダイムって言葉はどうか、とも思ったが大袈裟すぎ。dominionかrealmだろう。どっちでもいいけど、realmは技術用語での実績があるようだから、レルムを使うことにする。

圏的セオリーでは（他のセオリーでもそうだが）、構文的に定義された圏がレルムに入る。つまり、構文論だけでもモデル論が可能になる。実はこの構文的モデルが、唯一具体的に作れて詳しくいじれるモデルだから、構文的モデルの分析が「セオリーの理論」の中核だろう。

それにしても、「セオリーの理論」つうのが用語的にまたアレだよなー。

*1204166502*[課題][復習]相対指標

- [http://d.hatena.ne.jp/m-hiyama-memo/20070524/1179986676:title]

と、そこからリンクされているエントリーもよく読め。

*1204168055*[プログラム意味論][形式言語理論][インスティチューション][具体例]形式言語系の例

- [http://d.hatena.ne.jp/m-hiyama-memo/20080107/1199699078:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180759386:title]

この話。

ラベル付き遷移系と多項式の例を出す。（多項式インスティチューションについては、[http://d.hatena.ne.jp/m-hiyama-memo/20060304/1141455936:title]参照。）まず全体的な対応。

|*形式言語系 |*ラベル付き遷移系 |* 多項式 |
| 指標Σ     | ラベル集合Σ     | 変数集合x ={x1, ..., xn}（無限でもいい） |
| 指標の射   | ラベル集合間の写像  | 変数集合間の写像 |
| Mod[Σ]    | Σラベル付き遷移系 | X上のK付値=レコード=点 |
| 構文モナドT | クリーネスター | 多項式生成関手 |
| Kleisli射 | ラベルのマクロ定義 | 多項式による変数変換 |
| モデルの自然拡張 | Σ&lt;sup&gt;*&lt;/sup&gt;への拡張 | 多項式上の付値 |

以前に出した&lt;a href=&quot;[http://d.hatena.ne.jp/m-hiyama-memo/20060304/1141455936:title]&quot;&gt;多項式インスティチューション&lt;/a&gt;では指標の圏を制限していたが、あまり気にしなくていい。

重要なのはモデルの自然拡張なので、そこを中心に以下にメモ。

&lt;h5&gt;ラベル付き遷移系の場合&lt;/h5&gt;

ラベル集合Σに対して、モデルのアンビアント圏は集合と部分写像の圏だとする。部分写像の圏のt:Σ×S→Sが遷移系を定義する。f:S→SがΣ作用を保つとき、ラベル付き遷移系の射として、ラベル付き遷移系の圏TS(Σ)を定義する。tからt':Σ&lt;sup&gt;*&lt;/sup&gt;×S→Sは自明に定義できる。この拡張を関手と考えて、ξ&lt;sub&gt;Σ&lt;/sub&gt;:TS(Σ)→TS(Σ&lt;sup&gt;*&lt;/sup&gt;)とする。

TS(Σ)の形の圏の全体が&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080228/1204158123&quot;&gt;レルム&lt;/a&gt;&lt;b&gt;TS&lt;/b&gt;になっている。

ξ&lt;sub&gt;Σ&lt;/sub&gt;のΣを動かすと、指標の圏（この場合は&lt;b&gt;Set&lt;/b&gt;）からレルムTSへの関手の自然変換になる。つまり、Nat(TS(-), TS(-&lt;sup&gt;*&lt;/sup&gt;):&lt;b&gt;Set&lt;/b&gt;→&lt;b&gt;TS&lt;/b&gt;)。&lt;b&gt;TS&lt;/b&gt;は遷移系の圏の圏。

&lt;pre&gt;
φ:Δ→Σ
以下が可換：
 TS(Σ)-(ξ&lt;sub&gt;Σ&lt;/sub&gt;)→TS(Σ&lt;sup&gt;*&lt;/sup&gt;)
 ↓TS(φ)      ↓TS(φ&lt;sup&gt;*&lt;/sup&gt;)
 TS(Δ)-(ξ&lt;sub&gt;Δ&lt;/sub&gt;)→TS(Δ&lt;sup&gt;*&lt;/sup&gt;)
&lt;/pre&gt;

&lt;h5&gt;多項式の場合&lt;/h5&gt;

体Kは固定する。変数の集合Xに対して、Mod[X]（単なる集合）は、X上で定義されたK値関数。X上のK値関数をK付値((全然別な意味の「付値」もあるが。))と呼んで、Val(X)と書くことにする。もちろん、Val(X) = Mod[X]。

P(X)を多項式集合とする。付値v∈Val(X)に対して、付値v':P(X)→K も代入計算として自然に定義できる。これにより、ξ&lt;sub&gt;X&lt;/sub&gt;:Val(X)→Val(P(X))を定義する。

&lt;pre&gt;
φ:Y→X
以下が可換：
 Val(X)-(ξ&lt;sub&gt;X&lt;/sub&gt;)→Val(P(X))
 ↓Val(φ)     ↓Val(P(φ))
 Val(Y)-(ξ&lt;sub&gt;Y&lt;/sub&gt;)→Val(P(Y))
&lt;/pre&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060307/1141721346&quot;&gt;命題論理の簡易インスティチューション&lt;/a&gt;の場合も多項式と同じだろう。

</body>
</day>
<day date="2008-02-29" title="">
<body>
*1204256899*[プログラム意味論]セリンガーのラベル付き遷移系

彼はラベルをアクションとも呼んでいる。アクションの全体は、B + {τ} + in(X) + out(Y) となる。Bを固有アクションと呼ぼう（これは by檜山）。セリンガーの用語では：

- B + {τ} を内部アクション
- in(X) を入力アクション
- out(Y) を出力アクション

X→&lt;sub&gt;B&lt;/sub&gt;Y という書き方もしている。すべてのアクションをAとして、inとoutを埋め込みだと解釈すると、X→A←Y となっている。A＼(in(X) + out(Y) + {τ}) = B となる。

X→&lt;sub&gt;B&lt;/sub&gt;Y, Y→&lt;sub&gt;C&lt;/sub&gt;Z に対して、X→&lt;sub&gt;B+C&lt;/sub&gt;Zが定義できるが、セリンガーは、X→&lt;sub&gt;B&lt;/sub&gt;Y, Y→&lt;sub&gt;B&lt;/sub&gt;Z の場合だけシーケンシャル結合（IO結合）を定義している。

セリンガーの定義はずっと一般化できると思うが、わかりやすいし、いい出発点になる。

</body>
</day>
<day date="2008-03-01" title="">
<body>
*1204332621*[プログラム意味論][論理]リンデンバウム／エルブランの原理

リンデンバウム代数やエルブランの定理からの教訓としての指導原理。

+ 構文構造からモデルを作れる。
+ モデル全体に十分に強い同値関係を入れれば、構文構造から作ったモデルを代表元にとれる。
+ したがって、妥当性検証は、構文構造から作ったモデルに対して行えばよい。

さらにはおそらく、

+ 「構文構造から作ったモデル」は、ある空間（スペクトル、モジュライ）の点である。
+ 命題は、この空間上の関数である。
+ したがって、妥当性検証とは、この空間上での関数値を求める問題である。

ここまで含めると、リンデンバウム／エルブラン／ストーンの原理かな。

参考：

- [http://d.hatena.ne.jp/m-hiyama-memo/20070522/1179802392:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070525/1180081962:title]

*1204353993*[雑記][物理っぽい]時計から円周パンドルとゲージ理論

- [http://d.hatena.ne.jp/m-hiyama/20080229/1204251236:title]

これの話。

Tをニュートン流の“時間の空間”とする。Tは図形的には直線だが物理次元を持つ。Tを12時間で割った T/12h = T&lt;sub&gt;12&lt;/sub&gt; を考える。これは図形的には円周S&lt;sup&gt;1&lt;/sup&gt;だが、あくまでも時間と考えてT&lt;sub&gt;12&lt;/sub&gt;と書く。

アナログ時計の文字盤は、ほんとに空間的な存在だからS&lt;sup&gt;1&lt;/sup&gt;とする。これに働く回転群はU(1)。U(1)のS&lt;sup&gt;1&lt;/sup&gt;への作用は自明。

さて、時計の目盛りや針（短針でも長針でも）は、T&lt;sub&gt;12&lt;/sub&gt;→S&lt;sup&gt;1&lt;/sup&gt;だが、T&lt;sub&gt;12&lt;/sub&gt;上のS&lt;sup&gt;1&lt;/sup&gt;バンドルを考えてそのセクションだと考える。つまり、写像のグラフをトーラス上に描くことにする。t∈T&lt;sub&gt;12&lt;/sub&gt;として、短針の運動θ(t)、長針の運動φ(t)などはバンドルのセクションである。定数セクションが目盛り（文字盤上を動かない）になる。

&lt;em&gt;短針から見ての&lt;/em&gt;長針の運動（φ(t) - θ(t)と書いてもいい）は、θをゲージとしての運動φの記述となる。12時の目盛りをσ(t)（ = 定数）とすると、標準的ゲージがσだが、θをゲージにして悪い理由はない。σゲージからは長針は半日に12回転し、θゲージからは11回転に見える。つまり、長針の回転数はゲージ不変な量ではない。

どんな目盛りでもどんな短針でも、とにかく等速回転運動してる限りはゲージ（フレームの場）として使える。そのとき、２つのゲージのあいだの変換はU(1)値のセクションであり、これは局所的な回転変換の集まりとみなせる。

等速ではなく、12時間周期の運動をする“針”があるとき、その加速度はゲージ不変な量のはずだ。ただし、加速度の方向はS&lt;sup&gt;1&lt;/sup&gt;から外に向かうから、S&lt;sup&gt;1&lt;/sup&gt;のベクトルとしては観測できない。S&lt;sup&gt;1&lt;/sup&gt;上のスカラーとして観測される。

</body>
</day>
<day date="2008-03-04" title="">
<body>
*1204619647*[雑記][メモ]Friday afternoon

Tom Leinsterが&quot;Friday-afternoonish description&quot;と書いている。


</body>
</day>
<day date="2008-03-05" title="">
<body>
*1204685712*[小咄][圏一般論]モノイダルモノイドは可換モノイド

eをただ1つの対象、id&lt;sub&gt;e&lt;/sub&gt; = 1 と書く。;は結合（第一モノイド演算））、#はモノイド積（第二モノイド変算）とする。対象がeしかないのでモノイド単位はe。

&lt;pre&gt;
 a;b 
 = (a#1);(1#b)
 = (a;1)#(1;b)
 = a#b
&lt;/pre&gt;

よって、;と#は一致する。

&lt;pre&gt;
 a;b 
 = (1#a);(b#1)
 = (1;b)#(a;1)
 = b#a
&lt;/pre&gt;

;と#が一致するから、a;b = b;a。

これが The Eckmann-Hilton argument。


</body>
</day>
<day date="2008-03-07" title="">
<body>
*1204856309*[プログラム意味論][インスティチューション][具体例]簡単な多重継承の略式インスティチューション

本編 [http://d.hatena.ne.jp/m-hiyama/20080304/1204615775:title] の補足：

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060304/1141455936&quot;&gt;簡易インスティチューション&lt;/a&gt;で定式化してみる。実は簡易インスティチューションにさえなってない略式インスティチューション。どのへんが略式かというと、指標Σに対してMod[Σ]は単なる集合。よって、指標射 Σ→Δ に対するMod[Δ]→Mod[Σ]は単なる写像。さらに、&lt;em&gt;文関手Senは考えない&lt;/em&gt;。

本編では、クラスという曖昧で直感的な概念を使ったが、ここではクラスを使わない。S={boolean, int double, string}を基本ソートの集合として固定（実はSは何でもいい）。Sの各ソートの意味（領域）も固定。T = S + S&lt;sup&gt;*&lt;/sup&gt;×S とする。Sは変数のソート、S&lt;sup&gt;*&lt;/sup&gt;×Sはメソッドのソート。

指標Σとはソート付き集合 |Σ|→T のこと。Σと|Σ|はしばしば区別しない。指標射は単射f:|Σ|→|Δ|で、f;Δ = Σ、つまりソート割り当てを保存するもの。Var(Σ) = Σ&lt;sup&gt;-1&lt;/sup&gt;(S), Var(Σ)⊆|Σ| だとする。

指標と指標射の全体を&lt;b&gt;Sign&lt;/b&gt;とすると、余完備圏。また、包含写像を考えると、inclusive category（category with inclusions）。

Mod[Σ]は、Var(Σ)をフィールド名とするレコード全体の集合、ただし、Var(Σ)上のソート割り当てに従うレコード。指標射Σで誘導されるレコード集合の写像は射影で、モデル全体の圏&lt;b&gt;Mod&lt;/b&gt;は&lt;b&gt;Sign&lt;/b&gt;の反対圏だと思ってもよい（略式だから！）。

&lt;b&gt;Sign&lt;/b&gt;が有限余完備なので、圏&lt;b&gt;Mod&lt;/b&gt;は有限完備。&lt;b&gt;Sign&lt;/b&gt;内でスパンの余ファイバー和が作れるが、任意のinclusionsに対して余ファイバー和は作れない。よって、inclusionの部分圏（順序構造）のなかで余ファイバー和は部分的にしか定義できない。このへんが、リネームを許して余ファイバー和を作れるようにするか、余ファイバー和をあきらめてinclusionだけに制限するか、の違いを表している。

*1204899451*[復習]以前考えていたけど、ほったらかしなこと

考え直そうね。

- notion of process→ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=notion%20of%20process
- notion of behaviour→ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=notion%20of%20behaviour
- Circ Kleisli→ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Circ%20Kleisli

</body>
</day>
<day date="2008-03-12" title="">
<body>
*1205309524*[雑記]CiteSeerから引き上げたのか？ クソッ！

&quot;Categories of Processes Enriched in Final Coalgebras&quot; http://citeseer.ist.psu.edu/411633.html はもはや利用不可能になっていた。見たければ、シュプリンガーから&lt;em&gt;バカ高い値段&lt;/em&gt;で買うしかない。ウーム、気になる論文はローカルにダウンロードしておくべきだなぁ。Webも（当然なことだが）まったく信頼できない。

*1205310577*[圏一般論]一般化合同の定義

http://www.tac.mta.ca/tac/volumes/1999/n11/n11.pdfより：

Definition.&lt;br&gt;A &lt;b&gt;generalized congruence&lt;/b&gt; on a category A is an equivalence relation ≡ on Ob&lt;sub&gt;A&lt;/sub&gt; and a partial equivalence relation ≡ on Mor&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;+&lt;/sup&gt; satisfying the following conditions.

+ φχ ≡ ψ implies cod(φ) ≡ dom(χ),
+ φ ≡ ψ implies dom(φ) ≡ dom(ψ) and cod(φ) ≡ cod(ψ),
+ a ≡ b implies id&lt;sub&gt;a&lt;/sub&gt; ≡ id&lt;sub&gt;b&lt;/sub&gt;,
+ φ ≡ ψ and χ ≡ ξ and cod(φ) ≡ dom(χ) implies φχ ≡ ψξ,
+ cod(f) = dom(g) implies fg ≡ (f;g).

Mor&lt;sub&gt;A&lt;/sub&gt;&lt;sup&gt;+&lt;/sup&gt;は、Mor&lt;sub&gt;A&lt;/sub&gt;の非空有限列の全体、これ自体は圏ではないが、dom[(f1, ..., fn)] = dom(f1),cod[(f1, ..., fn)] = cod(fn) としてdom, codは定義しておく。連接により半群だが、単位元はない。半群の連接演算は並置（無記号）としている。圏の結合は「;」。

</body>
<comments>
<comment>
<username>sakesnare</username>
<body>2点のコメントです。&lt;br&gt;&lt;br&gt;1. 部分的な等号／等式との関係について&lt;br&gt;部分的な等号／等式&lt;br&gt;http://www.chimaira.org/docs/PartialEquality.htmより&lt;br&gt;&lt;br&gt;このページの「弱い等号、クリーニの等号」と、「一般化合同」とは関係付けることはできますか。&lt;br&gt;&lt;br&gt;2.一般化合同の定義について&lt;br&gt;http://d.hatena.ne.jp/m-hiyama-memo/20071207&lt;br&gt;より引用&lt;br&gt;&lt;br&gt;＞＞引用始め&lt;br&gt;コンピューティングサイエンスと形式言語理論の多くの部分（と論理の一部）は、幾何学的な定式化を持ち、それは Generalized Topological Quantum Field Theory (gTQFT) の形をしているはずで、背後にはコンパクト閉圏（または類似の圏）があるのだ、てなところです。&lt;br&gt;なんでそうなのか? の内在的理由はわかりませんが、計算現象も物理現象の一種であり、物理現象の記述にはコンパクト閉圏や類似の圏が便利なのだ、と楽観的に信じいます。当然ながら、実用的な意味もあります（僕の出発点は実用ですから）。&lt;br&gt;＜＜引用終わり&lt;br&gt;&lt;br&gt;ここで、計算現象も物理現象の一種であり、物理現象の記述にはコンパクト閉圏や類似の圏が便利であることを示すために&lt;br&gt;&lt;br&gt;「一般化合同の定義」をどのような文脈の上で利用すればよいと思われますか。&lt;br&gt;&lt;br&gt;また、その際にいくつか問題が生じるとするならばどのような問題が生じますか。</body>
<timestamp>1206777910</timestamp>
</comment>
<comment>
<username>m-hiyama-taxon</username>
<body>&gt; このページの「弱い等号、クリーニの等号」と、「一般化合同」とは関係付けることはできますか。&lt;br&gt;&lt;br&gt;一般化合同は、商圏（ビジネスエリアじゃなくて、quotient category）という概念をチャンと扱う目的から出て来たと思うけど、等式概念の拡張にもなっているので、「弱い等号、クリーニの等号」とも似てます。が、無理に関係づけてもさほど生産的じゃない気もします。&lt;br&gt;&lt;br&gt;&gt; 「一般化合同の定義」をどのような文脈の上で利用すればよいと思われますか&lt;br&gt;&lt;br&gt;物理現象云々とは必ずしも直結しないのだけど、僕の意図としては、「構文から意味を作る」ときの手段に一般化合同を使えそう、ってこと。構文論で出てくる指標ってのは、だいてい有向グラフ。一部分に結合が定義されていたりして、プレ圏なんです。そのプレ圏から自然に圏を作ろうとすると、有向グラフが作った自由圏に、一般化合同を入れてその商圏を作る、って手順ですね。&lt;br&gt;構文から自然に生成される構造が「標準的な意味」を提供するってのはひとつの指導原理で、エルブランやリンデンバウムがやっていることがそういうことです。マイヒル／ネロードの定理もそんな感じかな。&lt;br&gt;問題点は事前にはわからないな、何かをやってみてうまくいかないときに問題点がわかるから。&lt;br&gt;&lt;br&gt;一般化合同は、型付き連立方程式みたなものなので、他にもいろいろと適用場面はあると思います。&lt;br&gt;&lt;br&gt;あーそれと、物理と計算が通底していることは、Rosettaによくまとまっていますね。</body>
<timestamp>1206779700</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>m-hiyama-taxonも檜山ですよ ^^;</body>
<timestamp>1206791455</timestamp>
</comment>
<comment>
<username>sakesnare</username>
<body>返信ありがとうございます。&lt;br&gt;&lt;br&gt;了解です。少しずつ理解していきます。&lt;br&gt;また、何かあったら質問します。よろしくお願いします。</body>
<timestamp>1206845346</timestamp>
</comment>
</comments>
</day>
<day date="2008-03-28" title="">
<body>
*1206670695*[論理]論理式、演繹系、セオリー

集合Lは、含意（⊃）と連言（∧）を持つ系の論理式全体の集合とする。K⊆Lが次の性質を持つとする。ここで、a, b, cなどは論理式、∧は⊃よりは優先度が強い演算子とする。

+ a∈Lに対して、a⊃a ∈K
+ a⊃b, b⊃c ∈K ならば a⊃c ∈K
+ a⊃b, a⊃c ∈K ならば a⊃b∧c ∈K

t∈Lをひとつ固定して、記法 a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;|-b を次のように定義する。

- n = 0 のとき： |-b ⇔ t⊃b ∈K
- n = 1 のとき：a|-b ⇔ a⊃b ∈K
- n = 2 のとき：a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;|-b ⇔ a&lt;sub&gt;1&lt;/sub&gt;∧a&lt;sub&gt;2&lt;/sub&gt;⊃b ∈ K
- nがそれ以上：a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;|-b ⇔ a&lt;sub&gt;1&lt;/sub&gt;∧...∧a&lt;sub&gt;n&lt;/sub&gt;⊃b ∈ K

それとは別に、集合T⊆Lを次のように定義する。

- a ∈T ⇔ t⊃a ∈K

Kがハッキリしているなら、Tもハッキリした存在だ。

Kに関する条件は、下界を持つ順序集合（実はプレ順序に過ぎない）の公理をゆるく（ぬるく）したものだ。b∧cの最大性は全然保証されない、存在だけは保証される状況。それでも、次は成立する。

+ t ∈T
+  a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;∈T、a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;|-b ならば、b ∈T

証明は定義の言い換えだから省略。

言いたいことは、次のような構造がほぼ同じだってこと。

+ ⊃と∧を持つ論理式において、ある性質を持つ部分集合K。
+ 演繹系
+ 演繹に対して閉じた集合であるセオリーT

[http://d.hatena.ne.jp/m-hiyama/20061031/1162266144:title]も参照。

*1206680140*[論理][復習]ムーア閉包

- [http://d.hatena.ne.jp/m-hiyama-memo/20051223/1135304733:title]

ムーア閉包は、

+ 単調（monotone）
+ 増大（isotonic）
+ ベキ等（idempotent）

な演算。公理は&lt;em&gt;3つ&lt;/em&gt;。

*1206686058*[論理][小咄]ムーア閉包に関連していろいろ

+ 位相閉包、閉集合
+ 凸閉包、凸体／凸図形
+ アフィン閉包、アフィン部分空間
+ 線形閉包／張る空間／生成された--、線形部分空間
+ 部分加群
+ イデアル
+ アッパーセット、フィルター
+ 構文的に導出されたセオリー
+ 意味的に導出されたセオリー
+ ムーア閉包
+ （ベキ等）モナド
+ 代数的閉包

</body>
</day>
<day date="2008-04-03" title="">
<body>
*1207206929*[形式言語理論]風景の絵を描いた

&lt;img src=&quot;http://www.chimaira.org/img2/flt-landscape.gif&quot; &gt;



</body>
</day>
<day date="2008-04-11" title="">
<body>
*1207891350*[プログラム意味論]1次元離散アフィン空間

(A, ≦, +, -)

+ Aは≦で全順序集合
+ +:A×&lt;b&gt;Z&lt;/b&gt;→A
+ -:A×A→&lt;b&gt;Z&lt;/b&gt;

+ a + 0 = a
+ (a + n) + m = a + (n + m)
+ (a + n) - a = n
+ a + (b -  a)  = b
+ a≦b ⇔ b - a ≧0

α&lt;sub&gt;a&lt;/sub&gt; = λb.(b - a) :A→&lt;b&gt;Z&lt;/b&gt;, β&lt;sub&gt;a&lt;/sub&gt; = λn.(a + n) :&lt;b&gt;X&lt;/b&gt;→A とすると、これらが互いに逆で、Aと&lt;b&gt;Z&lt;/b&gt;は順序構造として同型。

*1207891987*[プログラム意味論]メモリ空間

A = (A, ≦, +, -)は1次元離散アフィン空間、E⊆Aは非空有限区間、Xは空でない集合（普通は束）として、(A, E, X)をメモリ空間と呼ぶ。Eの最小元bを基点（base point, base position）、α&lt;sub&gt;b&lt;/sub&gt;:A→&lt;b&gt;Z&lt;/b&gt;を標準アドレスと呼ぶ。

A = (A, ≦, +, -)、M = (A, E, X)をメモリ空間として、写像E→Xをメモリ空間Mの状態と呼ぶ。状態の全体をState(M)とする。メモリ空間の射を適切に定義すると、f:M→Nに対して、State(N)→State(M)が定義できて、Stateは反変関手となる。

*1207903920*[プログラム意味論]メモリ射といろいろな関手

A, Bが1次元離散アフィン空間空間のとき、f:A→Bと加群射φ:&lt;i&gt;Z&lt;/i&gt;→&lt;i&gt;Z&lt;/i&gt;の組で、f(a + n)= f(a) + φ(n) となるものを射とし、アフィン射と呼ぶ。φ(b - a) = f(b) - f(a) が従う。整数の性質から、φ(n) = k*n となるk&gt;0がある。これをスケール因子と呼ぶ。

メモリ空間(A, E, X)と(B, F, Y)があるとき、スケール因子kのアフィン射A→Bと、Y&lt;sup&gt;k&lt;/sup&gt;→X という写像の組をメモリ射と呼ぶ。

メモリ空間(A, E, X)と(B, F, Y)、スケール因子kのアフィン射(f, φ):A→Bに対して、{f(a) + i | a∈K, i = 0, ..., k}で定義されるBの部分集合をアフィン射のブロック像と呼ぶ。メモリ射を構成するアフィン射に対して、Eのブロック像がFに含まれるとき、そのメモリ射は包含的、または妥当と呼ぶ。

メモリ空間M = (A, E, X)の状態State(M)に対して、read(n) : State(M)→Xとwrite(n, x):State(M)→State(M)が定義できる。{read(n) | n = 0, ..., (size(M)-1)}∪{write(n, x) | n = 0, ..., (size(M)-1), x∈X}を観測／アクションとする決定性遷移系を定義できる。これをメモリ空間M上の読み書き機械と呼びRWM(M)と書く。RWM(-)を関手にしたい。

</body>
</day>
<day date="2008-04-12" title="">
<body>
*1207964647*[プログラム意味論]X-オートマトン

昨日、読み書き機械という概念を導入したが、集合（つうか圏の対象）Xに対してX-オートマトンという概念／用語のほうがいいと思い直した。

(S, X, O, A)がX-オートマトン（背景の圏は&lt;b&gt;Set&lt;/b&gt;）だとは、

+ Sは状態の集合
+ Xは観測値の集合
+ Oは観測子（属性）の集合、f∈O なら、f:S→X
+ Aはアクション（遷移）の集合、a∈A なら、a:S→S

メイヤーが言うクエリ＆コマンド方式の、クエリの値をXに限定したもの。背景の圏を変えると、部分性や非決定性も表せる。

一般には、圏Cと、X∈|C|を含む指標Σに対して、Autom(C, Σ)が定義できる。指標Σ内のソート記号xが前もってXにバインドされている状況。Autom(C, Σ(X)) = Autom&lt;sub&gt;Σ&lt;/sub&gt;(C, X) のようにも書ける。Σが自明ならAutom(C, X)、さらにCも暗黙に固定（例えば&lt;b&gt;Set&lt;/b&gt;）するならAutom(X)。

メモリ空間M = (A, E, X)があると、Σ(M) = (O(M), A(M))を次のように定義できる。

- O(M) = {read(i):s→X | 0 ≦ i ＜ size(M)}
- A(M) = {write(i, x):s→s | 0 ≦ i ＜ size(M), x∈X}

このΣ(M)とState(M)があれば、Autom(M)が構成できる。

背景となる圏を（例えば&lt;b&gt;Set&lt;/b&gt;に）固定して、X-Automの圏とY-Automの圏の関手を定義すべきだし、X-Autom = Autom[X] としてindexed categoryにすべき。うーむ、やっぱりそういうことになるのか。

*1207965253*[プログラム意味論][リンク]形式意味論 Javaの場合

- http://citeseer.ist.psu.edu/jacobs02coalgebras.html

*1207975717*[プログラム意味論]読み書き機械の指標とモデル

やっぱり読み書き機械だけでもいいのかもな。んんと、こういうことか。

集合Xと非負整数nが与えられると、指標Σ(X, n)が作れる。

- read(i):s→X (i = 0, ..., n-1)
- write(i, x):s→s (i = 0, ..., n-1、x∈X)

ここで自由なソート記号sに集合を対応させ、オペレータ記号に写像を対応させれば、指標Σ(X, n)のモデルとなる。セオリーとしては：

+ (true){write(i, x)}(read(i) == x}
+ (read(j) == y ∧i ≠ j){write(i, x)}(read(j) == y}

でいいと思う。このセオリーも一緒に考えるとして、そのモデル圏をRWM(X, n)とすればいいかな。

メモリー空間A = (A, E, X)があると、size(M) = size(E) = n として、対(X, n)が決まるから、RWM(M) = RWM(X, n) と定義できる。空のメモリ空間を許しても、RWM(M)は単元集合を状態空間として、（妥当な）観測子もアクションもまったくない機械になる。


</body>
</day>
<day date="2008-04-14" title="">
<body>
*1208166288*[モノイド圏]モノイド圏の別な公理化

これでいいと思う。

+ I*f = f*I = f
+ (f*B)*C = f*(B×C), B*(C*f) = (B×C)*f
+ B*(f*C) = (B*f)*C
+ C*(f;g) = (C*f);(C*g),  (f;g)*C = (f*C);(g*C)
+ id&lt;sub&gt;A&lt;/sub&gt;*B = id&lt;sub&gt;A×B&lt;/sub&gt;, B*id&lt;sub&gt;A&lt;/sub&gt; = id&lt;sub&gt;B×A&lt;/sub&gt;
+ (f*B);(A';g) = (A*g);(f;B')

</body>
</day>
<day date="2008-04-15" title="">
<body>
*1208255308*[リンク][からみ系]アブラムスキーのテンパリー／リーブ圏の解説

- http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/tambook.pdf

Webからなくなると悲しいからローカルに落とした。


</body>
</day>
<day date="2008-04-16" title="">
<body>
*1208316209*[復習][からみ系][お絵描き]点とか線の操作の代数と生成元

- [http://d.hatena.ne.jp/m-hiyama-memo/20070417/1176776829:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070418/1176881492:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177562726:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070427/1177656071:title]

とかを読み直す。

時間を縦に取ると、粒子の生成・消滅、交換、合流、分解、対生成／対消滅などの素過程から構成される現象となる。

1粒子の消滅をT、生成を⊥とする（逆もありだろうが）。(∩+⊥);(T+∪)を横に走る線分（--と書く）に変形する規則はどうだろう？ 代数的には次の等式になる。

+ (∩+⊥);(T+∪) = --
+ (∪+T);(⊥+∩) = --
+ (I+T);--;(⊥+I) = I
+ (⊥+I);--;(I+⊥) = I

これからジグザグ等式は出てくるだろう。が、絵を描かないとわからんな、これ。

追記：絵を描いた。

&lt;img src=&quot;http://www.chimaira.org/img2/simple-zigzag.gif&quot; &gt;

*1208322898*[用語法]associator, unitor

- [http://d.hatena.ne.jp/m-hiyama-memo/20070221/1172049792:title]

そういえば、α、λ、ρをそれぞれ、associator, left unitor, right unitorと言うことがあるようだ。tensoratorなんて言葉もある。

*1208352842*[用語法]自然数が対象の圏

自然数（非負整数）集合が対象である圏をなんか呼び名があったような。PROだかPRODだか、うーんと？ グレアム・シーガル（Graeme Segal）が言っていたのだっけ？

オペラッドが自然数を対象とする複圏？

</body>
</day>
<day date="2008-04-17" title="">
<body>
*1208406717*[モノイド圏][高次圏論][プログラム意味論][マンダラ]2-ベクトル空間と、形式テンソルによる構成

おー、なんかやっと面白くなった。

2-ベクトル空間ってバエズの定義をみても分からなかった。バエズによれば、ベクトル空間の圏のなかの圏対象（内部圏）が2-ベクトル空間ってことだが、これだけだと何がうれしいかわかんない。

- Title: Categorical Representations of Categorical Groups
- Authors: JOHN W. BARRETT AND MARCO MACKAAY
- URL: http://arxiv.org/abs/math.CT/0407463
- 35ページ印刷済み

↑を眺めていたら、ものすごく具体的に2-ベクトル空間を定義してあって、やっと実感が湧いた。が、バレット＆マッカイ（発音わからないけど、いいや）の定義にやや違和感がある。具体的過ぎるのが問題かもしれない。

バレット＆マッカイは、対象＝0セルを自然数、対象のモノイド積は自然数の積だとしている。が、自然数の代わりに格子矩形（lattice rect.）を使うといいと思う。0セルのモノイド積は格子矩形の直積だ。直積で格子矩形の次元（階数）は上がる。

さて、格子矩形を使うとなると、[http://d.hatena.ne.jp/m-hiyama-memo/20080223/1203733311:title]で触れているテンソルグラフ、形式テンソルと話が噛み合ってくる。つまりこういうことだ； 2つの格子矩形からテンソルグラフ（行列グラフ＝二部グラフを含む）が定義できるが、平行テンソルグラフという特殊なモノだけを考える。一般に、モノイド圏Cを係数とするテンソルグラフは再び圏となるが、バレット＆マッカイの2-ベクトル空間は、平行テンソルグラフに関して係数圏をMat&lt;sub&gt;&lt;b&gt;C&lt;/b&gt;&lt;/sub&gt;にとったもんだ。Mat&lt;sub&gt;&lt;b&gt;C&lt;/b&gt;&lt;/sub&gt;は複素係数行列の圏。

圏Cが半環圏（semiringal cat.）のとき、和（双積）とテンソル積（モノイド積）を使えば、横結合（平行結合）も定義できるので、双圏を作れる。和、テンソル積、双対（スター）、共役（ダガー）などを持つ圏をベース（係数圏）にして、形式テンソル関手TENSを使ってよりリッチな圏を作れるのだろう。

行列のクロネッカー積は、入れ子の行列として定義したほうが自然だろう。無理に平坦化すると不自然。それに、クロネッカー積は対称ではなく右作用／左作用2種類のクロネッカー積を定義するのがよさそうだ、その2つは添字置換の同型で結ばれる。

まーともかく、自然数係数またはブール係数の形式テンソルからはじめて、バレット＆マッカイの2-ベクトル空間を完全に定義して、より一般のテンソル構成（係数は半環圏、スター半環圏、ダガー半環圏など）も試してみよう。

圏Relを係数としたテンソル構成はプログラム意味論に使えそうだ。マンダラ仮説によると、プログラムの全体は大変に複雑な高次圏だが、振る舞いの圏はモノイド双圏＝単一対象の3-圏くらで定式化できそうだ。[http://d.hatena.ne.jp/m-hiyama-memo/20080221/1203567363:title]の絵も参照。

モノイド双圏（monoidal bicategory）は使えそうな気がしてきた。うむっ、面白くなった。面白いと思っているうちに何かしよう、っと。


</body>
</day>
<day date="2008-04-18" title="">
<body>
*1208492871*[モノイド圏][高次圏論]圏群と交差モジュール

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080417/1208406717&quot;&gt;昨日&lt;/a&gt;言及したバレット＆マッカイ（Barrett and Mackaay）論文に、圏群（categoracal group）ってのが出てくる（つうか、それが主題だ）。群の交差モジュール（crossed module）と同じ概念なんだそうだ。

交差モジュールは、群E, G、群準同型δ:E→G、左作用-*-:G×E→E の組。GはEに作用している。つまり、EはG集合になっている。が、この作用がE上の群自己準同型になっているかどうかよくわからん。群演算は単なる並置で表すとして：

+ δ(x*a) = x(δa)x&lt;sup&gt;-1&lt;/sup&gt;
+ (δa)*b = aba&lt;sup&gt;-1&lt;/sup&gt;

xyx&lt;sup&gt;-1&lt;/sup&gt;のような自己作用をy&lt;sup&gt;x&lt;/sup&gt;で表すと。

+ δ(x*a) = (δa)&lt;sup&gt;x&lt;/sup&gt;
+ (δa)*b = b&lt;sup&gt;a&lt;/sup&gt;

つまり、δと*を経由して回り道な自己作用を作ると、それが xyx&lt;sup&gt;-1&lt;/sup&gt;、aba&lt;sup&gt;-1&lt;/sup&gt;のような形をしている。

*1208507569*[モノイド圏][高次圏論]圏群と交差モジュール 2

圏群の定義だけど：

- 亜群の圏の群対象

まー、わかるんだけど、台構造（underlying structure）にも構造射にも逆があるから、記法が紛らわしいかな。Gが亜群として、Gの射f∈G(X, Y)には逆f&lt;sup&gt;-1&lt;/sup&gt;∈G(Y, X)がある。一方、(-)&lt;sup&gt;-1&lt;/sup&gt;:G→Gという関手＝構造射もある。X∈|G|に対して亜群の意味での逆はない（あるけど自明だ）が、圏群の（上部構造）の意味での逆はあるから、X&lt;sup&gt;-1&lt;/sup&gt;も考えることができる。X&lt;sup&gt;-1&lt;/sup&gt;はたいていXとは全然別物だ。あー、ややこしい。

すぐ思いつく例は、Mをリー群だとして、Mの道（区分的になめらかな曲線）の全体をΓ(M)とでもして、ホモトピーで割り算してG = G(M)を作る。道の繋ぎ演算により、|G| = M な亜群ができる。α、β∈Γ(M)に対して、Mの群積から積をいれると、亜群の圏の群対象を定義するだろう。α∈Γ(M)の道としての逆はα~とでも書いた方がいいかな。α:[0, 1]→M なら、α~(t) = α(1-t)。

圏群は、上部構造の群演算をモノイド積として厳密モノイド圏になる。ということは、亜群上の弱い群対象（厳密でない公理）により少し一般化した圏群が定義できるのだろう。

</body>
</day>
<day date="2008-04-19" title="">
<body>
*1208571995*[圏一般論][モノイド圏][計算]弱い代数系、0.5次の構造

モノイド、群、半環のように、等式的に定義された代数系を考える。当然にこれらは、集合を台として定義される。圏を台にしたモノイドはモノイド圏、亜群を台とした群は圏群、圏を台とした半環は半環圏（まだ定義は曖昧）のようになるが、集合と圏の中間的な台を考えてみる。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080414/1208166288&quot;&gt;モノイド圏の別な公理化&lt;/a&gt;では、対象類がモノイドになっていて、そのモノイドが射（ホムセット）に左右から作用しているような定式化で厳密モノイド圏を構成している。似たような発想で、まず対象類を代数系にして、それから圏全体に構造を入れることを考える。

対象類に代数構造を入れるにしても、厳密（強い）ケースだけだと応用上狭すぎるので、弱いケースも考える。弱いケースは等号の代わりに同型を使うので、同型概念は必要になる。そこで、ベースとして亜群を取る。例えば弱いモノイドは：

+ 亜群Gがある。
+ M = |G| 上に演算×と特定の元Iがある。
+ ×とIに関する法則を亜群の射（常に同型）で記述する。
+ 一貫性条件を付ける。

となる。僕は一貫性条件を理解してないのだが、まー、必要に違いあるまい。

特に面白いのは弱い半環で、対象類の上に×、+の２つのモノイド演算があり、これらが弱いモノイドになっている。さらに弱い分配律も成立している。圏Cから作られた亜群Iso(C)上に弱い半環構造があり、対象が射に作用している状況をうまく公理化できると面白い（かもしれない）。ただし、厳密ケースじゃないから難しそう。

集合上の構造は台が0次、圏上の構造は台が1次、となると亜群上の構造は台が0.5次といってもいいだろう。（単なる気分だが。）

*1208574480*[圏一般論][モノイド圏][計算]圏係数の行列計算とモノイド二重圏

圏を係数系とした行列／テンソルの計算をしたかった。だから、バレット＆マッカイの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080417/1208406717&quot;&gt;2-ベクトル空間や圏群の話&lt;/a&gt;は、ちょうどいいタイミングだった。

バレット＆マッカイでは、具体的な行列を使ってモノイド双圏を作っている。が、僕の興味としてはモノイド二重圏のほうがふさわしい。モノイド二重圏の一部にモノイド双圏は埋め込まれているし。

モノイド二重圏をうまく作るには、係数の圏Cが半環圏でなくてはならない。CからIso(C)を作ると弱い半環となっている。まずはこの弱い半環だけを使って行列計算する。K, L, M, Nなどは格子矩形だとする。格子矩形の全体に集合としての直和と直積を入れて、弱い半環にできる。特に直積に関して弱いモノイド構造を持つ。Iso(C)が作る弱い半環をRとしておく（Rは、Cと無関係に与えられる弱い半環でもよい）。

この状況で、Mat&lt;sub&gt;R&lt;/sub&gt;(K, L)は、矩形K×LにRの元を割り当てた行列（形式テンソル）だとする。A∈Mat&lt;sub&gt;R&lt;/sub&gt;(K, L)とB∈Mat&lt;sub&gt;R&lt;/sub&gt;(L, M)の積はRの半環構造から定義できる。ただし、Rが弱いので、圏の単位律と結合律も弱くなり、弱圏しか定義できない。骨格的部分弱圏をとれば圏にできるかもしれない。

2つの行列A:K→L、B:M→N に対して、A×B:K×M→L×N は(A×B)[(k, m), (l, n)] = A[k, l]×B[m, n] で定義できる。モノイド単位は矩形[1] = {1}である。

さらに、二重圏構造を定義するために、行列A:K→Lと行列B:M→Nを結ぶ2セルα::A⇒Bが必要になる。これは、格子K×Lと格子M×Nを両サイドとする二部グラフを考えて、二部グラフをシェープとするC係数カテグラフαを2セルとする。

2セルαの境界（dom, codに相当）と縦結合はカテグラフとしては自明に定義できる。問題は横結合。α::A⇒A':K→L,K'→L' とβ::B⇒B':L→M, L'→M' に対してα*β::A;B⇒A';B':K→M, K'→M' を合理的に定義すること。形式的な計算ならできそうな気がする。やってみるか。

*1208588056*[高次圏論][モノイド圏][計算]圏係数の行列計算の実例

まず、弱半環として、集合と双射、直和と直積を考える。これを&lt;b&gt;SB&lt;/b&gt;(Sets and Bijections)とする。詳しくは、(&lt;b&gt;SB&lt;/b&gt;, +, 0, ×, 1, 法則ごとの同値性)。法則ごとの同値性とは、associator αとか、なんか色々。

I, J, Kなどは有限集合として、弱半環&lt;b&gt;SB&lt;/b&gt;係数の行列を、I×J→|&lt;b&gt;SB&lt;/b&gt;| という写像で定義する。Mat&lt;sub&gt;&lt;b&gt;SB&lt;/b&gt;&lt;/sub&gt;(I, J)は、(I, J)をシェープとする行列の全体。A, B∈Mat&lt;sub&gt;&lt;b&gt;SB&lt;/b&gt;&lt;/sub&gt;(I, J)に対して、α:I×J→Mor(&lt;b&gt;SB&lt;/b&gt;) という写像（割り当て）で、α[i, j]:A[i, j]→B[i, j] in &lt;b&gt;SB&lt;/b&gt;となっているものを行列の同値変換と呼ぶ。α::A→B:I→J と書くと自然変換（自然同型）と同じ感じ。Aとαの“積”は行列のアダマール積と似ている。

A∈Mat&lt;sub&gt;&lt;b&gt;SB&lt;/b&gt;&lt;/sub&gt;(I, J), B∈Mat&lt;sub&gt;&lt;b&gt;SB&lt;/b&gt;&lt;/sub&gt;(J, K)に対して行列積（の反対）A;B∈Mat&lt;sub&gt;&lt;b&gt;SB&lt;/b&gt;&lt;/sub&gt;(I, K)は、&lt;b&gt;SB&lt;/b&gt;の弱半環構造を使って定義できる。が、結合律／単位律はon-the-noseには成立しない。up-to-同値変換では成立。すべての行列と同値変換の全体は亜群となる。dom, cod, idは厳密に定義できる。行列の積は、亜群に対して弱い圏構造を入れる。

2つの行列A, Bに対して、今度はRelを係数としてのハイパー行列Φ:A⇒Bを考えることができる。ハイパー行列は、AからBへのセルでI×J → K×Lのような二部グラフに対するRel値のカテグラフのこと。ハイパー行列Φ, Ψに対する横結合（スター積）Φ*Ψも定義できて、up-to-(同値変換の対)で結合律／単位律が成立する。次元は次のようになるだろう。

- I, J  -- 0セル 添字集合
- A, B  -- 1セル 行列
- Φ, Ψ -- 2セル ハイパー行列
- (α, α'), (β, β') -- 3セル 同値変換の対

*1208590432*[高次圏論][モノイド圏][用語法]テンソル積とクロネッカー積

古典的計算的な意味でのテンソル積は (A×B)[i, j] = A[i](×)B[j] のような感じで、添字の集合の次元が上がる。一方、クロネッカー積は、添字の次元をスプライシングで落としてしまう。2次元配列を“配列を要素とする配列”にするようなもんだ。

要するにいくらクロネッカー積をとっても行列のままで高階のテンソルが出てこないのがいい点でもあり悪い点でもある。バレット＆マッカイの2-ベクトル空間の定義では、対象（0セル）が自然数でそのモノイド積が掛け算になっている。自然数だけで済ませるために、実はテンソル積としてクロネッカー積を使っている。この方法だと不自然な面があるし、単純化と同時に複雑化することもあるよな。

</body>
</day>
<day date="2008-04-21" title="">
<body>
*1208735209*[高次圏論][計算]圏係数の行列計算 もっと

弱半環（pseudoを使って疑似半環 or 疑半環のほうがいいかも？）係数の行列計算は、なんか奇妙だ。が、既存の枠組みに入るような気もする。とありえず現象：

+ 行列A, B:I→Jに対しして同値α:A~~&gt;B がある。これを2セルと考えることもできるが、ちょっと違うような。
+ ホムセットMat(I, J)は同値により亜群となる。が、亜群で豊饒化でもないような。
+ 行列A:I→J, B:J→Kの行列積（図式順）A;Bを定義できるが、単位律、結合律はup-to-同値でしか成立しない。疑圏（pseudo-category）とでもいうべき構造。
+ A:I→J, B:K→Lに対するテンソル積A×B:I×K→J×Lは定義できる。モノイド積と思ってよい。
+ ほんと(?)の2セルは、α:;A⇒B I×J→K×Lの圏係数ハイパー行列だと思われる。

ハイパー行列という言葉は今とりあえず使っている。二部グラフから圏へのグラフ写像のことだが、二部グラフの左右が多次元構造物であるもの。

この計算がうまくなったらなにかいいことあるのか？ たぶんありそうだ。


</body>
</day>
<day date="2008-04-22" title="">
<body>
*1208831428*[高次圏論][計算]圏係数の行列計算 3セル

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080421/1208735209&quot;&gt;昨日の記事&lt;/a&gt;に訂正： シェープが(I, J)であり圏の対象を成分とする行列を1セルと考えると、同じシェープで射を成分とする行列は2セルと思ってよい。2セルの縦結合はアダマール積に似てるからアダマール結合と呼ぼう。Mat(I, J)はアダマール結合で圏になる（アダマール圏かな）。A∈Mat(I, J), B∈Mat(J, K)の行列積は、up-to-同値で定義できるが、同値は射の行列で与えられる。2セルの横結合（水平結合、スター積）も定義可能と思われる。

A∈Mat(I, J), B∈Mat(K, L)のあいだの射η:A→Bはやはり2セルのような気がするが、Mat(I, J)の内部に存在しない点で&lt;em&gt;異種の2セル&lt;/em&gt;だ。α::A⇒A':I→J とβ::B⇒B':K→L があると、η::A⇒B, η':A'⇒B'を辺とするようなΦ:::α(3)⇒β という3セルがあるような気がする。ハイパー行列は、この3セルの辺なのじゃないだろうか？

*1208831580*[雑記][高次圏論]Dominic Verity のcomplicial setsの本

アマゾンから案内が来た：
- http://www.amazon.co.jp/gp/product/0821841424/

*1208831852*[オフトピック][リンク]東京おもちゃ美術館

消防博物館とも近い。

- http://www.goodtoy.org/ttm/

*1208853750*[高次圏論][リンク]バタニンがエクマン／ヒルトンと対称性を解説

- Title: The Eckman-Hilton argument and higher operads
- Authors: M.A. Batanin
- URL: http://arxiv.org/abs/math/0207281
- (Submitted on 30 Jul 2002 (v1), last revised 14 Jun 2007 (this version, v4))
- 57ページ

</body>
</day>
<day date="2008-04-23" title="">
<body>
*1208919845*[用語法]simplicial, simplex, simplices, simplexes

Dominic Verity の本がcomplicial sets だったが、simplicialと類似の言葉だな。

simplicialを僕はsimplicalと勘違いしていた。発音もたぶんシンプリカルじゃなくてシンプリシャルなんだろう。simplexの複数はsimplices（iに注意）で、complexの複数はcomplexesかぁ。でも、simplexesでもいいようだな。Simplexes and Complexes なんてタイトルも許されているようだし。

*1208919929*[高次圏論][計算]行列の疑半環

係数半環を固定して、行列の全体Matを考える。A, B∈Matに対して、形状が同じとき、その成分の置換を射と考えて亜群を作る。任意の置換ではなくて、ブロックに切って（矩形分割して）の置換だけを考えてもいいだろう（ゲームっぽい）。

すると、亜群Matは、対角ブロック和とクロネッカー積で疑半環になる。サイズを取る写像size(A) = (I, J)は、疑半環から半環&lt;b&gt;N&lt;/b&gt;×&lt;b&gt;N&lt;/b&gt;への疑半環の射となる。

そういえば、行列の変形は2セルだな。

*1208920507*[高次圏論][計算]クロネッカー積の添字計算

行列のクロネッカー積を作るときは、添字を 0, 1, 2, ..., I-1 としたほうが便利。a[i, j]とb[k, l]のテンソル積を a(×)b とすれば、

- (a(×)b )[i, j, k, l] = a[i, j]*b[k, l]

a(×)b を平坦化した行列をcとして； c[α, β] = a[i, j]*b[k, l]

- α = i*K + k
- β = j*L + l

逆向きに解くと：

- i = α/K
- k = α%K
- j = β/L
- l = β%L

よって、

- c[α, β] = a[α/K, β/L]*b[α%K, β%L]

*1208940581*[高次圏論][計算][具体例]すぐに扱える高次圏の例

手が痛えー。タイピングが不自由。

+ コボルディズムの圏
+ 両側加群（bimodule）の圏
+ ラベル付き遷移系の圏
+ 圏係数行列の圏

他に、順序集合の圏の圏、強2-圏の圏とかタングルの圏とか。

|* 典型的対象   |* 0セル |* 1セル |* 2セル |
|コボルディズム |境界なし多様体 | 同境 | 同境の写像 |
|両側加群       |可換環  | 両側加群 | 両側加群の写像 |
|ラベル付き遷移系 | 頂点集合 | 遷移グラフ | 双模倣 |
|圏係数行列     |添字集合 | 行列 | 射を係数とする行列 |

演算：

|* 典型的対象   |* 1-結合  |* 2-縦結合 |* 2-横結合 |
|コボルディズム | 同境の貼り合わせ | 写像の合成 | 写像の貼り合わせ |
|両側加群       | テンソル積 | 写像の合成 | 写像のテンソル積 |
|ラベル付き遷移系| 遷移グラフの貼り合わせ | 双模倣の合成 | 双模倣の貼り合わせ |
|圏係数行列     | 対象行列の積 | 射行列のアダマール結合 | 射行列の積 |

二重圏が多いな。とにかく、触って慣れる。


</body>
</day>
<day date="2008-04-24" title="">
<body>
*1208994290*[圏一般論][課題]profunctor, bimodule, 行列

profunctorとbimodule（両側加群）と行列の関係は？

*1208994291*[高次圏論][計算][具体例]行列疑半環は厳密

行列の対角和とクロネッカー積の半環は、単位律も結合律もon-the-noseで成立する。2つのpermutative圏の構造を持つ。具体的な添字計算で分かる。

*1209022900*[高次圏論][計算][具体例]クロネッカー積の対称置換

a[i, j], b[k, l]、0≦i＜I, 0≦j＜J, 0≦k＜K, 0≦l＜L とする。

- c[α, β]  = a[i, j]*b[k, l]
- d[α', β']  = b[k, l]*a[i, j]

のとき、0≦α＜I*K, 0≦β＜J*L に対して、

- α' = (α%K)*I + α/K = σ(α)
- β' = (β%L)*J + β/L = τ(β)

とすると、(α, β) |- σ×τ →(α', β') がクロネッカー積の対称置換を与える。


</body>
</day>
<day date="2008-04-25" title="">
<body>
*1209110698*[雑感][計算]添字計算がめんどくさい

対角和とクロネッカー積の計算をしてみたのだけど、整数の掛け算／割り算ができねーよ。ダメダコリャ。

だいたいの見通しはついているのだけど、具体的な算術計算すると間違う。ダメダコリャ。

どうしたもんかなー？ 次男と一緒に勉強し直すか（割とマジ）。

*1209112001*[雑感][オフトピック][計算]ブロックで計算したい

LaQ（http://www.yoshiritsu.com/html/new_top/new_top.html）のピースのタイプ番号を覚えられない。四角とか三角とか曲がったヤツとか呼んでいる。次男にバカにされる。

と、それはどうでもよくて、LaQの“四角のようなヤツ”（何番だ？）で、直接的に接合できるのがないかな。レゴは少しでかすぎるような。ダイヤブロック（http://www.diablock.co.jp/）は明らかにでかすぎ。それに、横に直接的接合できないんだよな。うーん。

整数計算とコンパクト閉圏の計算もできるようなブロックないかなー、ってないか、ヤッパリ。自作するにしても大量に作るには金型必要そうだし。

*1209114756*[高次圏論][モノイド圏][計算]余りのある割り算になると分からなくなる“件”、というか“圏”

とととと、で、どんな計算をしていたか。

I, J, K, Lとかは非負整数、[I]= {0, 1, ..., I-1}、#([I]) = I とする。対応する小文字i, jなどはI, J上を走る変数。+, * は普通の足し算と掛け算。/, % は余りのある割り算（整除）と余り。

I(*)J = [I*J] として、f:[I]→[K], g:[J]→[L]に対して、

- (f(*)g)(x) = f(x/J)*L + g(x%L)

とする。それと、

- x' = τ&lt;sub&gt;I,J&lt;/sub&gt;(x) = (x%J)*I + x/J

としたとき、τを対称として(&lt;b&gt;N&lt;/b&gt;, *, 1)を対象類とする対称モノイド圏となることを示す。特にヤン／バクスター型の方程式を示す。

有限集合の圏に対して、ある種のゲーデル符号化している。もとの有限集合の圏では自明なことなんだが、計算だけで示すのは割り算が不自由な僕には大変。人為的な符号化をするのがマズイのかもしれないが、算術計算の練習だね。

</body>
</day>
<day date="2008-04-26" title="">
<body>
*1209169755*[復習][プログラム意味論][高次圏論]プログラムと高次圏や多重圏との関係

- [http://d.hatena.ne.jp/m-hiyama-memo/20070116/1168910807:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070113/1168670955:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070118/1169088000:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080104/1199433463:title]

*1209170911*[具体例][圏一般論][説明]単純化したpseudo, lax, oplax関手

集合上に部分的な二項演算「;」を持つ系を考える。圏だと思う必要はないし、圏だと思いたければそれもよし。プレ順序≦もあるとする。a≦b かつ b≦a のとき、a～b と書く。～は同値関係。

演算;が結合的であるとき、厳密プレ半群、～の意味で結合的であるとき疑似プレ半群と呼ぶことにする。主に疑似プレ半群を考える。f:A→Bが、

- f(a;b) = f(a);f(b) のとき厳密準同型
- f(a;b) ～ f(a);f(b) のとき疑似準同型
- f(a;b) ≦ f(a);f(b) のときlax準同型
- f(a;b) ≧ f(a);f(b) のときoplax準同型

と呼ぶ。


</body>
</day>
<day date="2008-05-01" title="">
<body>
*1209620123*[用語法]unitalとunitary

どう使い分けるのかな？

</body>
</day>
<day date="2008-05-02" title="">
<body>
*1209690441*[モノイド圏][具体例]半環圏の7つの例

半環圏の一貫性まで含めた完全な定義はよくわからん。が、事例はある。

&lt;h5&gt;自然数&lt;/h5&gt;

半環としての&lt;b&gt;N&lt;/b&gt;を対象として、標準順序から圏だとみなすと、半環圏。

&lt;h5&gt;集合圏&lt;/h5&gt;

直和と直積で半環構造を入れる。零対象である空集合は、0×x = 0 を厳密に満たすから強零対象（strong zero object）と呼ぶことにする。

&lt;h5&gt;関係圏&lt;/h5&gt;

直和と直積で半環構造を入れる。自己双対なダガー・コンパクト閉圏にもなっている。

&lt;h5&gt;ベクトル空間の圏&lt;/h5&gt;

テンソル積でテンソル圏。直和が双和となっているので、双デカルト構造にテンソル構造が加わった圏。内積があればダガー・コンパクト閉圏。

&lt;h5&gt;行列の圏&lt;/h5&gt;

対角和とクロネッカー積で半環構造を入れる。対象は半環としての&lt;b&gt;N&lt;/b&gt;になる。

&lt;h5&gt;形式テンソルの圏&lt;/h5&gt;

行列の圏と類似しているが、クロネッカー積よりはテンソル積のほうが自然。

&lt;h5&gt;対称モノイド圏の自己関手の圏&lt;/h5&gt;

Cを対称モノイド圏として、C→C という対称モノイド関手の全体に結合で積を入れた構造。

*1209699480*[計算][モノイド圏]クロネッカー積の添字計算

本編に書いた[http://d.hatena.ne.jp/m-hiyama/20080501/1209618676:title]、ほんとにできないよ。時間を使ってもしょうがないから早々とあきらめているのだけど。

使えることって：

+ (x/N)N + x%N = x
+ (x*N)%N = 0
+ (x%N)%N = x%N
+ (x + y)%N = (x%N + y%N)%N
+ (x + y)/N = x/N + y/N + (x%N + y%N)/N

これくらいしか思いつかんし。他にもあるか？

*1209700356*[用語法]distributor

The Handbookでは、プロ関手（profunctor; http://en.wikipedia.org/wiki/Profunctor）をdistributorと呼んでいる。プロ関手をbimoduleとかmoduleとか呼ぶこともあるそうだが、それはひどすぎるだろう。bimoduleは双加群＝両側加群の意味で使うべきかと思う→http://en.wikipedia.org/wiki/Bimodule

ところで僕は、associator, unitorと一緒に半環圏（semiringal category）の分配律の法則を与える同型をdistributorと呼びたい。associator, unitor, distributorは、結合性同型、単位性同型、分配性同型かな。

*1209700564*[用語法]zeor

a×0 = 0 という法則を与える同型はzerorってことか？ 零性同型？

*1209707270*[からみ系][お絵描き]クロス・スワップ公式からアルチン関係式

&lt;a target=&quot;_blank&quot; href=&quot;http://www.chimaira.org/docs/EtbDiagrams.htm#s8&quot;&gt;ETBダイアグラムの8節&lt;/a&gt;に、クロスの公理がある。最後の公理は、クロスにそって射（ボックス）をスワップできることを示す。これは非常に強力な公理だ。

クロスをまとめる公式とスワップを使えば、アルチン関係式（ヤン・バクスター方程式）は出る。

&lt;img src=&quot;http://www.chimaira.org/img2/swap-to-artin.gif&quot; &gt;


</body>
</day>
<day date="2008-05-03" title="">
<body>
*1209779113*[高次圏論][お絵描き][具体例]形式テンソルの図示

まずは絵を見よう。

&lt;img src=&quot;http://www.chimaira.org/img2/formal-tensor.gif&quot; &gt;

左上：これは、A = (A[1], A[2])、B = (B[1], B[2]) という“対象の列”（対象形式ベクトル）のあいだの行列。f:A→B は、成分射f[i→j]:A[i]→B[j] 達で与えられる。ストリング図で描けば列はワイヤー、行列はオダンゴ。A, Bなどの列の長さはワイヤーの厚みだと思えばいい。行列fの内部では、ワイヤーがほぐされて分岐して配線される。

左下：行列からテンソルへの拡張。直線状の列が平面や立体的な配置に変わる。図でA, Bは列だがA(×)Bは格子矩形。(A(×)B)[i, j] = A[i](×)B[j] と定義されるので、行列の係数圏はテンソル圏（半加法的な半環圏）。形式テンソルは、射の成分 f[i, j→k]:A[i](×)B[j]→C[k] 達で定義される。

テンソル圏（半テンソル圏と呼ぶべきかも）に係数を持つ形式テンソルをストリング図で示すなら、上と下に複数のワイヤーが出たオダンゴ。

右：古典テンソル計算でいう「添字の上げ下げ」。fが形式テンソルとのとき、ケリー双対のベントを使ってワイヤーの方向を曲げることができる。これは乗法的トレース（縮約）にもつながる。

*1209779318*[高次圏論][雑感]Think weakly

一貫性がよくわからん。けど、なんでもかんでもweak版で考えて、一貫性条件を書き下してみるといいみたい。

*1209780713*[モノイド圏]半環圏の構造射

(C, +, 0)に関する結合性同型（associator）、単位性同型（unitor）、対称（symmetry, permutation symmetry, symmetric braiding）を、β、η&lt;sup&gt;L&lt;/sup&gt;、η&lt;sup&gt;R&lt;/sup&gt;、σとする。ηの上付きL, Rは左と右を表す。

(C, ×, 1)に関する結合性同型、単位性同型は、α、ε&lt;sup&gt;L&lt;/sup&gt;、ε&lt;sup&gt;R&lt;/sup&gt;とする。×に関しての対称性は仮定しない。

δ&lt;sup&gt;L&lt;/sup&gt; = δ&lt;sup&gt;L&lt;/sup&gt;&lt;sub&gt;A,B,C&lt;/sub&gt; :A×(B + C) → A×B + A×C を分配性同型（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080502/1209700356&quot;&gt;distributor&lt;/a&gt;）と呼ぶ。

さらに、0・a = 0 などに相当する法則が必要で、ζ&lt;sup&gt;L&lt;/sup&gt;&lt;sub&gt;A&lt;/sub&gt;:0×A→0 などの同型を考える。左右のζを零性同型と呼ぶことにする。

半環圏は、まずは2つのモノイド構造を持つ。それぞれのモノイド構造を独立に考えてモノイド圏として一貫性が必要。それ以外に分配性（分配法則）と零性（零法則）に関する一貫性も要る。少し書き出してみた（なぜか、対象は小文字、積はナカグロ）。

&lt;img src=&quot;http://www.chimaira.org/img2/semiringal-coherence.gif&quot; &gt;

*1209782107*[圏一般論][トレース／コンパクト閉圏]対蹠の一貫性

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177562726&quot;&gt;対蹠作用素&lt;/a&gt;（antipodal operator）の弱いバージョンを考える。モノイド積は並置で表す。

+ τ&lt;sub&gt;A&lt;/sub&gt;:A&lt;sup&gt;##&lt;/sup&gt;→A
+ ι:I&lt;sup&gt;#&lt;/sup&gt;→I
+ δ&lt;sub&gt;A,B&lt;/sub&gt;:(AB)&lt;sup&gt;#&lt;/sup&gt;→B&lt;sup&gt;#&lt;/sup&gt;A&lt;sup&gt;#&lt;/sup&gt;

とりあえず思いつく一貫性。可換図式じゃなくて、棚みたいな書き方をする。

&lt;pre&gt;
 I&lt;sup&gt;##&lt;/sup&gt;
 ↓(ι)&lt;sup&gt;#&lt;/sup&gt;
 I&lt;sup&gt;#&lt;/sup&gt;
 ↓ι
 I

equals

 I&lt;sup&gt;##&lt;/sup&gt;
 ↓τ&lt;sub&gt;I&lt;/sub&gt;
 I
&lt;/pre&gt;

&lt;pre&gt;
 ((AB)C)&lt;sup&gt;#&lt;/sup&gt;
 ↓δ
 C&lt;sup&gt;#&lt;/sup&gt;(AB)&lt;sup&gt;#&lt;/sup&gt;
 ↓C&lt;sup&gt;#&lt;/sup&gt;δ
 C&lt;sup&gt;#&lt;/sup&gt;(B&lt;sup&gt;#&lt;/sup&gt;A&lt;sup&gt;#&lt;/sup&gt;)

equals

 ((AB)C)&lt;sup&gt;#&lt;/sup&gt;
 ↓(α')&lt;sup&gt;#&lt;/sup&gt;
 (A(BC))&lt;sup&gt;#&lt;/sup&gt;
 ↓δ
 (BC)&lt;sup&gt;#&lt;/sup&gt;A&lt;sup&gt;#&lt;/sup&gt;
 ↓δA&lt;sup&gt;#&lt;/sup&gt;
 (C&lt;sup&gt;#&lt;/sup&gt;B&lt;sup&gt;#&lt;/sup&gt;)A&lt;sup&gt;#&lt;/sup&gt;
 ↓α
 C&lt;sup&gt;#&lt;/sup&gt;(B&lt;sup&gt;#&lt;/sup&gt;A&lt;sup&gt;#&lt;/sup&gt;)
&lt;/pre&gt;

*1209783778*[まとめ][トレース／コンパクト閉圏]ケリー双対といろいろな圏

ケリー双対については、http://d.hatena.ne.jp/m-hiyama-memo/20070331 に書いてある。直進圏は http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177562726、軸的圏は http://d.hatena.ne.jp/m-hiyama-memo/20070329/1175144493 。

|*種類       |*左双対 |*右双対 |* 左＝右 |* 対蹠 |* 射の双対 |
|モノイド圏  | -      | -      | -       | -     | -         |
|左自立圏    | 在り   | -      | -      | 定義可能| 定義可能 |
|右自立圏    | -      | 在り   | -      | 定義可能| 定義可能 |
|両側立圏    | 在り   | 在り   | -      | 2つ定義可能| 2つ定義可能 |
|自足圏      | 在り   | 在り   | 成立   | 一意に定義可能| 2つ定義可能 |
|直進圏      | 定義可能| 定義可能  | 成立   | 在り| 2つ定義可能 |
|軸的圏      | 定義可能| 定義可能  | 成立   | 在り| 一意に定義可能 |

*1209793912*[小咄][高次圏論]バエズのNegative Thinking

&quot;Lectures on n-Categories and Cohomology&quot; http://arxiv.org/abs/math/0608420 は、バエズ（John C. Baez）の講演をシャルマン（Michael Shulman; マイケルかミハエルか？）がまとめたもの。バエズはホントに面白い話をする。

P.10からP.13を読んだだけだが、次の観察からnegative dimensionの圏をひねり出す。

&lt;b&gt;バエズの観察：&lt;/b&gt;x, yは、n-圏の共端（後述）なj-射だとする。そのとき、hom(x, y)は (n - j -1)-圏である。

これを導くために、

+ 圏の次元の格上げ。n-圏を(n+1)-圏となす方法。
+ 小宇宙への次元降下。n-圏のhom-thingは (n-1)圏であること。

つまり、&lt;b&gt;n-Cat&lt;/b&gt;は&lt;b&gt;(n+1)-Cat&lt;/b&gt;に標準的に埋め込めるし。n-圏は&lt;b&gt;(n-1)-Cat&lt;/b&gt;豊饒化されている、ということ。基本的には、バタニンのglobularアプローチにより強n-圏を考える。

「共端」とは、バエズの言葉だと平行（parallel）。始セルと終セルが一致する2つのセルを共端と呼ぶ。

- xとyのあいだに射があるかどうかを議論できる ⇔ xとyは共端 ⇔ hom(x, y)が意味を持つ
</body>
</day>
<day date="2008-05-07" title="">
<body>
*1210115820*[高次圏論][用語法][モナド][課題]オペラッド、複圏、モナドの複グラフ

トム・レインスター（TOM LEINSTER）の&quot;OPERADS IN HIGHER-DIMENSIONAL CATEGORY THEORY&quot; (2004)を&lt;em&gt;ほんの少し&lt;/em&gt;読んだ。

オペラッドって言葉を目にしたことはあっても、ほとんど知らない。レインスターによると、&lt;em&gt;複圏と同じ&lt;/em&gt;らしい。対象が１つしかない複圏を特にオペラッドと呼んでいるようだ。用語オペラッドが一般化した結果、複圏を色付きオペラッド（coloured operad, clored operad）と呼ぶ人もいるようだ。coloured operadのcolours (colors)が複圏の対象類になるらしい。

|* オペラッド派   |*  複圏派 |
| プレーン（plain）オペラッド|  対象が1つの複圏 |
| 色付きオペラッド | 一般の複圏 |

オペラッド／複圏の射はアロー、マップ、multimapと呼ばれることが多いようだ。複射（multimorphism）と呼んでもよさそうだが、あんまり使われていないのかな？

レインスターはアンビエント圏C上のモナドTに対するT-グラフをベースにしている。T-グラフGは、アンビエント圏C内の TA←B→A、A→B という図式対でdom, cod, idを与えるもの。TがSetの恒等モナドならT-グラフは普通の小さいグラフとなる。Tが列モナドのとき普通の複グラフ（ハイパーグラフの特殊ケース）となる。複圏は複グラフ上のモノイド的構造となる。

T-グラフ上にT-複圏が定義できる。A=1として、T1←B→1, 1→B を考えてT-オペラッドが定義できる。アンビエント圏Cも明示すれば、(C, T)-複圏、(C, T)-オペラッドなど。アンビエント圏がCatのとき、圏Cから道の圏Path(C)（またはPath&lt;sub&gt;+&lt;/sub&gt;(C)）を作るモナドをTとしてのT-複圏はどうなるかな？

*1210116149*[高次圏論][プログラム意味論]双模倣の定義

セリンガーの http://www.mathstat.dal.ca/~selinger/papers/catasynch.pdf などを参考に、ラベルなし（単純）のケースで述べておく。

s, s'∈S, t, t'∈T、双模倣を与える関係をR⊆S×T、遷移（1ステップ）を矢印で表す。また xRx' を x～x' で示す。

+ s～t, t→t' ならば、s'～t', s→s' となるs'がS内にある。
+ s～t, s→s' ならば、s'～t', s→s' となるt'がT内にある。

以上が強双模倣の定義になる。普通の遷移以外に、無音遷移 x…→x' が定義されていれば、弱双模倣も定義できる。が、とりあえずラベルなしのケースでは強双模倣だけを考える。

SがTをRにより模倣できるとは、双模倣の半分の条件が成立すること：

- s～t, t→t' ならば、s'～t', s→s' となるs'がS内にある。

遷移グラフとしてT⊆S（Tは部分グラフ）のとき、Sは包含によりTを模倣できる。これが典型例。

模倣可能性は、遷移系全体の集まりにプレ順序を入れる。このプレ順序は、模倣を射とする圏を2値化して得られるやせた圏のことだ。プレ順序から導かれる同値関係が振る舞い同値を与え、同値類が振る舞い型となる。

*1210116542*[気付いた][高次圏論][プログラム意味論]高次遷移系と模倣

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070519/1179562343&quot;&gt;高次オートマトン&lt;/a&gt;とかはあまり意味があるように思えなかった。が、そうでもない、役に立ちそう、と気付いた。

まずは基本的用語を準備； 有向グラフにさらに有向2-セルを考えた構造を2-グラフと呼ぶことにする。ただし、2-セルの形状が色々あるから区別しなくてはならない。とりあえず、矩形セルを考える（下図）。
&lt;pre&gt;
 x → x'
 ｜  ｜
 ↓  ↓
 y → y'
&lt;/pre&gt;

x→x' と y→y' が水平1-セル、それと2つの垂直1-セルで囲まれた部分が2セルで、(x→x')⇒(y→y') という方向で考える。この2-セルにαと名前を付けると、α::(f:x→x')⇒(g:y→y') と書ける。ちなみに、このような矩形2-グラフ上に各種の演算を考えると二重圏になる。二重圏を使った定式化はタイルアプローチ。

2-グラフは矩形2-セルを持つとして、境界付きの2-遷移系を次のように考える。X, Yは1-遷移系、Bは2-遷移系、B&lt;sub&gt;1&lt;/sub&gt;を2-遷移系の1-骨格（2セルをすべて忘れる）だとする。i;X→B&lt;sub&gt;1&lt;/sub&gt;, j:Y→B&lt;sub&gt;1&lt;/sub&gt; が1-遷移系の射になっているとき、これらが作る構造を境界付き2-遷移系と呼ぶ。境界付き1-遷移系の自然な拡張だ。

さて、Bとして最も簡単なものは、XとYを結ぶ二部2-グラフのときだろう。X, Yが二部1-グラフのときは、ハイパー二部グラフ、X, Yを行列と考えればハイパー行列となる。つまり、境界付き2-遷移系はハイパー行列の一般化でもある。

さらに、X, Yが任意の1-グラフ（＝ラベルなしの遷移系）のとき、(X, Y)二部2-グラフは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210116149&quot;&gt;模倣&lt;/a&gt;を与える。ここはもう少し確認する必要があるが、模倣、双模倣を高次グラフ／高次圏で定式化できそうだ。

*1210125976*[高次圏論][お絵描き][具体例]2角柱状の3-セル

そういえば、次のような絵を描いた。行列または形式テンソルの計算で3ーセルが登場する。その状況の絵だね。

&lt;img src=&quot;http://www.chimaira.org/img2/cylindrical-morph.gif&quot; &gt;

AとA'はシェイブ（プロファイル）が I→J である半環圏の対象を係数とする行列。αはアダマール2-セル -- つまり、αもI→J型の行列だが、成分が同じ半環圏の射であり、縦結合は行列のアダマール積で与えられる。βも同様にアダマール2-セル。

ΦはAからA'へのハイパー行列。つまり、I×JとK×Lを両端とする完全二部グラフの各辺に、係数圏の射を対応させたもの。これも一種の2-セルで、Φ::A⇒B と書ける。係数圏がプレ半加法的ならば、ハイパー行列の結合は定義できる。Φ'も同じく A'⇒B' である2-セル。

(i, j)∈I×J, (k, l)∈K×L をとると、α、β、Φ、Φ' により、係数圏の四角形ができる、これがすべて可換のとき、ΦとΦ'の組は、αからβへの射だとする。すると、(Φ, Φ')は、2-セルと2-セルのあいだをつなぐから3-セルということになる。2角形（2辺形）を底面とする柱体の形をしている。

*1210155603*[圏一般論][用語法]初歩的圏（rudimentary category）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080416/1208352842&quot;&gt;自然数が対象の圏&lt;/a&gt;、なんか定着した用語がないようだな。ローヴェルの代数的理論（Lawvere's algebraic theory）もその例だし、行列圏もその例、単体圏も（代数的理論だからもちろん）そう。n個の円周を境界とする曲面の圏をコンパクト閉圏と考えればこれも例になる。単一対象と適当な射で生成された厳密対称モノイド圏も事例となる。

|&lt;i&gt;C&lt;/i&gt;| = &lt;b&gt;N&lt;/b&gt;だと、なにかと扱いやすい。うーむ、、、、、 初歩的圏（rudimentary category）なんてどうだろう？ 初等的（elementary）は別な意味があるから、初歩的にした。

</body>
</day>
<day date="2008-05-08" title="">
<body>
*1210236595*[高次圏論][計算]ハイパー行列（R-Ω 2-セル）の計算

RとΩは半環。RからΩへの縮約と呼ばれる半環射χがあるとする。具体例としては、R=&lt;b&gt;N&lt;/b&gt;、Ω={0, 1}、χ(0) = 0, それ以外はχ(n) = 1とする。

R係数の行列A、Bがあるとする。A∈Mat&lt;sub&gt;R&lt;/sub&gt;(n, m), B∈Mat&lt;sub&gt;R&lt;/sub&gt;(k, l)。P∈Mat&lt;sub&gt;Ω&lt;/sub&gt;(n, k), Q∈Mat&lt;sub&gt;Ω&lt;/sub&gt;(m, l)の組(P, Q)を考える。RからΩへの縮約を使えば、行列P;χ(B);Q&lt;sup&gt;T&lt;/sup&gt;やP&lt;sup&gt;T&lt;/sup&gt;;χ(A);Qを定義できる。ここで、行列へのχ作用は、成分にすべてχを作用させたもの。右肩Tは行列の転置。

P&lt;sup&gt;T&lt;/sup&gt;;χ(A);Q ⊆ χ(B) が成立しているとき、(P, Q)を A⇒B というハイパー行列だと考える。ハイパー行列は、2次元の矩形シート（膜、ハイパー辺、2-遷移）をハイパー辺とする二部ハイパーグラフと解釈できる。

行列とハイパー行列の総体は、行列のサイズを与える自然数を0-セル、R係数行列を1-セル、R-Ωハイパー行列を2-セルとする二重圏となる。2-セルの縦結合はΩ行列の掛け算、横結合はR行列の掛け算を使って定義する。

*1210237965*[モナド][具体例]圏論的閉包作用素／余閉包作用素

あとで描く。


</body>
</day>
<day date="2008-05-09" title="">
<body>
*1210310188*[ホッピングボール][小咄][計算]半環Pow(&lt;b&gt;N&lt;/b&gt;)の計算

本編のほうでホッピングボール・マシンの話を書き出した。これは、境界付き遷移系でラベル（アクション名）集合が単元に退化した例。加法モノイド&lt;b&gt;N&lt;/b&gt;を圏と見なしての境界付きカテグラフだとも言える。全体として、モノイド構造を持った&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210155603&quot;&gt;初歩的圏&lt;/a&gt;になるように細工している。

で、メモ編の分類カテゴリーに「ホッピングボール」を追加して、ホッピングボール・マシン関係のメモとする。

さて、ホッピングボール・マシンFがあると、その振る舞いBeh(F)は半環Pow(&lt;b&gt;N&lt;/b&gt;)を係数とする行列になる。Behは、Pow(&lt;b&gt;N&lt;/b&gt;)係数の行列圏への厳密モノイド関手となる。その係数半環Pow(&lt;b&gt;N&lt;/b&gt;)の話だけど、加法は集合和∪、問題は情報・のほうで、次のように定義する。

- A・B = {n∈&lt;b&gt;N&lt;/b&gt;| a + b = n となるa∈A, b∈B がある}

A・B = {a + b | a∈A, b∈B }といっても同じ。一般化すると、モノイドM上に半環Rに値をとる関数半環R[M]を考えて、積を畳み込みでいれる。つまり、

- (f・g)(z) = Σ[z = x*y | f(x)g(y) ]

z = x*y となるx, yの組が無限個あるときは、Σとして総和構造や積分が必要。モノイドMが&lt;b&gt;N&lt;/b&gt;の足し算、Rを{0, 1}にしたときが当該の例。

ところで、Pow(&lt;b&gt;N&lt;/b&gt;)は、実数区間[0, 1]の二進小数展開と&lt;em&gt;だいたい&lt;/em&gt;1対1に対応する。[0, 1]の実数と見ると、掛け算・は、通常の位取り方式の筆算と同じ。ただし、足し算に繰り上がり（桁上がり）がない。つまり、普通の計算と少し違うが、Pow(&lt;b&gt;N&lt;/b&gt;)の計算は[0, 1]実数の筆算として再現される。

</body>
</day>
<day date="2008-05-10" title="">
<body>
*1210401251*[ホッピングボール][小咄][説明]半環Pow(&lt;b&gt;N&lt;/b&gt;)と同型な半環&lt;b&gt;B&lt;/b&gt;と、とあるアナロジー

いずれにしてもPow(&lt;b&gt;N&lt;/b&gt;)に∪と・を入れた半環を使うのだけど、{x∈&lt;b&gt;R&lt;/b&gt; | 0≦ x ＜2} に、足し算／掛け算を入れた代数を使っても同じ。こっちのほうが親しみがわくかもしれない。固有名詞を&lt;b&gt;B&lt;/b&gt;にしておこう。文字Bに特に意味はない。

通常の数と、Pow(&lt;b&gt;N&lt;/b&gt;)や&lt;b&gt;B&lt;/b&gt;のあいだには、次のようなアナロジーがある。

|* 普通の数 |* Pow(&lt;b&gt;N&lt;/b&gt;)  |* &lt;b&gt;B&lt;/b&gt; |
| 整数      | 有限集合        |有限小数  |
| 有理数    | 正規集合        |循環小数  |
| 整係数1次方程式 | 有限的再帰方程式 | 有限的再帰方程式 |

整係数1次方程式と再帰方程式の対応のところがなんかアヤシイけど。

[http://d.hatena.ne.jp/m-hiyama-memo/20080516/1210893628:title], [http://d.hatena.ne.jp/m-hiyama-memo/20080516/1210902616:title]も参照。

*1210402223*[ホッピングボール][用語法]振る舞い同値

ホッピングボール・マシンFに対して、その振る舞い行列をBeh(F)として、F≡G :⇔ Beh(A) = Beh(G) と定義して、F≡G とは何であるか？を分析したい。

ところがまた、&lt;em&gt;用語の問題&lt;/em&gt;がある。F≡G を振る舞い同値（behavioural equivalence）と呼びたいが、通常の振る舞い同値はこんな定義ではない。Sが遷移系として、台集合もSで示す。x, y∈S が振る舞い同値とは、どんな可視コンテキストcに対しても c(x) = c(y) であること。cは可視なので、c(x)の値は可視な値であり、イコールも可視値に対する（ホントの）等しさである。

遷移系SとTが同じ指標を持つなら、可視コンテキストの集合（試験集合とか実験観察集合と呼んだほうが適切）は同じだから、x∈S, y∈T であっても、sとtが振る舞い同値であることは定義できる。S, Tが初期状態をただ1つ持つような遷移系なら、(S, x), (T, y)がシステムとして振る舞い同値なことを、点xと点yが振る舞い同値であることにより定義できる。

よって、振る舞い同値性は、必ずしも状態点に限定せずに使えるのだが、初期状態が複数あるシステムだと定義がやや難しくなる。I⊆S, J⊆Tとして、(S, I), (S, J)が振る舞い同値は、x∈Iに対して、y∈J が存在して(S, x)と(T, y)が振る舞い同値になることだろう。

模倣可能（simulatable）とか互いに模倣可能（mutually simulatable）とかも既存用語と食い違うかもな。僕は次が同じ意味でもいいと思っているが：

+ 2つのシステムが振る舞い同値
+ 2つのシステムが互いに模倣可能
+ 双模倣関係（bisimulation relation）が存在する
+ 双模倣的（bisimular）

</body>
</day>
<day date="2008-05-12" title="">
<body>
*1210550763*[ホッピングボール]TTL付きのボールと言語の受理問題

言語の受理（認識）問題に対応する問題は、time to live付きのボールを落として、どこからでもいいから出てくるかどうかを見るだけでよい。出てこない場合は、絶対に出てこない運命かたまたま出てこなかっただけかのケースがある。「たまたま出てこなかっただけ」なら「いずれは出てくる」

前もってボールのTTLがわかれば、待ち時間は確定するので、1試行あたりの時間は有界。

</body>
</day>
<day date="2008-05-13" title="">
<body>
*1210668805*[ホッピングボール][用語法]behavioral/behaviorallyとobservational/observationally

どうも確実な区別の根拠が見あたらないなー。behavioral equivalence と observationally indistinguishable って結局は同じことで、その使い分けも恣意的なんじゃないのかな？

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20060825/1156469121&quot;&gt;「はじめての圏論 その第5歩：変換キューの圏」&lt;/a&gt;では、次のような使い分けを意識した。

- 2つのシステムが振る舞い同値：広義、双模倣的と観測的に識別不可能の2つに分けられる。
- 2つのシステムが観測的に識別不可能：狭義、ブラックボックスとして、実験・観察を通しては区別できない。ブラックボックスとしては置き換え可能である。
- 2つのシステムが双模倣的： 状態空間のあいだに双模倣関係（bisimulation relation）が存在する。ブラックボックス的定義ではない！

さらに、振る舞い同値や観測的に識別不可能なモノが何であるかの問題がある。次の用法がある。

+ 状態空間S内の2点s, s'が振る舞い同値or観測的に識別不可能
+ 状態空間S, T内の2点s, tが振る舞い同値or観測的に識別不可能
+ 2つのシステムが振る舞い同値or観測的に識別不可能

開始状態が1点であるシステム（遷移系）なら、2番目と3番目の定義は同じことになる。


</body>
</day>
<day date="2008-05-14" title="">
<body>
*1210737641*[トレース／コンパクト閉圏][形式言語理論]自由コゥゼン圏（Kozen圏）

コゥゼン圏は、トレースを持つベキ等・双デカルト圏のこと（だとしたが、ベキ等を落としてもいい気もするが）。圏的指標Σがあるとき、Σから自由コゥゼン圏FK(Σ)を作れる。FK(Σ)は、Σの正規表現全体の代数に対応し、FK(Σ)の射は正規表現。

圏的指標Σはグラフと考えてよい（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070605/1181014022&quot;&gt;プレ圏&lt;/a&gt;だと考えるのが正確）。アンビエント・コゥゼン圏C（意味領域）を適当に固定して、グラフ準同型γ:Σ→C があるとする。γはFK(Σ)→C のコゥゼン関手に拡張できる。コゥゼン関手は“コゥゼン圏の圏”の射、トレース付き双デカルト構造を保つ関手。γの拡張Γによる射の像は「正規表現の意味」を与える。

もちろん、忘却関手U:KozenCat→Graphと自由生成関手FK:Graph→KozenCatは随伴。

*1210737642*[ホッピングボール][小咄]&lt;b&gt;N&lt;/b&gt;上の周期関数と周期集合

f:&lt;b&gt;N&lt;/b&gt;→X（Xは何でもいい）が周期的だとは、f(n + p) = f(n) となるpがあること。集合A⊆&lt;b&gt;N&lt;/b&gt;の特性関数が周期的ならAは周期的集合。Xが半環のとき、f + g, f*g（畳み込み）の周期はどうなる？

- (α&lt;sub&gt;k&lt;/sub&gt;f)(n) = f(n - k) if definable else 0
- (δ&lt;sub&gt;k&lt;/sub&gt;f)(n) = f(n + k)

このα、δの作用、有界台の関数との和とか畳み込みとかを考える。

*1210746767*[人物]コリーナ・シルステア（Corina Cirstea）

URL: http://www.ecs.soton.ac.uk/people/cc2

Cirsteaはルーマニアの姓らしく、シルステアと読むようだ。

*1210760598*[トレース／コンパクト閉圏][ホッピングボール][気付いた]トリビアルが役に立つ話 -- トレースがそのままスターになる

&lt;b&gt;[追記]&lt;/b&gt;このエントリー、かなり間違いが含まれる。が面白いところもある。明かな間違いは消し線付ける。&lt;b&gt;[/追記]&lt;/b&gt;

Cは単一対象の圏だとする。つまり、|C| = {*}で、Cは結合;に関してモノイド。Cの対象には *×* = * というトリビアルな積を入れて、Cはモノイド圏になっているとする。つまり、Cは;と×という2つのモノイド演算を持つ代数系。積×は対称だとするとこれは可換演算。さらにCにトレースが入っているなら、f:*→*は、f:*×*→*×* とみなして、Tr(f):*→* となるから、TrはC上にwell-definedな単項演算とみなせる。

&lt;b&gt;[追記]&lt;/b&gt;&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080305/1204685712&quot;&gt;モノイダルモノイド&lt;/a&gt;にエクマン／ヒルトンの手法を適用して、モノイド積は結合と一致する。よって、cup-plus代数のcupはモノイド積ではない。そうじゃなくて、AbMon豊饒化されたhom-setだと考えて、そのAbMon演算がcupってことだな。&lt;b&gt;[/追記]&lt;/b&gt;

別なトレース付き圏Eがあって、関手L:E→Cがモノイド関手であり、かつトレースも保つとする。対象のレベルでは|E|→{*}はトリビアルになるので、g∈Eがどんな射であっても、L(Tr(g)) = Tr(L(g)) のようになる。

さて、こんな定式化が何の役にたつのか？ 形式言語理論のポンプの補題やパリクの定理を自然に証明できる。以下に、ホッピングボール・マシンの文脈で語ってみる。

Gは境界付き有限グラフとすると、Gは適当な境界付きアサイクリックグラフH（または、被覆有限ヘッジH）に対してTr(H)の形に書ける。これは、（辺に0, 1でラベルした）境界付き有限グラフの圏を、直和とルーピングでトレース付き圏と考えれば、Gの構造に関して帰納法により証明できる。この帰納法が使えるのは、この圏が自由トレース付き圏だから。証明を簡略化したいなら、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210155603&quot;&gt;初歩的圏&lt;/a&gt;の範囲で定式化するとよい。

G境界を繋ぐすべての道（軌道）に対して、その長さとなる自然数の集合をL(G)とする。L(G)はPow(&lt;b&gt;N&lt;/b&gt;)を台とするエキゾチック代数だが、&lt;s&gt;∪をモノイド積、+を結合とした&lt;/s&gt;モノイド圏ともみなせる。クリーネスターがこの圏のトレースを与えて、結局Pow(&lt;b&gt;N&lt;/b&gt;)をトレース付き圏だとみなせる。

関手Lはトレース付きモノイド関手だから、G = Tr(H) をL(G) = Tr(L(H)) に移す。アサイクリックグラフと&lt;b&gt;N&lt;/b&gt;の有限集合が対応するから、Tr(L(H))は有限集合のクリーネスターになる。あとは、有限集合のクリーネスターがどんな集合かを見ればよい。

以上、細かい点でイイカゲンなのだが、L(G)=Length(Path(G)) をトレース付きモノイド関手とみなすところがミソ。すごく具体的に見るところは、&lt;b&gt;N&lt;/b&gt;の部分集合で、等差数列の有限合併（準アフィン集合）で書けるものは、有限部分を除いて周期的な集合であること； それと、有限集合のクリーネスターが等差数列の有限合併の形をしていること。

ここらへんの具体的観測の背後には、&lt;b&gt;N&lt;/b&gt;や&lt;b&gt;N&lt;/b&gt;&lt;sup&gt;k&lt;/sup&gt;という空間の準アフィン集合が実は正規集合であり、可換クリーネ代数の元でもある事実がある。

僕は今まで、単一対象のクリーネ圏にはモノイド積が入らない（つうか、入れてもしょうもない）と思っていたが、トリビアル積なら入るし、これがすごく役に立つようだ。トリビアル積はデカルト積や余デカルト積ではないが、それでもかまわない。トレース付きデカルト圏の範囲で考えるのではなくて、単に“トレース付きモノイド圏の圏”で考えればよい。

トレースからスターに至る道として、 f&lt;sup&gt;*&lt;/sup&gt; = Tr(∇;f;Δ)  以外にも、f&lt;sup&gt;*&lt;/sup&gt; = Tr(f) というトリビアルな手もあったわけだ。

一般のラベル付き遷移系に関して、ポンプの補題／パリクの定理の完全に圏論的な証明もできそうだ。&lt;b&gt;[追記]&lt;/b&gt;ポンプの補題とパリクの定理では事情がかなり異なる。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2008-05-15" title="">
<body>
*1210834243*[プログラム意味論][圏一般論][高次圏論]Path Rewriting SystemとPR-Precategories

パス書き換え系（Path Rewriting System; PRS）は項書き換え系（TRS）の一般化。次のものから構成される。

+ 0セルの集合V
+ 1セルの集合E、VとEでグラフになる。
+ 書き換えと呼ばれる2セルの集合
+ 書き換えの結合（合成）と代数的な法則

f, g, hなどが1セルだととして、隣接する（グラフの意味で）で1セルの列[f, g, h]などをパスと呼ぶ。パスに含まれる1セルの個数を長さとする。[]は長さ0のパス、[f]は長さ1のパス。書き換えα:F⇒G は、共端（バエズの用語では平行）なパスF, Gのあいだを結ぶ。Fの長さ=n, Gの長さ=m もとき、αを&lt;strong&gt;n-m書き換え&lt;/strong&gt;と呼ぶ。

2セルである書き換え達の反射的推移的閉包を考える。この閉包の2セルも書き換えと呼ぶ。αがFからGへの広義の書き換えのとき、α:F⇒* G と書く。

F, Gが共端なパスとして、α:F⇒* G、β:G⇒* G があるとき、F≡G と書いて、FとGは合同と呼ぶ。α:F⇒* H、β:G⇒* H となるα, β, Hがあるとき、F～G と書いて、FとGはj弱合同と呼ぶ。書き換え系が合流性を持つなら、弱合同は同値関係になる。

次に、特殊なパス書き換え系を考える。書き換えは、0セル（の一部）でインデックスされた1-0書き換えと、長さ2のパス（の一部）でインデックスされた2-1書き換えが与えられている。これをもとに、長さnのパス（の一部）に対して、n-(n-1)書き換えが構成できる。この書き換えに基づいて、弱合同を定義できる。このとき、

+ 最初に与えられて書き換えの集合は、単位律と結合律を満たす。
+ 弱合同は同値関係になる。

このような性質を持つPRSを&lt;strong&gt;PRプレ圏&lt;/strong&gt;（PR-precategory）と呼ぶ。PRプレ圏があれば、そのパス圏を弱合同で割り算して圏を構成できる。この圏が、もとのPRプレ圏の自由圏となる。自由圏を作る関手は、ベキ等モナドになる。

*1210836690*[その他代数][ホッピングボール]半線形代数

主に&lt;b&gt;N&lt;/b&gt;を係数半環とする半線形代数を考えておくといいと思った。基本概念は：

+ 係数半環／半体
+ 半加群／半ベクトル空間
+ 部分半加群
+ 半線形独立
+ 半イデアル
+ 半アフィン空間／半アフィン集合
+ 半アフィン不動点方程式

半体の例はあまり多くない（&lt;b&gt;Z&lt;/b&gt;+{∞}に、min-plus代数とか）ので、ベクトル空間にこだわってもしょうがない。半線形代数＝半加群の理論。

Mが半加群、A⊆Mが半線形独立とは、

- どのy∈Aも、A＼{y}の半線形結合では書けない。

Rが半環のとき、I⊆Rが半イデアルとは、

+ 0∈I
+ x, y∈Iならば、x+y∈I

半イデアルは、R内の部分半加群。任意のA⊆Rは半イデアルを生成する。

Mが半加群で、Nが部分半加群のとき、b∈Mにより、b+N と書ける集合は半アフィン集合と呼ぶ。

&lt;b&gt;N&lt;/b&gt;, &lt;b&gt;N&lt;/b&gt;&lt;sup&gt;k&lt;/sup&gt;の部分集合をcup-plus代数で半環とみなすときの半イデアルの概念、k&lt;b&gt;N&lt;/b&gt; = &lt;b&gt;N&lt;/b&gt; + ... + &lt;b&gt;N&lt;/b&gt; の部分集合に、Pow(&lt;b&gt;N&lt;/b&gt;)をk倍にコピーして作用させるスカラー乗法により、Pow(k&lt;b&gt;N&lt;/b&gt;)はPow(&lt;b&gt;N&lt;/b&gt;)半加群とみなせる。この半加群の部分半加群や半アフィン集合の概念は？


</body>
</day>
<day date="2008-05-16" title="">
<body>
*1210893628*[形式言語理論][ホッピングボール][その他代数]スター有理性

Tを項だとして、ρx.T を、方程式 T = 0 を満たす解の1つだとする。

|*代数的有理性    |*   スター有理性 |
|1次方程式  ax + b = 0 | 一次不動点方程式 ax + b = x|
|  ax - 1 = 0 の解 | ax + 1 =  x の解|
|  a&lt;sup&gt;-1&lt;/sup&gt; | a&lt;sup&gt;*&lt;/sup&gt; |
| b/a =  ba&lt;sup&gt;-1&lt;/sup&gt; | ba&lt;sup&gt;*&lt;/sup&gt;, a&lt;sup&gt;*&lt;/sup&gt;b |
| ρx.(ax - b) | μx.(ax + b) |

再帰代数、あるいは不動点代数とでも呼べる構造があって、それがμ半環、さまざまなスター半環として定式化されている。アフィン1次不動点方程式は、まさにアフィン1次代数方程式の対応物で、有理性の概念を定める。このスター有理性は正規性に他ならない。

*1210902616*[ホッピングボール]グラフと行列の対応関係

|*境界付き0-1ラベル付きグラフの圏 |* 行列の圏 |
| 境界なし | 0×0行列 |
| 入り口1つ | 縦ベクトル |
| 出口1つ   | 横ベクトル |
| 出口1つ入り口1つ | 1×1行列≒スカラー |
| 直和 | 対角和 |
| 結合 | 積 |
| フィードバック | 加法的トレース |
| 模倣可能性  | 順序 |
| 互いに模倣可能 | 等しい |
| 完全フィードバック・モニター |  クリーネ閉包 |

*1210903872*[形式言語理論][トレース／コンパクト閉圏]正規射の概念

クリーネ圏やコォゼン圏に関しては、正規表現と正規射（regular morphism）という概念を&lt;em&gt;相対的に&lt;/em&gt;に定義できる。

一番分かりやすいのはコォゼン圏だから、Cはコォゼン圏だとしよう。A⊆Cを任意の部分グラフとする。正確には、Cをプレ圏とみなして、部分プレ圏がA。Aから形式的に生成された自由コォゼン圏をFK(A)とする。FK(A)を作るには、プレ圏Aからの自由生成アルゴリズムを使う。FK(A)を作るさいに出てくる形式的な表現が正規表現。

正規表現は、FK(A)の射に対応する。正規表現が同値だとは、同じ射に対応すること。FK(A)は自由コォゼン圏なので、自然な関手KF(A)→Cがある。この関手の像に入る射は正規射と呼び、正規射の全体をReg(A, C)とする。Reg(A, C)はCの部分コォゼン圏となっている。

Cとして、アルファベットΣ上のすべての言語を係数とする行列からなる初歩的圏、Aとして、単元言語の集合をとると、古典的な正規言語の概念が得られる。正規射は、正規言語を係数とする行列で与えられる。特に1×1行列は正規言語そのものである。


</body>
</day>
<day date="2008-05-17" title="">
<body>
*1211002343*[課題][形式言語理論]クリーネっぽい圏や代数系のあいだの関係

いまだに僕は、クリーネ圏、コォゼン圏、クリーネ代数（クリーネ／コォゼン半環と呼ぶのがふさわしいと思う）の関係がよくわかってない。

次のことはわかる。

+ コォゼン圏はクリーネ圏である。
+ クリーネ圏のend-setはクリーネ代数である。したがって、コォゼン圏のend-setもクリーネ代数。
+ 単一対象のクリーネ圏はクリーネ代数である。
+ 単一対象のコォゼン圏は存在しない。
+ 単一対象から生成されたコォゼン圏はクリーネ代数係数行列圏と圏同値である。

- [http://d.hatena.ne.jp/m-hiyama-memo/20061024/1161648695:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20061024/1161670281:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20061109/1163049291:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20061204/1165193527:title]

*1211007594*[用語法][メモ法]クリーネに統一

「クリーニ」という読みは「クリーネ」に直した。クリーネも残っているが、検索は「クリーネ」だけでOK.

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%af%a5%ea%a1%bc%a5%cd

Kleene, Conway, Kozenなどを完全にカタカナ化はまだできてない。

*1211018339*[リンク][TQFT]これは面白い！

- http://www.cs.mcgill.ca/~prakash/Talks/mfps07.pdf

ダウンロードした。対応する論文は

- http://arxiv.org/abs/math/9805102

あたりかな。

発表者はパナンガデン（Panangaden, http://www.cs.mcgill.ca/~prakash/）。

*1211019913*[まとめ][圏一般論][形式言語理論]半加法性のいろいろ

まずはAb圏の定義から：

+ hom-setがアーベル群
+ 射の結合は双線形
+ 零対象を持つことは仮定しない（零射は存在する）。

次に加法圏：

+ Ab圏である。
+ 零対象を持つ。
+ 双積を持つ。

Ab圏をプレ加法圏（preadditive category）とも呼ぶ。

対応する「半」概念。
|* 加法性  |* 半加法性 |
|Ab        | AbMon |
|Ab圏      |AbMon圏 |
| -        |IAM(Idempotent AbMon)圏 |
|プレ加法圏  |プレ半加法圏 |
| - | 近半加法圏 |
| 加法圏 | 半加法圏 |
| -      |べき等半加法圏 |

- AbMon圏＝プレ半加法圏（pre-semiadditive category）
- 零対象を持つプレ半加法圏を近半加法圏と呼ぶ。
- 参照 [http://d.hatena.ne.jp/m-hiyama-memo/20080207/1202355652:title]

</body>
</day>
<day date="2008-05-19" title="">
<body>
*1211155050*[子供]引き算は難しい

次男にイデアルを生成させようとしたが無理だった。具体的には、二数（例えば3と5、次男は8と10を選んだが）から、足し算と引き算でいろいろな数を作る。

引き算が入るとダメみたい。足し算からの生成ならなんとか理解するようだ。足し算だけからの生成は半イデアル((半環のイデアルを思い切って半イデアルと呼んでしまえ。))。半イデアルはイデアルの部分になるが、もちろん一致はしない。

長男に三角形の面積を教えたが、これも引き算がネック。理解してない。詳細は後でまた書く（かもしれない）。


</body>
</day>
<day date="2008-05-20" title="">
<body>
*1211260084*[課題][復習][高次圏論][形式言語理論]コォゼン圏、クリーネ圏、二重圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070420/1177025950&quot;&gt;「(仮称)一様性二重圏」&lt;/a&gt;に書いてある内容がけっこう本質的な気がする。

コォゼン圏もクリーネ圏も、ほんとは二重圏で定式化すべきで、 潰れた（退化した）二重圏として圏（1-圏）が登場するのではないだろうか？ 潰れてない状態で扱った方が自然な気がする。

*1211268332*[ホッピングボール]ポンプの補題の変種

ホッピングボール・マシンが有限型（有限状態マシンと観測的に同値）なら、それから生成される&lt;b&gt;PN&lt;/b&gt;値（Pow(&lt;b&gt;N&lt;/b&gt;)の値）は、有限か、さもなくば等差数列を含む。

これから、素数の全体や{n&lt;sup&gt;2&lt;/sup&gt; | n = 1, 2, ...}, {2&lt;sup&gt;n&lt;/sup&gt; | n = 1, 2, ...}などは生成できない、とわかる。


</body>
</day>
<day date="2008-05-23" title="">
<body>
*1211508810*[気付いた][計算][トレース／コンパクト閉圏][高次圏論][マンダラ]二重圏と一様性、2-セルによる定式化

関連するエントリーは次：

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070420/1177025950&quot;&gt;(仮称)一様性二重圏&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070123/1169510881&quot;&gt;セリンガーのND補題&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061202/1165029369&quot;&gt;一様性を持つ部分トレース付き圏の周辺 &lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061201/1164960303&quot;&gt;一様性を持つ部分トレース付き圏（partially traced category with uniformity）&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163147851&quot;&gt;一様性原理 &lt;/a&gt;

次の言葉を使う。

- 一様射（uniform morphism）セリンガーに従う
- 一様クラス（uniform class） 一様射の全体
- 垂直射 本来二重圏の概念だが、境界を境界に移す射、入出力変換
- 垂直クラス 垂直射の全体

圏Cはトレース付きモノイド圏で、一様クラスUと垂直クラスHが指定されているとする。一様クラスは長谷川／セリンガー／ステファネスクなどが考察しているアレである。垂直クラスの最も簡単な例は、idだけからなるクラス（射の集まり）である。

Circ構成で、f:A+X→B+X を、f/X:A→B と書くことにする。f+g もf/g のような分数記法を使う。後の計算例では、A+Bは縦（Aが上）に並べるだけでf+gだけ分数にしている（統一性がないがいいとする）。f:A+X→B+Y が分数では書けない（f=f1+f2とならない）、または書く必要がないことを強調して A/X |f| B/Y のように書く（後の計算例を参照）。計算記法が未成熟だが、今のところ、こういう暫定記法を採用している。

&lt;img src=&quot;http://www.chimaira.org/img2/uniform-2cell.gif&quot; &gt;

f/X:A→Bとf/Y:A'→B'がCのCirc圏の射だとする。もちろん、Cで見れば f:A+X→B+X、g:A'+Y→B'+Y ということ。α=α/uがf/Xからg/Yへの2-セルであるとは次のこと：

- a:A→A', b:B→B' は垂直射である。
- Cにおいて、f;(b+u) = (a+u);g が成立する。

αは (a, b, u)の3つ組となるが、特にuを強調してα/uとも書く。上の計算は、2-セルα、βの結合がまた2-セルになること。モノイド圏の交替律しか使ってないが、次の事実は仮定している。

- 垂直射の結合は垂直射
- 一様射の結合は一様射

つまり、U⊆C, H⊆C が部分圏となっている。この状況で2-セルは双模倣であり、一様性原理は次のように述べられる。

- Tr(f/X);b = a;Tr(g/Y) 

しかし、これでも一般性が不足。元の圏Cが2-圏だとして

- Cにおいて、φ::f;(b+u)⇒(a+u);g なら、ψ::Tr(f/X);b⇒a;Tr(g/Y) がある。

という形にしたい。上の状況で、 入力変換a、出力変換b、状態空間の模倣写像（simulation map）u、模倣関係φがあるとき、振る舞いのあいだにも模倣関係ψがあると解釈できる。φやψを関係と呼ぶと混乱しそうだから、模倣表明（simulation assertion）がいいかな。

*1211510352*[課題][プログラム意味論][トレース／コンパクト閉圏][高次圏論][マンダラ]マンダラ仮説と二重トレース付き半環二重圏

&lt;a href=&quot;二重圏と一様性、2-セルによる定式化&quot;&gt;マンダラ仮説&lt;/a&gt;は僕の作業仮説。だいたいはこういうこと； 計算科学に出てくる構造は、いたるところに無闇とたくさんの高次圏が含まれるであろう。

マンダラ仮説を前提とするなら（僕は当然に前提としている）、高次圏は必須。だが、高次圏は全然マジメにやってなかった。せめて、双圏と二重圏くらは使えないとな。

いまのところ、公理化は全然できなくて、現象論的にしか考えていない（それしかできない）。が、トレースが2つ付いた半環二重圏（semiringal double category）が出てくるのは間違いないだろう。掛け算を忘れて足し算のほうだけに注目すると、トレースが1つ付いたモノイド二重圏となる。

振る舞い関手と一様性原理は、トレース付きモノイド二重圏でも調べられる。コゥゼン圏とクリーネ圏の関係も二重圏で考えないとスッキリしない気がする。

</body>
</day>
<day date="2008-05-24" title="">
<body>
*1211599840*[課題][形式言語理論][トレース／コンパクト閉圏][インスティチューション]パリク圏とパリク関手

パリク・ベクトルを一般化して、正規集合に関するパリクの定理（本来は文脈自由文法に関する定理）を示したいものだ。

まず、Pow(&lt;b&gt;N&lt;/b&gt;&lt;sup&gt;n&lt;/sup&gt;)に、足し算∪と掛け算+で半環構造（cup-plus代数とでも呼ぶべきか）を入れる。クリーネ級数は収束するから、クリーネ連続半環（クリーネ級数が収束する半環）となる。クリーネ・スターが定義できて、これは可換クリーネ代数だとみなせる。この代数系をn-パリク半環（n-パリク代数）と呼ぼう。

nを固定してのn-パリク半環、またはすべてのnを同時に考えてパリク半環達はどんな圏論的構造を持つのだろう。それが定式化できればパリク圏と呼んでよいだろう。パリク・ベクトルをなんらかの関手とみなして、パリク関手と呼ぶ。パリク関手は、トレース付きモノイド圏、またはトレース付きモノイド圏の族（インスティチューション、インデックス圏）からパリク圏への関手となるべき。

パリク圏とパリク関手の基本性質からパリクの定理が自動的に出るようにならないだろうか。

*1211608677*[課題][形式言語理論][トレース／コンパクト閉圏]帰納原理と一様性原理

昨日のエントリー&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080523/1211508810&quot;&gt;「二重圏と一様性、2-セルによる定式化」&lt;/a&gt;の話だが、背景圏Cが局所順序付き圏（Ord豊饒化された圏）であるとする。すると、f;(b+u) ≦ (a+u);g in C(A+X, B'+Y)が意味を持つ。C(A+X, B'+Y) は、状態空間のあいだを飛ぶ転移（遷移とは区別しよう）とねじれた入出力を持つ系を意味する。

α=(a, b, u)が f;(b+u) ≦ (a+u);g を満たすとき模倣と呼び、不等式 f;(b+u) ≦ (a+u);g を模倣表明だとする。不当式による定義でも、模倣αとβの結合は再び模倣になる。一様性原理の不等式版は：

- f;(b+u) ≦ (a+u);g ⇒ Tr(f);b ≦ a;Tr(g)

帰納原理に少し近い形になる。帰納原理と一様性原理の関係を理解したい。

</body>
</day>
<day date="2008-05-26" title="">
<body>
*1211759810*[雑記]ジラール（Girard）のthe big picture

Esfandiar Haghverdiのプレゼンより：ジラールのGoIは次のようなアナロジーに基づくようだ。

|*証明的 |*ジラール曰く|* 手続き的 |*関数的 |
|証明   | アルゴリズム(algorithm) | プログラム | 式 |
|cut消去 | 計算(computation)      |実行       |評価／簡約 |
|cutなし証明| データ(datum)   | 結果       |値 |

大規模なカリー／ワハード対応みたいなもんか？

cut消去と計算の部分はトレースによって与えられる、ここが面白い。ただし、トレースは部分トレース（partial trace）。

*1211795306*[雑記][モノイド圏][高次圏論][課題]モノイド二重圏

コゥゼン圏の定義に加法的ベキ等性を入れると、ホムセットが順序集合になり、局所順序圏になる。となると、コゥゼン圏は2-圏になる。垂直クラスHを導入すると、二重圏にすることもできる。もちろん、最初からモノイド積（双デカルト積）は入っている。

とまー、そんなわけで、コゥゼン圏はモノイド二重圏の例になる。これは、トレース付きモノイド二重圏がプログラムや形式言語のモデルに登場することの兆候だと僕は思っている。ほんとは半環二重圏になるのだが、モノイド二重圏でもかなりの説明能力を持っているだろう。

モノイド二重圏の定義は、「モノイド圏の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080228/1204158123&quot;&gt;レルム&lt;/a&gt;（圏の圏）内の内部圏（圏対象）」と、「二重圏のレルムのモノイド対象」の２つの方式があるが、同値だと思われる。ハッキリと示したほうがいいだろう。あるいは、トレース付き圏のレルムの圏対象はどうなるのだろうか？

</body>
</day>
<day date="2008-05-27" title="">
<body>
*1211859415*[具体例][高次圏論]二重トレース付き半環圏HTens

順序半環Kをベースにする（Kを圏に一般化できるだろうが）；二値ブール代数&lt;b&gt;B&lt;/b&gt;、クリーネ代数Pow({a, b}*)、自然数の半環&lt;b&gt;N&lt;/b&gt;、max-plus代数など。Kにはダガーもあって、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060829/1156817276&quot;&gt;ダガー半環&lt;/a&gt;だとしよう。どんな半環でも自明なダガー構造が入るから、この仮定は特に問題にはならない。

&lt;b&gt;F&lt;/b&gt;を有限集合全体の類として、J⊆&lt;b&gt;F&lt;/b&gt;をその有限部分類だとする。Jから直和で生成された&lt;b&gt;F&lt;/b&gt;の部分類をJ'とでもしておく。A, B∈J' ならば、A+B∈J' となる。二項直和だけでなく公平なn項直和を入れておいたほうが便利だろう。A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;∈J' に対して、列 (A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;)を、J上の多重インデックスと呼ぶ。

A = (A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;)、B = (B&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., B&lt;sub&gt;m&lt;/sub&gt;) に対して、A・B = (A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;, B&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., B&lt;sub&gt;m&lt;/sub&gt;)と連接で積を入れる。同じ長さの多重インデックスには成分ごとの和で和も入る。このようにしてJから作った多重インデックスの集合を、積と和も一緒に考えてI(J)とする。I(J)を単にIとも書く。A = (A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;) に対して、|A| = A&lt;sub&gt;1&lt;/sub&gt;×A&lt;sub&gt;2&lt;/sub&gt;× ...×A&lt;sub&gt;n&lt;/sub&gt; と書く。

A, B∈Iに対して、|A|×|B|からKへの写像を、(A, B)型のK係数斉次形式テンソルと呼ぶ。(A, B)型のK係数斉次形式テンソルの全体を、係数半環K、インデックス集合の生成セットJを添えで、HTens&lt;sub&gt;K,J&lt;/sub&gt;(A, B) のように書く。J = {{}, {0}, {0, 1}, ...}のときはJを省略する。図示する場合は、カウフマンの抽象テンソル図式を使って描ける。

斉次テンソルの全体はかなり豊富な構造を持っている。

+ 双積
+ 双積に分配的なテンソル積
+ 転置行列によるスター構造（対象は自己双対）
+ 転置＋成分ごとのダガーによるダガー構造
+ コンパクト閉構造
+ 局所順序構造
+ 多圏構造
+ 2つのトレース

*1211875554*[まとめ]注目すべき等式やら命題やら

もう少しチャントまとまったら書こうと思っていたが、とりあえず叩き台。

&lt;h4&gt;●不動点等式／不等式／帰納法&lt;/h4&gt;

- a・a* + 1 = a* [不動点等式; the fixed point equation] 
- a・a* + 1 ≦ a* [不動点不等式; the fixed point enequation] 
- a・x + b ≦ x ⇒ a*・b≦x [不動点帰納法; the fixed point induction rule] 
- x・a + b ≦ x ⇒ b・a* ≦ x [双対不動点帰納法； dual- ]
- a・x + b = x ⇒ a*・b ≦ x [弱不動点帰納法; weak fixed point induction rule]

弱不動点帰納法では、仮定が不等式から等式へと強くなる。よって、推論原理としては弱くなる。

&lt;h4&gt;●クリーネ代数／クリーネ圏&lt;/h4&gt;

&lt;b&gt;コゥゼン（Kozen）の定義：&lt;/b&gt;
+ 1 + a・a* ≦ a* 
+ 1 + a*・a ≦ a* 
+ b + a・x ≦ x ⇒ a*・b ≦ x 
+ b + x・a ≦ x ⇒ b・a* ≦ x 

&lt;b&gt;カール（Kahl）の定義：&lt;/b&gt;
r:A→A, q:B→A、s:A→Cに対して：
+ r* = 1 + r + r*;r* 
+ q;r⊆q ⇒ q;r* ⊆q 
+ r;s⊆s ⇒ r*;s ⊆s 

&lt;b&gt;木下の定義：&lt;/b&gt;
q:A→A, r, x:X→A、s, y:A→Yに対して：
+ 1 + q*;q = q* 
+ 1 + q;q* = q* 
+ r + x;q ⊆x ⇒ r;q*⊆x 
+ s + q;y ⊆y ⇒ q*;s⊆y 

&lt;b&gt;ホプキンス（Hopkins）の定義：&lt;/b&gt;
u: A→B, v: A→A, w: B→B, x: A→B に対して：
+ 1&lt;sub&gt;A&lt;/sub&gt; + ff* ≦ f*
+ u + xv + wx ≦ x ⇒ w* u v* ≦ x

&lt;h4&gt;●一様性原理／帰納原理&lt;/h4&gt;

- [HU]  f;(B+ψ) = (A+ψ);g ⇒  f↑ = g↑
- [PU]  f;ψ = (A+ψ);g ⇒ f&lt;sup&gt;†&lt;/sup&gt;;ψ = g&lt;sup&gt;†&lt;/sup&gt;
- [KU]  f;ψ = ψ;g ⇒ f&lt;sup&gt;*&lt;/sup&gt;;ψ = ψ;g&lt;sup&gt;*&lt;/sup&gt;
- [KI-1] f;ψ ≦ ψ ⇒ f&lt;sup&gt;*&lt;/sup&gt;;ψ ≦ ψ
- [KI-2] ψ;g ≦ ψ⇒ ψ;g&lt;sup&gt;*&lt;/sup&gt; ≦ ψ 

&lt;h4&gt;●スター／ダガー公式群&lt;/h4&gt;

Conway等式 Conway半環の定義
和ダガー等式／積ダガー等式
- (a + b)&lt;sup&gt;†&lt;/sup&gt; = (a&lt;sup&gt;†&lt;/sup&gt;b)&lt;sup&gt;†&lt;/sup&gt;a&lt;sup&gt;†&lt;/sup&gt;
- (ab)&lt;sup&gt;†&lt;/sup&gt; = 1 + a(ba)&lt;sup&gt;†&lt;/sup&gt;b

和スター等式／積スター等式
-  (a + b)* = (a*・b)*・a* 
-  (ab)* = 1 + a・(ba)*・b 

行列スター公式：
M = [a, b; c, d], M* = [α, β; γ, δ] として：
+ α = (a + bd*c)* 
+ β = αbd* 
+ γ = δca* 
+ δ = (d + ca*b)* 

&lt;h4&gt;●Conway不動点&lt;/h4&gt;

Conwayオペレータ公理：

- [対角自然性] f:A×U→V, g:U→V に対して、(f;g)&lt;sup&gt;†&lt;/sup&gt; = (A×g;f)&lt;sup&gt;†&lt;/sup&gt;;g
- [対角性(diagonal prop.)] f:A×U×U→Uとして、(&amp;#40;A×Δ);f)&lt;sup&gt;†&lt;/sup&gt; = (f&lt;sup&gt;†&lt;/sup&gt;)&lt;sup&gt;†&lt;/sup&gt;

f:A,X→X, g:A,Y→Y が2つの系だとして、制御パラメータ領域Aは共通。このとき、並列結合 A,X×Y→X×Y が定義できる。この並列結合を&lt;f|g&gt;と書くことにする。&lt;f|g&gt;の不動点&lt;f|g&gt;&lt;sup&gt;†&lt;/sup&gt;をfの不動点とgの不動点によって書き下す公式がBekicの公式。（Bekicの公式を今は書き下さない。）

&lt;h4&gt;●相互関係&lt;/h4&gt;

トレース付きモノイド圏（対称性は当然に仮定）がデカルトのとき、f:A×X→Xの不動点f&lt;sup&gt;†&lt;/sup&gt;は次のように定義できる。

- f&lt;sup&gt;†&lt;/sup&gt; = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;(f;Δ&lt;sub&gt;X&lt;/sub&gt;)

さらに双デカルトなら、f:X→X の繰り返し（repetition）f*は：

- f* = Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;X,X&lt;/sub&gt;(∇&lt;sub&gt;X&lt;/sub&gt;;f;Δ&lt;sub&gt;X&lt;/sub&gt;)

これらから、双デカルト・モノイド圏では：

- f* = (∇;f)&lt;sup&gt;†&lt;/sup&gt;

逆に、スターでダガーを定義できる。f:A×X→Xのとき

- f&lt;sup&gt;†&lt;/sup&gt; = (&amp;#40;Δ&lt;sub&gt;A&lt;/sub&gt;+X);(A+f))*

ダガーによるトレースの定義は：

- Tr&lt;sup&gt;X&lt;/sup&gt;&lt;sub&gt;A,B&lt;/sub&gt;(f) = (π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;A,B&lt;/sub&gt;;f)&lt;sup&gt;†&lt;/sup&gt;;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;B,X&lt;/sub&gt;

ここで、π&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;、π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;は、それぞれ第一、第二射影（直積因子は２つ）。

※以下、f∨g = Δ;(f + g);∇ とする。

f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt; を絵算で示すときに、どうも次の公式が必須なようだ。

- ∇;Δ =  (Δ+Δ);(1+σ+1);(∇+∇)

□≡(Δ+Δ);(1+σ+1);(∇+∇) と置けば、

- ∇;Δ =  □

それで：

- f&lt;sup&gt;*&lt;/sup&gt; = Tr[(1+Δ);(σ + f);(1 + ∇)]
- f&lt;sup&gt;*&lt;/sup&gt; = Tr[(1+f);□] = Tr[□;(1+f)]
- f&lt;sup&gt;*&lt;/sup&gt; = 1 ∨ Tr(∇;f;Δ) = 1 ∨ f&lt;sup&gt;+&lt;/sup&gt;


</body>
</day>
<day date="2008-05-30" title="">
<body>
*1212132098*[具体例][課題][モノイド圏]数珠暖簾の圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080527/1211859415&quot;&gt;HTens&lt;/a&gt;の多重インデックスについて少し考えてたら、なぜか数珠暖簾＜じゅずのれん＞の圏が出てくる。なんか不思議だ。数珠暖簾の圏の上の二重圏として形式テンソルが現れるのか？

数珠暖簾圏をちゃんと考えてみるか。


</body>
<comments>
<comment>
<username>salmonsnare</username>
<body>元sakesnareです。&lt;br&gt;&lt;br&gt;数珠暖簾っていう構造に興味があります。&lt;br&gt;この日記と、googleで検索をかけても定義が見当たらなかったので&lt;br&gt;よろしければ、数珠暖簾の定義を教えていただけませんか？</body>
<timestamp>1212306057</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>追伸&lt;br&gt;二重件→二重圏では？</body>
<timestamp>1212306123</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>salmonsnareさん、&lt;br&gt;&gt; 数珠暖簾の定義を教えていただけませんか？&lt;br&gt;「数珠暖簾」は僕の造語です。定義は非常に簡単です。別エントリーに定義を書きましょう。&lt;br&gt;&gt; 二重件→二重圏では&lt;br&gt;です。</body>
<timestamp>1212361903</timestamp>
</comment>
</comments>
</day>
<day date="2008-06-02" title="">
<body>
*1212362195*[具体例][モノイド圏]数珠暖簾の圏の定義

数珠暖簾＜じゅずのれん＞は僕の造語。アミダ図やブレイド図の圏と似た、簡単な図形を射とする圏。

数珠は、糸（ストランド; strand）に数珠玉を何個か通したもの。
&lt;pre&gt;
 ｜
 ○
 ｜
 ○
 ｜
 ○
 ｜

 ｜
 ｜
 ｜
&lt;/pre&gt;

数珠は数珠玉の個数だけで識別されるので、自然数（0含む）で表示される。n個の数珠玉を持つ数珠を(n)と書く。(0)は糸だけ。

数珠を横に並べたものが数珠暖簾。数珠(3)と数珠(0)を並べた暖簾なら(3, 0)と書く。

&lt;pre&gt;
  ---------
   ｜  ｜
   ○  ｜
   ｜  ｜
   ○  ｜
   ｜  ｜
   ○  ｜
   ｜  ｜
  ---------
&lt;/pre&gt;

数珠の本数がkである数珠暖簾は、自然数のkタプル(n&lt;sub&gt;1&lt;/sub&gt;, ..., n&lt;sub&gt;k&lt;/sub&gt;)で表示できる。&lt;b&gt;N&lt;/b&gt;を対象集合として、すべての数珠暖簾を射集合とする圏は、f = (n&lt;sub&gt;1&lt;/sub&gt;, ..., n&lt;sub&gt;k&lt;/sub&gt;)、g = (m&lt;sub&gt;1&lt;/sub&gt;, ..., m&lt;sub&gt;k&lt;/sub&gt;) として：

+ dom(f) = cod(f) = k
+ id&lt;sub&gt;k&lt;/sub&gt; = (0, 0, ..., 0) （kタプル）
+ f;g = (n&lt;sub&gt;1&lt;/sub&gt; + m&lt;sub&gt;1&lt;/sub&gt;, ..., n&lt;sub&gt;k&lt;/sub&gt; + m&lt;sub&gt;k&lt;/sub&gt;)

さらに、タプルの連接をモノイド積（モノイド単位は空タプル()）としてモノイド圏になる。

数珠暖簾自体は簡単なものだが、不思議なのは他の圏／高次圏／擬半環／パリクベクトルなどと微妙に関係すること。

</body>
<comments>
<comment>
<username>salmonsnare</username>
<body>エントリーありがとうございます。しっかり読んでみます。</body>
<timestamp>1212559715</timestamp>
</comment>
</comments>
</day>
<day date="2008-06-10" title="">
<body>
*1213090995*[オフトピック]忘れた！

ンガッ！ 恵比寿まで行ったのにバインダー買うの忘れた。もう、なにやってんだか。

それにしても、近所にバインダー売ってる文具屋がないというのは悲劇だ。うどん屋がないのも悲劇だ。
</body>
</day>
<day date="2008-06-11" title="">
<body>
*1213150742*[課題][メモ]忘れていること

部分トレースとかトレースクラス（トレースイデアル）について、定義を書き残しておこうと思ってなんかプリントしたけど、忘れている。それと：

- [http://d.hatena.ne.jp/m-hiyama-memo/20060908/1157705529:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080220/1203485134:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060207/1139303427:title]

とか。パナンガデン（Panangaden）のプレゼンも見ておこう。


</body>
</day>
<day date="2008-06-13" title="">
<body>
*1213331428*[リンク][多圏]コスロウスキーの多圏論文

他でメモった気がするが：

- Title: A MONADIC APPROACH TO POLYCATEGORIES
- Author: JURGEN KOSLOWSKI
- URL: http://www.tac.mta.ca/tac/volumes/14/7/14-07.pdf

- Title: Morphisms And Modules For Poly-Bicategories (2003) 
- Authors: J. R. B. Cockett, J. Koslowski, R. A. G. Seely
- URL: http://citeseer.ist.psu.edu/564964.html

*1213331644*[リンク]クアンタロイド

- Title: CATEGORICAL STRUCTURES ENRICHED IN A QUANTALOID:TENSORED AND COTENSORED CATEGORIES
- Author: ISAR STUBBE
- URL: http://www.tac.mta.ca/tac/volumes/16/14/16-14.pdf




</body>
</day>
<day date="2008-06-18" title="">
<body>
*1213755866*[雑記]上から目線ねぇー

上から目線ってのは、エラソーってことだろうな、たぶん。

エラソーはいけません、エラソーは。なにがいけないって、人から何か教えてもらえるチャンスが減るものな。

*1213762861*[具体例][メモ][トレース／コンパクト閉圏]3点テンパリー／リーブ代数の行列表現の作り方

&lt;s&gt;後で計算用紙をスキャンした画像を貼る予定。&lt;/s&gt;（貼った）

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080617/1213688278&quot;&gt;ジョニーへの伝言：3点テンパリー／リーブ代数の行列表現&lt;/a&gt;
&gt;&gt;
ゴミ箱から裏紙を拾い出して、イッパイ計算した。オジチャン、疲れたよ、もう。
&lt;&lt;

計算を4回くらい失敗したので、紙をけっこう消費してしまった（↓）。
&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-0.jpg&quot; &gt;

うまくいった計算だけなら&lt;s&gt;紙2枚くらいか？&lt;/s&gt;（紙4,5枚）

&lt;b&gt;[追記]&lt;/b&gt;1,2箇所、書き間違いがあるが、見れば分かる程度だからイイヤ。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;心の準備&lt;/h5&gt;

+ クロネッカー・デルタの定義と公式を復習しておく。
+ 平面（2次元ベクトル空間）の正規直交基底を&lt;b&gt;e&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;b&gt;e&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;とする。しばらくこれを眺めてから、e&lt;sub&gt;1&lt;/sub&gt;, e&lt;sub&gt;2&lt;/sub&gt; と太字をやめる。
+ 太字じゃなくてもベクトルだと思えるようになる。
+ そしたら、平面の正規直交基底だったことも忘れる（潜在意識には残しておく）。

&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-1.gif&quot; &gt;

&lt;h5&gt;形式的にテンソル代数を定義する&lt;/h5&gt;

+ {e&lt;sub&gt;1&lt;/sub&gt;, e&lt;sub&gt;2&lt;/sub&gt;}から生成される自由非可換代数を考える。
+ e&lt;sub&gt;1&lt;/sub&gt;とe&lt;sub&gt;2&lt;/sub&gt;に関する次数を考えて、次数がkである斉次部分をP&lt;sup&gt;k&lt;/sup&gt;とする。
+ P&lt;sup&gt;0&lt;/sup&gt;, P&lt;sup&gt;1&lt;/sup&gt;, P&lt;sup&gt;2&lt;/sup&gt;, P&lt;sup&gt;3&lt;/sup&gt; を使う。
+ ∇:P&lt;sup&gt;2&lt;/sup&gt;→P&lt;sup&gt;0&lt;/sup&gt; と Δ:P&lt;sup&gt;0&lt;/sup&gt;→P&lt;sup&gt;2&lt;/sup&gt; を具体的に定義する。メンタルモデル（潜在意識）としては、内積と対角スカラー行列を考える。
+ Δ;∇ と ∇;Δ を具体的に計算する。
+ I∇、∇I、IΔ、ΔI を定義し、具体的な表式を求めておく。

&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-2.gif&quot; &gt;

&lt;h5&gt;必要な等式を示す&lt;/h5&gt;

+ I∇、∇I、IΔ、ΔI に関してジグザグ恒等式を示す。
+ ループ出現が「×2」であることを示す。
+ RとSをI、∇、Δから作って、ジグザグ恒等式とループによる掛け算の性質からRとSに関する恒等式を示す。

&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-3.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-4.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-5.gif&quot; &gt;

&lt;h5&gt;書き下す&lt;/h5&gt;

+ RとSをできるだけ展開しておく。
+ {1, 2}×{1, 2}×{1, 2} から {1, 2, 3, 4, 5, 6, 7, 8}への写像を固定して、添字の等式から行列成分を求める。
+ 1マスが2×2の行列である4×4の方陣を使うと便利。

&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-5a.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/tla-calc-6.gif&quot; &gt;

&lt;h5&gt;挫折ポイント&lt;/h5&gt;

最初から最後まで行列だけで計算しようと思ったんだが、これで何度も挫折した。原理的にはできるはずだが、間違いをおかす。もともとがテンソル代数の構造を持っているので、無理に添字をフラットにすると、添字の対応関係を取るのが大変。置換を1個でも忘れるとオジャン。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20080501/1209618676&quot;&gt;整数の加減乗除のなかにもひそんでいるヤン・バクスター方程式&lt;/a&gt;：
&gt;&gt;
ウチの長男も割り算は苦手のようだが、僕もダメだ。アタマこんがらかって計算できないよー。挫折した。
&lt;&lt;

ここ（↑）に書いた事情がからんでいる。行列の行の置換、列の置換を適切に行わないといかんのだが、その管理が僕の手に余る。


</body>
</day>
<day date="2008-06-19" title="">
<body>
*1213861291*[リンク][メモ]手計算が大変すぎるなら

これを使えば：

- http://www1.bbiq.jp/kougaku/maxima.html



</body>
</day>
<day date="2008-06-21" title="">
<body>
*1214029184*[からみ系][メモ]ジョーンズ多項式、なんか勘違いしているようだ

捻る＜ひねる＞と捩る＜ねじる＞はどう違うんだろう？ 「捻る」で＜ねじる＞とも読むし、撚る＜ひねる＞もあるな。

それはそうとして、2点（紐2本）ブレイド群（むしろブレイド圏全体の話だが）をテンパリー／リーブ代数に埋め込むとして、ループの乗数τと、係数A、Bを使ったカウフマン・ブラケットKを考える。（ほんとのブラケットを使うとHTML文字参照が必要だから使わない。）

- `／ ：正交差
- ＼' ：負交差
- ｜｜ ： ブレイドの単位元
- ⊃ ：半分のマル
- H : ∪と∩を縦にならべたもの

とかの記法を使うとして、基本関係として

- K(`／) = AK(｜｜) + BK(H)
- K(G ○) = τK(G) （Gは任意）

を取る。

2点ブレイドの逆元の関係（ライデマイスター移動II）から AB = 1 と A&lt;sup&gt;2&lt;/sup&gt; + A&lt;sup&gt;-2&lt;/sup&gt; = -τ が出る。これから、A&lt;sup&gt;4&lt;/sup&gt; + τA&lt;sup&gt;2&lt;/sup&gt; + 1 = 0 が出て、Aとτを制約する。τをAで書き下してしまえば特に問題はない。τから先に固定すると、Aの値が定数になることがある。A = 1, A = -1, A = i とか。こういう定数だと忠実表現は作れない。

さて、こっからがなんか勘違いしているようなんだが、K('／⊃) = K(｜）つまり、ヤンキング公式を示そうとすると、Aが1の3乗根になってしまう。普通ωって書くやつ。計算を間違ったかもしれないが、それより、カウフマンブラケットではヤンキングが出ない可能性が高い。いずれにしても、どっかで変なことをしている。

考え直そう。


</body>
</day>
<day date="2008-06-26" title="">
<body>
*1214438458*[からみ系][メモ]ジョーンズ／カウフマン理論

ジョーンズ多項式関係をカウフマンが整理した体系をジョーンズ／カウフマン理論と呼ぶことにする。

その構成要素は：

+ ライデマイスター移動 （背景にライデマイスターの定理）
+ アレクサンダーの定理
+ マルコフの定理とマルコフ変形（マルコフ移動）
+ トレースのマルコフ性質
+ マルコフ・トレースの定義
+ ブレイドの表現とマルコフ・トレース
+ 捻れ数
+ ジョーンズ多項式とマルコフ・トレースの関係

注意すべきことは、無向／有向で定義が少し違うこと。トレースのマルコフ性質が tr(xσ&lt;sub&gt;n&lt;/sub&gt;) = τ・tr(x) 以外に tr(xσ&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;) = τ&lt;sup&gt;-1&lt;/sup&gt;・tr(x)ってのもあること（イマイチよくわからん）。

定数τ（ループ乗数）をどこにいれるか、とか係数環を何にするか、などの差も影響する。けっこう注意を要する。

*1214450133*[からみ系][メモ]続・ジョーンズ／カウフマン理論

U&lt;sub&gt;i&lt;/sub&gt;をカウフマン図によるテンパリー／リーブ代数の生成元として、適当なスカラーαで、e&lt;sub&gt;i&lt;/sub&gt; = α・U&lt;sub&gt;i&lt;/sub&gt; とすると。

- e&lt;sub&gt;i&lt;/sub&gt;e&lt;sub&gt;i&lt;/sub&gt; = e&lt;sub&gt;i&lt;/sub&gt;
- e&lt;sub&gt;i&lt;/sub&gt;e&lt;sub&gt;i+1&lt;/sub&gt;e&lt;sub&gt;i&lt;/sub&gt; = τe&lt;sub&gt;i&lt;/sub&gt;

とできる。α&lt;sup&gt;2&lt;/sup&gt; = 1/τ 。

カウフマンは、σをブレイドの正交差として tr(xσ&lt;sub&gt;n&lt;/sub&gt;) = τ・tr(x)  をマルコフの性質と呼んでいるが、確率過程のマルコフ性と紛らわしいので、マルコフ等式とかよんだほうがいいだろう。

また、マルコフ移動も、マルコフ変形、マルコフ変換などのほうが適切だと思う。項書き換え系の書き換え／還元に近い操作だから。


</body>
</day>
<day date="2008-06-27" title="">
<body>
*1214524872*[圏一般論][具体例]初歩的分断亜群

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070110/1168422137&quot;&gt;分断圏&lt;/a&gt;とか&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210155603&quot;&gt;初歩的圏&lt;/a&gt;とか、どうでもいいような概念にこだわってきたが、やっぱり意味はあるな。

初歩的分断亜群の例は、アミダの圏（置換の圏、対称圏）、ブレイド圏、可逆行列の圏などがあるが、可逆計算の圏も初歩的分断亜群として定式化できる。ヒルベルト空間（複素内積空間）で定式化してもモノイド分断亜群となる。

</body>
</day>
<day date="2008-06-28" title="">
<body>
*1214629481*[からみ系][物理っぽい]ポッツ模型

テンパリー／リーブ代数がポッツ模型（Potts model）と関係するらしい。カウフマンの解説はイイカゲンらしいが、それでも面白い。よく分かってないが、ともかくもメモしておく。

&lt;h5&gt;分配関数Z(G)&lt;/h5&gt;

平面無向単純グラフGを考える。Gが単純とはループも多重辺も持たないこと。そっち方面（どっち方面？）の用語では、頂点をサイト、辺をボンドと呼ぶ。頂点＝サイトにスピンとかカラーと呼ばれる値を割り振る。この値は{0, 1, ..., q-1}だと思ってよい。e&lt;sup&gt;2πi/q&lt;/sup&gt; という円周上の等分点をスピンの値として取ることが多いようだ。

#|G| = (Gの頂点数) をNとして、スピン割り当ての個数はq&lt;sup&gt;N&lt;/sup&gt;ある。それぞれの割り当てを、配位（configuration）と呼ぶのだそうだ。状態（state）とも呼ぶ。状態をSとして、S(i), S(j)などで状態Sのi番目のサイトでの値を表す。[i, j]はサイトiとjを結ぶボンドを表すとする。便宜上、i &lt; j と約束しておく。

δ(x, y)はクロネッカー・デルタ、ただし、x, yは任意でいいとする。要するに、任意の集合の対角集合の特性関数がδ。グラフG上の状態SにおけるエネルギーE(S)を定義する。まず、ボンド[i, j]に対して、ε(S; i, j) = ε&lt;sub&gt;S&lt;/sub&gt;([i, j]) = δ(S(i), S(j)) と定義する。ボンドのエネルギーは、両端のスピンが一致するかどうかで決まる。

各ボンドのエネルギーの総和 Σ([i, j]はすべてのボンド: ε(S; i, j)) をSのエネルギーE(S)とする。適当な定数cを用意して、cの肩にエネルギーを乗せた c&lt;sup&gt;E(S)&lt;/sup&gt; を、状態Sの寄与、効果、作用のように考えて、すべての状態に関して和をとる。

- Z = Σ(すべての状態S: c&lt;sup&gt;E(S)&lt;/sup&gt;)

これはGにより決まるので、Z(G) と書いて、Gの状態和、または分配関数と呼ぶ。

&lt;h5&gt;分配関数のパラメータ&lt;/h5&gt;

Z(G) は、Gの関数であるが、他にスピンの自由度（値の個数のことだが）qと温度Tをパラメータに持つ。温度Tは、別な定数vに組み入れて考える。v = c - 1 であり、定数cのなかに指数の形でTが含まれる。T, c, vの関係は単なる定数の取り替えに過ぎないから気にしなくていい。

qとvを変数だと思って、それらを変数とする分配関数を Z(G, q, v) と書く。具体的にZを求める計算式が欲しい。グラフGを帰納的に構成して、ある種の漸化式を作ってみる。bをGのボンドだとして、G＼b と G↓b を次のようなグラフとする。

- G＼b -- Gからボンドbを取り除いたグラフ（サイトは変化せず）
- G↓b -- bの両端を1つのサイトにまとめたグラフ

次の漸化式が成立する。

- Z(G) = Z(G＼b) + vZ(G↓b)
- Z(・∪G) = qZ(G)

「・∪G」はGに一点を付け加えたグラフ。

&lt;h5&gt;計算テクニックと絡み目との関係&lt;/h5&gt;

等式 c&lt;sup&gt;δ(x, y)&lt;/sup&gt; = 1 + (c - 1)δ(x, y) が使われる。これは当たり前だが、言われないと気がつかない。c - 1がvとなる。非自明な計算はこの部分だけだろう。

Gは平面単純グラフだが、Gの状態Sは、Gから作った平面4-正則グラフ（Gのユニバーサル、または中間グラフと呼ぶらしい）Uの領域塗り分け（彩色）に対応する。特に、q = 2 のときは、二色塗り分け。これから、Gの交点に符号を与えることができて、絡み目の射影図と思える。

任意のグラフの状態と絡み目の状態を結びつけるのは、ユニバーサル（4-正則グラフ）なので、グラフの頂点彩色、ユニバーサルの領域彩色の相互関係をハッキリと理解する必要がある。頂点彩色＝スピン割り当てのエネルギーは、領域彩色のときは頂点（交差点）での双対エネルギーのようなものか？ エネルギーの双対って何だよ？？

*1214643564*[からみ系][トレース／コンパクト閉圏]手作りトレース

n点テンパリー／リーブ代数のi番目の生成元をH&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;とする（Uは使わない）。特に、H = H&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;1&lt;/sub&gt;。単位元をI&lt;sup&gt;n&lt;/sup&gt;とする。特に、I = I&lt;sup&gt;1&lt;/sup&gt;。

係数環Rとループ乗数τを固定して、テンパリー／リーブ代数をTL(n)とする。TL(n) = TL(n, n)とみなして、TLはR-線形なモノイド圏（R係数テンソル圏）とみなす（初歩的分断圏）。

基本トレースTr: TL(n)→TL(n-1)を定義する。

+ Tr(I) = τ、τ∈TL(0) = R
+ Tr(H&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;) = τH&lt;sup&gt;n-1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;
+ Tr(H&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;n-1&lt;/sub&gt;) =  I&lt;sup&gt;n-1&lt;/sup&gt;
+ Tr(XI;YH) = X;YI

最後の等式で、X∈Tr(n-1), Y∈Tr(n-2) である。

TL(n)の加群としての階数は有限だから、帰納的にTrを計算できると思う。実際に、TL(n)の基底の形を具体的に見ないといけないが。

Tr&lt;sup&gt;k&lt;/sup&gt;をTrのk回の繰り返しにすると、Tr&lt;sup&gt;k&lt;/sup&gt;:TL(n)→Tr(n-k)、あるいは、Tr&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;m,m&lt;/sub&gt;:TL(m+k, m+k)→ TL(m, m) が定義できる。このTr&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;m,m&lt;/sub&gt;が普通の意味でトレースになっていると思う。確認は組み合わせ的な議論。

次に、∪&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;と∩&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;が独立に入った圏に対して、代数的なトレース Tr(X) = □∩;XI;□∪ を使って同じことをやってみるとよさそうだ（□はI&lt;sup&gt;n&lt;/sup&gt;と同じ）。


</body>
</day>
<day date="2008-06-30" title="">
<body>
*1214782175*[からみ系]拡張ライデマイスター移動

カウフマンが5種の移動からなる拡張ライデマイスター移動を定義している。追加その１はジグザグ等式。その２が、ブレイド交差をねじって斜め卍にする変形。仮に、カウフマンの卍変形とでも呼んでおこう。

カウフマン卍変形は、布や粘土を回転する感じで面白いのだが、あまりアトミックな感じがしない（カウフマンは飴などのねじれが好きらしいが）。トゥラエフのΨ変形を基本としても同じ。Ψ（ぷさい）は十手に似てる。卍と十手は同値。

*1214782176*[からみ系]正規化ブラケット

別なカウフマン・ネタ。＜-＞をカウフマン・ブラケットとして、有向絡み目Kに対して次の量Lを考える。

- L(K) = (-A&lt;sup&gt;3&lt;/sup&gt;)&lt;sup&gt;-w(K)&lt;/sup&gt;＜/K/＞

ここで、Aは基本的な関係式（スケイン関係）の係数（ローラン多項式の変数でもある）、w(K)はKのひねり数、/K/はKを無向化した無向絡み目。カウフマンはKと/K/を区別しないのでちょっと混乱した。

Lは、事実上ジョーンズ多項式。


</body>
</day>
<day date="2008-07-01" title="">
<body>
*1214878753*[からみ系][トレース／コンパクト閉圏]ブレイド閉包とホップ絡み目

(`／;`／) というブレイドを閉じるとホップ絡み目になる。これは簡単に示せる。その類似として、右トレースと左トレースが右トレース2回と同じかと思ったらオオマチガイ。

って図がないとわからんな。

*1214898095*[リンク][からみ系][物理っぽい]ポッツ模型と記号力学

http://en.wikipedia.org/wiki/Potts_model では、1次元ポッツ模型が記号力学で定式化できるようなことが書いてある。

*1214899162*[からみ系]一般ブラケット

カウフマン・ブラケットに限らず、タングルの圏からベクトル空間（あるいは加群）のテンソル圏への関手が、ある公理を満たすとそれをブラケットと呼んでいる。

その公理の内容は要するに、内積V→V&lt;sup&gt;*&lt;/sup&gt;、上から下に見て∪に対応する双線型形式 V×V→K（Kはスカラー）、ヤン・バクスター方程式を満たす線形変換R:V×V→V×Vで生成された関手が、ジグザグ等式やアルチン関係式（ヤン／バクスター方程式を含む）を満たすこと。

ブラケットは、トゥラエフのタングル圏の線型表現だと思えばよい。表現を作る上で重要なのはヤン／バクスター方程式の解となる行列、これをR行列と呼んでいる。

いまいち圏論的な構造が曖昧だが、タングル圏とベクトル空間の具体的テンソル圏とブラケットの定義を見比べればわかるような気がする。トレースの役割がポイントかもしれない。また、ヤンキングに関して調整する因子も大事だ。ブラケットがあればジョーンズ多項式風の不変量が得られる。



</body>
</day>
<day date="2008-07-02" title="">
<body>
*1214965846*[からみ系]続・一般ブラケット

ブラケットの公理は、トゥラエフのΨ移動、ヤンキング、ヤン／バクスター関係式だった。∇がV上の非退化双線形形式、RがV×V上の可逆オペレータ（R行列）として、次を要求する。IdはVの恒等、×はテンソル積、R'はRの逆。

+ (R×Id);(Id×∇)  = (Id×R);(∇×Id)  [Ψ移動 1]
+ (R'×Id);(Id×∇)  = (Id×R');(∇×Id)  [Ψ移動 2]
+ R;∇ = α∇ （αはスカラー） [ヤンキング]
+ (R×Id);(Id×R);(R×Id) = (Id×R);(R×Id);(Id×R) [ヤン／バクスター]

可逆行列Rと非退化双線形形式∇から構成される、有向タングル圏上の関手をブラケットと呼ぶ。Rが可逆であることと、ヤン／バクスター関係式から、ブラケットがブレイド圏（タングル圏の部分圏）の表現を与えるのは明らか。

αはヤンキングにより紐にかかるねじれのストレスのようなもの。有向タングルDのひねり数をw(D)とすると、正規化（規格化）因子 α&lt;sup&gt;-w(D)&lt;/sup&gt; をつければ、全同位（トゥラエフ移動）不変な量となる。特に、Kがカウフマン・ブラケットで、α = (-A&lt;sup&gt;3&lt;/sup&gt;)のとき、Kから正規化因子(-A&lt;sup&gt;3&lt;/sup&gt;)&lt;sup&gt;-w(D)&lt;/sup&gt;を付けて得られる不変量が（事実上）ジョーンズ多項式。

*1214966458*[からみ系][トレース／コンパクト閉圏]ブレイドやタングルの表現とマルコフ・トレース

環（多元環）上の加群が、その環の線形表現と同義であるのと同じように、ブレイド付き圏（braided category）は、ブレイド圏の表現と同義だ。

- 対称付き圏（対称モノイド圏） ＝ 対称の圏（置換の圏）の表現
- ブレイド付き圏 ＝ブレイド圏の表現
- 対称コンパクト閉圏 ＝対称な荷電付きタングル圏の表現
- ブレイド付きコンパクト閉圏 ＝ 荷電付きタングル圏の表現

特に、圏の対象がベクトル空間や加群のときは線形表現になる。

さて、マルコフ・トレースだが、まずは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210155603&quot;&gt;初歩的&lt;/a&gt;ブレイド圏Bの上で考える。圏Bで定義されて、環Rに値をとるマルコフ・トレースφとは、次を満たすもの。×はモノイド積（自然数の和に対応）、σはブレイドの生成元σ:2→2。

+ φ(A;B) = φ(B;A) A, B∈B(n, n)
+ φ(A×σ) = τφ(A) A∈B(n, n), σ∈B(2, 2)
+ φ(A×σ&lt;sup&gt;-1&lt;/sup&gt;) = τ'φ(A) A∈B(n, n), σ&lt;sup&gt;-1&lt;/sup&gt;∈B(2, 2)

ここで、τ = φ(σ)、τ' = φ(σ&lt;sup&gt;-1&lt;/sup&gt;)、τ'がτの逆とは限らない！

マルコフ／トレースがあると、適当な正規化因子を付けて、絡み目の不変量が得られる。その正規化因子はちょっと複雑で：

- (ττ')&lt;sup&gt;-(n - 1)/2&lt;/sup&gt;(τ'/τ)&lt;sup&gt;e(A)/2&lt;/sup&gt;

ここで、e(A)はブレイドAのひねり数w(A)と同じだが、ブレイド語で表示されていれば、ベキ指数の和となる。nはブレイドの釘（紐、ストランド）の数。

ブレイド圏の表現（主に線形表現）と、マルコフ・トレースを考えるのは、ブレイド圏に圏論的なトレースを考えるのと同じような気がする。タングル圏には自然なトレースがあるし、ベクトル空間のテンソル圏にも縮約としてのトレースがある。

結局は、タングル圏を自然にトレース付きブレイド付き圏（traced braided category）と考えて、トレースも含めて線形テンソル圏に表現してしまえば、ブレイドの表現も絡み目の不変量も得られるのではないかと。トゥラエフ移動にマルコフ変形も加えると、組み合わせ的なトレース計算ができそう。

&lt;b&gt;[追記]&lt;/b&gt;マルコフ移動って、トゥラエフ移動から出るのか？出るかも知れない。&lt;b&gt;[/追記]&lt;/b&gt;

*1214988540*[からみ系]スケイン関係式

スケイン関係式が、そもそも用語として意味不明だった。すこし調べた。

まず単語「スケイン (skein)」だが、和訳は「かせ」、「一かせの毛糸」とかの用法がある。毛糸を束ねてグリグリとねじったのが「かせ」らしい。ストランドもブレイドも髪の毛と関係あるけど、見た目は女性の巻き毛を連想させる。ようするに、糸や紐が束ねて巻かれてねじられたものがスケインらしい。

それで、スケイン関係式だが、既にアレクサンダー多項式について考えられていたようで、アレクサンダー／コンウェイ関係式とも呼ぶらしい。最近だと、ジョーンズ多項式やホムフリー多項式でもスケイン関係式が出てくる。

一般的に語るため、スケイン・トリプルの概念を準備する。[-]&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;m&lt;/sub&gt;を上にn点、下にm点を持つ空っぽな四角だとする。[-]&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;m&lt;/sub&gt;を穴（ホール）と呼ぼう。穴を持つ図式を図式コンテキストと呼ぶ。D[-]&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt;で、2-2型穴を持つ図式コンテキストだとする。

図式コンテキストに、具体的なブレイドやタングルを代入できる。それを、D['／]とかD[＼']のように書く。図式コンテキストD[-]に対して、D&lt;sub&gt;+&lt;/sub&gt; = D[`／], D&lt;sub&gt;-&lt;/sub&gt; = D[＼'], D&lt;sub&gt;0&lt;/sub&gt; = D[｜｜] で定義される3つ組(D&lt;sub&gt;+&lt;/sub&gt;, D&lt;sub&gt;-&lt;/sub&gt;, D&lt;sub&gt;0&lt;/sub&gt;)をスケイン・トリプルと呼ぶ。

Fが環R（多くの場合、n変数の&lt;b&gt;C&lt;/b&gt;係数ローラン多項式環）に値を取る量だとして、F(D&lt;sub&gt;+&lt;/sub&gt;), F(D&lt;sub&gt;-&lt;/sub&gt;), F(D&lt;sub&gt;0&lt;/sub&gt;)のあいだに成立するR内の線形関係をスケイン関係式と呼ぶ。

もっと一般化すると、U&lt;sub&gt;1&lt;/sub&gt;, ..., U&lt;sub&gt;n&lt;/sub&gt;を何らかの基本図式、D[-]を図式コンテキスト、F&lt;sub&gt;0&lt;/sub&gt;,  F&lt;sub&gt;1&lt;/sub&gt;, ... を環や加群に値を取る量だとして、F&lt;sub&gt;j&lt;/sub&gt;(U&lt;sub&gt;i&lt;/sub&gt;) 達にあいだに成立する線形関係式がスケイン関係式となる。

ベースとなる環や加群において、F&lt;sub&gt;j&lt;/sub&gt;(U&lt;sub&gt;i&lt;/sub&gt;)で生成され、スケイン関係式で割り算した環／加群が不変量の領域となるべきものだろう。

*1214990775*[からみ系]ポッツ模型やらイジング模型やらと彩色多項式

分配関数はスピン配位（状態）の実現確率の規格化（分母）に使うようだ。指数分布ってのがどうもわからんが、ともかくも、状態σが実現する確率 W(σ) （なぜかPじゃなくてW)が次の形で与えられる。

- (1/Z)exp(-E(σ)/kT)

Eは状態σのエネルギー、k = k&lt;sub&gt;β&lt;/sub&gt;がボルツマン定数、Tが温度。exp(-1/kT)をc（たぶんcは1より小さい）と置くと、(1/Z)c&lt;sup&gt;E(σ)&lt;/sup&gt; の形。全体の確率を1にするために、c&lt;sup&gt;E(σ)&lt;/sup&gt;をσ全体に渡って足したモノがZ。

σの値が1の累乗根、とくに{1, -1}を動くとして、J(i, j)が各ボンドに与えられた結合定数だとして、E(σ) = -Σ([i, j]はボンド（辺）: J(i, j)×σ(i)×σ(j)) がイジング模型らしい。ポッツ模型は、ボンドごとのエネルギーが δ(σ(i), σ(j)) の形だったからちょっと違う。

それはそうとして、グラフの頂点彩色多項式は、色数nに関する漸化式で定義できる。これがスピン値の個数がnである分配関数と似てるのは確か。グラフのユニバーサル（中間点グラフ）を描いて、点で接する境界を持つ島国（海がある）達の地図だと思う。この地図の国をn色で塗り分ける仕方が彩色多項式で与えられる。漸化式はスケイン関係式に似てる。

が、ハッキリしたことはわからんわ！

</body>
</day>
<day date="2008-07-03" title="">
<body>
*1215073610*[からみ系](2+ε)次元の幾何、ひねり付きブラケット

結び目、絡み目（リンク）、もつれ（タングル）などの幾何は、もともとは3次元内の全同位による同値類を考えるのだが、しかし、操作的には2次元に張り付いた紐のハナシになっている。交差が2種類ある点で2次元ではないのだが、この交差の上下はZ方向にε（任意に小さい数）だけの高さをとれば済むので、からみ系／もつれ系の幾何は、3次元つうより (2+ε)次元の幾何というべきだろう。

タングルの釘の位置を、(i, 1)（i = 1, 2, 3, ...）と(j, 0)（j = 1, 2, 3, ...）のように固定してもいい。また、タングルの拡がりを、0≦x、0≦y≦1に限定してもよい。そのうえで、n→mのタングル図は、[0, 1]と単位円の直和からの写像としていいだろう。εの高さは交差点での符号（時計回りか反時計回りか）でも区別できる。[0, 1]と円周を&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;1&lt;/sup&gt;と&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;2&lt;/sup&gt;の部分集合として、なめらかな圏で考えれば、初等的な微積分で具体的表式が得られる。

この表式では向きが必然的に付くが、パラメータ表示の取り替えとして向きも忘れることができる。

とりあえず、次の同値関係を導入しよう。

- 自明同位： 交差を変更しないで位置を直すだけ。
- 正則同位： ヤンキングはしない。
- 全同位： すべてのライデマイスター移動に対応。

タングル写像φ:n×I + m×C→&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;2&lt;/sup&gt;があると、これをパラメータの取り替えと、自明同位で割った空間をOTD（oriented tangle diagrams）とする。向きを忘れたものはULD（unoriented tangle diagrams）。OLD, ULD, OND, UNDは、oriented/unoriented link/knot diagrams, *BDはbraid diagrams。*ND⊂*LD⊂*TD、*BD⊂*TD、ブレイド閉包は、*BD→*LD の写像を定義する。

正則同位をRI、全同位をAIとする。UBD/RI はブレイド群BGとなる。カウフマンブラケットは、ULD/RIで定義される。ブレイド閉包は、UBD/RI→ULD/RI とみなせるので、UBD/RI を経由して、ブレイド群上にカウフマンブラケットを定義可能。Cl(UBD/RI)⊆ULD/RI にマルコフ同値の半分（マルコフ変形その1）を入れてもなおカウフマンブラケットは定義できる。

F*LD を枠付き（framed）なリンク図とする。各リンク成分に整数としてひねり数を入れておく。カウフマンブラケットは、FULD/AI上でひねりを乗法作用として定義できる。UBD/RIを、FULD/RIに埋め込み、FULD/AIに落とすことにより、BG = UBD/RI上のひねりを考慮したカウフマンブラケットが得られる。

このひねり付き（枠付き）カウフマンブラケットが面白い。


</body>
</day>
<day date="2008-07-04" title="">
<body>
*1215129404*[物理っぽい][圏一般論][用語法]ユニタリ対応の圏

用語法がややこしいからまとめておく。

|* 係数体 |* 内積 |* ベクトル空間 |* 内積保存変換 |
| 実数   | ユークリッド内積 | ユークリッド空間 | 直交変換 |
| 複素数 | エルミート内積 | ヒルベルト空間 | ユニタリ変換 |
| 実数 | ミンコフスキー内積 | ミンコフスキー空間 | ローレンツ変換 |

けっこう用語法のゆらぎはある。例えば、ミンコフスキー内積からの計量はなぜかローレンツ計量と呼び、ローレンツ計量が与えられた多様体はローレンツ多様体と呼んだりする。

内積には普通、対称性（複素ならエルミート対称性）、正定値性、ノルムゼロならゼロなどが要求される。

さて、昨晩考えたことによると、対称性、正定値性、ノルム条件などがなくても、基本的な枠組みはできる。余分なことがないほうがスッキリする。計算科学と圏論のアナロジーから発見的な議論を経由して、結局、一般化内積の一般化ユニタリ対応という概念が便利だと思った。

最終的には集合論的な定義に落とせる。それは部分単射になった。ここでは、非退化双線形形式を内積（一般化内積）と呼び (-|-) と書く。

UとWが内積空間として、f:U→Wがユニタリ対応であるとは：

+ Uの部分空間Vがある。
+ 内積を保存する線形写像f&lt;sub&gt;0&lt;/sub&gt;:V→W がある。
+ fは、Vとf&lt;sub&gt;0&lt;/sub&gt;で定義される。

これは、集合の部分写像や部分単射の概念で議論できる。

圏論的には、ユニタリ埋め込みの圏をUEmbとしてのSpan(UEmb)、ユニタリ引き込み（レトラクション）の圏をURetとしてのCosp(URet)を考えると、これらは反変同型。Span(UEmb)とCosp(URet)を同一視した圏をUCorrとする。UCorrの射がユニタリ対応。

UCorrには、テンソル積でモノイド構造が入り、左右の脚を入れ替える自己関手でダガー構造が入る。双対がスター構造を定義するから、ダガー・スター圏になる。たぶん、ケリー単位もあって、ダガー・コンパクトだろう。

UCorrは具体的で計算できる。有限ヒルベルト空間を対象とするUCorrは有限量子計算（量子算数）に使えるのではないかと思う。

*1215136203*[からみ系][リンク][用語法]ボロミアン環とブルン絡み目

ボロミアン環（ボロミアンリング Borromean ring）については、http://en.wikipedia.org/wiki/Borromean_rings 。イタリアのボロミオ家（Borromeo family）の紋章だったんだそうだ。

ボロミアン環は、ブルン性（Brunnian property）を持つ。ブルンはHermann Brunnから。ブルン性を持つ絡み目はブルン絡み目だが、Brunnian link（ブルニアンリンク）というから、ボロミアンリングと紛らわしい。→ http://en.wikipedia.org/wiki/Brunnian_link

*1215140284*[からみ系][まとめ]ねじれ付き（枠付き）絡み目のねじれ付き不変量

やっぱり、カウフマンブラケットはねじれ付き無向絡み目に対して定義するのが自然だな。ねじれ（ひねり）はねじれ乗数（twist factor）に表現される。輪っこもねじれもスカラー乗法になるのは不思議な気もするが、スプライシング（交差の解消）とヤンキング（引き伸ばし）は似ているから、まーいいのかも。ネジレ玉（後述）をハサミで切り落とすと、それは輪っこだから、輪っこが生じるスプライシングと同類、たぶん。

記号の約束：

- BD ：ブレイド図の全体（平面の重力方向はあるが、図は無向）
- LD ：無向絡み目図の全体
- RI ：正則同位 ライデマイスター移動IIとIII
- AI ：全同位 ライデマイスター移動IとIIとIII
- AR ：アルチン関係式（等式） ライデマイスター移動IIとIIIに対応
- BW ：ブレイド語の全体
- B  ：ブレイドの全体
- CC ：cyclic cancellation ブレイド語の両端が互いに逆のとき消す
- CBD ：closed braid diagrams
- M1, M2 ：マルコフ移動

スラッシュは同値関係で商を作ることだとして、B = BD/RI は定義だと思ってよい。

- B = BD/RI = BW/AR

これがアルチンの定理。ブレイド語の説明を以下に；基本素片 ／、＼、｜を任意に並べた列をブレイド記号またはブレイド字（braid letter）と呼ぶ。例えば、／／｜＼｜ はブレイド記号。ブレイド記号xの幅W(x)を、W(／) = W(＼) = 2, W(｜) = 1 として、足し算で定義する。w(／／｜＼｜) = 2 + 2 + 1 + 2 + 1 = 8。

同じ幅のブレイド記号を何個か並べた列をブレイド語と呼ぶ。ブレイド語全体を、トゥラエフ流の基本変形とアルチン関係で商を取ると、ブレイド群BG(n)ができる（nは幅）。ブレイド群BG(n)の生成元は、幅nのブレイド記号の全体だが、n個の基本生成元上の自由群をアルチン関係で割っても同じ。一般のブレイド記号より、基本ブレイド記号だけを考えたほうが楽だが、絵図との対応は悪い。

BD/(RI + M1 + M2) がブレイド閉包演算子Clによる商 BD/Cl と同じことを主張するのがマルコフの定理。よって

- BD/(RI + M1 + M2) = BD/Cl = LD/AI

最後の部分、BD/Cl = CBL/AI = LD/AI はアレクサンダーの定理。

さて、絡み目に紐（むしろベルト、リボン）の回転量、またはネジレ玉（符号が付いている）の個数（符号付きで勘定）を付けたものをねじれ付き絡み目とする。ねじれ付き絡み目では、ねじれ付きヤンキング＝ねじれ付きライデマイスター移動Iが使われる。ねじれ付き絡み目図の全体をFLD（framed link diagrams）とする。

カウフマンブラケットは、FLD上で定義できる。FLD/RI の不変量であり、ねじれ付きヤンキングに対してはスカラー乗法分だけ変化する。ネジレ玉がどの輪に分布しているかを無視して、ネジレ玉の総数だけを考えてもカウフマンブラケットに差はない。

そこで、BW/(AR + CC)×&lt;b&gt;Z&lt;/b&gt; を考えて、この上でカウフマンブラケットを計算できる。(AR + CC)による同値関係では不変。マルコフ移動2に関しては、ヤンキングでの交差解消がネジレ玉の個数とのトレードオフになる。輪っこもネジレ玉も掛け算で作用する。この掛け算と、スケイン関係式を使って交差を解消して、ブラケットの値を計算できる。

BD/RI は、閉包演算Clにより FLD/RI に埋め込める。埋め込まれた像は、BW/(AR + CC)×&lt;b&gt;Z&lt;/b&gt; で完全に表示できる。この表示による計算が、FLD/RI 上でのカフフマンブラケットの値を効果的に出す方法を与える。

あと、マルコフ・トレースとの関係とかが問題だな。

*1215161344*[物理っぽい][圏一般論]ユニタリ対応の圏の集合論的構成

JavaScriptのBoolean仕様にあきれつつ、線形代数も考えてみた。

ユニタリ対応の圏は圏論的に作るとスマート。Span(UEmb)とCosp(URet)まではキレイに作れる。だが、Span(UEmb)とCosp(URet)を貼り合わせるところは、いまいちクリアになってない。

ユニタリ対応を集合論的に構成するとシチメンドクサイのが難点だが、手で触った感じがするし、貼り合わせが具体的になる。以下、集合論的に構成してみる。対象は有限次元内積空間。

まず、今までユニタリ埋め込み、ユニタリ引き込みと呼んでいたもの（線形写像）を、全域ユニタリ埋め込み、余全域ユニタリ引き込みと形容詞を付ける。そして、ユニタリ埋め込みとユニタリ引き込みを新たに次のように定義する。

+ V⊆Uで、f:V→W が全域ユニタリ埋め込みのとき、(V⊆U, f)を、「U→Wのユニタリ埋め込み」と呼ぶ。
+ V⊆Wで、f:U→V が余全域ユニタリ引き込みのとき、(V⊆W, f)を、「U→Wのユニタリ引き込み」と呼ぶ。

ユニタリ埋め込みと引き込みの全体を UEMB(U, W), URET(U, W)（全部大文字にした）とし、UCORR(U, W) = UEMB(U, W)∪URET(U, W) とする。UCORR(U, W) と UCORR(W, Z)の結合は、場合分けをして定義できる。場合分けが面倒だが、結果は自然な計算となる。

eを埋め込みの象徴、rを引き込みの象徴とすると、e;e = e, e;r = r, r;e = r, r;r = r となり、随伴でeとrがトグルする。雰囲気的には e = 1, r = 0 としての掛け算。随伴は x&lt;sup&gt;†&lt;/sup&gt; = 1 - x 、&lt;em&gt;あくまで雰囲気&lt;/em&gt;だが。

UCorr(U, W) = UCORR(U, W)/≡ としてユニタリ対応を定義するが、同値関係 A ≡ B とは次の&lt;em&gt;どれか（少なくとも1つ）&lt;/em&gt;が成立すること：

+ A = B
+ A∈URET, B∈UEMB で A&lt;sup&gt;†&lt;/sup&gt; = B&lt;sup&gt;-1&lt;/sup&gt;
+ B∈URET, A∈UEMB で B&lt;sup&gt;†&lt;/sup&gt; = A&lt;sup&gt;-1&lt;/sup&gt;

(-)&lt;sup&gt;-1&lt;/sup&gt;:UEMB(U, W)→UEMB(W, U) は自然に定義できる。ダガーは、(-)&lt;sup&gt;†&lt;/sup&gt;:URET(U, W)→UEMB(W, U) とEMBとRETを互いに入れ替える。

これらの定義が整合的であることを示すには：

+ ≡がほんとに同値関係であること
+ 同値類に関して、場合分けで定義した結合がwell-definedであること

を示す必要がある。場合分けが多くて非常に面倒だが、基本的に手間の問題。

面倒になる理由は、直交補空間と直交分解を使わないからで、これが使えるなら手間は減る。が、直交概念を使わない定式化にも意味はあるだろう、たぶん。


</body>
<comments>
<comment>
<username>salmonsnare</username>
<body>＞ユニタリ対応の圏&lt;br&gt;この記事すごくためになりました。もう一度、『量子コンピュータの基礎数理』を読み直してみます。</body>
<timestamp>1215138732</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>&gt; 『量子コンピュータの基礎数理』&lt;br&gt;今日か明日、大きな本屋まで行ってみようと思ってます ^^;&lt;br&gt;&lt;br&gt;とりあえず線形代数の復習でもしようと思ったのですが、エルミート内積がある空間のユニタリ変換だけを考えるのはなんか不自然な感じがしたのでした。射があまりに少なすぎて計算に不便！ ユニタリ対応まで拡げると、双対ベクトル、射影、内積（テンソル積空間からの線形写像と考える）なども、すべてユニタリー対応です。</body>
<timestamp>1215141648</timestamp>
</comment>
</comments>
</day>
<day date="2008-07-05" title="">
<body>
*1215227815*[物理っぽい][圏一般論][その他代数]意外にめんどくさい -- 双対空間

なるべく双対空間を使った定式化にしようとしてたら、細かい点が色々と気になりだした。

まず、そもそも双対空間の定義； 標準的にU&lt;sup&gt;*&lt;/sup&gt; = L(U, K) とするのが分かりやすいが、対称性に欠ける。スカラー値のペアリングを備えた2つの空間U, Wとする方法もあるが、相方の一意性がup-to-isoでしかわからない。まー、それでもいいけど、腰が落ち着かない感じ。選択された双対空間を選ぶ写像をスター関手として定義して、ケリー余単位 ε:U×U&lt;sup&gt;*&lt;/sup&gt;→K で公理化する手もあるが、話が一気に線形テンソル圏までいってしまう。ムーーー。

&lt;hr&gt;

x∈Uに対して、xで定義されるL(K, V)の元をx&lt;sub&gt;#&lt;/sub&gt;と書くことにする。xとx&lt;sub&gt;#&lt;/sub&gt;の扱いに関して：

+ 別物として区別する。
+ 同一視する。
+ そもそもxを考えないで、x&lt;sub&gt;#&lt;/sub&gt;のことをxと書く。

&lt;hr&gt;

内積とは非退化双線形形式のことだとして、f:U→Wの双対をf&lt;sup&gt;*&lt;/sup&gt;:W&lt;sup&gt;*&lt;/sup&gt;→U&lt;sup&gt;*&lt;/sup&gt;とする。スター記法として、これは妥当だろう。x&lt;sub&gt;#&lt;/sub&gt;:K→Uがあると、(x&lt;sub&gt;#&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;:U&lt;sup&gt;*&lt;/sup&gt;→K&lt;sup&gt;*&lt;/sup&gt; が定義できる。もし、xとx&lt;sub&gt;#&lt;/sub&gt;を同一視するなら、(x&lt;sub&gt;#&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;をx&lt;sup&gt;*&lt;/sup&gt;と書いていい。

(x&lt;sub&gt;#&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt; がどんな写像かというと、K&lt;sup&gt;*&lt;/sup&gt;をKと同一視すれば、x&lt;sup&gt;^&lt;/sup&gt; である。ここで、(-)&lt;sup&gt;^&lt;/sup&gt;:U→U&lt;sup&gt;**&lt;/sup&gt;は自然な埋め込み。

- (x&lt;sub&gt;#&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt; = x&lt;sup&gt;^&lt;/sup&gt;

&lt;hr&gt;

がそもそも、K&lt;sup&gt;*&lt;/sup&gt;をKと同一視していいものかどうか？ Kがスカラーなら、K, End(K) = L(K, K), K&lt;sup&gt;*&lt;/sup&gt; は標準的に同型だが、常に同一視していかどうかはわからない。

&lt;hr&gt;

双対性の定義を、普通にU&lt;sup&gt;*&lt;/sup&gt; := L(U, K)で与えても、スター自己関手と非退化なペアリング（ケリー余単位）で与えても、まー、計算は大差ない。内積の定義は、U上のペアリングとしても、UとU&lt;sup&gt;*&lt;/sup&gt;の同型（可逆線形写像）としても、これも大差ない。

内積を与えるU→U&lt;sup&gt;*&lt;/sup&gt;の同型をΦ=Φ&lt;sub&gt;U&lt;/sub&gt;とかく。Φ&lt;sup&gt;*&lt;/sup&gt;:U&lt;sup&gt;**&lt;/sup&gt;→U&lt;sup&gt;*&lt;/sup&gt;だが、U&lt;sup&gt;**&lt;/sup&gt;をUと同一視すれば、Φ&lt;sup&gt;*&lt;/sup&gt; =  Φ となる。Φ(x)をx&lt;sup&gt;#&lt;/sup&gt;と書くことにする。これは、今まで（僕もみんなも）x&lt;sup&gt;*&lt;/sup&gt;と書いたりしていたが、整合性がない、&lt;em&gt;ダメだ&lt;/em&gt;。なぜなら、x&lt;sup&gt;*&lt;/sup&gt; = (x&lt;sub&gt;#&lt;/sub&gt;)&lt;sup&gt;*&lt;/sup&gt;と考えれば、x&lt;sup&gt;^&lt;/sup&gt;のことになってしまい、UとU&lt;sup&gt;**&lt;/sup&gt;を同一視すると、xそのものだ。

f∈U&lt;sup&gt;*&lt;/sup&gt;のときは、f&lt;sup&gt;#&lt;/sup&gt; = Φ&lt;sup&gt;-1&lt;/sup&gt;(f)とする。記法 (-)&lt;sup&gt;#&lt;/sup&gt;のオーバーロードがあるが、カンベンしてもらう。

(x|y) = Φ(x)(y) も考慮すると、定義よりただちに：

+ x&lt;sup&gt;##&lt;/sup&gt; = x
+ f&lt;sup&gt;##&lt;/sup&gt; = f
+ x&lt;sup&gt;#&lt;/sup&gt; = (x|-) = λ.(x|y)

となる。U&lt;sup&gt;*&lt;/sup&gt;の内積は、(f|g) = f(Φ&lt;sup&gt;-1&lt;/sup&gt;(g)) で定義する。すると、次が成立する。

+ (x|y) = x&lt;sup&gt;#&lt;/sup&gt;(y) = x&lt;sup&gt;#&lt;/sup&gt;・y&lt;sub&gt;#&lt;/sub&gt;  （End(K) = K として）
+ (f|g) = f(g&lt;sup&gt;#&lt;/sup&gt;) = f・g&lt;sup&gt;#&lt;/sup&gt;&lt;sub&gt;#&lt;/sub&gt; （End(K) = K として）
+ x&lt;sub&gt;#&lt;/sub&gt;&lt;sup&gt;†&lt;/sup&gt; = (-|x) = λy.(y|x)
+ f&lt;sup&gt;*&lt;/sup&gt; = f&lt;sub&gt;#&lt;/sub&gt; （K&lt;sup&gt;*&lt;/sup&gt; = K として）
+ f&lt;sup&gt;†&lt;/sup&gt; = (f&lt;sup&gt;#&lt;/sup&gt;)&lt;sub&gt;#&lt;/sub&gt;

*1215243466*[物理っぽい][圏一般論][その他代数]うまくいくなあ、ユニタリ対応

なんかうまくいきすぎて不気味つうか、なんか&lt;em&gt;勘違い&lt;/em&gt;してないか不安だ。変な感じがするのは、長さが定義できないのに等長埋め込みのように振る舞うとか。

長さに関しては、内積が対称なら (x|x)を（平方根を取らないで）ノルムのように扱える。(x|x) = ≪x≫ とでもして、(x|y) + (y|x) = 2(x|Y)を使えば次が出る。

- (x|y) = 1/2[≪x + y≫ - ≪x≫ - ≪y≫] 長さから内積は出る

単射性に関しては、ヌルベクトルがあっても、非退化だけから「内積保存⇒単射」が出るのかもしれない。いや、一応そうなっているのだけど：
&lt;pre&gt;
すべてのx, yに対して
 (Ax|Ay)  = (x|A&lt;sup&gt;†&lt;/sup&gt;Ay) = (x|y)
を仮定。

すると、すべてのxに対して (x|A&lt;sup&gt;†&lt;/sup&gt;Ay) = (x|y)。
これから、すべてのyに対して (A&lt;sup&gt;†&lt;/sup&gt;A)y = y 。
よって、A&lt;sup&gt;†&lt;/sup&gt;A = I 。
&lt;/pre&gt;

上の推論から、内積保存なAは、対応する引き込みA&lt;sup&gt;†&lt;/sup&gt;を持つ。引き込みを持つなら単射に決まっている。

(Ax|y) = (x|A&lt;sup&gt;†&lt;/sup&gt;y) に関しては、(A&lt;sup&gt;†&lt;/sup&gt;x|y) = (x|Ay) でも同じだから：
&lt;pre&gt;
 (A&lt;sup&gt;†&lt;/sup&gt;x|y)
 = (Φ&lt;sup&gt;-1&lt;/sup&gt;A&lt;sup&gt;*&lt;/sup&gt;Φx|y)
 = [Φ(Φ&lt;sup&gt;-1&lt;/sup&gt;A&lt;sup&gt;*&lt;/sup&gt;Φ)x]y
 = [(A&lt;sup&gt;*&lt;/sup&gt;(Φx)]y
 = (Φx)(Ay)
 = (x|Ay)
&lt;/pre&gt;

A&lt;sup&gt;††&lt;/sup&gt; = A も普通に計算して出るし、、、、

他に確認したことは：

+ ベクトルxがユニタリ⇔x&lt;sub&gt;#&lt;/sub&gt;がユニタリ埋め込み⇔xが単位ベクトル⇔(x|x) = 1
+ コベクトルfがユニタリ⇔fがユニタリ引き込み⇔fが単位ベクトル⇔(f|f) = 1

あと、W⊆U に対して、W + W&lt;sup&gt;⊥&lt;/sup&gt; = U という直交分解がこれまたうまくいく。手順は：

+ Wの包含をJとすると、Jは内積保存なので、ユニタリ埋め込み
+ Jの随伴をRとすると、Rはユニタリ引き込み
+ P = JR とすると、Pは射影
+ Pの像＝Jの像＝Rの像はWで、W上では恒等
+ Pの核=Rの核 はWの直交空間
+ Pは直交射影を与え、WとPの核であるW&lt;sup&gt;⊥&lt;/sup&gt;で分解できる。

ユニタリ対応としては、PとRを区別しなくていいので、随伴がユニタリである射影はユニタリってことになる。随伴がユニタリの射影はつまり直交射影だから、

- 直交射影はユニタリ

となる。

なんでうまくいくんだ？ いや、うまくいくようにしたつもりではあるが、、、ダガーコンパクト閉圏の1つのモデルを作っているような気もするな。それがうまくいく理由かも。

</body>
</day>
<day date="2008-07-08" title="">
<body>
*1215488145*[物理っぽい][圏一般論][その他代数]すごく簡単になった、ユニタリ対応

紆余曲折があったが、ユニタリ対応の定式化はすごく簡単になった。普通の線形代数だけでOK。だが、ちゃんとSpanを使った定式化の痕跡が残っているのがうれしい。

ユニタリ対応の例として直交射影を考察したが、直交射影は事例ではなくてユニタリ対応の本質。ユニタリ対応とは、直交射影の概念をほんとに&lt;em&gt;わずか&lt;/em&gt;に一般化したものだった。わずかと言っているのは、域と余域が異なってもよいとする所だけだから。

必要なことは、直交補空間が取れることと、直交直和分解の表示を使えば出てくる。ImやKerの計算が出てくるのがなつかしい。

&lt;b&gt;[追記]&lt;/b&gt;

&lt;span style=&quot;font-size:xx-large&quot;&gt;&lt;b&gt;こりゃダメだ。勘違い、間違っている。&lt;/b&gt;&lt;/span&gt;

どうも安易すぎた。圏論的な定義に戻って、部分的に定義された線形写像の結合と、部分的線形写像を全域に拡張する方法をちゃんと考えないとダメ。ようするに、部分線形写像の圏を作って、そｒと全域線形写像、および随伴との関係を調べる。

&lt;b&gt;[/追記]&lt;/b&gt;

*1215523261*[メモ][JavaScript]JavaScript関係、主に真偽値と条件式

いずれ本編記事に&lt;em&gt;まとめる&lt;/em&gt;が、とりあえずこっちにメモ。

&lt;h5&gt;referece型&lt;/h5&gt;

referece型は内部的使用に限定される型。JavaScriptのアドレス（特に左辺値）のことだが、そもそもアドレスモデルが高水準だから、(base propname)というペア。referenceがオブジェクト参照なのではなく、baseがオブジェクト参照でpropnameがプロパティ名文字列。

referenceの値の操作はGetValue, PutValue関数（これらの関数は仕様記述専用関数）。GetValue(V:ReferenceOrOtherValue), PutValue(V:ReferenceOrOtherValue, W:Any)と使うが、

|* 状況 |* GetValue |* PutValue|
|Vがreferenceではない | Vを返す | ReferenceError |
|Vのbaseがnull | ReferenceError | baseを大域オブジェクトとする |

&lt;h5&gt;特殊な値&lt;/h5&gt;

|* 大域変数 |* 型 |* 他の表記 |
| undefined | Undefined Type | (void 0) |
| NaN | Number Type | Number(&quot;a&quot;) |
| Infinity | Number Type | 1/0 |

大域変数はreadonlyではない。deleteもできる。Number(&quot;a&quot;)以外の表記はないのか？

&lt;h5&gt;ゼロのようなもの&lt;/h5&gt;

- 0 == &quot;&quot;
- 0 == &quot;0&quot;
- 0 == &quot;0.0&quot;
- 0 == &quot;-0.0&quot;
- 0 == false
- 0 == null // false!
- 0 == undefined // false
- null == false // false
- undefined == false // false
- null == undefined
- &quot;&quot; == null

&lt;h5&gt;falseと評価されるもの&lt;/h5&gt;

- undefined
- null
- 0 (+0, -0), NaN
- &quot;&quot;

null以外のオブジェクトは、常にtrueに評価される。

- (new Boolean(false) ? 1 : 0) ⇒ 1
- (new Number(0) ? 1 : 0) ⇒ 1
- (new String(&quot;&quot;) ? 1 : 0) ⇒ 1

- Boolean(0) ⇒ false
- Boolean(&quot;&quot;) ⇒ false
- Boolean(new Boolean(false)) ⇒ true
- Boolean(new Number(0)) ⇒ true
- Boolean(new String(&quot;&quot;)) ⇒ true

- Boolean(String(false)) ⇒ true
- String(Boolean(&quot;false&quot;)) ⇒ true
- String(Boolean(&quot;&quot;)) ⇒ false
- Boolean(String(Boolean(&quot;&quot;))) ⇒ true

- Boolean(Number(&quot;0&quot;)) ⇒false
- Boolean(&quot;0&quot;) ⇒true

&lt;h5&gt;内部メソッド&lt;/h5&gt;

|* メソッド |* 戻り値 |* 例外 |*備考 |
|Get(プロパティ名:String) | Any | なし（undefinedを返す） | |
|Put(プロパティ名:String, 値:Any) | Void | なし（何もしない） | |
|CanPut(プロパティ名:String)|Boolean | なし | |
|HasProperty(プロパティ名:String)|Boolean | なし | |
|Delete(プロパティ名:String)|Boolean | なし（falseを返す） | |
|DefaultValue(ヒント:String)|String OR Number | TypeError | |
|Construct(...) | Object | オブジェクト（関数）依存 | 関数のみ|
|Call(...) | Any | オブジェクト（関数）依存 | 関数のみ|
|HasInstance(値:Any) | Boolean | たぶんなし |関数のみ|
|Match(文字列:String, インデックス:Integer) | ? | ?| 正規表現のみ |

正規表現は未調査だが、typeof /a+b/ がfunctionであることに注意。データ型以外に、内部プロパティであるClassがあり、正規表現はRegExpクラス（Class内部プロパティの値がRegExp）。

&lt;h5&gt;その他雑多&lt;/h5&gt;

- NaNはfalseになる。
- undefinedはNaN、nullは0になる。
- ToInt32では、なんとNaN, +∞, -∞が0になる。
- NaN === NaN はfalse、a + 1 + 2 === a + 2 + 1
- (1 + &quot;2&quot;)*3 ⇒ 36
- &amp;amp;&amp;amp; と || は変態、(?:)はマトモ
- true == 1, true == 2 の結果は違う
- true == &quot;2&quot; はfalse
- if (2) print(&quot;YES&quot;); if (2 == true) print(&quot;YES&quot;)
- if (&quot;0&quot;) print(&quot;YES&quot;); if (&quot;0&quot; == true) print(&quot;YES&quot;)

ミステリアス、不思議な世界。

&lt;b&gt;[追記]&lt;/b&gt;
true == 2 は、Boolean(2)とtrueが比較されるのではない。Number(true) と 2が比較される。true == &quot;1&quot;, true == &quot;2&quot;, false == &quot;0&quot;, false == &quot;&quot; でも同じ。
&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2008-07-09" title="">
<body>
*1215569445*[物理っぽい][その他代数][メモ]復習：線形代数 ユニタリ性

[http://d.hatena.ne.jp/m-hiyama-memo/20080708/1215488145:title]
&gt;&gt;
ユニタリ対応の定式化はすごく簡単になった。普通の線形代数だけでOK。
&lt;&lt;

普通の線形代数でも、復習しないと&lt;em&gt;すぐ忘れる&lt;/em&gt;ので、書いておこう。

&lt;b&gt;[追記]&lt;/b&gt;

&lt;span style=&quot;font-size:xx-large&quot;&gt;&lt;b&gt;こりゃダメだ。勘違い、間違っている。&lt;/b&gt;&lt;/span&gt;

以下の議論で、Uに直交分解 X + Y が与えられていると、部分空間Zに X∩X + Y∩Z という分解を誘導するように書いているが、これはウソ。絵を描けば3次元の反例が作れる。どうも安易すぎた。

圏論的な定義に戻って、部分的に定義された線形写像の結合と、部分的線形写像を全域に拡張する方法をちゃんと考えないとダメ。ようするに、部分線形写像の圏を作って、それと全域線形写像、および随伴との関係を調べる。

&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;分解とユニタリ性の定義&lt;/h5&gt;

まず、ベクトル空間の部分空間による分解の議論。X, Y⊆U として、(X, Y)が分解とは、任意のu∈Uが u = x + y x∈X, y∈Y という形で書けること。X, Yで生成される空間を＜X∪Y＞ = X∨Y として、X∨Y = U とも書ける。この加法分解が一意的のとき(X, Y)を一意分解と呼ぶ。

- (X, y)が一意分解 ⇔ X∩Y = {0}

一意分解を仮定して、u∈X∩Yを分解してみる。u = u + 0 （u∈X） という分解を持つ。同様に、u = 0 + u （u∈Y）。分解は一意だから (u, 0) = (0, u) 、つまり u = 0。

逆向き； u = x1 + y1 = x2 + y2 と分解できたとして、x1 - x2 = -(y1 - y2)、x1 - x2 をzと置くと、z∈X, -z∈Y だが、z∈Y でもあるから、z∈X∩Y。仮定からz = 0。つまり、x1 - x2 = 0, y1 - y2 = 0、x1 = x2, y1 = y2なので、分解は一意的。

- (X, Y)がUの分解だとして（一意じゃなくてもいい）、Zを第3の部分空間とする。このとき、(X∩Z, Y∩Z) はZの分解となる。&lt;br&gt;&lt;span style=&quot;font-size:xx-large&quot;&gt;&lt;b&gt;これはウソ。&lt;/b&gt;&lt;/span&gt;

これ↑は、後で。（今、調子悪い）。(X, Y)が最初から一意でもいい。

上の補題は、P:U→W, Q:W→Zがユニタリなとき、結合（合成）P;Qがユニタリであることを示すのに使う。

&lt;hr&gt;

そもそもユニタリの定義を述べてなかった。Pがユニタリとは Ker(P)&lt;sup&gt;⊥&lt;/sup&gt; ≡ Im(P)であること。ここで、(-)&lt;sup&gt;⊥&lt;/sup&gt;は直交補空間、≡は内積同型。

問題は Ker(P)&lt;sup&gt;⊥&lt;/sup&gt; ≡ Im(P)、Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt; ≡ Im(Q)のとき、Ker(P;Q)&lt;sup&gt;⊥&lt;/sup&gt; ≡ Im(P;Q) を示すこと； Ker(P;Q)はP&lt;sup&gt;←&lt;/sup&gt;(Ker(Q)) である（上付き←は逆像）。W上に、(Ker(Q), Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;)という直交分解があるが、これをP&lt;sup&gt;←&lt;/sup&gt;で引き戻したい。そのとき、(Ker(Q)∩Im(P), Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;∩Im(P)) がIm(P)の直交分解を与えているなら、Im(P)はKer(P)&lt;sup&gt;⊥&lt;/sup&gt;と同型だから、Ker(P)&lt;sup&gt;⊥&lt;/sup&gt;内に直交分解が誘導される。&lt;br&gt;&lt;span style=&quot;font-size:xx-large&quot;&gt;&lt;b&gt;これはウソ。&lt;/b&gt;&lt;/span&gt;

誘導された分解は、(P&lt;sup&gt;←&lt;/sup&gt;(Ker(Q)), P&lt;sup&gt;←&lt;/sup&gt;(Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;))、問題はP&lt;sup&gt;←&lt;/sup&gt;(Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;)のほうで、これがIm(Q)と内積同型なことを示す必要がある。だが、Im(Q)→Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;、Ker(Q)&lt;sup&gt;⊥&lt;/sup&gt;∩Im(P)→Ker(P)&lt;sup&gt;⊥&lt;/sup&gt; という同型を繋げばよい。&lt;br&gt;&lt;span style=&quot;font-size:xx-large&quot;&gt;&lt;b&gt;これはウソ。&lt;/b&gt;&lt;/span&gt;

&lt;h5&gt;内積保存なら単射であること&lt;/h5&gt;

随伴に関して次が基本的に重要：

+ (A&lt;sup&gt;†&lt;/sup&gt;x|y) = (x|Ay)
+ A&lt;sup&gt;††&lt;/sup&gt; = A （適当な同一視のもとで）

これを使って、次が示せる。

- A:U→Wが内積保存 ⇔ A&lt;sup&gt;†&lt;/sup&gt;A = Id&lt;sub&gt;U&lt;/sub&gt;

随伴の定義を展開して計算すればよい。これからAが単射でA&lt;sup&gt;†&lt;/sup&gt;が全射だとわかる。

&lt;h5&gt;直交補空間が一意分解を与えること&lt;/h5&gt;

X⊆Uだとして、Xの包含写像をJとする。P = J&lt;sup&gt;†&lt;/sup&gt;とする。直前の定理から、PJ = Id&lt;sub&gt;X&lt;/sub&gt;。K = Ker(P)とする。このKがX&lt;sup&gt;⊥&lt;/sup&gt;と一致することを示す。

まずy∈Kだとして、任意のx∈Xに対して、(x|y) = (Jx|y)（x∈XならJx = xだから）。(Jx|y) = (x|Py)（Pの定義）。y∈K, K = Ker(P) を思い起こせばPy = 0、したがって(x|Py) = (x|0) = 0。任意のx∈Xに対して(x|y) = 0 なのだからx∈X&lt;sup&gt;⊥&lt;/sup&gt;。

逆にy∈X&lt;sup&gt;⊥&lt;/sup&gt;を取る。任意のx∈Xに対して(x|y) = 0。ところで、(x|y) = (Jx|y) = (x|Py) だから、任意のx∈Xに対して (x|Py) = 0、非退化性より Py = 0、y∈Ker(P)。

X∩X&lt;sup&gt;⊥&lt;/sup&gt; = {0} の代わりに X∩K = {0}を示す； x∈Kだとすると、Px = 0、一方PはX上では恒等だから、x∈XならPx = x。よって x = 0 。

*1215582978*[物理っぽい][具体例]古典計算と量子計算

初歩的圏の範囲で対応をとってみる。

|＼|* 古典計算 |* 量子計算 |
|メモリサイズ| n ビット | n キュービット |
|圏の対象 | [n] | [n] |
| 状態空間 | {0, 1}の直積 | &lt;b&gt;C&lt;/b&gt;&lt;sup&gt;2&lt;/sup&gt; のテンソル積 |
|モノイド積 | 集合の直積 | ベクトル空間のテンソル積 |
| モノイド単位 | 単元集合 | スカラー |
| 否定 | 0と1の交換 | e&lt;sub&gt;0&lt;/sub&gt;とe&lt;sub&gt;1&lt;/sub&gt;の交換 |
| 対称性 |直積の置換 | テンソル積の置換 |

*1215584223*[物理っぽい][モノイド圏]抽象スカラーと貼り合わせ自由代数

モノイド積を×、モノイド単位を1として、

- λ:1×A→A
- ρ:A×1→A

を単位律を与える構造射（unitor）だとする。K = End(1)を抽象スカラーとして、抽象スカラーによる乗法は次のように定義される。

- k-*f = λ&lt;sup&gt;-1&lt;/sup&gt;;(k×f);λ
- f*-k = ρ&lt;sup&gt;-1&lt;/sup&gt;;(f×k);ρ

記号-*と*-は苦し紛れ、左乗法と右乗法を区別するため。このとき：

- i;j = i-*j = i*-j
- i;j = j;i （ケリー交換性）

が成立する。スカラーの上では、左乗法も右乗法も結合のことであり、その結合は可換。

&lt;hr&gt;

独立しているが、関連する話。Xを集合、Rを代数（多元環）として、f:X→R という&lt;em&gt;部分写像&lt;/em&gt;があるとする。Xから自由生成された代数をR＜X＞とする。Xは加群の生成元として、Rは1の倍数としてR＜X＞に埋め込める。f&lt;sup&gt;~&lt;/sup&gt;:X→R＜X＞を次のように定義する。

- f(x)が定義されていれば、f&lt;sup&gt;~&lt;/sup&gt;(x) = f(x) ∈R⊆R＜X＞
- f(x)が定義されていないならば、f&lt;sup&gt;~&lt;/sup&gt;(x) = x ∈X⊆R＜X＞

xとf(x)を同一視する関係をR＜X＞に入れたものをR＜X＞&lt;sub&gt;f&lt;/sub&gt;と書く。Xがモノイドであるときは、fにf(xy) = f(x)f(y) を「片方が定義できるなら、もう一方も定義できて等しい」の意味で要求する。

モノイド圏の抽象スカラーは可換モノイドKとなるので、KからRへの部分写像fにより R＜X＞&lt;sub&gt;f&lt;/sub&gt;を定義できる。この代数は、圏全体の係数環として使える。


</body>
</day>
<day date="2008-07-11" title="">
<body>
*1215765532*[物理っぽい][その他代数][メモ]直交性を使うための条件：弱対称性

内積を扱っていて、直交性や直交補空間を使わないのは無理がある。

だが、内積の対称性をまったく仮定しないと直交性がうまく定義できない。x⊥y ⇒ y⊥x がないと辛い。一般には、(x|y) = 0 ⇒ (y|x) = 0 は出ない。2次元で反例：以下、&amp;lt;x, y&gt;は縦ベクトル、[x, y]は横ベクトル。

Φ(&amp;lt;x, y&gt;) = [x + y, -y] と定義する。&amp;lt;1, 0&gt;と&amp;lt;1, -1&gt;は45度三角定規だから、Φは非退化双線形形式を定義する。Φが定義する内積を(-|-)とする。
&lt;pre&gt;
 (&amp;lt;1, 1&gt;|&amp;lt;1, 2&gt;)
= [2, -1]&amp;lt;1, 2&gt;
= 2 - 2 = 0

 (&amp;lt;1, 2&gt;|&amp;lt;1, 1&gt;)
= [3, -2]&amp;lt;1, 1&gt;
= 3 - 2 = 1
&lt;/pre&gt;

これが、(x|y) = 0 かつ (y|x) ≠ 0 の例を与える。

以上より、x⊥y ⇒ y⊥x が欲しいなら、(x|y) = 0 ⇒ (y|x) = 0 を前もって仮定せざるを得ないことがわかる。(x|y) = 0 ⇒ (y|x) = 0 を弱対称性と呼ぼう。

*1215766985*[からみ系]カウフマン流のテンパリー／リーブ圏とアルチン型定理

[http://d.hatena.ne.jp/m-hiyama-memo/20070308/1173336053:title]あたりから、少しは理解が進んだ。書いておく。

2次元のn点（n紐）カウフマン図にループ数のカウントkを組にしたものを射とする圏Dを考える。初歩的な圏になるが、分断的かつ可逆（亜群）となる。D(n, n)は、{n点カウフマン図の全体}×&lt;b&gt;N&lt;/b&gt; となるが、Dをカウフマン図の圏と呼ぶ（ループカウントも含めてカウフマン図と呼ぶと考えればよい）。ブレイドの圏とよく似ている。

圏Dの射を図示するときは、狭義カウフマン図に○を何個か加えて描くことにする。○の位置は問題にならない。D(0, 0)はアブラムスキーの意味でDの抽象スカラーであり、結合でモノイドになる。このスカラーモノイドは、D全体に作用する（ケリーのスカラー乗法）。実際には、D(0, 0)は&lt;b&gt;N&lt;/b&gt;と同型。

Rを代数だとして、φ:D(0, 0)→R をモノイドの乗法的表現とする。D(0, 0)は単元生成なので、生成元○の像φ(○) = τ∈R が決まればよい。R係数でDから自由生成したR加群豊饒な圏R[D]を、φで貼り合わせた圏を作れる。そのとき、係数代数Rの作用は少しだけ変形される（まったく自由ではなくなる）。

こうして作った線形（R加群豊饒な）圏をカウフマン流のテンパリー／リーブ圏と呼び、KTL(R, τ)で示す。τはφ(○)である。KTL(R, τ)は図形的に定義されている。

一方、形式的なジョーンズ基底H&lt;sub&gt;i&lt;/sub&gt;から、組み合わせ的に定義されるテンパリー／リーブ圏もある。こちらは、ジョーンズ流のテンパリー／リーブ圏と呼び、JTL(R, τ)で示す。

KTL(R, τ)とJTL(R, τ)が同型であることは全然自明ではない。そこで、KTL(R, τ)とJTL(R, τ)の同型を具体的に構成する必要がある。この手続きは、図形的に定義されたブレイド群を、組み合わせ的に定義されたアルチン群の同型を示すのと似ている。テンパリー／リーブ圏に対するアルチン型の定理といえる。

他でも、図形的に構成された代数構造と組み合わせ的に構成された代数構造が同型（または同値）であることを主張することはアルチン型定理と呼んでいいだろう。

</body>
<comments>
<comment>
<username>タナカコウイチロウ</username>
<body>＞Φ(&lt;x, y&gt;) = [x + y, -y]&lt;br&gt;について&lt;br&gt;Φ(&lt;a+ b, y&gt;)　＝[a+ b + y, -y]&lt;br&gt;Φ(&lt;a, y&gt;) ＋Φ(&lt;b, y&gt;)＝[a + y, -y]＋[b + y, -y]&lt;br&gt;で、線形性が出てこないんですけど…&lt;br&gt;ベクトルの和に、特別な演算を入れているのですか。</body>
<timestamp>1215915423</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>タナカコウイチロウさん、&lt;br&gt;ほんとに縦に書くのは困難なんで、&lt;x, y&gt;で縦（上下）に並んだ二つの数xとyを代用してるだけです。[x, y]のほうは横に並んだx, y。&lt;br&gt;&lt;a, b&gt; + &lt;c, d&gt; = &lt;a + c, b + d&gt; は高校(?)で習った普通の足し算だと思います。&lt;br&gt;&lt;br&gt;Φ(&lt;a + c, b + d&gt;)&lt;br&gt; = [(a + c) + (b + d), -(b + d)]&lt;br&gt; = [(a + b) + (c + d), (-b) + (-d)]&lt;br&gt; = [a + b, -b] + [c + d, -d]&lt;br&gt; = φ(&lt;a, b&gt;) + φ(&lt;c, d&gt;)&lt;br&gt;&lt;br&gt;Φは線形です。</body>
<timestamp>1215940230</timestamp>
</comment>
<comment>
<username>HN</username>
<body>はじめまして．&lt;br&gt;私は昔タングル圏と戯れており，現在計算機科学に近いところで暮らしているような状況にありまして，このサイトの内容は興味深く読ませていただいています．&lt;br&gt;ところで&lt;br&gt;&gt; Φは非退化双線形形式を定義する。Φが定義する内積を(-|-)とする。&lt;br&gt;のくだりは，「Φは可逆な線形写像を定義する．Φと R^2 の通常の内積から新たに双線形形式が定義される．」ということですよね．何度か読み返してしまいました．</body>
<timestamp>1219072557</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>HNさん、&lt;br&gt;&gt; 私は昔タングル圏と戯れており，現在計算機科学に近いところで暮らしているような状況にありまして，&lt;br&gt;僕は昔デスマーチプロジェクトを渡り歩く生活をしてまして（案の定、体を壊しました）、現在タングル圏と戯れて遊んでいます :-)&lt;br&gt;&lt;br&gt;&gt; このサイトの内容は興味深く読ませていただいています．&lt;br&gt;ありがとうございます。&lt;br&gt;でもここは、原則的に個人的なメモなんで、自分以外の読む人のことは*なんにも*考えてません。間違いや早とちりやtypoに満ちていると思いますので、ご了承ください。&lt;br&gt;&lt;br&gt;&gt; 「Φは可逆な線形写像を定義する．Φと R^2 の通常の内積から新たに双線形形式が定義される．」ということですよね．&lt;br&gt;あー、そうです、そうです。日本語が変ですね（つうか、間違っている）。僕の中では、UからUの双対への可逆線形写像と非退化双線形形式が同一視されていたんです。非退化双線形形式は、コンパクト閉圏でいえば余単位だし、上から下に向けて描くタングルなら∪です。</body>
<timestamp>1219103523</timestamp>
</comment>
</comments>
</day>
<day date="2008-07-15" title="">
<body>
*1216077763*[オフトピック][メモ]遺失物

+ Gnu Makeのマニュアル （2008-09-12 見つかった）
+ 物理に出てくる確率過程（お見合い問題／モーテル問題だっけ？）について書いてあったムック


</body>
</day>
<day date="2008-07-17" title="">
<body>
*1216279081*[その他代数][雑感][具体例]線形代数を今振り返ってみると

やっぱり具体例で見ると面白いな。

U⊆W だとして、埋め込み U→W を次の完全列に拡張する。

- 0→U→W→W/U→0

双対を取っても完全だから、

- 0→(W/U)&lt;sup&gt;*&lt;/sup&gt;→W&lt;sup&gt;*&lt;/sup&gt;→U&lt;sup&gt;*&lt;/sup&gt;→0 （完全）

U→Wが埋め込みのとき、W&lt;sup&gt;*&lt;/sup&gt;→U&lt;sup&gt;*&lt;/sup&gt;は、W上の線形形式（コベクトル）をU上の制限する写像。f∈W&lt;sup&gt;*&lt;/sup&gt;なら、f|&lt;sub&gt;U&lt;/sub&gt; として与えられる。この制限写像の核が(W/U)&lt;sup&gt;*&lt;/sup&gt;となる。

この事実を言い換えると、部分空間U上では零になる形式は、商空間U/W上の形式を定義することになる。これは3次元あたりの絵を描けばわかる。特に、商空間が補空間で実現できることを考えると：

- 直線の束があって、各直線に対して値を取るような形式で、原点を通る直線では零になるものは、束の切断面上の形式と同じこと。
- 平面の層があって、各平面に対して値を取るような形式で、原点を通る平面では零になるものは、層の貫通直線上の形式と同じこと。

代数的な完全列や双対が、なんか物理的なイメージで語れるところが面白い。

</body>
</day>
<day date="2008-08-06" title="">
<body>
*1217985641*[メモ]ネタ、ネタ、ネタ

本編含めて書くことが色々あるが、ネタに筆（キーボード）が追いつけない。

- タングルの定義
- トレースを含めたタングル圏による古典knot theoryの整理
- アルチン型定理としてみたトゥラエフ移動と組み合わせ的計算
- jsonエンコーダの作成
- JavaScript用のMakefile
- new JsDoc toolkit
- makeのパターン（%）について
- 非対称な直交性について、2つの直交補空間
- 内積保存埋め込みスパンの圏
- WCCのこと
- ErlangのOTP管理下アプリケーション、リリース、システムなどの概念
- Erlangのビヘイビアをもっと詳しく
- YAWSのビルドとインストールの試み on windows
- 上江州計算
- とりあえず上江州計算の記号法
- 紐と添字のテンソル計算

*1217986856*[からみ系]カウフマン図を(2+ε)次元で考える

まず、狭義のカウフマン図は2次元図形だと考える。ループを入れて広義のカウフマン図を考えた場合、2次元だと、どうしても次の点がスッキリしない。

- ループだけがなぜ自由に移動できるのか？

それで、カウフマン図を&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080703/1215073610&quot;&gt;(2+ε)次元の幾何&lt;/a&gt;で考える。厚みがεの薄い箱に3次元カウフマン図（特殊なタングル）を閉じ込めると、可能性として交差ができるが、その交差はΨ移動や2回クロスの解消などで消すことができる。つまり、カウフマン図は「交差しない」のではなくて、交差しても「交差をを消せる」のだ。

カウフマン図の紐（ストランド）は、上下の棒に繋がれているので、ある種のディレクレ条件の支配下にある。∩と∪が合体すると、なぜか拘束がはずれて自由になる。ループも交差を許されるから、拘束がないと自由に動けることになる。

この描像でも、「拘束がはずれる」メカニズムが天下りだが、2次元よりは多少の納得感がある。境界がくっつくと拘束がはずれることは、境界に電荷（チャージ）を考えると分かりやすいかもしれない。電荷が打ち消し合って拘束から自由になるのだろう、たぶん。

</body>
</day>
<day date="2008-08-07" title="">
<body>
*1218090966*[からみ系][小咄]輪が組み替えられると

惰読用の本（もうどっかにいった）に面白い絵があった。次のようなもの。

&lt;img src=&quot;http://www.chimaira.org/img2/two-loops.gif&quot; &gt;

円筒とかトーラスに白と黒の輪ゴムが巻き付いているとする。その2つの輪がぶつかって交差する。2次元というより、これも(2+ε)次元で考える。なんかのはずみで2本の輪に組み替えが起こると、トポロジーがまったく変わってしまう。

これは、ブレイド交差に対するスプライシングと同じだ。DNA鎖とかでは実際に組み替えが起こっているらしい。なんか面白いな。

*1218091313*[からみ系][説明]タングルの絵

箱入りのタングルの説明をしようと思って描いたドラフト。

&lt;img src=&quot;http://www.chimaira.org/img2/boxed-tangles.gif&quot;&gt;


</body>
</day>
<day date="2008-08-08" title="">
<body>
*1218164637*[圏一般論][その他代数][課題]圏-R代数とR化圏

Rを可換環だとする。半群、モノイド、群などに対して、R係数の半群環、モノイド環、群環などが定義できる。最近の用語法では、群環より群代数と呼んだほうがいいかもしれない。ようするに、Xの元から自由生成された加群に、Xの積から誘導（induce）された積を入れた代数。まったく同様にして、圏CのR係数の圏代数R&amp;lt;C&gt;が定義できる。Cが箙（えびら；有向グラフ）Gの道(path)圏Path(G)であるときが有名。

一方で、圏Cの各ホムセットC(a, b)をR加群にすることができて、R加群豊饒化した圏R[C]も作れる。これは、「CをR加群豊饒化した圏」と呼ぶべきだが、長いからR化圏ということにする。

Rに対する圏代数R&amp;lt;C&gt;とR化圏R[C]はよく似てる。ほとんど同じと言っていいくらいだ。この「ほとんど同じ」を厳密に述べよ（課題）。

他にも、圏Cからクリーネ圏を作るのと、クリーネ代数を作るのが似てる。おそらく、半環Rに対しても、R&amp;lt;C&gt;とR[C]の類似性は成立しているのだろう。もっと一般化して、基数κに対してκ総和可能な半環Rに対して、κ総和可能な半代数R&amp;lt;C&gt;と、κ総和可能な加群で豊饒化されたR[C]のあいだにも類似があると思う。

*1218164638*[からみ系][課題]一般化スケイン加群

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080702/1214988540&quot;&gt;スケイン関係式&lt;/a&gt;に関して、穴と図式コンテキストの概念を書いた。穴は型付き（dom, codが指定されている）変数だと思ってよい。となると、図式コンテキストは一種の項だろう。穴に名前か番号を付けたセットを考えておけば、代入もできる。名前付き穴のセットをXとすると、Xを含むコンテキストの全体Cont(X)は代入をモナド乗法としてモナドになる。

Xが穴の名前付きセットだとして、Xに対する穴なし図形の割り当てがスケインセット（スケイントリプルの一般化）となる。Cont(X)のアイソトピー類を取って、さらに自由加群を作る。この自由加群内で、スケインセットSに対するスケイン関係式を定義できる。スケイン関係式の記述は、カウフマンがやっているように、穴に入るべき実図形を括弧で囲んだ記号と、スカラー乗法、足し算、等号を使って記号的に表現できる。

結局、スケインセット上のスケイン関係式は、スケインセット上の自由加群の部分加群になる。これはまた、Cont(X)（のアイソトピー類）上の自由加群の部分加群と対応する。この部分加群がスケイン加群と呼ばれるものだろう（たぶん、要確認）。

スケイン関係式／スケイン加群をもう少し圏論的に定式化できないかな？

ところで、「穴」とう用語は円環やトーラスの穴と間違われるのでまずいな。部屋（チャンバー）にしようか。仮引数、実引数にならって、仮チャンバー、実チャンバーとか。となると、図形コンテクストも図形項か項図形か？

</body>
</day>
<day date="2008-08-19" title="">
<body>
*1219116824*[気付いた]可換性に関する論法：ケリーとエクマン／ヒルトン

モノイド圏のスカラー（アブラムスキーの言う抽象スカラー）が可換モノイドになることはケリーが証明したらしいが、これってエクマン／ヒルトン論法（The Eckman-Hilton argument）と同じだよね。モノイド積が双関手であるところがミソ； 交替律の成立が可換律を導く。

</body>
</day>
<day date="2008-08-20" title="">
<body>
*1219198533*[気付いた][からみ系]テンパリー／リーブ代数とかフロベニウス代数とか、どう理解するか

表題にテンパリー／リーブ代数と書いたが、実際はテンパリー／リーブ代数よりもっと基本的な代数なんだが、どうも特定の名前がないような気がする。まー、圏として見れば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070427/1177656071&quot;&gt;「直進圏とその変種」&lt;/a&gt;で書いたようなタングル圏の変種のこと。フロベニウス代数は線形代数で定義できるが、圏としては曲面のコボルディズム圏になる。

フロベニウス代数に対応する曲面の圏は、タングルの圏の2次元版かというと、まったく&lt;em&gt;もつれてない&lt;/em&gt;ので趣がだいぶ異なる。にもかかわらず、外の空間（箱）が十分に高次元の場合の2次元タングルと思うことはできる。箱入りコボルディズム（相対コボルディズム）圏の特殊例になっていると考えてよい。

|＼                       |* タングルの圏 |* 曲面の圏 |
|注目する図形           |コンパクト1次元多様体 | コンパクト2次元多様体 |
|図形の境界の形           | n個の点（n≧0）    | n個の円周（n≧0） |
|外の空間（箱）の次元     | 3                    | 十分高いN |
|境界が載る空間（棒）の次元 | 1                  | 2 |
| からんでいるか          | YES                  | NO |
|関連する代数             |テンパリー／リーブ、他| フロベニウス |

フロベニウス代数は、曲面の圏（からんでない2タングルの圏）を表現すると考えられる。からんでないので、ある意味では1次元タングルより簡単である。曲面の圏の生成元は、円筒パイプ（円周1個のid）、上下のズボン、上下の帽子（cup, cap）となる。n個の円周に全順序を入れる場合は、入れ替えとしてパイプの対称公差（クロッシング）も入る。

パイプの中心線を考えると、曲面の圏は1次元絵算で計算できる。ズボンはΔ、∇、帽子は生成／消滅になる。

1次元でも2次元どちらの場合でも、次のような3つのタイプの圏が出現する。

+ ほんとの図形の、なんらかのアイソトピー類の圏（幾何学的）
+ 記号の組み合わせによる圏（計算しやすい、アルゴリズムとして記述可能）
+ ベクトル空間や加群からなる圏に追加構造を付けた圏（基底を取れば行列計算）

ベクトル空間の圏を、双対を考えてスター圏、随伴（共役）を考えてダガー圏のように捉えておいて、その部分スター圏／部分ダガー圏などに、非退化双線形形式やR行列のような可逆な演算子などを見つける作業をするが、あれは、タングルや曲面の圏の線形表現を作っていることになる。

ようするにTQFTの枠組みだが、こう考えると話は簡単になる。いや、物理的な内容はトンデモナク難しくて、まったく手が出ないが、組み合わせ計算のところはシコシコ計算できるし、行列の計算も実行可能だから、計算目的なら理解可能な形となる。


</body>
</day>
<day date="2008-08-21" title="">
<body>
*1219312593*[用語法][メモ]自然数が対象の圏はPROP

[http://d.hatena.ne.jp/m-hiyama-memo/20080416/1208352842:title]：
&gt;&gt;
自然数（非負整数）集合が対象である圏をなんか呼び名があったような。PROだかPRODだか、うーんと？ 
&lt;&lt;

PROPです。ステファン（スティーブンか？）・ラックの&quot;Composing PROPs&quot;ってのがある。

- http://www.tac.mta.ca/tac/volumes/13/9/13-09abs.html


</body>
</day>
<day date="2008-08-22" title="">
<body>
*1219386898*[リンク]クリス・アイシャムのトポス理論

- http://math.ucr.edu/home/baez/topos_physics/


</body>
</day>
<day date="2008-08-23" title="">
<body>
*1219463293*[用語法]自立と自律

自立圏と自律圏が混じっているな。[http://d.hatena.ne.jp/m-hiyama-memo/20070506/1178446182:title]の段階で既に混じっている。「自立」を使おうと思っているが、まーいいや、ほっておこう。

*1219464310*[からみ系][トレース／コンパクト閉圏][物理っぽい]自明が自明ではない：コンパクト閉圏内のフロベニウス代数

対称性を仮定しないコンパクト閉圏（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080823/1219463293&quot;&gt;自立圏&lt;/a&gt;と呼ぶことにしたのだった）には自明なモノイドがある。次のエントリーに書いておいた。
- [http://d.hatena.ne.jp/m-hiyama-memo/20070523/1179889032:title]

が、これが含意する内容は全然&lt;em&gt;自明でない&lt;/em&gt;かもしれない。

- 同じようにコモノイドも定義できる。
- 実はフロベニウス代数になる。

結合律、単位律、フロベニウス律などを絵算で示すと、テンパリー／リーブ代数つうかカウフマン図が出てくる。ケリー単位は実際にモノイド単位だし、ケリー余単位はコモノイド余単位になる。

行列計算（つうか古典テンソル計算）で追いかけても、それほど自明な結果ではない、面白い計算になる。A |→ A&lt;sup&gt;*&lt;/sup&gt;(×)A という対応を作ると、なんか出てくるかな。

クックとパヴロヴィックの定式化だと、「古典対象＝フロベニウス代数」だが、このフロベニウス代数は、フロベニウス・コモノイドと呼ぶのがふさわしい。フロベニウス・コモノイドを使った&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060603/1149326993&quot;&gt;スタンピング&lt;/a&gt;コモナドが定義できる。このコモナドの余Kleisli圏がどうも、測定（波束の収縮）を定式化するらしい。

*1219466252*[からみ系][トレース／コンパクト閉圏][物理っぽい]フォックスの定理

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080823/1219464310&quot;&gt;直前のエントリー&lt;/a&gt;は、次を読んで思ったことだ。

- Bob Coecke, Dusko Pavlovic &quot;Quantum measurements without sums&quot; http://arxiv.org/abs/quant-ph/0608035 

このなかに、フォックス（Fox）の定理というのが出てくるのだが、なかなかに凄まじい。概要を以下に書いておく。

Qが対称モノイド圏とする。Qと書いたのは気持ちとしては量子圏とか線形圏とか、線形論理が幅をきかすような圏。Qの内部コモノイドの全体をK(Q)とする。Kは「古典」のつもり。「コモノイド＝デカルト構造＝古典構造」という感じだ。K(Q)はQから作っているので、下部構造にQの対象・射を持つ。よって、忘却関手U:K(Q)→Qがある。

Cがデカルト圏だとして、対称モノイド圏Qへのモノイド積を保つ関手F:C→Qを考える。Qは固定して、C, Fを動かす。F:C→QとG:D→Qの間の射を、デカルト関手Φ:C→DでF, Gと可換になるものだとする。こうやって作った圏をClassic(Q)とする。Q上で実現できる古典世界の全体がClassic(Q)だ。忘却関手U:K(Q)→QはClassic(Q)に入るが、Uは終対象であることがフォックスの定理。U:K(Q)→Qは、ある意味で最大の古典世界で、他の古典世界を含んでいるほどに豊かだと思ってよい。

古典対象は、Qに棲んでいるのではなくて、実際はK(Q)内にいる。以下、k(Q)をKと書くとして、X∈Kごとに、Q上のコモナドと余Kleisli圏ができる。すべての余Klesili圏をたばねたものが世界の表現なのかもしれない。もっとも、この発想は操作的でご都合主義だから、世界の実相に迫れるとは思えないが、まー、計算には便利。

古典対象を、{0, 1}&lt;sup&gt;n&lt;/sup&gt; に限っただけでも面白いと思う。ビットの古典世界の“量子化”になる -- ここでいう量子化は普通の意味じゃなくて、測定値を古典的集合Xにしたときに、古典集合Xを通して見える量子的世界を考えることだ。量子計算は、この枠組みでもいいような気がする。

*1219467674*[量子計算][用語法]量子ナントカ

量子計算＝量子コンピュータ＝量子回路＝量子ゲート

全部同義語。実体はとある圏の射。量子データ型が対象、量子状態は文脈による。古典対象Xによる測定は、(余Kleisli圏)&lt;sup&gt;op&lt;/sup&gt;の射。

</body>
<comments>
<comment>
<username>msakai</username>
<body>Qに余自由なコモノイドを作るコモナド !: Q→Q があれば、線形論理のモデルでよくある話だと思うのですが、それが前提になっていないのが何だか凄そう……</body>
<timestamp>1220049981</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>msakaiさん、&lt;br&gt;&lt;br&gt;フォックスの定理は簡単な言及を見ただけですが、すごそうです。セリンガーも、ゆるい条件を満たすモノイド圏のなかに極大なデカルト閉圏が一意に存在することを示したりしてます。デカルト閉圏≒古典的世界、なんらかのモノイド圏≒量子的世界と考えると、こういうタイプの定理は「世界の関係」を示すので興味深いです。&lt;br&gt;&lt;br&gt;定式化がいくつかあるのがまた面白い； (1)古典世界は量子世界の部分圏、(2)古典世界の古典対象ごとに量子世界がある（ファイバー圏）、(3)古典世界の下部構造として量子世界がある（忘却関手）。&lt;br&gt;&lt;br&gt;ところで、線形論理のビックリ（!）はよくわかりません。構文じゃなくて、わかりやすい具体的な意味論てないんですかね。フォック空間を使うのは見たことあるけど、構文との対応がよくわかりませんでした。</body>
<timestamp>1220069397</timestamp>
</comment>
<comment>
<username>msakai</username>
<body>! の具体例として個人的に馴染み深いのは、Cppo(最小元を持つ完備半順序集合)と正格な連続関数からなる圏での、持ち上げ(新たな最小元の追加)です。&lt;br&gt;もっとも、この圏はSMCCではあるものの、あまり線形論理っぽくはないのですが。&lt;br&gt;&lt;br&gt;あと、Chu spaces なんかでも ! を具体的に構成できたと思います。</body>
<timestamp>1220484704</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>&gt; あと、Chu spaces なんかでも ! を具体的に構成できたと思います。&lt;br&gt;そうなんですか。セリンガーが量子計算で ! を使っているのですが、構文と計算規則しか出してないので、実感が湧かないんですよね。日常言語との対応も付かないし。</body>
<timestamp>1220500251</timestamp>
</comment>
</comments>
</day>
<day date="2008-08-25" title="">
<body>
*1219622473*[説明][トレース／コンパクト閉圏][具体例][気付いた]これは面白い例題！ フロベニウス代数

- [http://d.hatena.ne.jp/m-hiyama-memo/20070523/1179889032:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080823/1219464310:title]

基底を決めたベクトル空間で、具体的なテンソル計算をしても楽しい。行列（線形写像）の2階テンソル表現を、アブラムスキーのname（つまり、カリー化したコード）だと思うと面白い。フロベニウス代数の乗法を・、name（エンコード）を[-]とすると、[f;g] = [f]・[g] となる。「行列積は、テンソル積して縮約する」に対応している。

ゲンツェンの言葉だと、縮約（contraction）の反対は水増し（thinning, weakening）だが、テンソル計算では何と呼ぶのだろう？ 対角と言えば対角だな。

まー、ともかく、古典テンソル計算を楽しくする方法がみつかったよ。これを使って、古典テンソル計算と対称コンパクト閉圏の対応を付けよう。オモロゥ。

*1219656815*[リンク][用語法]プロペラッド（PROPERAD）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080821/1219312593&quot;&gt;PROP&lt;/a&gt;に関連してプロペラッド（properad）てのがある。PROPとオペラッドからの造語だろう。

- http://www.google.co.jp/search?hl=ja&amp;q=site:arxiv.org+properad

けっこうある。

</body>
<comments>
<comment>
<username>bonotake</username>
<body>&gt; 行列（線形写像）の2階テンソル表現を、アブラムスキーのname（つまり、カリー化したコード）だと思うと面白い。&lt;br&gt;&lt;br&gt;ちょうど今、自分もこの対応付けをやろうとして、もがいてます。でもやっぱり計算めんどい・・・（笑）</body>
<timestamp>1219627257</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>はじめはしんどいけど、しばらくやっているうちにカリキュレータズ・ハイになって楽しくなってきます。</body>
<timestamp>1219656371</timestamp>
</comment>
</comments>
</day>
<day date="2008-08-27" title="">
<body>
*1219800729*[からみ系][圏一般論]図式コンテキストと記号回路

スケイン関係式の定式化で図式コンテキスト（型付きプレイスホルダーが含まれる図）が必要だと書いた。

- [http://d.hatena.ne.jp/m-hiyama-memo/20080702/1214988540:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080808/1218164638:title]

以前から気になっていた記号回路って概念（例えば↓）も、図式コンテキスト同じだと思う。

- [http://d.hatena.ne.jp/m-hiyama-memo/20070511/1178842309:title]

*1219802757*[論理][圏一般論]シーケントで書ける圏上のオペレータ

列挙する。思いつけば書き足す。

+ 恒等（id）
+ 結合（composition）狭義のカット
+ モノイド積
+ 一般のカット＝恒等と結合とモノイド積の組み合わせ
+ 結合律の構造射（平等バージョン）
+ 単位律の構造射（平等バージョン）
+ 始対象、終対象
+ カリー化、アンカリー化
+ 双対（スター関手）
+ 随伴（ダガー関手）
+ トレース
+ 増、減、換

「増、減、換」は難しい。対角を持つ対称圏なら：

- 増 対角により右側はできる。左増はできない。
- 減 対角により左側はできる。右減はできない。
- 換 対称で左右ともできる。

使えるルールと圏の概念との対応。

+ 単なる圏 -- 恒等と結合、カンマも使えない！
+ モノイド圏 -- モノイド積、結合律、単位律（1の自由な増減）
+ 対称モノイド圏 -- 交換
+ 点付き圏など -- 始対象、終対象
+ 閉圏 -- カリー化、アンカリー化
+ スター圏 -- スター （当たり前だ）
+ ダガー圏 -- ダガー （当たり前だ）
+ トレース付き圏 -- トレース （当たり前だ）

*1219805223*[メモ][からみ系]黒板枠付け

黒板枠付けはカウフマン本に載っていた。




</body>
</day>
<day date="2008-08-28" title="">
<body>
*1219908274*[気付いた][圏一般論][その他代数]モノイドの圏と加群の圏

Cがモノイド圏だとして、Mon(C)をCの内部モノイドの圏とする。Mon(C)はΔを単体圏としての関手圏C&lt;sup&gt;Δ&lt;/sup&gt;としても実現できる。Cが線形（AbとかLinで豊饒化されているとか、アーベルだとか）のときは、Mon(C)は「Cの代数」の圏と呼ぶ方が普通だろう。

CのモノイドAと、a:A×M→M という射があって、aがAの乗法に対して結合的／単位的なとき、(A, M, a)はA上の加群だといってよい。集合圏ならモノイドAが作用する集合（A-集合）、線形圏なら通常の加群となる。Cの加群の圏をMod(C)とする。Mon(C) = C&lt;sup&gt;Δ&lt;/sup&gt;と同様に、適当な図式の圏Γがあって、Mod(C) = C&lt;sup&gt;Γ&lt;/sup&gt;とできるだろう。Γの生成元は2個だな。

双対的な議論で、コモノイド上の余加群が定義できる。双モノイド（双代数）やフロベニウスモナド（フロベニウス代数）も考えられるし、両側加群、両側余加群、双加群、両側双加群などのバリエーションも考えられる。

</body>
</day>
<day date="2008-08-29" title="">
<body>
*1219980591*[物理っぽい]古典的とは可換代数か？

クックやパヴロヴィックによると、「古典対象＝ある種のフロベニウス代数」ということだ。余可換な余積は双対を取れば可換な積となる。つまりは、可換代数が古典的と考えればいい。ゲルファンドなどの表現論だと、可換代数は点（基底と考えてよい）を持つから、点を点に移すような写像が古典的となる。結局、古典圏とは可換代数の圏となる。

となると、可換代数上の加群の圏が量子的圏に対応する。 -- と、そんなに簡単なわきゃないのだが、観測の議論をうまくすれば、観測の結果（outcome）として古典的な点が得られる、という筋書きはできるかもしれない。

*1219980889*[気付いた][トレース／コンパクト閉圏][物理っぽい]等長写像と部分埋め込みの圏

クックは、関係の圏とヒルベルト空間の圏が似ていると言っている。ヒルベルト空間の等長写像は、部分埋め込み（部分的に定義された単射）と似ている。付点集合を考えて、未定義部分は零（pointedのpointのこと）で吸収すると、部分埋め込みと同値な圏ができる。付点集合の零をベクトル空間の零とみなしての自由生成ベクトル空間を考えると、だいたい等長になる気がする。

*1219981730*[用語法][トレース／コンパクト閉圏]ストリートの用語法と記法

Ross Streetの&quot;Frobenius algebras and monoidal categories&quot;から。

モノイド圏の構造を与える自然同型は constraints。

- associatvity constraints and unital constraints
- unit constraints とも書いている。

A duality A -| B とは、α:A×B→I, β:I→A×B でジグザグ等式を満たすもの。詳しく書けば、(A -| B) = (A, B, α:A×B→I, β:I→A×B)。関手の随伴と同じ記号、いろいろな意味で具合がいい。

モノイド圏が、自立（autonomous）、コンパクト、堅い（rigid）とは、任意のAに対して C -| A -| B となる2つのduality C -| A,  A -| B があること。この用語法では、

- 自立圏 ＝ コンパクト圏 ＝ 堅い圏

自立にもコンパクトにもなんら特別な意味はなくて、単に with duals のこと。右だけ、左だけの双対は特に言及してない。

*1219984852*[用語法][トレース／コンパクト閉圏]自然基底と計算用基底

ダガー・コンパクト閉圏のダガー・フロベニウス代数を扱う場合などは、フロベニウス構造から決まる自然基底（古典集合、古典空間）があるから、これと計算用に人為的に取った基底は区別する必要がある。natural baseとcomputational base。


</body>
</day>
<day date="2008-08-30" title="">
<body>
*1220071161*[量子計算][物理っぽい]測定構造と自然基底／計算用基底、空間

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080829/1219984852&quot;&gt;自然基底と計算用基底&lt;/a&gt;という概念はバカみたいだが、すごく重要かも知れない。僕らが自然基底（あるいは標準基底）だと思っていたのが計算用基底だったのかも知れない。

例えば、自己随伴（自己共役）作用素があると、固有ベクトルの組が自然基底ということだろう。関数を、時間や空間の変数で書いているのは、たまたま使いやすい計算用基底（あるいは記述用基底）を使っているのであって、（ある観点からは）自然ではないってことだ。

スペクトル論（の一部）は、与えられたヒルベルト空間＋自己随伴作用素（観測構造といえるだろう）に対して自然基底を求める手法といえるだろう。複数の自己随伴作用素があれば、それぞれが自然な基底を持つ。交換する作用素は自然基底を共有する。が、一般には交換＝共有しないから、いろんな自然基底があるってこと。いろんな基底による表示＝展開は用途により使い分ける。

基底とはつまり空間なんだろう。空間とは関数がそこで定義されるべき点の集まりね。実際には、点があるから関数があるのではなくて、関数があるから点が見える。で、見え方がいろいろ。ことなる方向から見ると空間もいろいろな見え方をする。空間が変われば、当然ながら関数の表示（展開）も変わるわけだ。

物理や工学で、時間領域と周波数領域って言葉を使うが、（言葉は変だが）あれは時間空間と周波数空間といっても同じ。ことなる空間で同じ関数を見ると（展開すると）表示式は違うが実体は同じ。表示の側の変換＝展開の書き換えがフーリエ変換だな、おそらく。

自然基底が一意に決まるかというと、そうでとは限らない。例えば、正規直交基底はユークリッド空間やヒルベルト空間の自然基底だが、一意には選べない。基底のあいだも変換群でも結ばれている。この場合は直交群やユニタリ群。

ヒルベルト空間上のダガー・フロベニウス構造は一意的に基底を定めるそうだから、これはものすごく強い構造ってことになる。究極的に強いね、標準基底が1個しかないのだから。

*1220073354*[量子計算][お絵描き][トレース／コンパクト閉圏]ベル状態を使ったラムダ計算

アブラムスキー／クックの用語でいうベル状態／ベル余状態だけど、あれは確かに重要だよな。だって、コンパクト閉圏でラムダ計算しようとしたら必須の構成要素だもの。普通は、ベル・ナントカとかいわずに単位／余単位だけど。

このことは、お絵描きすれば&lt;em&gt;実に明らか&lt;/em&gt;。

&lt;img src=&quot;http://www.chimaira.org/img2/lambda-in-compact-cat.gif&quot; &gt;

いちおう説明：

上段が定義、下段が計算。図示の方向は上から下（下から上じゃないよ！）。eval（計算科学ではむしろapply）は&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080623/1214181815&quot;&gt;オダンゴ&lt;/a&gt;（&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080222/1203648686&quot;&gt;ジョン・バエズは「evバブル」と呼ぶ&lt;/a&gt;）。指数 A -o B は双対とテンソル積で A&lt;sup&gt;*&lt;/sup&gt;×B と書ける。ev(x, f) = f・x なこと（位置の逆転）に注意。基本は&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20071029/1193619375&quot;&gt;普通のラムダ絵算&lt;/a&gt;と同じ。

この絵でいいたいことは&lt;b&gt; fx = (λx.(fx))・x &lt;/b&gt;ってこと。エータ（イータ）変換と簡単なベータ変換を含んでいる。ｆのラムダ抽象はアブラムスキー／クックの三角で示したが、これはベル状態によるfのエンコード（アブラムスキーはfのnameとかconameと呼ぶ）。

計算のミソは、ベル状態とベル余状態でジグザグ等式が成立すること。空間的に離れたところでは過去と未来をズラしていいこと。空間的な隔たりは無視していいこと。

空間的な隔たりを考えると、これは量子テレポーテーションの絵になっている。つまりは、量子テレポーテーションとはベータ変換てことで、ベル状態とベル余状態がベータ変換を引き起こすメカニズムを与える。ウム、そうか。

*1220074778*[用語法][トレース／コンパクト閉圏][課題]もうなにも気にしないで「コンパクト」を使おうか

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070506/1178446182&quot;&gt;「ソブリン圏」&lt;/a&gt;に、次のように書いている：

- ソブリン（自足）圏は、両側自律圏であり、右双対と左双対が一致するもの。

- リボン圏はブレイドとねじれ（ツイスト）を持つので、ブレイド／ねじれの性質から、右双対から左双対を定義できて、それが一致することが証明できる(たぶん、やってないけど）。よって、リボン圏は自足圏の例となる（はず）。

「（両側）自立でブレイドとツイストを持てば自足」てのは重要だ。それがほんとなら、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080829/1219981730&quot;&gt;ストリート&lt;/a&gt;のように、語源とか経緯とか考えずに、「コンパクト＝自立＝堅い」と言ってしまってもいい。コンパクト対称圏は対称性から自足圏だろうから、今までの定義と整合する。単なるコンパクト圏＝自立圏では自足性は言えない。例えば軸的圏はコンパクト圏＝自立圏だが、対称でもブレイド付きでも自足でもない。

ダガー構造を持てば、ダガーコンパクトの条件に自足になる前提が含まれているから、この場合も、コンパクト圏＋追加公理としてダガーコンパクト構造を捉えてよい。

スター自立圏は、自立圏であり、左双対が A⊃⊥ に対応する A -o D で与えられるものだろうと思うが、ここらへんはよくわかってない。

*1220078325*[メモ][物理っぽい][その他代数]コンヌの言葉

アラン・コンヌが次のようなこと（ママではない）を言っている。

&gt;&gt;
可換群Γから出発する（Γはコンパクトのようだが、ハッキリはしない）。Γの双対空間をXとする（Xはたぶん指標の空間だろう）。Xはコンパクトである（？ そうなのか？）。X上の複素数値連続関数の環C(X)を考える。普通の積と複素共役を考えると、C(X)は対合を持つ可換バナッハ環になる。C(X)は、Γ上の畳み込み積で作ったC&lt;sup&gt;*&lt;/sup&gt;(Γ)に同型。
&lt;&lt;

以上は、Γが円周の場合のフーリエ理論とかを、ゲルファンド表現で言い直したもののような気がする。

&gt;&gt;
可換フォン・ノイマン環の理論＝自己共役作用素のスペクトル理論＝ルベーグ測度の理論
&lt;&lt;

最初の等号はなんとなくわからないでもないが、ニ番目の等号は見当が付かない。

</body>
</day>
<day date="2008-09-01" title="">
<body>
*1220229976*[連絡的]低水準の基本的な概念・用語

- ビットだけの世界がそこにある。
- ビットコンビネーション、バイト、オクテット(octet)、ワード、レジスタサイズ
- いまどき、「バイトとオクテットは違います」なんていうヤツはいねーと思うが。
- 「レジスタっても何本もあるよ」というツッコミはあるかもね。
- メモリセル、アドレス、アドレス空間、メモリ空間
- 「アドレス空間とメモリ空間はどう違うんですか？」「しらねーよ」
- メモリオブジェクト、メモリブロック、メモリ領域
- メモリオブジェクトが正式な用語法だと思うんだが、「オブジェクト」から変な連想をするヤツが多くて困る。よって、僕は「ブロック」を多用する。
- 算術値、論理値、アドレス値 -- 所詮はビットコンビネーションだが用途によって分類できる。原始的な型概念。
- 符号のありなし、これも原始的な型概念。与えられたビットコンビネーションをどう解釈するか、解釈の立場や方法、その後の取り扱い方の指針。
- 16進ダンプや2進ダンプは基本。


</body>
</day>
<day date="2008-09-02" title="">
<body>
*1220347467*[リンク][量子計算]OR学会誌の量子計算連載PDF

- http://www.orsj.or.jp/~archive/pdf/bul/Vol.47_04_251.pdf
- http://www.orsj.or.jp/~archive/pdf/bul/Vol.47_05_322.pdf
- http://www.orsj.or.jp/~archive/pdf/bul/Vol.47_06_393.pdf
- http://www.orsj.or.jp/~archive/pdf/bul/Vol.47_07_453.pdf
- http://www.orsj.or.jp/~archive/pdf/bul/Vol.47_08_523.pdf

</body>
</day>
<day date="2008-09-03" title="">
<body>
*1220399705*[連絡的]gccと関連コマンド

gccオプション

- -v 詳細表示
- -E プリプロセス（標準出力）
- -S コンパイルのみ .s
- -c コンパイル＆アセンブル .o

単独で呼べるコマンド

- cpp プリプロセッサ
- as アセンブラ
- ld ローダー
- cc1 コンパイラ本体（libexecの下のどっか、直接は呼ばないな）

*1220400077*[形式言語理論][その他代数]まったくダメだった もう疲労困憊

うーん、なんやかんや、やっていたけど、どうも失敗、&lt;b&gt;徒労&lt;/b&gt;だったようだ。あー、疲れた。むなしい。

形式言語理論における列言語をフーリエ変換できないかと思ってやっていた。非可換モノイドMから出発して、A⊆MをM上のブール値関数（特性関数）だと思う。M上のブール値指標を使って関数としてのAを展開できないか？ と考えた。

x:M→&lt;b&gt;B&lt;/b&gt;で、x(ab) = x(a)∨x(b), x(e) = ⊥（eは単位、⊥はfalse）というものを指標とすると、指標は素イデアルに似た部分集合（xによるTの逆象）に対応する。指標の空間＝素イデアルの空間＝スペクトルだと思って、M上のブール値関数をスペクトル上に移す。

f^(X) = [F∩X = φ] と定義する。Fはfに対する集合。[…]は命題の真偽値。これはなにやらフーリエ変換に似てるんだけど、残念ながら素イデアル＝極大イデアルが1個しかない(!)ので、スペクトルの空間が自明になってしまい、&lt;em&gt;なんの意味もなかった。&lt;/em&gt;

Pow(M)を畳み込み積で、二元体上の非可換環だと思って、その素イデアルを使うという方法が残っているが、どうかな？ なんかもう気力が湧かない。疲れた、ほんとウンザリ。

*1220400617*[用語法][論理]証明論の用語

- deductive/deduction system
- sequent 
- Gentzen system
- logical rules, structural rules
- one-sided sequent 
- Exchange, Weakening(Thinning) Contraction
- left rule, right rule
- introduction rule, elimination rule
- sequentのantecedent 前例、先例、先立つ事情、既述の事項、前項
- sequentのsuccedent 続いて起こる（こと）
- deduction rule
- premize, conclusion （deduction ruleのとき）
- n-premize deduction rule (s1, ..., sn |- s)

竹内さんは、

- term, formula （原語のまま使用）
- 式（sequent）
- 式の左辺(antecedent)、右辺(succedent)
- 推論図 (deduction rule)
- 上式 (premizes)、下式 (conclusion)
- 三段論法＝cut
- provable
- 始式（proof treeのleaf）


</body>
</day>
<day date="2008-09-04" title="">
<body>
*1220486629*[用語法][メモ]変形版 エディントンのイプシロン

本来のエディントンのイプシロンは、添字が3つ付いたε&lt;sub&gt;ijk&lt;/sub&gt;だ。

- http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%87%E3%82%A3%E3%83%B3%E3%83%88%E3%83%B3%E3%81%AE%E3%82%A4%E3%83%97%E3%82%B7%E3%83%AD%E3%83%B3

添字の範囲を1,2,3として、ε&lt;sub&gt;ij&lt;/sub&gt; := ε&lt;sub&gt;ij3&lt;/sub&gt;のように最後の添字を固定すると添字が２つのεができる。直接の定義は：

- ε&lt;sub&gt;ij&lt;/sub&gt; = 1 if i &amp;lt; j
- ε&lt;sub&gt;ij&lt;/sub&gt; = -1 if i &gt; j
- ε&lt;sub&gt;ij&lt;/sub&gt; = 0 if i = j

一般的なエディントン・イプシロンを定義するなら、{1, 2, ..., n}から選んだ順列にある転倒数（追い越しの数）の偶奇を考えて、偶なら1、奇なら-1、重複があれば（転倒数に無関係に）0という成分表示だろう。

http://www12.plala.or.jp/ksp/lib/Levi-Civita.pdf に面白いことが書いてある。

*1220487808*[説明][お絵描き]お絵描きテンソル計算の導入部分

お絵描きテンソル計算の説明を考えている。最初に、紐だけの状況を考える。これは圏論的には恒等で、クロネッカーデルタで成分表示される。その後に、箱がある状況を考える。箱は行列や（狭義の古典的）テンソルで表示される。最初のクロネッカーデルタの場合も、箱の内部が単なる紐であったと解釈される。

また、単なる紐だけの自明な箱に付けられた名辞がδであり、δ&lt;sub&gt;i&lt;/sub&gt;&lt;sup&gt;j&lt;/sup&gt;はその成分表示という解釈も可能だ。クロネッカーデルタに関する公式を出す前に、δが単位テンソルであること（圏論的には恒等と、転置＝双対への同型）を図式上で説明するのがいいと思う。圏論的には結合の単位律の説明になる。

*1220487809*[説明][用語法]単位、余単位、ベント、コベント

「単位／余単位」は圏論的には定着しているが、テンソル計算の文脈ではフィットしない。「カップ／キャップ」も使われているが、すぐに「どっちがどっちか」わからなくなる。「ベル状態／ベル余状態」では特定分野に片寄りすぎ。

ステファネスクの用語、「ベント／コベント」はどうだろう。テンソルの縮約はコベントで定義できる。コベントが縮約だとすると、ベントは水増し、拡散（thinning）ともいえる。フロベニウス構造のレベルで見ると、ベクトルを対角行列にする対角化（diagonal）と、スカラーをベクトルとみなすベクトル化から、拡散が定義できる。これは定数から定数関数、関数から乗法作用素という格上げと同じ。

*1220505360*[圏一般論][トレース／コンパクト閉圏][課題]双対と随伴

ストリート（Ross Street）が、双対（a duality）の記法として、A -| B を採用している（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080829/1219981730&quot;&gt;「ストリートの用語法と記法」参照&lt;/a&gt;）。この記法が具合がいいのは、関手の随伴と同じだからだ。

対象の双対ペアと関手の随伴ペアが並行的に扱える。モノイド圏を、対象が1個しかない2-圏だと思うと、対象の双対ペアは1セルのペアとなり、関手の随伴ペアと同じように扱える。つまり、双対も随伴も、ある2-圏の1セルのあいだの関係とみると同じ枠組みで議論できる。

左双対／右双対と左随伴／右随伴も並行的な定義となる。F -| G のとき、随伴の単位 η:I→F;G は、A -| B の単位 η:I→A×B と同じになる。特に、圏Cの自己関手の圏End(C)を非可換なモノイド圏と考えると、このモノイド圏における双対と自己関手の随伴はまったく同じ定義になる。双対が定義する自明なモノイドとコモノイドがEnd(C)の場合はモナドとコモナドになる。

End(C)において、フロベニウスモノイド（フロベニウス代数）とは何か、双モノイドとは何か？ などは面白いかもしれない（つまんないかもしれない^^;）。

*1220507615*[メモ]伝統的テンソル計算を理解するヒント スキャン画像

&lt;b&gt;[追記 date=&quot;2008-10-18&quot;]&lt;/b&gt;:=は、左を右で定義する、ということ。イコールの上に黒丸や三角が乗っているのは、正確にはイコールじゃないけど、記号の濫用や規約に基づきイコールで書きますよ、ってな気分だと思う（実は書いたときの気分を忘れているが）。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;hr&gt;

&lt;img src=&quot;http://www.chimaira.org/img2/tensor-calc-1.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/tensor-calc-2.gif&quot; &gt;

&lt;hr&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/tensor-calc-3.gif&quot; &gt;
&lt;hr&gt;

</body>
</day>
<day date="2008-09-05" title="">
<body>
*1220589435*[連絡的]ヘッダファイルの内容（概要）

http://www.st.rim.or.jp/~phinloda/cqa/cqa13.html より：

&lt;pre&gt;

&amp;lt;errno.h&gt;（エラー）
  EDOM
  ERANGE
  errno

&amp;lt;stddef.h&gt;（共通の定義）
  NULL
  offsetof(型,メンバ指示子)
  ptrdiff_t
  size_t
  wchar_t

&amp;lt;assert.h&gt;（診断機能）
  NDEBUG
  void assert(int expression);

&amp;lt;ctype.h&gt;（文字操作）
  int isalnum(int c);
  int isalpha(int c);
  int iscntrl(int c);
  int isdigit(int c);
  int isgraph(int c);
  int islower(int c);
  int isprint(int c);
  int ispunct(int c);
  int isspace(int c);
  int isupper(int c);
  int isxdigit(int c);
  int tolower(int c);
  int toupper(int c);

&amp;lt;locale.h&gt;（文化圏固有操作）
  LC_ALL
  LC_COLLATE
  LC_CTYPE
  LC_MONETARY
  LC_NUMERIC
  LC_TIME
  NULL
  struct lconv
  char *setlocale(int category, cons char *locale);
  struct lconv *localeconv(void);

&amp;lt;math.h&gt;（数学）
  HUGE_VAL
  double acos(double x);
  double asin(double x);
  double atan(double x);
  double atan2(double y, double x);
  double cos(double x);
  double sin(double x);
  double tan(double x);
  double cosh(double x);
  double sinh(double x);
  double tanh(double x);
  double exp(double x);
  double frexp(double value, int *exp);
  double ldexp(double x, int exp);
  double log(double x);
  double log10(double x);
  double modf(double value, double *iptr);
  double pow(double x, double y);
  double sqrt(double x);
  double ceil(double x);
  double fabs(double x);
  double floor(double x);
  double fmod(double x);

&amp;lt;setjmp.h&gt;（非局所分岐）
  jump_buf
  int setjmp(jmp_buf env);
  void longjmp(jmp_buf env, in val);

&amp;lt;signal.h&gt;（シグナル操作）
  sig_atomic_t
  SIG_DFL
  SIG_ERR
  SIG_IGN
  SIGABRT
  SIGFPE
  SIGILL
  SIGINT
  SIGSEGV
  SIGTERM
  void (*signal(int sig, void (*func)(int))) (int);
  int raise(int sig);

&amp;lt;stdarg.h&gt;（可変個数実引数）
  va_list
  void va_start(va_list ap,最終引数 );
  va_arg(va_list ap, 型);
  void va_end(va_list ap);

&amp;lt;stdio.h&gt;（入出力）
  _IOFBF
  _IOLBF
  _IONBF
  BUFSIZ
  EOF
  FILE
  FILENAME_MAX
  FOPEN_MAX
  fpos_t
  L_tmpnam
  NULL
  SEEK_CUR
  SEEK_END
  SEEK_SET
  size_t
  stderr
  stdin
  stdout
  TMP_MAX
  int remove(const char *filename);
  int rename(const char *old, const char *new);
  FILE *tmpfile(void)
  char *tmpnam(char *s);
  int fclose(FILE *stream);
  int fflush(FILE *stream);
  FILE *fopen(const char *filename, const char *mode);
  FILE *freopen(const char *filename, const char *mode, FILE *stream);
  void setbuf(FILE *stream, char *buf);
  int setvbuf(FILE *stream, char *buf, int mode, size_t size);
  int fprintf(FILE *stream, const char *format, ...);
  int fscanf(FILE *stream, const char *format, ...);
  int printf(const char *format, ...);
  int scanf(const char *format, ...);
  int sprintf(char *s, const char *format, ...);
  int sscanf(char *s, const char *format, ...);
  int vfprintf(FILE *stream, const char *format, va_list arg);
  int vprintf(const char *format, va_lis arg);
  int vsprintf(char *s, const char *format, va_list arg);
  int fgetc(FILE *stream);
  char *fgets(char *s, int n, FILE *stream);
  int fputc(int c, FILE *stream);
  int fputs(const char *s, FILE *stream);
  int getc(FILE *stream);
  int getchar(void);
  char *gets(char *s);
  int putc(int c, FILE *stream);
  int putchar(int c);
  int puts(const char *s);
  int ungetc(int c, FILE *stream);
  size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
  size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
  int fgetpos(FILE *stream, fpos_t *pos);
  int fseek(FILE *stream, long int offfset, int whence);
  int fsetpos(FILE *stream, const fpos_t *pos);
  long int ftell(FILE *stream);
  void rewind(FILE *stream);
  void clearerr(FILE *stream);
  int feof(FILE *stream);
  int ferror(FILE *stream);
  void perror(const char *s);

&amp;lt;stdlib.h&gt;（一般ユーティリティ）
  EXIT_FAILURE
  EXIT_SUCCESS
  MB_CUR_MAX
  NULL
  RAND_MAX
  div_t
  ldiv_t
  size_t
  wchar_t
  double atof(const char *nptr);
  int atoi(const char *nptr);
  long int atol(const char *nptr);
  double strtod(const char *nptr, char **endptr);
  long int  strtol(const char *nptr, char **endptr, int base);
  unsigned long int  strtoul(const char *nptr, char **endptr, int base);
  int rand(void);
  void srand(unsigned int seed);
  void *calloc(size_t nmemb, size_t size);
  void free(void *ptr);
  void *malloc(size_t size);
  void *realloc(void *ptr, size_t size);
  void abort(void);
  void atexit(void (*func)(void));
  void exit(int status);
  char *getenv(const char *name);
  int system(const char *string);
  void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
  void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
  int abs(int j);
  div_t div(int numer, int denom);
  long int labs(long int j);
  ldiv_t ldiv(long int numer, long int denom);
  int mblen(const char *s, size_t n);
  int mbtowc(wchar_t *pwc, const char *s, size_t n);
  int wctomb(char *s, wchar_t wchar);
  size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
  size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);

&amp;lt;string.h&gt;（文字列操作）
  NULL
  size_t
  void *memcpy(void *s1, const void *s2, size_t n);
  void *memmove(void *s1, const void *s2, size_t n);
  char *strcpy(char *s1, const char *s2);
  char *strncpy(char *s1, const char *s2, size_t n);
  char *strcat(char *s1, const char *s2);
  char *strncat(char *s1, const char *s2, size_t n);
  int memcmp(const void *s1, const void *s2, size_t n);
  int strcmp(const char *s1, const char *s2);
  int strcoll(const char *s1, const char *s2);
  int strncmp(const char *s1, const char *s2, size_t n);
  size_t strxfrm(char *s1, const char *s2, size_t n);
  void *memchr(const void *s, int c, size_t n);
  char *strchr(const char *s, int c);
  size_t strcspn(const char *s1, const char *s2);
  char *strpbrk(const char *s1, const char *s2);
  char *strrchr(const char *s, int c);
  size_t strspn(const char *s1, const char *s2);
  char *strstr(const char *s1, const char *s2);
  char *strtok(const char *s1, const char *s2);
  void *memset(void *s, int c, size_t n);
  char *strerror(int errnum);
  size_t strlen(const char *s);

&amp;lt;time.h&gt;（日付及び時間）
  CLOCKS_PER_SEC
  NULL
  clock_t
  time_t
  size_t
  struct tm
  clock_t clock(void);
  double difftime(time_t time1, time_t time0);
  time_t mktime(struct tm *timeptr);
  time_t time(time_t timer);
  char *asctime(const struct tm *timeptr);
  char *ctime(const time_t timer);
  struct tm *gmtime(const time_t *timer);
  struct tm *localtime(const time_t *timer);
  size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timepttr);

&lt;/pre&gt;

http://www1.cts.ne.jp/~clab/hsample/Bug/Bug1.html より：

定数名にのみ注目、定数自体はアテにならない！
&lt;pre&gt;
limits.h の中の記号定数

    CHAR_BIT    8    // char 型は８ビット

    CHAR_MAX    UCHAR_MAX    // char 型とunsigned char 型の最大値は同じ
    CHAR_MIN    0    // char 型の最小値

    INT_MAX    +32767    // int 型の最大値
    INT_MIN    -32768    // int 型の最小値

    LONG_MAX    +2147483647L    // long 型の最大値
    LONG_MIN    -2147483648L    // long 型の最小値

    SCHAR_MAX    +127    // signed char 型の最大値
    SCHAR_MIN    -128    // signed char 型の最小値

    SHRT_MAX    +32767    // short 型の最大値
    SHRT_MIN    -32768    // short 型の最小値

    UCHAR_MAX    255U    // unsigned char 型の最大値
    UINT_MAX    65535U    // unsigned int 型の最大値
    ULONG_MAX    4294967295UL    // unsigned long 型の最大値
    USHRT_MAX    65535U    // unsigned short 型の最大値

    // unsigned : 符号なし    // signed : 符号あり
&lt;/pre&gt;

*1220594198*[その他代数][トレース／コンパクト閉圏][課題]テンソル代数

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080904/1220488123&quot;&gt;本編の「伝統的テンソル計算を理解するヒント」&lt;/a&gt;において、内積空間Uをひとつ固定して、内積空間と（任意の）線形写像の圏の充満部分圏Tens[U]を考える、という話をした。

実はUが内積空間（ユークリッド空間、ヒルベルト空間など）である必要はなくて、Uとその双対U&lt;sup&gt;*&lt;/sup&gt;があればよい。U&lt;sup&gt;*&lt;/sup&gt;も標準的な双対である必要はなくて、UとWが a dual の関係にあればよい。すると、UとWと非退化双線形形式φをもとに、最小のコンパクト閉圏が作れる。そこでの計算がテンソル計算になる。

ところで、ベクトル空間Uに対して、外積代数（交代代数）A(U)とか対称代数S(U)が作れる。Tens[u]に対応する代数（多元環）はなんだろう。Uを文字'+'、U&lt;sup&gt;*&lt;/sup&gt;を文字'-'で代表するとしよう。この文字は別になんでもいいのだが、ともかく2文字。アルファベット{+, -}から作られる文字列、たとえば&quot;+--+&quot;がテンソル積 U(×)U&lt;sup&gt;*&lt;/sup&gt;(×)U&lt;sup&gt;*&lt;/sup&gt;(×)U を表す。U(×)U&lt;sup&gt;*&lt;/sup&gt;(×)U&lt;sup&gt;*&lt;/sup&gt;(×)U = U&lt;sup&gt;+--+&lt;/sup&gt; のような指数表示をする。

任意の文字列α∈{+, -}&lt;sup&gt;*&lt;/sup&gt;（ここのスターはクリーネスター）に対する U&lt;sup&gt;α&lt;/sup&gt; を全部直和で組むと代数ができる。T(U) = Σ(α∈{+, -}&lt;sup&gt;*&lt;/sup&gt; : U&lt;sup&gt;α&lt;/sup&gt;) とすると、これは階付き代数（graded algebra）になる。階のモノイド（grade monoid）が非可換な{+, -}&lt;sup&gt;*&lt;/sup&gt;となる。しかし、αβ |→ βα という対称（symmetry）があるから、非可換だが割と扱いやすい。

圏Tens[U]と代数T(U)の関係って、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080808/1218164637&quot;&gt;圏-R代数とR化圏&lt;/a&gt;になってんじゃないのかな？ &lt;b&gt;[追記]&lt;/b&gt;←全然違う。間違い。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2008-09-08" title="">
<body>
*1220831395*[連絡的]今のPCの処理能力って？

横方向は空間方向、縦方向は時間方向として、ビットを1cm×1cmのマスで描くと、1秒間の処理はどのくらいのサイズの絵になるか？

- http://d.hatena.ne.jp/m-hiyama/searchdiary?word=16%bf%ca%a4%f2
</body>
</day>
<day date="2008-09-09" title="">
<body>
*1220920075*[連絡的]サンプル

&lt;pre class=&quot;code&quot;&gt;
/* rec.c */

foo(int count)
{
  printf(&quot;%4d: %p\n&quot;, count, &amp;count);
  if (count &lt;= 0) {
    return;
  }
  foo(count - 1);
}

bar(int count)
{
  if (count &gt; 0) {
    bar(count - 1);
  }
  printf(&quot;%4d: %p\n&quot;, count, &amp;count);
}

main()
{
  foo(10);
  printf(&quot;\n\n&quot;);
  bar(10);
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
/* unsig.c */
#include &lt;limits.h&gt;

main()
{
  int i = -1;
  unsigned int u = (unsigned int)i;

  printf(&quot;%d, %u\n&quot;, i, u);
  printf(&quot;%u, %d\n&quot;, i, u);
  printf(&quot;UINT_MAX=%u\n&quot;, UINT_MAX);
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
/* size.c */

main()
{
  short s =0;
  int i = 0;
  long long x = 0;

  printf(&quot;sizeof 0 = %d\n&quot;, sizeof(0));
  printf(&quot;sizeof s = %d\n&quot;, sizeof(s));
  printf(&quot;sizeof i = %d\n&quot;, sizeof(i));
  printf(&quot;sizeof x = %d\n&quot;, sizeof(x));
}
&lt;/pre&gt;

*1220921637*[連絡的]データをビット／バイトのレベルで観察する

&lt;h5&gt;文字列と整数の相互変換&lt;/h5&gt;

+ 実用上は、適切なライブラリ関数を探す。
+ 練習としては、自前で作る。

文字列→整数 は、自前で作っても割と簡単。
整数→文字列 は、戻り値をどうするかで悩むかもしれない。

&lt;h5&gt;変換ではなくて直接出力なら割と簡単&lt;/h5&gt;

putcharだけを使って（他のライブラリ関数は一切使わない）、整数を標準出力に書き出す関数を作れ。最後に改行は付けなくていい。

+ print_int_d(int x) -- 通常の十進で。
+ print_int_x(int x) -- 16進で。
+ print_int_b(int x) -- 2進で。

&lt;h5&gt;文字列を文字番号で出力&lt;/h5&gt;

- print_str_as_numbers(char *s) -- 各文字を十進番号で、文字と文字の区切りにカンマを挿入

&lt;h5&gt;scanfは推奨しない&lt;/h5&gt;

理由はそのうち。

&lt;h5&gt;再帰&lt;/h5&gt;

メカニズムを理解して使う。

&lt;h5&gt;データのバイトサイズ&lt;/h5&gt;

sizeof, limits.h

&lt;h5&gt;ビット演算&lt;/h5&gt;

ビットレベルの操作なら、割り算や余りより、ビットシフトやビットマスク（アンド演算）のほうがむしろ分かりやすい。

&lt;h5&gt;結局&lt;/h5&gt;

コマンドライン引数から入力を受け取り、ビット演算を使って操作してみる。

</body>
</day>
<day date="2008-09-10" title="">
<body>
*1221005020*[連絡的]数とビット模様

- 人間は、数（number）とその計算に慣れている。
- 機械は、ビット模様（の物理的実現）を記憶、転送、操作するだけ。

数の世界とビット模様の世界にはギャップがある。二進数が2つの世界を翻訳するときの架け橋となる。

- 二進数は数（number）としての意味を持つ。
- 二進数の姿形はビットコンビネーションに過ぎない。

数の計算は機械にとっては困難。機械のリアリティはビット模様、&lt;em&gt;数は幻影&lt;/em&gt;。

- 論理（AND, OR, NOT）ゲート、シフト、回転
- 1桁の足し算
- 繰り上がり付き1桁の足し算
- 時計の算数

&lt;pre class=&quot;code&quot;&gt;
#include &lt;limits.h&gt;

main()
{
  int i = INT_MAX;
  int j = i + 1;

  printf(&quot;i = %d, j = %d\n&quot;, i, j);
}
&lt;/pre&gt;

AND, OR, NOTのゲート（回路）からXORの回路をどう作る？ &lt;del datetime=&quot;2008-09-10T17:55:15+09:00&quot;&gt;経済性も考えるとどうなる？&lt;/del&gt;←あんまり経済的にできないな。


</body>
</day>
<day date="2008-09-11" title="">
<body>
*1221090618*[連絡的]データ転送の原形

+ 即値
+ レジスタ内容 -- 単にレジスタ
+ レジスタ内容をアドレスとみなしてのメモリブロック -- [レジスタ]

組み合わせを考えると：

+ 即値 → レジスタ
+ 即値 → [レジスタ]
+ レジスタ → レジスタ
+ レジスタ → [レジスタ]
+ [レジスタ] → レジスタ
+ [レジスタ] → [レジスタ]

即値を「即値またはレジスタ」、レジスタを「メモリブロック」に置き換えるとより一般的な状況になる。

*1221113677*[課題][圏一般論][モノイド圏]プロ関手の圏＝一般化関係圏

以下、ストリートが書いていたこと：

まずモノイド圏Mを1つ固定する。M-豊饒化された圏を単にM-圏と呼ぶ。M-圏の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080228/1204158123&quot;&gt;レルム&lt;/a&gt;をM-Catとする。A, B∈|M-Cat| に対して、そのテンソル積が定義できる。

- 対象： |A×B| = |A|×|B| ここで×は直積
- ホムセット： (A×B)(&amp;lt;a, b&gt;, &amp;lt;a', b'&gt;) = A(a, b)×B(a', b') ここで×はMのモノイド積
- その他： まー、適当に。

M-&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080502/1209700356&quot;&gt;プロ関手（profunctor, distributor）&lt;/a&gt;の圏を作る。AからBへのM-プロ関手P:A/→B とは（/→は一種の矢印記号のつもり）、B&lt;sup&gt;op&lt;/sup&gt;×A→M という関手、×は先ほど導入したテンソル積。
&lt;hr&gt;

この話、僕には難しい。よく理解できないから、もう少し調べてから書くかもしれないが、いったん中断。

*1221124420*[課題][圏一般論]圏Catがデカルト閉であることとか

圏Catに普通のデカルト積を入れる。指数を関手圏とすると、デカルト閉であることをちゃんと示せ。

同じ事をモノイド閉圏Mで豊饒化した状況で成立するか。M-Catが、なんらかの適切な定義のもとでモノイド閉か？

</body>
</day>
<day date="2008-09-12" title="">
<body>
*1221184588*[連絡的][リンク]C99の解説、落とし穴

- http://seclan.dll.jp/c99d/c99d00.htm
- http://www.aerith.net/cpp/typical_bug-j.html  と、ここからリンクされたページ。

*1221186103*[連絡的]How much? か How many? か（英語が）わからん

「左にシフトすると2倍」は違う。シフトはシフトと思えばそれでいい。いちいち翻訳しない。

&lt;pre class=&quot;code&quot;&gt;
/* haw much? */
#include &lt;limits.h&gt;

int main()
{
  unsigned char c = UCHAR_MAX;
  unsigned char d = c + 2;
  unsigned char e = c;
  unsigned char f = d;

  printf(&quot;c = %d, d = %d\n&quot;, c, d);
  e &lt;&lt;= 1;
  f &lt;&lt;= 1;
  f &lt;&lt;= 1;
  printf(&quot;e = %d, f = %d\n&quot;, e, f);
}
&lt;/pre&gt;

</body>
</day>
<day date="2008-09-13" title="">
<body>
*1221272650*[圏一般論][プログラム意味論]圏の圏が閉圏であるならラムダ計算ができる

n個の型パラメータを持つ総称型は、C&lt;sub&gt;1&lt;/sub&gt;×...×C&lt;sub&gt;n&lt;/sub&gt;→D という関手だと思ってよいだろう。総称関数は自然変換、あるいは自然変換を少し拡張した概念で定式化できるだろう。

世間で総称型／総称関数といっているものがすべてこのようにみなせるわけではないが、タチのいいものに限れば、関手と自然変換だと思ってもよい。

圏の圏Catはデカルト閉だから、そこで普通のラムダ計算ができる。このラムダ計算はタチの良い総称計算だと思っていい。別にCatに限る必要もなく、デカルト性が必要なわけでもない。モノイド閉圏になるような&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080228/1204158123&quot;&gt;レルム&lt;/a&gt;上では総称ラムダ計算ができるはずだ。

*1221272809*[圏一般論][雑感]M-豊饒圏上のM-プロ関手圏

M-豊饒圏のレルムM-Catをベースに、単なる関手ではなくてM-プロ関手による圏M-ProCatを考えること、M-CatをM-ProCatに埋め込んで考えることは&lt;em&gt;ものすごく重要&lt;/em&gt;な気がする。

とりあえず、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080911/1221113677&quot;&gt;ストリートが言っている&lt;/a&gt;線形テンソル圏Vect&lt;sub&gt;k&lt;/sub&gt;を使った豊饒化とプロ関手（ストリートの用語だとモジュール）を理解したいのだが、、、、

*1221273504*[メモ]ネタ、ネタ、ネタ

[http://d.hatena.ne.jp/m-hiyama-memo/20080806/1217985641:title]と重複するが、まだ記述してないこと。

- JsDoc Toolkit 2.*
- ErlangのMakefile
- Erlnagのアプリケーション概念
- Erlnagのerlからの関数／式の実行
- 関手圏 [C, D], Func(C, D), Nat(F, G)
- 量子計算の状態概念
- クック／パヴロヴィック流の測定
- スペクトル（概念）のスペクトル（視点、視野）
- ErlangでJSON
- EDocの使い方
- 反射的な位相ベクトル空間とコンパクト圏
- Obj(-)関手と完全有向グラフK(-)の随伴性
- 行列の積が群上の畳み込み積の一般化とみなせること
- 量子状態の表現の色々と相互関係
- コマンドラインから使うerl 続編 init flagsとかtipsとか
- Erlangのアプリケーション仕様データの説明
- 論理のコンパクト性定理
- http://d.hatena.ne.jp/m-hiyama-memo/20080904/1220507615 の解説・続き

</body>
</day>
<day date="2008-09-17" title="">
<body>
*1221607624*[連絡的]英語がわからんが How much? その2

クイズ： 実行前にいくつになるか予想せよ。
&lt;pre class=&quot;code&quot;&gt;
/* and haw much? */
#include &lt;limits.h&gt;

int main()
{
  unsigned char u = UCHAR_MAX;
  signed char c = CHAR_MAX;
  unsigned char u2 = c;
  signed char c2 = u;
  u += 2;
  c += 2;
  u2 += 2;
  c2 += 2;

  printf(&quot;u = %d, c = %d\n&quot;, u, c);
  printf(&quot;u2 = %d, c2 = %d\n&quot;, u2, c2);
}
&lt;/pre&gt;


これも、実行前に表示（出力）を予想せよ。

&lt;pre class=&quot;code&quot;&gt;
#include &lt;limits.h&gt;

/* 警告（Warning）が出るが、エラーではないのでコンパイルはできる。*/

int main()
{
  char c = CHAR_MAX;
  unsigned char uc = UCHAR_MAX;
  int i = INT_MAX;
  unsigned int ui = UINT_MAX;

  c += 2;
  uc += 2;
  i += 2;
  ui += 2;

  printf(&quot;(1 :c -  d) %d\n&quot;,  c);
  printf(&quot;(2 :c -  u) %u\n&quot;,  c);

  printf(&quot;(3 :uc - d) %d\n&quot;,  uc);
  printf(&quot;(4 :uc - u) %u\n&quot;,  uc);

  printf(&quot;(5 :C -  d) %d\n&quot;,  CHAR_MAX + 2);
  printf(&quot;(6 :C -  u) %u\n&quot;,  CHAR_MAX + 2);

  printf(&quot;(7 :UC - d) %d\n&quot;,  UCHAR_MAX + 2);
  printf(&quot;(8 :UC - u) %u\n&quot;,  UCHAR_MAX + 2);

  printf(&quot;(9 :i  - d) %d\n&quot;,  i);
  printf(&quot;(10:i  - u) %u\n&quot;,  i);

  printf(&quot;(11:ui - d) %d\n&quot;,  ui);
  printf(&quot;(12:ui - u) %u\n&quot;,  ui);

  printf(&quot;(13:I  - d) %d\n&quot;,  INT_MAX + 2);
  printf(&quot;(14:I  - u) %u\n&quot;,  INT_MAX + 2);

  printf(&quot;(15:UI - d) %d\n&quot;,  UINT_MAX + 2);
  printf(&quot;(16:UI - u) %u\n&quot;,  UINT_MAX + 2);
}
&lt;/pre&gt;

*1221612581*[記録]EMOBILEカード、ゼロインストールのインストール・エラー

インストールの最後で、Windowsのエラーダイアログボックス。メッセージは：
&lt;pre&gt;
ディスクがありません.

Exception Processing Message c0000013
Parameters 764cbf9c 4 764cbf9c 764cbf9c
&lt;/pre&gt;

*1221615145*[メモ法][Erlang]すぐに、断片でも、メモせよ

アームストロングのErlang本に、アプリケーションコントローラーとアプリケーションスターターが混同してあるところがあって、僕は「コントローラーとスターターは違うんだぜ」と思った。それは憶えている。

が、アプリケーションスターターが何であるかを今は憶えてない！ ガーン！！

こういう（アームストロングでさえ勘違いする）概念は即座にメモしないと忘れる、わからなくなる。

*1221615991*[メモ][連絡的]意味、（低水準な）内容、場所

データに関しては、その意味（例：算術値）、内容（ビットコンビネーション、バイト列）、場所（アドレス、スタック、ヒープなどの領域の区分）を組にして考えるとよい。意味だけを考えてはうまくいかないし、不自然なことも多い。

*1221641262*[リンク][物理っぽい]力学か？

ウーーンン？ チンプンカンプンだが、これって力学？

- Title: Noncommutative Geometry and Quiver algebras
- Authors: William Crawley-Boevey, Pavel Etingof, Victor Ginzburg
- URL: http://arXiv.org/abs/math.AG/0502301


</body>
<comments>
<comment>
<username>暇人</username>
<body>解析力学を起源に持つシンプレクティック幾何学という分野の論文と思われます。上記の論文は非可換版ですが、可換（普通のシンプレクティック多様体）の場合については&lt;br&gt;http://en.wikipedia.org/wiki/Moment_map&lt;br&gt;が参考になると思います。&lt;br&gt;論文の abstract にある Hamiltonian reduction とは上記  wiwipedia 内の symplectic quotient の事だと思います。</body>
<timestamp>1221704223</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>暇人さん、ありがとうございます。&lt;br&gt;可換なケースが古典解析力学とすると、非可換なこれは量子版ですか。スタイルは代数幾何みたいだし。ハッ、歯が立たない、、、</body>
<timestamp>1221714588</timestamp>
</comment>
</comments>
</day>
<day date="2008-09-18" title="">
<body>
*1221714709*[メモ][連絡的]unsignedが素敵な理由

代入やキャストやビット演算に際して、とても素直な振る舞いをする。

符号付き、あるいは符号付き／符号なしが混じるとなんだか複雑になる。いちおうコンパイラは値（ビットパターンではない）を守ろうとがんばってくれるが、がんばりきれないときの挙動がよくわからん。

*1221717764*[連絡的]レジスタ

レジスタはあんまり意識しなくていい。そもそも、レジスタが面倒だから高級言語があるわけだから。

だが、次は知っていると納得する（知らないと困惑する）場面も多い。

- 演算はレジスタに入れてから行う。結果もレジスタに入る。
- 関数の戻り値は多くの場合レジスタに入れる。

変数名x, pが適当なメモリブロックを指しているとして、x = *(p + 4); をものすごく簡単な仮想（フィクション、オモチャ）機械で実行するといいかもしれない。

</body>
</day>
<day date="2008-09-19" title="">
<body>
*1221779998*[メモ][JavaScript]8進数の扱いがチグハグ

リテラル 012 と Number(&quot;012&quot;)が違うのでビックリ。

</body>
</day>
<day date="2008-09-22" title="">
<body>
*1222041198*[リンク][その他プログラミング]BCPL

マーチン・リチャーズ(Martin Richards)本人が今でもメンテナンスしている。

- http://www.cl.cam.ac.uk/~mr10/BCPL.html

*1222041327*[連絡的][用語法]2の補数、1の補数

「2の補数」、「1の補数」 -- もう最悪の用語法だな。

- 2の補数： 2&lt;sup&gt;n + 1&lt;/sup&gt; の補数の最上位ビット切り落とし
- 1の補数：(2&lt;sup&gt;n + 1&lt;/sup&gt; - 1) の補数 ＝ ビットごとのNOT

なんでこんな用語が生き残っているのだろう？ 歴史的な遺物。代替表現がないのでそのままなのだろうが、ひどすぎる。無視すべきだろう。

*1222043055*[メモ][ToySys]バイナリモドキ

テキストエディタで書けるバイナリ

+ 空白類(間隔、タブ、改行、復帰）、カンマは無視される。
+ #から次の改行まではコメント、無視される。

データ表現

+ 16進ニブル : [0-9a-fA-F]
+ アスキー文字 : 'に続けて文字
+ エスケープ表現 : \[\stnr'] sは間隔文字
+ 2進ニブル : $に続けて4桁の0,1 左が上位
+ 2進バイト : $に続けて8桁の0,1 左が上位

ニブルは連続する2つを上位、下位にしてバイトを作る。半端なニブルはエラー。

繰り返し

+ Repeat : *N バイト表現 -- Nは16進4桁、回数を表す
+ FillUntil : ?N バイト表現 -- Nは16進4桁、バイトオフセットを表す

例 

- $1010,A -- これで1バイト
- *000A 'A -- 文字Aを10回繰り返す
- ?00FF 00 -- オフセットFFまでをゼロで埋める

*1222044382*[講座][連絡的]備忘メモ

- [http://d.hatena.ne.jp/m-hiyama-memo/20080901/1220229976:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080909/1220921637:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080910/1221005020:title]

- 符号が関係するのは、符号拡張と算術シフト（MSB保存シフト）くらい。
- とにかく体で覚える！ 3ビットくらいで練習と確認。
- 一覧表を作れ。
- nmコマンド
- バイナリ表示と16進電卓


</body>
</day>
<day date="2008-09-24" title="">
<body>
*1222220306*[メモ][ToySys]バイナリモドキ修正

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080922/1222043055&quot;&gt;バイナリモドキ&lt;/a&gt;を少し修正。

+ 2進数はなくてもいいや。
+ ニブル単位ではなくて、常にバイト単位で扱う。

&lt;pre&gt;
Hex ::= [1-9A-Za-z]
S ::= LF | CR | TAB | SPACE
D ::= S | ','
Hex2 ::=  Hex Hex
Char ::= &quot;'&quot; [^\]
EscapedChar ::= &quot;'&quot; '\'' [stnr']
Byte ::= Hex2 | Char | EscapedChar
Bound ::= Hex Hex Hex Hex
Repeat ::= '*' Bound D* Byte
FillUntil ::= '?' Bound D* Byte
Comment ::= '#' Any* NewLine
Delm ::= D+ | Comment
PseudoBin ::= (Delm | Byte | Repeat | FillUntil)*
&lt;/pre&gt;

*1222222185*[連絡的]変な動作

クイズ：なんでこんな動作をするのだろう？ （これはイタズラコード； インテル32ビットCPU + gcc）

&lt;pre class=&quot;code&quot;&gt;
/* trick.c */

void bar()
{
  printf(&quot;Hi, this is bar.\n&quot;);
  printf(&quot;... byebye from bar.\n&quot;);
  exit(0);
}

unsigned _bar = (unsigned)&amp;amp;bar;

void foo(int arg) {
  unsigned *p = (unsigned *)(&amp;amp;arg - 1); // IA32 + gcc
  *p = _bar;
  printf(&quot;This is foo.\n&quot;);
}

main()
{
  printf(&quot;This is main.\n&quot;);
  foo(0);
  printf(&quot;Byebye from main.\n&quot;);
}
&lt;/pre&gt;


イタズラの悪のり：

&lt;pre class=&quot;code&quot;&gt;
/* countdown.c */

void countdown(int *);
void mark(int);

main(int argc)
{
  int c = 10;
  mark(0);
  printf(&quot; %2d\n&quot;, c);
  countdown(&amp;amp;argc);
}

unsigned _mark;

void mark(int arg)
{
  _mark = *(&amp;#40;unsigned *)(&amp;amp;arg - 1));
}  

void countdown(int *pargc)
{
  unsigned *p = (unsigned *)(&amp;amp;pargc - 1); // IA32 + gcc
  *p = _mark;

  int *pc = pargc - 3;
  if (*pc &lt;= 0) {
    printf(&quot;BANG!\n&quot;);
    exit(0);
  }
  (*pc)--;
}
&lt;/pre&gt;

*1222232784*[説明][連絡的]Helloプログラム

これだって Hello。イイカゲンにしなさい、ペシッ。

&lt;pre class=&quot;code&quot;&gt;
/* hello.c */

unsigned g[2] = {0x6c6c6548, 0x000a216f};

main()
{
  int i = 0, c;
  while (c = i++[(char *)g]) putchar(c);
}
&lt;/pre&gt;

*1222240514*[Erlang][リンク]Erlangの例外

スライド、教訓的。
- http://www.erlang.se/euc/04/carlsson_slides.pdf

もうひとつ。

- http://www.erlang.se/workshop/2004/exception.pdf


</body>
</day>
<day date="2008-09-25" title="">
<body>
*1222318802*[連絡的]またHelloプログラム

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

void print_word(unsigned w)
{
  int i, c;
  for (i = 0; i &lt; 6 &amp;amp;&amp;amp; (c = (w &amp;amp; 0x1f)) != 0x1f; i++, w &gt;&gt;= 5) {
    putchar(65 + c);
  }
}

main()
{
  print_word(0x3ee5ac87);
  putchar('\n');
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

char g[] = &quot;pmmfi&quot;;

main()
{
  char *p = g + 4;
  while (g &lt;= p) {
    (*p)--;
    write(1, p, 1);
    p--;
  }
  putchar('\n');
}
&lt;/pre&gt;

*1222320473*[形式言語理論][物理っぽい]力学系とオートマトン

s:&lt;b&gt;R&lt;/b&gt;×X→X を連続力学系 x' = s(t, x) だとする。S⊆X が横断的とは次のことだとする。

- x∈S に対して、時間を十分短い区間(-ε, +ε)に制限すると、s(0, x)以外はSに入らない。

つまり、時刻0の付近の軌道はSと1点でしか交わらない。

横断的なS上には、「部分的に定義された決定性の離散力学系」をポアンカレ写像で定義できる； x∈S に対して、s(t, x)∈Sとなる一番最初のt &gt; 0 を選んで、x' = s(t, x) とする。そのようなtがないときはx'は未定義だとして、部分写像 x|→x' が定義できる。この部分写像が部分的な遷移系を定義する。

f:S→S が部分的かもしれない（しかし決定性）遷移とする。Sの分割 S = Σ(i : S&lt;sub&gt;i&lt;/sub&gt;) があるとする。分割の添字の集合をIとして、非決定性写像 g:I→I を次のように定義する。

- あるx∈S&lt;sub&gt;i&lt;/sub&gt; に対して、f(x)∈S&lt;sub&gt;j&lt;/sub&gt; なら j∈g(i) とする。

Sの分割が、gを&lt;em&gt;決定性&lt;/em&gt;にするなら、それはマルコフ分割となる。マルコフ分割の条件は：

- iに対して適当なjがあって、すべてのるx∈S&lt;sub&gt;i&lt;/sub&gt; に対して、f(x)∈S&lt;sub&gt;j&lt;/sub&gt;。または、S&lt;sub&gt;i&lt;/sub&gt;上でfがまったく未定義。

時間の空間も連続的な運動の系から、離散的な記号が出現するのは、このようなメカニズムなのだろうか？

</body>
</day>
<day date="2008-09-26" title="">
<body>
*1222393599*[ToySys]バイナリモドキのロケーション指定

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080924/1222220306&quot;&gt;バイナリモドキ&lt;/a&gt;に、ロケーション指定を入れる。

&lt;pre&gt;
Addr ::= Hex Hex Hex Hex
Location ::= '@' Addr
PseudoBin ::= (Delm | Byte | Repeat | FillUntil | Location)*
&lt;/pre&gt;

*1222393774*[連絡的]バイトオーダーとか

ポインターとキャストが（いずれ）わかったら、出力結果（表示）を予測してみよう。

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

main() {
  unsigned char c4[4] = {0x01, 0x02, 0x03, 0x04};
  unsigned short s2[2] = {0x0001, 0x0002};
  char *str = &quot;hello&quot;;

  unsigned u1 = *(unsigned *)c4;
  unsigned u2 = *(unsigned *)s2;
  unsigned u3 = *(unsigned *)str;
  printf(&quot;u1 (from c4) = %x\n&quot;, u1);
  printf(&quot;u2 (from s2) = %x\n&quot;, u2);
  printf(&quot;u3 (from str) = %x\n&quot;, u3);
}
&lt;/pre&gt;


</body>
</day>
<day date="2008-09-27" title="">
<body>
*1222486461*[用語法][小咄]足し算／引き算について、知らなかったよ

- 被加数 + 加数 = 和
- 被減数 - 減数 = 差

- augend + addend = sum
- minuend - subtrahend = diffrerence

英語ではオシリにendが付くのね（オシリだからそりゃendだろうって？）

*1222486532*[ToySys]低水準データ型

+ numeric
+ character
+ boolean

*1222486614*[ToySys][リンク]Toyアーキテクチャのヒント

単に箇条書きで羅列。

+ 昔はスタックがない機械もあったらしい。まー、自前でも作れるが、メンドーだからスタックはあったほうがいい。
+ 明確なコール／リターン命令がない機械もある。が、メンドーだからあったほうがいい。
+ コールで、戻り番地（当該命令の次の番地）をリンクレジスタに入れる方式と、スタックに積む方式がある。呼び出しが入れ子になれば、どっちにしろスタックに積むことになる。よってスタックに積む。
+ fp（フレームポインタ）がフレーム内のどこを指すかは勝手。そもそもフレームの定義もいろいろ。
+ fpがない、使わない方式もあるらしいが、使おう。
+ 引数は「呼び側の領域か、呼ばれ側の領域か？」微妙だ。
+ fpはローカル変数が始まるところを指すのがいいと思う。最初or最後の引数のを指す方式もある。
+ sp（スタックポインタ）を大量に増減させるとき、pop/pushは不向き。
+ インテルのretはスタックトップにあるアドレスにジャンプする。
+ 関数内のプロローグコード（入り口）、エピローグコード（出口）は色々。
+ インテルCPU + Cでは、(1) 今のbp(fpと同じ）をスタックに積む（待避） (2) 今のspをbpに設定（bpが今のスタックトップを指し、スタックトップにはbp待避値） (3) ローカル領域分spを増やす（実際は引き算）。
+ 同じくエピローグコードは、(1)spをbpにセット (2)popでスタックトップをbpに入れる（古いbpを回復） (3)retでスタックトップにあるアドレスにジャンプ（戻り番地はpopされる）
+ インテルでは、エピローグ用にenter、プロローグ用にleaveがある。
+ よって、call, enter, ...., leave, ret となる。
+ レジスタの保存は規約の問題
+ MIPSだと、temporaryレジスタは呼び側の責任、その他は呼ばれたほうで待避と回復をする。
+ 汎用レジスタに関しては、どっちか一方の責任にしてもいいような気がする。
+ ジャンプの飛び先をターゲットアドレスと呼ぶことがある。
+ インテル対象のアセンブリ言語では、mov α,β は α→β の方向のコピー。cpコマンドと同じだが、代入とは逆。
+ レジスタを使うときは、左の引数から順にレジスタに割り当て、残りは右から順にスタックに積み上げるのが普通。
+ 可変引数があると、左からスタックに積むと、1番目の引数が特定できない。
+ インテルでは、bp（fp）がローカルデータのはじまりを指す。
+ 結局、引数右→引数左→戻り番地→1つ前のbp→ローカルデータ
+ 引数を積むのは呼び側、戻り番地はcall命令、以前のbpはプロローグ（enter）が積む。新しいbpのセットもプロローグコード。
+ 最初の（最後に積んだ）引数とローカルデータの間に戻り番地と旧bpで8バイト分使う。

それと、参考になりそうなスライド：

- http://tmubdell.phys.metro-u.ac.jp/makoto/presentation/tyu-kan_ppt.ppt

*1222486679*[ToySys]トレードオフ

現状では：

+ IP（命令ポインタ）、SP（スタックポインタ）、FP（フレームポインタ）、F（フラグ）を直接見ることもさわることはできない。
+ 関数のプロローグコード、エピローグコードはほとんど不要。FPの保存、スタックのアンワインド（後かたづけ、たたむこと）も機械がやる。
+ アドレス方式は、即値、メモリ直接（オペランドが絶対アドレス値）、レジスタ直接（オペランドがレジスタ番号）、レジスタ間接（指定されたレジスタ内容が絶対アドレス値）。
+ 定数ディスプレースメントを使ったアドレッシングはない。
+ 第二オペランドがレジスタ指定のとき、16ビット中12ビットは余っている。定数ディスプレースメントを入れられる。

変更のpros and cons

+ SP, FPを露出させると、ローカル変数操作命令は不要。
+ SP, FPを使ったローカル変数操作では、ディスプレースメントが欲しい。
+ ディスプレースメントを導入するペナルティは特にない。
+ push, popもなくていい。
+ IPが見えているなら、call/retもjmpも要らない。
+ 見えない／触れないレジスタがあると、setjmp/longjmpが実装できない。

+ ローカル変数、手続きのような概念はあえて還元しないで保ったほうがいいのではないか。
+ call, ret, push, pop などがあったほうが分かりやすい。これらまでも下位命令で作るのは低水準すぎる。

*1222494907*[連絡的]いろいろなアドレス

&lt;pre class=&quot;code&quot;&gt;
int g[] = {1, 2};

main(int argc)
{
  int i = 1;
  int j = 2;
  char *pc = (char *)g;

 start:
  printf(&quot;g = %p\n&quot;, g);
  printf(&quot;&amp;amp;g[0] = %p\n&quot;, &amp;amp;g[0]);
  printf(&quot;&amp;amp;g[1] = %p\n&quot;, &amp;amp;g[1]);
  printf(&quot;g + 1 = %p\n&quot;, g + 1);
  printf(&quot;g + 2 = %p\n&quot;, g + 2);
  printf(&quot;pc = %p\n&quot;, pc);
  printf(&quot;&amp;amp;pc[1] = %p\n&quot;, &amp;amp;pc[1]);
  printf(&quot;pc + 1 = %p\n&quot;, pc + 1);

  printf(&quot;&amp;amp;argc = %p\n&quot;, &amp;amp;argc);
  printf(&quot;&amp;amp;i = %p\n&quot;, &amp;amp;i);
  printf(&quot;&amp;amp;j = %p\n&quot;, &amp;amp;j);
 working:
  printf(&quot;&amp;amp;main = %p\n&quot;, &amp;amp;main);
  printf(&quot;&amp;amp;&amp;amp;start = %p\n&quot;, &amp;amp;&amp;amp;start);
  printf(&quot;&amp;amp;&amp;amp;working = %p\n&quot;, &amp;amp;&amp;amp;working);
}
&lt;/pre&gt;

*1222494908*[連絡的][メモ][その他プログラミング]エラーの通知

+ エラーは起きないと仮定
+ 正常値と異常値を戻り値で
+ 大域変数にエラー情報
+ エラー変数を出力引数に
+ 戻り値を出力引数に
+ 構造的データを使う

例：num ::= [0-9]* (8桁まで) エラーはBAD_CHARとTOO_LONG。

*1222495565*[連絡的][メモ][その他プログラミング]大きな戻り値

+ 構造体は値としてやり取りできる（コンパイラがやってくれる）
+ 呼ぶ側にバッファを準備してもらう。サイズも渡すのが吉。
+ 呼ばれた側にある静的バッファを使う。マルチスレッドで無理がある。
+ 呼ばれた側で動的メモリを確保して返す。free忘れで問題も起きる。

*1222496428*[ToySys]どうしても必要な命令

+ 定数生成
+ メモリからのロード、メモリへのストア
+ レジスタ間転送
+ 算術論理演算
+ 比較演算（条件（condition）の生成）
+ 無条件ジャンプ、条件ジャンプ
+ Jamp and Link（呼び出し用）
+ レジスタやスタックトップをターゲットとしたジャンプ（戻り用）
+ 入出力

定数生成はロードでも実行できる。

*1222496429*[ToySys]レジスタの変化

|* レジスタ |* 命令  |
| F | ADD, SH*, EQ, GT, GE |
| SP | POP, PUSH, CALL, RET, OSP (Offset SP)|
| FP | CALL, RET |
| IP | J*, CALL, RET |

*1222506589*[メモ][高次圏論]圏の組み合わせ幾何

いくつかのヒントを書く。

&lt;h5&gt;高次セルを忘れる関手&lt;/h5&gt;

Cが高次圏だとして、|C|&lt;sub&gt;k&lt;/sub&gt;はk次までのセルを考えた圏だとする。特に |C|&lt;sub&gt;0&lt;/sub&gt; = |C| = Obj(C) となる。|C|は忘却関手となり、次に述べるK(A)と随伴になる。このような随伴関係が一般化できないか。

&lt;h5&gt;完全有向グラフ&lt;/h5&gt;

Aを集合だとして、K(A)はAから作られた完全有向グラフとする。AとK(A)上に自明な圏構造を定義できる。この圏もまたK(A)で表す。A|→K(A) は、C|→|C|と随伴になる。

&lt;h5&gt;圏の懸垂&lt;/h5&gt;

空間Xに対して 柱体 X×[0, 1]を作り、X×{0}とX×{1}を1点に縮めた図形ΣXが懸垂であり、さらに懸垂の2つの端点を同一視したものが約懸垂。

圏の懸垂は、実際には約懸垂。新しい0セルが1個だけ導入され、0セルはループとなり、1セルはループを結ぶ2セルとなる。この方法で、モノイド圏を2圏と解釈できる。一般の高次圏Cの次元を1つ上げる懸垂写像を定義せよ。

&lt;h5&gt;高次元化&lt;/h5&gt;

n-圏があるとき、自明なn+1セルを加えて(n+1)-圏とみなせる。あるいは、AからK(A)を作るのと同じようにしても次元を上げることができそうだ。懸垂もまた次元を上げる。

&lt;h5&gt;次元のシフト&lt;/h5&gt;

Cのi次元パートをC&lt;sub&gt;i&lt;/sub&gt;とする。何らかの方法で、すべての整数にC&lt;sub&gt;i&lt;/sub&gt;が定義できるなら、C[k]&lt;sub&gt;i&lt;/sub&gt; = C&lt;sub&gt;k + i&lt;/sub&gt; で新しい圏を構成できる。

&lt;h5&gt;圏環と畳み込み&lt;/h5&gt;

モノイド環（モノイド代数）と畳み込み積を真似して圏環と畳み込みが定義できる。fとgが1セル上に定義された関数のとき：

- h(γ) = Σ(γ=α;β :  f(α)g(β))

として定義されるhが、fとgの畳み込み。γは1セルで、αとβはγの分解になっている。

&lt;h5&gt;鎖複体&lt;/h5&gt;

適当な係数で射の線形結合を作ると鎖を定義できる。バタニンのグローブなら、簡単に境界を定義できそうだ。

</body>
</day>
<day date="2008-09-29" title="">
<body>
*1222647963*[圏一般論][用語法]偏圏（partial category）

部分的に演算が定義された圏もどきをプレ圏と呼んでいたが、この用語法は都合が悪いことが分かってきた。プレを「部分的に定義された」という意味の形容詞には使いにくい。例えば、部分的に定義されたモノイド圏をプレモノイド圏と呼ぶのはまずい。かといって、「部分モノイド圏」ではsub-* と紛らわしい。

partialを表す形容詞として「偏」がある。「偏」を使って偏圏としよう。部分的に結合や積が定義されたモノイド圏もどきは偏モノイド圏となる。また、完全に（tatally）定義されたモノイド積を持つ偏圏はモノイド偏圏と呼べばよいだろう。

高次偏圏と、それを「生成系と関係」とみなして“自由生成”された高次圏は、使える道具になる予感がする。偏圏と圏は、高次圏の文脈では区別しなくてもいいような気もする。

*1222647964*[連絡的]言い忘れている

- &lt;del datetime=&quot;2008-09-29T09:34:19+09:00&quot;&gt;不等号比較でも符号が関係するな。&lt;/del&gt; やっぱり関係しないな。
- ニブル、MSBとLSB、桁位置と桁数
- 符号ビットという言葉はある。
- 3本指で8、片手で32、両手で1K (1024)、両手両足で1M (1024*1024)
- 型とサイズの一覧表

- http://d.hatena.ne.jp/m-hiyama-memo/20080922/1222044382

それからアドレス。

</body>
</day>
<day date="2008-09-30" title="">
<body>
*1222734665*[連絡的]再帰の秘密を覗いてみる

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

int x = 1;
int i = 1;

void rec(int c)
{
  int i = 0;
  printf(&quot;(c = %d) &amp;amp;x = %p, &amp;amp;c = %p, &amp;amp;i = %p\n&quot;, c, &amp;amp;x, &amp;amp;c, &amp;amp;i);
  if (c &lt;= 0) return;
  rec(c - 1);
}

main()
{
  int c = 5;
  printf(&quot;(main ) &amp;amp;x = %p, &amp;amp;c = %p, &amp;amp;i = %p\n&quot;, &amp;amp;x, &amp;amp;c, &amp;amp;i);
  rec(c);
}
&lt;/pre&gt;

*1222735152*[連絡的]配列は意外なところもある

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

int a[] = {1, 2, 3};
char b[] = {1, 2, 3};

main()
{
  printf(&quot;a = %x, &amp;amp;a = %x, sizeof(a) = %d\n&quot;, a, &amp;amp;a, sizeof(a));
  printf(&quot;a[0] = %x, &amp;amp;a[0] = %x, sizeof(a[0]) = %d\n&quot;, a[0], &amp;amp;a[0], sizeof(a[0]));
  printf(&quot;b = %x, &amp;amp;b = %x, sizeof(b) = %d\n&quot;, b, &amp;amp;b, sizeof(b));
  printf(&quot;b[0] = %x, &amp;amp;b[0] = %x, sizeof(b[0]) = %d\n&quot;, b[0], &amp;amp;b[0], sizeof(b[0]));

  int *p;  char *q;
  printf(&quot;p = a; q = b;\n&quot;);
  p = a; q = b;
  printf(&quot;p = %x, &amp;amp;p = %x, sizeof(p) = %d\n&quot;, p, &amp;amp;p, sizeof(p));
  printf(&quot;p[0] = %x, &amp;amp;p[0] = %x, sizeof(p[0]) = %d\n&quot;, p[0], &amp;amp;p[0], sizeof(p[0]));
  printf(&quot;q = %x, &amp;amp;q = %x, sizeof(q) = %d\n&quot;, q, &amp;amp;q, sizeof(q));
  printf(&quot;q[0] = %x, &amp;amp;q[0] = %x, sizeof(q[0]) = %d\n&quot;, q[0], &amp;amp;q[0], sizeof(q[0]));
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char a[][5] = {
  &quot;abcd&quot;,
  &quot;uvwx&quot;
};
char *b[] = {
  &quot;abcd&quot;,
  &quot;uvwx&quot;
};

char *s = &quot;abcdef&quot;;

main()
{
  printf(&quot;a[0]= %s, a[1] = %s\n&quot;, a[0], a[1]);
  printf(&quot;b[0]= %s, b[1] = %s\n&quot;, b[0], b[1]);
  printf(&quot;sizeof(a) = %d, sizeof(b) = %d\n&quot;, sizeof(a), sizeof(b));
  printf(&quot;sizeof(a[0]) = %d, sizeof(b[0]) = %d\n&quot;, sizeof(a[0]), sizeof(b[0]));
  printf(&quot;strlen(a[0]) = %d, strlen(b[0]) = %d\n&quot;, strlen(a[0]), strlen(b[0]));
  printf(&quot;sizeof(s) = %d, strlen(s) = %d\n&quot;, sizeof(s), strlen(s));
}
&lt;/pre&gt;

*1222735453*[連絡的]構造体もけっこう意外だったりして

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

struct person {
  unsigned short age;
  char *name;
} ichiro = {23, &quot;SUZUKI Ichiro&quot;};

struct person2 {
  unsigned short age;
  char name[20];
} jiro = {20, &quot;SUZUKI Jiro&quot;};

main()
{

  printf(&quot;sizeof(ichiro) = %d\n&quot;, sizeof(ichiro));
  printf(&quot;sizeof(ichiro.age) = %d\n&quot;, sizeof(ichiro.age));
  printf(&quot;sizeof(ichiro.name) = %d\n&quot;, sizeof(ichiro.name));
  printf(&quot;&amp;amp;ichiro = %x, ichiro = %x\n&quot;, &amp;amp;ichiro, ichiro);
  printf(&quot;&amp;amp;ichiro.age = %x, &amp;amp;ichiro.name = %x\n&quot;, &amp;amp;ichiro.age, &amp;amp;ichiro.name);

  printf(&quot;sizeof(jiro) = %d\n&quot;, sizeof(jiro));
  printf(&quot;sizeof(jiro.age) = %d\n&quot;, sizeof(jiro.age));
  printf(&quot;sizeof(jiro.name) = %d\n&quot;, sizeof(jiro.name));
  printf(&quot;&amp;amp;jiro = %x, jiro = %x\n&quot;, &amp;amp;jiro, jiro);
  printf(&quot;jiro = %x, &amp;amp;jiro = %x\n&quot;, jiro, &amp;amp;jiro); // ちょっと難しい
  printf(&quot;&amp;amp;jiro.age = %x, &amp;amp;jiro.name = %x\n&quot;, &amp;amp;jiro.age, &amp;amp;jiro.name);

}
&lt;/pre&gt;


</body>
</day>
<day date="2008-10-01" title="">
<body>
*1222829752*[ToySys]FPの指す場所

+ 候補：第1引数を指す。引数がないときは、親の領域の最後。
+ 候補：ローカル領域の最初を指す。ローカル領域がないときは、未使用領域の最初。
+ 候補：戻り番地の格納場所を指す。
+ 候補：旧FPの待避場所を指す。

どれでも大差ないけど。

*1222833291*[連絡的]配列

配列はけっこう難しい。配列データの概念は全然難しくないけど、ソースコード上の配列名がなんであるかが分かりにくい。ポインタ変数というわけでもない。一方で、ポインタ変数は構文上は配列名と同じように機能する。「配列名＝ポインタ変数」は間違いだが、さほど問題が起きなかったりもする。

でも、やっぱり違いを理解しておかないとダメだな。

- 参考： http://d.hatena.ne.jp/m-hiyama/searchdiary?word=%b2%ad%ce%d3

</body>
</day>
<day date="2008-10-03" title="">
<body>
*1223021967*[Erlang][その他プログラミング]BCPLの型概念

マーチン・リチャーズは型を：

+ conceptual type
+ internal type (or actual type)

に分けて考えている。ウムッ！

internal typeによりcoceptual typeをうまく表現するのが&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E6%9C%AC%E7%89%A9%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC%E3%81%AF%E3%83%91%E3%82%B9%E3%82%AB%E3%83%AB%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84&quot;&gt;本物のプログラマ&lt;/a&gt;ってことかな。

*1223021969*[Erlang][小咄]プロパティリスト

proplist, plist、多用される。{foo, boolean()}型のプロパティはアトムfooで代用できる。ときに、{foo, false}をno_fooで表現することも（標準的ではないが）。

次の2つがプロパティをミニマイズする関数。変換するのは{atom(), true}だけ！ atom(), false} → 'no' + atom() はやらない。
&lt;pre&gt;
property(Key, Value) -&gt; Property
where
 Key = term()
 Value = term()
 Property = atom() | tuple()

property(Property) -&gt; Property
 where Property = atom() | tuple()
&lt;/pre&gt;

http://www.erlang.org/doc/man/proplists.html も参照。

*1223025175*[Erlang]EDoc内容の型

+ 無視されるテキスト 例：hidden, private
+ 単なるテキスト 例：copyright
+ タグ特有の構造的なテキスト 例：author
+ 型表現 例：spec, type
+ XHTMLフラグメント 例：doc

これで全部だと思うがね。

</body>
</day>
<day date="2008-10-04" title="">
<body>
*1223090383*[メモ][後で消す]紛失本

- 黒くて薄いコンパイラ本 -- まだ見つかってない。
- ホーアのCSPの本
- セリンガーの非同期の論文、いったい何回印刷したことか！

*1223091732*[その他プログラミング]Perl Getopt:Long

http://d.hatena.ne.jp/m-hiyama/20081002/1222921844 の落ち穂拾い。

+ オプション名のcaseは無視される。
+ 'foo+' は複数回指定を宛先変数に累積カウントする。
+ 'foo=s' の宛先変数が配列なら複数回指定を配列に入れる。
+ オプション全体（一部でもいいのだが）の宛先をハッシュにできる。そのときのオプション指定は、引数並び、または配列引数で指定。
+ 一般論として、+をオプションに使うのは非推奨。
+ GetOptionsは真偽値を戻す。
+ -- とすると、そこから後はオプション解析をしない。
+ ひとつのオプションに対して、宛先をハッシュにできる。GetOptions(&quot;def=s&quot; =&gt; \%macros); コマンドラインは --def name=foo version=1.0 --def author=Hiyama のよう。
+ 関数を指定できる。GetOptions('verbose' =&gt; \$verbose, 'quiet' =&gt; sub{$verbose = 0}); 
+ 単一の-はオプションと認識されないで、@ARGVに残る。だが、GetOptions('' =&gt; \$stdio); と出来る。無名のオプションを指定したことになる。
+ 'help|?' =&gt; \$help はイディオム。

*1223100914*[気付いた][小咄][説明][課題]畳み込み積

モノイドの畳み込み積を圏に一般化してみる。


</body>
</day>
<day date="2008-10-06" title="">
<body>
*1223249318*[記録][Erlang]erl, werlの中断

Windowsでは：
+ werlは、Ctrl-PauseにもCtrl-Cにも反応しない。&lt;em&gt;Ctrl-Gには反応&lt;/em&gt;。
+ erlは、Ctrl-Pause、Gtrl-Gに反応せず、Ctrl-Cでいきなり死んでしまう。

*1223249319*[記録]andLinux

最初に起動したとき、コアが初期化するのにえらい時間がかかった。死んだかと思った。

&lt;pre class=&quot;out&quot;&gt;
loadkyes jp106
&lt;/pre&gt;

↑をしないとエライことになる。なんかたまに勝手に英語キーボードに切り替わっている気もする。

ネットワーク回りは何もやってない。

&lt;pre class=&quot;code&quot;&gt;
$ apt-get update
$ apt-get install emacs
&lt;/pre&gt;
これでとりあえずemacs使えるようになった。基本的に別ウィンドウで動くから&amp;amp;いれないとターミナル側のシェルが待ってしまう。いつも（って10年前？）ターミナル上で使っていたからどうも勝手がわからなん。

- メニューはうざい→ http://d.hatena.ne.jp/m-hiyama-memo/20071102/1193986959
- コンソールのアイコンがショボ過ぎ。
- ユーザー作ってないから、.emacsを書く場所がない。
- 同じく.profile（いや、/etc/profileか）に loadkeys jp106 を書いておかないと。

*1223250618*[気付いた][プログラム意味論]ラベルの解釈（読み）と無音記号、自発性問題

+ コマンド読み：ラベルはコマンド、外部からの命令、内部は命令に従って動作
+ レポート読み：ラベルはレポート、内部からの事後報告、内部は自発的に動作する

+ コマンドは、外部から発行され内部に届き、内部で実行される。
+ レポートは、内部による実行後に発行され、外部に届く。

+ 外部視点では、コマンドは能動的に発行し、レポートは受動的に受け取る（観測）。
+ 内部視点では、コマンドは受動的に受け取り（受理、受容）、実行とレポートは能動的に発行する。

- レポートは、内部から発行されるコマンドとも解釈可能。
- したがって、コマンドをパブリックアクション、レポートをプライベートアクションとも解釈できる。

状態遷移を観測できるが内部ラベル（レポート、プライベートアクション）を観測できない観測者がいると、すべての内部ラベルは無音記号に見える。つまり、内部ラベルを縮退させた擬似外部ラベルが無音記号なのだろう。これがもっともまっとうな無音記号の解釈だと思う（なにが「まっとう」かはあまりつっこまないとして）。

*1223280167*[Erlang][用語法]Erlangジャーゴン的

|* 言葉     |* Erlang |* 一般的 |
| プロセス | 軽量プロセス | OSプロセス |
| ポート | port() 型 | 通信の口 |
| チャンネル | - | 伝送経路 |
| アプリケーション|モジュール集合 | 普通の意味 |
| メールボックス | メッセージキュー | 普通の意味 |
| ノード |クラスター内のERTS| グラフやツリーの頂点 |
| リンク |プロセス間の結合| いろいろ |
| RPC    | (下に説明) | ネットワーク越しの呼び出し |
| 束縛   | (下に説明) | いろいろ |
|ベヘイビア | ミニフレームワーク | ？ |

ポート、アプリケーション、メールボックスは説明なしでの使用はダメーー。

- PRCは、メッセージベースの手続き呼び出し方式のことを意味することがる。そのときは、単一ノード、単一メモリ空間でもremoteという。
- rpcモジュールは、クラスター構成でノードを越えた手続き呼び出し機能を提供する。
- 束縛は、自由変数のラムダ束縛と、変数と値の関連（association）を表す名前／値ペアの意味がある。束縛の全体が環境。

*1223286490*[記録]インストールとか

&lt;pre&gt;
dpkg -l 文字列 -- ある文字列を含むパッケージを探す 
&lt;/pre&gt;

なるフム。

&lt;pre class=&quot;out&quot;&gt;
$ apt-get install erlang
&lt;/pre&gt;

してコーヒーを飲みにいった。あれ、エラーしてたような、、、/var/log/dpkg.log にログが書いてあるが、画面に出たエラーメッセージは入ってないや。
&lt;pre class=&quot;out&quot;&gt;
$ apt-get install erlang | tee log 
&lt;/pre&gt;
すべきだった。

</body>
</day>
<day date="2008-10-07" title="">
<body>
*1223338907*[雑記][その他プログラミング]_doprnt関数

これでナニかやったことがある。なつかしいような。が、ナニがなんだったかサッパリ思い出せない。

*1223353433*[雑記][メモ]Ctrl-G って

- [http://d.hatena.ne.jp/m-hiyama-memo/20081006/1223249318:title]

あ、そうか。^G ってEmacsの中断だな、とか思っていたが、OSシグナルのSIGINTだったのか。シグナルなんてすっかり忘れてるな。^CもSIGINTだったんじゃないの？ &lt;b&gt;[追記]&lt;/b&gt;んっ？ SIGINGは^Cだけだったか？ ダメダ、忘れて混乱している。&lt;b&gt;[/追記]&lt;/b&gt;

SIGSTOPの^SとSIGCONTの^QはMS-DOCの時代もあったなー。が、あんまり効かなかった。

^ZはSIGTSTPか、これはよく使うな。

*1223356415*[オフトピック]なるほど、YouTubeはなんぼでも時間を無駄にできる道具だ

- http://jp.youtube.com/watch?v=TbP2djP0h5g&amp;feature=related リベリオン最後のほう 縦長過ぎ
- http://jp.youtube.com/watch?v=CeHrq_Fs1vk&amp;NR=1 その続き
- http://jp.youtube.com/watch?v=szlqfoStaNc&amp;NR=1 見せ場、横長ー、小さーい
- http://jp.youtube.com/watch?v=_mAH_6V5h4c&amp;feature=related ガンカタの解説
- http://jp.youtube.com/watch?v=tINWl0gzQWI&amp;feature=related ガンカタ編集版

*1223361082*[Erlang][課題]副作用と順次実行

- 1. 局所環境＝変数環境への作用 パターンマッチング
- 2.1 メッセージ送出 他プロセス／ランタイム全体への作用 
- 2.2 ランタイム外部への影響 ポート 一応メッセージングと統合されている

式Eの環境σでの評価結果＝値を【E】&lt;sub&gt;σ&lt;/sub&gt;とする。Eの評価に伴う環境σへの作用をE(σ)とする。

+ 【(E1, E2)】&lt;sub&gt;σ&lt;/sub&gt; = 【E2】&lt;sub&gt;σ'&lt;/sub&gt; where σ' = E1(σ)
+ (E1, E2)(σ) = E2(E1(σ))

- (E1, E2, E3) ≡ ((E1, E2), E3)

もう少し網羅的精密な定式化が必要だな。

</body>
</day>
<day date="2008-10-08" title="">
<body>
*1223427324*[Erlang][リンク]Erlangの例外、その他

以下の2つ、いろいろな意味で面白い！ 味読すべき一品。プロセスリンクとシグナリングシステムについても考えさせられる。

- http://www.erlang.se/workshop/2004/exception.pdf  論文
- http://www.erlang.se/euc/04/carlsson_slides.pdf スライド

その他：
- http://www.erlang.org/doc/pdf/test_server.pdf これはマニュアル。TestServerって知らなかった。
- http://www.erlang.se/publications/Ulf_Wiger.pdf よく出来た紹介。一般的なプレゼンによさそう。

*1223428370*[Erlang][リンク]アームストロングとカールソンの言葉をクリップ

Joe Armstrong, &quot;defensive programming&quot;
- http://www.erlang.org/pipermail/erlang-questions/2003-March/007869.html
&gt;&gt;
If you do *nothing* to your code you get a good diagnostic anyway:
&lt;hr&gt;
In C etc. you  have to write *something* if you detect an
error -  in Erlang it's  easy - don't  even bother to write  code that
checks for errors - &quot;just let it crash&quot;.
&lt;&lt;

Richard Carlsson, erlang:fault/1 vs. erlang:exit/1
- http://www.erlang.org/pipermail/erlang-questions/2006-May/020606.html
&gt;&gt;
when you *really* do mean &quot;terminate the process, giving Term
as the reason if anyone is watching this process&quot;, use exit(Term).
&lt;&lt;

Joe Armstrong, Why OO Sucks
- http://www.sics.se/~joe/bluetail/vol1/v1_oo.html


</body>
</day>
<day date="2008-10-09" title="">
<body>
*1223525166*[後で消す][メモ]今週と来週

- EC2
- 日常的TODO(?)消化
- 10日は公園フェステバル
- 10-13は休日、10-15（水曜）に延期。
- 10-14は早く帰る
- 写真の整理と追加
- メガネ＋コンタクト
- EC2
- SVNローカルコピーの整理
- またクリーニングとか

*1223525656*[プログラム意味論][リンク]継続とか

http://www.ice.nuie.nagoya-u.ac.jp/~h003149b/ -- 名古屋大学の学生さんだろうか？ 面白いことが書いてある。継続関係は：

- http://www.ice.nuie.nagoya-u.ac.jp/~h003149b/lang/cont_intro.html
- http://www.ice.nuie.nagoya-u.ac.jp/~h003149b/lang/block.html
- http://www.ice.nuie.nagoya-u.ac.jp/~h003149b/lang/actor/actor.html
- http://www.ice.nuie.nagoya-u.ac.jp/~h003149b/lang/cps_values.html

</body>
<comments>
<comment>
<username>syamino</username>
<body>どうやらリンク切れのようですね。&lt;br&gt;以下のページは同じ内容でしょうか？&lt;br&gt;&lt;br&gt;プログラム言語とその他のメモ。 http://kreisel.fam.cx/webmaster/clog/img/www.ice.nuie.nagoya-u.ac.jp/~h003149b/lang/index.html</body>
<timestamp>1325053462</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>syaminoさん、&lt;br&gt;卒業しちゃうとページがなくなるとか、かな。&lt;br&gt;&lt;br&gt;&gt; 以下のページは同じ内容でしょうか？&lt;br&gt;ハッキリ覚えてませんが、たぶんソレのような。</body>
<timestamp>1325055953</timestamp>
</comment>
</comments>
</day>
<day date="2008-10-14" title="">
<body>
*1223953806*[Erlang][メモ]EDocの興味ある関数、オプション

edoc_lib.erlの、
+ get_first_sentence
+ read_info_file
+ write_info_file

- {includes, [string()]} オプション&lt;br&gt;外部ファイルのサーチパスを指定する。@docfile, @headerfileで効いてくる。includesと複数形、値は文字列のリストであることに注意。


</body>
</day>
<day date="2008-10-15" title="">
<body>
*1224028630*[連絡的]備忘

+ JavaとCのあいだには文化問題があると思う。
+ 異なる文化は同列に議論も理解もできない。
+ 欧米やアフリカの人に、「粒餡（tsubuan）」や「鰹だし（katsuodashi）」の意味を説明するには？
+ 郷に入りては郷に従え。
+ 欠点も含めて特徴。メリットデメリットはものごとの表裏。

</body>
</day>
<day date="2008-10-17" title="">
<body>
*1224229734*[高次圏論]globular relations

n＞i≧0 として、一般化したdomをd&lt;sub&gt;-&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;、一般化したcodをd&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;、一般化したidをs&lt;sup&gt;n←i&lt;/sup&gt;と書く。次をglobuar relationsと呼ぶ。n = i のときは、すべて恒等写像としてもよい（そうしたいなら）。

- d&lt;sub&gt;α&lt;/sub&gt;&lt;sup&gt;i←j&lt;/sup&gt;・d&lt;sub&gt;β&lt;/sub&gt;&lt;sup&gt;j←n&lt;/sup&gt; = d&lt;sub&gt;α&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt; （i＜j＜n）

これのモデルは、G&lt;sup&gt;n&lt;/sup&gt; = {0, n+1}（2元集合）として、

+ d&lt;sub&gt;-&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;(0) = 0
+ d&lt;sub&gt;-&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;(n+1) = 0
+ d&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;(0) = i + 1
+ d&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;i←n&lt;/sup&gt;(0) = i + 1

で定義できる。

sに関しては：

- s&lt;sup&gt;n←j&lt;/sup&gt;・s&lt;sup&gt;j←i&lt;/sup&gt; = s&lt;sup&gt;n←i&lt;/sup&gt;

sとdが特に関係ないなら、先のモデルで、

- s&lt;sup&gt;n←i&lt;/sup&gt;(0) = 0
- s&lt;sup&gt;n←i&lt;/sup&gt;(i+1) = n + 1

とすればよい。sだけならもっと簡単なモデルもある。

次は、レトラクションの定義を一般化したようなもの。

- d&lt;sub&gt;α&lt;/sub&gt;&lt;sup&gt;j←n&lt;/sup&gt;・s&lt;sup&gt;n←i&lt;/sup&gt; = (j＜i⇒d&lt;sub&gt;α&lt;/sub&gt;&lt;sup&gt;j←i&lt;/sup&gt;; j = i⇒Id; j＞i⇒s&lt;sup&gt;j←i&lt;/sup&gt;)

すべての等式を満たすfamily of mapsは、reflexive glubular setを定義する。これのモデルはほんの少し複雑になる。

</body>
</day>
<day date="2008-10-18" title="">
<body>
*1224300132*[高次圏論]strict globular categoryは簡単そう

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081017/1224229734&quot;&gt;昨日&lt;/a&gt;と少し記法を変える。0≦i＜k  だとして、

- d&lt;sub&gt;-&lt;/sub&gt;&lt;sup&gt;i←k&lt;/sup&gt;をdom&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;
- d&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;i←k&lt;/sup&gt;をcod&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;
- s&lt;sup&gt;k←i&lt;/sup&gt;をid&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt;

要するに、上から下に向かう矢印があると思えばいい。で、反射的球集合（reflexive globular set）を考える。Cが反射的球集合だとして、そのk次元部分をC&lt;sup&gt;k&lt;/sup&gt;と上付き添字で示す。

x, y∈C&lt;sup&gt;i&lt;/sup&gt;だとして、(k, i)-ホムセット（とりあえず構造は入れない）C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(x, y) は次のように定義する。

- f∈C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(x, y) ⇔ (f∈C&lt;sup&gt;k&lt;/sup&gt;, dom&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(f) = x, cod&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(f) = y)

次元が付いている以外は、1-圏とまったく同じ。単位は既にid&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt;として定義している。x∈C&lt;sup&gt;i&lt;/sup&gt;のとき、反射的球関係式（reflexive globular relations）から、id&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt;(x)∈C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(x, x) なのがわかる。

結合は、隣接するホムセットの間で定義できる。

- -[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]- :C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(x, y)×C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(y, z) → C&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;(x, z)

例えば左単位律は、id&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt;(x)[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]f = f と普通に記述できる。結合律も同様。

それ以外に、境界の条件と交替律が必要だ（それだけでいいのか？）、dom&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;k-1&lt;/sub&gt;は単にdom&lt;sup&gt;k&lt;/sup&gt;、またはdom（codも同じ）、id&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;k+1&lt;/sub&gt;を単にid&lt;sub&gt;k&lt;/sub&gt;、またはidと略記することにする。

まずは境界に関する条件：

- dom(f[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]g) = dom(f)[&lt;sup&gt;k-1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]dom(g)
- cod(f[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]g) = cod(f)[&lt;sup&gt;k-1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]cod(g)

結合の交替律は：

- (f[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]g)[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;j&lt;/sub&gt;](f'[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]g') = (f[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;j&lt;/sub&gt;]g)[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;](f'[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;j&lt;/sub&gt;]g') 

と、けっこう見やすい。恒等に対する交替律は：

- id(f[&lt;sup&gt;k&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]g) = id(f)[&lt;sup&gt;k+1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]id(g)

まー、上下の添字がめんどくさいのではあるが、等式なので、別に問題なく計算できる。やっぱり、strictケースなら、さほど難しくはないな。

&lt;b&gt;[追記]&lt;/b&gt;iセルで隣接したkセルの結合を f[n;i]g と書くと添字がなくなっていいかもね。手書きのときは□とかを使って、横か中にn, iを書けばいいだろう。&lt;b&gt;[/追記]&lt;/b&gt;

*1224314900*[高次圏論]bridge graph, bridge magma

strictな計算は簡単。さて、Carl A. Futiaに従うとして、次はブリッジだ。僕のイメージとしては、ブリッジつうより&lt;em&gt;膜&lt;/em&gt;の集まりなんだけどね。

a, b∈C&lt;sup&gt;k&lt;/sup&gt; に対して、1次元高い膜c∈C&lt;sup&gt;k+1&lt;/sup&gt;が与えられているとき、c:a～→b と書くことにする。与えられた膜（ブリッジ）cの全体がブリッジ関係R。

+ c:a～→b なら、dom(c) = a, cod(c) = b, aとbは共端
+ id(a):a～→a という恒等膜（恒等ブリッジ）は常に考える。
+ c:a～→b, d:a～→b なら、c = d

これらの条件はRに含まれる膜（ブリッジ）に関するもの。例えば、共端じゃないと膜は張れないし、1つの共端ペア(a, b)には高々1枚の膜しか張れない。id(a)は自明な膜で、最低でもこの自明膜は存在する。

自明膜の存在から反射律が成り立つと思ってよいし、もし結合演算があるなら推移律も成り立つようにできる。が、a～→b から b～→a は保証されないので対称ではない。

台構造がmagmaのときは、ブリッジ関係から反射的かつ推移的な関係を生成できる。magma上のブリッジが一貫性データを記述する手段らしいが、まだよくわからん。

*1224317562*[連絡的]メモリブロック

+ どこ？＝場所＝先頭アドレス
+ どのくらい？＝サイズ
+ なに？＝中身

メモリセルとは区別する。メモリセクション／セグメントともちょっと別。

xがメモリブロックを指すなら、

+ どこ → &amp;amp;x
+ どのくらい → sizeof(x)
+ なに → 例えば次の関数

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

void dumpmem(unsigned char *p, unsigned size)
{
  static int hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		  'A', 'B', 'C', 'D', 'E', 'F'};

  unsigned char *bound;
  int u;
  for (bound = p + size; p &lt; bound; p++) {
    u = *p;
    putchar(hex[(u&amp;0xF0)&gt;&gt;4]); // 上位ニブル
    putchar(hex[u&amp;0x0F]); // 下位ニブル
    putchar(';'); // 1バイトの終わりを示す
  };
}

// お試し
main()
{
  int foo[] = {1, 0x230F, 0x450F0, 0x670F00, 0x890F000};
  dumpmem((unsigned char*)foo, 5*4);
}
&lt;/pre&gt;

- 変数の宣言は（省略可能ではあるが）だが必須、なぜか？
- 関数の宣言はイイカゲンでどうでもよかった、なぜか？

</body>
</day>
<day date="2008-10-20" title="">
<body>
*1224459414*[連絡的]ASCIIコマンド

自前でasciiコマンドを作る。

縦列にするカラム型のレイアウトはめんどうだから、横に見ていく形でよい。

0から127の値に対して、16進表記と対応するASCII文字を並べた3行で1セット。行の長さは見やすいように適宜調整。

*1224459609*[高次圏論][課題]ブリッジωグラフのコントラクション

用語法をフーティア（Carl A. Futia）にあわせて、加算無限次元の反射的球集合をωグラフと呼ぶことにする。ωグラフにブリッジ関係（bridge relation）が付いた構造がブリッジωグラフ。

ブリッジωグラフの準同型f:(X, R)→(Y, Δ)で、Yのブリッジ関係は自明（各次元の恒等だけ）だとして、次の条件を満たすならコントラクション：

+ c:a～→c in X ならば、f(a) = f(b) = u、f(c) = id(u) in Y。
+ a, b∈X&lt;sup&gt;i&lt;/sup&gt;、aとbは共端、f(a) = f(b) ならば、c:a～→c となるcがある。

要するに、ブリッジがあるとその両端はつぶれて同一になる。逆に、共端なセルがfでつぶれるのは、（少なくとも片方向の）ブリッジがあるときに限る。aとbのあいだにブリッジがないときは、f(a)とf(b)は同じになれないので、ブリッジの不在が&lt;em&gt;反発力&lt;/em&gt;となってつぶれるないように&lt;em&gt;ささえている&lt;/em&gt;感じ。

ブリッジωグラフから、標準的な（普遍的な）コントラクションを作れるだろうか？ どんな条件があればいいのだろうか？ イコールが推移的だから、「不在＝反発力」の原理(?)から、ブリッジも推移的じゃないといけないな。ただし、方向を無視した推移性だけど（これはややこしい）。対称性は全然必要ない。

フーティアはさらに、ブリッジωマグマからのコントラクションの先が厳密ω圏のときペノン（Pennon）準同型と呼んでいる。ペノン準同型の感覚がどうも掴めない。

</body>
</day>
<day date="2008-10-21" title="">
<body>
*1224549709*[メモ]ウギャ、恥ずかしい間違い blidge→bridge

ここ何日か、blidgeと書いていた。直さなきゃ。

*1224554519*[リンク]コックのツリーに関する論文

- Title: Polynomial functors and trees
- Author: Joachim Kock
- URL: http://arxiv.org/abs/0807.2874
- 51ページ

長いな。でも、コックは読みやすいからいいかも。

*1224554793*[リンク]グランディスの弱方体圏に関する論文

- Title: HIGHER COSPANS AND WEAK CUBICAL CATEGORIES (COSPANS IN ALGEBRAIC TOPOLOGY, I)
- Author: MARCO GRANDIS
- URL: http://www.tac.mta.ca/tac/volumes/18/12/18-12.pdf
- 28ページ

*1224579369*[圏一般論]余極限の定義とか性質とか、ペギオ版を修正

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20081020/1224461181&quot;&gt;本編で話題沸騰&lt;/a&gt;（? もう&lt;em&gt;終結&lt;/em&gt;だけど）の郡司ペギオさん。1999年論文に出ていた左カン拡張や余極限の定義だけど、これは教科書の引き写しだろうから正しいのかと思っていたら、写し間違いがあったみたいだ(苦笑)。これは修正可能だから、“トレーニングとして”書き直しておこう（これだけだよ）。

&lt;h5&gt;たぶん写し間違い&lt;/h5&gt;

まず、写し間違いらしいところ（≒は同型のつもり、＝って書いちゃうかもしれないけど、それはカンベンね）：

- Nat(Lan&lt;sub&gt;F&lt;/sub&gt;X, M) ≒ Nat(X, MF)

郡司さんの記号をできるだけそのまま使うことにして、F:A→B, X:A→C, M:C→Bは関手。GFのような並置は反図式順の結合（GF = F;G）。前提される状況は下図のとおり。

&lt;pre&gt;
 A -(X)→C
 ｜    ／
 F   ／M
 ↓／
 B
&lt;/pre&gt;

XとMが入れ違っているので上の同型は解釈不可能。次が修正したやつ：

- Nat(Lan&lt;sub&gt;F&lt;/sub&gt;X, M) ≒ Nat(F, MX)

下の図では、Lan&lt;sub&gt;F&lt;/sub&gt;XをLと書いていて、“自然変換＝2セル”の集合の間に同型（≒で示した）がある：

&lt;pre&gt;
  C           A
｜  ｜     ｜   ｜
L ⇒M  ≒  F ⇒ MX 
↓  ↓     ↓   ↓
  B           B
&lt;/pre&gt;

郡司さんは、圏Cをsingletonな圏に特化して、余極限を論じているんだけど、圏と圏の対象を混同しているので、激しくワケわからん記述となっている。以下、全部書き直す。

&lt;h5&gt;自明な圏1からの関手と自然変換&lt;/h5&gt;

F:A→B は任意の関手。1はただひとつの対象(0と書く)とid&lt;sub&gt;0&lt;/sub&gt;だけからなる自明な圏。X:A→1 は、圏A全体を一点につぶしてしまう関手。A→1はひとつしかない； 圏1は圏の圏の終対象。

さて、M:1→B が関手だとは、結局、Bの対象を１つ特定する操作なので、MはM(0)というBの対象と同一視してもよい。つまり、

- Func(1, B) ≒ |B| （Bの対象集合）

この同型により、b∈|B| に対応するFunc(1, B)内の関手も単にbと書く； 記号を濫用して b:1→B、b(0) = b。Bの対象b, b'を選ぶと、Nat(b, b':1→B)はホムセットB(b, b')と標準的に同型。要するに、指数法則 B&lt;sup&gt;1&lt;/sup&gt; = B ということね。

&lt;h5&gt;余極限&lt;/h5&gt;

Fの余極限を論じる。定義としては、Fからの（F下の）余錐の圏CoCone(F)を考えて、この圏の始対象を余極限だとする。単に余極限というと曖昧なので、圏CoCone(F)の始対象は&lt;strong&gt;余極限余錐&lt;/strong&gt;、余錐の頂点を&lt;strong&gt;余極限対象&lt;/strong&gt;と区別して呼ぶ。余極限余錐をColim(F)、余極限対象をcolim(F)と書く（ちょっと紛らわしいが大文字、小文字で区別）。

以下、関手（Aをシェープとする図式と思ってもいい）F:A→Bに対して、γ = Colim(F)、c = colim(F)とする。定義から、γ∈|CoCone(F)|、c∈B である。γはCoCone(F)の始対象なので、任意の（Fからの）余錐αに対して γ→α という余錐の射（CoCone(F)の射）は1本しかない。

&lt;h5&gt;余極限の特徴付け&lt;/h5&gt;

先の図を C = 1 と特化すると：
&lt;pre&gt;
  1           A
｜  ｜     ｜   ｜
L ⇒M  ≒  F ⇒ MX 
↓  ↓     ↓   ↓
  B           B
&lt;/pre&gt;

LはFの余極限対象（を1からの関手とみなしたもの）、Mは任意の関手、XはAを1点につぶす関手である。余極限対象の関手版であるLはBの対象cで決まり、MもBの対象b = M(0) と同一視する。また、X;M = X;b も、Aからの定数関手なので、対象bと同一視してよい。その結果、次のように書いてよい。

&lt;pre&gt;
  1           A
｜  ｜     ｜   ｜
c ⇒b  ≒  F ⇒ b 
↓  ↓     ↓   ↓
  B           B
&lt;/pre&gt;

それで示すべきは、

- Nat(c, b) ≒ Nat(F, b) （c = colim(F)）

となる。Nat(c, b) = B(c, b) は既に明らかにしたから、以下で Nat(F, b) = B(c, b) を示す。

まず、b∈|B|に対して、bを頂点とする余錐の集合をCoCone(F→b)とする。CoCone(F→b)⊆|CoCone(F)| である。任意のβ∈CoCone(F→b)に対して、φ:γ→β という余錐の射φが1本存在する（φ = 0&lt;sub&gt;β&lt;/sub&gt;と書くべきかも）、γが始対象だから当たり前ね。φの頂点部分を f:c→b in B とすると、β|→f という対応は、CoCone(F→b)からB(c, b)への写像となる。逆に、f∈B(c, b) が与えられたとき、cを頂点とする余錐γに、fを後結合してbを頂点とする余錐βを作り出せる、この構成は B(c, b)→CoCone(F→b) となる。

上の2つの構成（「始対象からβへの唯一射」の頂点を取る構成と、頂点射から余錐βの構成）は互いに逆なので、

- CoCone(F→b) ≒ B(c, b) （c = colim(F)）

が得られる。（もうちょっと丹念に定義と付き合わせる作業が必要かもしれないが、大丈夫だろう。）

&lt;h5&gt;もうひと押し&lt;/h5&gt;

c, b∈B が何であれ、Nat(c, b:1→B) ≒ B(c, b) はOK。cがFの余極限対象であるとき、CoCone(F→b) ≒ B(c, b) 。となると、Nat(F, b) ≒ CoCone(F→b) が示せれば望みの結果が得られる。

βが F⇒b:A→B という自然変換だとする、つまりβ∈Nat(F, b:A→B)。a∈|A| に対する自然変換βの成分β&lt;sub&gt;a&lt;/sub&gt;:F(a)→b は余錐の母線だと思える。逆に、Fからの余錐の母線は自然変換の成分だと思える。つまり、Nat(F, b)≒CoCone(F→b) となっている。

以上から、

- Nat(F, b)≒CoCone(F→b)≒B(c, b)≒Nat(c, b) （c = colim(F)）

が成立する。

キモは、CoCone(F→b)≒B(c, b) の同型の部分かな。

&lt;h5&gt;それで&lt;/h5&gt;

いちおうトレーニングになったか？ でもなんか&lt;em&gt;むなしい&lt;/em&gt;から、ペギオ版の修正、書き直しはもうやらない！

&lt;b&gt;[追記]&lt;/b&gt;本編に書いたこと：
&gt;&gt;
原文を引用してもどうせラチがあかないので、それはしませんでしたが、郡司さんのメチャクチャ解説のトピックである「余極限」を、もとの記号は保ったまま書き直す試みはしてみました。でも、こんなことやっても別に意味ありません。「まともな教科書か論文を読め」で済む話ですわ。あー、バカみたい。
&lt;&lt;
バカみたいです。&lt;b&gt;[/追記]&lt;/b&gt;

*1224584859*[圏一般論]カン拡張と指数と随伴

カン拡張って、僕よくわからんのだが、ともかく、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081021/1224579369&quot;&gt;トレーニング(?)&lt;/a&gt;に書いた次の同型を見ると、ある種の随伴の形ではある。

- Nat(Lan&lt;sub&gt;F&lt;/sub&gt;X, M) ≒ Nat(F, MX)

&lt;pre&gt;
 A -(X)→C
 ｜    ／
 F   ／M
 ↓／
 B
&lt;/pre&gt;

記法として、Lan&lt;sub&gt;F&lt;/sub&gt;XのFが添字になるのがどうもよろしくないが、Lan&lt;sub&gt;F&lt;/sub&gt;Xは「Xに沿ったFの拡張」、Xによる前送りになっているので、X&lt;sub&gt;*&lt;/sub&gt;(F)とか書いてもよいだろう。MX = X;F はXを前結合（precompose）しているので、Xによる引き戻しだから、X;F = X&lt;sup&gt;*&lt;/sup&gt;(F) だな。つまり：

- Nat(X&lt;sub&gt;*&lt;/sub&gt;(F), M) ≒ Nat(F, X&lt;sup&gt;*&lt;/sup&gt;(M))

両辺にNatが現れているが、これは指数圏のホムセットだから、明白に書けば：

- B&lt;sup&gt;C&lt;/sup&gt;(X&lt;sub&gt;*&lt;/sub&gt;(F), M) ≒ B&lt;sup&gt;A&lt;/sup&gt;(F, X&lt;sup&gt;*&lt;/sup&gt;(M))

つまり、

- X&lt;sub&gt;*&lt;/sub&gt;:B&lt;sup&gt;A&lt;/sup&gt;→B&lt;sup&gt;C&lt;/sup&gt;
- X&lt;sup&gt;*&lt;/sup&gt;:B&lt;sup&gt;C&lt;/sup&gt;→B&lt;sup&gt;A&lt;/sup&gt;

X&lt;sub&gt;*&lt;/sub&gt; -| X&lt;sup&gt;*&lt;/sup&gt;、ここで、X&lt;sup&gt;*&lt;/sup&gt;のほうがはるかにやさしいし、常に存在する。とうわけで、左カン拡張は、関手Xの前結合による「関手の引き戻し関手」の左随伴として特徴付けられる。となると、右カン拡張は、関手Xの後結合による「関手の前送り関手」の右随伴だろう。

2つの関手圏（圏の指数圏）の間の関手の随伴性だから、ちょっと分かりにくいが、もとの関手は前結合、後結合だから、まー、さほどのことではないか。


</body>
<comments>
<comment>
<username>JP</username>
<body>郡司氏の『原生計算と存在論的観測』の圏論の記述にもこのような誤植がないかどうか、東京大学出版会に問い合わせました。&lt;br&gt;&lt;br&gt;その際に、このエントリを東京大学出版会側にご紹介しました。現在、郡司さんにこの件についての連絡が行っていることを先ほど東京大学出版会からメールで確認しました。</body>
<timestamp>1226983134</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>JPさん、&lt;br&gt;わざわざありがとうございます。&lt;br&gt;&lt;br&gt;&gt; このような誤植がないかどうか、&lt;br&gt;うーん、写し間違いがあったにしても、「誤植」と言っていいかどうかはハナハダ疑問ですね。誤植なら、字句修正でなんとかなりますが、このエントリーの内容は字句修正でどうのこうのってレベルじゃないです。&lt;br&gt;『原生計算と存在論的観測』のほうは、僕はまったく見てないのでなんとも言えませんが。&lt;br&gt;&lt;br&gt;&gt; 郡司さんにこの件についての連絡が行っていることを先ほど東京大学出版会からメールで確認しました。&lt;br&gt;それは面白い。もし、今後なにかあれば、そして差し障りがなければ経緯を教えてください。</body>
<timestamp>1226986693</timestamp>
</comment>
</comments>
</day>
<day date="2008-10-22" title="">
<body>
*1224633239*[メモ][小咄][課題]T = T&lt;sup&gt;7&lt;/sup&gt;

T = T&lt;sup&gt;7&lt;/sup&gt; のパズルは面白い。解けてないけど。

- &lt;b&gt;A tree is the same as seven trees.&lt;/b&gt;

ナンセンス証明（nonsense proof）はできた。「ナンセンス証明が妥当である」というメタ定理があるけど、同型(bijection)を構成的・具体的に与えたい -- そうじゃないと面白くない。

*1224633420*[高次圏論]やせたωグラフ／マグマ、可逆マグマ

用語はフーティア流。Gがωグラフのとき、f, g∈G&lt;sup&gt;i&lt;/sup&gt;で、f, gが共端のとき、G&lt;sup&gt;i+1&lt;/sup&gt;(f, g)が高々1個しかセルを含まないとき、やせたωグラフと呼ぶ。1-グラフ＝1-骨格的な((「骨格的」（skeltal）は別な意味・用法もあるが、フーティアはある次元から上が自明なωグラフを骨格的と呼ぶ))ωグラフがやせていれば、有向単純ブラフとなる。

やせたマグマ（ωグラフ上のマグマ）は、プレ順序集合の高次版だろう。やせたマグマは、高次順序的構造や同値関係の定式化に使えそう。

可逆マグマは亜群の拡張となる。分類や同値関係の記述に使えるはず。可逆だから、対称性を持つ関係に対応する（と思う）。

やせた可逆マグマは、ほぼ等式的システムになりそう。

</body>
</day>
<day date="2008-10-23" title="">
<body>
*1224730961*[用語法]デンドロイド、デンドロイダル

dendroidが既に「樹状の」という形容詞だが、dendroidalって何よ？ これも「樹状」かな。

*1224731057*[人物][メモ]フーティアはアマチュアか？

フーティア（Carl A. Futia）はどこにも所属してないみたい。所属のあたりに自宅の住所を書いているし、メールもAOLだし。アマチュアかもしれない。

だとしたらリッパなもんだ。が、後が続くのか？と心配にもなる。


</body>
</day>
<day date="2008-10-27" title="">
<body>
*1225066455*[連絡的]主に配列

*** 課題の確認：

+ コマンドラインからの符号なし整数をビット表示
+ ファイルの16進ダンプ
+ asciiコマンド
+ 新規：画像ファイルを読んで、縦横“サイズ”&lt;em&gt;など&lt;/em&gt;を表示
+ ファイルの扱いやエラー処理の常識を自習

履歴はとっておけ！ バカな自分を振り返れば、進歩した自分に自信を持てる。

*** 定数とは：

&lt;pre&gt;
y = x + 5;
&lt;/pre&gt;
これをできるだけ低水準で解釈せよ。そのとき、5って何？

*** 用語：

- インストラクション
- オペコード
- オペランド

*** ポインタ算術：

- ポインタと生アドレスは違う
- ポインタ ± 整数
- ポインタ - ポインタ

*** 配列：

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

char a0[] = {'a', 'b', 'c', '\0'};
char a1[] = {'x', 'y', 'z', '\0'};
char[] a[] = {a0, a1};
// char* a[] = {a0, a1};

char *b[] = {&quot;abc&quot;, &quot;xyz&quot;};

char c[][4] = {{'a', 'b', 'c', '\0'}, {'x', 'y', 'z', '\0'}};

char d[][] = {{'a', 'b', 'c', '\0'}, {'x', 'y', 'z', '\0'}};

// オマケ xもa, b, cと同じにするには？
unsigned x0 = 0;
unsigned x1 = 0;
unsigned * x[] = {&amp;x0, &amp;x1};

main()
{
  int i;
  // a
  for (i = 0; i &lt; 2; i++) {
    printf(&quot;a[%d] : %s\n&quot;, i, a[i]);
  }
  // b
  for (i = 0; i &lt; 2; i++) {
    printf(&quot;b[%d] : %s\n&quot;, i, b[i]);
  }
  // c
  for (i = 0; i &lt; 2; i++) {
    printf(&quot;c[%d] : %s\n&quot;, i, c[i]);
  }
  // x
  for (i = 0; i &lt; 2; i++) {
    printf(&quot;x[%d] : %s\n&quot;, i, x[i]);
  }
}
&lt;/pre&gt;

*1225066786*[用語法][論理][課題]モデル論の図式

モデル論の「図式（ダイアグラム）」は意外な意味。

Aが言語Lのモデルのとき、Lの原子文または原子文の否定（Prologだとリテラルって呼んでいたかな？）で、Aで成立するものを全部集めたものをAの図式と呼ぶようだ（まだ自信がないが）。

いずれにしても、モデル論の用語をまとめる必要がある。

</body>
</day>
<day date="2008-10-28" title="">
<body>
*1225156967*[その他代数][圏一般論]Seven Treesの楽屋裏：Ring of high elements

Seven Treesのメタ定理において、半環から環を絞り出すことが重要なのだが、フィオレ（Fiore((例によって読み方は分からんが暫定カタカナ書き。&lt;b&gt;[追記]&lt;/b&gt;フィオールのほうがいいような気がしてきた。&lt;b&gt;[/追記]&lt;/b&gt;))、フィオール？）とレインスターは、ここで面白い議論をしている。簡単だが見たことがない論法。意外； なんで考えついたかわからんし、他の方法との関連も不明。

可換半群（単位元を要求しない）の圏（またはセオリー）内で考えるとして、高い元（high element）とクリーク（clique）を次のように定義する。以下、A = (A, *) は可換半群だとする。

- a, c∈A、a＜&lt;sub&gt;A&lt;/sub&gt;b :⇔ ∃c∈A.(a*c = b) （下付きAは適宜省略する）
- a∈A が高い :⇔ ∀x∈A.(x＜a)
- H(A) = {a∈A | aは高い}
- Aがクリーク :⇔ A = H(A)

関係＜は、Aに単位元がなければ反射的にならない。推移的ではある。

- 定理： Aがクリーク ⇔ Aはアーベル群

ここで注意すべきは、Aに単位元eがあっても、アーベル群としての単位元になるとは限らない点。この点をハッキリさせると：

- (A, *, e)が可換モノイドでクリークだとすると、z∈Aがあり、(A, *, z)にアーベル群の構造を与えることができる。

以上より、任意の可換半群Aに対して、H(A)にアーベル群構造を与えることができる。ただし、H(A)が空のケースもある。

以上の準備のもとで、Rが半環だとして、半環の加法だけを考えて（他は忘却）可換半群の圏にいったんは入れる。高い元の集合H(R)が空でないとして、適当なz∈H(R)を選んでアーベル群にできる。問題は掛け算で、もとの掛け算をH(R)上にうまく定義できるか？ &lt;del datetime=&quot;2008-10-28T15:53:56+09:00&quot;&gt;これは個別ケースで確認するしかないようだが、&lt;b&gt;N&lt;/b&gt;係数多項式半環のとある商半環のときはうまくいく。&lt;/del&gt;結局うまくいくので、高い多項式の環ができ上がる、というシナリオ。

&lt;b&gt;[追記]&lt;/b&gt;上の段落で消してあるところは僕の勘違い。(R, +, *, 0, 1)が半環だとして、半群(R, +)から作ったH(R, +)を単にHと書くことにして、(H, +, z)（zは通常0とは異なる）がアーベル群になるのだった。実は、掛け算単位1も別に準備して、(H, +, *, z, u)が環になる。u = 1 + z。

半環Rから、環Hを抜き出すというよりは、(R, +, *, 0, 1)と、H⊆R に対する (H, +, *, z, u)を一緒に考える感じ。同じ足し算／掛け算に関して、異なる加法単位／乗法単位で半環と環が同居しているのが面白い。単位を無視すれば部分半環なのだが、Hに制限し、かつ単位を変えているのでうまいこと逆元が生じている。うーん、これは思いつかないよなー、、、 僕が商を作るほうばかり見ているせいか？

それはそうと、どーでもいいが「クリーク」は「閉鎖的で小さい仲良しグループ」みたいな意味があるのね。H(R)は互いに移りあえるので確かにクリークな感じだ。しかも、メンバーはみんなハイソ(high)で、他人を（実は自分も）見下している（∀x. x＜a）から、かつてのヒルズ族みたいなもんだな、、、←まったく無意味な比喩。&lt;b&gt;[/追記]&lt;/b&gt;

このシナリオが一般的なのか限定的なのかわからない。ベクトル束の安定同値などを作る方法と似ているような気もするが、ハッキリしない。

*1225159393*[連絡的]配列

- 先入観、思いこみ、つまらない（事実とは異なる）推測は徹底的に捨てよう！
- 余計なことは考えない。ただひたすら、メモリ状況の（事実に即した）絵を描くのみ。

内部の状態（メモリレイアウト）と出力の意味を説明せよ。
&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

char a0[] = {'a', 'b', 'c', 'd', 'e', '\0'};
char a1[] = {'v', 'w', 'x', 'y', 'z', '\0'};
char* a[] = {a0, a1};

char *b[] = {&quot;abcde&quot;, &quot;uwxyz&quot;};

char c[][6] = {{'a', 'b', 'c', 'd', 'e', '\0'}, 
	       {'v', 'w', 'x', 'y', 'z', '\0'}};

char d[][6] = {'a', 'b', 'c', 'd', 'e', '\0', 
	       'v', 'w', 'x', 'y', 'z', '\0'};

char e[] = {'a', 'b', 'c', 'd', 'e', '\0', 
	    'v', 'w', 'x', 'y', 'z', '\0'};

// メモリブロックをダンプする関数
void dumpmem(unsigned char *p, unsigned size)
{
  static int hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		  'A', 'B', 'C', 'D', 'E', 'F'};

  unsigned char *bound;
  int u;
  for (bound = p + size; p &lt; bound; p++) {
    u = *p;
    putchar(hex[(u&amp;0xF0)&gt;&gt;4]); // 上位ニブル
    putchar(hex[u&amp;0x0F]); // 下位ニブル
    putchar(';'); // 1バイトの終わりを示す
  };
}

main()
{
  // a
  printf(&quot;a addr=%p size=%d\n&quot;, a, sizeof(a));
  dumpmem(a, sizeof(a)) ;
  // b
  printf(&quot;\n\nb addr=%p size=%d\n&quot;, b, sizeof(b));
  dumpmem(b, sizeof(b));
  // c
  printf(&quot;\n\nc addr=%p size=%d\n&quot;, c, sizeof(c));
  dumpmem(c, sizeof(c));
  // d
  printf(&quot;\n\nd addr=%p size=%d\n&quot;, d, sizeof(d));
  dumpmem(d, sizeof(d));
  // e
  printf(&quot;\n\ne addr=%p size=%d\n&quot;, e, sizeof(e));
  dumpmem(e, sizeof(e));
  putchar('\n');
}
&lt;/pre&gt;

どこがなぜコンパイルエラーするのか？ どうしたらコンパイラが通るか？ 動いたときの出力（表示）の意味は？
&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

int a[] = {1, 2, 3, 4};

main()
{
  printf(&quot;&amp;1 = %p\n&quot;, &amp;1);
  printf(&quot;a = %p\n&quot;, a);
  printf(&quot;&amp;a = %p\n&quot;, &amp;a);
  a++;
  printf(&quot;a = %p\n&quot;, a);
  a = 0;
  printf(&quot;a = %p\n&quot;, a);
}
&lt;/pre&gt;

*1225180576*[論理][課題][雑感]一日たつと忘れる

えーと、そうか、モデル論の初歩だけでもキッチリまとめようと昨日思ったのだった。

不等号みたいな記号（ラッパ状の＜）とか、Diagとか&lt;i&gt;L&lt;/i&gt;&lt;sub&gt;A&lt;/sub&gt;とか、何の説明もなしに使われているときがあるからな。初等同値、初等部分構造とか、ね。タイプ（type）って概念も特有で、混乱するな。

</body>
</day>
<day date="2008-10-29" title="">
<body>
*1225250202*[その他代数][用語法]とりあえず、代数的整数の出発点

+ 環の単数、単数群
+ 単数による同伴関係
+ 既約元 （↓）
+ 素元 （↓）

&lt;em&gt;整域の範囲で考える&lt;/em&gt;として、aが既約だとは、次の条件を満たすこと。

+ aは0でも単元でもない（0や単元に既約とかいってもしょうがない）
+ a = xy と因数に分解できたとき、xかyのどちらかは単数

「事実上、もうそれ以上分解できない」「分解できたとして、それは自明な分解に限る」ということ。

素元は少し定義が違って、pが素元だとは、任意のa, bに対して

+ pがabの約数なら、pはaの約数かbの約数になっている。

「pが素元⇒pは既約元」は成立。逆が成立しない。その反例は&lt;b&gt;Z&lt;/b&gt;[√-5]内の1+√-5。

イデアルによる定式化は：

+ aは単元⇔(a) = (1) = R イデアル的には1
+ aとbが同伴⇔(a) = (b) イデアル的に区別できない
+ aは既約元⇔「(a)=(x)(y) ならば、(a) = (x) または (a) = (y)」イデアル的に分解できない

単項イデアル整域（PID）では、「既約元は素元」。

Rが一意分解整域（UFD）とは：

+ 任意の元は既約元の積で書ける。
+ 分解は順序と同伴を除いて一意的

一意分解整域でも「既約元は素元」。

+ 数体＝代数体＝代数的数の体
+ 代数的整数：整係数&lt;em&gt;モニック&lt;/em&gt;多項式の根
+ 数体Kのなかで代数的整数になっているもの全体が、Kの整数環
+ &lt;b&gt;Q&lt;/b&gt;の整数環は&lt;b&gt;Z&lt;/b&gt;

aが平方数でない有理数として&lt;b&gt;Q&lt;/b&gt;(√a)が2次体。2次体は、適当な整数mで&lt;b&gt;Q&lt;/b&gt;(√m)と書ける。外の体が2次体である（代数的）整数が2次体の整数。ガウス整数環や&lt;b&gt;Z&lt;/b&gt;[√2]などは2次体の整数環。


</body>
</day>
<day date="2008-10-30" title="">
<body>
*1225349010*[その他代数][メモ][小咄][計算]計算メモだ

定数、変数はすべて&lt;b&gt;N&lt;/b&gt;上で考える。

- [k]&lt;sub&gt;n&lt;/sub&gt; = k if k＜n
- [k]&lt;sub&gt;n&lt;/sub&gt; = n if k≧n

参考：'&amp;#91;' #91 だよ。

+ [ [k]&lt;sub&gt;n&lt;/sub&gt;]&lt;sub&gt;n&lt;/sub&gt; = [k]&lt;sub&gt;n&lt;/sub&gt;
+ [a + b]&lt;sub&gt;n&lt;/sub&gt; = [b + a]&lt;sub&gt;n&lt;/sub&gt;
+ [ [a + b]&lt;sub&gt;n&lt;/sub&gt; + c]&lt;sub&gt;n&lt;/sub&gt; = [a + b + c]&lt;sub&gt;n&lt;/sub&gt;
+ [ [a]&lt;sub&gt;n&lt;/sub&gt; + [b]&lt;sub&gt;n&lt;/sub&gt;]&lt;sub&gt;n&lt;/sub&gt; = [a + b]&lt;sub&gt;n&lt;/sub&gt;
+ [a[b]&lt;sub&gt;n&lt;/sub&gt;]&lt;sub&gt;n&lt;/sub&gt; = [ab]&lt;sub&gt;n&lt;/sub&gt;

n∈&lt;b&gt;N&lt;/b&gt;を固定したうえで、
- a(+)b := [a + b]&lt;sub&gt;n&lt;/sub&gt;
- a(*)b := [ab]&lt;sub&gt;n&lt;/sub&gt;

適当な集合S⊆&lt;b&gt;N&lt;/b&gt;を取って、(S, (+), (*)) は、半環から0と1の存在を除いた公理を満たす。「半環から0と1の存在を除いた」代数系を、とりあえず&lt;strong&gt;分配代数&lt;/strong&gt;（distributive algebra）と呼んでおく。これは、distributive categoryと用語をそろえるため。

*1225349011*[その他代数][メモ][計算]これも計算メモだ

Seven Treesの背景。

Tが二分木の領域だとして、

- Z := {1 + (-1) =} 1 + T&lt;sup&gt;3&lt;/sup&gt;
- U := {1 + Z =} 2 + T&lt;sup&gt;3&lt;/sup&gt;
- N := {Z - 1 = (-1)} = T&lt;sub&gt;3&lt;/sub&gt;

と置く。波括弧内は、非形式的な心理的動機。

*** Z + Z = Z

展開予定を丸括弧、展開後を角括弧
&lt;pre&gt;
  Z + Z
 = 1 + (T^3) + 1 + T^3
// X^3 = T^2 + T^4 （3-展開公式）
 = 1 + [T^2 + T^4] + 1 + T^3
 = (1 + T^2) + T^4 + 1 + T^3
// 1 + T^2 = T （1-縮約公式）
 = [T] + T^4 + 1 + T^3
 = 1 + T + T^3 +  T^4
 = 1 + (T + T^3) +  T^4
// T + T^3 = T^2 （2-縮約公式）
 = 1 + [T^2] + T^4
 = 1 + (T^2 + T^4)
// T^2 + T^4 = T^3 (3-縮約公式）
 = 1 + T^3
&lt;/pre&gt;

*** T&lt;sup&gt;n&lt;/sup&gt; + Z = T&lt;sup&gt;n&lt;/sup&gt;

n = 1
&lt;pre&gt;
   T + (1 + T^3) 
 = T + 1 + T^2 + T^4
// 1 + T^2 = T （1-縮約）
 = T + T + T^4
// 下を参照
 = T

// 最後のステップの証明
  T 
 = 1 + T^2
// 2-展開
 = 1 + T + T^3
// 3-展開
 = 1 + T + T^2 + T^4
 = 1 + T^2 + T + T^4
// 1 + T^2 = T （1-縮約）
 = T + T + T^4
&lt;/pre&gt;

一般のn
&lt;pre&gt;
   T&lt;sup&gt;n&lt;/sup&gt; + (1 + T^3) 
// n-展開
 = T&lt;sup&gt;n-1&lt;/sup&gt; + T&lt;sup&gt;n+1&lt;/sup&gt; + (1 + T^3)
 = T&lt;sup&gt;n+1&lt;/sup&gt; + (T&lt;sup&gt;n-1&lt;/sup&gt; + (1 + T^3))
// 数学的帰納法の仮定
 = T&lt;sup&gt;n+1&lt;/sup&gt; + T&lt;sup&gt;n-1&lt;/sup&gt;
// n-縮約
 = T&lt;sup&gt;n&lt;/sup&gt; 
&lt;/pre&gt;

*** T&lt;sup&gt;n&lt;/sup&gt;Z = Z

n = 1
&lt;pre&gt;
   T(1 + T^3)
 = T + T^4
// 1-展開
 = 1 + T^2 + T^4
// 3-縮約
 = 1 + T^3
&lt;/pre&gt;

一般のn
&lt;pre&gt;
   T^n(1 + T^3)
 = T^n + T^(n+3)
// n-展開
 = T^(n-1) + T^(n+1) + T^(n+3)
// (n+2)-展開
 = T^(n-1) + T^(n+2)
 = T^(n-1)(1 + T^3)
// 数学的帰納法の仮定
 = 1 + T^3
&lt;/pre&gt;

*1225349514*[その他代数][用語法]高地と高地環

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081028/1225156967&quot;&gt;the set of high elements, the ring of high elements&lt;/a&gt; ってのもナンだから、高地（highland）と高地環（highland ring）でいいよね。high elementは高地に住む人に相当する。&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%81%E3%83%A5%E3%83%BB%E3%83%94%E3%83%81%E3%83%A5&quot;&gt;マチュピチュ&lt;/a&gt;とか？←意味不明。

*1225351011*[その他代数][用語法]用語が足りないなー

つうか、概念と用語が全然足りないよね（なんのこと？）&lt;br&gt;Seven Treesの背景の代数をいじっていたのだがね。

わかったことは：

+ 各ステップの計算は中学生レベル
+ 全体として難解な印象

これはなぜ？

+ 全然知らなかった代数系が登場する
+ 未経験な計算は慣れてないから難解に感じる
+ 既存知識と先入観が邪魔をする

まだ僕らが注目しなかった、あるいは定式化さえしなかった代数系がイッパイあって、特定応用ではそれらが役に立つ、そういう現象もあるのだな。

んで、まず「分配代数」だが、どう考えてもよい用語法じゃないが、しかたなかろう。半環の定義が、もともと0と1を入れてなかったらよかったんだが、言っても遅い。分配代数とは：

+ 二項演算+に関して可換半群（0は要求しない）
+ 二項演算・に関して半群（1は要求しない）
+ ・は+に対して両側から分配する

通常の半環の定義は「分配代数 ＋ 0の存在 ＋ 1の存在」。1の存在は仮定しないで、単位半環（unital semiring）とか呼ぶ流儀もあるが、0はたいてい仮定する。

分配代数の圏論版が分配圏（distributive category）：

+ 二項関手+に関して対称半群圏
+ 二項関手・に関して半群圏
+ ・は+に対して両側から分配する

等式は同型で考える。一貫性がいるだろうがよくわからん。半群圏（semigroupal category）は、モノイド圏から単位の存在を抜いたもの。半群の圏（category of semigroups）と混同しそう -- 半群的圏がいいのか？

まとめると、次の概念は必要なのだ。

+ 半群圏（semigroupal category）
+ 分配代数（distributive algebra）
+ 分配圏（distributive category）
+ 半環圏（semiringal category, rig category）

*1225356314*[圏一般論][その他代数][用語法]バーンサイド関手とバーンサイド系

忘れそうだからモシャモシャとメモしておく。&lt;b&gt;[追記]&lt;/b&gt;&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413921&quot;&gt;バーンサイド（Burnside）を形容詞に使うのはどうか？&lt;/a&gt;&lt;b&gt;[/追記]&lt;/b&gt;

&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;を圏のレルムだとする。つまり、&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;の対象は圏なので、U:&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;→&lt;b&gt;Cat&lt;/b&gt; という忘却関手を持つ。&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;は、圏のセオリーの拡張セオリーのモデル圏になっている。

&lt;i&gt;C&lt;/i&gt;を圏だとして、バーンサイド関手（Burnside functor）は、B:Eq(&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;)→&lt;i&gt;C&lt;/i&gt; という関手。圏に&lt;i&gt;C&lt;/i&gt;の対象を対応させるが、&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;の射（関手）に&lt;i&gt;C&lt;/i&gt;の対象を割り当てることは要求しない（できないことが多い）。Eqは、圏同値を射とする圏を作る操作である。Eq(&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;)は亜群となる。

バーンサイド関手が何であるかは後回しにして（いずれ書くつもり）、用語法だけメモしておく。B:Eq(&lt;b&gt;&lt;i&gt;R&lt;/i&gt;&lt;/b&gt;)→&lt;i&gt;C&lt;/i&gt; の値であるB(&lt;i&gt;A&lt;/i&gt;)∈|&lt;i&gt;C&lt;/i&gt;| を、圏&lt;i&gt;A&lt;/i&gt;のバーンサイド系、バーンサイド構造などと呼ぶ。値を取る圏&lt;i&gt;C&lt;/i&gt;によって適当なネーミングをする。

- &lt;i&gt;C&lt;/i&gt; = &lt;b&gt;Set&lt;/b&gt; なら バーンサイド集合
- &lt;i&gt;C&lt;/i&gt; = &lt;b&gt;Mon&lt;/b&gt; なら バーンサイド・モノイド
- &lt;i&gt;C&lt;/i&gt; = &lt;b&gt;Semigrp&lt;/b&gt; なら バーンサイド半群
- &lt;i&gt;C&lt;/i&gt; = &lt;b&gt;Rng&lt;/b&gt; なら バーンサイド環
- &lt;i&gt;C&lt;/i&gt; = &lt;b&gt;Semirng&lt;/b&gt; なら バーンサイド半環（or リグ）

バーンサイド系に構造を持たせるには、もとのレルムが対応する構造を持つ圏のレルム（対応する構造を定義するセオリーのモデル）でなくてはならない。例えば、バーンサイド・モノイドを定義するには、モノイド圏のレルムが必要になる。

</body>
</day>
<day date="2008-10-31" title="">
<body>
*1225413160*[高次圏論]n-同値

- 0-同値 集合の元のイコール
- 1-同値 圏の対象の同型
- 2-同値 2-圏の対象の同値（例：圏同値）

n-同値が定義できそうだが？

*1225413161*[圏一般論][用語法]骨格か本質か

骨格に関して次の用法は&lt;em&gt;確かに&lt;/em&gt;ある。

+ 圏Cの対象|C|を、同型で割った商集合を骨格と呼ぶ。
+ &lt;del datetime=&quot;2008-11-01T11:14:25+09:00&quot;&gt;射に対しても同型を定義すれば、骨格に圏の構造を与えられそうだ（これは要確認）&lt;/del&gt;。&lt;b&gt;ウソです。&lt;/b&gt;
+ 同型がイコールであるような圏は骨格的圏と呼ぶ。
+ 部分圏が骨格的なら骨格的部分圏と呼ぶ。ベクトル空間の圏で数空間の圏は骨格的部分圏。

1番目の意味を表すのに、「圏の本質」（essence）という言葉を見たことがあるのだが、一般的ではないのかもしれない。骨格を使っておくのが無難か。

*1225413561*[メモ][小咄][計算]計算メモ

http://d.hatena.ne.jp/m-hiyama-memo/20081030/1225349010 の計算は：

+ [a + [b] ] = [a + b]
+ [a[b] ] = [ab]

の２つから全部出る（下付きnは省略した）。

1番のaを0、または2番のaを1にすれば、[ [a] ] = [a]。1番のbに b + c を入れれば、[a + [b + c] ] = [a + b + c] となる。

*1225413921*[圏一般論][その他代数][用語法]また用語で困ったぞ、形容詞「バーンサイド」

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081030/1225356314&quot;&gt;昨日のエントリー&lt;/a&gt;で、バーンサイド（Burnside）を形容詞に使ったのだが、既に使用例がある。

- バーンサイド環：有限群Gが作用する有限集合の圏（直和と直積を考えて分配圏）の、グロタンディーク環（Grothendieck ring）。Gに対して定義されるので、「Gのバーンサイド環」という用法。
- バーンサイド関手：有限群Gの部分群Hに対して、Hのバーンサイド環を対応させると、順序構造を圏とみなして環の圏への&lt;del datetime=&quot;2008-10-31T15:34:02+09:00&quot;&gt;加群&lt;/del&gt;関手となる。これがバーンサイド関手。

いくつかの論点がある。

まず、バーンサイド環は圏に対して定義されているわけではないが、Gではなくて&lt;b&gt;FinSet&lt;/b&gt;&lt;sub&gt;G&lt;/sub&gt;を定義域とみなすと、圏→環 となる。もともとの状況でも、Gを動かして {&lt;b&gt;FinSet&lt;/b&gt;&lt;sub&gt;G&lt;/sub&gt; | Gは有限群} とすれば、レルム上でバーンサイド環関手が定義される。そのレルムが有限群でパラメトライズされる（インデックスされた圏）だけ。よって、とあるレルム上で定義され圏&lt;b&gt;Rng&lt;/b&gt;に値を取る関手とみることはまーいいだろう。

次に、バーンサイド環は、半環ではなくて環。グロタンディーク環やグロタンディーク群の構成では、半環、モノイドから環や群を作る。ところが、フィオール／レインスター（Fiore/Leinster）はグロタンディーク構成はしてない。単に同型類を取るだけ。

となると、本来の定義からどう一般化したか？ というと：

+ 有限群ではなくて、単なる圏に対してバーンサイド系が定義される。
+ バーンサイド系は環である必要はなくて、さまざまな圏の対象である。
+ 同型類を取るが、グロタンディークの構成（これも関手）はしない。

逆に、本来のバーンサイド環／バーンサイド関手は、次の手順で構成される。

+ 有限群Gから、圏やレルムを準備する
+ レルムに対して一般化バーンサイド関手を適用する。
+ 一般化バーンサイド関手の後に、グロタンディーク構成の関手を適用する。

と、書いてみると、一般化したというようりは、元のバーンサイド関手の一部だけを取り出して利用している感じだ。プレ・バーンサイド関手がいいかな。


</body>
</day>
<day date="2008-11-01" title="">
<body>
*1225518932*[圏一般論]十分な（adequate）部分圏

部分圏が充満（full）とか広大（broad）とかいう概念があるが、十分な（adequate）部分圏という概念も必要だ。

D⊆C  が十分とは、任意の(f:X→Y)∈Cに対して、Cの同型i:X→X', j:Y→Y'とDの射 f':X'→Y' があって、f = i;f';j と書けること。

Dが十分なら、Cのどんな射でもD内で適切に表現できる。例は、ベクトル空間の圏で、数空間から生成される充満部分圏、集合圏で基数の類から生成される充満部分圏など。

*1225518933*[圏一般論][論理][計算]T = T^2 ですべてがつぶれる

「『二分木領域＝T』の多項式で生成される圏」という状況は後で正確に説明する（たぶん）。その圏の無限領域だけを集めた圏を&lt;b&gt;B&lt;/b&gt;とする。&lt;b&gt;B&lt;/b&gt;のバーンサイド環（結局は環になる）がつぶれるかどうか、という問題。

「1 = 0」が成立するとつぶれる。「-1 = 0」でも同じくつぶれるから、N = Z 、つまり、T&lt;sup&gt;3&lt;/sup&gt; = 1 + T&lt;sup&gt;3&lt;/sup&gt; が成立するかどうかが問題になる。T&lt;sup&gt;3&lt;/sup&gt; = 1 + T&lt;sup&gt;3&lt;/sup&gt; を仮定すると、
&lt;pre&gt;
  T^3 = 1 + T^3
 -------------------------[両辺にTを足す]
  T + T^3 = T + (1 + T^3)
 -------------------------[左辺に2-縮約]
  T^2 = T + (1 + T^3)
 -------------------------[Z = 1 + T^3 の性質]
  T^2 = T
&lt;/pre&gt;
となり、T = T^2 が出る。よって、T = T^2 を否定できれば、  T^3 = 1 + T^3 を否定でき、バーンサイド環の崩壊を防げる。

一般に、x = 1 + x^2 と x = x^2 が矛盾するわけではない。x = ω = 加算基数とすると、これは成立する。いま x = 1 + x^2 だけを仮定した整係数多項式のセオリーを Th(x = 1 + x^2) とする。もし、

- Th(x = 1 + x^2) |- x = x^2

だったら、Th(x = 1 + x^2) の任意のモデルMで M |= x = x^2 だが、これはそうじゃないモデルを作って否定できるので、Th(x = 1 + x^2) |- x = x^2 でないことは分かる。

さて、圏&lt;b&gt;B&lt;/b&gt;の射とは、実は構文的に定義されたもので、Th(x = 1 + x^2)に対応する圏論的セオリー CatTh(X ～ I + X^2) の自由圏、つまりモデル圏（レルム）の始対象（である圏）として構成されている。圏&lt;b&gt;B&lt;/b&gt;内で、T ～ T^2 を与える射が存在しないとは、CatTh(X ～ I + X^2) の自由圏に対応する射がないことである。

そこで、自由圏にT ～ T^2 を与える射が存在したとして矛盾を導くことになる。ここは、ちゃんと追ってないのだが、仮定を満たす射が存在すると自由圏（始対象）でなくなることを、実際に2つ以上の射を構成して示すのだろうと思う。

ここがうまくいけば、「自由性と矛盾するからそのような射はない」と言える。議論をさかのぼって、T = T^2 は否定される。T ≠ T^2 が確実に言えれば、かなりの数の非存在命題が出てくる。1＜k＜7 に対する T = T^k の否定も言えるだろと思う。

だが、以上のシナリオは、圏論的モデル論にヘビーに頼った方法で、大げさすぎないか？ 計算量の評価とかで出来るんじゃないのか？

それはそうとして、T = T^2 を仮定すると、直積ベキはすべてつぶれて、多項式が nI + mT の形になるが、1 + T^2 = 1 + T = T を使うと、定数でない多項式はTだけになる。

まず、1 + T = T を繰り返し使えば、n + T = T となる。一方、1 + T = T の両辺にTを掛けて T + T^2 = T^2、これから T + T = 2T = T。これらを繰り返し使えば、nI + mT = T が言える。これは矛盾でもなんでもない。T = ω では実際に起きる現象。

*1225531626*[圏一般論][説明][具体例]二分木の多項式の圏と、その部分圏のバーンサイド環

[http://d.hatena.ne.jp/m-hiyama-memo/20081101/1225518933:title]
&gt;&gt;
「『二分木領域＝T』の多項式で生成される圏」という状況は後で正確に説明する（たぶん）。
&lt;&lt;

Tを二分木の領域として、「Tの多項式で生成される圏」という概念、これは正確にはどういうことだろうか。

まず、対象は、1（単元集合）とTから直和と直積を自由に、ただし有限回適用してできる集合を全部集めたもの。1×X ～ X とか X×Y ～ Y×X とかの同一視をしておくと、少し小さくなるが、たいした問題ではない。（～は同型）

e:1→T（単ノード木をpointする）、c:T&lt;sup&gt;2&lt;/sup&gt;→T（consまたはcompose）、d:1+T&lt;sup&gt;2&lt;/sup&gt;→T（[e, c]:1 + T&lt;sup&gt;2&lt;/sup&gt;→T の逆）を固有な（非自明な）斜として指定する。では、自明な射がどのくらいあるかというと：

+ 恒等射
+ 直積の射影
+ 直和の入射
+ 直積結合律の構造射 アソシエータ（associators）
+ 直積単位律の構造射 ユニッタ（unitors）（なくてもいい）
+ 直積可換律の構造射 対称
+ 直和結合律の構造射
+ 直和単位律の構造射（なくてもいい）
+ 直和可換律の構造射

それらから生成するときの組み立て方は：

+ 結合
+ デカルト対 &amp;lt;f, g&gt; による構成
+ 余デカルト対 [f, g] による構成

こうして作った圏はデカルトかつ余デカルトになるが、&lt;em&gt;デカルト性は実は本質ではないし、必要でもない。&lt;/em&gt;必要な性質は分配圏であることだ。

構成した分配圏のなかで、無限領域だけを選んで対象類とする。この無限領域の類から誘導された充満部分圏（誘導部分圏）が問題の圏。この圏をBとすると、Bは親の圏の足し算と掛け算を受け継いで（継承演算、誘導構造により）、再び分配圏となる。ここで、同型同値類を取るだけのバーンサイド型関手（骨格関手）を適用して、Bのバーンサイド分配代数を作る。Bのバーンサイド分配代数が計算の舞台となる。

ポイントは、有限領域をすべて捨ててしまうことである。0も1も捨ててしまう。これにより、部分分配圏は一旦は零と単位を失う。が、バーンサイド代数でも零と単位を失うとは限らないのだ。これが盲点というか、ものすごく気付きにくいところだ。0や1はバーンサイド代数の零や単位ではなくて、&lt;em&gt;あくまでも代表元&lt;/em&gt;だったので、他の代表元を取り直せる可能性はある。バーンサイド代数でも零、単位が消えたと思ったのは錯覚だったわけだ、目がくらんでいた、痛恨！

さーて、それとは別に、分配代数や環の計算と推論を行う形式的演繹系を準備して、Bのバーンサイド分配代数（結局は環）をモデルとしたモデル論を作る。このモデル論と、τを1の原始6乗根として&lt;b&gt;Z&lt;/b&gt;[τ]で定義される環とのモデル論を比較する。バーンサイド分配代数は実は可換環となり、&lt;b&gt;Z&lt;/b&gt;[τ]と計算と演繹に関しては区別できない。どの程度区別できないかが問題なのだが。

*1225531733*[計算]T = T^2 ですべてがつぶれる の補足

&lt;pre&gt;
  T = T^2
// 右辺を2-展開
  T = T + T^3
// 左辺を T → 1 + T + T^3
  1 + T + T^3 = T + T^3
// 両辺からTを消去（移項を使う）
  1 + T^3 = T^3
&lt;/pre&gt;

よって、T = T^2 ⇒ Z = N が出る。Z ≠ N（0 ≠ (-1)）を示したいなら、T ≠ T^2 を示せ。

1 = (-1) だとすると、U = N、したがって 2 + T^3 = T^3、これは 1 + T = T^2 から出る。
&lt;pre&gt;
 1 + T = T^2
// 右辺を2-展開
 1 + T = T + T^3
// 左辺にZを足す
 1 + T + 1 + T^3 = T + T^3
// 両辺からTを消去
 1 + 1 + T^3 = T^3
 2 + T^3 = T^3
&lt;/pre&gt;

よって、1 + T ≠ T^2 を示したい

他に、1 + 1 + ... + 1 = 0 が成立するかどうかを確かめないといけない。U + U + ... + U = Z。2の場合だと、U + U = Z、つまり、2 + T^3 + 2 + T^3 = 1 + T^3、うーん、すぐさまは分からない。

*1225532598*[圏一般論][その他代数][用語法]バーンサイド＝骨格＝脱圏化

ここ2,3日考えたことはすべて関連する。

- [http://d.hatena.ne.jp/m-hiyama-memo/20081028/1225156967:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20081029/1225250202:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20081030/1225356314:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413921:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413161:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413160:title]

って、関連することを考えていたんだから&lt;em&gt;当たり前&lt;/em&gt;だけど。

まず、有限群とか表現論とかで出てくる「本物の」バーンサイド環、バーンサイド関手のアイディアを借用して、バーンサイド型関手（Burnside-type functor）を定義できる。そのもっとも素朴なバージョンは、圏の骨格関手となる。Skel:&lt;b&gt;Cat&lt;/b&gt;→&lt;b&gt;Set&lt;/b&gt; がバーンサイド型関手の例。

Skel(C) = |C|/～ と定義できるが、ここで～は同型関係。n-同値の概念が適切に定義できれば、n-圏Cに対して、S&lt;sup&gt;k&lt;/sup&gt; := C&lt;sup&gt;k&lt;/sup&gt;/～&lt;sup&gt;k+1&lt;/sup&gt; として高次骨格（higher skelton）が定義できるだろう。高次骨格関手は、n-&lt;b&gt;Cat&lt;/b&gt;→(n-1)-&lt;b&gt;Cat&lt;/b&gt; と、「n-圏の圏」から「(n-1)圏の圏」への関手だが、ω-&lt;b&gt;Cat&lt;/b&gt;→ω-&lt;b&gt;Cat&lt;/b&gt; だとさらに具合がいい、できるか？

まーとりあずは、一般的な高次骨格関手と、演算（オペレーション）を持つ圏（半群圏、モノイド圏、分配圏、半環圏、トレース付き圏、対称圏、ブレイド付き圏など）の骨格関手を考えるのがよさそう。

用語法だが： 僕は、形容詞「バーンサイド」を使うのがちょっと抵抗があったので、「骨格」を使うことにしよう。多くの場合、バーンサイド＝骨格だし、骨格関手に他の関手（グロタンディーク構成など）を後結合してバーンサイド型関手を作ることもある。要するに、「骨格」をメインに使って、必要に応じて「バーンサイド」を付記する、ということ。

気になるのは、フーティア（Carl A. Futia）の用語法との整合性だ。フーティアの「骨格的」（skeltal）と区別するために、本質（essence）を使おうと思ったのだが、なんとか無理矢理に整合させることはできそう、要確認。ちなみに、フーティアは、(k+1)-セルがすべて自明になる（したがって、それ以上の次元もすべて自明）なωグラフをk-骨格的と呼んでいる→[http://d.hatena.ne.jp/m-hiyama-memo/20081022/1224633420:title]。

もうひとつ、複体の幾何だと、複体Kの次元k以下の部分をk-骨格と呼ぶ。この用語法との整合は根本的に無理だな。この用語法を採用すると、圏Cの0-骨格が|C|、1-骨格がCそのものになる。骨格関手の概念とまったく整合しない。複体やn-圏に対して、次元k以下の部分を別な呼び名にするしかない、ウーン、いい呼び名は難しいな。

ところで、フーティアは複体の骨格概念とのアナロジーで骨格的と呼んでいる気がする。つまり、Cと「Cの複体的k-骨格」が一致するときにCはk-骨格的としているようだ。だから本来は、フーティアの骨格概念は、同値による商構造ではない。フーティア流だと、コントラクション（縮約）が骨格関手に近いかもしれない。

ウーム、あちらを立てればこちらが立たず。ひょうとすると、「k-本質」を使うことになったりして、、、、

最後に、骨格関手は脱圏化（decategorification）を与えることを注意しておく。


</body>
</day>
<day date="2008-11-04" title="">
<body>
*1225757093*[圏一般論][用語法]ガーン！ distributor

associator, unitorはけっこういい用語法だと思っていた。これに合わせると、分配法則を記述する構造同型射（structure isomorphism）をdistributorと呼べばいいのだ、ぬあんと、プロ関手（副関手、profunctor）を、&lt;strong&gt;distributor&lt;/strong&gt;とも呼ぶのであった。

そもそも、オーストラリアの人はプロ関手を加群（module）とか双加群（bimodule）とか呼ぶし、、、ムーッ。

*1225757094*[圏一般論]圏の骨格は圏にならないが、グラフにはなること

[http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413161:title]
&gt;&gt;
射に対しても同型を定義すれば、骨格に圏の構造を与えられそうだ（これは要確認）。
&lt;&lt;

これは&lt;b&gt;ウソ&lt;/b&gt;だが、骨格はグラフ構造を持つ。以下に述べる。

記号≡と～を使い分ける。idを対象と同じ記号で略記することあり。

- X≡Y :⇔ ∃f:X→Y, g:Y→X.(f;g = X, g;f = Y)
- (f:X→Y)～(f':X'→Y') :⇔ ∃i:X→X', j:Y→Y'(i, jはiso, i;f';j = f)

+ f～f' ⇒ dom(f)≡dom(f')
+ f～f' ⇒ cod(f)≡cod(f')
+ X～X' ⇒ id&lt;sub&gt;X&lt;/sub&gt;～id&lt;sub&gt;X'&lt;/sub&gt;

(f:X→Y)～(f':X'→Y') なら、isoなi:X→X', j:Y→Y'があるのだから、X≡X' かつ Y≡Y'。

X～X'を与えるisoを i:X→X'、その逆をj:X'→X とすると、id&lt;sub&gt;X&lt;/sub&gt; = i;j = i;id&lt;sub&gt;X'&lt;/sub&gt;;j、よって id&lt;sub&gt;X&lt;/sub&gt; = i;j = i;id&lt;sub&gt;X'&lt;/sub&gt;。

一般的には結合をうまく定義する方法がない。しかし、グラフにはなる。このグラフはいったい何だろう？ 正体が分からない？？ ちょっと不気味な存在。

*1225758241*[圏一般論][高次圏論]n-法則 （まだワカラン）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413160&quot;&gt;n-同値&lt;/a&gt;の続きの話。

可換性や結合性などの性質は、等式を使った法則として表現される。等式は0-同値による関係式だから、0-法則と呼ぶ。1-同値＝同型による法則は1-法則と呼んでいいだろう。1-法則の実体は同型射なので、可逆な1-セルとなる。1-法則を与える1-セルのあいだには、通常、一貫性（メタ法則）が成立している。一貫性は1法則の組み合わせのあいだの0-法則で与えられる。

| 法則セルの次元| 同値の種類  | メタの階数 |
| 1             | 同型        | 0 対象レベル |
| 2             | 同一        | 1 メタレベル |

これから類推すると、2-法則は次のようなものだろう。見当違いかもしれないが。

| 法則セルの次元  |同値の種類 | メタの階数 |
| 2               | 同値      | 0 対象レベル |
| 3               | 同型      | 1 メタレベル |
| 4               | 同一      | 2 メタメタレベル |

例えば、&lt;b&gt;Cat&lt;/b&gt;における演算◎の可換律の2-法則は、

- A◎B ≡ B◎A

の形で、実体は圏同値、つまり、関手F:A◎B→B◎A, G:B◎A→A◎B と自然同型α::F;G⇒I, β::G;F→I。αとβに関する関係式は3セルで与えられる。で、その先がわからん。定式化がミスっている可能性もある。

*1225759979*[圏一般論][用語法]本質的に…

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081031/1225413161&quot;&gt;「圏の骨格」はある程度は使われている用語。&lt;/a&gt;「圏の本質」は定かではない。だが、圏が「本質的に小さい」（essentially small; &lt;em&gt;綴り字注意&lt;/em&gt;）は使われる。その定義は、&lt;em&gt;小さい圏と圏同値になる&lt;/em&gt;ことである。

局所小で骨格も小さい圏Cは、骨格集合Skel(C)からのセクション s: Skel(C)→|C| があれば、sの象から充満部分圏（誘導部分圏）を作ってやれば、本質的に小さいような気がするが、どうかな？

骨格のセクションから誘導された部分圏は骨格的部分圏でかつ&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081101/1225518932&quot;&gt;十分な部分圏&lt;/a&gt;。骨格的な十分部分圏はもとの圏と圏同値になるだろうが、猛烈に強い選択公理が必要そうだな。

*1225760891*[圏一般論][用語法][その他代数]合同とは

Rがなんらかの代数構造で、代数構造を保存する同値関係を合同（congruence）と呼ぶ。これは曖昧すぎるが、個々のケースでは厳密な定義ができる。たとえば、モノイド上の合同は：

+ ～は同値関係
+ a～a'、bからb' ならば ab～a'b'

～がM上の合同なら、商M/～を再びモノイドになる。圏論的にいえば、具象圏があって、台集合の～による商が再び圏の対象とみなすことができれば、～は合同ってことだろう。

合同は同値関係なので、対角を含む集合として外延化できる。外延の大小により、合同の大小も定義できる。小さいほど弱く、大きいほど強いと表現して強弱を考えることができる。通常、強い（強すぎる）合同は興味の対象にはならず、できるだけ弱い合同を求めることが問題になる。

合同を計算する一般的な手段は項書き換え系である。うまく項書き換え系を作れば、合同をアルゴリズム的に判断できるようになる。が、一般的には、合同を判定するアルゴリズムがあるとは限らないし、あっても発見は難しい。

多項式のイデアル論は、合同の定義と判定がうまくいった典型例だろう。合同の理論的な側面はイデアルの抽象的一般論でうまく展開できて、具体的なアルゴリズムはグレブナー基底で計算可能。

*1225761413*[圏一般論][メモ][小咄]スパンの圏の別な定式化

これは気付かなかった -- コロンブスの卵。

圏Cの骨格を[C]と書くことにする。[C]はとりあえずは単なる集合。

Eを有限極限を持つ圏で、選択された直積×を持つとする。A, B∈|E|に対して、A×Bは決まる。スライス圏E/(A×B)も定義できる。骨格 [E/(A×B)] が、スパンの圏Span&lt;sub&gt;E&lt;/sub&gt;のホムセットを与える。ちょっと考えればアタリマエ。だがこれは面白い。

*1225762449*[その他代数][メモ][小咄]半環の融合和で悪くなる

半環Rに&lt;b&gt;N&lt;/b&gt;が作用しているとき、融合和（amalgamated sum）が定義できる。半直和という感じの構成だ。

(R, +, ・, z, u)が半環（zは零、uは単位）とする。x∈Rに対して、

- 0△x = x
- n△x = u + .. + u + x（uがn個）
- 0*x = z
- n*x = x + ... + x（xがn個）

として作用△:&lt;b&gt;N&lt;/b&gt;×R→R、 *:&lt;b&gt;N&lt;/b&gt;×R→R を定義する。要するに、&lt;b&gt;N&lt;/b&gt;をRに自然に入れて（埋め込みとは限らないが）、自然に演算を拡張したもの。

直和集合 &lt;b&gt;N&lt;/b&gt; + R には、場合分けにより足し算と掛け算が入り再び半環となる。これを融合和と呼ぶことにする。融合和はたいして有用とは言えないが、いくつかの注目すべき点がある。

+ Rの零と単位は、零と単位ではなくなる。
+ Rが環であっても、融合和は環でない。

気分的な表現をすると、融合和により、性質が悪くなるのだ。融合和により悪くなった半環から、&lt;b&gt;N&lt;/b&gt;を切り落として、もとのRだけを抽出すれば、よい性質の代数系（環とか）を再現することができる。データ構造のバーンサイド分配代数から、有限集合を取り除くのは、この抽出過程にあたる。

*1225788992*[Erlang][メモ]spec指定属性

kernel/file.erl に -spec が使われている。

</body>
</day>
<day date="2008-11-05" title="">
<body>
*1225842677*[Erlang][メモ法]悔やまれる

一時、Erlangのアプリケーションコントローラ（appplicationモジュール）とか、アプリケーションスタータとかの関係を理解したのに、今はわからない。クッソー、メモしておかなかったからだ。

*1225844138*[Erlang][メモ]spec指定属性の実際

R12B-4 (erl5.6.4) のlib：次のソースで -spec(...). が使われている。意外にもEDocでも使っている。
&lt;pre&gt;
compiler-4.5.4/src/beam_disasm.erl
compiler-4.5.4/src/core_parse.erl
compiler-4.5.4/src/erl_bifs.erl
cosNotification-1.1.7/src/cosNotification_Grammar.erl
dialyzer-1.8.2/src/dialyzer.erl
dialyzer-1.8.2/src/dialyzer_analysis_callgraph.erl
dialyzer-1.8.2/src/dialyzer_callgraph.erl
dialyzer-1.8.2/src/dialyzer_cl.erl
dialyzer-1.8.2/src/dialyzer_cl_parse.erl
dialyzer-1.8.2/src/dialyzer_codeserver.erl
dialyzer-1.8.2/src/dialyzer_contracts.erl
dialyzer-1.8.2/src/dialyzer_dataflow.erl
dialyzer-1.8.2/src/dialyzer_dep.erl
dialyzer-1.8.2/src/dialyzer_gui.erl
dialyzer-1.8.2/src/dialyzer_options.erl
dialyzer-1.8.2/src/dialyzer_plt.erl
dialyzer-1.8.2/src/dialyzer_succ_typings.erl
dialyzer-1.8.2/src/dialyzer_typesig.erl
dialyzer-1.8.2/src/dialyzer_utils.erl
edoc-0.7.6/src/edoc_parser.erl
edoc-0.7.6/src/edoc_run.erl
edoc-0.7.6/src/edoc_wiki.erl
edoc-0.7.6/src.orig/edoc_parser.erl
edoc-0.7.6/src.orig/edoc_run.erl
edoc-0.7.6/src.orig/edoc_wiki.erl
hipe-3.6.8/cerl/erl_bif_types.erl
hipe-3.6.8/flow/cfg.inc
hipe-3.6.8/flow/ebb.inc
hipe-3.6.8/flow/hipe_bb.erl
hipe-3.6.8/flow/hipe_dominators.erl
hipe-3.6.8/flow/liveness.inc
hipe-3.6.8/icode/hipe_beam_to_icode.erl
hipe-3.6.8/icode/hipe_icode.erl
hipe-3.6.8/icode/hipe_icode_bincomp.erl
hipe-3.6.8/icode/hipe_icode_callgraph.erl
hipe-3.6.8/icode/hipe_icode_cfg.erl
hipe-3.6.8/icode/hipe_icode_coordinator.erl
hipe-3.6.8/icode/hipe_icode_exceptions.erl
hipe-3.6.8/icode/hipe_icode_fp.erl
hipe-3.6.8/icode/hipe_icode_heap_test.erl
hipe-3.6.8/icode/hipe_icode_inline_bifs.erl
hipe-3.6.8/icode/hipe_icode_instruction_counter.erl
hipe-3.6.8/icode/hipe_icode_mulret.erl
hipe-3.6.8/icode/hipe_icode_pp.erl
hipe-3.6.8/icode/hipe_icode_primops.erl
hipe-3.6.8/icode/hipe_icode_range.erl
hipe-3.6.8/icode/hipe_icode_split_arith.erl
hipe-3.6.8/icode/hipe_icode_ssa.erl
hipe-3.6.8/icode/hipe_icode_ssa_struct_reuse.erl
hipe-3.6.8/icode/hipe_icode_type.erl
hipe-3.6.8/main/hipe.erl
hipe-3.6.8/main/hipe_main.erl
hipe-3.6.8/misc/hipe_consttab.erl
hipe-3.6.8/misc/hipe_gensym.erl
hipe-3.6.8/rtl/hipe_rtl_arch.erl
hipe-3.6.8/util/hipe_digraph.erl
hipe-3.6.8/util/hipe_dot.erl
hipe-3.6.8/util/hipe_timing.erl
kernel-2.12.4/src/application.erl
kernel-2.12.4/src/auth.erl
kernel-2.12.4/src/disk_log.erl
kernel-2.12.4/src/disk_log_1.erl
kernel-2.12.4/src/disk_log_server.erl
kernel-2.12.4/src/dist_util.erl
kernel-2.12.4/src/erl_boot_server.erl
kernel-2.12.4/src/erl_ddll.erl
kernel-2.12.4/src/erl_prim_loader.erl
kernel-2.12.4/src/error_handler.erl
kernel-2.12.4/src/error_logger.erl
kernel-2.12.4/src/file.erl
kernel-2.12.4/src/global_search.erl
kernel-2.12.4/src/heart.erl
kernel-2.12.4/src/hipe_unified_loader.erl
kernel-2.12.4/src/inet.erl
kernel-2.12.4/src/net_adm.erl
kernel-2.12.4/src/os.erl
kernel-2.12.4/src/packages.erl
kernel-2.12.4/src/rpc.erl
kernel-2.12.4/src/zlib.erl
megaco-3.8.1/src/text/megaco_text_mini_parser.erl
megaco-3.8.1/src/text/megaco_text_parser_prev3a.erl
megaco-3.8.1/src/text/megaco_text_parser_prev3b.erl
megaco-3.8.1/src/text/megaco_text_parser_prev3c.erl
megaco-3.8.1/src/text/megaco_text_parser_v1.erl
megaco-3.8.1/src/text/megaco_text_parser_v2.erl
megaco-3.8.1/src/text/megaco_text_parser_v3.erl
mnesia-4.4.5/src/mnesia.erl
mnesia-4.4.5/src/mnesia_lib.erl
os_mon-2.1.7/src/cpu_sup.erl
parsetools-1.4.5/include/yeccpre.hrl
parsetools-1.4.5/src/yeccparser.erl
percept-0.7.2/src/egd.erl
percept-0.7.2/src/percept.erl
percept-0.7.2/src/percept_db.erl
percept-0.7.2/src/percept_html.erl
runtime_tools-1.7.2/src/percept_profile.erl
snmp-4.11.1/src/compiler/snmpc_mib_gram.erl
stdlib-1.15.4/doc/html/notes.html
stdlib-1.15.4/src/array.erl
stdlib-1.15.4/src/beam_lib.erl
stdlib-1.15.4/src/erl_compile.erl
stdlib-1.15.4/src/erl_lint.erl
stdlib-1.15.4/src/erl_parse.erl
stdlib-1.15.4/src/erl_parse.yrl
stdlib-1.15.4/src/file_sorter.erl
stdlib-1.15.4/src/gb_trees.erl
stdlib-1.15.4/src/gen_event.erl
stdlib-1.15.4/src/gen_fsm.erl
stdlib-1.15.4/src/gen_server.erl
stdlib-1.15.4/src/lists.erl
stdlib-1.15.4/src/qlc.erl
stdlib-1.15.4/src/string.erl
tools-2.6.2/src/xref_parser.erl
xmerl-1.1.10/src/xmerl_b64Bin.erl
xmerl-1.1.10/src/xmerl_xpath_parse.erl
&lt;/pre&gt;


</body>
</day>
<day date="2008-11-06" title="">
<body>
*1225961657*[Erlang][メモ]興味深い関数

+ code:clash/0
+ statistics/1
+ erlang:system_info/1
+ erlang:iolist_size/1
+ erlang:iolist_to_binary/1
+ erlang:port_command(Port, Command)
+ erlang:bump_reductions/1
+ erlang:garbage_collect/0
+ erlang:open_port/2
+ erlang:port_close(Port)
+ erlang:get_stacktrace/0
+ erlang:is_process_alive(P)
+ erlang:process_info/1, /2


</body>
</day>
<day date="2008-11-07" title="">
<body>
*1226040006*[Erlang][記録]Cygwin環境下でYAWSをインストール

ネタもと： http://yaws.hyber.org/wiki/showPage.yaws?node=YawsAndCygwin 

- src/Makefile内の yaws_generated.erl に注目。
- 同、regenターゲットにも注目。
- ん？ EBIN_FILES=$(MODULES:%=../ebin/%.$(EMULATOR)) ../ebin/yaws.app このパーセントの使い方は？
- SSLに関しては未調査。

*1226044925*[Erlang][メモ]それと、アプリケーションに関して

アプリケーション・マスターって概念もあったな。

グループリーダーってのはプロセスの概念だが、関係あったっけ？

</body>
</day>
<day date="2008-11-11" title="">
<body>
*1226366987*[Erlang][メモ]EDocのtype定義

@type の左辺は関数呼び出し形式、総称の型パラメータを入れてよい。

&lt;pre class=&quot;code&quot;&gt;
@type pair(X, Y) = {X, Y}
&lt;/pre&gt;

別名や一部束縛は次のようにする。

&lt;pre class=&quot;code&quot;&gt;
@type tuple_2(X, Y) = pair(X, Y)
@type tuple_2_atom(Y) = tuple_2(atom(), Y)
&lt;/pre&gt;

レコード型の型定義は次のようにする。

&lt;pre class=&quot;code&quot;&gt;
@type person() = #person {
 nickname = atom(),
 real_name = string(),
 age = integer()
}
&lt;/pre&gt;

レコード型の直接指定は #person{}。中括弧を忘れないこと！

次のようにタプル成分（element, リストはmember）にラベルを付けられる。
&lt;pre class=&quot;code&quot;&gt;
@type person() = {Nickname::atom(), RealName::string()}
&lt;/pre&gt;

&lt;h5&gt;注意すべきこと、いろいろ&lt;/h5&gt;

右辺に大文字から始まる名前を使った「型のマクロ定義」はできない。@specのwhere節とは違う。

cons(,)と[]が使える。このとき、リストのメンバーにもラベルが付けられる。

Erlangの型システムとは違い、string() や none()  型が使えることに注意。

@specで書いた引数名はデフォルト（関数定義の名前）を上書きする。

次の例では、引数名Nameはなくなる。

&lt;pre class=&quot;code&quot;&gt;
% @spec (N) -&gt; none()
% where N = string()
foo(Name) -&gt; ok.
&lt;/pre&gt;

次は上書きされる（引数名がNamになる）。

&lt;pre class=&quot;code&quot;&gt;
% @spec (Nam:N) -&gt; none()
% where N = string()
foo(Name) -&gt; ok.
&lt;/pre&gt;

*1226367207*[Erlang][JavaScript][用語法]ErlangとJSONとJavaScript

|＼     |* Erlang          |* JSON |* JavaScript |
|リストの成分 |メンバー    | 要素 | 要素 |
|マップの成分 |要素    | メンバー | プロパティ |

*1226376770*[Erlang][メモ][気付いた]EDocエライ

behaviour定義があると、勝手にメッセージを生成してくれる。
&gt;&gt;
This module defines the serialize_json behaviour.
Required callback functions: special_value/3, integer_value/3, real_value/3, string_value/3, start_array/2, end_array/2, start_object/2, key/3, end_object/2.
&lt;&lt;

*1226389906*[Erlang][メモ]見つかった！

stdlib/erl_posix_msg.erl :
&lt;pre&gt;
message(e2big) -&gt; &quot;argument list too long&quot;;
message(eacces) -&gt; &quot;permission denied&quot;;
message(eaddrinuse) -&gt; &quot;address already in use&quot;;
message(eaddrnotavail) -&gt; &quot;can't assign requested address&quot;;
message(eadv) -&gt; &quot;advertise error&quot;;
message(eafnosupport) -&gt; &quot;address family not supported by protocol family&quot;;
message(eagain) -&gt; &quot;resource temporarily unavailable&quot;;
message(ealign) -&gt; &quot;EALIGN&quot;;
message(ealready) -&gt; &quot;operation already in progress&quot;;
message(ebade) -&gt; &quot;bad exchange descriptor&quot;;
message(ebadf) -&gt; &quot;bad file number&quot;;
message(ebadfd) -&gt; &quot;file descriptor in bad state&quot;;
message(ebadmsg) -&gt; &quot;not a data message&quot;;
message(ebadr) -&gt; &quot;bad request descriptor&quot;;
message(ebadrpc) -&gt; &quot;RPC structure is bad&quot;;
message(ebadrqc) -&gt; &quot;bad request code&quot;;
message(ebadslt) -&gt; &quot;invalid slot&quot;;
message(ebfont) -&gt; &quot;bad font file format&quot;;
message(ebusy) -&gt; &quot;file busy&quot;;
message(echild) -&gt; &quot;no children&quot;;
message(echrng) -&gt; &quot;channel number out of range&quot;;
message(ecomm) -&gt; &quot;communication error on send&quot;;
message(econnaborted) -&gt; &quot;software caused connection abort&quot;;
message(econnrefused) -&gt; &quot;connection refused&quot;;
message(econnreset) -&gt; &quot;connection reset by peer&quot;;
message(edeadlk) -&gt; &quot;resource deadlock avoided&quot;;
message(edeadlock) -&gt; &quot;resource deadlock avoided&quot;;
message(edestaddrreq) -&gt; &quot;destination address required&quot;;
message(edirty) -&gt; &quot;mounting a dirty fs w/o force&quot;;
message(edom) -&gt; &quot;math argument out of range&quot;;
message(edotdot) -&gt; &quot;cross mount point&quot;;
message(edquot) -&gt; &quot;disk quota exceeded&quot;;
message(eduppkg) -&gt; &quot;duplicate package name&quot;;
message(eexist) -&gt; &quot;file already exists&quot;;
message(efault) -&gt; &quot;bad address in system call argument&quot;;
message(efbig) -&gt; &quot;file too large&quot;;
message(ehostdown) -&gt; &quot;host is down&quot;;
message(ehostunreach) -&gt; &quot;host is unreachable&quot;;
message(eidrm) -&gt; &quot;identifier removed&quot;;
message(einit) -&gt; &quot;initialization error&quot;;
message(einprogress) -&gt; &quot;operation now in progress&quot;;
message(eintr) -&gt; &quot;interrupted system call&quot;;
message(einval) -&gt; &quot;invalid argument&quot;;
message(eio) -&gt; &quot;I/O error&quot;;
message(eisconn) -&gt; &quot;socket is already connected&quot;;
message(eisdir) -&gt; &quot;illegal operation on a directory&quot;;
message(eisnam) -&gt; &quot;is a name file&quot;;
message(elbin) -&gt; &quot;ELBIN&quot;;
message(el2hlt) -&gt; &quot;level 2 halted&quot;;
message(el2nsync) -&gt; &quot;level 2 not synchronized&quot;;
message(el3hlt) -&gt; &quot;level 3 halted&quot;;
message(el3rst) -&gt; &quot;level 3 reset&quot;;
message(elibacc) -&gt; &quot;can not access a needed shared library&quot;;
message(elibbad) -&gt; &quot;accessing a corrupted shared library&quot;;
message(elibexec) -&gt; &quot;can not exec a shared library directly&quot;;
message(elibmax) -&gt;
    &quot;attempting to link in more shared libraries than system limit&quot;;
message(elibscn) -&gt; &quot;.lib section in a.out corrupted&quot;;
message(elnrng) -&gt; &quot;link number out of range&quot;;
message(eloop) -&gt; &quot;too many levels of symbolic links&quot;;
message(emfile) -&gt; &quot;too many open files&quot;;
message(emlink) -&gt; &quot;too many links&quot;;
message(emsgsize) -&gt; &quot;message too long&quot;;
message(emultihop) -&gt; &quot;multihop attempted&quot;;
message(enametoolong) -&gt; &quot;file name too long&quot;;
message(enavail) -&gt; &quot;not available&quot;;
message(enet) -&gt; &quot;ENET&quot;;
message(enetdown) -&gt; &quot;network is down&quot;;
message(enetreset) -&gt; &quot;network dropped connection on reset&quot;;
message(enetunreach) -&gt; &quot;network is unreachable&quot;;
message(enfile) -&gt; &quot;file table overflow&quot;;
message(enoano) -&gt; &quot;anode table overflow&quot;;
message(enobufs) -&gt; &quot;no buffer space available&quot;;
message(enocsi) -&gt; &quot;no CSI structure available&quot;;
message(enodata) -&gt; &quot;no data available&quot;;
message(enodev) -&gt; &quot;no such device&quot;;
message(enoent) -&gt; &quot;no such file or directory&quot;;
message(enoexec) -&gt; &quot;exec format error&quot;;
message(enolck) -&gt; &quot;no locks available&quot;;
message(enolink) -&gt; &quot;link has be severed&quot;;
message(enomem) -&gt; &quot;not enough memory&quot;;
message(enomsg) -&gt; &quot;no message of desired type&quot;;
message(enonet) -&gt; &quot;machine is not on the network&quot;;
message(enopkg) -&gt; &quot;package not installed&quot;;
message(enoprotoopt) -&gt; &quot;bad proocol option&quot;;
message(enospc) -&gt; &quot;no space left on device&quot;;
message(enosr) -&gt; &quot;out of stream resources or not a stream device&quot;;
message(enosym) -&gt; &quot;unresolved symbol name&quot;;
message(enosys) -&gt; &quot;function not implemented&quot;;
message(enotblk) -&gt; &quot;block device required&quot;;
message(enotconn) -&gt; &quot;socket is not connected&quot;;
message(enotdir) -&gt; &quot;not a directory&quot;;
message(enotempty) -&gt; &quot;directory not empty&quot;;
message(enotnam) -&gt; &quot;not a name file&quot;;
message(enotsock) -&gt; &quot;socket operation on non-socket&quot;;
message(enotsup) -&gt; &quot;operation not supported&quot;;
message(enotty) -&gt; &quot;inappropriate device for ioctl&quot;;
message(enotuniq) -&gt; &quot;name not unique on network&quot;;
message(enxio) -&gt; &quot;no such device or address&quot;;
message(eopnotsupp) -&gt; &quot;operation not supported on socket&quot;;
message(eperm) -&gt; &quot;not owner&quot;;
message(epfnosupport) -&gt; &quot;protocol family not supported&quot;;
message(epipe) -&gt; &quot;broken pipe&quot;;
message(eproclim) -&gt; &quot;too many processes&quot;;
message(eprocunavail) -&gt; &quot;bad procedure for program&quot;;
message(eprogmismatch) -&gt; &quot;program version wrong&quot;;
message(eprogunavail) -&gt; &quot;RPC program not available&quot;;
message(eproto) -&gt; &quot;protocol error&quot;;
message(eprotonosupport) -&gt; &quot;protocol not suppored&quot;;
message(eprototype) -&gt; &quot;protocol wrong type for socket&quot;;
message(erange) -&gt; &quot;math result unrepresentable&quot;;
message(erefused) -&gt; &quot;EREFUSED&quot;;
message(eremchg) -&gt; &quot;remote address changed&quot;;
message(eremdev) -&gt; &quot;remote device&quot;;
message(eremote) -&gt; &quot;pathname hit remote file system&quot;;
message(eremoteio) -&gt; &quot;remote i/o error&quot;;
message(eremoterelease) -&gt; &quot;EREMOTERELEASE&quot;;
message(erofs) -&gt; &quot;read-only file system&quot;;
message(erpcmismatch) -&gt; &quot;RPC version is wrong&quot;;
message(erremote) -&gt; &quot;object is remote&quot;;
message(eshutdown) -&gt; &quot;can't send after socket shutdown&quot;;
message(esocktnosupport) -&gt; &quot;socket type not supported&quot;;
message(espipe) -&gt; &quot;invalid seek&quot;;
message(esrch) -&gt; &quot;no such process&quot;;
message(esrmnt) -&gt; &quot;srmount error&quot;;
message(estale) -&gt; &quot;stale remote file handle&quot;;
message(esuccess) -&gt; &quot;Error 0&quot;;
message(etime) -&gt; &quot;timer expired&quot;;
message(etimedout) -&gt; &quot;connection timed out&quot;;
message(etoomanyrefs) -&gt; &quot;too many references: can't splice&quot;;
message(etxtbsy) -&gt; &quot;text file or pseudo-device busy&quot;;
message(euclean) -&gt; &quot;structure needs cleaning&quot;;
message(eunatch) -&gt; &quot;protocol driver not attached&quot;;
message(eusers) -&gt; &quot;too many users&quot;;
message(eversion) -&gt; &quot;version mismatch&quot;;
message(ewouldblock) -&gt; &quot;operation would block&quot;;
message(exdev) -&gt; &quot;cross-domain link&quot;;
message(exfull) -&gt; &quot;message tables full&quot;;
message(nxdomain) -&gt; &quot;non-existing domain&quot;;
message(_) -&gt; &quot;unknown POSIX error&quot;.
&lt;/pre&gt;


</body>
</day>
<day date="2008-11-12" title="">
<body>
*1226466341*[Erlang][メモ]ライブラリモジュールの名前

file_libじゃなくて、filelib。まー、そういうこともあるよね。

ところで、libはツマンネー。あれはなんだ？

*1226466342*[Erlang][メモ]-type属性

kernel/include/file.hrl で使われている。型に、pos_integer(), non_neg_integer() なんてのも使われている。

*1226466343*[Erlang][メモ]EDocエラクナイ

@typeによる型定義に長い説明を付けたいのだが、それができない。@docは、どこに書いても次の関数にかかってしまう。

*1226466344*[Erlang][メモ]コマンドライン引数

&lt;pre class=&quot;out&quot;&gt;
werl hi -myapp foo bar baz -myapp hoge -- fuga
&lt;/pre&gt;

&lt;pre class=&quot;out&quot;&gt;
1&gt; init:get_plain_arguments().
[&quot;fuga&quot;]
2&gt; init:get_arguments().      
[{root,[&quot;C:\\INSTAL~1\\ERL56~1.4&quot;]},
 {progname,[&quot;erl&quot;]},
 {home,[&quot;C:\\Documents and Settings\\Hiyama\\Work&quot;,&quot;hi&quot;]},
 {myapp,[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]},
 {myapp,[&quot;hoge&quot;]}]
3&gt; 
&lt;/pre&gt;

- http://www.erlang.org/doc/man/erl.html
- http://www.erlang.org/doc/man/init.html

*1226479099*[用語法][圏一般論]バーンサイドよりラッセルだろう

圏の骨格代数を、一部でバーンサイド代数と呼ぶが、集合圏のバーンサイド半環は、基数の代数ってことになる。基数が集合の同型類だと指摘したのは確かラッセルだよね。「3とは、この世にある『3つのモノからなる集まり』すべてからなる類」とか言っていた。

とすると、集合圏の骨格概念はラッセルが嚆矢に近いと思われる。まー、僕の気分ではラッセル代数だな。折り合いを付けて、ラッセル／バーンサイド代数か。

*1226480365*[Erlang][メモ][記録]EDoc、どうもダメ

&lt;pre class=&quot;code&quot;&gt;
%% @doc シリアライズ・ドライバ.
%%
%% @docfile &quot;serialize.edoc&quot;
&lt;/pre&gt;

これはクラッシュしてしまう。

日本語のせいではなくて、@docと@docfileは共存させられないようだ。
</body>
</day>
<day date="2008-11-13" title="">
<body>
*1226536903*[Erlang][メモ]deep lists, io data

io_libのman：
&lt;pre class=&quot;code&quot;&gt;
Type:

chars() = [char() | chars()]

Function:

char_list(Term) -&gt; bool()
  Returns true if Term is a flat list of characters, otherwise it returns false.

deep_char_list(Term) -&gt; bool()
  Returns true if Term is a, possibly deep, list of characters, otherwise it returns false.
&lt;/pre&gt;

fileのman：
&lt;pre class=&quot;code&quot;&gt;
Type:

iodata() = iolist() | binary()
iolist() = [char() | binary() | iolist()]
&lt;/pre&gt;

deeplist()は、EDocの組み込み型

erlang&amp;#58;iolist_size/1 はバイトサイズを返す。実際には引数にiodata()を入れてもいい。これはなかなか便利。

*1226536904*[Erlang][メモ]format_error

stdlib/src/shell.erlに次のような行がある。
&lt;pre class=&quot;code&quot;&gt;
 io:fwrite(&quot;** ~w: ~s **\n&quot;, [Line,apply(Mod,format_error,[What])]),
&lt;/pre&gt;
Whatがエラーreasonで、対応するモジュールModのformat_error/1 を呼び出して
人間可読エラーメッセージを生成している。

同じ手法は：

- kernal/src/file_io_server.erl
- syntax_tools/src/epp_dodger.erl
- stdlib/src/erl_lint.erl
- stdlib/src/erl_parse.erl

http://www.erlang.org/doc/man/io.html の最後の記述も参照。

*1226538346*[Erlang][記録]ERL_LIBS

ERL_LIBSが実在しないディレクトリを指すとwerlがクラッシュ。


</body>
</day>
<day date="2008-11-14" title="">
<body>
*1226626732*[Erlang][メモ]ERL_WINDOW_TITLE けっこう便利

&lt;pre class=&quot;out&quot;&gt;
&gt; werl -env ERL_WINDOW_TITLE &quot;Test and Debug&quot;
&lt;/pre&gt;

*1226631401*[メモ法]ついでに書いておく！

本編で「ErlangとJavaのあいだでリモートメッセージング」という記事を書いたとき、ERTSノードのロングネームについてかなり調べた。が、書かなかった。あれは書いておくべきだった。ついでにメモしておけば、今ごろ再度調べる手間は省けたものを！！！

*1226648402*[メモ][Erlang]-nameオプションのロングネーム

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081114/1226631401&quot;&gt;ついでに書いておかなかった件。&lt;/a&gt;

曖昧な記憶によると：

- -name node1@localhost -- ドメイン名にドットがないと、どっかで構文エラー。
- -name node1@128.0.0.1 -- 忘れた。
- -name node1@192.160.0.33 （ホントのIPアドレス） -- 忘れた。ダメだったかな。
- -name node1@not.exist.domain -- DNSを引きに行くのでダメ。

ホントのIPアドレスはipconfで表示される。名前解決をだますには、/etc/hosts に書き込む。Windowsでは、\WINDOWS\system32\drivers\etc\hosts （なんて場所だ）。

次がだました実例：
&lt;pre class=&quot;code&quot;&gt;
127.0.0.1       localhost

192.168.0.1     router router.local.net

192.168.5.32 ohtani.local.net
192.168.5.36 hori.local.net
192.168.5.37 hirose.local.net
192.168.5.33 koba.local.net
192.168.5.35 hiyama.local.net
&lt;/pre&gt;

local.netというドメインがあるように見える。

*1226648667*[メモ][Erlang][記録]erl_callとEPMD幽霊

erl_call -s -sname test とかして、testノードが起動してないと、erl_callがERTSを起動しようとする（-s （startかな）オプションによる）。これが失敗した場合、どうもクリーンナップができてないようで、testというノードのエントリーがEPMDに残るようだ。

次にtestという名前を使ってERTSを起動するとクラッシュ。

ところで、ショートネームでもロングネームでもアライブ名が同じだとクラッシュするのは、EPMDのエントリーキーが一律にアライブ名を使っているせいかもしれない。


</body>
</day>
<day date="2008-11-15" title="">
<body>
*1226720805*[用語法][メモ]clash と crash と crush

意味も似てるし綴りも似てる。こりゃ間違うよな。

- clash 衝突
- crash 衝突、破壊、墜落、崩壊
- crush つぶれる、崩壊、壊滅

flushも綴りに注意。


</body>
</day>
<day date="2008-11-19" title="">
<body>
*1227087199*[メモ][Erlang][課題]コードリーディング

stdlib/proc_lib.erlを読むといいかも。

*1227087200*[メモ][Erlang]undefだとわかるまで

動的呼び出し Mod:func(Arg) がundefで失敗するまでに、とんでもない時間がかかる。

*1227088081*[メモ][圏一般論]序数と基数の問題

本編に書こうと予定してるが、どうなるか？ とりあえメモしておく。

&lt;b&gt;Ord&lt;/b&gt;は順序集合と単調写像（order preserving maps）の圏。離散順序を付ける関手 D:&lt;b&gt;Set&lt;/b&gt;→&lt;b&gt;Ord&lt;/b&gt;と忘却関手U:&lt;b&gt;Ord&lt;/b&gt;→&lt;b&gt;Set&lt;/b&gt;は随伴。Dは埋め込みと考えられるから、その像＝離散順序集合の部分圏を&lt;b&gt;DOrd&lt;/b&gt;⊆&lt;b&gt;Ord&lt;/b&gt;とする。それとは別に、全順序＝線形順序の部分圏を&lt;b&gt;TOrd&lt;/b&gt;⊆&lt;b&gt;Ord&lt;/b&gt;とする。

&lt;b&gt;Ord&lt;/b&gt;上に2種の足し算#, ++ を考える。どちらも台集合は直和になる。#は直和順序、X++Y は、Yの元はすべてXの元より大きいとして入れた順序。#は対称モノイド積、++は非対称（対称とはならない）モノイド積。ただし、有限集合に限れば++も対称にできる。

X, Y∈|&lt;b&gt;DOrd&lt;/b&gt;|に X++Y すると、もはや&lt;b&gt;DOrd&lt;/b&gt;からはみ出してしまい、ハッセ図が完全二部グラフである順序ができる。一方、X, Y∈|&lt;b&gt;TOrd&lt;/b&gt;|に X#Y すると、全順序であはなくなるから、やはりはみ出す。

(&lt;b&gt;DOrd&lt;/b&gt;, #, &lt;b&gt;0&lt;/b&gt;), (&lt;b&gt;TOrd&lt;/b&gt;, ++, &lt;b&gt;0&lt;/b&gt;) はそれぞれモノイド圏になるが、&lt;b&gt;DOrd&lt;/b&gt;に++は入らず、&lt;b&gt;TOrd&lt;/b&gt;に#は入らない。&lt;b&gt;DOrd&lt;/b&gt;∩&lt;b&gt;TOrd&lt;/b&gt; = {&lt;b&gt;0&lt;/b&gt;, &lt;b&gt;1&lt;/b&gt;}なので、この2つの圏は&lt;em&gt;ほとんど無関係。&lt;/em&gt;


</body>
</day>
<day date="2008-11-20" title="">
<body>
*1227154247*[メモ][Erlang]EDoc関係

- edoc:read_source/{1, 2} -- これは便利だ！

他にも意外に便利な関数があるかもよ。

@headerfile を読む検索パスは、{includes, Path} where Path = [string()] オプションで指定される。includesはEPPの処理のときも共通に使われる。

{doc_path, Path} where Path = [string()] でDoc Pathが指定できるが、パスが示すディレクトリにedoc-infoがないと無意味。

edoc-infoは次のようなタームファイル。consultで読むのだろう。
&lt;pre class=&quot;code&quot;&gt;
{application,'Utils'}.
{packages,[]}.
{modules,[common_error,mark,server_util,t_server_util]}.
&lt;/pre&gt;

*1227172084*[圏一般論][高次圏論][論理]高次骨格の基本推論

高次骨格はずっと気になっている。高次&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081112/1226479099&quot;&gt;ラッセル／バーンサイド&lt;/a&gt;代数というとカッコイイかも知れない。以下、ある種の同値関係と簡単な推論図に関してメモ。

Cを2-圏とする。話を簡単にするために厳密（strict case）とする。Cのホム圏C(A, B)は圏だから、このなかで対象（もとのCでは1-セル）の同型が考えられる。それを ～&lt;sub&gt;A,B&lt;/sub&gt; とする。

- f ～&lt;sub&gt;A,B&lt;/sub&gt; f' ⇔ α::f→f':A→B となる可逆2-セルαがある。

～&lt;sub&gt;A,B&lt;/sub&gt;が集合|C(A, B)|（もとの1-セルの集合）の同値関係であることは明らか。

+ f ～ f （恒等2-セルは可逆だから）
+ f ～ f' ⇒ f' ～ f （逆もまた可逆）
+ f ～ f', f' ～ f'' ⇒ f ～ f'' （可逆2-セルの結合は可逆）

各A, B∈C&lt;sup&gt;0&lt;/sup&gt;（Cの0-セルの集合）に対して、Iso(C(A, B)) を割り当てると、亜群で豊饒化された圏になる。以下の議論は、実際に豊饒圏になってるかどうか、って話でもある。

この状況で非常に基本的な推論は次の2つ（実際にはバリエーションがいくつかあるが）。
&lt;pre&gt;

   f ～ f' : A→B    g ～ g' : B→C
 ------------------------------------
    f;g ～ f';g' : A→C


  f;g ～ h : A→C   f ～ f' : A→B
 ------------------------------------
   f';g ～ h : A→C
&lt;/pre&gt;

1-セルの同値を与える可逆2-セルを明示的に書いて α:: f ～ f' : A→B のような書き方を使う。すると、
&lt;pre&gt;
   α:: f ～ f' : A→B   β:: g ～ g' : B→C
  ------------------------------------------
    α*β :: f;f' ～ g;g' : A→C


  γ:: f;g ～ h : A→C   α:: f ～ f' : A→B
 --------------------------------------------
   (α^(-1)*Id_g)|γ :: f';g ～ h : A→C
&lt;/pre&gt;

と具体的に同値を与える2-セルを書き下せる。ここで、* は横結合、| は縦結合。この2つの推論が成立する根拠は、縦結合と横結合の交替法則。エックマン／ヒルトンにしろ、これにしろ、やっぱり交替法則は本質的なんだ、と感じる。

次は、亜群の圏&lt;b&gt;Grpoid&lt;/b&gt;に直積でモノイド構造を入れて、実際に豊饒圏の定義を確かめる。それと、2-圏の1-骨格として圏ができることを確認する必要がある。勘違いしてなければ、今示した推論があればOKのはず。


</body>
</day>
<day date="2008-11-21" title="">
<body>
*1227229746*[圏一般論][高次圏論]高次骨格と高次亜群

1日15分くらいずつ考えている感じだな。高次骨格の構成はそれほど単純じゃないかもな。

Cが2-圏として、C&lt;sup&gt;1&lt;/sup&gt;をCの1-セルの集合だとする（1以下のセルではない）。C&lt;sup&gt;0&lt;/sup&gt;の同値（2-同値）をもとにして、C&lt;sup&gt;1&lt;/sup&gt;にも普通の同値関係を入れられるが、期待した構造とはどうも違う。「期待」のほうが間違っていた感じがする。

0-セルAとBが同値であることは、i:A→B と i&lt;sup&gt;#&lt;/sup&gt;:B→A があって、i;i&lt;sup&gt;#&lt;/sup&gt; ～ 1&lt;sub&gt;A&lt;/sub&gt;、かつ i&lt;sup&gt;#&lt;/sup&gt;;i ～ 1&lt;sub&gt;B&lt;/sub&gt; なこと。i&lt;sup&gt;#&lt;/sup&gt; はiから一意的に決まるものではない。～&lt;sub&gt;A,A&lt;/sub&gt;、～&lt;sub&gt;B,B&lt;/sub&gt; を基点をA, Bとしたループのホモトピーのように考えると、up-to-homotopyで可逆ということになる。だから、i&lt;sup&gt;#&lt;/sup&gt;は、ホモトピー的な逆だとはいえる。

2つの1-セル f:A→B、f':A'→B' の同値は、0-セルの同値i:A→A'、j:B→B' があって、f = i;f';j&lt;sup&gt;#&lt;/sup&gt; と書けること、と定義できる。

以上の定義が妥当かどうか自信がないが、ともかくも作業仮説としていじってみると、亜群の圏の圏対象（内部圏）が出てくる。2-圏の骨格は圏ではなくて、内部圏として定義すべきだという可能性もある（ハッキリしないが）。となると、n-亜群とω-亜群が何であるか、n-亜群の圏の(n-1)-圏対象が何であるかが興味の対象となる。

1-亜群が、同値関係を持った集合の直接的な拡張であるなら、n-亜群が高次の同値関係と関係を持つだろう、という予測は自然な気がする。まー、自然でも実態が分かるまでは予測に過ぎないが。

*1227231290*[オフトピック]なんで鳥山明キャラ？

- シェンロン
- ブルードラゴン
- 亀仙人

まっ、いいか。

*1227246682*[圏一般論][高次圏論]高次骨格はホモトピーか？

で、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081121/1227229746&quot;&gt;さらに15分ほど&lt;/a&gt;考えた。

f:A→B, g:C→Dだとして、B ～C であったとき、cod(f)≠dom(g) でも f;g を定義できるか？ これが問題になる。結論を言えば「できない」。これはホモトピーとの類似を追いかけてみるとわかる。i:B～C, j:B～C であるとき、i～j とは限らないことが問題。

つまり、1-骨格がうまく圏になるのは期待できない。しかし、亜群で豊饒化された圏、合同を持つ圏、とかにはできる。グランディスが、基本群に変えて基本圏なんてのを定義しているし、連結成分の定義もあった -- あの路線だろう。

どうも、いろんな構造を up-to-homotopyで考える、ってことのようだ。

</body>
</day>
<day date="2008-11-22" title="">
<body>
*1227331045*[Erlang]アプリケーションのメカニズムと作り方

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081105/1225842677&quot;&gt;悔やまれた件&lt;/a&gt;、もう一度調べた。基本的には、&lt;a target=&quot;_blank&quot; href=&quot;http://www.erlang.org/doc/pdf/design_principles.pdf&quot;&gt;「OTP設計原理」&lt;/a&gt;を読めばよいのだ。

次の概念を理解しよう。

+ アプリケーション
+ OTP-ST（監視ツリー）
+ OTP-STアプリケーション
+ トップスーパーバイザ
+ アプリケーションコントローラ・プロセス
+ アプリケーションマスター・プロセス
+ アプリケーション・コールバックモジュール

Erlangのアプリケーション概念は多様／多義的、ここでは最も狭く厳密な定義を扱う。それが&lt;strong&gt;OTP-ST（supervison tree）アプリケーション&lt;/strong&gt;。OTPの正統的なアプリケーション概念だ。

アプリケーションは基本的にモジュールの集まりだが、実行時にはプロセスが生成される。特にOTP-STアプリケーションでは必ずプロセスが使われる。よって、モジュールとプロセスをどのように編成／構造化するかの規約が必要になる、それが「設計原理」に書いてあるわけ。よほどのことがない限りOTPフレームワーク（ビヘイビア群）を使うことになる。

&lt;!- ================================================== --&gt;
&lt;h5&gt;アプリケーションコントローラとspecial process&lt;/h5&gt;

アプリケーションコントローラはカーネルの一部で、システム（ERTS）に1つだけ常に存在する（登録名：application_controller、PIDは5番くらい((多少の欠番があって、init, erl_prim_loader, error_loggerの次かな。))）。

アプリケーションコントローラは、システム内に存在するOTP-STアプリケーション（以下、単にアプリケーション）全てを完全に掌握している。アプリケーションコントローラに管理されないアプリケーションは&lt;b&gt;野良アプリケーション&lt;/b&gt;ということになる。

OTP用語&lt;em&gt;ではない&lt;/em&gt;が、アプリケーションコントローラに管理されるアプリケーション、モジュール、プロセスを&lt;strong&gt;オフィシャル&lt;/strong&gt;と形容することにしよう。オフィシャルモジュールは、必ず1つのアプリケーションに属さなくてはならない。複数のアプリケーションで同一モジュールを共有することはできない。ただし、これは所属関係の話で、&lt;em&gt;利用（コール）はどこからでもできる&lt;/em&gt;。同様に、オフィシャルプロセスはただ1つのアプリケーションに所属する。ちなみに、プロセスを持たないアプリケーションはライブラリアプリケーションと呼ばれる（純粋ライブラリ・アプリケーションという感じだが）。

- application:get_application(Pid | Module) -&gt; {ok, Application} | undefined
- application:get_application() ≡ application:get_application(self())

get_applicationが単値の関数であることから、所属関係の事情はわかるだろう。get_applicationがundefinedを返せば、それは野良モジュール／プロセス（カーネルプロセスinitとかは話が別）。おそらくsystools内に所属の重複をチェックするツールがあるはず。

オフィシャルプロセスは必ずしも名前を持たなくてもよい。が、proc_libの関数で生成されたspecial process（&lt;em&gt;OTP用語&lt;/em&gt;）で、プロセスディクショナリに管理情報（メタデータ）を持つ。special processは、このメタデータで統制される。

&lt;pre class=&quot;out&quot;&gt;
&gt; {dictionary, DList} = erlang:process_info(pid(0, 4, 0), dictionary). 
{dictionary,[{'$ancestors',[&lt;0.1.0&gt;]},
             {'$initial_call',{gen,init_it,
                                   [gen_event,&lt;0.1.0&gt;,&lt;0.1.0&gt;,
                                    {local,error_logger},
                                    [],[],[]]}}]}
&gt; {value, Ances} = lists:keysearch('$ancestors', 1, DList).
{value,{'$ancestors',[&lt;0.1.0&gt;]}}
&gt; 
&lt;/pre&gt;

&lt;!- ================================================== --&gt;
&lt;h5&gt;トップスーパーバイザApp_sup&lt;/h5&gt;

正当なアプリケーションはST（監視ツリー）を持つ。STのルートプロセスはトップスーパーバイザと呼ばれる。supervisorビヘイビアのコールバックモジュールがトップスーパーバイザの実行仕様を与える。慣例的に、トップスーパーバイザのコールバックモジュール名は App_sup とする。ただし、App_supはinit(Arg)（と慣例的便利関数）を公開するだけの簡単なものだ((コールバックモジュールじゃなくて、単にsupervisor:{start, start_link}にデータを渡してもいいような気がするくらいだ。))。

supervisor:start_link(App_sup, Arg)、または supervisor:start_link(SupName, App_sup, Arg)（登録名が必要なとき）がSTを始動させるトリガーとなる。うまくアプリケーションのST（リンクされたプロセス群）が始動すれば {ok,Pid} が返る。Pidはトップスーパーバイザ・プロセスのPid。

App_supは、慣例として、コールバックinit(Arg)以外に次を公開する。

&lt;pre class=&quot;code&quot;&gt;
start_link() -&gt;
 supervisor:start_link({local, ?SERVER}, ?MODULE, ?DEFAULT_ARG).

start_link(Arg) -&gt;
 supervisor:start_link({local, ?SERVER}, ?MODULE, Arg).
&lt;/pre&gt;

App_sup:start_link(Arg)のArgはコールバックinit(Arg)のArgとして&lt;em&gt;そのまま&lt;/em&gt;渡される。可変なArgが不要なら、App_sup:start_link/0 だけ公開すればよい。

&lt;!- ================================================== --&gt;
&lt;h5&gt;アプリケーションコールバックモジュールApp_app&lt;/h5&gt;

App_sup:start_link()は誰がコールするか？ コントローラーが直接コールするのではなくて、アプリケーションコールバックモジュールApp_appのstart(Type, Arg)を経由する。コールバックApp_app:start/1の引数仕様：

- Typeの値は通常normal、それ以外の値（{takeover,Node} | {failover,Node}）は分散アプリケーションのときのみ。
- Argは、&lt;em&gt;トップスーパーバイザのArgとは無関係！&lt;/em&gt;。コントローラが、アプリケーション仕様（もとは.appファイル）から取り出した値をArgとしてApp_app:start(Type, Arg)に渡す。アプリケーション仕様にstart引数が定義されてなければ、デフォルト値の[]が渡される。

アプリケーションコールバックは次のテンプレートでほとんど十分：
&lt;pre class=&quot;code&quot;&gt;
%% App_app.erl
&amp;#45;module(App_app).
&amp;#45;behaviour(application).

&amp;#45;export([start/2, stop/1]).

start(_Type, _Arg) -&gt;
 App_sup:start_link().

stop(_State) -&gt;
 ok.
&lt;/pre&gt;

App_app:start/2は、成功時に {ok, Pid}か{ok, Pid, State}を返せる。通常は、supervisor:start_link/{2, 3} が {ok,Pid} | ignore | {error,Error} を返すので、それをそのまま使う。もし、Stateを付けると、それがstop/1の引数に渡される。stop/1の引数のデフォルト値は[]だが、不要なら無視する。

&lt;em&gt;非常に重要な注意：&lt;/em&gt; App_app:stop/1 はアプリケーションのSTシャットダウンが完了した&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;後に&lt;/b&gt;&lt;/span&gt;呼び出される。STの終了処理(terminate(Reason, State)コールバック）とは何の関係もない。STではできない後始末を行うのだ。

&lt;!- ================================================== --&gt;
&lt;h5&gt;アプリケーションマスター・プロセス&lt;/h5&gt;

アプリケーションコールバックモジュールApp_appのstart/2（引数はたいてい使わない）から、トップスーパーバイザを始動するApp_sup:start_link/0（その実体は、supervisor:start_link(Mod, Arg)など）が呼ばれる。当然に、App_app:start/2をコールした当のプロセスはアプリケーションのトップスーパーバイザとリンクされる。

では、リンクによりSTを監視するハイパーバイザー（スーパー・スーパーバイザ）は誰なのだろう？ コントローラか？ そうではない。アプリケーションごとに“影の支配者”となるアプリケーションマスター・プロセスが作られ、そのマスターがApp_app:start/2をコールする。
&lt;pre&gt;
コントローラ 
  +-(生成)-&gt; マスタープロセス 
                +-(start/2)-&gt;コールバックモジュール
                                +-(start_link/0など)-&gt;トップスーパーバイザ
                                                               +
                &lt;--(戻り値:{ok, Pid})--------------------------+
&lt;/pre&gt;

コントローラは、自分の配下であるマスタープロセスを使って、アプリケーションSTを完全に制御する。モジュールApp_appは、STの始動とシャットダウン後の後始末に登場するだけで、&lt;em&gt;稼働中のSTでは何の役割も果たさない。&lt;/em&gt;プロセスリンクは、マスタープロセス（ハイパーバイザー）とトップスーパーバイザプロセス間で確立される。

&lt;!- ================================================== --&gt;
&lt;h5&gt;シャットダウン&lt;/h5&gt;

アプリケーションのスタートは、アプリケーションマスタープロセスが当該アプリケーションのアプリケーションコールバックモジュールのstart/2を呼ぶところから始まる。では、アプリケーションの終了はどうなるか。予想とは違い、stopメッセージは使わない。参考までに標準的なstopメッセージの方式は：

&lt;pre class=&quot;code&quot;&gt;
handle_cast(stop, State) -&gt;
    {stop, normal, State}.
&lt;/pre&gt;

ワーカープロセスで上記のごとくstopメッセージをサポートするのは、特に必要はない。スーパーバイザから管理下の子ワーカを止めるには、supervisor:terminate_child/2が使える。

&lt;pre&gt;
supervisor:terminate_child(SupRef, Id) -&gt; Result
where
 SupRef = Name | {Name,Node} | {global,Name} | pid(),
 Name = Node = atom(),
 Id = term(),
 Result = ok | {error,Error},
 Error = not_found | simple_one_for_one .
&lt;/pre&gt;

スーパーバイザを止めるには、シャットダウン戦略に従ったシャットダウン手順を踏む必要がある。これは、シグナルexit(Target, shutdown)を使う。おおよその手順は：

+ コントローラがアプリケーションマスターにシャットダウンを指示する。
+ アプリケーションマスターはトップスーパーバイザにshutdownシグナルを送る。
+ トップスーパーバイザは配下のスーパーバイザ／ワーカーを止める。
+ トップスーパーバイザが死んでEXITシグナルをアプリケーションマスターに送る。
+ アプリケーションマスターも死ぬ。

原則的に、トップスーパーバイザの終了はアプリケーションコントローラを使う。

*1227335750*[Erlang][メモ][小咄]rpc.erl

&gt;&gt;
%% This code used to reside in net.erl, but has now been moved to&lt;br&gt;%% a searate module.
&lt;&lt;

s/searate/separate/ 


</body>
<comments>
<comment>
<username>jj1bdx</username>
<body>この手のスペルミスはかなりありそうですが，調べるときりがないですね．epmdのデバッグメッセージのスペルが違っていたのでバグレポートを出したことがあります．</body>
<timestamp>1227936190</timestamp>
</comment>
<comment>
<username>m-hiyama-memo</username>
<body>jj1bdxさん、&lt;br&gt;&gt; 今風であることをあえて追求する必要もないんじゃないでしょうか&lt;br&gt;はい、別に不満はありません。&lt;br&gt;古風や今風に価値判断が含まれるわけではなく、好き嫌いで言えば、古風な感じは好きです。</body>
<timestamp>1227938358</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body># あっ、メールの返答先が間違っていたのか。&lt;br&gt;# 失礼しました。&lt;br&gt;&gt; この手のスペルミスはかなりありそうですが，調べるときりがないですね．&lt;br&gt;調べる気は全然ないですが、たまたま気付いたので。&lt;br&gt;最初、searateはなんか意味があるかと思っちゃいました。</body>
<timestamp>1227939158</timestamp>
</comment>
</comments>
</day>
<day date="2008-11-27" title="">
<body>
*1227771782*[圏一般論]∃同値と∀同値

恒等射、同型射、圏同値を与える関手などを総称して、同値性セル（equivalence cell）と呼ぶことにする。

A, Bのあいだに、i:A→B と、（iに対して一意的とは限らない）i&lt;sup&gt;#&lt;/sup&gt;があって、

+ i;i&lt;sup&gt;#&lt;/sup&gt; ～ id&lt;sub&gt;A&lt;/sub&gt;
+ i&lt;sup&gt;#&lt;/sup&gt;;i ～ id&lt;sub&gt;B&lt;/sub&gt;

となることが同値性セルの条件。ここで、～ は、適当な同値関係だが、ホモトピーとの類似では A、Bを基点とするループのホモトピーに相当する。

同値性セル i:A→B が存在すれば、AとBは∃同値と呼ぶことにする（正確に書くと、形容詞がイッパイ付くが省略）、単に同値性セルが&lt;em&gt;存在する&lt;/em&gt;よ、って意味。i, j:A→B が2つの同値性セルだとして、iとjがより高い次元で同値であることはまったく保証できない。より高い次元の同値で同値性セルを分類すると、同値性の同値類ができる。

AとBの同値性の同値類が1つだけしかないとき、AとBは∀同値と呼ぶことにする。、&lt;em&gt;すべて&lt;/em&gt;の同値性が事実上同じってことね。この∀同値性は強いので、強同値とか呼びたいが、もともとがup-to-homotopyのようなsettingで考えているので弱い。混乱するから「強」は止める。

だが、∀同値は、弱い同値関係の世界ではトンデモナク強くて、AとBはどうやっても区別できないことを意味する。実在物としては超越的に区別できても、構造的／機能的に区別できないし、取り替えても誰も分からない、つうか誰も迷惑しない。

2-圏で考えると、対象を∀同値で分類すると、その商集合の上には圏（1-圏）の構造を載せることができる。これは確かに骨格圏と呼んでいいと思う。が、無理に商を作るのが得策とは思えなくなってきた。亜群の構造やさまざまな同値関係を&lt;em&gt;あるがまま&lt;/em&gt;に見たほうが、豊富な情報を捨てずに済むから有益だろう。

*1227771824*[その他プログラミング][メモ]シェルとかコマンドとか

+ シェル変数への代入は、=の両側空白なし。FOO=bar 、FOO='bar baz' とか。
+ $$はシェルのPID、一時ファイル名によく使う。Makefile上では$$$$
+ install -d は便利
+ でも、installよりcpのほうが便利なときが多い。
+ cp -R my/dir  your/  と cp -R my/dir/*  your/dir/ は同じ
+ cp と Windows copy の挙動が違うので注意

</body>
</day>
<day date="2008-11-28" title="">
<body>
*1227831876*[Erlang]文化と伝統

- バージョンをvsnと表記する（いまだに馴染めない^^;）。
- 「アプリケーション」が独特な意味を持つ（いまだに馴染めない^^;）。
- libはアプリケーション群を意味する（馴染んだ）。
- シェルとmakeをヘビーに使う（もう大変だよ）。
- 全体に古風（年寄り向きとも言えるか？）。
- あんまりかっこよくない。


</body>
<comments>
<comment>
<username>jj1bdx</username>
<body>今風であることをあえて追求する必要もないんじゃないでしょうか :)</body>
<timestamp>1227935230</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body># 試しにメールで返答してみたのですが、失敗したのかな？&lt;br&gt;jj1bdxさん、&lt;br&gt;&gt; 今風であることをあえて追求する必要もないんじゃないでしょうか&lt;br&gt;はい、別に不満はありません。&lt;br&gt;古風や今風に価値判断が含まれるわけではなく、好き嫌いで言えば、古風な感じは好きです。</body>
<timestamp>1227938958</timestamp>
</comment>
</comments>
</day>
<day date="2008-11-29" title="">
<body>
*1227940056*[その他プログラミング][メモ]Makeターゲット

標準的なのは、次くらいで十分だろう。

- all -- 必要なもの一式を全部作る。デフォルトターゲット。
- clean -- ほぼallの反対。生成に時間がかかるファイルや、ほとんど変更しないファイルは消さなくてもよい。
- distclean -- 配布に含まれていなかった全てのファイルを消して、配布を復元する。ただし、配布を展開した後でユーザーが追加したファイルを消さないように注意。

次のターゲットは配布作成やインストールに関連する。

- dist -- 配布用tarを作成する。
- install -- 自分のシステムにインストールする。
- uninstall -- installで作ったりコピーしたものを消す。

問題点：

+ allでdocも作るか？ 不要な気がする。
+ 1つのMakefileですべてのターゲットをサポートするか？
+ インストール後にユーザーが変更したファイルもuninstallで消すのか？
+ distをdist_devとdist_execに分けたほうがいいのでは。

*1227940961*[その他プログラミング][メモ]Makefileで使うかどうか？

mkdir -p は便利、という意見と、使うな、という意見がある。

&gt;&gt;
&amp;#45;p, --parents 

引き数に指定した各々の directory で、存在しない親ディレクトリも含めて作成する。作成された親ディレクトリのアクセス権は、 umask の値に `u+wx' としたものが設定される。すでに存在するディレクトリに対応する引き数は無視される。 (従って、ディレクトリ /a が存在する場合に `mkdir /a' とするとエラーとなるが、 `mkdir -p /a' とするとエラーにならない。) 
&lt;&lt;

とりあえず、install -d のほうがいいような。

rm -fr は危ないが、、、

&gt;&gt;
&amp;#45;r または -R 

再帰的にディレクトリツリーを削除する 
&lt;&lt;


</body>
</day>
<day date="2008-12-01" title="">
<body>
*1228101290*[連絡的]構造体の前に少し

次のような言葉はよく耳（目）にするだろう。

+ スタック
+ スタックフレーム
+ ヒープ
+ スレッド
+ プロセス

で、あらためて&lt;b&gt;「これはなに？」&lt;/b&gt;

&lt;hr&gt;
- nm, strip, od  とか使え。
- 自作asciiを色々改善しろ。
- 自作ダンプも色々改善しろ。

&lt;hr&gt;
データとそれに対する操作は：

+ 値（ビット列）の計算（ビット操作）
+ メモリブロックの操作

いつも心に留めるべきことは&lt;b&gt;「どこに、どれくらい、何が」&lt;/b&gt;

あとは、憶測により事実とは異なる勝手なイメージを作らないこと。回り道（余計なこと）しないで、とにかく素直に考えること。

</body>
</day>
<day date="2008-12-03" title="">
<body>
*1228272054*[Erlang][メモ]ignoreって

gen_server:startとかがignoreを返すのってなに？ と思っていたが、例えば、既に同じ機能をサービスするサーバーが上がっているから自分は不要だ、とかいうとき使えるかも。エラーではないが起動する必要はない、って事情。

*1228273986*[Erlang][メモ]アプリケーション概念

アプリケーションの意味を4つくらいに分けて考えるといい。

+ 単にモジュールの集合
+ .appファイル（メタデータ）を持つモジュールの集合
+ OTP監視ツリー構造を持つモジュール集合
+ アプリケーションコントローラが認識できるアプリケーション

ライブラリアプリケーション＝関数ベースアプリケーションもアプリケーションの一種となる。

OTPビヘイビアを使い、OTP設計原理に従ったアプリケーションは「OTP適合アプリケーション」（OPT-conformant application）と呼ぶことにするか。OTP監視ツリーを作ると、結局はアプリケーションコントローラに認識させることになるから、三番目と四番目は差がないかもしれない。

ところで、included applications と including application の使い方がまだわからない。

</body>
</day>
<day date="2008-12-05" title="">
<body>
*1228435642*[Erlang][メモ]モジュール名の命名規則

| App.erl      | アプリケーションのインターフェースモジュール |
| App_app.erl  | applicationコールバックモジュール|
| App_server.erl|gen_serverコールバックモジュール| 
| App_X_srv.erl| サーバーが複数の場合の、gen_serverコールバックモジュール|
| App_sup.erl  | トップスーパーバイザ|
| App_Y_sup.erl| 中間のスーパーバイザ|
| App_impl.erl | App_serverの実装モジュール（必要なら）|
| App_X_impl.erl| App_X_srvの実装モジュール（必要なら）|
| App_lib.erl| App_implと同じ目的だが、これだけを外部から使える関数群|
| App_util.er|Appで使う便利関数、小物など |


</body>
</day>
<day date="2008-12-08" title="">
<body>
*1228696482*[ホッピングボール][小咄]時計が毛糸

子供らが、変身トンネルとかなんかいっていた。

- トケイトケイ、、、、ケイト
- ボタンボタン、、、、タンボ

次はわからなかった。

- ワリオワリオ、、、、オワリ

ワリオは「悪いマリオ」（ゲーム）だそうだ。


</body>
</day>
<day date="2008-12-10" title="">
<body>
*1228866135*[連絡的]文字列を数値に

そろそろ、次の課題の解答例を挙げておこう。

- 符号なし（'+', '-'が付かない）十進整数を表現する文字列を数値（コンピュータが通常は整数と認識するであろうデータ）に変換する関数

素直に無駄なく、直球勝負で書けばこんな感じだろう。

&lt;pre class=&quot;code&quot;&gt;
/* 符号なし整数のatoi、自家製版 */

/**
 * 制限:
 * 引数の文字列は符号なし（'+', '-'が付かない）十進整数の表現だとする.
 */
string_to_integer(char *s)
{
  int val;
  for (val = 0; *s; s++) {
    val = val*10 + (*s - '0');
  }
  return val;
}

// お試し用のmain
main()
{
  char *strs[] = {
    &quot;123&quot;,
    &quot;007&quot;,
    &quot;76543210&quot;,
    &quot;0&quot;,
    &quot;+5&quot;, // これはダメ
    &quot;-1&quot;, // これもダメ
    &quot;abc&quot;, // 全然ダメ
  };
  
  int i;
  for (i = 0; i &lt; (sizeof(strs)/sizeof(char*)); i++) {
    printf(&quot;(%d) \&quot;%s\&quot; ==&gt; %d\n&quot;, 
           i, strs[i], string_to_integer(strs[i]));
  }
}
&lt;/pre&gt;

先頭の符号（'+'と'-'）を解釈するようにはしたほうがいいだろう（どうなる？）。

エラーチェックコードとか入れたくなるかも知れないが、やらないほうがいい。正しい構文の引数を準備するのは呼ぶ側の責任だから、変な引数に対して変なことをしても別にいいのだ。例外がない環境でのエラーの返し方は別の機会に。

*1228887530*[メモ法]ストーリーも忘れるから見出しだけでもサッサと書いておけ

なにかしらストーリーがある書き物のとき。ある状況では、全体が見えている。が、これも忘れる。見出しや概要だけでもいいから、見えているときに書いておいた方がいい。細部を忘れるのは当たり前だが、ストーリーも忘れる。

</body>
</day>
<day date="2008-12-11" title="">
<body>
*1228953820*[連絡的]例外もどき：マズイことが起きたことを伝える方法

+ 正常な戻り値とはなり得ない値をエラー値とする。fopen()のNULL、getchar()のEOFとか。
+ 正常な戻り値のなかで何か選んで「エラーかもしれない値」とする。それとは別に大域変数を使う。errno方式。
+ 引数に、結果を返すべき変数（バッファ）へのポインターを渡す。関数戻り値は、成功／失敗。出力バッファ方式。
+ 引数に、エラー番号などを入れる変数へのポインタを渡す。
+ 構造体を返す。構造体戻し方式。

errno方式はよく使われるが、使い勝手が悪いしスレッドセーフじゃないので割愛。引数にerrno相当の変数へのポインタを渡せば少しマシだが、折衷案で中途半端だからこれも割愛。

出力バッファ方式：
&lt;pre class=&quot;code&quot;&gt;
#include &lt;ctype.h&gt;

#define OK 0
#define NG (-1) 

string_to_integer_1(char *s, int *presult)
{
  int val;
  int c;
  for (val = 0; c = *s; s++) {
    if (!isdigit(c)) return NG;
    val = val*10 + (c - '0');
  }
  *presult = val;
  return OK;
}
&lt;/pre&gt;

構造体戻し方式：
&lt;pre class=&quot;code&quot;&gt;
struct result {
  int status; // OK or NG
  int value;
};

struct result string_to_integer_2(char *s)
{
  struct result r;
  int val;
  int c;
  for (val = 0; c = *s; s++) {
    if (!isdigit(c)) {
      r.status = NG;
      return r;
    }
    val = val*10 + (c - '0');
  }
  r.status = OK;
  r.value = val;
  return r;
}
&lt;/pre&gt;

エラー値が一番単純、それが使えないなら出力バッファが無難な気がする。

</body>
</day>
<day date="2008-12-12" title="">
<body>
*1229043724*[連絡的]ファイルの16進ダンプ

最初の頃の課題：装飾はなくていいので、とにかく16進でダンプ。

素直に無駄なく、必要なことだけをストレートに書く。そして、次のようなしきたりは守る。

+ 引数なしならstdin（標準入力）、これは絶対ってわけでもない。
+ エラーメッセージはstderrに！ これは絶対。
+ 成功なら0、失敗なら0以外の終了ステータス、これも絶対。コマンドライン／シェルスクリプトでは、なぜか0がtrue。

&lt;pre class=&quot;code&quot;&gt;
#include &lt;stdio.h&gt;

#define DELM_CH ','
#define SIZE_OF_BLOCK 16

#define OK 0
#define CANT_OPEN (-1)

typedef unsigned char byte;

print_byte_in_hex(byte b)
{
  static int hex[] = {'0', '1', '2', '3', 
		      '4', '5', '6', '7', 
		      '8', '9', 'A', 'B', 
		      'c', 'D', 'E', 'F' };
  putchar(hex[b&gt;&gt;4]);
  putchar(hex[b&amp;0xF]);
}

print_block_in_hex(byte *block, int size)
{
  int i;
  for (i = 0; i &lt; size; i++) {
    print_byte_in_hex(block[i]);
    if (i &lt; size - 1) putchar(DELM_CH);
  }
  putchar('\n');
}

dump_file(FILE *fp)
{
  byte buffer[SIZE_OF_BLOCK];
  size_t n_bytes;
  while (n_bytes = fread(buffer, 1, SIZE_OF_BLOCK, fp)) {
    print_block_in_hex(buffer, n_bytes);
  }
}

open_and_dump_file(char *filename)
{
  FILE *fp = fopen(filename, &quot;rb&quot;);
  if (fp == NULL) return CANT_OPEN;
  dump_file(fp);
  fclose(fp);
  return OK;
}

main(int argc, char **argv)
{
  if (argc == 1) {
    dump_file(stdin);
  } else if (open_and_dump_file(argv[1]) == CANT_OPEN) {
    fprintf(stderr, &quot;can not open file '%s'\n&quot;, argv[1]);
    exit(1);
  }
  exit(0);
}
&lt;/pre&gt;

+ 関数の数はやや多いが、どの関数も&lt;em&gt;10行以内&lt;/em&gt;。
+ 入れ子はあっても&lt;em&gt;一段階まで&lt;/em&gt;。
+ 個々の関数は再利用可能（ライブラリにできる）。
+ define定数を書き換えて若干のカスタマイズ可能。

*1229073206*[用語法]生成元

Same Origin Policyの訳語が「同一生成元ポリシー」だった。生成元は「せいせいもと」だろな。「せいせいげん」と読んでしまうが、それはoriginじゃなくてgeneratorだ。

*1229073571*[msched][WCC][その他代数]ミーティング・スケジューラ、イベントの代数

Erlangでミーティング・スケジューラを作ろうかな、っと。そういうもんは色々あるんだけどさ、メールとか使わないでもっとダイレクトにサッサッとできるヤツね。通信はWCC使って； 現状、通信のセキュリティがないのが大問題だけど、そこはホッカブリして、理屈を考える。

理屈はうんと理屈っぽくね。

基本はイベント一元論。ここでの&lt;strong&gt;イベント&lt;/strong&gt;は時区間（time interval）にラベルを付けたもの。時間の1次元アフィン空間を&lt;b&gt;T&lt;/b&gt;とする； これはニュートン時間ね、相対論使いません^^;  時区間iは、i⊆&lt;b&gt;T&lt;/b&gt; なんだけど、開始時点s, 終了時点e（s, e∈&lt;b&gt;T&lt;/b&gt;）により、i = [s, e] と書けるもの。それで、ラベルの集合をLとして、イベントは (A, i) = (A, [s, e]) と表現できる。ここで、A∈L、s, e∈&lt;b&gt;T&lt;/b&gt;, s≦e 。

ラベルの集合Lは固定するとして、イベントの全体はEvとする。イベントには、それ以上は分解できない原子イベントがある。原子イベントの集合をAE（atomic evetns）とする。当然 AE⊆Ev。AEは天下り（公理的と言ってもいいが）に与えられている。AEの条件とか使い方は、また後で。

イベントa, bなどに対して、そのラベルはA, Bなどと書くことにする（単に、記法上の約束）。特殊なイベントをいくつか導入しておく。まず、(A, [s, s])の形のイベントは&lt;strong&gt;時点イベント&lt;/strong&gt;、または&lt;strong&gt;点イベント&lt;/strong&gt;。s＞t のとき [s, t]は空になるから、これも認めて0と書くことにする。(A, 0)は&lt;strong&gt;空イベント&lt;/strong&gt;。ラベルが付いているので空イベントは無限にある（Lは無限としておく）。さらに、Lのなかに特殊な&lt;strong&gt;⊥（ボトム）&lt;/strong&gt;を入れておく。⊥の意味は何ものでもない、ってこと。

Lのなかに&lt;strong&gt;∧（ミート）&lt;/strong&gt;って演算を入れる。

- A = B のとき、A∧B  = A = B
- それ以外のとき、A∧B  = ⊥ （気持ちとしては、そんなものねーよ）

i, j が時区間のとき i∩j は、単に&lt;b&gt;T&lt;/b&gt;の部分集合の共通部分として定義する。空区間を認めたので、この演算は、時区間のなかでwell-defienedとなる。

∧と∩を組み合わせて、

- (A, i)∧(B, j) = (A∧B, i∩j)

と定義する。これも&lt;strong&gt;ミート&lt;/strong&gt;。言い忘れていたが、(⊥, i)は、iが何でもあっても(⊥, 0)と&lt;em&gt;同一視&lt;/em&gt;する。(⊥, 0)は絶対的空（どこにもない）の意味。(⊥, 0)を&lt;strong&gt;Θ&lt;/strong&gt;と書くことにする（形が0に似てるから）。(A, 0)と(B, 0)も同一視したほうがいいかどうかは、まだ分かってない。

- (a∧b)∧c = a∧(b∧c) （結合的）
- a∧Θ = Θ∧a = a （単位的）
- a∧b = b∧a （可換）
- a∧a = a （ベキ等）

となるから、イベントの全体はベキ等可換モノイドとなる。ミート半束とか呼ぶこともあるね。a⊆b ⇔ a∧b = a として順序が入る。a⊆b のとき、イベントaはイベントbに&lt;strong&gt;含まれる&lt;/strong&gt;、あるいは、aはbの&lt;strong&gt;部分イベント&lt;/strong&gt;と言おう。

今日はここまで。

</body>
</day>
<day date="2008-12-13" title="">
<body>
*1229138718*[msched][WCC]イベントのR構造と状態空間

あたらめて、msched -- meeting scheduler ね。

ラベルLを固定する。ボトム⊥を入れて、Lはミート半束の構造を持つ。アフィン時間&lt;b&gt;T&lt;/b&gt;の区間の全体も共通部分でミート半束。これらの直積をとり、ボトムの部分をつぶす（つぶし方は複数ある）とまたミート半束。こうやって作ったイベントの半束(Ev, ∧, Θ) が舞台。物理で言えば配位空間。∧から導かれる順序は⊆で表す。

もう少しイベント間に定義できる基本関係：

- a∧b が空である ⇔ aとbは&lt;strong&gt;分離&lt;/strong&gt;している、離れている
- a∧b が点イベント ⇔ aとbは&lt;strong&gt;隣接&lt;/strong&gt;している、接触している
- a∧b が空か点 ⇔ aとbは&lt;strong&gt;無衝突&lt;/strong&gt;である。

2つのイベントが衝突していればダブルブッキング。通常は不整合とするが、不整合もとりあえずは許す。不整合も「普通に」扱わないとダメだってことは、文書のvalidationでさんざんに経験したこと。不整合を拒絶するアプローチはどうせ破綻する。そもそも「不整合」という概念や用語を入れるべきじゃないかもしれない。

&lt;h5&gt;相対イベント&lt;/h5&gt;

a, bがイベントで、a⊆b であるとき、組(a, b)を&lt;strong&gt;相対イベント&lt;/strong&gt;と呼ぶ。「bのなかで起きたa」という意味。あるいは、bがタイムコンテナで、「bのなかでアロケートされたa」という感じか。bはaの親イベントってことになる。

任意のイベントaを相対イベントとみなす方法は2つある。

+ (a, a)とする。
+ a = (A, i) として、(A, &lt;b&gt;T&lt;/b&gt;)を親とする。

&lt;h5&gt;イベントの和&lt;/h5&gt;

a = (A, i), b = (B, j)が隣接しているとき、隣接の定義から A = B となる。iとjの集合論的合併は再び時区間になる。(A, i∪j) を、aとbの&lt;strong&gt;和&lt;/strong&gt;と定義する。

イベントの族Kが次の条件を満たすとする。

+ a, b∈K、a≠b なら、aとbは無衝突である。
+ a∈K に対して、aと隣接するイベントb∈Eが存在する。

上の条件を満たす族に対しては、和（総和）が定義できる。よって、そのような族を&lt;strong&gt;総和可能&lt;/strong&gt;（summable）と呼ぶことにする。

イベントの族Kが総和可能のとき、その和を ΣK と書く。

&lt;h5&gt;原子イベントと有効イベント&lt;/h5&gt;

AE⊆Ev を天下りに与えて、AEの元を原子イベントと呼ぶ。次の条件を入れておく。

- 空イベント、点イベントは原子イベントには入らない。原子は必ず拡がりを持つのだ！
- 2つの異なる原子イベントは無衝突である。接触は許す、貫入はダメ。

与えられたAE上で、(A, i)が有効イベントとは、「原子イベント、または有限個の原子イベントの和として書けること」。定義より、空イベントや点イベントは有効イベントになりえない。

&lt;h5&gt;R構造&lt;/h5&gt;

ラベル集合Lと原子イベントの集合AEを固定する。すると、その上で有効イベントの集合EEが確定する。Lとは別にラベルの集合Rを用意する。Rは何でもいいが、通常は有限集合である。

イベントの&lt;strong&gt;R構造&lt;/strong&gt;、または&lt;strong&gt;Rイベント構造&lt;/strong&gt;は次のように定義される。

- 有限な台集合D⊆EE。
- r∈Rに対してD上の二項関係が対応している。

特殊なケースとして台集合Dは空であってもよい。Rは空ではないと仮定する（最低でも1つの記号を含む）。R構造は、Dを頂点集合とする、辺ラベル付き有向グラフとなる。r∈Rを固定すると、単純有向グラフになる。R構造は&lt;strong&gt;Rグラフ&lt;/strong&gt;と言ってもいいだろう。

R構造は、ある瞬間での状態データと考えるので、我々の考察の領域は、Rを固定してすべてのR構造からなる集合である。システムの状態遷移はR構造の空間のなかで軌跡を描く。これから、R構造の空間＝状態空間に対するオペレーションを定義していく。オペレーションはアトミック（トランザクション）である。

オペレーション＝コマンドを定義するとは、

+ コマンドの事前条件をR構造の言葉で記述する。
+ コマンドの効果をR構造の言葉で記述する。
+ 状態に対する不変条件（述語）を記述する。

コマンドの定義とかはまた次。

</body>
</day>
<day date="2008-12-15" title="">
<body>
*1229334168*[msched][WCC]mschedの用語法、大幅変更

「イベント」をコンピュータ屋さんが聞いたら、まずアノテの「イベント」を思い起こすよな。これじゃ、まともにコミュニケーションできない。時相論理とかではイベントも使っていたと思うが、ともかくイベントは止めよう。代替候補は：

+ タイムリソース
+ タイムスパン
+ タイムセグメント
+ タイムインターバル

それと、イベント、じゃねーや、（とりあえず）タイムリソースの入れ子構造／親子構造だけは特別扱いすることにする。つまり、最初から木構造を考えて、木を構成する辺には特別なラベルを付けないでいいとする。&lt;strong&gt;タイムツリー&lt;/strong&gt;と呼ぶことにする。DOMツリーのイメージでいいだろう。

R構造も、もっと直接的に&lt;strong&gt;スケジュール構造&lt;/strong&gt;とか呼ぶことにしよう。汎用性があるデータ構造だから、あまり特定目的に縛られたネーミングはしたくないのだけど、背に腹は代えられない。

スケジュール構造は複数のタイムツリーからなり、それらツリーを構成するノード＝タイムリソースの間を結ぶラベル付き辺（&lt;strong&gt;リンク&lt;/strong&gt;）を含めた構造。ツリーに関する操作はまー分かるだろう。それに、木を越えた（越えないときもあるが）リンクを張ることになる。ツリー構造の辺はいちいちリンクとは呼ばないことにする。リンクは、親子構造とは別な関連性を示す。


</body>
</day>
<day date="2008-12-16" title="">
<body>
*1229394345*[WCC][プログラム意味論][その他プログラミング]APIの分類とか記述とか

当然に、メイヤー先生のQuery/Commandスタイルを採用するのだ。が、CommandよりOperationのほうが好きなので、Query/Operationスタイル。

&lt;b&gt;[追記]&lt;/b&gt;以下、非同期に関して混乱した記述があるが、まー、いいや（ママ）。それと、APIのアクセス制御の問題があるが、それはまた。&lt;b&gt;[/追記]&lt;/b&gt;

- Query APIは、状態とか状態から計算される量を取得するAPIであり副作用は一切ない。
- 問い合わせ結果は通常、関数の戻り値で返す。が、遅れがある場合はメッセージで非同期に返すかもしれない。
- Operation APIは、状態の変更を要求する。戻り値はvoidだが、失敗や例外を通知する必要があるかも知れない。このときも、通知は遅れる可能性がある。

他にイベントがある。イベントは戻り値も例外もなく、単に送るだけ。

- Query -- 常に twoway（go and back, request and reply/response）
- oneway Operation -- requestのみで、結果は知らん。または、結果は後から非同期で来る。
- Operation -- 成功失敗や例外が戻り値で同期的に返ってくる。
- Event -- 常にoneway

なんらかのリクエストに対して、後から返る（かもしれない）通知はeventではあるが、区別して呼んだほうがいいかもしれない。notificationかな。あと、Eventとoneway Operationの区別も微妙だなー。

それはともかく、Query, Operation, Eventがあると、その使い方が問題になる。使い方を規定するのがプロトコル。プロトコルとは、Query, Operation, Eventの発行（issue）と、それに伴う状態遷移（正確に言えば、内部状態ではなくて、観測者が想定する抽象状態、以前僕はステージと呼んでいたやつ）の時系列を記述したもの。図で描くならシーケンス図みたいなものを使うかな。

プロトコルの記述に遷移生成系（トランスデューサ）が使えたりする。

*1229401553*[WCC][その他プログラミング]ブール値投票のプロトコル

事前に次の事項を決めておく。

+ 投票開始と終了の時間
+ 有権者とその階層分け
+ 棄権の時の扱い →無効、賛成（true）、反対（false）
+ 有効投票数の最低値；それに満たないときは、投票そのものが無効となる、ただし、棄権を賛成／反対とみなす規約があれば、棄権は有効票になる。

投票が終わると集計と判定をする。そのとき、判定基準／手続きが必要。有権者が二階層に分けられているとして以下記述する（n階層でも同じ）。階層1と階層2とする。

各有権者の投票結果は、数値1と0でエンコードされ、総投票数はN&lt;sub&gt;1&lt;/sub&gt;、N&lt;sub&gt;2&lt;/sub&gt;とする。有効な投票結果を並べたベクトル（ビット列に見える）をv&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;とする。

判定関数fは、投票結果ベクトルを受け取って、0か1、または[0, 1]内の実数値を返す。次があれば十分だろう。

+ min(v) -- 全員一致でないと賛成とならない。
+ floor(ave(v)) -- 多数決。同数なら否決（0 = false）
+ ceiling(ave(v)) -- 多数決。同数なら可決（1 = true）
+ ave(v) -- 実数の比率（階層2で決める）

階層1の判定関数をf&lt;sub&gt;1&lt;/sub&gt;として、r&lt;sub&gt;1&lt;/sub&gt; = f&lt;sub&gt;1&lt;/sub&gt;(v&lt;sub&gt;1&lt;/sub&gt;) とする。整数値とみた値r&lt;sub&gt;1&lt;/sub&gt;を階層2に反映させる関数をgとする。次のようなgが考えられる。

+ 恒等関数
+ 定数mを使った m*r&lt;sub&gt;1&lt;/sub&gt;
+ 定数w（実数の重さ）とN&lt;sub&gt;1&lt;/sub&gt;を使って、w*N&lt;sub&gt;1&lt;/sub&gt;*r&lt;sub&gt;1&lt;/sub&gt;

最終的な結果は、f&lt;sub&gt;2&lt;/sub&gt;(v&lt;sub&gt;2&lt;/sub&gt;, g(r&lt;sub&gt;1&lt;/sub&gt;))で決まる。

全体の結果を可決、否決、未決と分けると、それぞれの後に来るアクションを決めておく必要がある。

+ 終了 成功裏に終わった
+ 破棄 なかったことにする
+ 保留 後日に持ち越す、再投票かもしれない

他に、有権者であることの確認（認証）、重複投票の予防、投票の告知、誘導、催促などが必要

</body>
</day>
<day date="2008-12-17" title="">
<body>
*1229507446*[WCC][Erlang]無限大を含む算術（x_arith）

Int = &lt;b&gt;Z&lt;/b&gt; = {..., -1, 0, 1, 2, 3, ...}、XInt = Int + {∞, -∞} とする。他に全体集合T（total, universal, あるいはterm）を考えて、すべての領域はTの部分集合だとする。圏論で定式化したいなら、Tを固定して、モノ射 X→T だけを考えたスラント圏（ほぼsubobjectsの圏）を考えればいいだろう（たぶん実際はもっと工夫が必要）。

X, YとかがTの部分領域だとして、射として部分関数 f:X⊃→Y を考える。D(f)⊆X をfの定義域、U(f)⊆X をfの未定義域とする。dom(f) = X = D(f)+U(f)（直和）となる。別に集合E, Fを準備して、Eを例外の値、Fをエラーの値とする。exceptionもerrorもEだから、faultのつもりでerrorの集合はFとした。EもFも単元集合としても本質は失わない。

f:X⊃→Y は、X→Y+E に持ち上げることができて、直和に関するモノイダルスタンピング・モナドになるだろう。このモナドのKleisli圏Kをとりあえず作ると、XやYはKの対象になる。射は、D(f)で値を計算し、U(f)では例外を起こすような関数。

次に、Kの射を T→T の部分関数とみなす。dom(f)⊆T で、K内で考えれば dom(f)でfは完全に定義されるが、dom(f)の外では定義されない。dom(f)の外ではFの値をとるとして、T→Tに拡張する。この定式化で算術的例外（エラーではない）とbadargランタイムエラーはだいたいモデル化できるだろう。だいたいだけどね。

ここからは、プログラミング上の問題：

まず、T上で定義された述語をいくつか定義した。T→&lt;b&gt;B&lt;/b&gt;（&lt;b&gt;B&lt;/b&gt;は真偽値集合）。

- XInt上の述語も定義すべきかどうか&lt;em&gt;悩む&lt;/em&gt;。これは実用上、使い勝手の問題だけど。
- ゼロ除算はbadarithのエラーとするか、自前の例外とするか悩む。標準算術じゃないから自前の例外。
- エラー（ランタイムエラー）は、すべてbadargとするのが良さそうだが、それをすると、ソースコードが煩雑になるから、なにかエラーが出ればそれでいいとする。意味的には badarithだが、他のエラーのこともあるのだ。このへんの匙加減はホーントに難しいな。ソースがあるのが前提なら、あまり神経質にならんでもいいが、ソースなしのときにも親切なエラー報告をするとなると辛いものがある。

現実的な妥協点としては、ソースがないときのことは考えなくてもいいんじゃないのかな。「ソース見て調べろ」と。


</body>
</day>
<day date="2008-12-18" title="">
<body>
*1229581542*[連絡的]grepに似たプログラム

適当な名前（strfindとか）で、ファイルから文字列を探し、発見したらその行を表示するプログラムを作れ。
&lt;pre class=&quot;out&quot;&gt;
$ strfind # これはエラー
$ strfind abc # abcを標準入力から探す
$ strfind abc file.txt # abcをfile.txtから探す
$ strfind abc file1.txt file2.txt # abcをfile1.txtとfile2.txtから探す
&lt;/pre&gt;

出力（表示）の形式とかは各自考える。オプションを付けるのもいい。


</body>
</day>
<day date="2008-12-19" title="">
<body>
*1229664580*[論理][トレース／コンパクト閉圏]片側シーケント

Γ ⇒ Δ がシーケントだとする。Γ ⇒  または  ⇒ Δ の形を片側（one-sided）シーケントと呼ぶ。例えば、 ⇒ Δ だけを考えて片側シーケント計算ができる。双対的に、Γ ⇒  だけの計算もできる。これは一見ナンセンスに見えるがそうではない。

まず、両側シーケントがいつでも片側にできるわけではない。非古典論理では、片側に変形できないものがある。この片側にできる／できないが、圏、複圏、多圏の違いに（ある程度は）関係している。

片側にできると、それは圏が非常に高い対称性をもっていることになる。典型的な例は、コンパクト閉圏。この文脈では、片側シーケントは、name, conameに対応する。別な言い方をすれば、ゲーデル符号化、ノイマン式プログラム、カリー化ともいえる。片側シーケント ⇒ Δ は、単に論理式（の並び）Δと同一視できるように見えるが、そうではない。圏で言えば、対象と射が同一視できないのと同様に同一視できない。もちろん、特定文脈での同一視はあるけれども。


</body>
</day>
<day date="2008-12-25" title="">
<body>
*1230162997*[リンク][オフトピック]山野さん

サッカー解説者 山野さん
- http://www.seeding.co.jp/talent/yamano.html

*1230162998*[リンク][WCC]テンプレート

- http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf

英語（つうか英単語）がスゲー難しい。

*1230163170*[連絡的]手と目を使え、体を動かせ、考え込む前にやってみれ

標準のライブラリ関数の使い方とか、あるいはライブラリ関数じゃ不足／不適切で自前の関数で置き換える事とか、メモリ管理の難しさとか、ともかく経験しないとナニもはじまらないし、前に進めるわけもない。

僕は根性主義は大嫌いだが（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060331/1143775244&quot;&gt;「アンチ根性 ミニリンク集」&lt;/a&gt;）、「体を動かす」、「経験する」ことは根性論とは全然別な話。
&lt;hr&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20080403/1207196994&quot;&gt;僕が沖林さん騒動を詮索する理由と、結局判断できないでいること&lt;/a&gt; （コメント欄も面白い）

沖林さんは、デタラメなCの解説を書いてしまったのだけど、ほんとの事情は謎。しかし確実に言えることは、彼は経験を積んでいないし、自分で手を動かして確認もしなかった。

まったく別な話題なのだけど：
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20081020/1224461181&quot;&gt;理念よりトレーニング&lt;/a&gt;

郡司さんもデタラメを書く人。ある種天才的なんだけど、頭でしか理解してないから、勝手な解釈のもと、インチキな計算しかできない。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20081209/1228787991&quot;&gt;子供と大人、あるいは技術的成熟度&lt;/a&gt;

単眼／近視眼、視野狭窄、稚拙なタコツボ的党派主義も（別な原因もあるけども）トレーニング不足。

</body>
</day>
<day date="2008-12-27" title="">
<body>
*1230341148*[リンク][オフトピック]ジャパネットたかた

今、できることなら弟子入りしたい人ナンバーワンは、たかた社長だ。せめて動画でも見て参考にしたいわけだが：

- http://www.japanet.co.jp/shopping/tv/index.html

たかた社長があんまり出てないな。

- http://www.japanet.co.jp/shopping/js242/js_mc.html

MCのトップはもちろんたかた社長だけど。

</body>
</day>
<day date="2008-12-29" title="">
<body>
*1230520280*[課題][モノイド圏][モナド]双対と随伴

- 「ストリート 双対 随伴」の検索 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%b9%a5%c8%a5%ea%a1%bc%a5%c8%20%c1%d0%c2%d0%20%bf%ef%c8%bc
- 「ケリー双対 左双対」の検索 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%b1%a5%ea%a1%bc%c1%d0%c2%d0%20%ba%b8%c1%d0%c2%d0
- 「池袋」の検索http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%c3%d3%c2%de
- 「池袋」の検索（本編） http://d.hatena.ne.jp/m-hiyama/searchdiary?word=%c3%d3%c2%de

これらを印刷すると、けっこうな枚数になった。改めて読んで&lt;em&gt;総括したい&lt;/em&gt;ところ。

それにしても、寒いのは苦手だ。

</body>
</day>
<day date="2009-01-03" title="">
<body>
*1230973438*[モノイド圏]一般化距離空間、坂道空間

もう正月はいいや。普通に戻りたーい。

ウィリアム・ローヴェルのアレなんだが、(a o- b) = max(a-b, 0) という制限差により、[0, ∞]自体、一般化距離空間になる。これは、[0, ∞]を高度と考えた坂道の空間で、距離は、なんらかの意味で移動の労力（滑り降りるのは労力が0）と考えることができる。

[0, ∞]は対称モノイド閉圏で、自然にそれ自身が[0, ∞]豊饒圏になるが、そのとき作られる自己豊饒圏が坂道の空間。豊饒関手や豊饒自然変換も定義できる。豊饒関手はコントラクション（正確に言えば非増大写像だがね）。

&lt;b&gt;[追記]&lt;/b&gt;坂道よりすべり台のほうがふさわしいと思うので、すべり台空間にしよう。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2009-01-04" title="">
<body>
*1231060673*[モノイド圏]豊饒版の米田の補題

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090103/1230973438&quot;&gt;昨日：&lt;/a&gt;
&gt;&gt;
もう正月はいいや。普通に戻りたーい。
&lt;&lt;

名目上は明日から始動だし、今日の曜日は&lt;b&gt;日曜&lt;/b&gt;でもあるが、アタマが腐りそう（いや、腐っているか？）だから、なんか書いておこう。

&quot;Short Introduction to Enriched categories&quot; の第2章、つまり後半の豊饒圏論の7ページ分をざっと読んだ。この論説の結論的主張は、Vが完備対称モノイド閉圏（complete symmetric monoidal closed category）であるとき、通常の（古典）圏論のほとんどの結果はV-豊饒圏（V-enriched category, V-category）に対しても成立する、というものだ。

その典型例として、米田の補題のV-豊饒版（V-enriched version）がある。Vが完備対称モノイド閉圏で、/V/はVの自然な自己豊饒圏（canonical self-enriched category）とする。この状況で、Cが&lt;em&gt;小さい&lt;/em&gt;V-圏（small V-category）、F:C&lt;sup&gt;op&lt;/sup&gt;→/V/ がV-関手（FはC上では反変）であるならば、F(a) ≒ Nat(F, C(-, a))  が&lt;em&gt;V内で&lt;/em&gt;成立する。

これの特殊事例として、V = [0, ∞] とした場合を考える。一般化距離空間/V/の台集合をPと書く。/V/ = (P, d&lt;sub&gt;/V/&lt;/sub&gt;)は自己豊饒圏＝標準的な一般化距離空間＝坂道（or 滑り台）空間。

X = (|X|, d&lt;sub&gt;x&lt;/sub&gt;),  は一般化距離空間、f:X→/V/が反変の縮小（非増大）写像だとする；これは、d&lt;sub&gt;/V/&lt;/sub&gt;(f(a), f(b)) ≦ d&lt;sub&gt;X&lt;/sub&gt;(b, a) を意味する。この状況下で、任意のa∈|X|に対して、f(a) = |f, d&lt;sub&gt;X&lt;/sub&gt;(-, a)| が成立する、というのが米田の補題。ここで、|f, g| は、2つの縮小写像の間の一般化距離で、最小上界∨を用いて、|f, g} = ∨&lt;sub&gt;t∈X&lt;/sub&gt;[d&lt;sub&gt;Y&lt;/sub&gt;(f(t), g(t))] と書ける。最小上界の存在は、Vの完備性として仮定されている。証明は、指数＝制限差、直積＝最小上界の定義に気を付けならば不等式評価を行う。不等式の向きとかは少しややこしい。

|* 一般論 |* 特殊事例 |
|モノイド圏 | 全順序モノイド|
|対象 | 元|
|射 |順序≦のインスタンス対 |
|モノイド積 |足し算 |
|モノイド単位 | 0 |
|閉性 | 制限差の存在 |
|指数 | 制限差|
|対称性 | 可換性|
| 直積 | 最小上界 |
|終対象 | 0 |
|始対象| ∞ |
|圏の完備性 | 順序の完備性|
|V-圏 | 一般化距離空間 |
|V-関手 |縮小写像（コントラクション） |
|V-自然変換 |縮小写像のあいだのある関係 |
|Nat(F, G) |縮小写像の一般化距離 |

坂道空間（すべり台）以外に、辺に非負実数の重みを付けた単純有向グラフから作られた一般化距離空間がある。この例はマスロフ脱量子化に関係するから、具体的に詳しく調べると楽しそうだ。ローヴェルの指摘とマスロフ理論を融合できるかな？


</body>
</day>
<day date="2009-01-05" title="">
<body>
*1231149206*[モノイド圏]一般化距離空間のもうひとつの例

一般化距離空間はけっこう面白いな。d(x, y) = 0 ⇔ x≦y または双対的に、d(x, y) = 0 ⇔ x≧y と定義すると順序構造ができる。普通の距離では、この順序は自明（離散順序）にしかならないが、一般化距離では自明でない例が作れる。また、順序構造に対して、距離の値が0か∞とした一般化距離が定義できるから、Ord→GMetという埋め込み関手も作れる。いずれにしても、Ordとの強い関係があるのがメリットだ。

Xがコンパクト距離空間（普通の距離！）のとき、2つの非空閉集合 A, B⊆X に対してハウスドルフ距離（Hausdorff metric, Hausdorff distance）D(A, B)が定義できて、非空閉集合全体の空間が再び普通の距離空間になる。∞を許せば、空集合を入れても別にかまわない（&lt;b&gt;[追記]&lt;/b&gt;ちょっと面倒になるかも&lt;b&gt;[/追記]&lt;/b&gt;）。

通常のハウスドルフ距離を定義するとき、非対称な（正確に言えば対称とは限らない）δ(A, B)を定義して、D(A, B) = max(δ(A, B), δ(B, A)) として対称化している。普通の距離Dを入れたCl(X)（Xの閉集合の全体）もかなり面白いが、非対称なδをそのまま使ってもこれまた面白い。特に、「Aが非空でδ(A, B) = 0 ⇔ A⊆B」が成立する。

内部を持つ閉集合に限って、A∩B が空でないときにAとBを辺で結び、辺の重さ（コスト）を非対称ハウスドルフ距離で与えたグラフが作れる。このグラフをチェック複体のように考えることができないだろうか？ フィンスラー幾何学((発音は「フィンズラー」のほうが近いと聞いたことがある。))とか有向ホモトピー（グランディス）とかとの関係もなんかありそうな？

まーともかく、これは予想以上に楽しいオモチャだ。

&lt;b&gt;[追記]&lt;/b&gt;まとめておくの忘れたわ、典型的な例は：

+ すべり台空間＝Vから作られた標準的な自己豊饒圏
+ 辺重み付き単純グラフから作られた一般化距離空間
+ 順序集合から自明に構成できる例
+ コンパクト距離空間の非空閉集合に片側ハウスドルフ距離を入れた空間

&lt;b&gt;[/追記]&lt;/b&gt;


</body>
</day>
<day date="2009-01-06" title="">
<body>
*1231218200*[リンク][論理][圏一般論]閉圏や反射的対象の論文

随分古いのがある。プロジェクト・ユークリッドは助かるなー、感謝。

- COLIMITS IN TOPOI 1973 -- http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?handle=euclid.bams/1183535542&amp;view=body&amp;content-type=pdf_1
- Cartesian closed categories, quasitopoi and topological universes 1986 -- http://dml.cz/bitstream/handle/10338.dmlcz/106447/CommentatMathUnivCarol_027-1986-2_4.pdf タイプ打ち原稿に手書きの絵、古典の香り(?)
- バエズのラムダ計算テキスト これは新しい http://math.ucr.edu/home/baez/qg-winter2007/lambda_calculi.pdf
- Liniear logic, domain theory and semi-functors 1990 -- http://www.cs.uu.nl/research/techreps/repo/CS-1990/1990-34.pdf
- EXPONENTIABILITY IN CATEGORIES OF LAX ALGEBRAS 2003（新しめ）http://www.tac.mta.ca/tac/volumes/11/15/11-15.ps

*1231234044*[論理][圏一般論]全然知らないことが山盛り載っていた

1990年の &quot;Liniear logic, domain theory and semi-functors&quot;（http://www.cs.uu.nl/research/techreps/repo/CS-1990/1990-34.pdf）をざっと眺めた。おもしろーい。

それほど難しくはないのだが、僕がまったく知らないことが色々と書いてある。ジラール圏（Girard category）、カロウビ展開圏（Karoubi envelope）、弱デカルト閉圏（weak CCC）、非外延的ラムダ計算（non-extensional）、質的領域（qualitative domain）とか。

半関手（semi-functor）、半コモナド（semi-comonad）、半クライスリ圏（semi-Kleisli category）などのsemi-notionsも全然聞いたことなかった。of-course演算 ! が半関手なんだそうな。フーン。

線形圏の定義があって、Relが線形圏の例として挙げられている。ベキがexponent functor C&lt;sup&gt;op&lt;/sup&gt;×C→C として定義されているのも面白い。RelがFdHilbと似てるとは、ボブ・クックも言っていたが、どちらも線形圏なわけだ。フーン。

*1231234045*[論理][圏一般論][プログラム意味論]反射的対象とスノーグローブな世界

反射的対象（reflexive object）に関する良い文献が見つからないなー。まー、いいか。

ベキ（指数）を持つ圏において、[A, B]をベキ対象（power object, exponent, exponential object）だとする。対象Rが反射的とは、[A, A]がAと同型になること。デカルト圏の終対象1は反射的だが、これはつまらない。つまらない例を排除するには、任意のAに対して、A→R というモニックの存在を仮定すればいいが、この条件は何か名前が付いているのだろうか？ 普遍的（universal）と言いたくなるが、普遍的には別な意味があるからダメだろうな。

ともかく、“十分に大きな”反射的対象Rがあれば、そのRのなかに圏全体Cを埋め込むことができる。おおよそ（不正確だが） C⊆R、R∈C と考えていいわけだ。すると、C→C の関手はR→Rの射で表現できるから、[R, R]に入ると思ってよい。ところが [R, R]=R だ（とみなせる）から、関手でさえRのなかに入る。同様に自然変換もRに入る。Cから構成的に作られるすべての圏からなるレルムがCの対象Rのなかに埋め込むことができる。世界がをモノに投影できるだけじゃなくて、複数の世界からなる宇宙も呑み込むようなモノがRだ。

ここらへんは、スノーグローブまたはマイクロコスモスの原理、日本風に言えば箱庭の原理だな。世界はマトリョーシカの構造を持つ。スノーグローブはバエズ（Baez）の言葉だが、豊饒圏についてバエズはピノキオだと言っていた； 生まれたときは圏に似てはいるが圏ではない、しかし後で圏にしてもらえる、てな意味。さすがにバエズ、スノーグローブもピノキオも面白い例えだ。スノーグローブとピノキオは、再帰的世界観を支えるものすごく重要な概念だ。

*1231236918*[論理][用語法][まとめ]論理の用語、日本語-英語

毎度毎度、、、  &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060930/1159604705&quot;&gt;さまざまな「ならば」達&lt;/a&gt;も参照。

&lt;h5&gt;構文&lt;/h5&gt;

+ 項 term
+ 基礎項＝閉じた項 ground term = closed term
+ 論理式 formula
+ 閉じた論理式＝文 closed formula = sentence
+ 命題論理式 propositional formula
+ 言明 statement
+ 素論理式＝原子論理式 prime formula = atomic formula
+ 複合論理式  composite formula
+ 否定 negation
+ 連言 conjunction
+ 選言 disjunction
+ 結合子 connectives
+ 条件法 conditional
+ 双条件法 biconditional
+ 含意 implication

&lt;h5&gt;意味&lt;/h5&gt;

+ 不定論理式 indefinit formula
+ 妥当式 tautology = valid formula
+ 充足可能 satisfiable
+ 帰結 consequence
+ 伴意 entailment
+ 付値 assignment, valuation

「|=」 の右に書かれるのが帰結。

&lt;h5&gt;推論と証明&lt;/h5&gt;

+ 演繹 deduction
+ 証明 proof
+ 演繹系 deduction/deductive system
+ 証明系 proof system
+ 証明図 proof-figure
+ 証明木 proof-tree
+ 推論規則 inference rule, rule of inference
+ 構造規則 structure/structural rule
+ 論理規則 logical rule
+ 演繹可能 deducible
+ 証明可能 provable
+ 始式（始シークエント） beginning sequent, initial sequent
+ 終式（終シークエント） end sequent
+ 上式（上シークエント）upper sequent
+ 下式（下シークエント）lower sequent
+ 主論理式 principal formula
+ 副論理式 side formula
+ 仮定 assumptions
+ 結論 conclusion

A, B |- C のとき、CはA, Bから演繹可能、特に |- C のときCは証明可能（仮定なしで演繹できる）というのだそうだ。

前提 premise/presupposition をどういう意味で使うかよく分からない。シークエントに関しては前件、後件という言い方もあったな、確か（いや、不確か）。

&lt;b&gt;[追記]&lt;/b&gt;藤川さんの本では、シークエントの左右は単に左辺、右辺を使っている。Proof Theoryの本では、左がantecedent、右がsuccedent、これが前件、後件に対応する語だと思う。ただし、構文的には antecedent、succedentでも、意味的に語る文脈では premises, conclusionsを使っている。LKのときは結論も複数なのでsが付く。LJでは単数形。premisesは前提と訳すのがいいのかな？ まっ、仮定、前提、前件を神経質に区別するほどのことではないと思う、left-hand side, right-hand sideでも十分だし。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;その他&lt;/h5&gt;

+ 対偶 contraposition
+ 矛盾 contradiction
+ 矛盾する contradict, inconsistent
+ 独立 independence
+ 整合する、無矛盾な consistent
+ 整合性 consistency
+ 決定可能 decidable
+ 完全性 completeness
+ 健全性 soundness
+ モダスポネンス modus ponens （最後はs）

</body>
</day>
<day date="2009-01-07" title="">
<body>
*1231299181*[モノイド圏][論理]豊饒圏から圏を作る -- ピノキオと人間

Vが対称モノイド閉圏だとして、□がモノイド積、[-, -]はベキ（指数）とする。そのとき、対象A, B, Cに対して、V内で結合を与える射c&lt;sub&gt;A,B,C&lt;/sub&gt;:[A, B]□[B, C]→[A, C] を定義したい。

まず、次の自然演繹証明図を考える。

&lt;pre&gt;
        A⊃B   A
       ----------[MP]
  B⊃C   B
 ----------[MP]
     C
&lt;/pre&gt;

これから、[B, C]□[A, B]□A → C が得られる。[B, C]と[A, B]に対称（置換、入れ替え）σ&lt;sub&gt;[B,C],[A,B]&lt;/sub&gt;を適用すれば、[A, B]□[B, C]□A → C、これをカリー化すれば、[A, B]□[B, C] →[A, C]。□の優先順位が強いとして、具体的に書き下すと：

- Λ&lt;sub&gt;[A,B],[B,C]&lt;/sub&gt;&lt;sup&gt;A&lt;/sup&gt;(σ&lt;sub&gt;[B,C],[A,B]&lt;/sub&gt;□id&lt;sub&gt;A&lt;/sub&gt; ; id&lt;sub&gt;[B,C]&lt;/sub&gt;□ev&lt;sub&gt;A,B&lt;/sub&gt; ; ev&lt;sub&gt;B,C&lt;/sub&gt;)

次にV-豊饒化している状況を考える。CがV-圏のとき、f:A→B, g:B→C in C は、f:I→C(A, B), g:I→C(B, C) in V のことだと解釈。Δ:I→I□I は単位律を使って定義可能だから、ペアリング&amp;lt;f, g&gt;を、Δ;(f□g) で定義できる。c&lt;sub&gt;A,B,C&lt;/sub&gt;:C(A, B)□C(B, C)→C(A, C) があるから、fとgの結合f;g は &amp;lt;f, g&gt;;c&lt;sub&gt;A,B,C&lt;/sub&gt;:I→C(A, C) として定義できる。

以上の方法を使うと、V-圏Cに対して、普通の圏Dを D(A, B) = V(I, C(A, B)) で定義できる。こうすれば、f:A→B in C は、f∈D(A, B)のことだとも解釈できる。記号の乱用をして、f:A→B in C ⇔ f:A→B in D （ちょっと混乱しそうだが）。ホントのことを言えば、Cには対象はあるが、&lt;em&gt;射と呼べるモノ&lt;/em&gt;なんてまったく存在しない、射の集まりに&lt;em&gt;相当するモノ&lt;/em&gt;があっただけなのだ。しかし、Dには確かに射が存在し、普通にここで圏論できる。

V-圏Cの概念には、D(A, B) = V(I, C(A, B)) を使った普通の圏が常に付きまとっている。バエズの例えで言うなら、CはピノキオだがDは人間だ。

Cとして、Vの標準自己豊饒圏を取ると、Cから作ったDによりVが再現する。この再現機構は詳しく見ておいたほうがいいだろう。

*1231299242*[リンク][圏一般論][論理]バエズのセミナー資料

- http://math.ucr.edu/home/baez/qg-fall2006/
- http://math.ucr.edu/home/baez/qg-winter2007/
- http://math.ucr.edu/home/baez/qg-spring2007/
- http://math.ucr.edu/home/baez/atmcs2008/

シーリィの1987年の論文 &quot;Modeling computations: a 2-categorical framework&quot; （http://math.ucr.edu/home/baez/qg-winter2007/seely_2-categorical.pdf）を印刷してみた。

&lt;b&gt;[追記]&lt;/b&gt;http://math.ucr.edu/home/baez/atmcs2008/にある&quot;Computation and the Periodic Table&quot;（http://math.ucr.edu/home/baez/atmcs2008/atmcs2008.pdf）も眺めた。なんか、バエズとアブラムスキーが言っていることがソックリなんで笑える。いや、笑っているハナシではなくて、彼らが見ている景色が同じ（少なくとも似てる）ということだ。そして、バエズとアブラムスキーが共通に見ている景色が世界の姿なのかもしれない。それが真実の姿かどうかは別にどうでもよくて、僕にとって面白いかどうか -- すごく面白い。面白ければいいのだ、面白くっても大丈夫。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2009-01-09" title="">
<body>
*p1*[リンク][その他代数]余代数の表現とか

- Title: A BRIEF INTRODUCTION TO COALGEBRA REPRESENTATION THEORY
- Author: William Chin
- URL: http://condor.depaul.edu/~wchin/crt.pdf
- Pages: 18ページ

短いのはいいのだが、基本を知らない僕にはちょっと、、、、

</body>
</day>
<day date="2009-01-10" title="">
<body>
*1231569709*[圏一般論][論理][雑感]スノーグローブ現象

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20060117/1137469335&quot;&gt;ゲーデル化&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080109/1199863428&quot;&gt;レイフィケーション&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20070813/1186984585&quot;&gt;コンパイル&lt;/a&gt;などはすべて同じこと。バエズのスノーグローブも、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20071212/1197437412&quot;&gt;（おそらくは宗教的な起源を持つ）手塚治虫が「火の鳥」で示した世界観&lt;/a&gt;も同じに思える。

要するに、世界を外部からみる視点と世界のなかに棲む主体からの視点の違いだ。外部から眺める（まー、なかの人からみたら超越者・神だ）は、世界の隅々まで完全に把握できるだけではなくて、世界の一部を、「部分集合として」認識できる。この、外からの視点で捉えられた世界の一部を外的集合とでも呼ぼう。たんに世界の一部（部分集合）だけではなくて、それから直積や無限の合併、内包的制限などにより普通に作られるあらゆる集合も外的集合だ。

一方で、世界のなかに棲むなかの人が把握できるのは、世界内にある個物・個体に限る。複数の個体をまとめたものが個体とみなせるとは限らないので、集合概念は使えない。

世界の外にいる超越者が認識できる外的集合はものすごく（気が遠くなるほど）豊かだが、世界のなかでは個体・個物の認識にとどまるから、そとの人（超越者）となかの人の認識能力の差はとんでもないほど開きがある。にもかかわらず、特定の構造に関しては、見える景色に差がない、というのがスノーグローブ現象だ。

スノーグローブ現象のキモは、たちがよい外的集合は、内部の個体によって“表現できる”ということだろう。この“表現”を、コード化、ゲーデル化、レイファイ、まーなんて呼んでもいい。典型例は、圏CのホムセットC(A, B)、これは明らかに外的集合で、なかの人からはまったく把握できない。が、べき[A, B]はなかの人に見えるモノだ。

1が圏Cの特殊な対象（終対象とかモノイド単位とか）として、A⊆C が、A = C(1, X) のとき、外的な集合Aは、内部の個体Xで表現されると考えてよい。この例では、外的な集合Aが、あたかも「Xのelements、またはpoints」の集合とみなせる。外から見た世界の一部分が、世界内個体で実現され、その個体はなかから認識できる、という構図。

V-圏Cにおいて、C&lt;sup&gt;~&lt;/sup&gt;(A, B) = V(1, [A, B]) として定義される通常圏C&lt;sup&gt;~&lt;/sup&gt;は上記の構図を利用している。[A, B]は個体だが、V(1, [A, B])は外的集合となる。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090107/1231299181&quot;&gt;ピノキオから人間を作る&lt;/a&gt;メカニズムだが、別な言い方をすると、なかの人が見ている擬似的な圏から、そとの世界（人間の世界じゃなくて、むしろ神の国）で認められる超越的な構造を作っている。もっとも、超越的な構造のほうが「普通」で、個物により組み立てた擬似的な圏のほうが偽物あつかいされているが。

カリー化、ゲーデル・コーディング、レイフィケーションは、結局はベキ（指数）のことだ。ベキがあると、外からの視点を完全にシミュレートする内的なレプリカが作れる。外に出ることなく、世界の内部に、その世界自体の完全な模型（ミニチュア）を作れる。模型を操作することにより、なかの人がそとの人とまったく同じ経験をできる。この、「なかにいるのに、そとにいる」がなにか非常に不思議な感じを抱かせるのだろう。実際、これは非常に不思議で、理知的に理解したつもりでも、ほんとの納得感が得られない。外に出ることは不可能なのに、どうして自分は「外にいるのと同じ」とわかるのだろう？ いやっ、外のひとが「コイツは俺と同じ経験をしている」と認識する話なのか。ともかく不思議ィ。

外的集合を内部個体化する最も強烈なメカニズムは完備性だ。極限を取る操作はなかからは見えないが、極限対象は個体だから、その個体を指し示してしまえば、なかの人にも極限対象は見える。そして、その極限対象という個体を通じて外的集合（むしろ部分圏や図式）をある程度は把握できることになる。

*1231569710*[圏一般論][論理]式と推論

シーケント（シークエント）計算と自然演繹の関係を考えるとき、次の対応を想定するとよい。

|＼              | 式  | 推論 |
| 自然演繹       |対象 |  射 |
| 片側シーケント |点射 |  射から導かれるオペレータ |
| シーケント     |射   | オペレータ |

点射（あるいは点、element）とは、1→A という形の射、オペレータは主にホムセットに対して定義される集合論的な操作で、対象や対象の組でindexされたもの。自然変換はオペレータの特殊なもの。結合、トレース、部分トレースなどもオペレータ。射からオペレータが導かれるとは、反変／共変のホム関手がいい例。

片側シーケント計算は、実は田中一之「数の体系と超準モデル」の65ページに出てくる。Gentzen-Tait System GT というのがそれだ。両側シーケントがいつでも片側に変換できるわけではないが、古典論理やコンパクト論理のような対称性が高い論理なら、片側にできる。

あーそれと、あまり脈絡もなく書いておくが、証明図はツリーだと思う必要はないな。別に分岐してもいい。ステファネスクが言うところのフローダイアグラムあたりか。ツルのように多少は絡まってもいい林みたいな図形。

*1231569873*[セミナー]参考書

青いProof Theoryの本のラムダ入門（P.12あたりから）のところはいい。それと、やっぱり青い（濃いツルツル青）のあの定番教科書も。

*1231570306*[モノイド圏][圏一般論]V-豊饒圏の扱い方

V-豊饒圏の扱い方の感覚が少しわかった。こういう感覚はほっておくとすぐに失われるから、今のうちに書き留めておこう（感覚を書き留めるって難しいがね）。

V-圏の対象は集合だから（集合じゃなくすることもできるかもしれないが、いまは考えない）、素朴集合論で扱うことになる。V-圏はもちろん、V-関手、V-自然変換など、すべてが、Vの対象／射のidexed familyになる。CがV-圏なら、各種familyのindex setは|C|、|C|×|C|、|C|×|C|×|C|などになる。indexらしさを出すためブラケットを使うとして：

+ ホム対象 |C|×|C| indexed な対象族 C[a, b]
+ 恒等射 |C| indexed な射族 u[a]:1→C[a, a]
+ 結合 |C|×|C|×|C| indexed な射族 c[a, b, c]:C[a, b]□C[b, c]→C[a, c]
+ 関手の対象パート |C| indexed な対象族（ただし、対象はV内にはない）  F[a]∈|D|
+ 関手のホムパート |C|×|C} indexed な射族 F[a, b]:C[a, b]→C[Fa, Fb]
+ 自然変換 |C| indexed な射族 φ[a]:1→[Fa, Ga]

関手も自然変換も族であるが、関手性（functor-ial-ity）、自然性（natural-ity）はV内の可換図式で表現できる。関手性はダイレクトだが、自然性は少しとまどうかもしれない。

以下では、(a, b) := C(a, b), (a, b)' = D(a, b), a' = F(a), γは結合、εが恒等、モノイド積はjuxtaposition という略記を使って関手性を書き下す。

&lt;pre&gt;
F(f;g) = F(f);F(g)

 (a, b)(b, c) -- F F → (a', b')'(b', c')'
     ｜                      ｜
    γ                       γ
     ↓                      ↓
   (a, c) ----- F ------→  (a', c')'

F(id_a) = id_Fa

  1     ====      1        
  ｜              ｜
  ε              ε
  ↓              ↓
 (a, a) -- F → (a', a')'
&lt;/pre&gt;

V内の等式で書くなら：

- (F F);γ = γ;F
- ε;F = ε

さて、自然性だが、普通に書くと：

&lt;pre&gt;
φ::F⇒G

 Fa - φ_a → Ga
 ｜           ｜
 Ff           Gf     
 ↓           ↓
 Fb - φ_b → Gb
&lt;/pre&gt;

だが、V-自然変換では、φ&lt;sub&gt;a&lt;/sub&gt;:1→[Fa, Ga] という |C|-indexedなVの射族であたえられるから、このままでは解釈でない。次の2つの列に分ける。

+ Fa - φ_a → Ga - Gf → Gb
+ Fa - Ff → Fb - φ_b → Gb

これをさらに：

+ 1 (a, b) -φ_a G →[Fa, Ga][Ga, Gb] → [Fa, Gb]
+ (a, b) 1 - F φ_b → [Fa, Fb][Fb, Gb] → [Fa, Gb]

として、可換性を等式で主張すると：

- (φ G);γ = (F φ);γ

これは、Vの対象 (a, b) と [Fa, Gb] の間の平行対(φ G);γ, (F φ);γ の等値核により自然変換が表現できることを示す。この事情をハッキリとさせるためには、自然とは限らない、関手間の変換について考えないといけない。が、疲れたから後日。

&lt;b&gt;[追記]&lt;/b&gt;あまり日がたつとまた忘れるな。C, DがV-圏なら、ベキ圏D&lt;sup&gt;C&lt;/sup&gt;が再びV-豊饒になる。これは、V-Catがベキを持つってことだから重要。その背景・理由は、Nat(F, G)がVの対象として確定することだが、どうやってNat(F, G)をVの対象だと思えるか？ ってのがヨク考えるべきことで、Vの完備性が効いてくる。

Vが完備だと、|C|⊆|V|であるようなV-圏の記述は、Vの対象と射だけで完結してしまう。雰囲気的に言えば、C⊆V ならば C∈V ってこと。やっぱり詳細は後日か。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2009-01-13" title="">
<body>
*1231808722*[セミナー][論理]単純型付きラムダ

ラムダ計算のセミナーをやるので、[セミナー]タグでネタを記録することにする。

青いProof Theoryの本とは、A. S. Troelstra, H. Schwichtenberg &quot;Basic Proof Theory Second Edition&quot;、著者の読み方（カタカナ表記）はトゥロエルストラ、シュウイッテンブルクかなー？？？ アブラムスキーやアクゼルもエディターになっているケンブリッヂのシリーズ物の一冊。このシリーズの執筆陣の豪華なこと豪華なこと… と、それはまーいいとして。

- 3.6 (P.85)に片側シーケントの古典論理が書いてある。ここだと、Gentzen-Shutte（ゲンツェン／シュッテ）になっている。ん？ ゲンツェン／テイトじゃなかった？
- 8章（p.258）は categorical logic
- 9章（p.283）は様相論理と線形論理

全体にモダンで洗練されている。証明論の本だから当たり前のことだが、モデル論がない。そこがなんかもの足りないね（←別な本読めよ＞自分）。

この本から、simply typed lambdaの項の定義、いつでも肩に型（駄洒落じゃない）を付ける流儀：

+ 型付き変数 x&lt;sup&gt;A&lt;/sup&gt;, y&lt;sup&gt;B&lt;/sup&gt;など。
+ t&lt;sup&gt;A→B&lt;/sup&gt;, s&lt;sup&gt;A&lt;/sup&gt;に対して、App(t&lt;sup&gt;A→B&lt;/sup&gt;, s&lt;sup&gt;A&lt;/sup&gt;)&lt;sup&gt;B&lt;/sup&gt;
+ t&lt;sup&gt;B&lt;/sup&gt;, x&lt;sup&gt;A&lt;/sup&gt;に対して、(λx&lt;sup&gt;A&lt;/sup&gt;.t&lt;sup&gt;B&lt;/sup&gt;)&lt;sup&gt;A→B&lt;/sup&gt;

これから略記を導入する。非常にスッキリ。

同書p.38から、∧と⊃だけの推論：

+ ∧の導入規則
+ A∧B からのAだけ、Bだけを選ぶ消去規則
+ A⊃Bを導入する含意導入規則、ただしAにはラベルを付ける
+ モダスポネンス

この本には書いてないが、構造規則として、換（Exchange）と増（thinning, copy, dup）は入れていいだろう。推論規則のアリティを記しておくと：

+ 換 2→2
+ 増 1→2
+ ∧導入 2→1
+ 射影 1→1
+ 含意導入 1→1 ただし、横から入るループが作られる。
+ モダスポネンス 2→1

*1231818619*[論理]古典的片側シーケントの体系

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090110/1231569710&quot;&gt;式と推論&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090113/1231808722&quot;&gt;単純型付きラムダ&lt;/a&gt;
&gt;&gt;
片側シーケントの古典論理が書いてある。ここだと、Gentzen-Shutte（ゲンツェン／シュッテ）になっている。ん？ ゲンツェン／テイトじゃなかった？
&lt;&lt;

田中さんの言うGentzen-Taitシステムと、A.S.T and H.SのGentzen-Shutteシステムはどうも同じものらしい。Gentzen-Shutte-Taitといえば不公平はないかな。念のため、定義を書いておく。まず田中本より。

- atomic formulaまたはその否定を基本とする。Prologだと、これをリテラルと呼んでいた気がするが、半分忘れた。それと、否定を原子記号に組み込んで極性（polarity）付き記号を使う流儀もあったな、バーワイズがやっていたような、、、参考：&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060726/1153889775&quot;&gt;「多圏上のシーケント計算」&lt;/a&gt;
- 一般のformulaは、∧、∨、∀、∃を結合子、限量子として組み立てる。
- 論理結合子としての否定は考えない。

φ, ψなどは論理式（formula）、αはリテラルだとする。リテラルに限って、￢αが許され、￢￢α = α とみなす。これは双対スターオペレータと同じ。

Tを論理式の集合とする。つまりTはセオリー（の生成系）。公理となるシーケントは：

- φ∈T に対して、⇒φ は公理
- ⇒α,￢α は公理

構造規則は：
&lt;pre&gt;
換
   ⇒Γ
  -------
   ⇒Γ'  （Γ'はΓを適当に入れ替えたもの）


増
    ⇒Γ
  -------
   ⇒Γ,Δ
&lt;/pre&gt;
田中さんも A.S.T-H.S も換を入れる代わりにmultisetを使っているが。次に論理的規則：
&lt;pre&gt;
   ⇒Γ,φ,ψ
  ------------- ∨導入
   ⇒Γ,φ∨ψ


   ⇒Γ,φ   ⇒Γ,ψ
  ------------------ ∧導入
     ⇒Γ,φ∧ψ


   ⇒Γ,φ(t)  （tは項）
  ---------------- ∃導入
   ⇒Γ,∃x.φ(x)


   ⇒Γ,φ(x) （xは変数で、Γに自由に出現しない）
  ------------- ∀導入
   ⇒Γ,∀x.φ

 
   ⇒Γ,￢α   ⇒Γ,α
  -------------------- cut
     ⇒Γ
&lt;/pre&gt;

A.S.T-H.Sでは、∨導入が左右2つある。
&lt;pre&gt;
   ⇒Γ,φ
  ------------- ∨導入1
   ⇒Γ,φ∨ψ


   ⇒Γ,ψ
  ------------- ∨導入2
   ⇒Γ,φ∨ψ
&lt;/pre&gt;
換と増があれば、１つで十分。

それと、田中本では言及されてなかった減がある。multisetと考えればこれは不要。
&lt;pre&gt;
   ⇒Γ,φ,φ
  ----------
   ⇒Γ,φ
&lt;/pre&gt;

cutは次の形。
&lt;pre&gt;
   ⇒Γ,α   ⇒Δ,￢α
  -------------------- cut
     ⇒Γ,Δ
&lt;/pre&gt;
この違いも本質的ではない。

*1231820085*[モノイド圏][お絵描き][人物][リンク]セリンガーえらい！さすが！！

- Title: A survey of graphical languages for monoidal categories
- Author: Peter Selinger
- URL: http://www.mscs.dal.ca/~selinger/papers.html
- Pages: 59

異常天才ぶりでは&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%eb%a1%bc%a5%ea%a5%a8&quot;&gt;ルーリエ&lt;/a&gt;が上だろうが、セリンガーも超優秀； 明晰で洗練されたスタイル、誠実で公平な態度は賞賛に値するね。イケ面だしなっ。

セリンガーは、アブラムスキー派のstrongって用語が不適切だ言って、結局アブラムスキー一派も改宗させてしまったのだが、今回も彼の、用語体系の整合性への希求が感じられる。

&gt;&gt;
The proliferation of different notions is often confusing to non-experts, and occasionally to experts as well.
&lt;hr&gt;
I have resisted the temptation to make major changes to the established terminology. However, I propose some minor tweaks that will hopefully not be disruptive.
&lt;&lt;
英単語：
- proliferation 【名】拡散、まん延、増殖、急増、増設、横行
- disruptive 【形】破壊的な、分裂的な、崩壊的な、混乱を起こさせる、破裂して生じた、秩序を乱す

この論説の冒頭で：

- rigid = autonomous  堅い=自立
- sovereign = pivotal 自足=軸的
- ribbon = tortile リボン=可捻

これだけでも有用な情報だ。


</body>
</day>
<day date="2009-01-14" title="">
<body>
*1231892774*[リンク]圏論勉強会 次のテキストへの推奨リスト

mixiは全然見ないから、こっちに引き写しておこう。後で追加するかも、本編にも何か書くかも（書かないかも）。

&lt;h5&gt;バエズ組&lt;/h5&gt;

- 2008夏セミナーのページ http://math.ucr.edu/home/baez/atmcs2008/

- Title: Computation and the Periodic Table
- Author: John C. Baez
- URL: http://math.ucr.edu/home/baez/atmcs2008/atmcs2008.pdf
- Pages: 27ページスライド、

- 檜山エントリー：バエズとステイのロゼッタストーン論文と現代のヒエログリフ http://d.hatena.ne.jp/m-hiyama/20080222/1203648686

- Title: Physics, Topology, Logic and Computation: A Rosetta Stone
- Authors: John C. Baez, Mike Stay
- URL: http://math.ucr.edu/home/baez/rosetta.pdf
- Pages: 64ページ

&lt;h5&gt;アブラムスキー組&lt;/h5&gt;

本命はやっぱりこれです。
- Title: Quantum measurements without sums
- Authors: Bob Coecke, Dusko Pavlovic
- URL: http://arxiv.org/abs/quant-ph/0608035
- Pages: 41

「もっと新しいのがあるよ」と言ったのは、これ
- Title: POVMs and Naimark's Theorem Without Sums
- Authors: Bob Coecke, Eric Oliver Paquette
- URL: http://arxiv.org/abs/quant-ph/0608072
- Pages: 16
ですが、いま眺めたら、より物理的な内容でキビシイ感じなので、先にQuantum measurementsを&lt;del datetime=&quot;2009-01-15T13:36:49+09:00&quot;&gt;呼ん&lt;/del&gt;読んでおくべきでしょう。

副読本は、
- Title: Bases in diagrammatic quantum protocols
- Authors: Bob Coecke, Eric Oliver Paquette, Simon Perdrix
- URL: http://arxiv.org/abs/0808.1029
- Pages: 21

&lt;h5&gt;セリンガー&lt;/h5&gt;

現状で一番新しい、絵算の教科書みたいなもの
- Title: A survey of graphical languages for monoidal categories
- Author: Peter Selinger
- URL: http://www.mscs.dal.ca/~selinger/papers.html
- Pages: 59

CPMに関してしばしば引用されるのは、
- Title: Dagger compact closed categories and completely positive maps
- Author: Peter Selinger
- URL: http://www.mscs.dal.ca/~selinger/papers.html
- Pages: 23

セリンガーは自分の論文をほとんど公開していて http://www.mscs.dal.ca/~selinger/papers.html からアクセスできます。どれも面白そうです。

&lt;h5&gt;その他&lt;/h5&gt;

- Title: Axiomatic Description of Mixed States From Selinger's CPM-construction.
- Author: Bob Coecke
- URL: http://www.mscs.dal.ca/~selinger/qpl2006/PDFS/01-Coecke.pdf 
- Pages: 10

- Title: Toy quantum categories
- Authors: Bob Coecke, Bill Edwards
- URL: http://arxiv.org/abs/0808.1037
- Pages: 11

- Title: Extending Graphical Representations for Compact Closed Categories with Applications to Symbolic Quantum Computation
- Authors: Lucas Dixon and Ross Duncan
- URL: http://dream.inf.ed.ac.uk/projects/quantomatic/quantomatic-aisc08.pdf
- Pages: 16

*1231896638*[雑感][圏一般論]右と左 n-たび セリンガーの左右

セリンガーの&quot;A survey of graphical languages for monoidal categories&quot;を眺めていて気付いた。彼は、右肩に星が付くA&lt;sup&gt;*&lt;/sup&gt;を「右双対」と呼んでる。

復習：まず、白旗さんの &quot;A sequent calculus for compact closed categories&quot; (http://citeseer.ist.psu.edu/shirahata96sequent.html)
&gt;&gt;
Definition 1 

In a monoidal category, a &lt;b&gt;left adjoint&lt;/b&gt; of an object A is an object A&lt;sup&gt;*&lt;/sup&gt; with maps
- d&lt;sub&gt;A&lt;/sub&gt;:I→A×A&lt;sup&gt;*&lt;/sup&gt; (unit)
- e&lt;sub&gt;A&lt;/sub&gt;:A&lt;sup&gt;*&lt;/sup&gt;×A→I (counit)
such that ...
&lt;&lt;

次にバカキリ本：
&gt;&gt;
(p.29)&lt;br&gt;DEFINITION 2.1.1

Let C be a monoidal category and V be an object in C. A &lt;b&gt;right dual&lt;/b&gt; to V is an object V&lt;sup&gt;*&lt;/sup&gt; with two morphisms
- (2.1.3) e&lt;sub&gt;V&lt;/sub&gt;:V&lt;sup&gt;*&lt;/sup&gt;×V→1,
- (2.1.4) i&lt;sub&gt;V&lt;/sub&gt;:1→V×V&lt;sup&gt;*&lt;/sup&gt;,
such that ...
&lt;&lt;

で、セリンガーのテキスト：
&gt;&gt;
(p.18)&lt;br&gt;
Definition ([17]). In a (without loss of generality strict) monoidal category, an exact pairing between two objects A and B is given by a pair of morphisms η: I → B×A and ε: A×B → I, such that the following two adjunction triangles commute:  ... (4.1)

In such an exact pairing, B is called the &lt;b&gt;right dual&lt;/b&gt; of A and A is called the left dual of B.
&lt;&lt;

用語と記号を合わせて、余単位を書いてみると：

+ 白旗さん A&lt;sup&gt;*&lt;/sup&gt;はAの左双対  A&lt;sup&gt;*&lt;/sup&gt;×A→I
+ バカキリ A&lt;sup&gt;*&lt;/sup&gt;はAの右双対  A&lt;sup&gt;*&lt;/sup&gt;×A→I
+ セリンガー A&lt;sup&gt;*&lt;/sup&gt;はAの右双対  A×A&lt;sup&gt;*&lt;/sup&gt;→I

状況は悲劇的； 白旗さんとバカキリの定義は同じだが左右が逆、バカキリとセリンガーは同じ言葉に逆の定義。統一されているどころか、考えられるすべてのバラエティがある。

「右肩星なら右双対」は憶えやすいからいいのだが、A&lt;sup&gt;*&lt;/sup&gt;×A と A×A&lt;sup&gt;*&lt;/sup&gt; のどっちがいいかは趣味の問題か。A&lt;sup&gt;*&lt;/sup&gt;×A が多いような気がするし、線形代数の双対とペアリングとの相性はいい、&amp;lt;x, f&gt; より &amp;lt;f, x&gt;  のほうが多いだろう。

ところで、ストリートのように、双対と随伴を区別しないとどうなるか？ F -| U のとき、UはFの&lt;b&gt;右随伴&lt;/b&gt;と呼ぶべきだろう。UをF&lt;sup&gt;*&lt;/sup&gt;と書くことにすると、余単位は、ε:F・F&lt;sup&gt;*&lt;/sup&gt;→I となる。ここで、・は&lt;em&gt;反図式順&lt;/em&gt;の関手結合。つまり、非対称テンソル積を反図式順結合にするなら、セリンガーの用法と整合する。一方、図式順結合を採用すると、ε:&lt;sup&gt;*&lt;/sup&gt;U;U→I となり、また違う記法になってしまう。

どうやってもうまくいかないのだが、現状での僕の態度としては、

+ 右双対は右肩の星（憶えやすい）
+ 右双対は余単位の定義域の右側に置く
+ 右随伴は -| の右に置く
+ 左右を整合的にするために、テンソル積としては反図式順結合を採用する

なお、⊥が双対化対象のとき

+ &lt;sup&gt;*&lt;/sup&gt;A = ⊥ o-- A = ⊥&lt;sup&gt;A&lt;/sup&gt;
+ A&lt;sup&gt;*&lt;/sup&gt; =  A --o ⊥ = &lt;sup&gt;A&lt;/sup&gt;⊥

だと思う。このときはやっぱり左右がひっくり返る。全面的に左右を揃えるのは所詮無理なのだ。

*1231903709*[リンク]証明とラムダ計算の一般化／高次化

バエズのセミナーページ http://math.ucr.edu/home/baez/atmcs2008/ からたどれる；

- Vladimir Voevodsky, A very short note on the homotopy lambda calculus, Sept. 27, 2006.  (http://math.ucr.edu/home/baez/Voevodsky_note.ps)

very shortすぎてサッパリわからん。何を言いたいかもわからん。

- Yves Guiraud, The three dimensions of proofs, Ann. Pure Appl. Logic 141 (2006), 266-295.  (http://arxiv.org/abs/math/0612089)

出だしの印象では意外とわかりやすそう。けっこう長い。

*1231911164*[セミナー]Little Expression Language

たいていのプログラミング言語のなかに埋め込める。

- 型：numberとboolean
- リテラル：普通
- 変数（インフォーマル）：a,b,c, x,y,zはnumber、p,q,r,s,tがboolean
- 名前付き関数と無名関数
- 算術演算子：+, -, *, %, 単項の-
- 組み込み関数： sqrt
- 論理演算子：&amp;amp;&amp;amp;, ||, !
- 比較演算子： ==, &amp;lt;, &gt;, &amp;lt;=, &gt;= 
- 複合型：配列 orリスト or タプル（なんでもよい）
- 制御：(? : ) と名前を使った再帰
- その他：括弧

&lt;pre class=&quot;code&quot;&gt;
Object.prototype.toString = function() {
  var s = &quot;{&quot;;
  for (var p in this) {
    var v = this[p];
    if (v !== undefined &amp;&amp; (typeof v) !== 'function') {
      s += p + &quot;=&quot; + v + &quot;, &quot;;
    }
  }
  s = s.replace(/, $/, &quot;&quot;);
  return s + &quot;}&quot;;
};

function App(fun, args) {
  return fun.apply(null, args);
}
&lt;/pre&gt;

やや一般化した閉包の説明に使える。

*1231911574*[モノイド圏][トレース／コンパクト閉圏]フーフマン（Hoofman）の線形圏

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090106/1231234044&quot;&gt;「全然知らないことが山盛り載っていた」&lt;/a&gt;のフーフマン（R. Hoofman）論文における線形圏（linear category）の定義を述べる。他の著者は、線形圏に別な定義をしているかも知れない。

&lt;h5&gt;記号の準備&lt;/h5&gt;

フーフマンによれば、線形圏とは、双対化対象（dualizing object）を備えた対称モノイド閉圏である。台となる対称モノイド閉圏を (C, □, 1, σ, --o) とする。--o は線形含意の記号だが、モノイド積□に随伴な閉圏のベキ（power, exponent）とする。左指数(右向き矢印） --o と右指数（左向き矢印） o-- をここでは区別しない（対称性から）。強いていえば、左指数＝右向き矢印を標準とする。

評価（適用）射evとカリー化オペレータは次のとおり：

- ev&lt;sub&gt;A,B&lt;/sub&gt; : (A --o B)□A → B
- Λ&lt;sub&gt;A,C&lt;/sub&gt;&lt;sup&gt;B&lt;/sup&gt; : C(A□B, C) → C(A, (B --o C))

最近の僕の好みから言えば：

- Λ&lt;sub&gt;A,C&lt;/sub&gt;&lt;sup&gt;B&lt;/sup&gt; : C(A□B, C) → C(A, (C o-- B))

なのだが、C o-- B = B --o C とすれば区別は付かない。

さて、対称σを使って引数の順序を入れ替えたものを

- ev'&lt;sub&gt;A,B&lt;/sub&gt; : A□(A --o B) → B
- Λ'&lt;sub&gt;B,C&lt;/sub&gt;&lt;sup&gt;A&lt;/sup&gt; : C(A□B, C) → C(B, (A --o C))

フーフマンは、ev'とΛ'を基本に考えているので、彼の記法ではev'がev、Λ'がΛ。だが、僕は逆の流儀だから、あえてプライム（ダッシュ）を付けるのだ。

これで準備は終わり。

&lt;h5&gt;双対化対象&lt;/h5&gt;

双対化対象（dualizing object）とは、単に選ばれた対象のことではなくて、それに付随する射の族、つまり圏的オペレータのシステムである。具体的には、

- 特別な対象 ⊥∈|C| がある。
- 射の族 τ&lt;sub&gt;X&lt;/sub&gt;:X→((X --o ⊥) --o ⊥) がある。

このτは次のように定義される。
&lt;pre&gt;

  ------------------------- Id
  (X --o ⊥) → (X --o ⊥)
  ------------------------- Λ'
  X□(X --o ⊥) → ⊥
  ------------------------- Λ
  X → (X --o ⊥) --o ⊥
&lt;/pre&gt;

どんな対称モノイド閉圏でもτの定義はできる。このτが同型になるとき、双対化対象と呼ばれる。

X&lt;sup&gt;*&lt;/sup&gt; = (X --o ⊥)と定義すると、X→X&lt;sup&gt;**&lt;/sup&gt; が同型なので、(-)&lt;sup&gt;*&lt;/sup&gt;はスターオペレータになる。(-)&lt;sup&gt;*&lt;/sup&gt;だけを考えて、--o を忘れると、(C, □, ⊥, σ, (-)&lt;sup&gt;*&lt;/sup&gt;)はコンパクト閉圏になり、B&lt;sup&gt;*&lt;/sup&gt;□A = B o-- A = A --o B となるはず。（細かい計算はしてない；課題）

￢A = (A --o ⊥) とすれば、論理っぽい。線形圏では、二重否定が成立するから、否定に関しては古典論理やコンパクト論理と似ている。ド・モルガン律を使ってテンソル積にに双対的なテンソル和を定義できるが、コンパクト閉圏なら積と和が一致してしまう。積と和が一致しない線形圏てなんだろう？

</body>
</day>
<day date="2009-01-15" title="">
<body>
*1231978724*[リンク][物理っぽい]その他、圏論的量子論の文献

- Title: Teleportation Topology (28 Jul 2004, 17 Apr 2005)
- Author: Louis H. Kauffman
- URL: http://arxiv.org/abs/quant-ph/0407224
- Pages: 17
&lt;hr&gt;

- Title: Frobenius algebras and planar open string topological field theories (18 Aug 2005)
- Author: Aaron D. Lauda
- URL: http://arxiv.org/abs/math.QA/0508349
- Pages: 66
&lt;hr&gt;

- Title: A new description of orthogonal bases (5 Oct 2008)
- Authors: Bob Coecke, Dusko Pavlovic, Jamie Vicary
- URL: http://arxiv.org/abs/0810.0812
- Pages: 14
&lt;hr&gt;

- Title: Quantum and classical structures in nondeterminstic computation (11 Dec 2008, 10 Jan 2009)
- Author: Dusko Pavlovic
- URL: http://arxiv.org/abs/0812.2266
- Pages: 14
&lt;hr&gt;

- Title: Categorical formulation of quantum algebras (4 May 2008)
- Author: Jamie Vicary
- URL: http://arxiv.org/abs/0805.0432
- Pages: 37
&lt;hr&gt;

- Title: Composing PROPs (2004)
- Author: Stephen Lack
- URL: http://www.tac.mta.ca/tac/volumes/13/9/13-09.pdf
- Pages: 18
- URL-2: http://www.maths.usyd.edu.au/u/stevel/papers/prop.html
&lt;hr&gt;

*1231990899*[圏一般論][雑感]圏的オペレータ

最近（とはいっても3年とかのスパンで）思っているのだが、圏的なオペレータ（cateogorical operators）が重要だよね。でも、あまりまとまった記述や指摘がないし、そもそもオペレータの定義や一般論が難しいので、オペレータは影にかくれやすい。ここで、定義らしきことを考えてみる。

Cが圏のとき、Obj(C)を|C|、Mor(C)は単にCと書く。オペレータは族の集合として与えられるから、先に族を定義する。Aがなんらかの集合だとして、Aをインデックス集合とする族は次のようなもの。

+ 対象の族： A→|C| という写像
+ 射の族： A→C という写像
+ 対象写像の族： A→PMap(|C|, |D|) という写像。PMapは下に説明。
+ 射写像の族： A→PMap(C, D) という写像。PMapは下に説明。

ここで、「f∈PMap(A, B) ⇔ f:X→Y, X⊆A, Y⊆B」、Aの部分集合からBの部分集合への写像がPMap。

インデックス集合Aは、たいていは、圏の対象類|C|や、その直積になっている。典型的なオペレータはトレースだろう。Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;:C(A×X, B×X)→C(A, B) なので、インデックス集合(|C|×|C|)×|C|とする、射写像の族になっている。射写像（部分写像）の場合、その定義域、余域はホムセットの場合が圧倒的に多い。

圏の結合、恒等、関手、自然変換もオペレータと思える。その他に思いつく例を挙げると：
+ スター・オペレータ： X |→ X&lt;sup&gt;*&lt;/sup&gt;
+ 二重双対同型：τ&lt;sub&gt;X&lt;/sub&gt;:X→X&lt;sup&gt;**&lt;/sup&gt;
+ ブレイディング：β&lt;sub&gt;X,Y&lt;/sub&gt;:X×Y→Y×X、特殊ケースが対称σ
+ ツイスト：θ&lt;sub&gt;X&lt;/sub&gt;:X→X
+ アソシエータ：α&lt;sub&gt;A,B,C&lt;/sub&gt;:A×(B×C)→(A×B)×C
+ ユニッタ：λ&lt;sub&gt;A&lt;/sub&gt;:1×A→A
+ Kelly単位：η&lt;sub&gt;A&lt;/sub&gt;:1→A&lt;sup&gt;*&lt;/sup&gt;×A
+ Kelly余単位：A×A&lt;sup&gt;*&lt;/sup&gt;→1

関手性や自然性を持つとは限らないオペレータを使って定義される構造がどんどん増えているような気がする。

*1232001436*[計算][msched][WCC]拡張スカラーの計算表

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081217/1229507446&quot;&gt;無限大を含む算術&lt;/a&gt;（&lt;a target=&quot;_blank&quot; href=&quot;http://erlang.g.hatena.ne.jp/m-hiyama/20081218/1229580333&quot;&gt;Erlang実装&lt;/a&gt;）の件：

まず、おおざっぱに符号の掛け算：

| × | - | 0 | + |
| -  | + | 0 | - |
| 0  | 0 | 0 | 0 |
| +  | - | 0 | + |

これはいいよね。

無限大を含む掛け算、n, n'は有限負数、p, p'は有限正数。

| × | -∞ | n   | 0 | p  |  +∞ |
| -∞|+∞  | +∞ | 0 |-∞ | -∞  |
| n' |+∞  | nn' | 0 | pn'| -∞  |
| 0  | 0   | 0   | 0 | 0  | 0   |
| p' |-∞  | np' | 0 | pp'| +∞ |
| +∞| -∞ | -∞ | 0 | +∞| +∞|

足し算のほうが簡単、x, x'は有限数、Undefは未定義。

| ＋ | -∞ | x  | +∞ |
| -∞| -∞ | -∞| Undef  |
| x'  | -∞ | xx' |+∞ |
| +∞| Undef| +∞ |+∞ |

別に代数的な合理性はどうでもよくて、実用になればオッケ。

*1232010244*[モノイド圏][トレース／コンパクト閉圏][論理]まだ右と左

現状での&lt;em&gt;思いと好み&lt;/em&gt;を記す。f:A, B → C のとき

- 左抽象 ΛL(f) = ^f:B → (A --o C) ここで、(A --o C) = &lt;sup&gt;A&lt;/sup&gt;C
- 右抽象 ΛR(f) = f^:A → (C o-- B) ここで、(C o-- B) = C&lt;sup&gt;B&lt;/sup&gt;

左適用、右適用、基本等式は

- AppL(a, ^f) = f
- AppR(f^, b) = f

モダスポネンスは

- A, (A --o C) |- C
- (C o-- B), B |- C

セリンガーに倣って、A&lt;sup&gt;*&lt;/sup&gt;がAの右双対として、ストリートに倣って 

- A -| B ⇔ A -| A&lt;sup&gt;*&lt;/sup&gt; ⇔ &lt;sup&gt;*&lt;/sup&gt;B -| B

BはAの右随伴であり、AはBの左随伴。&lt;em&gt;右は右側に置き右星印、左は左側に置き左星印。&lt;/em&gt;随伴と双対は区別しない。余単位は

- ε: A, A&lt;sup&gt;*&lt;/sup&gt; → 1
- ε: &lt;sup&gt;*&lt;/sup&gt;B, B → 1

単位は並びが逆になるから：

- η: 1 → A&lt;sup&gt;*&lt;/sup&gt;, A
- η: 1 → B, &lt;sup&gt;*&lt;/sup&gt;B

εを適用と解釈するために

- ε: A, (A --o ⊥) → ⊥
- ε': (⊥ o-- B), B → ⊥

ペアリングを &amp;lt;-, -&gt; と書くと、上なら&amp;lt;x, f&gt; 、下なら &amp;lt;f, x&gt;。

*1232012095*[セミナー]ランダムなメモ：後で整理する

- 立体視が重要
- だが、複数の視点を紹介する時間がない
- 上江州流が中心
- 関数概念
-- 「集合と関係グラフ」ベース、非常に静的
-- 記号と計算（記号の書き換え）ベース
-- 装置メタファー、直感的
-- 矢印ベース、圏論へ
- 関数計算の基本演算
-- 適用中心
-- 結合（合成）中心
- 高階関数の考え方
-- 数学では
-- 物理では
-- コンピュータでは
- 「一番よく使う記号は省略する」の原則
- 計算と計算結果、値とはなにか
- 1 + 2 = 3 だが、 3 = 1 + 2 は？
- 式は値か？
- 定数は変数か？
- 変数の束縛環境（値束縛）
- 閉包ってなんだぁ？？
- 実行と評価、それと結果、それと無限走行
- 「ピュアすぎると嫌われる」
- 「単純すぎるとわかりにくい」
- 物と働き、データと操作の二元論
- どこまでがハードウェア、どこからがソフトウェア
- 個別算術ハードウェアと万能算術機械
- プログラムは物であり働きである 二面性
- 二面的だが存在ブツとしてはひとつ、これが謎
- 自由、束縛を構文的に区別する
- 記号表現より絵のほうが合理的なときもある
- グラウンドな項、閉じた式

不純ラムダ計算とは：

+ 多変数（多引数）を許す
+ 型付きである、が暗黙の宣言で型の明示をサボル
+ タプル構成子を持つ
+ タプルからの成分取り出し（ドットやブラケット）はプリミティブ
+ 定数（リテラル）を持つ
+ 組み込み関数、演算子を持つ
+ 制御構造を持つ
+ 変数の辞書式順序を利用する
+ 環境のチェーン、したがって入れ子の閉包を許す

普通のプログラミング言語と違う点は、多引数と多値の解釈：

+ 多引数をタプル1引数だと考える
+ 名前付き引数は、変数タプルへの値タプルからの同時代入で実現されると解釈
+ タプル戻り値は、多引数関数にそのまま代入できると考える。


</body>
</day>
<day date="2009-01-16" title="">
<body>
*1232062828*[圏一般論][雑感]「左右問題」の高次元化

Cが圏のとき反対圏C&lt;sup&gt;op&lt;/sup&gt;が考えられる。2-圏のときは、台の1-圏の反対化以外に2-セルの方向を逆にすることもあるから、1-op, 2-op と区別すると：

- C
- C&lt;sup&gt;1-op&lt;/sup&gt;
- C&lt;sup&gt;2-op&lt;/sup&gt;
- C&lt;sup&gt;1-op,2-op&lt;/sup&gt;

が考えられる。ただし、複圏とか、形式的（図形的）可逆性を持たないセルを使う高次圏ではopが定義できない。高次圏の左右問題はどうなるのやら？

*1232062829*[セミナー]ポリシー

- 言葉、立場、見方の&lt;em&gt;多様性&lt;/em&gt;を強調
- 単眼と複眼、投影図と立体視
- 上江州流の紹介
- 絵算入門

*1232063964*[圏一般論][論理]圏的オペレータとシーケント

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090115/1231990899&quot;&gt;圏的オペレータ&lt;/a&gt;を考えるといいことのひとつが、シーケントの（とりあえずの）意味論ができることだ。

シーケントを射と思うと、基本推論は、0個、1個、2個のホムセットの直積から1個のホムセットへの写像と考えることができる。ホムセットを(a, b)のように書くことにすると、推論は、|- (a, a) とか (a, b),(b, c) |- (a, c) のように書ける。

この方針で、有限個のホムセットの並び（ストリング）を対象とする圏（むしろ多圏）を作れる。この圏のモノイド積は連列で非対称。モノイド単位は空な並び。基本推論（に対応するオペレータ）が生成射になる。生成射から生成された自由圏が証明の圏ということになる。証明の圏の射＝証明が、もとの圏上にうまく2-射を定義できる保証はない。が、いずれにしも証明の圏はもとの圏と強い関係がある。

問題意識としては、命題＝対象、自然演繹＝射である圏があるとき、自然演繹＝シーケント＝対象、ゲンツェン証明＝射である圏をどう構成するのか、もとの圏＝自然演繹の圏と、構成された証明の圏はどう関係するのか？ さらには証明の変形／書き換えを2-射とするとき、2-射をどう構成するのか？ などだろう。

ジラール（Girard）がいうように、証明図が「式」で、証明図の変形が「計算」、それ以上変形できない証明図が「値」である計算論も構成できるのだろう、おそらく。

*1232081309*[物理っぽい][TQFT][量子計算][からみ系]カウフマンを読みたい：振幅

カウフマンのこれ：

- Title: Teleportation Topology (28 Jul 2004, 17 Apr 2005)
- Author: Louis H. Kauffman
- URL: http://arxiv.org/abs/quant-ph/0407224
- Pages: 17

短いから読みたい。カウフマンのあの独特の感性、よくわからんのだが魅力的。語り口はわかりやすそうなんだが、「カウフマン感覚」に付いていくのがチョット大丈夫かな？

「空間1次元＋時間」の2次元時空で粒子を追いかける話のようだ。次元が低いので絡んだりはしない。ブレイディングもないわけ。

振幅（amplitude）という言葉が出てくるが、これをどう解釈するか？ とりあえずスカラー量だが、むしろ複素1次元ベクトル空間のあいだの変換だと思った方がよさそうだ。Vが1次元なら、End(V)≒&lt;b&gt;C&lt;/b&gt; が複素ベクトル空間の圏で成立する（つうか、多元環として同型だけど）。

事情はなんだかよくわからんが、大昔（過去）の真空や未来の真空に対しても1次元の状態空間があるらしくて、過去→未来 という遷移を記述するなら、1次元ベクトル空間→1次元ベクトル空間 なので、End(V)の元、つまりはこれは複素数とみなせる。この複素数をどうも振幅と呼んでいるようだ。

振幅の絶対値（のルートか？）が確率を与えるらしい。つまり、昔のとある真空が未来のとある真空に移る確率が振幅から計算される。その計算は（基底を入れれば）行列のテンソル計算となるようだ。

カウフマンのことだから、このテンソル計算を彼流の図式計算にして、平面内の曲線のトポロジーと関係づける魂胆だろう。

*1232083409*[プログラム意味論]λ代数、万能対象

自己適用の分析のために、確か適用構造だか適用代数だかという概念があったと思う。適用に相当する二項演算・があって、それがナニガシかの公理を満たすようなものだったと思うのだけど、あんまり憶えてない。

とりあえず、横内さんの『プログラム意味論』を探した。適用構造はなかったが、似たような話でλ代数があった。少しアレンジして述べる。

まず、λ演繹系（横内本にはない）(V, L, |-)を次のように定義する。

+ 変数の集合V
+ Vから構文的な適用とラムダ抽象から生成された式（項）の集合L
+ 2つの式M, Nから作られる同値性のjudgement M = N （単なる構文）
+ M = N を導出するための書き換え／推論規則と、演繹（導出）可能性判を示す |-。

Sがλ演繹系なら、|- M = N  という主張が意味を持つ。λ演繹系の具体例は形無しのラムダ計算から作れる。もっとも、書き換え／推論規則の具体的な構成は難しいが。

λ演繹系S上のラムダ代数は、二項演算・を備えた集合X、環境Env=Map(V, X)、意味写像[(-:-)] : L×Env→X からなる系で：

+ [(x:α)] = α(x)
+ FreeVars(M)上でαとβが一致するなら、[(M:α)] = [(M:β)]
+ [(M N :α)] = [(M :α)]・[(N :α)]
+ [(λx.M :α)]・d = [(M :α[x:=d)]
+ |- M = N ⇒ ∀α.([(M : α)] = [(N : α)])

要するに、形無しのもっとも単純なλ演繹系に対する都合のよいモデルのことだ。ただし、λモデルというより広い概念はまた別にあるようだ。

&lt;hr&gt;
ついでに、反射的対象と万能対象についても。

Vが反射的対象とは、ベキ[V, V]がVに埋め込めること。ここで、埋め込めるは単なる単射じゃなくてEPペアの存在を仮定する。別な言い方をすると、i:[V, V]→V に対してレトラクト（または射影）rがあって、i;r = id が成立している。

万能対象の万能はおそらくuniversalだろう。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090106/1231234045&quot;&gt;「反射的対象とスノーグローブな世界」&lt;/a&gt;で「普遍」は使えない、と言ったが、どうやら使ってしまっているようだ。Uが万能だとは：

+ 任意の対象Aに対して、埋め込み A→U が存在する。ここで埋め込みはEPペア。
+ h:U→Uがベキ等ならば、h = r&lt;sub&gt;A&lt;/sub&gt;;i&lt;sub&gt;A&lt;/sub&gt; となるEPペアが存在する。

万能対象は任意の対象を内包するだけでなく、ベキ等射がEPペアで表現できるという条件が付く。つまり、外の圏の対象類全体を万能対象のベキ等射として埋め込めることになる。そう言えば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090106/1231234044&quot;&gt;「全然知らないことが山盛り載っていた」&lt;/a&gt;のカロウビ展開圏が、ベキ等射を対象とみなす構成だったと思う。

</body>
</day>
<day date="2009-01-17" title="">
<body>
*1232182707*[プログラム意味論][圏一般論][メモ]点が十分ある対象

横内さんの本にあったからメモ。対象Aが has enough points または is well-pointed とは、任意のf, g:A→A に対して、f ≠ g ⇒ ∃a:1→A.( a;f ≠ a;g)。

「任意のf, g:A→A」を「任意のXと、任意のf, g:A→X」にしても同じ。


</body>
</day>
<day date="2009-01-19" title="">
<body>
*1232320473*[メモ][圏一般論]コサイクルとマグマ

圏で定義されて圏に値を取るコチェーンを考えている。しかし、定義域が圏である必要はないと思われる。高次グラフ、またはフーティアのいうマグマが適切ではないか？

*1232320474*[セミナー]意外と難しいかも知れない基本概念／用語

- 自由変数 - 大域変数とは限らない。相対的な概念。PerlやJavaScriptでは？
- 束縛変数（ラムダ変数） -- 位置引数であること、本質的に無名
- 大域環境、局所環境 -- ようするに環境、細かいこと言わなければ同じ。

PerlやJavaScriptでの実例を考える。あと、物理的なカリー化の例として、熱方程式とか（離散化、単純化して）。
</body>
</day>
<day date="2009-01-20" title="">
<body>
*1232419072*[リンク][オフトピック]なつかしい

- http://www.megasoft.co.jp/mifes8/

*1232431021*[オフトピック]下着、整理

- イオンのプライベートブランド「トップバリュ」に『ヒートファクト』つうのがあるらしい。汗かいても冷えにくい。
- 男用のワコール『クロスウォーカー』 -- 歩行時の歩幅を拡げ運動になると。

- 赤めだか 本 買うか  ← 買った。
- キーワード 整理[できない]／片づけられ{る,ない}／捨てる／ゴミ
- キーワード 恥ずかしいけど困った
- キーワード シェア

*1232430169*[セミナー][メモ]ランダム・メモ

とりあえず、紙にメモすると散らばるから。

- 絵の描き方
++ 上から下
++ f x と、左から右
++ 抽象は右抽象 f^
++ タプリングは白丸
++ λも白丸（バブル）
++ Applyは黒丸
++ タプルの抽象は、白丸と白丸を結ぶ
++ ベキ（指数型）は二本線、逆向きの対
++ タプルのアリティ（項数）は、白丸のなかに数値
- タプル導入はうっとうしい
++ 定数は0引数関数か？
++ 2引数関数と2-タプル1引数関数は同じか違うか？
++ 多引数と多値は対称にはできないのか？
++ タプルがなくて済むならスッキリ
++ が、タプルレスは必ずしも直感的ではない。
- 問題意識
++ 関数とは何か？
++ 関数は働き（行為、動作）か、それともモノか？
++ 関数の計算はどうするのか？
++ 関数で何が表現できるのか、どう表現できるのか？
- ラムダ計算からのメッセージ
-- 働きとしての関数と、モノとしての関数は区別しなくても大丈夫
-- いったん区別しない限りは「区別しなくても大丈夫」の意味は理解できない
- さまざまな視点とは
++ 立体視
++ 中からの視点、外からの視点
++ 区別しない立場、区別する立場
++ 構成的な立場、超越的な立場
++ ソフトウェア的、ハードウェア的
++ 抽象的、具象的
++ 計算過程の操作的、計算結果の表示的
++ 自然物、人造物
-- 関数、閉包
++ 式と関数は違うのか
++ 変数の名前とは何か、名前はいるのか？
++ 関数＝大きなラムダ式 と考える（上江州流）
++ 閉包＝関数＋環境（名前付きパラメータ）
- 純ラムダの計算と、関数はグラフ（関係）と見る立場の距離は大きい
- コンピューティングの世界は、それと統合し発展したモデルで記述される（べき？）
- 変数に辞書式順序 -- これは便宜的ルール、だがないと困る。
- コンパイラ＝カリー化＝小さいラムダ、アプライ＝ハードウェア
- 自然も計算している（ニュートン力学も熱拡散も量子力学も）

まだ続く、かも。

ここから続き：

- 別な問題意識：「計算している自分」＝作業当事者は「計算している自分」を意識できるか、客観視できるか。
- 自然の計算 例： y = f(v, θ, t)
- 自然の計算 例： τ = f(k, t) 熱拡散の離散化
- 高階関数： Σで総和、sigma(n, m, f)
- 高階関数： 1次関数を返す関数、総和を取る高階関数を返す関数、関数の2回適用をした関数を返す関数
- 言葉：ラムダ抽象、関数抽象、抽象、カリー化、
- この世界：コンピュータ上でCで書かれたJVM上のJavaで書かれたRhinoでCPUエミュレータを作る、とか。それが平気になっている。そんな世界をどうやって理解するんだ？

*1232442940*[高次圏論][リンク]マグマ

http://math.ucr.edu/home/baez/week136.html より：

&gt;&gt;
Now, strict ω-categories are great, but we need to weaken this notion. So, first Penon defines an &quot;ω-magma&quot; to be something exactly like a strict ω-category but without the axioms of type B. You may recall that a &quot;magma&quot; is defined by Bourbaki to be a set with a binary operation satisyfing no laws whatsoever - the primeval algebraic object! An ω-magma is just as lawless, and a lot bigger and meaner. 

strict ω-categories are too strict: all laws hold as equations. Ω-magmas are too weak: no laws hold at all! How do we get what we want? 
&lt;&lt;

高次圏論的マグマはPenonが起源だそうだ。が、昔ブルバキが定義していたのか、フーン。

フーティアの論文から、マグマの定義を引き写しておく。マグマは、ωグラフ（反射的球集合）をベースに、結合（composition）と呼ばれる二項演算を入れた形をしている。二項演算の性質が5つの公理になっているが、3つと2つに分けて述べる。フーティアは、中置の○&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;で演算を表している。上付きjはセルの次元、下付きiはセルどおしが接合している境界の次元である。ここでは、[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]を使う。

最初の3つ（まとめたり、順序を変えたり）は、

+ （もとの2と3）jセルaとbがi次元境界で隣接しているなら、a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b が一意に定まる。
+ a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b = c ならば、aとbはi次元境界で隣接している。

残りの2つは、a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]bの境界（dom, cod）がどんな形をしているかを規定する。

+ i = j - 1 のとき、dom&lt;sup&gt;j&lt;/sup&gt;(a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b) = dom&lt;sup&gt;j&lt;/sup&gt;(a), cod&lt;sup&gt;j&lt;/sup&gt;(a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b) = cod&lt;sup&gt;j&lt;/sup&gt;(b) が成立する。
+ i &amp;lt; j - 1 のときは、dom&lt;sup&gt;j&lt;/sup&gt;(a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b) = dom&lt;sup&gt;j&lt;/sup&gt;(a) [&lt;sup&gt;j-1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;] dom&lt;sup&gt;j&lt;/sup&gt;(b)、cod&lt;sup&gt;j&lt;/sup&gt;(a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b) = cod&lt;sup&gt;j&lt;/sup&gt;(a) [&lt;sup&gt;j-1&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;] cod&lt;sup&gt;j&lt;/sup&gt;(b) が成立する。

「a[&lt;sup&gt;j&lt;/sup&gt;&lt;sub&gt;i&lt;/sub&gt;]b が一意に定まる」を、「定まるかもしれない。もし定まるなら一意的である」に置き換えるとプレマグマ（premagma）が定義できる。

&lt;b&gt;[追記]&lt;/b&gt;そういえば、フーティアの論文を明示的に参照してなかったわ。

- Title: Weak Omega Categories I (11 Apr 2004)
- Author: Carl A. Futia
- URL: http://arxiv.org/abs/math.CT/0404216
- Pages: 57

&lt;b&gt;[/追記]&lt;/b&gt;

*1232444967*[XML]四角の世界

本編に書くつもりだ。

*1232445226*[復習]DFD

ちょっと忘れたが：

- http://d.hatena.ne.jp/m-hiyama-memo/20071231/1199053530


</body>
</day>
<day date="2009-01-22" title="">
<body>
*1232596318*[セミナー]イータ変換までやるかな、それと、大きなラムダの基本概念とか

土曜日の目標を、ベータ変換だけでなくイータ変換までにしようかと、もし可能ならだが。ガンマオペレーション＝脱抽象が、ラムダオベレーション＝抽象の逆であることを理解する。

背景となる意味的な法則は：

- Exec(λt.(φ・t), a) = Exec(φ, a)

である。ここで； Execは解釈実行系（評価系＝関数ランタイムエンジン）、ラムダ式は関数コードとして解釈し、記号「・」はExec自身の実行を表す（指示する）演算子。

これを「Execの中の人」の立場で解釈すると、

- λt.(φ・t) ⇒ φ

という事前処理を行うことになる。この関数コードの事前（実行に先立つ）処理をイータ変換と呼ぶ。次が、イータ法則、あるいはイータ仮説と呼んでいいだろう。

- なかの人がイータ変換を行っても実行結果に影響を与えない。

ところでガンマオペレーションは、g = &amp;lt;x| g(x)&gt; に対して &amp;lt;x, t|Exec(g(x), t)&gt; として与えられる。次のイータ・コード化ルールを設ける。

- Λt&amp;lt;x, t| Exec(g(x), t)&gt; = &amp;lt;x| λt.(g(x)・t) &gt;

この段階で既に、記号「・」の導入とイータ・コード化ルール、イータ仮説（イータ変換が意味的に妥当とする仮説）、イータ変換を行う解釈実行系などを導入している。イータ変換合理化のために、けっこう色々やっているのだ。

これらの下準備のもとで：
&lt;pre&gt;
   Γ(g)
  = Γt&amp;lt;x| g(x)&gt;
  = &amp;lt;x, t| Exec(g(x), t) &gt;

以上Γオペレーションの定義

   Λ(Γ(g))
 = Λt&amp;lt;x, t| Exec(g(x), t) &gt;
 // イータ・コード化ルール（ドットの使用）
 = &amp;lt;x| λt.(g(x)・t) &gt;
 // イータ仮説、イータ変換の実施
 = &amp;lt;x| g(x) &gt;
 // 大きいラムダのイータ法則
 = g
&lt;/pre&gt;

大きいラムダ計算は、対象となる（オブジェクトレベル）の言語／計算ではなくて、記述用の外の言語だから妥当性は天下りに信じるか、直観に訴えるしかない。大きいラムダ計算でも、アルファ、ベータ、イータの法則（等式）がある。

+ アルファ： &amp;lt;x | f(x)&gt; =  &amp;lt;y | f(y)&gt;
+ ベータ： &amp;lt;x | f(x)&gt;(a) =  f(a)
+ エータ： &amp;lt;x | f(x)&gt; =  f

*1232610732*[セミナー][プログラム意味論]イデアルコンパイラ

本編のhttp://d.hatena.ne.jp/m-hiyama/20070813/1186984585 「圏論的指数の周辺：ラムダ計算、デカルト閉圏、ノイマン型コンピュータ」とか、http://d.hatena.ne.jp/m-hiyama/20070816/1187250855「圏論的指数の定義」とかで述べているが、「fのラムダ抽象f^を作り、f^の出力を得る」とfをコンパイルしたことになる。ただし、f^に引数（パラメータ）が残っていると、f^はパラメータを渡すと実行コードを吐き出す仕組みとなる。

f^はコンパイラと言えばコンパイラだが、実行コードジェネレータとでも呼ぶほうがいいだろう。「fをコンパイルする」という目的で考えると、ラムダ抽象で実行コードジェネレータを作りだし、次にジェネレータを動かしてコードを吐き出させることになる。

以上の手順は、関数ｆに対して、実行コード（関数コード）φを作るので、あきらかにコンパイラだが、ソースfは理念的な存在物だからイデアルコンパイラと呼んでおこう。もちろん、イデアルコンパイラとは、ラムダ抽象＝ラムダオペレーションの別名に過ぎないが。

*1232614075*[記録]寄付の使い道

- Tクリップファイル ￥630
- コクヨ クリップホルダー ￥966

*1232616416*[セミナー]ひたすら記号計算としてのラムダ計算

表記のような計算はまったく触れないことにした（http://d.hatena.ne.jp/m-hiyama/20090109/1231481303参照）。が、ネタは考えていたので後日の為列挙しておく。

+ λ(f, g).λx.g(fx) 合成
+ λx.λy.λz.x(yz) 同じく合成
+ チャーチの数と掛け算（足し算は難しすぎ）
+ SKK = I の話
+ spl = (λx.xx)(λx.xx)
+ (λab.b) spl I
+ W = λh.f(hh), Y = λf.WW 不動点演算子
+ True = λxy.x, False = λxy.y
+ IfThenElse L M N = (LM)N = LMN


</body>
</day>
<day date="2009-01-27" title="">
<body>
*1233021108*[高次圏論][プログラム意味論]圏の圏化としての高次圏

自然演繹とシーケント計算の関係は圏の圏化になっているような気がする。圏化とは、イコールを同型で置き換えることだが、一般化すると、nセルのイコールを(n+1)の可逆セルで置き換えることだ。

書き換えルールや書き換え系が重要な例。書き換えルールの適用列をセルだと思うと、「そのセルの変形＝書き換え履歴の書き換え」が出てくる。リファクタリングとか最適化だな。

*1233021576*[気付いた][多圏]コンパクトシーケントと従順多圏とモノイド圏

まず、コンパクトシーケントとは、コンパクト論理のシーケントで、左辺と右辺のカンマの解釈が同じもの。古典論理のシーケントとは違う。次のような規則を使う。

&lt;pre&gt;
  Γ ⇒ Δ,Δ'   Δ',Ψ ⇒ Φ
  ----------------------------[右Cut]
    Γ,Ψ ⇒ Δ,Φ


  Γ ⇒ Δ',Δ   Ψ,Δ' ⇒ Φ
  ----------------------------[左Cut]
    Ψ,Γ ⇒ Φ,Δ

 
  Γ,A ⇒ B
  ---------------[右o--導入]
  Γ ⇒ A o-- B

  A, Γ ⇒ B
  ---------------[右--o導入]
  Γ ⇒ A --o B

  A, B ⇒ Δ
  -----------[左∧導入]
  A∧B ⇒ Δ

  Γ ⇒ A, B
  -----------[右∧導入]
  Γ ⇒ A∧B
&lt;/pre&gt;

他にも規則はあるが、とりあえず先に進む。

このシーケント計算のモデルとして、扱いやすい多圏を導入する。従順多圏と呼ぶことにする。Oが基本対象の集合、O&lt;sup&gt;*&lt;/sup&gt; がOから作った列の集合として、O&lt;sup&gt;*&lt;/sup&gt;の元は Γ, Δなどで書く。Oの元はA, Bなど。圏と同様に、dom, cod, idを持つ。そして、右cutと左cutが2つの結合を与える。並置が標準的なモノイド積となる。

従順多圏には標準的に圏が含まれる。長さ1の多対象をdom, codにする多射だけを考えると、これは圏となる。これを従順多圏のコア圏と呼ぶことにする。コア圏に、対称とは限らないモノイド積と2つの指数が与えられているとき、従順閉多圏と呼ぶことにする。コア圏は右自立かつ左自立なので自立圏となる。

さらに、コア圏に、A&lt;sup&gt;**&lt;/sup&gt; = A、(A×B)&lt;sup&gt;*&lt;/sup&gt; = B&lt;sup&gt;*&lt;/sup&gt;×A&lt;sup&gt;*&lt;/sup&gt;、(A o-- B)&lt;sup&gt;*&lt;/sup&gt; = (B&lt;sup&gt;*&lt;/sup&gt; --o A&lt;sup&gt;*&lt;/sup&gt;)、(A --o B)&lt;sup&gt;*&lt;/sup&gt; = (B&lt;sup&gt;*&lt;/sup&gt; o-- B&lt;sup&gt;*&lt;/sup&gt;) を満たすようなスターオペレータがあるとすると面白い。このスターオペレータに関して、AとA&lt;sup&gt;*&lt;/sup&gt;を結ぶ τ&lt;sub&gt;A&lt;/sub&gt; : A→A&lt;sup&gt;*&lt;/sup&gt; があって、τ&lt;sub&gt;A&lt;/sub&gt;;τ&lt;sub&gt;A*&lt;/sub&gt; = A となってほしい。τはハーフツイスト射になる。

この状況で示せる典型的な公式として、軸反転（pivoting）公式がある。X&lt;sub&gt;A,B&lt;/sub&gt;を対称ブレイディング（クロス）、τをハーフツイスト、LΛとRΛをそれぞれ左抽象、右抽象とすると：

- LΛ(X&lt;sub&gt;A,B&lt;/sub&gt;;f);τ = RΛ(f)

が示せる、つうか示せるように定式化すべき。

*1233026422*[子供][後で消す]木曜午後4時

備忘。

*1233039245*[セミナー][小咄]簡略オダンゴ図

ラムダバブルを二重丸、三重丸で描くと少し図が簡略になる。そのとき、もとの（カリー化する前の）関数のアリティ（引数の個数）を知りたいなら、丸の数を0, 1, 2, ... と勘定し、それと、上に出ている線の本数を足す。丸の数は0から勘定する、なぜなら一番内側はバブルではなくてオダンゴの輪郭だから。

&lt;img src=&quot;http://www.chimaira.org/img2/curry-pict-2.jpg&quot; &gt;

下に出ている束に含まれる線の数は、(0から勘定した丸の数)+1 = (1から勘定した丸の数) となる。

常にフルカリー化しておく約束だと、上に出る線はないので、
- アリティ = (0から勘定した丸の数)、
- (下に出ている線の数) = アリティ+1、
- 特にアリティ=0 ならば、丸が一重で、下に出ている線は1本。

常にフルカリー化して考える流儀だと、定数はアリティ0、関数はすべて1引数と考えていい。ただし、関数に引数を渡すには、eval/applyを表す「・」と組み合わせる。「定数または1引数関数のみ」と単純化されるのがうれしい。

</body>
</day>
<day date="2009-01-28" title="">
<body>
*1233100829*[セミナー][小咄]関数合成をするコンビネータ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090122/1232616416&quot;&gt;ひたすら計算&lt;/a&gt;とは違った感じで合成（結合）を扱ってみる。

(f;g)(x) = g^・(f^・x) が成立することを示す。まず、&lt;f, g, x| g^・(f^・x)&gt;を考える。正確には、&amp;lt;f, g, x| Exec(g^, Exec(f^, x))&gt; だが略記した。これをフルカリー化すると &amp;lt;|λf.λg.λx.(g^・(f^・x) &gt;、この引数なし関数（値はコンビネータ）をcとする。c()をcとも書く。

c・f^・g^ は、(f;g)^ になっている。よって、

- (f;g)^ = c・f^・g^
- (f;g)(a) = (f;g)^・a = c・f^・g^・a

それと、K = Λ(Λπ) なんてのも出る。πは直積の射影。

*1233101857*[多圏][モノイド圏]モノイド従順多圏、コア圏、計算

Oが基本対象の集合として、Pは、O&lt;sup&gt;*&lt;/sup&gt;にdom/codを持つ多射からなる多圏とする。多射の合成は2種類あり、f: Γ ⇒ Δ,Δ' と g:Δ',Ψ ⇒ Φ に対する f[;&lt;sub&gt;Δ'&lt;/sub&gt;]g と、  f:Γ ⇒ Δ',Δ  と g:Ψ,Δ' ⇒ Φ に対する f[&lt;sub&gt;Δ'&lt;/sub&gt;;]g の2種。適当な公理は満たす。

それとは別に、並置によるモノイド構造を持ち、厳密な単位律と厳密な結合律が成立する。さらに、コア圏には普通のアクチュアルなモノイド構造と右指数(o--)、左指数(--o)があるとする。Pのコア圏はCとする。

このとき、コア圏のn個の直積C&lt;sup&gt;n&lt;/sup&gt;を多圏Pに自然に埋め込める。単に平行に並べると考えればよい。C&lt;sup&gt;0&lt;/sup&gt;は単元圏（非空な自明圏）だが、これは空列εからなる部分多圏にマップされる。結果的に、CのクリーネスターがP内に全部埋め込める。

Pにn-タプリングとn-アンタプリング（デタプリング）があれば、それを使ってT:P→Cという写像を作れる。

+ 空 |→ I（モノイド単位）
+ A |→ A
+ A&lt;sub&gt;1&lt;/sub&gt;,...,A&lt;sub&gt;n&lt;/sub&gt; |→ A&lt;sub&gt;1&lt;/sub&gt;×...×A&lt;sub&gt;n&lt;/sub&gt;
+ f:A&lt;sub&gt;1&lt;/sub&gt;,...,A&lt;sub&gt;n&lt;/sub&gt; → B&lt;sub&gt;1&lt;/sub&gt;,...,B&lt;sub&gt;n&lt;/sub&gt;に対して、τ&lt;sub&gt;A1,...,An&lt;/sub&gt;;f;ν&lt;sub&gt;B1,...,Bm&lt;/sub&gt;。

τ（タウ）とν（ニュー）は、多圏におけるタプリングとアンタプリング操作（多射である）。

このような操作をもっと丁寧に定義すれば、多圏Pを圏とみなして（それはやろうと思えばできる）関手T:P→Cが作れる。これはレトラクトになっている。

PとCの関係は「式と値」と同じだ。Pは還元可能だから「式」、Cはそれ以上還元できないから「値」。式の還元のタイミングはいつでもよい。Pの多対象、多射をレトラクトでCにマップすることが計算的意味論を与えていると思える。単に計算を遂行するにはPのほうがずっと便利だ。PはコアCのハロ（halo）だと思うといいだろう。&lt;strong&gt;ハロ多圏&lt;/strong&gt;だな。

ちなみに、多圏と圏の関係を考えるときに、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177558963&quot;&gt;Turaevゲーム&lt;/a&gt;のムービーやスチルの考え方が使える。

- [http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177580259:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070418/1176881401:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080927/1222506589:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080820/1219198533:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080806/1217986856:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20070418/1176881492:title]

*1233103138*[リンク][DFD][復習]Gauge theory of things alive and universal dynamics

- ゲルハルト・マック http://d.hatena.ne.jp/m-hiyama-memo/20080207/1202355931

を見よ。

*1233114650*[気付いた][多圏][モノイド圏]ハロ多圏とコア圏

結局、ハロ多圏の多射が項であって、コア圏の射が値だな。多射は図形だが、それは構文的な存在でもあり、項書き換えの対象となる。つまり、書き換え操作が計算であり2-多射でもある。計算の結果を対応さると、式と計算の意味論ができて、多圏のほうには、2-多射を使った1-同値が定義できるってことだろう。

*1233135596*[雑感][メモ]後でもっと書くかも

ゲンツェンが構造規則と論理規則を分けた理由がサッパリわからなかったが、ハロ多圏とコア圏で考えてはじめて納得がいった。しかし、エライ人は、50年も100年も先を見られるんだな。なんでシーケントを考えついたのだろう？ 奇跡に思えるよ。

ハーフツイスト＝180度ネジリはけっこう面白い。ブレイドとほぼ同じものだが、双対（スター）と関わる点が少し違う。ヤンキングやフルツイスト＝360度ネジリとどう関係するのだろう？

ハロ多圏とコア圏の考え方を、テンソル計算に使えないか？ そもそもテンソル計算では、形式的行列やテンソルを作って、もとの圏をその内部に埋め込み、レトラクト関手が存在することを確認している。ある圏や高次圏の構造を、そのハロ構造（構文構造、項と計算）から定義できる気がする。そのとき、「値は式に埋め込むことができて、式の計算結果が値」という小学校以来の直感が使えるだろう。


</body>
</day>
<day date="2009-01-29" title="">
<body>
*1233202398*[雑感][説明][論理][セミナー]アニメーションとしての証明

僕が知る限り、自然演繹（他のシステムでもいいのだが）の証明過程を証明図のアニメーションだという説明を見たことがない。証明図が静的な図形のように語っている。これはいけない、これでは本質がわからない。

計算も動的（時間的な推移）だし、証明も動的だ。アニメーションの全過程（履歴）が証明であって、個々の証明図はスナップショットに過ぎない。マー確かに、最後の証明図に途中経過は織り込まれている（木の年輪みたいな感じ）なのだが、中間で大きく変形することもある。その変形の痕跡を全部最後の証明図に織り込むのは難しい。

特に、含意導入では仮定が消えるので、消えた仮定をどう図示するかは、単に図示方法の問題としても難しい。公理と仮定だけの図をt=0（tは時間）において、t=1まで変形させた軌跡を全部考えるのが正解。t=0 は空図形だと思ってもいい。すると、真空からt=1の図形（これは結論を意味する）が生まれる過程になる。

なんかコボルディズム圏に似てるな。

|* 計算   |* 証明 |
| 項      | 証明図（スナップショット） |
| 還元    | 推論＝証明図の変形 |
| 計算    | 証明過程 |
| 等式    | メタな主張／判断 |

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080526/1211759810&quot;&gt;ジラール（Girard）のthe big picture&lt;/a&gt;とも関係しそうだ。

*1233202716*[復習][圏一般論]シェープクラスからの新しい圏（複圏、多圏）の構成法

- トラス（truss）圏構成 http://d.hatena.ne.jp/m-hiyama-memo/20070117/1168993359

この定義を拡張できるかも。ブレイドとか、その他、なんらかの複体とみなせる図形的対象の圏または複圏、またはマグマを考える。これはシェープの集合だが、なんらかの結合演算は入っている。それだけではなくて、高次の射（膜、変形）も入っている。シェープから、圏（高次圏かも）への写像を考えると、それが多射とか行列とか回路になるような気がする。

基本概念はシェープのクラスS、C内の図式（ダイアグラム；シェープから圏へのグラフ写像）、図式の結合や積。どうも、カテグラフとも同じ概念のようだ。圏CをSで拡張する話とも受け取れるし。

値の圏Cがあるとき、シェープクラスSや結合演算を適当に定めて、Diag(S, C) を作ると、新しい圏が自動的に作れる、となりそうだが。

</body>
</day>
<day date="2009-01-30" title="">
<body>
*1233283892*[WCC][msched]アロケーションの基本

&lt;h4&gt;基本的な定義&lt;/h4&gt;

以下、a, b, cなどは任意の実数（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090115/1232001436&quot;&gt;+∞、-∞を含むかも知れない&lt;/a&gt;）、x, y, zなどは0以上1以下の実数だとする。[a, b;x]のような形式を考える。これは、aとbを端点とする区間を表し、それに実数xが付随している。[a, b;x]で表現される対象を&lt;strong&gt;重み付き区間&lt;/strong&gt;（weighted interval）と呼ぶ。

a＞b のとき、[a, b;x]は空集合、[a, a;x]は一点となる。便宜上、空区間を[;x]、1点区間を[a;x]と書く。これらはゴミ扱いされるが、計算の途中では出てくるかもしれない。空でも1点でもない（重み付き）区間を&lt;strong&gt;プロパーな区間&lt;/strong&gt;と呼ぶ。

重み付き区間をα、β、γなどギリシャ小文字で表す。また、単に「区間」と言っても重みが付いているとする。重み（重さ）は、本来実数値だが、現実にはパーセント値として0から100の整数で表す。が、ここでは理屈の話だから実数のまま扱う。

区間α = [a, b;x]に対して、begin(α) =  a, end(α) = b, dur(α) = (b - a) とする。空区間は考えない（例外だ）。

区間のリスト[α1, α2, ...]を考える。begin(α1)≦begin(α2)≦ ... となっているとき、このリストは&lt;strong&gt;整列されている&lt;/strong&gt;という。以下で区間のリストを考えるとき、たいていは整列されているとする（整列されてなかったら、まずは整列する）。

区間のリストがあるとき、それをより簡略な形にすることを考える。まず、一点区間は除いておく（空区間は最初から入らないようにすべき）。つまり、すべての区間はプロパーだとしよう。

&lt;h4&gt;リストの正規化&lt;/h4&gt;

[a, b;x]と[c, d;y]がリスト内で隣り合う区間だとする。次の条件を満たすとき、&lt;strong&gt;縮約可能&lt;/strong&gt;という。

+ x = y （重みが等しい）
+ b = c  （ピッタリくっついている）

このとき、[a, b;x]と[c, d;y]を[a, d;x]に置き換える操作を&lt;strong&gt;縮約&lt;/strong&gt;（contraction）と呼ぶ。縮約すると、リストの長さが1つ短くなる。縮約は何度も繰り返し行えるかもしれない。

[a, b;x]と[c, d;y]がリスト内で隣り合う区間だとするとき、c＜b なら、その区間対は&lt;strong&gt;オーバラップ&lt;/strong&gt;しているという。オーバラップしている区間対を次の3つの区間に分ける。

+ [a, c;x]
+ [c, b;x+y]
+ [b, b;y]

a=cのときは、最初の区間が点区間になるので捨てる。b=dのときは、3つ目の区間が点区間になるので捨てる。この操作を（うまい名前がないので）&lt;strong&gt;オーバラップ解消&lt;/strong&gt;と呼ぶ。オーバラップ解消で、2つの区間が3つ、または2つ、または1つになる。

次の条件をすべて満たすリストは&lt;strong&gt;正規形&lt;/strong&gt;と呼ぶ。

+ 整列されている。
+ すべての区間はプロパーである。
+ 簡約可能な対が存在しない。
+ オーバラップしている対が存在しない。

任意に与えられたリストを正規形にすることを&lt;strong&gt;正規化&lt;/strong&gt;と呼ぶ。normalizeを正規化する関数だとすると、
- Aが正規形 ⇔ normalize(A) = A
- normalize(normalize(A)) = normalize(A) 
であることに注意せよ。

&lt;h4&gt;オーバーフローとアロケーション&lt;/h4&gt;

リスト[α1, ...]があるとき、これを正規化すると、重みが1を超える区間が生じることがある。正規化後に重みが1を超える区間を持つようなリストは&lt;strong&gt;オーバーフロー&lt;/strong&gt;しているという。

consをLispの意味でのリスト操作として、cons(α, A) がオーバーフローしないとき、区間αはリストAに&lt;strong&gt;consable&lt;/strong&gt;と呼ぼう。

区間とは別に、(d, x)という形を考える。これは「durationがd、重みがx」という意味で、beginが指定されてない（未定な）区間の表現と考える。区間[a, b;x]が、b - a = dのとき、(d, x)の&lt;strong&gt;実現とか具体化&lt;/strong&gt;と呼ぶ。

&lt;b&gt;[追記]&lt;/b&gt;以下のアロケーションの記述で、αの位置に関して上限と下限の&lt;em&gt;条件が抜けている。&lt;/em&gt;実際には、実数s, tがあって、アロケート可能な範囲は[s, t]内に限定する。この条件がないと、無意味なアロケーションを許すことになる。&lt;b&gt;[/追記]&lt;/b&gt;

リストAが与えられたとき、(d, x)の適当な実現αが存在して、αがAにconsableなとき、(d, x)はAにおいて&lt;strong&gt;アロケート可能&lt;/strong&gt;という。αは、(d, x)のAにおける&lt;strong&gt;アロケーション&lt;/strong&gt;であるという。アロケーションはたくさん（無限に）あるかもしれないので、特定のアロケーションを&lt;strong&gt;アロケーション・インスタンス&lt;/strong&gt;とも呼ぶ。

オーバーフローしてないリストAと、(d, x)を与えられて、アロケート可能かどうかを判定する問題、そして、アロケート可能ならアロケーション・インスタンスを決定する問題を&lt;strong&gt;アロケーション問題&lt;/strong&gt;と呼ぶ。アロケーション問題が解けるのはあきらかなので、効率的なアルゴリズムや美しい(?)データ構造を求めることが興味の対象となる。

&lt;h4&gt;さらに&lt;/h4&gt;

上に述べたアロケーション問題は、もっとも簡単なケースであり、実際にはもっと複雑になる。簡単なケースが解けないでは複雑はケースが解けるわけがないので、簡単なケースを十分に理解する。

*1233306598*[WCC][msched]フリーリストからのアロケーション

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090130/1233283892&quot;&gt;「アロケーションの基本」&lt;/a&gt;では、予約済み区間のリストAと全体区間[s, t]を与えて、(d, x)を&lt;em&gt;残りの部分&lt;/em&gt;からアロケートする方法を説明した。ここでは、リストに空き区間が保持されている状況でのアロケートを考える。

&lt;h4&gt;包含（inclusion）関係&lt;/h4&gt;

α=[a, b;x]、β=[c, d;y]として、次が成立すれば α⊆β。

+ c≦a
+ b≦d
+ x≦y

これが（重み付き）区間の&lt;strong&gt;包含関係&lt;/strong&gt;。四角形のイメージで考えれば自明だろう。

α=[a, b;x]のとき、a＜a1＜b であるa1を取って、[a, a1;x], [a1, b;x]の2つの区間に分けることを&lt;strong&gt;分割&lt;/strong&gt;という。より一般に、a=a0, a1, ..., an=b を使った分割が考えられる。分割は縮約のちょうど逆の操作になる。

準備ができたので、αは重み付き区間、Bが[β1, ..., βn]というリストのとき、α⊆A の定義を考える。リストBは正規化されているとする。適当なi（1≦i≦n）があって、α⊆βiなら当然に α⊆B だが、それより少し一般化した定義を与える。

- αの適当な分割α1, α2, ..., αkがあって、どのαiも、Bの要素である区間に含まれるなら α⊆B 。

これも、図形イメージで考えると割と当たり前。

&lt;h4&gt;包含の判定&lt;/h4&gt;

与えられた区間αと（正規な）リストBに対して、α⊆B を判断するのはめんどくさい。正直に定義に従うと、αの分割が必要になる（ことがある）。αの分割を避けるため、Bのほうに細工をしておく方法がある。

β=[c, d;y]とβ'=[c', d':y']が&lt;strong&gt;接合&lt;/strong&gt;（あるいは&lt;strong&gt;隣接&lt;/strong&gt;）しているとは、d = c' なこと。正規なリストが与えられと、簡単なアルゴリズムで隣接している区間をグループにまとめられる。例えば、[α, β, γ, δ]で、αとβ、βとγが隣接していて、他に隣接する対がないとき、[&amp;#91;α, β, γ], δ] という入れ子のリストを作れる。

上記[α, β, γ]のように、隣接している成分からなるリストは、図形的には連結成分を表す。今までの表現では、2次元領域を“縦に割って”表現してきたが、連結成分なら横割りにもできる。「縦割り表現→横割り表現」の操作を各連結成分に施す。この変換操作はコストがかかるが、包含の判定のときには便利になる。詳細は割愛、図を描いて考えればわかるはず。

&lt;h4&gt;フリーリストとアロケーション&lt;/h4&gt;

重み付き区間[a, b;x]を、「xだけ使用されていて、1-xの空きがある状況」だと解釈する。特に[a, b;0]は区間[a, b]が完全に（100%）空いていることを示す。重み付き区間α1, ..., αnからなるリストA=[α1, ..., αn]を&lt;em&gt;空き&lt;/em&gt;を記述するフリーリストだとする。

(d, x)が与えられたとき、(d, x)の実現である区間αがあり、α⊆Aのとき、(d, x)はフリーリストAから&lt;strong&gt;アロケート可能&lt;/strong&gt;という。

&lt;h4&gt;予約（使用）リストとフリーリストとの関係&lt;/h4&gt;

予約または使用されている区間のリストA=[α1, ..., αn]と、全体区間[s, t]が与えられると、それから簡単にフリーリストを構成できる。

リスト[α1, ..., αn]の要素を順に見ていく。隣り合う２つの区間[a, b;x], [c, d:y]がb＜cのとき、&lt;strong&gt;ギャップがある&lt;/strong&gt;という。ギャップがあるとは、接合（隣接）してないことである。ギャップがあるとき、ギャップ区間に重さ0を与えた区間を挿入することによりギャップを埋めることができる。すべてのギャップを埋めたリストを作る。

リスト[α1, ..., αn]は、既にギャップが埋められ、全体区間[s, t]を覆い尽くしているとする（重さが0の部分があってもよい）。各区間の重みxを1-xに置き換えるとフリーリストができる。このフリーリストをもとにアロケーションをしてもよい。

</body>
</day>
<day date="2009-02-02" title="">
<body>
*1233530101*[雑記][復習]笑える

- 左双対を検索 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%ba%b8%c1%d0%c2%d0

*1233530102*[タグ説明]「タグ説明」タグについて

タグの数が増えてきたので、[タグ説明]というタグで、タグの説明を書くことにする。例えば、[タグ説明][論理] とタグ付けされたエントリーでは、[論理]タグの説明を書く（[論理]タグは説明不要だがね）。

という次第で、[タグ説明]タグの最初の使用例は、[タグ説明]タグ自身の説明でした。

＃このエントリーはメタ循環しているよな。

*1233530213*[タグ説明][セミナー]「セミナー」タグについて

もともとは、2009年1月24日セミナー用だったが、「もしセミナーをやるなら」というネタはすべて「セミナー」タグに書くことにする。思い付きや小咄でも、それがセミナーの話題として使えそうなら「セミナー」タグを付ける。

*1233530214*[タグ説明][紛失物]「紛失物」タグについて

探しても見つからないモノを書く。見つかれば消すだろう。

*1233530350*[紛失物]黒くて薄いコンパイラ本

あったはずだ。どこにいった？？ とりあえず、簡単なスタックマシンの仕様がみたい。ヴィルトのは簡単すぎるし。

*1233530351*[紛失物][探してみる]近藤基吉先生の黄色い本

これは元々手元にはないのだが、田舎の倉庫にある可能性が多少は残っている。僕にとっては、あれは名著だ。

*1233530352*[メモ法]トラックバック設定

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080104/1199431728&quot;&gt;「はてなの自動トラックバック」&lt;/a&gt;の方針では、自動トラックバックを活用すべし、だが、本編にやたらにトラックバックが貯まるのも鬱陶しい。で、本編において、メモ編からのトラックバックを拒否にしてみた。

*1233530682*[WCC][msched]アロケータへの問い合わせとその応答形式

いくつか（かなり大量）のコンテナを管理し、アロケーションに責任を持つモジュールなりサーバーなり（実体は問わない）をとりあえずアロケータと呼ぶ。アロケータはリソース管理系の中核機能を抽象的に指す言葉になる。

アロケータは、実際のアロケーションを行うだけでなく、リソース状況の問い合わせに答える責務がある。特に、(d, x)（durationとweightの組）が与えられたとき、(d, x)のアロケーションが可能かどうか、可能なら「&lt;em&gt;すべてのアロケーション候補&lt;/em&gt;」（理論的には無限集合）を返す必要がある。

(d, x)に対してbegin値aが決まれば、実現[a, a+d;x]が決まるので、「begin値←→アロケーションインスタンス」の対応がある。よって、「begin値の集合←→アロケーションインスタンスの集合」となる。begin値は単なるスカラーなので、実数直線内の集合だが、これは互いに交わらない有限個の区間の合併で表現できる。

有限個の区間は、区間（[a, b]の形）のリストで表現可能だが、次の意味で正規化しておく。

+ 空区間や1点区間は含まない。プロパーな区間だけ。
+ 区間達は整列されている。
+ リスト内で隣り合う2つの区間は離れている。

「離れている」とは、隣接もオーバラップもしてないこと。つまり、[a, b]と[c, d]が離れているとは、b＜c のこと。オーバラップ（c＜b）または隣接（b = c）していれば縮約して1個の区間にできる。空集合は空リストで、単一のプロパー区間は要素を1つ持つリストで表現できる。

正規化された（重みはない）リストも非常に重要なデータ構造で、このデータ（意味は実数の部分集合）に関する集合演算（∩、∪）が後で役に立つ。重みが1に固定された区間群を扱うときも、重みを省略して区間や区間のリスト（意味的には実数直線内の集合）の演算が使える。

*1233531568*[小咄][セミナー]頭山とのっぺらぼう

ほんとに落語の話（咄）なのだが、頭山は再帰つうかスノーグローブ現象だよね。

今朝の子供番組で「のっぺらぼう」も再帰構造だと知った。のっぺらぼうの娘さんに会ってビックリ、坂を駆け上って会った男の人がのっぺらぼう、という夢を見てさめて話した女房がまたのっぺらぼう、という夢を見てさめて話した女房がまたのっぺらぼう、…

*1233533072*[連絡的]オモチャの圧縮実験

最大一致スライディング辞書方式によるアスキーテキストの圧縮をしてみる。一致検査をする最大バイト数とファイルの最大サイズを適当に決定する。

+ 欠点：7ビットテキストにしか適用できない
+ 欠点：ファイルの最大サイズが制限される
+ いい点：1パスで済む
+ いい点：簡単
+ いい点：最悪でもそのまま

拡張子.comp は自動的に付加、拡張子に基づく操作。それなりに安全に作る。動作を強制するオプションがあればbetter。

- &lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20080611/1213164122&quot;&gt;c2fとか名付けていたトッツァン（僕）が、関数や変数のネーミングについて最近思うこと&lt;/a&gt;

*1233567899*[WCC][msched]ホワイトコンテナとグレーコンテナ

ホワイトとグレーという“色”は比喩的なもので、実際の色ではない。が、&lt;em&gt;あたかも背景色&lt;/em&gt;であるように語る。白は空きリソースを意味し、グレーは予約済みでもなく空きでもない&lt;em&gt;未定リソース&lt;/em&gt;を表す。

白が背景であるコンテナーは予約部分（赤や緑の色が付いていると考える）以外＝白い所はすべて空きだと考える。よって、予約リストから、その補集合として空きリストを計算できる。空きリストを別に持つ必要はない（効率のためには持つかも知れないが）。

一方、グレーコンテナのグレーの部分は、予約してないリソースだが、かといって空き（白）でもない。空きリソースは、明示的に白で指定しなくてはならない。つまり、グレーコンテナ内の空きリソースとは、それが空きだと予約されたものである。背景が白ではないので、赤や緑と同様に白もまた予約して&lt;em&gt;塗る&lt;/em&gt;必要がある。

背景を白にするかグレーにするかは、コンテナの生成時に指定するが、途中で変更することもできる。

</body>
</day>
<day date="2009-02-03" title="">
<body>
*1233620192*[気付いた][プログラム意味論]ゲッ、直積が直和だから、、、あーそうか！

関係圏Relでは、圏論的直積が集合論的直和で与えられる。僕は、これは単に面白い小咄（地口落ち）だと思っていた。が、いやいや重要ですぜ。今まで奇妙に感じていたことがこれで解明される。

デカルト圏の対角Δが、なぜか直和へのコピーに解釈されることがあって、違和感を持ち続けてきた。しかし、射が関数でも部分関数でもなくて、関係であるとすると、デカルト積が集合としては直和で与えられるのは当たり前だった。

集合圏で考えていると、始対象と終対象が違うのも都合が悪いのだが、関係圏では、どっちも空集合で与えられるんで、空集合を⊥と書くとツジツマが合う。余対角∇も導入できて、Δ∇ = 1 も言えるので加法的ペキ等圏（1 + 1 = 1の圏）になる。

関係圏が&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090114/1231911574&quot;&gt;フーフマンの線形圏&lt;/a&gt;になるから、ベクトル空間の直和＝直積＝双積と同じ感覚で扱えばいいのだ。集合論的直積はテンソル積だ。なるほど、これは自然だ。

*1233620193*[プログラム意味論][多圏][説明]タブリング＝パッカー＝待ち合わせ同期

タプリングの意味を並列計算やデータフロー計算で考えてみると、2つ以上のデータをパックして1つのデータ（かたまり）にすることだが、これはまた、すべての成分データが揃うまで待つので、&lt;em&gt;データ同期&lt;/em&gt;を表していることになる。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090128/1233101857&quot;&gt;コア圏とハロ多圏&lt;/a&gt;のモデルを使うと、コア圏は同期逐次的な関数計算を表していて、ハロ多圏が非同期並列的なデータフロー計算を表してることになる。結合、モノイド積、トレースなどの演算も、コア圏とハロ多圏では解釈が違う。構文的には違いが分かりにくいので、もっと精密なセマンティクスが必要だ。

多圏をデータフロー計算とみなすってのはいい観点だと思う。引数評価が終わる前に関数（というべきか？）本体が評価できるので、call by name っぽい計算ともいえる。バート（古いプログラム理論本の著者）は、eal方式（evaluate arguments last）と呼んでいたが、ようするに遅延評価。

んで、遅延評価なんだけど、計算が途中まで進行した&lt;em&gt;結果の式&lt;/em&gt;が渡されるという解釈と、計算を途中まで遂行した&lt;em&gt;状態の計算体&lt;/em&gt;（プロセスのようなもの）へのチャネルを渡される（引きずり回す）という解釈がある。モノ（式）が移動すると考えれば移動経路、チャネルが引きずり回されると考えれば通信用ワイヤーが図示されるべき。

運動（移動）軌跡とチャネルワイヤーという対比も説明には便利かもしれないな。副作用がなければコピー（モノ）と参照（チャネル）の区別は必要ないもんね。

*1233626763*[プログラム意味論][気付いた]テレスコープ展開

関数解析だか微分方程式だかでテレスコープ展開というのがあったと思うが、忘れた！

で、本来の意味のテレスコープ展開はどうでもよくて、再帰方程式 f = F(x, f) を有限回展開して絵に描くと、これはまさにテレスコープ展開。テレスコープ展開で絵を変形して不動点定理を示そうと思っているんだが、うまくいかない。（上から下の図で）下にテレスコープが伸びるのを横にも伸ばす感じに変形すればよさそうだが、、、

*1233638784*[論理][モノイド圏][気付いた]モノイド圏からシーケント計算の作り方

一気にドカッと書こうと思っていたけど、無理そうだからチマチマ書こう、っと。

モノイド圏からハロ多圏を作って、そのハロ多圏上でシーケント計算を作る処方箋が分かってしまったよ、ムフムフ。

もとになるモノイド圏だが、これにはいろいろなオペレータが付いていてもいい。主に考えるオペレータは：

+ ラムダオペレータ（抽象、カリー化、指数、閉性）
+ Conway流不動点オペレータ
+ トレース

の3つだ。カザネスク／ステファネスク／ハイランド／長谷川の定理によれば、デカルト圏では不動点オペレータとトレースが同値だが、一般的文脈では違うオペレータになる。

他にアクセサリー的なオペレータとして：

+ 対角Δ
+ 余対角（和）∇
+ ブレイディングβ
+ クロス（対称ブレイディング）σ
+ 放電器!
+ ボトム⊥

など。放電器!とボトム⊥は、記号も概念の由来も違うが双対的。対角と余対角ももちろん双対。

オペレータの挙動が基本推論規則となるので、これらのさまざまなオペレータ、その組み合わせによりシーケント計算も変わる。また、オペレータ（恒等や結合もオペレータとみなす）の推論系としての定式化も、公理、構造規則、論理規則のどれにするかはすごくバリエーションがある。好みが相当入っててしまう。まー、それはいいとしよう。

プレーンな（アクセサリ的オペレータを持たない）モノイド圏では、次の定式化が必要。

+ Aごとの恒等
+ 結合
+ モノイド積
+ モノイド単位

「普通な感じ」で定式化すれば：

+ 恒等は公理（公理シェマ）
+ 結合は左cutと右cutの構造規則
+ モノイド積は論理規則
+ モノイド単位は、定数Iに関する増と減

「定数Iに関する増と減」は構造規則なのか、論理定数の導入消去規則なのかビミョー、まーどうでもいいけど。

推論規則を記述するとき、射（多射）というよりは対象（多対象）を変形することがある。このタイプの規則は略記ができると便利。それで、右側半規則、左側半規則、両側半規則という概念と記法を入れたい。例えば：

&lt;pre&gt;
   A, B
  -------[両:∧導入]
   A∧B
&lt;/pre&gt;
これは両側半規則で、次のような規則に書き換えて（展開して）よい。

&lt;pre&gt;
  Γ, A, B, Δ ⇒ Φ
  -------------------
  Γ, A∧B, Δ ⇒ Φ


  Δ ⇒ Φ, A, B, Ψ
  -------------------
  Δ ⇒ Φ, A∧B, Ψ
&lt;/pre&gt;

半規則の意味は多射である。その多射を前結合（多圏の部分結合だが）または後結合することにより、射に関する規則が得られる。&lt;em&gt;左半規則は下から上に読み&lt;/em&gt;、前結合により規則を得る。&lt;em&gt;右半規則は上から下に読み&lt;/em&gt;、後結合により規則を得る。両側半規則は同型でなくてはならない。

仮定なしでシーケントが証明できれば、そのシーケントが意味する多射がハロ多圏に存在することを保証する。あるいは、そのシーケントが真空から生まれることを保証する。仮定があるなしに関わらず、証明は、多射を1セルとする高次多圏において2セルになる。よって、証明を対象とした計算は2セルの計算になる。恒等証明、証明の部分結合、証明の並置（形式的モノイド積）などは2セル＝証明に対するオペレータ。そして、cut消去など、証明の変形は3セルになる。

*1233639737*[タグ説明][探してみる]「探してみる」タグについて

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090202/1233530351&quot;&gt;近藤先生の本&lt;/a&gt;は紛失物というよりは、探してみる候補。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090202/1233530214&quot;&gt;「紛失物」タグ&lt;/a&gt;とは別に「探してみる」を設ける。これは、田舎とか大書店とか図書館とかに行ったときに探す候補。オンラインで探すこともあるかもしれない。

*1233654262*[探してみる]高橋正子さんの『計算論』

本編の http://d.hatena.ne.jp/m-hiyama/20090126/1232925460 のコメント欄に出てくる。『計算論』て本。

*1233654568*[紛失物]Webサービス、はてな認証

雑誌かムックで、はてな認証について書かれたヤツ。


</body>
</day>
<day date="2009-02-04" title="">
<body>
*1233707181*[論理][モノイド圏][プログラム意味論][気付いた]シーケント計算のPow意味論

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090203/1233638784&quot;&gt;昨日の話&lt;/a&gt;の続き。モノイド圏に意味を持つシーケント計算は、あたりまえだがモノイド圏に意味を持つ。特に、集合直和を圏論的直積＝デカルト・モノイド積とする関係圏で解釈すると具合がいい。だが、ここではあえて集合圏（実際は順序も入るが）を使ってみる。

シーケント計算の論理としては、論理結合子が1つしかないコンパクト論理。否定も含意もない。含意がないからモダスポネンスもないという、ひどく原始的な論理だ。「そんなもん論理じゃねー」 -- ごもっとも。

それでもなお、無理クリにでも命題論理の計算だと思うのだ。基本記号A, Bなどには集合【A】, 【B】などが前もって割り当てられているとする。めんどうなので、【A】, 【B】などを単にA, Bと書く。あるいは、最初からA, Bなどは集合だと思ってもよい。論理式は、基本記号、論理定数I、論理結合子∧、括弧で組み立てた形（構文木）。論理式の意味は：

+ 【A】 = 【A】 （Aは基本記号）
+ 【I】 = φ（空集合）
+ 【α∧β】 = 【α】+【β】（直和）

以下、必ずしも基本記号ではない論理式もA, Bなどと書く。

論理式の列 A1, ..., An の意味は、Pow(【A1】)× ...×Pow(【An】) だとする。特に空列εに対しては、Pow(φ) = {φ} = 1 とする。と、こうすると、シーケントの左も右も順序集合になる。そして、シーケント自体には順序の意味で連続な写像を対応させる。

ミソは、Pow(【α∧β】) = Pow(【α】+【β】) = Pow(【α】)×Pow(【β】) となること。まさにPowは指数関数なので、足し算と掛け算が入れ替わってくれる -- これだけのことだが、とてもありがたい！

この状況を外から眺めてみる； Powを取ると、順序が入るので、【A】&lt;sub&gt;*&lt;/sub&gt; = Pow(【A】) として定義された【-】&lt;sub&gt;*&lt;/sub&gt;は、シーケント計算の順序圏Ordによる意味論となる。実際の議論に必要な性質は、最小限⊥を持つこと（従って非空）、ω完備であることくらいだ。ようするに、ωCPOだ。

シーケント計算のωCPOでの意味論が構成可能だということは、RelからωCPOへの関手があることを示唆する。実際、Powがその関手となる。この関手によって、Rel側のトレースや不動点オペレータがどう写るか、ωCPO側のカリー化などがRelとどう関係するのか、などを調べられる。

</body>
</day>
<day date="2009-02-05" title="">
<body>
*1233792555*[セミナー][論理]ゲーデル符号化、記号とかその解釈とか

あの鉤括弧はUnicodeにあるのか？ '「'の鏡映文字があればいいんだな。とりあえずはG(-)とか書くテもあるが。

本来、ゲーデル符号＝ゲーデル数は論理式とか証明とかに対して付けられている。構文領域から数領域への関数。だけど、構文領域に意味論があるなら（たいていはある）、意味領域から数領域への関数だと思ってもよいだろう。符号が数とは限らないなら、意味領域から符号領域（code space）への関数にまで拡張解釈できる。

Fが意味領域＝リアルワールドに実在する関数のとき、Fのゲーデル符号G(F) = ψ は符号領域の個物。Fが符号領域を定義域とする関数なら、F(ψ)が意味を持つ -- というのがだいたいは自己適用の原理だな。

</body>
<comments>
<comment>
<username>msakai</username>
<body>あの鍵括弧は U+231C TOP LEFT CORNER (&#8988;) と U+231D TOP RIGHT CORNER (&#8989;) ですかね。</body>
<timestamp>1233841565</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>msakaiさん、&lt;br&gt;どうもありがとうございます。自分で調べるのめんどくさい、とかモノグサなこと思っていました。このアンパサンド文字参照はブラウザでちゃんと解釈されるようです。が、フォントがないと悲しいことに、、、</body>
<timestamp>1233878276</timestamp>
</comment>
</comments>
</day>
<day date="2009-02-06" title="">
<body>
*1233898335*[紛失物]モーテル問題のムック

モーテル問題、たしかお見合い問題とも言ったと思うが、それについて書かれていたサイエンス社のムック。物理か確率過程のムックだと思う。

*1233898598*[連絡的]「おまじない」と言われても納得しない感性

Kuwataさん、いいこというよな → http://return0.dyndns.org/log/2009/02/05#s_1

&lt;pre class=&quot;code&quot;&gt;
char c = -1;
int i = -1;
unsigned char u = 0xFF;
&lt;/pre&gt;
なんていう&lt;em&gt;ドウッテコトナイ&lt;/em&gt;代入を見て、どう理解するかだよな。ほんとにリアルにイメージしてるか、と。

ところで、符号拡張ってナーンダ？ 言葉の意味を辞書的に知っていてもしょうがない。ほんとにリアルにイメージしないと。


</body>
</day>
<day date="2009-02-07" title="">
<body>
*1233969563*[論理][モノイド圏]含意、随伴、両側シーケント、片側シーケント

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090204/1233707181&quot;&gt;例の話&lt;/a&gt;の続き。

両側シーケント計算を片側シーケント計算に還元できる場合がある。片側には右側と左側がある。この状況を分析してみると、モノイド圏の閉性（closedness, closure）が背後にある。そして閉性は、随伴により記述できる。

以下、モノイド積に対称性やブレイディングを&lt;em&gt;一切仮定しない&lt;/em&gt;。古典論理なども扱えるように（いや、扱えないけどさ^^;）、モノイド積が∧、∨の2つあるとする。単に2つのモノイド積があるだけでは何にも面白くないのだが、2つのモノイド積の関連性とか一貫性はひとまず置いておく。∧の単位対象がT、∨の単位対象が⊥とする。

圏Cが上で述べた∧、∨、T、⊥を持つとして、典型的含意は4種類考えられる。それぞれ、o--, --o, x--, --x で表す。

+ C(A∧B, C) ＝ C(A, C o-- B)
+ C(A∧B, C) ＝ C(B, A --o C)
+ C(A, B∨C) ＝ C(B --x A, C)
+ C(A, B∨C) ＝ C(A x-- C, B)

o-- と --o  は非対称なコンパクト論理の段階で既に考えていたもの。--x と x-- は今まで出てない。随伴で考えると：

+ (-∧B) -| (- o-- B)
+ (A∧-) -| (A --o -)
+ (B --x -) -| (B∨-)
+ (- x-- C) -| (-∨C)

ハイフンがいっぱい出てくるが、無名変数、随伴記号（逆ターンスタイル）の一部、含意記号の一部なのでヨロシク。

さて、両側シーケントを右片側シーケントに変換する原理は次。

&lt;pre&gt;
  A → B
 -------------
  T∧A → B
 -------------
  T → B o-- A


  A → B
 -------------
  A∧T → B
 -------------
  T → A --o B
&lt;/pre&gt;

これは演繹定理だ。それに対して、両側シーケントを左片側シーケントに変換するときは：
&lt;pre&gt;
  A → B
 -------------
  A → B∨⊥
 -------------
  B --x A → ⊥


  A → B
 -------------
  A → ⊥∨B
 -------------
  A x-- B → ⊥
&lt;/pre&gt;

古典論理やスターを持つコンパクト論理なら、B --x A は ￢B∧A として与えられるから、A |- B  ⇔ ￢B, A |- ⊥ という分解原理のような形となる。

演繹定理や分解原理（だったか？Prologとかの原理）は、古典論理では成立するが、どんな論理でも成立するとは限らない。対称性が乏しい圏では、右片側シーケント化と左片側シーケント化が全然異なる状況になる可能性がある（どっちかはできないとか）。

ある圏のシーケント計算が右片側にできたとする。すると、Δ⇒Γ が証明できることと、⇒R(Δ;Γ) が証明できることが同値になる。ここで、R(Δ; Γ) は、Δを右に寄せた結果である。このRは、任意の射を、Tからの射に変換する働きを持つ。つまり、A, Bに対して対象 R&lt;sub&gt;A,B&lt;/sub&gt;を割り当て、f:A→B に対して、ρ&lt;sub&gt;A,B&lt;/sub&gt;(f):T→R&lt;sub&gt;A,B&lt;/sub&gt;を対応させるオペレータになる。オペレータを推論図で書くなら：

&lt;pre&gt;
    A → B
 ------------[ρ(A,B)]
  T → R(A,B)
&lt;/pre&gt;

圏Cが閉じている、つまり指数（べき）を持つなら、オペレータ(R&lt;sub&gt;A, B&lt;/sub&gt;, ρ&lt;sub&gt;A, B&lt;/sub&gt;)を指数を用いて具体的に表示できることになる。実際、Rは指数演算そのものだし、ρはフルカリー化によって与えられる。

ハロ多圏構成のテクニックを使うと、モノイド圏なら何に対してもシーケント計算が定義できる。閉じた圏なら片側シーケント計算も構成できる。片側シーケント計算は自然演繹と似たようなものなので、ある条件下では圏の自然演繹計算も構成できることになる。やっぱりハロ多圏構成は便利だ。

インフォーマルな道具として便利なのはわかったが、ハロ多圏の形式的な定義は出来てないから、考えないとな。

*1233989641*[セミナー][メモ]氏名公開の承諾とアンケート

氏名公開のご承諾は当日その場で記入していただいて、アンケートのほうは後でメールというのがよさそうだな。

*1233992176*[雑感]時間と体力がない

Erlangとかラムダ計算とかファイバーバンドルとかプロセス代数とか、書きたいことは山ほどあるんだけどなー。土日はあんまり時間取れないし、ウィークディは疲れてるし、来週はチョックラ遊びたいし、、、、

体にいいことはダイッキライだが人より長生きしたい。

</body>
</day>
<day date="2009-02-09" title="">
<body>
*1234135928*[紛失物]ヨアヒム・コックのアレ

フロベニウス代数が知りたい、このあいだまで手元にあったのだけどな？

&lt;b&gt;[追記]&lt;/b&gt;あったーっ。椅子の横に置くことにした。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2009-02-10" title="">
<body>
*1234230561*[雑感][用語法]帰納と再帰

帰納（induction）と再帰（recursion）という言葉は使い分けたほうがいいと思う。のだが、どう使い分けていいか実はわからない。帰納は証明の手法で、再帰は定義の手段だ、とか言えばそれらしい。が、集合の定義で帰納的定義はあるしな。なんとなく、なるべく使い分けよう、わかんないながらに（まったく情けない主張だ）。


</body>
</day>
<day date="2009-02-12" title="">
<body>
*1234421894*[メモ][後で消す]水道と火災保険と鍵とネットワーク

- 水道はどうなっているんだ？
- 鍵はあと一つ作る？

*1234397253*[メモ][プログラム意味論][モノイド圏]タプル再考

ワイヤー図にタプリングするジャンクションを入れる話。タプリングを「待ち合わせによるデータ同期」と捉えられるが、待ちあわせしないタプリングはどうなるだろう？

次のようなジャンクションを考える； aとbが同時（ある範囲の誤差でほぼ同時）に入ってきたときはタプル[a, b]を流す。aだけが入ってきたら [a, ⊥]、bだけがなら [⊥, b]。

これは待ちあわせをしないで、[a, b], [a, ⊥], [b, ⊥] を流すことになる。同時性のチェックを、一定間隔のポーリングで行うなら、入力がないときはタイムチック[⊥, ⊥]を定期的に流すことになる。

この話は、モノイド圏の交替律と&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177558963&quot;&gt;インターリーブ定理&lt;/a&gt;に関連しそうだ。

*1234418990*[モノイド圏][リンク]五角形関係とか色々

結合律と五角形の関係が相変わらず理解できない(ショボ)。Pachner移動と関係するのかも知れない。

- Pachnerの日記内検索→ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Pachner

カーター／カウフマン／サイトウ（J. Scott Carter, Louis H. Kauffman, Masahico Saito）の&quot;Structures and Diagrammatics of Four Dimensional Topological Lattice Field Theories&quot;の最初の16ページを印刷した（以前も印刷したような気がするが）。これは物理の話でわからん、が絵を眺める。

- http://www.math.uic.edu/~kauffman/SD4D.pdf

Ruth M Williamsの&quot;Discrete quantum gravity&quot;のほうはURLが404になっていた。が、次のURLで取れる。

- http://www.iop.org/EJ/article/1742-6596/33/1/004/jpconf6_33_004.pdf?request-id=1f8361df-225c-41be-bfc1-d6a13b8e3204

↑これは、やっぱりわからんね。とりえず今は読めない。

さて、以下はMelliesの&quot;MacLane's coherence theorem expressed as a word problem&quot;：

- http://hal.archives-ouvertes.fr/docs/00/15/42/13/PDF/25_0310mn_Mellies.pdf

これならなんとか読めるかも。

それと、次のPSファイルはひどい、オンラインビューでは不便すぎ、印刷するしかなかったので印刷した。ホップ代数の表現の圏が線形論理のモデルになる、とかいう話。

- Hopf Algebras and Linear Logic 1 Introduction → http://aix1.uottawa.ca/~rblute/hopf.ps

*1234428642*[メモ][その他プログラミング]ActionScriptのメリット

だいぶ昔にActionScript 3を触ったのだった。そのときのメモが発掘された。「ココはJavaよりいいじゃねーの」みたいな特徴が箇条書きで書いてあった。

+ internalスコープ： パッケージローカルな可視性
+ プロパティが定義できる。set count : Void {}, get count : Number {} とか。
+ 従って、フィールドと引数なし関数を区別しなくてよい。
+ 引数にデフォルト値がある。
+ 符号なし整数uintがある。
+ E4Xがある。
+ dynamicクラス。

ActionScriptにfor-in, foreachのような構文がない、とも書いてあるがホントかいな？


</body>
</day>
<day date="2009-02-13" title="">
<body>
*1234485617*[リンク][高次圏論][お絵描き]ストリング図

ストリング図というのは、オダンゴ図のオダンゴを点にしてしまったものだが、2次元の圏論では、領域（チャンバー）内の面の部分を0-セルに割り当てる。

次の論文のchapter 4がストリング図：

- Title: On unitary 2-representations of finite groups and topological quantum field theory (Submitted on 26 Jan 2009)
- Authors: Bruce Bartlett
- URL: http://arxiv.org/abs/0901.3975
- Pages: 243 (PhD thesis)

引用：
&gt;&gt;
String diagrams are a two-dimensional graphical notation for working with 2-categories, and may be regarded as the 'Poincare duals' of the ordinary globular notation.
&lt;&lt;
複数形の使用がおかしい気もするが、、、ともかく、そういうわけだ。The ordinary globular notation とはペースティング図のこと。ペースティング図は確かに球状集合の絵になっている。

ところで、セリンガーはboxes-and-wires図もストリング図と呼んでいるが、これは最高次元のセルが箱やオダンゴ、それより1次元低いのが線ということで一応整合性は取れている。図形的な議論では、箱やオダンゴはワイヤー上の一点にフレーミング（法ベクトル、有向法枠）を付けたものとみなすのがいいようだ。

*1234512135*[メモ][プログラム意味論]簡単なループをトレースで書く

とても簡単なプログラム：
&lt;pre class=&quot;code&quot;&gt;
if (x == 0) {
 z = x;
} else {
 z = 1;
}
&lt;/pre&gt;

同じこと、ただし無駄にループを回す。
&lt;pre class=&quot;code&quot;&gt;
if (x == 0) {
 z = x;
} else {
 while ( x &gt; 1) x--;
 z = x;
}
&lt;/pre&gt;

ループを外す。並列プログラム。
&lt;pre class=&quot;code&quot;&gt;
cobegin {
 if (x == 0) {
  z = x;
 } else {
  w = x;
 }
} and {
 if (y &gt; 1 ) {
  w = --y;
 } else {
  z = y;
 }
} // coend
&lt;/pre&gt;

これを (x, y)→(z, w) というプロファイルの射（並列計算の圏の射）だと思って、yとwを同一視してトレースを取るとループが再現する。

*1234514049*[モノイド圏][リンク]正規形がないときでもコヒーレンス

- Title: Coherence without unique normal forms (Submitted on 30 May 2007)
- Authors: Jonathan A. Cohen
- URL: http://arxiv.org/abs/0705.4334
- Pages: 23

Melliesの&quot;MacLane's coherence theorem expressed as a word problem&quot;（http://hal.archives-ouvertes.fr/docs/00/15/42/13/PDF/25_0310mn_Mellies.pdf）と一緒に読むといいかもしれない。

*1234514183*[メモ][圏一般論][高次圏論]オペラッド

以前にも書いたが：

- オペラッド = 対象が1つの複圏
- 色付きオペレッド（colored operad） = 複圏

（単色の）オペラッドは色付きオペレッドの特殊なケース。で、オペラッドの代数というものが定義できて、圏がオペラッド代数として定義できるそうだ。I. Moerdijkとかが言っている。

- http://golem.ph.utexas.edu/category/2009/02/dendroidal_sets.html
- http://golem.ph.utexas.edu/category/2009/02/moerdijk_on_infinityoperads.html

オペラッドについては：
- http://pantodon.shinshu-u.ac.jp/topology/literature/operad_basics.html

*1234514184*[メモ][圏一般論][indexed/fibred圏]豊饒圏の圏の積分（総和）表記

やはり、I. Moerdijkとかが言っている。集合Xに対して、Xを対象とする圏の全体をCat&lt;sub&gt;X&lt;/sub&gt;とする。Xを色々と動かせば、すべての圏が得られるので、Cat = Σ(X∈Set : Cat&lt;sub&gt;X&lt;/sub&gt;)のように書ける。Σは総和記号、積分記号をつかってもいい。

もう少し正確に書くと、X |→ Cat&lt;sub&gt;X&lt;/sub&gt; はindexed圏になっている。総和記号はindexed圏の平坦化（グロタンディーク構成）を意味する。つまり、CatはSetの上のファイバー圏。

Vが対称モノイド圏のとき、V-CatをCat[V]とも書くと、Cat[V] = Σ(X∈Set : Cat&lt;sub&gt;X&lt;/sub&gt;[V]) と書ける。が、Cat[V]もindexedのような気がする。

- ECat = Σ(V∈SMC: Σ(X∈Set : Cat&lt;sub&gt;X&lt;/sub&gt;[V]))

と書けそう。フビニの定理が成立しないか？

*1234515137*[セミナー]基本等式の応用として

+ エミュレータ -- 例えば6809を586でエミュレートする。世にVMはいろいろあるしな。
+ スタンドアロンな（あるいは抽象的）コンパイラ -- &lt;em&gt;人間&lt;/em&gt;の行為を機械（のようなモノ）で代行する。
+ クロスコンパイラ -- 開発マシン上でコンパイラ・&lt;em&gt;プログラム&lt;/em&gt;を動かす。
+ 普通のコンパイラ・プログラム -- クロスコンパイラの特殊例
+ 高級言語のネイティブコード化 -- LispソースをC言語を経由してネイティブコードにコンパイルする。

てな図を描く。

</body>
</day>
<day date="2009-02-14" title="">
<body>
*1234577925*[圏一般論][論理][からみ系]ドウセンの論文、これはサイコー：命題論理とタングル

コスタ・ドウセンとゾラン・ペトリック（Kosta Dos&lt;sup&gt;v&lt;/sup&gt;en and Zoran petric&lt;sup&gt;'&lt;/sup&gt;）の&quot;Coherence and Confluence&quot;（arXiv:math/0506310v3）を見つけた。僕の理解力とか好みにたまたまマッチしたということだろうが、これは面白い！ スゲー面白い。&lt;em&gt;11ページ&lt;/em&gt;しかないから読み切れる。僕にとっては示唆と刺激に富む。解説としてもポイントが押さえてあってとても分かりやすい。実に良い。

もういろいろ面白いんだが、とりあえずこのエントリーでは、例として出てくるコンパクト論理と、それが「からみ系（タングルなど）」とどう関係するかを述べる。

命題変数（命題letterとも言う）p, q, rなどから組み立てられた命題論理式を考える。使えるのは含意記号⊃と掛け算（multiplication）×。×は、∧と思ってよいが、論理結合子が1つしかないからコンパクト論理。推論は、常に&lt;em&gt;1入力-1出力&lt;/em&gt;で、次の推論を許す。以下では、p, q, rなどは、命題変数つうよりは論理式（項といってもいいが）を表すメタ変数。

&lt;pre&gt;
(1)
  p×q
 ------[k1]
    p

(2)
  p×q
 ------[k2]
    q

(3)
  p×(p⊃q)
 ----------[ε, モダスポネンス]
    q

(4)
    p
  ------[w, 増]
   p×p

(5)  
      q
  ----------[η]
  p⊃(p×q)

(6)
    p×q 
  -------[γ, 換]
    q×p
&lt;/pre&gt;

ドウセン／ペトリック論文では、⊃に矢印を使っている。γ（対称、またはブレイディング）は僕が付け足した。その他の記号はママ採用。少し注意：

+ 射影がπじゃなくてkなのは、Kコンビネータからだろう。
+ 対角がwなのはdoubleだからだろう。weakeningのwかもしれない。
+ ηとεは、単位／余単位の記号。余単位εがモダスポネンスなのは面白い。

以上の推論図から次のような、タングルもどきを作る。

&lt;pre&gt;
(1)
  p×q
  |  |
  | 
  p

(2)
  p×q
  |  |
     |
     q

(3)
  p×(p⊃q)
   ∪    |
         |
         q

(4)
    p
   ／＼
  p × p

(5)  
         q
         |
   ∩    |
  p⊃(p×q)

(6)
   p × q 
    ＼／
    ／＼
   q × p
&lt;/pre&gt;

命題変数のラベルを忘れてしまうと：

&lt;pre&gt;
(1) k1: 2→1
  *  *
  |  |
  | 
  *

(2) k2:2→1
  *  *
  |  |
     |
     *

(3) ε:3→1
  * * *
   ∪ |
      |
      *

(4) w:1→2
    *
   ／＼
  *    *

(5) η:1→3
      *
      |
   ∩ |
  * * *

(6) γ:2→2
   *    *
    ＼／
    ／＼
   *    *
&lt;/pre&gt;

となる。縦につないで結合、横に並べてモノイド積（テンソル）を入れると、&lt;b&gt;N&lt;/b&gt;を対象類とする対称モノイド圏（またはブレイド付きモノイド圏）となる。この圏は、対称の圏（またはブレイドの圏）を含むが、放電器や∪、∩を単独で取り出すことは出来ない（閉じ込められている）。対称性が不完全で双対もない。

以上で作られた圏では面白くなくて、縮約操作で得られる図形も全部入れた圏を考える（正確な定義はまだハッキリしない）。縮約してできる図形が証明ネットだろう。縮約は証明ネットの変形（書き換え）に対応する。基本的な書き換え規則から生成された書き換えを2-セルとして2圏を作る。この2圏（弱いかも知れない）が興味の対象だ。

ドウセンによると、問題の2圏内の2セルに3-セルを使って同値関係を入れて正規形を選び出すのが困難らしい。どうも焦点は3-構造のように思われる（僕の誤解がなければ）。

この例題は定義が簡単で、手でいくらでもいじれる。そのくせ難しい。テンパリー／リーブ圏とかカウフマン図式の圏とかと比べても面白い。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070418/1176881492&quot;&gt;トゥラエフのタングル圏&lt;/a&gt;（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070426/1177562726&quot;&gt;コッチも&lt;/a&gt;）とも似ているし。

適当なタングルを生成元とすると、面白い代数の例がいくらでも作れる気がする。q |- p⊃(p∧q) がモダスポネンスの“ある種の双対”となるのは&lt;em&gt;まったく知らなかった&lt;/em&gt;。絵図を使わないと気が付きにくいだろう。

*1234581251*[圏一般論][論理][用語法]ドウセンの論文：一貫性の理解

ドウセンの論文で、一貫性をどう理解すべきかがやっと（&lt;em&gt;少し&lt;/em&gt;）わかった気がする。

まず、素朴集合論に対する公理的集合論のように、公理的圏論（axiomatic category theory）あるいは形式的圏論（formal category theory）の文脈で考えないといけない。これは重要だ。

公理的圏論における公理系（その他諸々一式）で定義される概念を、圏のブランド（a brand of category）と呼ぼう（ドウセンの用語）。ブランドは正確に定義しにくいが、公理系のモデルである圏の圏（僕は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080228/1204158123&quot;&gt;レルムと呼んでいる&lt;/a&gt;）は、ウルトラ超越的な立場では外延として実在するから、ブランドの意味はレルムだと言ってもいい。ただし、レルムが純粋に外延なのに対して、ブランドはもっとイデアル（理念的）で、ブランドの実現として公理系がある、という雰囲気。

一貫性は、ブランドを実現する公理系に対する性質を述べている。論理との比較（比喩？）でまとめると次のようになる。

|*論理 |* 公理的圏論|
| 論理式 | 等式 |
| 健全性 | 健全性 |
| 充分性、(弱)完全性 | 完全性 |
| (強)完全性 | 一貫性 |

もともと用語法が混乱しているが、充分性はadequacyのつもり。十分条件（sufficient condition）の「十分」と区別して「充分」とした。ちなみに、充足はsatisfyの訳語。

では、一貫性（コヒーレンス）は（強い意味の）完全性の同義語かというとニュアンスが違うのだ。まず、一貫性が扱う論理式（論理文）は等式系である。等式系は可換図式の表現で、実質は可換図式とも言える。Dが図式で、対応する等式系をEとすると、|- E ⇔ Comm(D) という感じ。図式のクラス&lt;b&gt;D&lt;/b&gt;に対して、∀D∈&lt;b&gt;D&lt;/b&gt;.[|- E(D) ⇔ Comm(D)] のようなメタな言明を問題にする。Comm(D)はモデル論の主張で、実際の圏のなかでの成立することを意味している。

一貫性のもう一つの特徴は、レルムに属する任意の圏を相手にするのではなくて、通常は自由圏と典型モデルを扱うこと。自由圏をうまく構成し、「等式系が自由圏で成立するなら、証明可能である」という命題（完全性の一形態）を述べる。レルム内の任意の圏が、典型圏と圏同値になる、という定理も必要だ。

自由圏をリンデンバウム代数として構成すれば、上の意味の完全性は当たり前になる。結局問題は、リンデンバウム代数の実際の構成法。それと、リンデンバウム代数＝自由圏よりさらに扱いやすい特定のモデル（典型モデルと呼ぼう）を構成して、充満関手G:F→M を構成すること。

Fがあるブランド（公理系、形式理論）のリンデンバウム代数＝自由圏なら、f = g in F ⇔ |- 'f = g' はFの作り方から当たり前。f = g in F ⇒ G(f) = G(g) in M も当然だが、これが典型モデルMに対する“あるブランドのセオリー”の健全性となる。通常、G(f)は、自由圏の射fの絵図表現となる。完全性が成り立つには、Mの射が必ずGの像となることが必要で、これはGの充満性の主張となっている。

Gが自由圏（特定の形式圏論＝ブランドのリンデンバウム代数）から典型モデルへの充満関手であることを示せば一貫性が従うが、より強く、典型モデルMが自由圏Fと圏同値（あるいは圏同型）であることまで示せることもある。シャムの定理はそのような例となっている。

*1234591412*[圏一般論][モノイド圏][課題]ドウセンの論文：スタシェフ多面体

たった11ページだが、面白い例が色々出てくる。

表題のスタシェフ多面体（Stasheff polytope）、別名アソシアヘドロン（associahedron）、5-letter結合律の図形的な表現。4letters a, b, c, dの2項演算結合を全部書くと五角形だが、5letters a, b, c, d, eだとスタシェフ多面体になる。

絵は自分で描いてみるのがいいと思う。9面体。そのデータは：

+ 五角形面が6
+ 四角形面が3
+ 21辺
+ 14頂点

すべての頂点に3辺が集まるので見取り図は3-正則グラフになる。

5-letterの二分木の全体が14頂点、1回の結合律適用が21の辺、9つの面が四角または五画の可換図式になる。

n-letterのスタシェフ多面体を記述するのは面白い問題だ。

*1234591828*[雑感]ドウセンの論文：ひと休み

ドウセン／ペトリック論文は11ページだが、まだ2,3ページしか読んでない気分だ。中身が濃いし面白い。これを真面目に読んでるといくらでも時間がかかるので一休みにする。

*1234596167*[モノイド圏]二分木と書き換えの圏

Melliesの&quot;MacLane's coherence theorem expressed as a word problem&quot;も、今読んでみると面白い。このなかで&lt;b&gt;&lt;i&gt;A&lt;/i&gt;&lt;/b&gt;という固有名詞で表記される圏が出てくる。&lt;b&gt;&lt;i&gt;A&lt;/i&gt;&lt;/b&gt;を僕なりに再定義してみる。&lt;b&gt;&lt;i&gt;A&lt;/i&gt;&lt;/b&gt;より弱い（構造が少ない）&lt;b&gt;A&lt;/b&gt;（イタリックじゃない）を定義する。

リーフノードが0, 1である二分木の全体をTとする。文字LとRの並び（空列も認める）をパスと呼ぶ。パスpはノードを指す。空列はルートを指す。pが指すノードが二分木a内に存在するときは p↓a  と書く。p↓aのとき、a[p]はpが指すノードそのもの。

+ pL↓a で、a[pL]がリーフでないとき、α[p](a)が定義できる。
+ p↓a で、a[p]がリーフでなく、a[pL]が0のとき、λ[p](a)が定義できる。
+ p↓a で、a[p]がリーフでなく、a[pR]が0のとき、ρ[p](a)が定義できる。

+ α[p](a)は、ツリーaのノードa[p]に関して結合律書き換えを適用した結果。
+ λ[p](a)は、ツリーaのノードa[p]に関して左単位律書き換えを適用した結果。
+ ρ[p](a)は、ツリーaのノードa[p]に関して右単位律書き換えを適用した結果。

α&lt;sup&gt;-1&lt;/sup&gt;, λ&lt;sup&gt;-1&lt;/sup&gt;, ρ&lt;sup&gt;-1&lt;/sup&gt; も同様に定義する。

ξを、α, λ, ρ, α&lt;sup&gt;-1&lt;/sup&gt;, λ&lt;sup&gt;-1&lt;/sup&gt;, ρ&lt;sup&gt;-1&lt;/sup&gt; のどれかだとして、(a, ξ[p], ξ[p](a)) の3つ組をすべて考える。Tを頂点、この(a, ξ[p], ξ[p](a))を辺とする有向グラフが出来る。このグラフから自由生成された圏を&lt;b&gt;T&lt;/b&gt;とする。

Tに、五角形／三角形条件で規定される射の同値関係を入れる。すると、TをE圏（各ホムセットに同値関係を持つ圏）とできる。Tを同値関係（合同）で割ると再び圏となる。対象は変わらない。T/≡ を&lt;b&gt;A&lt;/b&gt;とする。

圏&lt;b&gt;A&lt;/b&gt;は、単一の生成元から生成された自由モノイド圏となる。このモノイド圏は厳密ではない。厳密にするには、対象類に同値関係を入れて割り算する必要がある。


</body>
</day>
<day date="2009-02-17" title="">
<body>
*1234826303*[圏一般論]圏の割り算問題

メリーズ（Mellies）は、Cの部分圏Dで次のようなものを導入している。

+ 広大部分圏（同じ対象を持つ, full on objects）
+ 亜群
+ 痩せている（細い、プレ順序）

そのとき、C/Dは定義できて、CとC/Dは圏同値になる。

さらに、圏の分数計算なども出している。

圏には、環のイデアルのような概念はないから、圏の割り算（商）を作るのは難しい。色々な特殊ケースがあるが、一般論は困難だろうな。


*1234826304*[復習]解離法則＝線形分配法則

- [http://d.hatena.ne.jp/m-hiyama-memo/20061107/1162864073:title]

ヘーッ。

と、自分で感心してみる。そういや、テンソルとパーはdissociative（解離的）だったか。

*1234829626*[気付いた][トレース／コンパクト閉圏][プログラム意味論][DFD]有限エルゴットオートマトン

有限決定性エルゴットオートマトンが実は面白いことに気が付いた。有限の場合は、グラフ理論と行列計算で完全に把握できる（無限だとよくわからない）。テンパリー／リーブ圏やタングルとの類似もけっこうあるようだ。グラフのサイクルが生じるところが、結び目の話と似ている。

もっと面白いのは、証明ネットを使った証明論との関係。シーケント計算が右片側シーケントに還元できるとき、カットは、Aと￢Aのペアにより表現される。片側シーケント証明図から証明ネットを構成できて、証明ネット上でのカット消去（正規化）が有限エルゴットオートマトンの実行になるようだ。

*1234839660*[説明][気付いた][DFD][その他代数]二次元パクナー（Pachner）移動

以下、カーター／カウフマン／サイトウ（J. Scott Carter, Louis H. Kauffman, Masahico Saito）の&quot;Structures and Diagrammatics of Four Dimensional Topological Lattice Field Theories&quot;（http://www.math.uic.edu/~kauffman/SD4D.pdf）を少し眺めて思ったこと。Pachnerはパクナーとカタカナ書きしてみる。

二次元（平面や曲面）だけを考えることにして、(2⇔2)パクナー移動とは四角形の対角線を交換することで、結合律または余結合律に相当する。一般にn角形の三角形分割は、(n-1)-lettersのアソシアへドロンの頂点集合(複体の0-骨格)を与える。一方、(1⇔3)パクナー移動は、三角形の三分割（細分）を与える。(2⇔2)パクナー移動と、別な代数的条件があると、(1⇔3)パクナー移動が出てくる、という結果がある。これが面白い。

別な代数的条件だが、これは半単純性（semisimplicity）と呼ばれているが、積∇と余積Δに関する Δ;∇ = 1 というヤツ。これは、対角／余対角（余和／和）なら 1+1=1 という条件。no-hole conditionとも呼ばれているし、幾何学的には、線の途中に出現する輪や菱形をつぶしてもいいよ、ってハナシだ。僕は、なんで半単純と呼ぶかわかんない。no-hole条件のほうを使うことにする。

no-hole条件をポアンカレ双対として描くとナールホドなのだ。スキャナが使えないから絵は載せないが、以下の説明で簡単に描けると思う。三角形ABCのまん中にOを取って、AOB, BOC, COAと三つに分割する。これが(1⇔3)パクナー移動になる。AOの中点をMとする。四角形ABOCAを考えると、これは平面内で凸にはならないが、位相的には四角形ABOCだ。AMOが対角線を与える。折れ線BMCがもう一本の対角線なので、AMO→BMCが(2⇔2)パクナー移動となる。

出来た図形のなかで、BMC, BOC, BC に注目。もともとMはなかった点だから、折れ線つうよりはなめらかな線BCを考えて、BC, BOC, BC を眺める。これはBOCで決まる二つの三角形が二辺を共有している図とみなせる。底面を二辺形（二点を持つ円）とする円錐を考えればよい。この退化した三角形分割を線にしてしまってもいいよ、がno-hole条件。ポアンカレ双対で描くと円板（二辺形）が潰れる絵となる。

ともかく、分割された三角形の凹四角形部分に(2⇔2)パクナー移動を適用し、その後no-hole条件で退化した図形をつぶす（取り除く）と、(1⇔3)パクナー移動が出来る。代数的には、結合的／余結合的な代数／余代数構造に半単純性があれば、二次元図形の不変量が構成できることになる。

&lt;b&gt;[追記]&lt;/b&gt;&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070501/1177989443&quot;&gt;「三角形を細分しても計算結果は同じにできる」&lt;/a&gt;に絵があるが、フロベニウス法則を使わなくても、結合律だけでもOKだったな。結合律でも輪が作れる。&lt;b&gt;[/追記]&lt;/b&gt;

*1234854780*[セミナー]あれれ、関数の等しさ

関数の（超越的な）等しさが計算的に判断できたらオカシイはずだが、、、、

嘘つきパラドックス＋対角線論法 のようなもんで、簡単だと思っていたが、アレレレ、出てこない。単に僕が頭悪いだけのようだ。

&lt;b&gt;[追記]&lt;/b&gt;

全域性を判断できないことを経由すれば、関数の等しさ判断も無理なことがわかる。等しさが判断できるなら、(fx)+1)/(f(x)+1) と定数1（定数関数は全域）を比較して全域性を判断できる。よって矛盾、となる。

関数の等しさの判断が、（有効な）定義域の等しさの判断につながる。別な言い方をすると、帰納的列挙可能集合の等しさの判断。帰納的列挙可能集合は具体的な集合と言えるから、具体的な集合の比較もアルゴリズム的には行えない。

- 関数の等しさが判断できる⇒具体的な集合の等しさが判断できる⇒全域性を判断できる

全域性の判断の不可能性には対角線論法を使うが、「持って回った」感はあるな。まーいいか。

&lt;b&gt;[/追記]&lt;/b&gt;

*1234855165*[紛失物]信じられなーい！

&lt;em&gt;ベリー・オモローッ&lt;/em&gt;と言っていた&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090214/1234577925&quot;&gt;ドウセン／ペトリック論文&lt;/a&gt;、ない。なくした。まー、これはプリンタで印刷し直せばいいのだが、我ながら驚くよ、あきれるよ。なんでなくすんだ。

11ページのPDFならまだしも、書籍や書類でも同じようになくすからな。バカか!? ＞自分

*1234855166*[紛失物]ICレコーダーのマニュアル

オリンパスのICレコーダー、まだ使い方憶えてないし、、、バカか!? ＞自分

&lt;b&gt;[追記]&lt;/b&gt;あった。いったいどこに置いたら紛失しないのか？&lt;b&gt;[/追記]&lt;/b&gt;


</body>
</day>
<day date="2009-02-18" title="">
<body>
*1234918647*[メモ][人物][多圏]polycategoryの創始者はザボ 

&gt;&gt;
Multicategory の拡張として polycategory というものもある。 M. Szabo が [Sza75] で導入した。 
&lt;&lt;

*1234919614*[セミナー]ランダムなメモ 作業用！

- グラフとしての関数（外延）、計算ルールとしての関数（内包）
- 計算ルール＝式やプログラム、ifやcase分岐があってもよい
- ε記号や s.t. such that があってもいい、例：平方根
- 関数の等しさは超越的
- 現実的、実効的な等しさは何か？
- f(x) = x(x+1), x^2 + x, x, 1 等しいのはどれか？ 可逆なのはどれか？

- コンピュータの計算は関数だと思ってよい
- 手続きや副作用も関数として表現可能
- サブルーチンが関数なのではない！
- ブートストラップも関数
- プログラム断片も関数
- {0, 1, ..., N}→{0, 1, ..., N} で充分

- 自然も生物も人間も機械も社会も計算している
- 機械の計算、力学（機械学）的、電気的（回路）、電子的
- 化学反応やDNAやらでも計算できる
- データ領域と計算（計算可能関数）が構成する世界が計算の世界
- 計算の世界を包括的に眺める、そこで起きている計算現象がある
- データ領域 -- 数値や記号的表現（文字、文字列、ツリーなど）、紙に書いたナニカ、音声、模様や絵なども
- 人間可読な表現もデータ領域に入る
- 人間可読な表現を人間が解釈計算することも「基本等式」
- 自然界の関数fを、人間可読表現f^H として記述することもイデアルコンパイル
- 解釈計算する人間をHとすると、HをエンジンMによってコード化すると H^M
- H^M は人間可読な表現（H-関数コード）を、機械語コードH^M(s)に直す。
- y = vt - 1/2gt^2 は、f = &amp;lt;t|vt - 1/2gt^2&gt;, f(3) を計算するのは人間

- 1 + 2 = 3 は等式かのか？
- 項書き換え系と計算
- 書き換えと等しさ
- 式の変形 還元、縮約、変換
- 1 + 2 + 3 → 1 + (2 + 3) → 1 + 5 → 6
- (1 + 2) + 3 = 5 + 1 のイコールは何？

- データと働きを徹底的に区別することにより、データと働きを同一視できるメカニズムを解明する
- (N←N)へのキャストはゲーデル符号化になるとみなす
- 方の記法には、Y&lt;sup&gt;X&lt;/sup&gt;または (Y←X) を使う。プロファイルの表現とは区別する。
- 関数のプロファイルはデータの型ではない！
- 型は運用上の約束事であり、「みなし方」のヒントまたは強制である。圏論では常に強制と考える。
- X&lt;sup&gt;X&lt;/sup&gt;＜X とか X×X＜X とか

*1234944817*[メモ][圏一般論]随伴対と自明なモノイド

随伴と双対を区別せずに、F -| G とか A -| B と書くことにする（ストリート流）。F -| G のとき、

+ G = F&lt;sup&gt;*&lt;/sup&gt;
+ F = &lt;sup&gt;*&lt;/sup&gt;G

と書いて、

+ G = F&lt;sup&gt;*&lt;/sup&gt; はFの右随伴
+ F = &lt;sup&gt;*&lt;/sup&gt;G はGの左随伴

と呼ぶ。左右が逆になる用語法もあるが、四の五の言ってもラチがあかないので、&lt;em&gt;とにかくこう決める&lt;/em&gt;（セリンガーの定義）。

F -| F&lt;sup&gt;*&lt;/sup&gt; のとき、単位η:I→F&lt;sup&gt;*&lt;/sup&gt;・F と 余単位ε:F・F&lt;sup&gt;*&lt;/sup&gt;→I が決まる。正確には、(F, F&lt;sup&gt;*&lt;/sup&gt;, η, ε)が随伴対。ここで「・」は当該の圏のモノイド積だとする。圏がEnd(C)のとき、・は関手の&lt;em&gt;反図式順&lt;/em&gt;結合。

M = F&lt;sup&gt;*&lt;/sup&gt;・F とおく。随伴対の単位は η:I→M となる。μ:M・M→M を、

- M・M = (F&lt;sup&gt;*&lt;/sup&gt;・F)・(F&lt;sup&gt;*&lt;/sup&gt;・F) = F&lt;sup&gt;*&lt;/sup&gt;・(F・F&lt;sup&gt;*&lt;/sup&gt;)・F

を使って、μ := F&lt;sup&gt;*&lt;/sup&gt;・ε・F として定義する。これは、随伴対から決まる標準的なモノイドで、モノイド法則は単位／余単位に関するジグザグ法則から自動的に出る。

関手の随伴対からモナド＝関手圏のモノイドが出現するメカニズムはこれだけだ。逆方向に、モナドから随伴対を構成するのは難しいが。

</body>
</day>
<day date="2009-02-20" title="">
<body>
*1235091830*[用語法]絵言語 VS 文言語

セリンガーはgraphical languageって言葉を使っている。僕は pictorial languageのほうが好きだな。いずれにしても訳語は絵言語でいいだろう。

絵言語の対語は何だろう？ symbolic languageか、textual languageか。語感がサッパリわからん。「絵と文」とかいうから、文言語かな。

それはそうとして、絵言語のほうが一瞬でわかるとか計算が楽って実利的なメリットもあるが、そもそも通常の式表現だと計算過程が表現できないんだよな。式が結果の表現に最適化されているから、過程を表すには面倒な記法を導入することになる。

例えば：

- (f×g);(Δ&lt;sub&gt;X&lt;/sub&gt;×Δ&lt;sub&gt;Y&lt;/sub&gt;);(id&lt;sub&gt;X&lt;/sub&gt;×σ&lt;sub&gt;X,Y&lt;/sub&gt;×id&lt;sub&gt;Y&lt;/sub&gt;) = Δ&lt;sub&gt;X×Y&lt;/sub&gt;;[(f×g)×(f×g)]

これどうよ？ 絵ならモロ・イッパツだぜ。

*1235091831*[用語法][論理]レイフィケーションとゲーデル符号化

[http://d.hatena.ne.jp/m-hiyama-memo/20090205/1233792555:title] ：
&gt;&gt;
本来、ゲーデル符号＝ゲーデル数は論理式とか証明とかに対して付けられている。構文領域から数領域への関数。だけど、構文領域に意味論があるなら（たいていはある）、意味領域から数領域への関数だと思ってもよいだろう。
&lt;&lt;

いや、意味領域内の符号化（符号空間への単射）までゲーデル符号化と呼ぶのはやっぱりマジイ気もしてきた。混乱を招きそうだ。

なんらかの項（構文的なモノ）の全体をTermとして、符号の空間をKとする。G:Term→Kはゲーデル符号化と呼んでいいだろう。ここで、像集合 G(Term)⊆K への所属は実効的に判定できて、部分的逆写像 G&lt;sup&gt;~&lt;/sup&gt;: K⊃G(Term)→ Term が定義できる、という条件がある。要するに、「nはゲーデル数である」とか「nは項tのゲーデル数である」とかが計算でちゃんと決着が付く。

Termに意味関数【-】:Term→Denoがあるとして、g(【t】) = G(t) となる g:Deno→K があればいいが、たいていそんなものはない。そうじゃなくて、c:Deno→Termを使って、【c(a)】= g(a) とする。cは意味に対して構文を一意に割り当てることだから、正規形だと思ってよい。

特に、適当な領域Dがあって、D⊆Term（定数として）、Deno = D&lt;sup&gt;D&lt;/sup&gt; のときが問題になる。g:D&lt;sup&gt;D&lt;/sup&gt;→D をゲーデル符号化と呼ぶのが適切か？ Term上のゲーデル符号化と正規化のアルゴリズムがあれば、gを定義できるが、、、これはやっぱりゲーデル符号化と呼ばない方が無難だよな。

このケースではレイフィケーションがいいんじゃないのかな。それと、反射的（reflexive）とかEPペアとかレトラクトとかも、用語と定義を整理したほうがいいな。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090116/1232083409&quot;&gt;「λ代数、万能対象」&lt;/a&gt;も参照。

*1235113536*[リンク][人物][論理]ヒューズ、証明ネットとか

ドミニク・ヒューズ（Hughes）

- Dominic Hughes - Selected Papers -- http://boole.stanford.edu/~dominic/papers/

*1235117103*[モノイド圏][説明][小咄][具体例]モノイド閉圏としての&lt;b&gt;Z&lt;/b&gt;

- 対象類：整数の全体
- 射：a≦b である [a, b]:a→b
- 対象のモノイド積：足し算、単位は0
- 射のモノイド積：[a, b]:a→b, [c, d]:c→d, [a+c, b+d]:a+c→b+d
- ベキ：(b←a) = b - a
- ラムダ抽象：f = [a+b, c]:a+b→c, f^ = [a, c - b]
- ev： ev&lt;sub&gt;a,b&lt;/sub&gt;:(b←a), a → b は id&lt;sub&gt;b&lt;/sub&gt;:(b - a)+a→b。

a&lt;sup&gt;*&lt;/sup&gt; = -a とすると、a+(-a)→0, 0→(-a)+a によりコンパクト閉圏にもなる。ふーん。

こういう例をもっともっと集めたいのだよな。

</body>
</day>
<day date="2009-02-21" title="">
<body>
*1235195227*[セミナー]時間が余ったら、って、甘い！

- [http://d.hatena.ne.jp/m-hiyama-memo/20090122/1232596318:title]

時間が余ったらイータ変換とか、それは無理だ。やってみて分かったな。

イータ変換ってば、関数の外延性（つうか、形式理論のなかの等号を外延的に解釈できるってこと）とか、圏論的ラムダオペレータの可逆性を保証するとか、いくつかの側面があるし。外延性が成立しない例を出すとか、項書き換えによる同値性とか、、、

冷静にちゃんと考えてみると、これだけでも90分だろうな。

*1235209545*[セミナー][プログラム意味論]計算の圏は集合圏とは全然(！)違う

http://d.hatena.ne.jp/m-hiyama/20090221/1235192629 ：
&gt;&gt;
バイナリ関数コードφ∈N&lt;sup&gt;N&lt;/sup&gt;が与えられると、f(x) = E(φ, x) としてfを再現できます。このことは、N→N という関数とN&lt;sup&gt;N&lt;/sup&gt;のデータの間に1：1の対応があることを意味します。ただし、この1：1対応に関しては、かなり精密な議論をしないと&lt;em&gt;誤解や混乱&lt;/em&gt;が生じます&lt;b&gt;[脚注：&lt;/b&gt;例えば、関数と関数コードが1:1に対応するなら、2つの関数の外延的同値性が実効的に判定可能なように思えます。が、それは誤解です。&lt;b&gt;]&lt;/b&gt;。できればこの点を別に説明したいのですが、今日はしません。
&lt;&lt;

これを精密に議論すると、、、、2時間、いや3時間くらいかかるのかなー？

集合圏では、N&lt;sup&gt;N&lt;/sup&gt;は、ある意味「簡単だ」ともいえる。しかし、計算可能関数の圏を極めて具体的に、デカルト閉圏として構成すると、N&lt;sup&gt;N&lt;/sup&gt;の意味は集合圏とは&lt;em&gt;ドエラク違う&lt;/em&gt;ことが分かる。

計算可能関数の圏にもいろいろなバリエーションがあるが、意味論だけではなくて、最小限の構文論（多ソート代数風）も入れた方がいい。そのほうが事情がハッキリするだろう。

こういうことは、具体的かつ徹底的にやらないとわかんないのだよね。


</body>
</day>
<day date="2009-02-23" title="">
<body>
*1235346434*[プログラム意味論]帰納的に自由な集合

集合X上に次のような構造を考える。

+ Xの部分集合I
+ X→Xである写像s1, s2, ..., sN （N≧1）

s1, ..., SN を任意に結合した写像を移動（move）と呼ぶことにし、その全体をMove(X)とする。一方、Σ = {s1, ..., SN}として、クリーネ・スターΣ&lt;sup&gt;*&lt;/sup&gt;を作る。すると、Σ&lt;sup&gt;*&lt;/sup&gt;→Move(X)という写像が定義できる。これは、構文的な項の意味写像と考えてよい。

次の条件を考える。

+ Iは有限集合である。
+ すべての移動m:X→Xは単射である。
+ Σ&lt;sup&gt;*&lt;/sup&gt;→Move(X) は単射である。
+ eval:Move(X)×X→X は全車である。

Σ&lt;sup&gt;*&lt;/sup&gt;I = I + ΣI + ΣΣI + ... とすると、上の条件は、XがΣ&lt;sup&gt;*&lt;/sup&gt;Iと同型なことを示す。別な言い方をすると、Xは次の再帰的定義で定義される。

+ IはXの元である。
+ xがXの元なら、s1(x), s2(x), ..., sN(x) はXの元である。
+ 以上で出来た元だけがXの元である。

XはIとΣ決まるから(I, Σ) と書いてもよい。仮にこのような集合を帰納的に自由な集合と呼んでおこう、なぜなら(I, Σ)で自由生成されているから。Σが空のときも許すと、すべての有限集合は帰納的に自由である。有限ではなく、もっとも簡単な帰納的自由集合は&lt;b&gt;N&lt;/b&gt; = ({0}, {suc})となる。

帰納的自由集合に実効的な同値関係を入れて割った集合や、実効的な述語で定義される部分集合は帰納的と言っていいと思うが、「実効的」の定義をしなくてはならない。もう少し考えねば。

*1235346831*[紛失物]線形論理、領域理論、半関手

あんれー？ 

- [http://d.hatena.ne.jp/m-hiyama-memo/20090106/1231234044:title]

で触れた&quot;Liniear logic, domain theory and semi-functors&quot;が見あたらないなー。カロウビ展開圏（Karoubi envelope）が知りたいのだけど、、、、

*1235349303*[連絡的]今日の説教と予定

+ 座学、畳水練は止めよう
+ わかんなかったら実験、探索
+ 少ない知識でも、組み合わせて推論すれば、たいていのことは分かる。
+ 組み合わせ方や推論の能力が真の問題かもしれないが、、、
+ 考えない習慣／やってみない習慣を直す（矯正する／強制する）ようにしよう

- 予定は、リンクリストと文字コードの話
- リンクリストへの挿入ソート
- リンクリストを逆順にたどる


</body>
</day>
<day date="2009-02-24" title="">
<body>
*1235436028*[プログラム意味論][形式言語理論][インスティチューション]再帰理論のインスティチューション

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090223/1235346434&quot;&gt;帰納的に自由な集合&lt;/a&gt;の件だが、有限な代数指標Σを決めて、Σの自由代数＝始対象のことだわな。Σを決めるごとに再帰関数（帰納関数）論ができるから、全体としてはインスティチューション。


*1235436029*[プログラム意味論][量子計算]量子エルゴットオートマトン

本編の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20080701/1214876519&quot;&gt;「可逆計算が面白いから、JavaScriptで書いてみた」&lt;/a&gt;に出てくるグリーン／アルテンキルヒ論文に、ヒープとガーベッジの概念が書かれている。エルゴットオートマトンと似ている。ヒープ＝ガーベッジとすれば、エルゴットオートマトンだと思ってよいだろう。

有限個の点＝ドットごとにヒルベルト空間を対応させると、量子エルゴットオートマトンになりそうだな。

*1235436162*[セミナー][論理]演繹系の素材

中学校(?)の連立一次方程式。

- 定数、演算、文字（変数）で項、等号、等式として論理式を定義できる。
- 連立とは、∧で結ぶこと。
- 等式的理論（等式理論）の公理系と推論規則

例えば推移律は、
&lt;pre&gt;
   A = B    B = C
  ----------------
     A = C
&lt;/pre&gt;
と推論規則なのか、それとも推移性の公理
&lt;pre&gt;
   ---------------------------
   (x = y)∧(y = z) ⊃ (x = z)
&lt;/pre&gt;
なのか？

論点はその他いろいろあるな。

*1235442306*[セミナー]練習問題

- 絵を上下反転（鏡映）、左右反転させて描く
- 算術式のパースツリーをいろいろな方式で描いてみる
- 中間ノードに演算を描く方式と、末端ノードに演算を描く方式とか

*1235442307*[セミナー]言い忘れ、反省

「言い忘れ」つうか、時間内に言い切ることに無理があった項目：

- 機械語と高級言語の境界線はない
- コンパイラとインタプリタの境界線はない
- テキストとバイナリの境界線はない
- 式と値の境界線はない（値としての式、値も一種の式）
- 世界は相対的、連続的
- 境界を引いて分断するのは人為的な操作、ソレ・イクナイ！

- 気持ちと心の問題は、「みなし方」「態度」「立ち位置（視点、視座）」とか
- 役割に対するラベルが型
- 扱い方のヒントや制約が型
- 型は、データに向かったときの解釈、意図、待遇のルール
- データの本性／素性＜ほんせい／すじょう＞と型は直接的な結びつきはない
- 「…とみなすことが可能か？」「…とみなすことにしよう」が型の本質

- コンビネータの2つの意味（プロパーなコンビネータ計算、ラムダ計算の一部）
- コンビネータの書き換え規則
- コンビネータをアトムとすること、アトムをコンビネータで表現すること

計算の世界＝構成可能な領域と計算可能関数の圏 を早期に導入してもよかったか？

- 自然数対象がある
- 有限対象がある
- ベキ（指数）がある
- 万能対象＝万能計算機＋その領域 がある

計算の世界の部分圏として算術の圏を位置付ける、とか。

*1235445816*[セミナー]言い忘れ、反省の続き

- 物理現象 f = &amp;lt;t|ut - (1/2)gt^2&gt; とかの例を出してもよかったかな
- プロファイルの説明がゴッソリ抜けてた

僕は最近、X, Y→Z のような書き方をする（カンマを使う）、その理由も説明するといいかもな。

+ ×（かける）はX（エックス）と紛らわしい。
+ テンソル積は難しげな印象を与える。
+ + も混乱のもとだし。
+ 一般のモノイド積で通用する話だから、特定の積を連想させる記号は好ましくない。だったら書くのヤメチャエ。
+ シーケントとの類似性
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090128&quot;&gt;ハロ多圏&lt;/a&gt;による意味論

※ 「意味論」と書こうとして、打ち間違えて「イモリン」とキー入力してしまった。「芋林」と変換された。

*1235446253*[紛失物]信じられなーい！ again

もらった書類やプリンタで印刷した紙束の紛失が尋常じゃない。

おかしい!? うちにはシュレッダーもブラックホールもないはずだが。

*1235451650*[後で消す]2月と3月

日付と曜日の関係が同じ。

*1235451651*[教訓]電話

- 強い興味を持ったにしても、いずれは忘れてしまう。
- メールじゃなくて電話で確認。

</body>
</day>
<day date="2009-02-25" title="">
<body>
*1235518617*[メモ][雑記]当座の座右の書

+ バカ、キリ
+ ランベック、スコット
+ カウフマン
+ コック（Kock）

*1235518618*[メモ][論理][その他プログラミング]計算理論と論理プログラミング

『計算理論と論理プログラミング』という、どこで手に入れたか分かんない本が出てきた。スマリアンのEFSがべースという変わった内容。

*1235518619*[メモ]人名の読み：Berger, Hughes

- Berger は ベルジュ
- Hughes は ヒューズ

*1235547575*[リンク][論理]証明ネット関係、のプレゼンテーションスライド

- Title: Jump from parallel to sequential proofs
- Author: Paolo Di Giamberardino
- URL: http://www.cirm.univ-mrs.fr/videos/2008/exposes/323/Giambera.pdf
- Pages: 42 オーバーレイあり

*1235549533*[リンク][モナド][お絵描き]ホップモナド、左右の随伴

- Title: A diagrammatic approach to Hopf monads (Submitted on 3 Jul 2008)
- Authors: Simon Willerton
- URL: http://arxiv.org/abs/0807.0658
- Pages: 26

最近の絵算もの、面白そうなので印刷した。

- Title: Isomorphisms between left and right adjoints (Submitted on 8 Jun 2002)
- Authors: H. Fausk, P. Hu, J.P. May
- URL: http://arxiv.org/abs/math/0206079
- Pages: 18

著者にJ.P. Mayが入っている。


</body>
</day>
<day date="2009-02-26" title="">
<body>
*1235627800*[リンク]絵算と一貫性、アソシアへドロン

- Title: COHERENCE OF PROOF-NET CATEGORIES
- Authors: Kosta Dosen and Zoran Petric
- URL: http://www.emis.de/journals/PIMB/092/n092p001.pdf
- Pages: 33

- Title: LogicWithout Syntax
- Author: DOMINIC HUGHES
- URL: http://boole.stanford.edu/~dominic/papers/lws/lws.pdf

- Title: Associahedron
- Author: Jean-Louis Loday
- URL: http://www.claymath.org/programs/outreach/academy/LectureNotes05/Loday.pdf

- Title: THE MULTIPLE FACETS OF THE ASSOCIAHEDRON
- Author: JEAN-LOUIS LODAY
- URL: http://www.claymath.org/programs/outreach/academy/LectureNotes05/Lodaypaper.pdf

- Title: Relating the associahedron and the permutohedron, Operads (1995)
- Author: Andy Tonks 
- URL: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4553

- Title: Realizations of the associahedron and cyclohedron
- Authors: Christophe Hohlweg, Carsten Lange
- URL: http://arxiv.org/abs/math.CO/0510614

*1235628920*[圏一般論]ピノキオを人間にする

Xが集合でVが対称モノイド圏、[-, -]:X×X→V がV-圏の構造を与えているV値ホムだとする。モノイド単位を I∈V として、C(A, B) = V(I, [A, B]) とすると、X×X上の集合値ホムC(-, -)が通常の圏を定義するはず。これがピノキオから人間を作る標準的な方法。

Cが閉圏のとき、ベキにより自分自身で豊饒化すると、内部ホム[-, -]ができる。/C/(A, B) = C(I, [A, B]) で定義される外部ホム/C/（と、それから作られる圏）はもとの圏Cとどう関係しているんだろう？ /C/がCを再現する条件は何だろう？

そういや、豊饒圏の短いテキストを途中までやって、まとめてないなー。いかん。

&lt;b&gt;[追記]&lt;/b&gt;

/C/(A, B) = C(I, [A, B]) = C(A, B) は、Cが閉圏なら自明に成立する。f::T :⇔ f∈C(I, T) と定義する。Tが[A, B]の形をしているときは、

- f::[A, B] ⇔ f∈C(I, [A, B]) ⇔ Γ(f)∈C(I×A, B)

となる。ΓはΛの逆。

&lt;b&gt;[/追記]&lt;/b&gt;

*1235628921*[セミナー]アデンダム or アネックス

- あー
- 心残り
- もったいない
- せっかくだから
- もう少し

あこもせも。

*1235630129*[紛失物]ありうる場所、事例の記録

[紛失物]に書いてなかったヤツだが、なくした書類が出てきた。紙はステープラで閉じて、その紙束をクリップで閉じる。で、紛失物は他のクリップ閉じのなかに紛れ込んでいた。

と、そうこうこともある。オリンパスのマニュアルもバラバラの紙束のなかにはさまっていた。

と、記録していくと、紛失物の「傾向と対策」ができるだろうか？ 

&quot;Liniear logic, domain theory and semi-functors&quot;や黒いコンパイラ本はいったいどこから出てくるのだろうか？ 出てくればいいんだけど、、、

*1235636822*[XML][形式言語理論][トレース／コンパクト閉圏]LSLとLTL

「XMLを圏論的に」というスローガンがあったわけだ。

関係の圏Relが集合の直和を直積としてデカルト圏になるとか、エルゴットオートマトンの圏とかを横目で睨むと、XMLの圏の様相も見えてくる。

とりあえず、LSL = Linear String Languageの圏を定義しよう。Σをアルファベットして固定する。LSLの対象は任意の集合（有限に限ることもある）、X→Yの射は、BNFによる文法定義。BNFにおいて、Yの元が左辺、Xも文字が右辺に出現する。

この圏に直和でモノイド積を入れる。A+T→B+Tの形の射を新たに射としてトレースを入れる。それでトレース付きデカルト圏（双デカルト？）を作る。

同様なことを線形ツリー言語LTLに関してもやれそうだ。

*1235636823*[説明][JavaScript]JavaScriptの導入

- 「なんでもプロパティ」のようなことを最初から出すのは得策ではない。
- 「変数がない」、「変数が未定義」は箱で説明できる。
- undefined値とかtypeof演算子、in演算子とかは最初から出してもいいようだ。
- ifの例題に時刻により文言を変える挨拶。
- 絶対値とか順序によらない差とかでもifが使える。
- whileの説明にカウントダウンとか、1からnまでの総和とかはいいようだ。
- 円、三角、台形の面積の計算を関数の例とした、これもまー分かりやすい。
- 配列からの検索もいい例題。いろいろなやり方、結果の返し方がある。
- 例：マイナスだったら末尾から勘定するインデックスアクセス関数
- returnは難しい、結果をprintするほうが受け入れやすい。
- returnはストップとして導入してはどうか、whileループ内から脱出とかで使える。
- 引数より戻り値概念が難しいようだ。

</body>
</day>
<day date="2009-02-27" title="">
<body>
*1235706615*[圏一般論][リンク]閉圏の定義

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090226/1235628920&quot;&gt;ピノキオを人間にする&lt;/a&gt; ：
&gt;&gt;
/C/(A, B) = C(I, [A, B]) = C(A, B) は、Cが閉圏なら自明に成立する。
&lt;&lt;

まー、自明なんだけど、それは閉圏の定義が自明になるように作られているからだよね。

- http://golem.ph.utexas.edu/category/2009/02/monoidal_closed_categories_and.html

にて、モノイド圏がclosedって何だろう？ って議論がされている。これは、ピノキオを人間にすることがそんなに簡単なの？ って話に通じると思う。

*1235706616*[小咄][説明][具体例]1次元ベクトル空間の圏

適当な係数（スカラー）体上の1次元ベクトル空間&lt;em&gt;だけ&lt;/em&gt;を集めた圏Vec1を考える。そんなものつまんねー、と思うだろうが、いいやっ、&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;十分に面白い&lt;/b&gt;&lt;/span&gt;。

テンソル積に関してモノイド圏になる。モノイド単位はスカラー体だが、実はどの対象を選んでも単位になる。単位しかないとも言えるが、選択された（識別された）単位が1つだけある。「みんな平等」という点では、加算無限集合の圏（デカルト圏）と似た感じもする。（[http://d.hatena.ne.jp/m-hiyama/20081107/1226024690:title]も参照）

記号の集合Σをとって、Σの記号1つから自由生成された空間を考える。これは単に1次元ベクトル空間というだけでなくて、標準基底＝1個の非零元が入る。a∈Σ に対して、自由ベクトル空間 K{a} を対応させると、Σ→Vect1 という写像が出来る。この写像の像から部分圏が作れる。

この部分圏内でテンソル計算ができるわけだ。双対空間も1次元なので、Vect1内の部分圏（とみなせる）記号的なコンパクト閉圏ができる。このコンパクト閉圏内での計算と法則が1次元量のモデルとなる。昔、小島順さんが書いていた線型代数（「形」じゃなくて「型」だ）の本が、詳しく扱っていたと思う。が、小島本も紛失したな、無念。

*1235711874*[紛失物]信じられなーい！ 3

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090225/1235549533&quot;&gt;「ホップモナド、左右の随伴」&lt;/a&gt;に挙げた&quot;A diagrammatic approach to Hopf monads&quot;を印刷したんだけど、なくなった。いや、ほんとに信じられない。

ウーン、、、研究の価値があるほどに謎の現象だ。

*1235721859*[説明][JavaScript]繰り返し

「配列内から特定の値を探す」課題に対して：

&lt;pre class=&quot;code&quot;&gt;
// Eチャンのコード
// 配列arは、具体的に与えられていて ar.length = 5
var i = 0;
while (i &lt; 5) {
 if (x == ar[i]) {
  print(&quot;found&quot;);
 } else {
  print(&quot;not found&quot;);
 }
 i = i + 1;
}
&lt;/pre&gt;

ナールホド。これはこれでいいんじゃないの。

&lt;h5&gt;その前の経緯&lt;/h5&gt;

まず、iが定数0, 1, 2, 3, 4 のときの、「もし見つかったら」を、

+ if (x == ar[0]) 
+ if (x == ar[1]) 
+ if (x == ar[2]) 
+ if (x == ar[3]) 
+ if (x == ar[4]) 

のように列挙してもらった。0から開始についてはシツコク説明済み。そこから、変数iによる記述

- if (x == ar[i])

を導く。

&lt;h5&gt;注意とか教訓とか&lt;/h5&gt;

繰り返しに関しては、

- 繰り返しごとに変わっていくカウンタ変数／作業用変数を探してもらう。
- 繰り返しの開始と終了の条件を明確にする。
- まずはwhileだけを扱う。

ループの途中から脱出はけっこう難しいようだ。

次のようなパターン化も有効か（試してない）。
&lt;pre class=&quot;code&quot;&gt;
var k = 初期値;
while (kを含む条件) {
 kを含む動作
 kを減らす／増やす
}
&lt;/pre&gt;

*1235723131*[紛失物]紛れ込むパターン

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090227/1235711874&quot;&gt;「信じられなーい！ 3」&lt;/a&gt;見つかった。

コンビニ袋に、SPA! と一緒に&quot;A diagrammatic approach to Hopf monads&quot;が入っていた。ナルホド。紛れ込むパターンが多いのだな。特に、雑誌、書籍、他の書類のなかに紛れ込むことが多いようだ。

*1235725870*[セミナー][説明][プログラム意味論]結局は、高階関数概念の理解なのかな

高階関数をさまざまな側面から理解することが重要なのだ、と思う。

- 関数のパラメータ付けられた族（関数族）
- パラメータを、もう1つのの変数と思う
- たくさんの関数達の値をまとめて表示すると、2次元の表（マトリクス）になる
- これはすなわち2変数関数だろ

- 例えば、f(a, x) = a*x + 1  とすると、aをパラメータとする関数族ができる
- λx.f(a, x) はaを変数とする関数だ。
- aを具体化するということは、関数族のパラメータを具体的に1個指定すること
- 関数を生成する機構に具体パラメータを渡して生成する＝高階関数

それと、高階関数とコンパイルの関係。これはコンピュータ屋さんには必須の認識だ。

- コンパイラとインタプリタにたいした差はない（教条的に考えないこと）
- コンパイル＆ゴー方式とか考えてみよ
- 関数を生成する機構に具体パラメータを渡して生成する＝高階関数
- 具体パラメータも一種のコードなのだ。
- うんと複雑なコードを考えたらどうなる？
- コードとデータから実行結果を出すのはマシンでしょう。
- コードとマシンで高階関数の実行がシミュレートできる
- マシンに食わせるコードを作るのがコンパイルやリンク
- 数学のマシンは自明な、自明すぎるマシン

要するに、現実世界で高階関数（に相当するモノ）を作る手順がコンパイルやリンク。

数学と現実では高階関数を作るコストが全然違う

- 数学：思えばかなう
- 現実：それなりに手間がかかる、コード化＝コンパイルは複雑な作業
- 記号の世界：記号操作でコンパイルが完了

本来のラムダ計算は記号の世界の計算だから、数学と同様なコスト。適用記号＝実行エンジンを入れてもコストは安い。が、適用記号の導入により現実世界につながる定式化が得られたわけだ。

*1235727942*[人物][モナド][お絵描き]ウィラートンのホップモナド

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090225/1235549533&quot;&gt;&quot;A diagrammatic approach to Hopf monads&quot;&lt;/a&gt;が&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090227/1235723131&quot;&gt;見つかった&lt;/a&gt;ので読んでいる。

著者はウィラートン（Simon Willerton）。ウィラートンも用語法では悩んでいるらしい。ベクトル空間の圏で使われる用語を標準と考えるのがいいのかも知れない。

モノイドとモノイドの作用などに関してまとめてみる。

|* 概念     |* 集合圏 |* K-ベクトル空間の圏 |* 自己関手の圏 |
|* モノイド | モノイド | K-代数          | モナド | 
|* モノイド作用| モノイド作用を持つ集合| K-代数の加群（線型表現）| モナドの加群|
|* 余モノイド| 余モノイド| K-余代数      | 余モナド |
|* 双モノイド| 双モノイド| K-双代数      | 双モナド（bimonad） |
|* ホップモノイド| ホップモノイド | K-ホップ代数 |ホップモナド | 

この表はほぼ機械的な対応になっているが、実際の用語法は乱れている。

他にも、co- と op- の使い分けとか、lax, weak, strong, strictなどの形容詞、左右のdualの定義とか、いろいろと悩んでいる様子。同情、同感、共感、

</body>
</day>
<day date="2009-02-28" title="">
<body>
*1235793021*[紛失物]林さんの本

林晋さんの論理の本（オーム社だったか）に、カリー／ハワード対応が載っていたような気がする。この本ないなー。どこだ？

*1235797401*[リンク]クックの本、バエズ／ステイの論文

ボブクックが本を編集しているらしい。

- http://golem.ph.utexas.edu/category/2008/09/new_structures_for_physics_ii.html

バエズ／ステイの論文がリバイスされている。

- http://math.ucr.edu/home/baez/rosetta/rose4.pdf

50ページからが「計算」の章。P.50からP.66まで印刷してみた。

*1235798085*[小咄][説明][具体例]0次元も入れてみる

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090227/1235706616&quot;&gt;1次元ベクトル空間の圏&lt;/a&gt;に、零空間を入れても圏になる。0と1に掛け算を入れた代数系の圏化／線型化かな？零空間は1個しかないと思ってもいいし、無限にあると思ってもいい。射は同型か零写像しかない。

*1235805949*[小咄][雑感]ライプニッツ・アドバンテージ

表題の言葉がいきなり頭に浮かんだ。その状況と理由は … それは後日にする。

ニュートンとライプニッツのどっちが先に微積分を発見したのか？ という話があるが、歴史的に早い遅いはどうでもいい（差があっても僅差だろう）として、記号法の便利さは圧倒的にライプニッツだ。

というわけで、計算技術、計算手段がより優れている、という意味で「&lt;em&gt;ライプニッツ・アドバンテージ&lt;/em&gt;」を使いたい。ライプニッツほどの巧みさはないにしても、ある程度は&lt;em&gt;使える&lt;/em&gt;計算デバイス（手計算の手法だが）がないと、やってられないよフントニ。記号法がまずいと、せっかくのきれいな法則さえ薄汚く見える。

*1235808870*[TQFT][お絵描き][モノイド圏]リボン圏の一貫性

Bruce Bartlett の &quot;Categorical Aspect of TQFTs&quot;(TQFTはフルスペル) より：
&gt;&gt;
&lt;b&gt;Theorem (Reshetikhin and Turaev [89]).&lt;/b&gt;

&lt;i&gt;Let (C,×, 1, σ, θ) be a ribbon category. Then the evaluation of a ribbon diagram into a morphism in C is invariant under 3d isotopy.&lt;/i&gt;

In other words, the graphical calculus in terms of ribbons is entirely consistent, and is a powerful way to do computations inside ribbon categories : simply deform the diagrams appropriately.
&lt;&lt;

これは一貫性だろう。

*1235809695*[セミナー][論理][お絵描き]演繹系の話題と練習

演繹系（証明系）を、&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;技術者の言葉&lt;/b&gt;&lt;/span&gt;で語ることが課題。まだ、いろいろと思案中だがね。

まず、基本的な態度あるいは視点としては； 演繹系も計算システムであるので、通常のコンピュータシステムやプログラミング言語システム（言語処理系と実行環境）と同じだ！ ということ。

&lt;h5&gt;算術のマクロ計算システム&lt;/h5&gt;

最初に算術のマクロ計算システムを導入する。ユーザーが定義できるのはマクロだとして、マクロの使用と展開は自由に出来るとする。基本演算は組み込み関数で提供される。組み込み関数とマクロの区別は構文的にはしない（そのほうが便利）。あえてマクロとするのは、証明図との対応はマクロのほうが幾分自然だと感じるから。計算図＝計算回路図と証明図を対応させる。

算術のマクロ計算システムと論理的演繹系の対応は：

|*      算術    |*  論理 |
| 定数リテラル  |  公理の論理式  |
| 変数          | メタ変数 |
| 組み込み関数（基本演算）  | 基本推論ルール |
| マクロ        | マクロ（induced）推論ルール |
| マクロライブラリ  | 推論ルールのセット |

マクロ定義は次のようにする
&lt;pre&gt;
macro F x is

           x
  ----------------[Dup]
  x           x
 ----[Dup]
 x  x
 ------[*]
  x*x         x
 ----------------[+]  ---[Const]
     x*x + x           1
    ----------------------[+]
       x*x + x + 1
end
&lt;/pre&gt;

書式は：
&lt;pre&gt;
macro 名前 引数変数並び（カンマ区切り） is 
 計算図
end
&lt;/pre&gt;
計算図は常に算術回路図と対応する。算術回路図のほうが簡明直接的で、計算図のほうが表現力も便宜性は劣るが、テキスト形式で記述できる点がメリット。

マクロの使用は
&lt;pre&gt;
     3
   -------[F]
     13
とか
     x + y
  ------------------------------[F]
   (x + y)*(x + y) + (x + y) + 1
&lt;/pre&gt;

このマクロFは x*x + x + 1 を計算するが、マクロの場合はその場で展開されるので、f(x) = x*x + x + 1 という新しい関数（ブラックボックス）を定義したわけではない。略記（テキスト展開）という位置づけ。マクロは常に展開形を参照できる。証明では、展開形を参照できることが重要でブラックボックス化はしない。

マクロの入出力に関する言明は次の形に書く。

- [F] x |- x*x + x + 1
- [F] x + y |- (x + y)*(x + y) + (x + y) + 1
- [F] 3 |- 13

これは、

- F(x) = x*x + x + 1
- F(x + y) = (x + y)*(x + y) + (x + y) + 1
- F(3) = 13

と同じと考えてよい。。

計算システムが実際の評価（加減乗除の実行、デルタ変換）を持たず、単なる式の構成規則であれば、計算図が算術式を意味し、マクロは算術式の生成器（term froming operator）、あるいいは算術式の変換器（converter）となる。

懸案：記号計算と数値計算をどう分けるか、あるいは統合するか。マクロ展開は、あくまで図を変型するだけで、関数（演算）呼び出し＝デルタ変換はしない、とするか。

算術式のパーズは、パーズツリー＝計算図の再現になっている。論理でも、論理式をパーズしたら証明図が再現できればうれしい（が、できるかどうかは別問題）。

&lt;h5&gt;システム設計における論点&lt;/h5&gt;

- ハードウェアとソフトウェアの境界（インストラクションセット）
- マイクロ（プア）カーネルかリッチ（ファット）カーネルか
- 言語の組み込み機能とライブラリの境界
- 標準ライブラリとユーザープログラミングの境界
- 関数にするか制御構造構文にするか

演繹系でも：

- 公理にするか定理にするか（公理の最小性を気にしないとして）
- 公理にするか基本推論規則にするか
- 基本推論にするかマクロ推論（ユーザー定義）にするか

組み込みにすれば高速だがコストがかかるし、基本部分のスリムさが失われる。かといって、あまりにプリミティブな基本機能だけでは使い勝手が悪い。

ライブラリが充実すれば便利だが、大きなライブラリは記憶が大変。重複機能も増え、選択に悩む。小さなライブラリではユーザーの負担が大きい。

&lt;h5&gt;事例&lt;/h5&gt;

等式的理論、項は多変数の多項式（算術式）、定数は有理数リテラル、論理式は：

- 等式（原子論理式、基本論理式）
- P∧Q （連言）
- P⊃Q （含意）

注意：マイナス記号の扱いは構文的には煩雑。

公理か推論か、の例：

+ (ref) x = x
+ (symm) x = y ⊃ y = x
+ (tran) x = y ∧ y = z ⊃ x = z

推論ルール（シェマ、パターン）なら：

&lt;pre&gt;
   A = B
  ------[Symm]
   B = A

   A = B,  B = C
  ---------------[Tran]
     A = C
&lt;/pre&gt;

置換ルールの例

&lt;pre&gt;
/* 2つのルール */

      A  = B
  ----------------[両辺に同一置換]
  A[C/x] = B[C/x]


     A =  B
  ---------------[1つの項に左右で置換]
  C[A/x] = C[B/x]
&lt;/pre&gt;

&lt;pre&gt;
/* 1つのルール */

   A  = B    M = N
  ----------------[置換]
  A[M/x] = B[N/x]
&lt;/pre&gt;

練習問題：移項（transposeだが、transitive lawと紛らしいからラベルMoveがいいか）をマクロ規則として導入するにはどうしたらいいか？

注意：1 + 1 = 2 のような定数の計算結果は、すべて公理に入っているとすべきだろう。デルタ規則といってもよさそうだ。あるいは、変数なしの論理式（文）にはオラクル判断してよい。

&lt;h5&gt;演繹原理&lt;/h5&gt;

演繹原理（定理つうより原理）が一番難しそうだ。

- 「仮定＝仮の前提」を結論に繰り込むこと
- 集合の包含関係を、「集合が全体に一致すること」に帰着させる

という説明が可能か？ ただし、包含関係を持ち出すには、「解＝モデル」の説明が必要だ。

恒等式（公式）と方程式の違いとしても説明可能かも？

- |- P のとき、Pは恒等式
- P |- Q のとき、Pは方程式でQは解の記述

とはいえ、PよりQが単純化されている保証は全然ない。x = 1 ∧ y = 2 |- x+y = 3 。「方程式を解く」の定義があまりハッキリしない。正規系（あるいは被約系）を決めて、Qが正規系のとき「解けた」とするか。

懸案：trueとfalseの扱いを、連立方程式の文脈で説明するか。

&lt;h5&gt;証明図の描き方&lt;/h5&gt;

横線を使う方式は普通どおり。ワイヤーを使うバージョンは、

- ∧導入は黒く塗った四角つうか、太く短い横棒
- モダスポネンスはオダンゴ
- 公理は三角、オダンゴでもいいのだが、公理であることを強調
- ⊃導入は、ワイヤーをつなぐ、適当に交差させてレイアウト
- 構造規則として換（公差、クロス）と、増（重複、コピー）

横線方式の「⊃導入」は、消える仮定に番号（ラベル）を付けて、対応する推論にも同じ番号を付ける。

懸案：明白な分岐（並列処理） A∧B |- A, B を入れたほうがいいか？ あるいは、構造規則として離（分離）とか合（合流）を入れるとか。並行処理＝モノイド積を入れるなら、分岐（フォーク）がないとおかしいな。どこで入れるか？ A |- A, A を分岐にするか、Unixのforkとソックリだし。

&lt;h5&gt;並列処理、データフロー計算との関係&lt;/h5&gt;

考え中。


</body>
</day>
<day date="2009-03-02" title="">
<body>
*1235955083*[メモ][モノイド圏]ハロ多圏の利用

ハロ多圏はかなり使える感じだ。

+ モノイド圏から自明な（単純な）ハロ多圏を作る。
+ ハロ多圏にジャンクションと等式的公理（書き換えの2-多セル）を入れて拡張する
+ 拡張した多圏からモノイド圏を作る

この手順でモノイド圏の拡張ができる。直接拡張するより、ハロ多圏を経由した方がずっと分かりやすい。ただし、多圏から圏を作る部分が技術的に整備すべきところで、多圏からのパッキング（あるいはシールド、シュリンクラップ）のような手順を形式化する必要がある。

*1235983318*[メモ][圏一般論][その他代数]単純、半単純

単純／半単純概念は、次のように定義できる。

- 零対象を持つ圏なら単純対象が定義できる； 部分対象が零射か恒等射に限られるなら、単純対象。
- 零対象を持つモノイド圏（通常は直積）なら反単純対象が定義できる； 単純対象の有限積で書ける対象は半単純対象。

圏が半単純だとは、その圏のすべての対象が半単純対象である圏。同様に単純圏も定義できるがあまり意味がない。0次元と1次元のベクトル空間からなる圏は単純圏。

アーベル圏の文脈なら、すべての対象が単純対象の有限個の直和＝直積＝双積で書ければ、その圏は半単純アーベル圏。

*1235984044*[TQFT]Categorical Aspect of TQFTs

Bruce Bartlett の &quot;Categorical Aspect of TQFTs&quot;(TQFTはフルスペル) は、かなり面白い。111ページもあるから読むのが大変だ。一人読書会？ いや、ダメだ。そういうのは全然苦手、うまくいくはずもないなー。


</body>
</day>
<day date="2009-03-03" title="">
<body>
*1236042585*[山勘][課題]計算可能世界ってなんだ？ トポス（もどき）かも

計算可能なデータ領域と関数の圏をComputableとでもする。と、名前を決めたところで、The Computableが定義できそうにない。なんか適当な定義をでっちあげても、その圏が The Computableだと&lt;em&gt;主張する根拠がない&lt;/em&gt;。だが、いろいろなA Computableを定義できるので、計算可能な世界は、単一の圏ではなくて圏のレルムだと解釈すべきだろう。このレルムを調べることが計算可能性を調べることだろう。

計算可能性の圏論的定式化では、EPペア（レトラクト）、ベキ等射などを使う。この部分は比較的整備されている。例えば、圏C内で対象Xのレトラクトの全体をRetr(X, C)とすると、これはEPペアの圏C&lt;sub&gt;EP&lt;/sub&gt;を使って、Retr(X, C) = C&lt;sub&gt;EP&lt;/sub&gt;/X と書ける。レトラクトからベキ等射を作るのは自明だ。モノ射m:A→X がレトラクタブルなことと、mがEP圏の射であることは同値。レトラクタブルなモノはベキ等射で表現可能。

レトラクタブルなモノ射((「モノ」が「物」と紛らわしいからモニックとか単的とかがいいか。))（の同値類）の全体は、把握可能な部分対象だと思ってよい。つまり、Subobj(X) のようなもの。Subobjが出てくると、なんかトポスの匂いがする。計算可能な圏、A Computableはトポスになるんじゃないだろうか？ トポスそのものじゃなくても、かなりトポスに近い。

トポスの部分対象分類子を特性射と呼ぶことにする。特性射の定義には、真偽集合（真偽値集合）に相当する真偽対象が必要だが、対象Ωと終対象1から射t:1→Ωの組が真偽対象となる。対象XからΩへの任意の射p:X→ΩはX上の述語と呼ばれる。

&lt;pre&gt;
  A → 1
  ｜   ｜
  ↓ p ↓t
  X → Ω
&lt;/pre&gt;

上の四角形がプルバックになるとき、A→Xは述語pの核と呼ぶことにする。pの核は、ほぼpの外延だと思ってよい。気持ちとしては A = {x∈X | p(x) } 。ただし、述語pに核が存在する保証は一般にはない。A→X が先に与えられたときは、pはA→Xの特性射と呼ぶ。気分としては部分対象Aがpで把握される((comprehensionの訳語は「包括」だが、ここでは「把握」を使うことにする。))。

計算可能関数は集合論的には部分写像なので、計算可能な圏の終対象は空集合である。真偽対象は単元集合で、自明な埋め込みをt（true）として取れる。部分対象が把握可能とは、それが計算可能関数の定義域となる集合のことである。

述語とレトラクトの相互変換は簡単なので、述語で把握可能な集合とレトラクタブルなモノ射（の同値類）は1:1で対応する。この状況は、当該の圏がトポスか、それに近い構造を持つことを示唆するだろう。

*1236046191*[課題][圏一般論][プログラム意味論]ハロ多圏と上江州計算

ハロ多圏と上江州計算を組み合わせると、かなり強力な道具になりそう。

上江州計算では、重複器、放電器、交差の存在を暗黙の前提にしている。それぞれ、変数の複数回出現（重複）、変数の未出現（未使用）、変数の順序交換（出現位置の順序が変わる）ことに相当する。

上江州アタッチメントの概要； Vが変数集合、τ:V→|C|がソート（型）付けとして、C[V, τ]が定義できる。C[V, τ]には、x∈Vに対する変数射x:[x]→A（τ(x) = A）と逆変数射x&lt;sup&gt;-1&lt;/sup&gt;:A→[x]が含まれる。単にアタッチするだけなら、Cは任意の圏でよい（実はCが圏である必要もない）。

圏のブランド（セオリー）ごとに上江州アタッチメントを定義できるが、自由構成ができないとうまくいかない。モノイド圏やデカルト閉圏ではうまくいくだろう。V上のラムダ式（項）は、アタッチメントC[V, τ]に対して定義される。このとき、Vに全順序を入れておくほうが話が簡単だし、実用性もある。

有限部分集合X⊆Vに対して、Xを整列した列{x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)を作れる。これから、対象[x&lt;sub&gt;1&lt;/sub&gt;]× ...×[x&lt;sub&gt;n&lt;/sub&gt;]が決まり、この対象をXの領域[X]だと定める。上江州ラムダ項Mと、Free(M)⊆X であるXの組を {X}M と書く。Xが省略されたときは、X = Free(M)だとする。この形式が [X]→τ(M) という射を定める。ここで、τ(M)はMに対する型（再帰的に定義できる）。

Y⊆X に対して、上江州抽象 Y↑({X}M) が定義できる。

- Y↑({X}M) = {X＼Y}(ΛY&lt;sup&gt;→&lt;/sup&gt;.M)

「＼」は差集合、Y&lt;sup&gt;→&lt;/sup&gt;はYを整列させた列、Λはデカルト閉圏の意味でで解釈される。

以上の構成を、ハロ多圏を使って再定式化できないか？ できるはずだ。

上江州ラムダ項Mと変数集合Xが与えられると、ケリー／マックレーン・グラフもどきが描ける。Xを全順序で整列した列を上に並べ、Mの自由変数の&lt;span style=&quot;font-size:large&quot;&gt;&lt;b&gt;出現&lt;/b&gt;&lt;/span&gt;から作られた列（集合やバッグではない！） FreeOcc(M) を下に並べ、対応する変数をつなぐ。このとき、つないだワイヤー群は重複、放電、公差の有限回の組み合わせとなる。これが、変数のジャンクション・パート。

変数のジャンクション・パート以外は、もとの圏Cで解釈できる。代入文を表す射（上江州さんの用語ではv←射）では、逆変数のジャンクション・パートが出現する。変数を扱う部分は、ハロ多圏内で吸収できるのかもしれない。もし、変数の使用をハロ多圏だけで済ませることができれば、上江州アタッチメントも不要になるかもしれない。いや、むしろ、変数を入れたハロ多圏を作り、それをパッキングすることで上江州アタッチメントを構成できるってことだな。

処方箋：

+ モノイド圏から単純ハロ多圏を作る。
+ ハロ多圏にジャンクションや多射を付け加える。
+ 目的の多圏を作る。
+ パッキングする。
+ 目的のモノイド圏を作る。
+ 新しいモノイド圏と多圏がハロ構造になっていることを確認する。

*1236047752*[セミナー][論理]回路図と大きなラムダ計算がキモかな

僕には、既存のコースや教科書を踏襲する必然性も制約もない。だから、ようするに分かりやすくて短時間で説明が完了すればソレデイイノダ。手段は選ばん！

となると、回路メタファーを使うのが早いだろうし、現実世界を記述する道具として位置づけた大きなラムダ式を活用すべきだろう。

ジャンクション（接合器）と回路素子（circuit element）のセットを回路キットと呼んで、特定の回路キットから作れる回路を考えることになる。入り口は算術回路かな。

|* 本来(?)の用語 |* 比喩的な用語 |
| 指標 | 回路キット |
| プロファイル付き記号 | 回路素子 |
| パラメータ付きプロファイル付き記号 | ジャンクション |
| ソート | ワイヤーのラベル |
| 変数／値 | ワイヤーを流れるデータ／記号的トレーサ |
| 同値 | 回路の同値 |

回路キットの雰囲気は、ラキュー（LaQ）の写真でも使うか。電子ブロックが本家か。

命題論理の回路とラムダ計算の回路の場合：

|*  命題論理    |* ラムダ計算 |
| 命題変数  | 基本型、ソート |
| 論理式    | 型表現 |
| 証明      | 式（自由変数あり）     |
| 前提なしの証明 | 閉じた式 |
| 演繹定理  | ラムダ抽象 |
| モダスポネンス | 適用 |
| モダスポネンス消去 | βη変換 |

これを使えば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080526/1211759810&quot;&gt;ジラール対応&lt;/a&gt;まで説明できるだろう。

*1236048954*[リンク][論理][お絵描き]ドミニク・ヒューズの証明絵算論文

- Title: Simple free star-autonomous categories and full coherence (July 7, 2005)
- Author: DOMINIC J. D. HUGHES
- URL: http://boole.stanford.edu/~dominic/papers/freestar/freestar.pdf
- Pages: 36

&gt;&gt;
This paper gives a simple presentation of the free star-autonomous category over a category, based on Eilenberg-Kelly-MacLane graphs and Trimble rewiring, for full coherence.
&lt;&lt;

*1236061217*[紛失物]再度一部を印刷

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090106/1231234044&quot;&gt;フーフマン論文&lt;/a&gt;が見つからない。しょうがないので、カロウビ展開圏のところを再度印刷した。

*1236061556*[圏一般論]割り算できそう

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090217/1234826303&quot;&gt;メリーズの定式化&lt;/a&gt;をヒントに割り算問題を考えてみた。思い付きだから、確認しないとヤバイけどね。

圏Cの部分圏Σが次の条件を満たすとき、Cのメッシュと呼ぶ。

+ 広大部分圏である。
+ 痩せた（細い）亜群である。
+ AとBが同型ならΣ(A, B)は空でない。

Σによる割り算として、商C/Σと強い商C//Σを定義する。C/Σの定義はメリーズと同じ。C//Σは次のように定義する。f:A→B と f':A'→B' が同値であることを次のように定義する。

+ AとA'、 BとB'はCで同型である。
+ Σの射を[A, A'], [B, B']のように書く。
+ f' = [A',A];α;f;β;[B,B'] と書けるとき、fとf'は同型である。ただし、αとβはCの自己同型。

メッシュΣの標準的な選び方はまったく存在しないので、ΣとΓがメッシュのとき、C//ΣとC//Γが圏同値になることを示さないといけない。

DがCの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081101/1225518932&quot;&gt;十分な部分圏&lt;/a&gt;のとき、CのメッシュΣをDに制限してもメッシュができる。C//ΣとD//Σは圏同値だと思うがどうか？

線型代数で言えば、線形写像の標準形を求める話。有限次元ベクトル空間の圏のなかで、数空間の圏が十分な部分圏になっている。特に数空間では標準基底が選べるから、数空間の圏には標準的メッシュが存在する。つうか、骨格部分圏か（圏が骨格的 ⇔ 同型の対象は等しい）。強い同値関係だから、ランクだけで分類されてしまう。結局、{0, 1, ..., n}を対象としして、0からkまでを0に移し、残りは単射で埋め込む写像の圏と圏同値になる。ほかの分類や標準形も、圏の割り算で説明できるか？

それと、十分な骨格部分圏の上で、f' = α;f;α&lt;sup&gt;-1&lt;/sup&gt;で同値関係を入れたらどうなるだろう。

*1236068726*[セミナー][論理]等式的推論の推論規則

&lt;h5&gt;推論の構造規則&lt;/h5&gt;

回路図ではジャンクション。

+ 無（恒等、NOP）
+ 増（重複、コピー）
+ 換（クロス）

放電器は入れない。また定数true（T、I）も入れないことにする。面倒になる割に恩恵が少ないから。

&lt;h5&gt;推論の論理規則&lt;/h5&gt;

|*略記号 |* 役割 |* 対応する射 |
| Sel1   | ∧-消去1 | π&lt;sub&gt;1&lt;/sub&gt; |
| Sel2   | ∧-消去2 | π&lt;sub&gt;2&lt;/sub&gt; |
| And    | ∧-導入  | (-, -) |
| MP     | ⊃-消去  | ・ |
| DT     | ⊃-導入  | Λ, λ |

∧の交換律を入れれば、∧-消去が1つになるが、対称性を重視して左右の消去を入れておく。

&lt;h5&gt;等式の推論規則&lt;/h5&gt;

+ 公理・定理のインスタンス化 Inst
+ 等式を前提とした置換 Subst

他に、等号に関する公理を入れる。

&lt;h5&gt;有理数の公理&lt;/h5&gt;

足し算に関する公理、掛け算に関する公理、分配法則も入れる。定数演算記号は、+, *, 0, 1 以外に ~, (-)&lt;sup&gt;-1&lt;/sup&gt; を入れておく。実際には、有理数を特定するわけではなくて、単に体の公理。


*1236068727*[セミナー][論理]連立一次方程式のためのマクロ推論規則

&lt;h5&gt;Subst' 規則&lt;/h5&gt;

A[y/y] ≡ A  を使う。
&lt;pre&gt;
   y = C
 -----------[Subst']
  A = A[C/y]
&lt;/pre&gt;

&lt;h5&gt;代入法の原理&lt;/h5&gt;

Subt'とSymm, Tranを使う。

&lt;pre&gt;
  A = B   y = C
 -----------------[Ass]
  A[C/y] = B[C/y]
&lt;/pre&gt;

&lt;h5&gt;左変型規則と右変形規則&lt;/h5&gt;

&lt;pre&gt;
  A = B
 --------[Left:A = A']
  A' = B
&lt;/pre&gt;

&lt;pre&gt;
  A = B
 --------[Right:B = B']
  A = B'
&lt;/pre&gt;

&lt;h5&gt;連続等式変型&lt;/h5&gt;

&lt;pre&gt;
   A  [S = S']
 = A' [T = T']
 = A''

よって、A = A''
&lt;/pre&gt;

&lt;pre&gt;
  S = S'
 ------------------[Subst]
  A[S/x] = A[S'/x]
  (A = A')               T = T'
                --------------------[Subst]
                 A'[T/X] = A'[T'/x]
                (A' = A'')
 -------------------------------[Tran]
  A = A''
&lt;/pre&gt;

*1236068728*[セミナー][用語法]Δとσはこんなにいろいろな言い方がある

Δ：1つのモノをコピーして2つにする
+ 対角（diagonal）
+ 余加法（coaddition）
+ 分岐（blanching, ramification）
+ 重複（duplication, duplicator）
+ コピー（copy）
+ クローン（clone）
+ フォーク（fork）
+ 水増し（weakening, thinning）

σ：2つのモノの並び順を入れ替える
+ 対称（symmetry）
+ 対称ブレイディング（symmetric braiding）
+ クロス、交差（cross, crossing）
+ 交換（exchange, interchange）
+ フリップ（flip）
+ スワップ（swap）
+ ツイスト（twist）

*1236068729*[セミナー][具体例]いろいろな算術システムの例

&lt;h5&gt;A1&lt;/h5&gt;

+ 任意のnに対して掛け算 (*n) : 1→1
+ 足し算 (+) : 2→1

xだけ、x, y、x, y, zに関してどんな出力が出来るか？ なんらかの標準形（正規形）は定義できるか？

&amp;#40;(x + x) + x) + x, (x + x) + (x + x ) を描くとどうなる？

&lt;h5&gt;A2&lt;/h5&gt;

+ Δ : 1→2
+ (+) : 2→1

xだけ、x, y に関してどんな出力が出来るか？ A1と比較。

&lt;h5&gt;A3&lt;/h5&gt;

+ Δ : 1→2
+ σ : 2→2
+ (+) : 2→1
+ (*) : 2→1

x, y に関して x*y + x*z は出来るか？ 標準形（正規形）は定義できるか？σをなくすと表現力はどうなるか？

&lt;h5&gt;その他&lt;/h5&gt;

定数や放電器の扱い。

半環のイデアル問題、部分半環の問題。

*1236074572*[雑感]絵暗算＜えあんざん＞

- 紙を使わず、目をつぶり、頭のなかに絵をイメージして、絵算すること。
- かなりの修行を要する。
- やってみるか。
- … …
- いや、待て、何を計算するのだ？
- 課題も頭の中でイメージ、、、、&lt;b&gt;むっ、難しすぎる。&lt;/b&gt;

</body>
</day>
<day date="2009-03-04" title="">
<body>
*1236144121*[セミナー][論理]カリー／ハワード／ジラール対応の陳述

次のように述べることができるだろう。

+ 前もって、命題変数と型名（型記号、型変数）の対応があるとする。
+ 命題論理式と型表現（type expression）の翻訳をτで示す。
+ 命題論理式Pの（仮定なし）証明と、τ(P)で型付けされた閉じたラムダ式が対応する。
+ 証明の中間に出てくる各論理式Qには、型がτ(Q)の変数が対応する。
+ 証明の各推論には、項の構成規則と型推論が対応する。（項の構成規則と型推論は一体）
+ 証明の簡約とラムダ式の計算が対応する。
+ 簡約済みの証明は正規形ラムダ式に対応する。

注意

+ true, falseの定数は入れない。
+ ∨や￢も入らない。
+ 2成分以上のタプルを扱ってもよい。

タプルに関する変型

+ (t.1, t.2) ⇒ t
+ (x, y).1 ⇒ x
+ (x, y).2 ⇒ y

&lt;pre&gt;
       t
 --------------[Dup]
  t         t
 ---[Sel1] ----[Sel2]
  t.1      t.2
 --------------[And]
     t.1∧t.2
&lt;/pre&gt;

これをストレートに。雰囲気は ◇⇒｜ 。

&lt;pre&gt;
  x     y
 ---------[And]
   x∧y
  -----[Sel1]
    x
&lt;/pre&gt;

これをストレートに。雰囲気は Y ⇒ ＼ ⇒ ｜、 Y ⇒ ／ ⇒ ｜ 。

&lt;b&gt;[追記]&lt;/b&gt;
引き伸ばし変型のまとめ：

+ ∩∪ ⇒ ｜ （β）
+ ∪∩ ⇒ ｜ or ｜⊃ ⇒ ｜ （η）
+ ◇ ⇒ ｜ 
+ Y ⇒ ＼
+ Y ⇒ ／
&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2009-03-05" title="">
<body>
*1236212353*[メモ][雑記]詳細は後で（バートレット、計算の世界、XML）

寒いし雨降っていたので、ふさぎ込んで頭に来ていろいろと考えた。

+ ブルース・バートレット（Bruce Bartlett）は秀才だ。修士論文も学位論文もよい。
+ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=Bartlett
+ そのバートレットの学位論文 &quot;On unitary 2-representations of finite groups and topological quantum field theory&quot; 5章を読んだ。
+ それで、カテゴリカルマニュピュレーションと工作圏論の概念を思いついた。
+ カテゴリカルマニュピュレーション＝手作業＝加工の例：ラムダ抽象とその逆、ブレイド（とツイスト((ツイストのペアによりネジレ玉をほぐす。))）による単位／余単位のフリッピング、軸的圏（pivotal category）における軸反転（pivotting）
+ バートレットは、双対構造のフリッピングによって、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070215/1171518089&quot;&gt;もろ手双対（もろ手随伴）&lt;/a&gt;を定式化している。ε&lt;sub&gt;A&lt;/sub&gt;をフリップする操作（マニュピュレーション）Ψ&lt;sub&gt;A&lt;/sub&gt;と、η&lt;sub&gt;A&lt;/sub&gt;をフリップする操作Φ&lt;sub&gt;A&lt;/sub&gt;の集まり。
+ バートレットは、even-handed構造と呼ぶ。訳語は両側構造か？ 両側公平、左右公平？？
+ バートレットは&lt;em&gt;随伴と双対は区別しない&lt;/em&gt;と明言している。ナルホド、やっぱりな。で、もろ手双対は ambidual（アンバイ双対、ambidextrous dualの短縮） でいいと思う。

それとは別に：

+ コンピュータとプログラムの世界を、全体的にまるごと定式化するにはどうする？
+ インスティチューションは必須だ。
+ プログラミング言語は、構文生成モナドTとプリミティブを与える指標Σとの組だ。
+ プログラムpは、モナドTのKleisli圏に射として存在するが、Σによるスライス圏の&lt;strong&gt;対象&lt;/strong&gt;と考えたほうがよい。
+ よって、プログラムp:Σ→Δ は、スライス圏のあいだのプログラム変換関手も定義する。圏の対象でもあり同時に関手でもあるという二重性。
+ プログラムの生成（creation）、進化（evolution）、リファクタリングなども定義したい。
+ エミュレーションやコンパイルも定式化。
+ そのためには、単一のインスティチューションでは無理そうだ。
+ インスティチューションの圏が必要だが、射の概念が難しい。
+ モデル圏は状態遷移系が基本だと思う。
+ セリンガー流の入出力＝コミュニケーションを持つ遷移系だろう。
+ 具体例のなかでの具体的構成が必要だ。

ひさびさにXMLのモジュールについて考えた。

+ モジュール式（表現）という概念が基本。
+ モジュールの名前は、モジュール型の変数
+ モジュール定義とは、モジュール（実体）のリテラル表記
+ 変数とリテラルを演算子で組み立てた表現がモジュール式
+ モジュール式もモジュールを指し示す
+ モジュール型変数へのモジュール式を代入する文（宣言）の集まりがモジュール記述
+ モジュールにもα変換がある
+ α変換で移れる関係＝α同値を入れて考える
+ α変換とα同値のもとでは、モジュールの並置（モノイド積）や結合（多圏の結合）が合理的に定義できる。
+ モジュールにプライベートな名前も内部α変換される。これは、圏からスパン圏を構成するときに同値類を取る操作に対応する。内部α変換で移れるモジュールはイコールとみなす。
+ 構文的には、結合以外に、並置とトレースを組み合わせたマージがある。
+ importの合理的解釈も可能だ。
+ includeは止めたほうがいい。
+ モジュールもコンパイルすべき。適当なプログラミング言語のソースにするか、独自の言語に変換。

*1236230848*[人物][文献][リンク][TQFT]ブルース・バートレットの圏論的TQFT

ブルース・バートレット（Bruce Bartlett）の論文。

修士論文：
- Title: Categorical Aspects of Topological Quantum Field Theories (Submitted on 5 Dec 2005)
- Author: Bruce H. Bartlett
- URL: http://arxiv.org/abs/math/0512103
- Pages: 111

博士論文：
- Title: On unitary 2-representations of finite groups and topological quantum field theory (Submitted on 26 Jan 2009)
- Authors: Bruce Bartlett
- URL: http://arxiv.org/abs/0901.3975
- Pages: 243 (PhD thesis)

2005年の論文もThesisと書いてあって「博士論文にしては学生のレポートみたいだ」と思ったが、こっちは修論だった。2009年の&quot;On unitary ...&quot;は、さすがにオリジナルな結果がたくさん入っている。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070219/1171877487&quot;&gt;ルーリエ&lt;/a&gt;は、突出した天才だということは僕にもわかるが、彼が書いているものは僕には&lt;em&gt;サッパリわからん&lt;/em&gt;。バートレットはルーリエほどに超絶「頭イイ」とは違うようだが秀才。わかりやすい文章を書く才能はたいしたものだ。クダンの学位論文も巧みな構成でつまみ読みもできるように工夫されている。

僕が読んだのは5章だけだが、ほぼself-contained((ジャーブ（gerbe, gerbes）やトルソー（torsor）はわからんけど。))。解説も丁寧だし、例も豊富。アイディアの源泉も書いてあるのが親切だ。双対性に関して、「双対の全体」を自覚的／意識的に把握して、双対性の全体の集合に群による対称性を入れている。この発想は目から鱗。スピン構造とのアナロジーで考えたらしいが、そもそもスピン構造との類似に気が付くのが素晴らしい。特定のdual morphismを選んで割り当てる行為（スターオペレータの定義）は、バンドルのセクション＝自明化として位置づけている。ナールホド。F|→F&lt;sup&gt;*&lt;/sup&gt;はセクションを固定することだったのか。

もろ手随伴は、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070215/1171518089&quot;&gt;アーロン・ラウダ（Aaron D. Lauda）の&quot;Frobenius algebras and ambidextrous adjunctions&quot;&lt;/a&gt;に出てくる概念で、Fの右随伴かつ左随伴であるようなGのこと。両側構造（even-handed structure）があれば、右随伴から左随伴（左随伴から右随伴）を作り出せるので、もろ手随伴（もろ手双対）が自動的に出現する。バートレットは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090228/1235805949&quot;&gt;記法の選択もうまく&lt;/a&gt;て、計算が簡単に思える。

*1236231861*[リンク]ジャーブについて

日本語の解説があるが、これはプレゼンスライド？ 字がでか過ぎる。

- http://www.ma.utexas.edu/users/kgomi/nitech/gerbe_1.pdf
- http://www.ma.utexas.edu/users/kgomi/nitech/gerbe_2.pdf
- http://www.ma.utexas.edu/users/kgomi/nitech/gerbe_3.pdf

*1236246173*[高次圏論][モノイド圏]2-圏における1-セルの双対性の集合

また、バートレット（Bruce Bartlett）の話だが： 彼は、Fの右双対F&lt;sup&gt;*&lt;/sup&gt;を圏（2-圏）全体で割り当てる定式化をさかんに（しかしやんわりと）批判している。僕は、割当てがあったほうが使いやすいと信じていたので、意外な感じもするが、「双対性の集合」を考える立場では確かに一意割当てを固定するのはふさわしくない。

FとGに対して、GをFの右双対にする双対性の全体を Adj(F -| G) とか Dual(A -| B) とバートレットは書く。これは、単なる命題「GはFの右双対」ではなくて、その命題を成立させる根拠の集合。つまり、

- Adj(F -| G) ＝ 空 ⇔ GはFの右双対となり得ない
- Adj(F -| G) ≠ 空 ⇔ GはFの右双対となり得る

左右公平構造（even-handed構造）は、F, Gごとに Adj(F -| G) → Adj(G -| F) という写像の族により定義される。逆向きペア(F, G):A→B を射とするような圏を考えると、Adjは射の上にファイバーとして集合をくっつけたような構造となる。このファイバーもどき構造を明示的に考察の対象とした点がバートレットの新しいところだと思う。


</body>
</day>
<day date="2009-03-06" title="">
<body>
*1236313266*[雑感][お絵描き]ゆらいでしまう等しさ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090227/1235727942&quot;&gt;ウィラートン&lt;/a&gt;の3次元絵算から：

&lt;img src=&quot;http://www.chimaira.org/img2/monoidal-functor.jpg&quot; &gt;

これは、関手M:C→Dがモノイド関手である条件（法則）のなかに出てくる比較射（法則の構造射ともいえる）に対する一貫性条件。ここで等号「=」が使われている。が、これらの図形はどう見たって等しくない。左から右、または右から左への変形過程（アニメーション）が存在するよ、って話だと思う。

しかしそうすると、一貫性条件の3つの“等式”に出現する比較射（比較セル）に関する高次の一貫性条件を書き下す必要がある。それは等式で書けるだろうか？ たぶん書けないだろう。また変形過程に見えてしまう。すると、、、（繰り返し）、、、無限に一貫性を書かなくてはならない。どうやってこの無限後退（無限前進か？）を終わらせることができるのだろう？

*1236314768*[プログラム意味論][インスティチューション]インスティチューションがうまくない理由

インスティチューションは、構文とモデルを区別する。もともとがモデル論だから当たり前だ。が、コンピュータでは、その構文領域もデータ領域としてモデルの世界に入り込む。ここが問題。

インスティチューションの構造を残しながらも、構文（項）がモデルの世界に入り込むメカニズムが必要だ。モデルMod[Σ]を関手圏A&lt;sup&gt;Σ&lt;/sup&gt;として定義するのがひとつの手かもしれない。圏Aは、定数係数のような外部環境のようなアーキテクチャのような、、、


&lt;pre&gt;
         |
 --------+-------- モデルの世界（Mod[Σ]達が住んでいる）
         |
         |          ↑意味写像
         |
 --------+-------- 構文の世界（ΣやT(Σ)達が住んでいる）
         |
        ↑この面（この図の上下方向）で切ってみたら何が見える？
&lt;/pre&gt;

&lt;em&gt;これは難しいなー。&lt;/em&gt;

&lt;b&gt;[追記]&lt;/b&gt;

コンパイルの概念を最初から組み込むしかないかな。大きなラムダ式とかハロ多圏とかがヒントになるのかも知れない。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2009-03-07" title="">
<body>
*1236387393*[モナド][お絵描き][モノイド圏]ベックの法則とモノイド

本編の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070507/1178496486&quot;&gt;「ベックの法則と複合モナド」&lt;/a&gt;の絵を使って、複合モナドの結合律と単位律を絵算でやるのはいい練習問題。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090303/1236074572&quot;&gt;絵暗算&lt;/a&gt;でやろうとしたが無理だった。

この計算は、どんなモノイド圏でも通用する。通常あまり意識されないのは、ベックの法則がブレイディングからすぐに出てきてしまうので、ベックの法則を使っている気がしないせいだろう。計算を分解してみると確かにベックの法則を使っている。

m:A×A→A, m':B×B→B を2つの積とする。σ:A×B→B×A をスワッパーとする。スワッパーは自然変換として与えられていなくてもいい。
&lt;pre&gt;
∪  ∪ 
 ＼／  (m×m');σ;
 ／＼
&lt;/pre&gt;

このとき、スワッパーにベックの法則を要求すると（σがベックのスワッパー）

- (m×m');σ = (1&lt;sub&gt;A&lt;/sub&gt;×σ×1&lt;sub&gt;B&lt;/sub&gt;);(σ×σ);(1&lt;sub&gt;B&lt;/sub&gt;×σ×1&lt;sub&gt;A&lt;/sub&gt;);(m'×m)

が成立する。これもベックの法則の繰り返し適用。絵では自明。

モナドはEnd(C)のモノイドだが、このモノイドが2-圏の双対構造（随伴構造）に基づく自明モノイドだってことが重要だ。ベックのスワッパー＝分配律は、局所的（アドホック、pointwise）に与えられた半ブレイディングになる。バートレットの視点に従えば、大域的に割当がなくても十分意味があるのだから、個別のスワッパー（半ブレイディングA×B→B×A）も当然に興味の対象となる。

あと、ウィラートンの絵とか見てると、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070507/1178496486&quot;&gt;「ベックの法則と複合モナド」&lt;/a&gt;に描いておいた「すべり台」はマンザラでもない。

&lt;img src=&quot;http://www.chimaira.org/img2/beck-deformation.gif&quot; &gt;

*1236389022*[用語法][圏一般論][人物]若い子達の言葉

ウィラートンやバートレットは若者だろう。で、彼らが使う言葉はやっぱり世代的な影響があるように思う。

- ウィラートンは三角恒等式を snake relation, snake condition と言う。
- バートレットも snake-style とか使っていた。
- ペースティング図ではなくてglobular diagramと言っている。
- ストリング図（globular図のポアンカレ双対）はどうやら定着したらしい。
- モノイド圏を2-圏と見なすのは常識化して、随伴と双対を区別しない

オジサンも若者言葉を使うことにしようっと。

*1236399688*[モナド][お絵描き][モノイド圏][小咄][具体例]ベックの法則をもう少し

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070507/1178496486&quot;&gt;「ベックの法則と複合モナド」&lt;/a&gt;の補足をもう少し。

絵図で見ると、ベックの法則は、ワイヤー（ストリング）のクロスする場所を乗法や単位をすり抜けさせる絵になっている。つまり、ジャンクションと回路素子に関する「すり抜け」の法則。ワイヤーのクロスがベックのスワッパー。絵算的には、スワッパーとは「すり抜け可能な交差」ということになり、実際、結合律や単位律の証明は「すり抜け」を何度か使って遂行する。ブレイドσがあるなら、(1×f);σ = σ;(f×1) などがすり抜けを表現する。

ところで（ここからが本題）、スワッパーは本来「分配法則」と言うのだが、これはなぜか？ (L, μ, η)がモナドとして、おおよそ、次のような雰囲気がある。

- Lは項生成規則（term {forming,production} rules）
- μは結合法則
- ηは、文字や変数を項とみなすこと

これだけじゃ分かりにくいが、本編のListモナド(L, μ, η)とEnumモナド(E, ν, ξ)を例にする（記号は違う）と、

- Lは自由掛け算モノイドの項を生成する
- μは掛け算に対するアンバイアスな結合法則＝括弧の外し方を与える
- ηは、アルファベットの単一文字を掛け算の項（あるいは文字列）とみなす。

同様に：

- Eは自由足し算モノイドの項を生成する
- νは足し算に対するアンバイアスな結合法則＝括弧の外し方を与える
- ξは、アルファベットの単一文字を掛け算の項（あるいは文字列）とみなす。

Listモナドは自由モノイドまたは自由半群を作る作用となる（空列を許さないと単位はないので半群）。掛け算は可換ではないが、μが“項の積”を項とみなすやり方を与える。Enumuモナドは自由可換モノイドまたは自由可換半群を作る作用。足し算は可換となり、νが“項の和”を項とみなすやり方を与える。

ListしてEnum（L;E = E・L）すれば、半環の項が生成される。半環の項の簡約には、結合律だけではダメで分配律が必要になる。それは、EnumしてList（E;L = L・E）した形、つまり和の積を単純化する法則だから、L・E ⇒ E・L という形の変換で与えられる。これが分配法則δ:L・E⇒E・L というわけ。

僕はベックの動機をまったく知らないが、半環項の生成と掛け算／足し算の結合律、足し算に対する掛け算の分配律を備えた計算体系が作りたかったのなら、確かにスワッパーは分配法則と呼ぶのは自然だ。

*1236400354*[モナド][モノイド圏][計算][小咄]超クレイジー計算

僕好みのネタを見つけた。「キチガイ」が差別用語にされているようだからクレイジーを使うが、超キチガイ計算のほうが“いい語感”だけどな。

&lt;b&gt;[追記]&lt;/b&gt;
- http://ck.mailmag.livedoor.com/ck/20090009bec47c0c080b4d015c/
&lt;b&gt;[/追記]&lt;/b&gt;

Cが、直和または直和に似たモノイド積を持つ圏だとして、そのモノイド積を自明に持ち上げて、End(C)を半環に近い構造にすることができる。掛け算は関手の結合で、足し算はCからの持ち上げ。

Fがモナド構造を持つと、1≦FとかFF≦Fが成立する感じだ。Fのクリーネ級数 1 + F + FF + FFF + を簡略化する計算とかはクレイジー計算で出来そうだ。ベックの分配法則（スワッパー）が、FG ≦ GF のような計算（書き換え）規則を与える。

このテのクレイジー計算は計算規則に対する計算を与えそうだ。

*1236400669*[モノイド圏][雑感]左右公平構造（even-handed structure）

バートレット（Bruce Bartlett）の左右公平構造（even-handed structure）は面白いなー。

バートレットは、Fのもろ手双対（ambidual）の集合AmbiDual(F)の上にフリップ写像Ψを定義して、ΨがΨ&lt;sup&gt;2&lt;/sup&gt; = Idであることを仮定している。もろ手双対を出さなくても、次のような定式化でもいい気がする。

- Fの右双対、左双対の集合をRDual(F), LDual(F)とする。
- d∈RDualのとき、d = (G&lt;sub&gt;d&lt;/sub&gt;, η&lt;sub&gt;d&lt;/sub&gt;, ε&lt;sub&gt;d&lt;/sub&gt;) と書く。
- Ψ:Rdual(F)→LDual(F) で、Ψ(d) = d' のとき、G&lt;sub&gt;d&lt;/sub&gt; = G&lt;sub&gt;d'&lt;/sub&gt; であるΨを考える。Gのことを双対dの台と呼ぶと、Ψは台を動かない。
- Ψが、双対の台を動かさない写像として、さらにΨは可逆で、逆Ψ&lt;sup&gt;-1&lt;/sup&gt;:LDual(F)→RDual(F)を持つ。

以上の状況で、Ψを左右公平フリップ、あるいはバートレット・フリップと呼んでもいいだろう。問題は、フリップの構成の仕方。ブレイド（特殊ケースとしては対称）とツイストで組み立てるのが具体的（工作的）で楽しい。

ついでに用語も整理しておくと、

- 任意のFの対して Rdula(F)≠空 のとき、圏は右自立
- 任意のFの対して LDula(F)≠空 のとき、圏は左自立
- 右自立かつ左自立なら両側自立

両側自立だけでは面白くないし、使いにくい。軸反転構造が入ると軸的圏（pivotal category）。2-射の双対が一意的に決まる；つまり、射の右双対と左双対の区別がなくなる。

*1236401148*[用語法]面倒だから揃えない

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%bc%ab%ce%a7%b7%f7
- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%bc%ab%ce%a9%b7%f7
- [google: site:d.hatena.ne.jp/m-hiyama-memo (自立圏|自律圏)]

*1236413864*[基本スキル]とりあえず思い付きで列挙

- 正規表現、オートマトン、BNFによる表現
- 構文図とモダンなフロー図
- 再帰下降パージング
- ビットストリーム（バイトに限らない）による通信
- バイト（あるいはワード）単位のビットによる画像表現
- メタ情報、ヘッダ、コンテンツ（ペイロード）
- マルチプレックス
- ファイルとストリームの概念
- スタックと手続き呼び出し
- 再帰
- 末尾呼び出しの最適化
- 同期アクションとコミュニケーション
- イベントという概念
- 3つの話題：データストリーム、手続き呼び出し、イベント配送


</body>
</day>
<day date="2009-03-09" title="">
<body>
*1236554636*[雑記]疲れている

本編と間違えて書き込んだよ、、、

*1236556564*[課題][復習][モノイド圏][モナド]ちゃんと調べてみよう、もう一度

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080414/1208166288&quot;&gt;モノイド圏の別な公理化&lt;/a&gt;

これは、End(C)をモノイド圏とみなすとき、自然変換の水平結合（横結合）が難しいので、その難しさを緩和するために作った公理系。 … のはず。

ペースティング図（globular図）、ストリング図と一緒に使えばそれなりに役立つはずだと思う。もう一度確認・整理すべし。

*1236556565*[セミナー][モナド][M3]更新モノイドとモノイダルスタンピング・モナド

Aが勝手な集合のとき、a, b∈A に対して、a・b = b として右自明演算が定義できる（左でも同様）。これは半群になるが単位元はない。単位元eを人為的に添加して A+{e} とすると、これはモノイド。右自明モノイドと呼ぶ。A→A である写像の全体End(A)に右自明モノイドを埋め込むことができる（定数写像と恒等写像）。

Aの右自明モノイドA+{e}に対するモノイダルスタンピング・モナドを考えると、大域変数への代入（値の破壊的更新）という副作用を持つ関数を記述できる。

整数の集合を、整数の加法群が作用する等質空間と考えて、同じくモノイダルスタンピング・モナドを作ると、カウンタの増減を副作用とする関数を記述できる。

スタックを作用付きの集合（余代数）だと思って、モノイダルスタンピング・モナド（余代数スタンピングだろうが）を作ると、入出力（読み書き）可能なファイルに対する作用を記述できる。

副作用の多くは、作用モノイドに対するモノイダルスタンピング・モナドで実現できる。代数スタンピング、余代数スタンピングまで考えるとかなり守備範囲は広い。

*1236556566*[セミナー][プログラム意味論]タプルとコンパイル、その他言い残し

- プログラムの実現はハードウェアでもソフトウェアでもよい。区別はしなくてもよい。
- 関数のパラメータ族（parameterized family）は2変数関数とみなせる、パラメータの具体的指定が引数の具体化
- 無名変数を、-, _, *, ・ などで表す習慣がある。
- 日常感覚が大事、日常感覚のほうが精密かも
- 例：(int×int)×bool と int×(int×bool) は違う型である。実際に、引数アダプターが必要になる。

&lt;pre&gt;
ソースコード →(コンパイル)→ マシンコード
  ｜                           ／
 (記述)                      ／
  ↓                       ／
 関数 ←(実現／エミュレート)
&lt;/pre&gt;

*1236556567*[セミナー]分類

- Lecture型
- Discussion型
- Training型

*1236558853*[お絵描き]ヤンキングとフリップの同値性、Ψ移動重要だ

以前も書いたような気がするが、ジグザグ公式を大前提として、ヤンキング公式とフリップ公式は同値になる。そのとき、重要なのはトゥラエフ移動のなかのΨ（プサイ）移動。

Ψ移動は次の形：

- (σ+1);(1+) = (1+σ)(ε+1)

これを使うと、クロスしたループ Tr(σ) = (1+η');(σ+1);(1+ε) を次の形にできる。

- (1+η');(1+σ);(ε+1)

ヤンキング公式は、(1+η');(1+σ);(ε+1) が自明になることを主張するが、この事とジグザグ公式からフリッピング可能であることが出る。

状況証拠からみて、ジグザグはほんとの基本なのだろう。Ψ移動も非常に基本的な気がする。Ψ移動とクロスオーバー公式は似ているが、クロスオーバーはブレイドの性質の直接の帰結。Ψ移動はブレイディングの性質から出てくるようには思えない。

</body>
</day>
<day date="2009-03-10" title="">
<body>
*1236639841*[お絵描き][モノイド圏]Ψ移動、クロスオーバー、フリップ、ヤンキング

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090309/1236558853&quot;&gt;「ヤンキングとフリップの同値性、Ψ移動重要だ」&lt;/a&gt; より：
&gt;&gt;
Ψ移動とクロスオーバー公式は似ているが、クロスオーバーはブレイドの性質の直接の帰結。Ψ移動はブレイディングの性質から出てくるようには思えない。
&lt;&lt;

って、こりゃ&lt;em&gt;完全にウソ&lt;/em&gt;。アーホじゃーー。以前、Ψ移動（トゥラエフ主移動と書いているが）とクロスオーバーの同値性は示していた(苦笑)。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061002/1159750282&quot;&gt;トゥラエフ主移動とクロスオーバー公式&lt;/a&gt;

というわけで、Ψ移動とクロスオーバー公式のどっちを前提しても同じこと。さらに、クロスオーバー公式は、ブレイドの基本特性から出る。ブレイディング交差に沿ったスワップ（∩が／の下をすり抜け）さえあればOKなのだ。

結局、双対性とブレイディングがあれば、ヤンキング公式とフリップ公式の同値性を示せる。つまり、議論はブレイド付き右自立圏内で行える。「ヤンキング公式⇔フリップ公式」は、空間の縦と横を入れ替える作用があるので、空間の等方性を主張することになる。

雰囲気としては、右自立圏（または左自立圏）にブレイディングがある状況で、ヤンキングかフリップのどちらか（どちらでもいい）が成立すれば、縦方向クロスループと横方向クロスループ（図形 ×⊃、⊂×）は同値な図形でどちらも伸ばして、恒等か単位／余単位にすることができる。

*1236651999*[モナド][プログラム意味論][インスティチューション]モナドと構文と計算

インスティチューションは概念を整理する枠組みとしては便利だが、中身がまったくないので、インスティチューションから出発してもラチがあかない。なんか実際のモノを作って、後から見たらそれはインスティチューションでした、ってことじゃないとダメだな。

で、抽象的インスティチューションに欠けている実質は、指標が何であるか？ 指標の圏が何であるか、指標の圏とモデルの圏をごちゃ混ぜにできるメカニズムなど。

構文論がモナドをベースにできることは、非常に確からしい気がする。ので、とりあえず、モナドから出発して、インスティチューションを意識しながらナニカ（何だ？）を作る方針にする。

&lt;hr&gt;

&lt;h5&gt;モナドの例と解釈&lt;/h5&gt;

モナドの例としては、自由ベクトル空間を作るモナドと自由半群（モノイドである必要はない）を作るモナドを考える。自由ベクトル空間を作るモナドの関手部分は K&lt;sup&gt;1&lt;/sup&gt;[A]、自由半群モナドでは A |→ A&lt;sup&gt;+&lt;/sup&gt; と書ける。K&lt;sup&gt;1&lt;/sup&gt;[A]は、K係数の1次多項式、A&lt;sup&gt;+&lt;/sup&gt;は空を許さない列を表す。

これらの例からも分かるように、モナドの関手部分は項生成オペレータ（term {forming, production} operator）とみなせる。そして、モナド乗法は、普遍的一般的な項簡約規則を与える。簡約規則は完全に構文的なルールで、個別具体的な項集合には依存しないで記述できるもの；その記述がモナド乗法に他ならない。なんらかの形式的（実体は伴わない）計算ルールを学ぶことはモナド乗法を知ることだ。

&lt;h5&gt;アイレンベルク／ムーア構成&lt;/h5&gt;

(T, μ, η)をC上のモナドとする。アイレンベルク／ムーア構成（Eilenberg-Moore）を考える。

最初に、関手Tに対してT代数の圏Alg&lt;sub&gt;T&lt;/sub&gt;を考える。このときTは、代数の類型（similarity type）、または指標を与える。実際、任意の自己関手を指標と定義する流儀もある（代数、余代数の一般論）。ここでは、Tは項生成関手だが、項の全体は指標によって決まるので、指標Σと関手Tは、T = T&lt;sub&gt;Σ&lt;/sub&gt; により同一視できる。

A = (a:T(X)→X) がT代数のとき、X = |A| と書いて、代数Aの台と呼ぶ。台は最初の圏Cの対象である。台の概念を使えば、代数の圏Alg&lt;sub&gt;T&lt;/sub&gt;からCに、忘却関手U = U&lt;sub&gt;T&lt;/sub&gt;を定めることができる。

A = (a:T(X)→X) に出てくるaは、項（式）に実際の値を対応させる写像のように解釈できるので、領域（みたいなナニカ）X上に「個別具体的な実際の計算機構＝形式的計算の意味」を与える。つまり、文字通りの“代数”である。

Xが何であれ、μ&lt;sub&gt;X&lt;/sub&gt;:TT(X)→T(X) はX上の形式的な計算を与える。一方で、a:T(X)→X は実質的・具体的な計算を与える。形式的な（構文論的な）計算と実質的（意味論的な）計算の互換性・協調性は次の可換図で示される。

&lt;pre&gt;
 TT(X) -(μ)→ T(X)  (形式的な計算)
  ｜            ｜
  ｜T(a)        ｜a
  ↓            ↓
  T(X)  -(a)→  X    (実質的な計算)
&lt;/pre&gt;

(T(a);a) : TT(X)→X はXとaで具体化された個別の実際計算を行う（入れ子の内側の実質計算を先にやる）。一方、μ;a は先に形式的な計算を済ませて、最後の最後で実際の計算を行う。call by valueとcall by name に似てる感じもする。

アイレンベルク／ムーア構成を済ませると、モナド(T, μ, η)から随伴対 (F&lt;sub&gt;T&lt;/sub&gt; -| U&lt;sub&gt;T&lt;/sub&gt;) ができる。モナド単位ηはそのまま随伴対（関手の双対）の単位となる。さらに、随伴余単位εが定義できる。余単位はev（evaluation）とも書かれるが、実際、ε:(F・U)(A)→A は、U(A) = |A| という台から構成された項に対する個別具体的な実際の計算を遂行することを意味する。

- モナド乗法 -- 形式的一般的な項簡約規則
- 余単位 -- 個別具体的な演算の遂行

&lt;h5&gt;クライスリ構成&lt;/h5&gt;

Kleisliを何とカタカナ表記すべきか？ わからーん！ が、「クライスリ」を採用することにした。

(T, μ, η)をC上のモナドとして、そのクライスリ圏をK&lt;sub&gt;T&lt;/sub&gt;とする。ホントはK&lt;sub&gt;(T, μ, η)&lt;/sub&gt;と書くべきだが少しさぼる。CをK&lt;sub&gt;T&lt;/sub&gt;に埋め込むのは簡単。いま、クライスリ射（クライスリ圏の射）f:X→T(Y) があったとき、fの拡張f&lt;sup&gt;#&lt;/sup&gt;:T(X)→T(Y)を対応させれば、(X |→ T(X), f |→ f&lt;sup&gt;#&lt;/sup&gt;) により、K&lt;sub&gt;T&lt;/sub&gt;→Cの関手が定義できる。埋め込みと拡張が随伴対なのだと思う（今、確認してないが）。

クライスリ射とその拡張の構文論的・計算論的意味だが、クライスリ射は、置換（substitution）の定義、またはマクロの定義となる。fがマクロ定義のとき、f&lt;sup&gt;#&lt;/sup&gt;は、そのマクロ定義を使ったマクロ展開（置換）を与える。

アイレンベルク／ムーア構成では、値の集合（とみなせる）台対象と、“ホントの演算”とみなせる項集合からの射が登場したが、クライスリ構成では、値もホントの演算も出てこないで、マクロの計算だけで済んでしまっている。

&lt;hr&gt;
確証はまったくないが、クライスリ圏のほうが指標の圏を与えて、アイレンベルク／ムーア圏のほうがモデルの圏を与えるような気がする。インスティチューションの論理文Senに関しても、項から論理式を生成するような論理式生成モナドが介在しているんじゃなからろうか。

*1236659846*[モナド][セミナー][具体例][M3]中学生のためのモナド

中学程度の素材でも例を作れるな。

要するに、

- 式の計算
- 値の計算（小学校）
- 式に値を代入
- 式に式を代入
- 式の計算と値の計算の関係（どのタイミングで代入してもよいこと）

とかはモナドだ。半環＝複合モナドも、中学で普通に扱うからベックの法則も射程内かも。

もっとも、総和のΣ、総積のΠとかがあったほうが一般の分配法則＝ベックのスワッパーの説明はやりやすい。高校から大学初年くらい？ 一次変換 x, y → z, w のようなんは高校か、これの計算はクライスリ圏内の計算だ。

*1236671715*[モナド][セミナー][具体例][M3]モナドの例いろいろ

とりあえず列挙する。

+ 列（リスト）モナド
+ バッグモナド
+ セットモナド＝非決定性モナド
+ 型なしレコードモナド（フィールド名は連接モノイド）
+ 付点モナド（1点の直和スタンピング）＝部分関数モナド
+ 一般の直和スタンピングモナド＝例外モナド
+ 大域更新モナド（自明モノイドのスタンピングモナド）
+ 直積スタンピングモナド＝内部状態モナド
+ カウンターモナド
+ ストリーム出力モナド
+ ストリーム入力モナド
+ 一次式モナド
+ 多項式モナド
+ 幾何学的凸閉包モナド（包含順序）
+ 有向グラフの推移的閉包モナド
+ ツリーモナド（末端ラベルが変化する）
+ 実数値の切り上げ
+ 下に有界な整数区間を拡げるモナド、射は単調写像（リフトモナド）
+ ばかみたいなモナド1＝恒等モナド
+ ばかみたいなモナド2＝消滅モナド（終対象に写す）

ベックの法則：

- 各種の直和スタンピングモナドの交換性
- 列モナドとバッグモナドの交換性＝分配法則

</body>
</day>
<day date="2009-03-11" title="">
<body>
*1236735372*[雑記]R言語

R言語を使い始めようと思っているんだけど、、、

なかなか、、、、

*1236735373*[高次圏論][モノイド圏]バートレットのダガー

θ::F⇒G が2-射で、F&lt;sup&gt;*&lt;/sup&gt;, G&lt;sup&gt;*&lt;/sup&gt;がそれぞれF, Gの右双対（F -| F&lt;sup&gt;*&lt;/sup&gt;、G -| G&lt;sup&gt;*&lt;/sup&gt;）のとき、θ&lt;sup&gt;†&lt;/sup&gt;と&lt;sup&gt;†&lt;/sup&gt;θ&lt;sub&gt;Ψ&lt;/sub&gt;を次のように定義する。

- θ&lt;sup&gt;†&lt;/sup&gt; = (η・G&lt;sup&gt;*&lt;/sup&gt;);(F&lt;sup&gt;*&lt;/sup&gt;・θ・G&lt;sup&gt;*&lt;/sup&gt;);(F&lt;sup&gt;*&lt;/sup&gt;・ε) : G&lt;sup&gt;*&lt;/sup&gt;→F&lt;sup&gt;*&lt;/sup&gt;

- &lt;sup&gt;†&lt;/sup&gt;θ&lt;sub&gt;Ψ&lt;/sub&gt; = (G&lt;sup&gt;*&lt;/sup&gt;・Ψ(η));(G&lt;sup&gt;*&lt;/sup&gt;・θ・F&lt;sup&gt;*&lt;/sup&gt;);(Ψ(ε)・F&lt;sup&gt;*&lt;/sup&gt;) : G&lt;sup&gt;*&lt;/sup&gt;→F&lt;sup&gt;*&lt;/sup&gt;

ようするに、ジグザグを利用して作った射に関する双対だが、バートレットはスター記号「θ&lt;sup&gt;*&lt;/sup&gt;」は使わない流儀。θ&lt;sup&gt;†&lt;/sup&gt;は、右双対構造から自然に決まる転置射。&lt;sup&gt;†&lt;/sup&gt;θ&lt;sub&gt;Ψ&lt;/sub&gt;は、フリッピングΨを使って作ったひっくり返し。Ψがあって初めて&lt;sup&gt;†&lt;/sup&gt;θが作れるので、Ψも添えている。次がバートレットの基本的な要請；左右平等等式（the even-handed equation）

- θ&lt;sup&gt;†&lt;/sup&gt; = &lt;sup&gt;†&lt;/sup&gt;θ&lt;sub&gt;Ψ&lt;/sub&gt;

軸的（pivotal）圏の軸反転（pivoting）とよく似ている。

*1236754280*[気付いた][多圏]ハロ多圏、ハロ複圏はモナドなのか？

モノイド圏Cから、適当な方法でハロ多圏やハロ複圏を作れる。どんな多圏／複圏を作るかは用途によりけり。この構成は、モノイド圏のレルムから（なんか適当な性質を持った）多圏／複圏のレルムへの関手になっている。さらに、多圏／複圏のレルム内では生成関手を繰り返し適用できそうだ。

多圏／複圏のレルムを&lt;b&gt;&lt;i&gt;D&lt;/i&gt;&lt;/b&gt;とすると、生成関手＝構成Pは、&lt;b&gt;&lt;i&gt;D&lt;/i&gt;&lt;/b&gt;上の自己関手となっており、どうもモナドのようだ。それとは別に、コア圏のレルム&lt;b&gt;&lt;i&gt;C&lt;/i&gt;&lt;/b&gt;は、&lt;b&gt;&lt;i&gt;D&lt;/i&gt;&lt;/b&gt;にハロ付きで埋め込める。具体的には、コンパクト閉圏のレルムを&lt;b&gt;KCC&lt;/b&gt;として、コンパクト閉構造を持つ多圏のレルム&lt;b&gt;KCPC&lt;/b&gt;とすると、生成関手F:&lt;b&gt;KCC&lt;/b&gt;→&lt;b&gt;KCPC&lt;/b&gt; があり、そのレトラクトR:&lt;b&gt;KCPC&lt;/b&gt;→&lt;b&gt;KCC&lt;/b&gt; もあり、さらに&lt;b&gt;KCPC&lt;/b&gt;上のPはFとほとんど同じように思える。

ハロ多圏／複圏を計算のための書き換え系とみなす観点が重要な気がする。

</body>
<comments>
<comment>
<username>uncorrelated</username>
<body>R言語、面白いですよ。&lt;br&gt;比較的違和感の無い制御構文と、変数にベクトルや行列があることによる統計演算の容易さ、ユーザーによる追加パッケージ作成機能がいい感じの相乗効果をもたらしていると思います。&lt;br&gt;とりあえずインストールをしてみて、行列演算やプロットなどをしてみると、便利さが分かってくると思います。</body>
<timestamp>1237329273</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>uncorrelatedさん、&lt;br&gt;ありがとうございます。&lt;br&gt;実はグラフを描きたいのですよ。&lt;br&gt;デスクトップのオフィスアプリのたぐいは嫌いで苦手なんで、容易にデータの視覚化ができるプログラミング言語がないものか？ と。で、R言語あたりかな、っと。&lt;br&gt;試してみます。</body>
<timestamp>1237338724</timestamp>
</comment>
</comments>
</day>
<day date="2009-03-12" title="">
<body>
*1236826591*[モナド][具体例][セミナー][M3]簡単で面白い例

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090310/1236671715&quot;&gt;モナドの例いろいろ&lt;/a&gt;を考えている。このなかで、

+ 切り上げ
+ 整数有限区間を拡げる
+ 有効単純グラフの推移的閉包
+ 平面内の図形の凸閉包

あたりが面白いかな。背景となる圏はそれぞれ：

+ 実数が対象、順序が射
+ 区間が対象、単調写像が射
+ 有効単純グラフが対象、辺を辺に写す頂点間写像が射
+ 図形が対象、包含順序が射

切り上げは割と面白い。区間の圏も、射を交差がない矢印の束（有向二部グラフ）で示せば、かなり直感的に説明可能かもしれない。


</body>
</day>
<day date="2009-03-13" title="">
<body>
*1236913281*[圏一般論]運算的圏論 フォッキンガ流

そう言えば、オランダのフォッキンガ（Fokkinga）達がcalculationalな圏論というのをやっていたな。

やや古い（90年代）が、

- Title: A Gentle Introduction to Category Theory - the calculational approach  - 
- Author: Maarten M. Fokkinga
- URL: http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.pdf

- Title: Category Theory for Program Construction by Calculation
- Author: Lambert Meertens
- URl: http://www.kestrel.edu/home/people/meertens/diverse/ct4pc.pdf

バックハウスなんかも運算的な流派だと思う。

で、A Gentle ... の付録で随伴を扱った所を少し読んでみたが、これは僕の性に合わない。記号の使い方とかは参考になるが、やっぱり何をやっているかが分からなくなる。

なかでもムッとしたのは、2つの自然変換に「;」という演算を入れているんだが、これはどうかな。「;」じゃなくて「#」を使って書いてみる。以下で使う記法は僕のDOTN記法。

- α:: J⇒F;;G : A→(B)→C
- β:: G::H⇒K : B→(C)→D

という状況。ここで「;;」は関手の普通の結合。

- α#β := (α;;H)|(F;;β)

ここでの「;;」は関手と自然変換の横結合で、結果は自然変換。「|」は自然変換の縦結合。なんつうか、すこしズラした結合で、多圏とかだと自然かもしれないが。やりすぎな気がする。

ただし、概念とか用語法とかでは使えそうなのもあるから、後でたぶんまた書く。

*1236914724*[圏一般論]随伴のメイトシップとアジャンゲート

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20070303/1172888964&quot;&gt;随伴相方＝アジョイントメイト&lt;/a&gt;は、ホムセットが1：1に対応するから、対応する射のペアを指している。ホムセットの同型をフォッキンガはadjungateと呼んでいる。adjointはadjunction（アジャンクション）とも言うので、それと、共役＝コンジュゲートのgateの部分をくっつけたのだろう。アジャンゲート。

&lt;pre&gt;
   V(F(X),  W)
  --------------[右アジャンゲート]
   S(X,   U(W)


   S(X,   U(W)
  --------------[左アジャンゲート]
   V(F(X),  W)
&lt;/pre&gt;

フォッキンガは、2つのアジャンゲート（互いに逆）を特殊な記号で表している。ゲーデル符号化を太くしたような記号。2つのアジャンゲートがメイトシップ（射のあいだのメイト関係）を定める。

*1236923203*[圏一般論]色付きオペラッド計算

僕は、ひょっとして無意識に色付きオペラッド計算をしてるのかもしれないな。モノイド圏のハロ多圏を使っているが、多圏じゃなくて複圏にしたら、色付きオペラッド計算でしょ。オペラッドに対称群やブレイド群が作用している状況だと、対称モノイド圏やブレイド付きモノイド圏。

ラムダ抽象はオペラッドに対するマニュピュレーションだとするとうまく説明できる。ただし、[B←A] と [A→B] という指数のハーフツイストが必要になるけど。ハーフツイスト同型は、[-←-]と[-→-]を結ぶ自然変換だから、指数を反変共変双関手として導入しておかないとまずいのか。

*1236937672*[プログラム意味論][圏一般論]半圏とプロセスとカロウビ展開圏

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20060828/1156723970&quot;&gt;「はじめての圏論 第6歩：有限変換キューと半圏」&lt;/a&gt; -- ここに書いてある半圏、擬似恒等、フルバッファー付き射とかの議論は、半圏のカロウビ展開圏の話につながる気がする。

</body>
</day>
<day date="2009-03-14" title="">
<body>
*1237007085*[紛失物]なぜなくすのか、対策と気分

プリンタで印刷した2枚の紙をなくした。印刷し直せばいいのだが、なくした状況が不可解。どうしてもなくなるとは思えない状況。なのに、なくなる。

要するに僕は、しばしば意識が飛んでしまい、そのあいだの行動が意識で制御されてないのでサッパリ記憶にも残らないってことだろう（アブネー）。

注意して改善できる部分も多少はあるだろうが、「意識が飛ぶ」現象がなくなるとは思えない。本質的にはもはや直らないだろう。

どんなときにどんなふうに意識が飛んで、そのときにどんなパターンで紛失その他の困った行動をするかを調べることで、多少は事後対策が可能そうだ。

それと、毎回悔やむのも精神衛生上よくないので、「意識が飛ぶ」現象のメリットのほうにも目をやるべきだろうな。非常に好意的な見方をすれば、どこにいても数分間の集中が可能なのだ。ただし、この集中の内容と時間をまったく制御できないのが困ったことだけどね。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090309/1236554867&quot;&gt;ジョーダン抜きに、絵暗算はやめとこう。&lt;/a&gt;

*1237007086*[紛失物]紙袋、ビニール袋

- http://d.hatena.ne.jp/m-hiyama-memo/20090223/1235346831
- http://d.hatena.ne.jp/m-hiyama-memo/20090303/1236061217

これは紙袋に入っていた。紙袋とかビニール袋は鬼門。

*1237008893*[プログラム意味論]ステージ付き遷移系

状態空間Sが、インデックス集合Iでインデックスされた部分集合族{S&lt;sub&gt;i&lt;/sub&gt;}で覆われているような状況を考える。S&lt;sub&gt;i&lt;/sub&gt;をステージと呼び、Iはステージ記号の集合と考える。被覆は分割でなくてもよい。

この用語は以前から使っていたもので、実務上必要だった。が、どうも理論的にも必要そうだ。状態遷移系上のアクションラベルの集合（アルファベット）を考えると、ステージがないと、どうもまずい。

ステージ記号の集合I上で、I×Iでインデックスされた記号集合の系を考える。i, j∈I×Iに対して、Σ(i, j)を考えるわけ。(x, a, x')が合法な遷移である条件として

- x∈X&lt;sub&gt;i&lt;/sub&gt;、x'∈X&lt;sub&gt;j&lt;/sub&gt;、a∈Σ(i, j)

を要求する。X&lt;sub&gt;i&lt;/sub&gt;達をまた状態空間と考えれば、Σ(i, i)とX&lt;sub&gt;i&lt;/sub&gt;で状態遷移系が構成できる。x≠j のときは、別な空間にジャンプする遷移。

記号0が開始状態、記号1が終了状態を表すとして、Σ(i, 1)とΓ(0, j) にだけ連接を認めてΣとΓの合成アルファベットを定義できる。とりあえず、ステージ記号の集合として {0, *, 1}だけを取り上げてもいい。それぞれ、開始状態、終了状態、その他の状態となる。

非決定性の扱いが難しそうだが、大きな状態空間の分割、集約（状態集合を点とみなす）、合成などは実務的にも重要だ。

素朴な定式化でうまくいかない事情に対して、次のことを試してみる価値がある。

+ 無音記号を考える
+ ワープ辺（入力なしで勝手に遷移する遷移辺）
+ アルファベットのコスパンの圏
+ アルファベットの写像に伴う遷移系の引き戻しと前送り

</body>
</day>
<day date="2009-03-15" title="">
<body>
*1237020466*[セミナー]「ラムダ計算、論理、圏」の予習・復習のために

※日付はダミー：実際の執筆・公開日は2009-03-14

最初にホワイトボードの写真があって、その直後に説明があります。（本編の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090225/1235521827&quot;&gt;「紙芝居：ラムダ抽象」&lt;/a&gt;とは、写真／説明の順序が逆ですね ^^;）

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc01_function.jpg&quot; &gt;

関数は昔「函数」と書いてたのよ。「函」は函館のハコだから「箱」の意味。で、箱の絵を描くわけだが、毎回リアルな箱やパイプを描くのは大変だから、四角（ボックス）と線（ワイヤー）で描くよ。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc02_pict-to-biglambda.jpg&quot; &gt;

四角も面倒ならオダンゴ（丸）でもいい。このセミナー内では、関数の向きは上から下だとする。関数をテキストで表現するときは、&amp;lt;x | f(x) &gt; のような書き方をする。入力変数（引数変数）がxで、f(x)のところには、fを表現する式を書いてもいい。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc03_biglambda-2args.jpg&quot; &gt;

例えばこれは二変数（二引数）の関数。fは、2つの変数xとyからf(x, y)を算出するメカニズムを持つから、そのメカニズムを 式 2*x + y*3 とかで表す。 

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc04_currying-pict-def.jpg&quot; &gt;

さて、関数のカリー化＝ラムダ抽象だが、図では右の入力ワイヤーを曲げることになる。カリー化をしたfをf^と書く。2回カリー化したらf^^だね。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc05_biglambda-currying.jpg&quot; &gt;

fが一変数関数 f(x) = x&lt;sup&gt;2&lt;/sup&gt; + x + 1 のとき、f^の計算はこうなる。大きなラムダ括弧（'&amp;lt;'と'&gt;'）の内部にある式に、小さなラムダ'λ'がかかることになる。

fが二変数関数 f(x, y) = x&lt;sup&gt;2&lt;/sup&gt; + y&lt;sup&gt;2&lt;/sup&gt; のときは、ホワイトボードの下半分のようになる。右側の変数yだけがλで束縛される。xはそのままだよ。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc06_currying-exer.jpg&quot; &gt;

ここらで練習問題だ。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc07_currying-example.jpg&quot; &gt;

g(a, b, x) = a*x + b だけやってみよう。g^, g^^, g^^^ はこんな感じに計算できる。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc08_multicurrying-pictorial.jpg&quot; &gt;

gからg^、g^からg^^を作る操作（それがカリー化＝ラムダ抽象）を絵に描くとこんな。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc09_lambda-basic-eq.jpg&quot; &gt;

ラムダ計算で一番大事な法則がこの等式だ。

fからカリー化されたf^を、実行エンジン（evaluator）Eに渡してあげれば、もとの関数fを再現できる。f^は、fの右ワイヤーを曲げたものだったけど、その状況は赤で描いてある。

&lt;hr&gt;
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/llc10_curried_plus.jpg&quot; &gt;

この図は、f(x, y) = x + y のケースで、f^とf^^を描いたもの。実行エンジンは、曲がったワイヤーが集まる場所として描いている。バエズは、ワイヤーが集まる場所＝実行エンジンの部分を“evalバブル”と呼んでいる。そのココロはベータ変換によりハジケテ消えてしまうから。f^を囲む外側のマルもバブル（ラムダバブル）で、やっぱりベータ変換によりハジケテ消える。

下の絵は、f^ と E の簡略記法。f^なら二重丸、f^^なら三重マル。ワイヤーも本数分だけ束ねた絵にする。描くのが少し楽になるよ。

&lt;h5&gt;その他の参考記事&lt;/h5&gt;

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090225/1235521827&quot;&gt;紙芝居：ラムダ抽象&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090127/1233039245&quot;&gt;簡略オダンゴ図&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090221/1235192629&quot;&gt;セミナー非参加者にもわかるリアルワールド向けラムダ計算&lt;/a&gt;


</body>
</day>
<day date="2009-03-16" title="">
<body>
*1237158608*[後で消す][子供]今日は晩ご飯作る。
</body>
</day>
<day date="2009-03-17" title="">
<body>
*1237284671*[セミナー]図の元ネタ

ターンスタイル

- http://en.wikipedia.org/wiki/Turnstile
- http://en.wikipedia.org/wiki/File:Turnstile.alewife.agr.jpg

ギローの図とウィラートンの図

- http://arxiv.org/abs/math/0612089 &lt;br&gt;http://arxiv.org/PS_cache/math/pdf/0612/0612089v1.pdf P.30
- http://arxiv.org/abs/0807.0658 &lt;br&gt;http://arxiv.org/PS_cache/arxiv/pdf/0807/0807.0658v1.pdf P.23

*1237276369*[プログラム意味論]プログラム実行の計算

+ A;B 直列（逐次、順次）実行； Aを実行し、次にBを実行
+ A+B 選択的実行； AまたはBのどちらか一方だけを実行
+ A&amp;amp;B 並列実行； AとBを同時に両方とも実行
+ A|c|B 同期通信； AとBを同期通信チャネルcでつないで並列実行

それと、繰り返しを表すエルゴット・トレースがある。

状態空間に関しては：

+ A;B 境界付き空間の貼り合わせ
+ A+B 直和
+ A&amp;amp;B 直積
+ A|c|B 直積

エルゴット・トレースは、状態空間の一部を同一視する（自分自身を貼り合わせる）操作になる。

なお、インターフェースの計算は、実行とは一応独立に議論できる。

*1237285079*[プログラム意味論][DFD][気付いた][マンダラ]境界付きアルファベット

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%de%a5%f3%a5%c0%a5%e9&quot;&gt;マンダラ仮説&lt;/a&gt;の定式化であるマンダラな圏を考えている。で、全体的なことは後で書くが、とりあえずアルファベットの概念。妥協の産物ではあるが、使い勝手は悪くない。

A, Bなどは、状態空間の境界、つまり始状態の集合＝始境界（initial boundary）と終状態の集合＝終境界（final boundary）を表すと思う。実際には、境界の連結成分の集合と考えたほうがいいが、今は気にしない。記号の集合Σに、AとBの要素でインデックスされた部分集合族がある。

+ Σ&lt;sup&gt;-&lt;/sup&gt;[a] a∈A
+ Σ&lt;sup&gt;+&lt;/sup&gt;[b] b∈B

Σ&lt;sup&gt;-&lt;/sup&gt;:A→Pow(Σ)、Σ&lt;sup&gt;-&lt;/sup&gt;:B→Pow(Σ)。Σ&lt;sup&gt;-&lt;/sup&gt;[a]に属する記号は、aからの開始記号（starting symbol）、Σ&lt;sup&gt;+&lt;/sup&gt;[b]に属する記号は、bへの終了記号（terminating symbol）と呼ぶ。そして、

- Σ[a, b] = (Σ&lt;sup&gt;-&lt;/sup&gt;[a])∩(Σ&lt;sup&gt;+&lt;/sup&gt;[b])

とする。s∈Σ[a, b]のとき、記号sはaからbに到達可能（可達）と呼ぶ。

(Σ, A, B, Σ&lt;sup&gt;-&lt;/sup&gt;, Σ&lt;sup&gt;+&lt;/sup&gt;)が、上の状況の時、Σ:A→B と書く。
Σ=(Σ, A, B, Σ&lt;sup&gt;-&lt;/sup&gt;, Σ&lt;sup&gt;+&lt;/sup&gt;)は、AからBへの境界付きアルファベットと呼ぶ。この記法から連想されるように、境界付きアルファベットΣはある種の射だと考える。ただし、すぐさま圏を構成する必要はない。

&lt;h5&gt;直和、直積、結合&lt;/h5&gt;

Σ:A→B、Γ:C→D として、Σ+Γ:A+C→B+D と Σ×Γ:A×C→B×D は自明に定義できる。Σ:A→B、Γ:B→Cのとき、結合Σ;Γが問題になる。

b∈Bに対して、s∈Σ&lt;sup&gt;+&lt;/sup&gt;[b]であり、かつ t∈Γ&lt;sup&gt;-&lt;/sup&gt;[b] のとけだけ連接stを作る。そうやって作られた連接の全体をΣ#Γとする。

Δ = (Δ、A, C, Δ&lt;sup&gt;-&lt;/sup&gt;, Δ&lt;sup&gt;+&lt;/sup&gt;)を次のように定義する。

+ 集合として、Δ=Σ+Γ+Σ#Γ
+ a∈Aに対して、s∈Σなら s∈Δ&lt;sup&gt;-&lt;/sup&gt;[a] ⇔ s∈Σ&lt;sup&gt;-&lt;/sup&gt;[a]
+ a∈Aに対して、t∈Γなら t∈Δ&lt;sup&gt;-&lt;/sup&gt;[a] ということはない。
+ a∈Aに対して、st∈Σ#Γなら st∈Δ&lt;sup&gt;-&lt;/sup&gt;[a] ⇔ s∈Σ&lt;sup&gt;-&lt;/sup&gt;[a]
+ c∈Cに対して、s∈Σなら s∈Δ&lt;sup&gt;+&lt;/sup&gt;[c] ということはない。
+ c∈Cに対して、t∈Γなら t∈Δ&lt;sup&gt;+&lt;/sup&gt;[c] ⇔ t∈Γ&lt;sup&gt;+&lt;/sup&gt;[c]
+ c∈Cに対して、st∈Σ#Γなら st∈Δ&lt;sup&gt;+&lt;/sup&gt;[c] ⇔ t∈Γ&lt;sup&gt;+&lt;/sup&gt;[c]

結合演算「;」は、このままでは圏の結合にはならないが、とりあえずはいいとする。

&lt;h5&gt;境界付きアルファベットの準同型&lt;/h5&gt;

Σ:A→BとΓ:C→D があるとき、f:A→C、g:B→D、φ:Σ→Γ は集合の写像で次を満たすとする。

+ s∈Σ&lt;sup&gt;-&lt;/sup&gt;[a] ならば φ(s)∈Σ&lt;sup&gt;-&lt;/sup&gt;[f(a)]
+ s∈Σ&lt;sup&gt;+&lt;/sup&gt;[b] ならば φ(s)∈Σ&lt;sup&gt;+&lt;/sup&gt;[g(b)]

このとき、(f, g, φ)を境界付きアルファベットの準同型とする。

準同型は通常の写像概念なので、その全体は圏をなす。実は二重圏を作りたい。


</body>
</day>
<day date="2009-03-18" title="">
<body>
*1237335246*[高次圏論][リンク]高次圏とホモトピーと代数

プレゼンのスライド

- Title: When pseudo comes for free
- Author: Richard Garner
- URL: http://www.dpmms.cam.ac.uk/~rhgg2/Talks/PSSL85.pdf
- Pages: 32 スライド

*1237341959*[セミナー][論理]参考：選言と否定

2009-03-19セミナーでは扱わないけど（いや、触れるか？）。

&lt;pre&gt;
        A    B
       ---  ---
        .   .
        .   .
 A∨B   C   C

      ∥
      ↓

           #1  #2
          ---  ---
           A    B
          ---  ---
          .   .
          .   .
   A∨B   C   C
  -----------------[∨消去 #1, #2]
         C
&lt;/pre&gt;

∨消去は⊃の導入と似た感じになる。∨の導入は簡単で、∧の消去と双対。

否定に関しては論理定数⊥が必要で：

&lt;pre&gt;
    A
   ---
    .
    .
   ⊥
 
   ∥
   ↓

   #1
  ----
    A
   ---
    .
    .
   ⊥
  ----[￢導入 #1]
  ￢A
&lt;/pre&gt;

￢の消去は排中律。

</body>
</day>
<day date="2009-03-23" title="">
<body>
*1237767052*[セミナー][用語法]基礎的

foundational, fundamental


</body>
</day>
<day date="2009-03-24" title="">
<body>
*1237880365*[セミナー][論理]マクロ規則（derived rules）とか定理とか

規則 MP' : A, A⊃B |- B
&lt;pre&gt;
  A   A⊃B
 ----------[Exch]
  A⊃B  A
 ---------[MP]
     B
&lt;/pre&gt;

規則 ∧の交換 : A∧B |- B∧A
&lt;pre&gt;
       A∧B
 -------------------[Dup]
 A∧B        A∧B
 ----[Sel-2] ----[Sel-1]
  B           A
 ---------------[And]
      B∧A
&lt;/pre&gt;

規則 Cut : A⊃B, B⊃C |- A⊃C
&lt;pre&gt;
       #1
       ---
  A⊃B  A
 ---------[MP]
      B       B⊃C
    ---------------[MP']
           C
        -------[DT #1]
         A⊃C
&lt;/pre&gt;

規則 Proj-1 : A, B |- A
&lt;pre&gt;
  A   B
 -------[And]
   A∧B
  ------[Sel-1]
    A
&lt;/pre&gt;

規則 Proj-2 : A, B |- B （Proj-1に同じ）

規則 ∧-Dup : A |- A∧A
&lt;pre&gt;
     A
  --------[Dup]
   A    A
  --------[And]
    A∧A
&lt;/pre&gt;

公式 A⊃(B⊃A)
&lt;pre&gt;
 #2    #1
 ---  ---
  A    B
 ---------[Proj-1]
    A
 -------[DT #1]
  B⊃A
 ----------[DT #2]
 A⊃(B⊃A)
&lt;/pre&gt;

規則 (A∧A)⊃B |- A⊃B
&lt;pre&gt;
             #1
             ---
              A
             ----[∧-Dup]
  (A∧A)⊃B  A∧A
  ----------------[MP]
         B
       ------[DT #1]
        A⊃B
&lt;/pre&gt;

規則 (A⊃B)⊃C |- (A∧B)⊃C
&lt;pre&gt;
                #2
               ----
     #1        A∧B
    ----      -----[Sel-2]
      A         B
    --------------[Proj-2]  
          B
       ------[DT #1]
        A⊃B            (A⊃B)⊃C
     ----------------------------[MP']
             C
        ---------[DT #2]
        (A∧B)⊃C
&lt;/pre&gt;
  
公式 [A⊃(B⊃C)]⊃[(A⊃B)⊃(A⊃C)] （ A⊃(B⊃C) |- (A⊃B)⊃(A⊃C) で示す。）
&lt;pre&gt;
                          #1
                          ---
       #2     A⊃(B⊃C)    A
     ------  -----------------[MP]
       A⊃B        B⊃C
      -------------------[Cut]
                 A⊃C
               ------------[DT #1]
                 A⊃(A⊃C)
 ---------[Th]  ----------[a derived rule]
 A⊃(A∧A)      (A∧A)⊃C
 -------------------------[Cut]
        A⊃C
    ---------------[DT #2]
    (A⊃B)⊃(A⊃C)
&lt;/pre&gt;

↑いくらなんでも長すぎないか、これ？


</body>
</day>
<day date="2009-03-25" title="">
<body>
*1237955837*[プログラム意味論][DFD][気付いた]境界付きシステム

僕の動機・要求からは境界付きシステムの定式化は必須で、これは&lt;em&gt;離散組合せ的コボルディズムのようなナニカ&lt;/em&gt;をベースにする。離散集合には幾何的構造が前もっては存在しないので苦労する。次元や連結成分の概念が使えない。

で、境界となる状態空間の部分集合に前もって同値関係を入れておくことにした。つまり、コボルディズム圏の対象は同値関係付きの集合とする。コボルディズム圏の射（境界付きの図形）には、前もっての同値関係は考えない。以下、同値関係付きの集合をE集合と呼ぶ。

境界であるE集合の同値類は連結成分の代わりに使う。境界は連結成分（同値類）の直和表示ができる。E集合の直和と直積もE集合だから、直和／直積構成しても直和表示の可能性は保存される。（課題：E集合の圏を調べる。）

ここでは、連結成分＝同値類が有限個であるE集合だけを考える（この制限ははずせるが）。全状態空間Xの始境界をA、終境界をBとする。AとBの直和分解を A = A&lt;sub&gt;1&lt;/sub&gt; + ... + A&lt;sub&gt;n&lt;/sub&gt;、B = B&lt;sub&gt;1&lt;/sub&gt; + ... + A&lt;sub&gt;m&lt;/sub&gt; とする。この境界付き状態空間（コボルディズム圏の射）に対して適合するアルファベットを次のように定義する。

Σを記号の集合として、Σには、A&lt;sub&gt;1&lt;/sub&gt; + ... + A&lt;sub&gt;n&lt;/sub&gt;, B&lt;sub&gt;1&lt;/sub&gt; + ... + A&lt;sub&gt;m&lt;/sub&gt; でインデックスされた (n+m)個の部分集合が指定されている。それらを、

+ Σ&lt;sup&gt;-&lt;/sup&gt;[A&lt;sub&gt;i&lt;/sub&gt;] （i = 1, ..., n）
+ Σ&lt;sup&gt;+&lt;/sup&gt;[B&lt;sub&gt;j&lt;/sub&gt;] （j = 1, ..., m）

とする。プラスマイナスは極性で、なにか区別できる2つの記号なら何でもよい。これらの部分集合は空でもよいし、特に制限もない。ΣとΣ&lt;sup&gt;-&lt;/sup&gt;[A&lt;sub&gt;i&lt;/sub&gt;], Σ&lt;sup&gt;+&lt;/sup&gt;[B&lt;sub&gt;j&lt;/sub&gt;] （j = 1, ..., m）を組み合わせた構造が境界付きアルファベットだが、単にΣで境界付きアルファベットを表す。

連結成分に分割された始境界／終境界を持った状態空間、その境界と適合した境界付きアルファベット（そう呼ぶことにする）があると、境界付きシステムを定義できる。境界付きシステムは、Σをラベル集合とするラベル付き遷移系で、境界に関するホーア流の制約を満たすものだ。（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090314/1237008893&quot;&gt;「ステージ付き遷移系」&lt;/a&gt;も参照。）

+ αは (x, a, x')∈X×Σ×X の集まり。αに所属する3-組は遷移とか変換と呼ばれる。
+ x∈A&lt;sub&gt;i&lt;/sub&gt; で (x, a, x')∈α のとき、a∈Σ&lt;sup&gt;-&lt;/sup&gt;[A&lt;sub&gt;i&lt;/sub&gt;]
+ x'∈B&lt;sub&gt;j&lt;/sub&gt; で (x, a, x')∈α のとき、a∈Σ&lt;sup&gt;+&lt;/sup&gt;[B&lt;sub&gt;j&lt;/sub&gt;]

境界付きシステムは(A, B, X, Σ, α)という5つ組で表現される。境界付きシステムに関して、直和、直積、境界を介した結合（連結、貼り合わせ）を定義できる。このとき、境界対[A, B]に対しても、直和、直積、結合（[A, B];[B, C] = [A, C]）が定義できる。境界付きアルファベットに関しても、直和、直積、結合（連接）が定義できる。

そして、決定的に重要なことは、境界付きシステム α = (A+C, B+C, X, Σ, α)に対してトレース Trα が定義できることである。このトレースは関数や部分関数からエルゴットオートマトンを作る定義&lt;em&gt;そのもの&lt;/em&gt;なので、エルゴット・トレースと呼ぶことにする。

Trα = (A, B, X, Σ', α') となる。全状態空間は変わらない。境界はAとBに減少し、新しいアルファベットΣ'は、Σのクリーネスター（の制限版）となる。ΣからΣ'を求めることは行列計算で出来る。ここは、形式言語理論とオートマトンとの古典的対応を再現している。

&lt;h5&gt;入出力&lt;/h5&gt;

境界概念は時間的境界、つまり始まりと終わりを定式化する。トレースは時間的な繰り返しの定式化だ。射はある一定時間で遂行される処理過程、変化の軌跡を表現する。

入出力やコミュニケーションの概念を入れるには、入出力用のアルファベットを別に準備する。いきなりコンパクト閉圏を作るには、アルファベットの極性（符号、荷電）を考える。荷電付き境界付きアルファベットから、境界付きシステムのアルファベットへの任意の写像がinoutマップとなる。これはセリンガーのin(x)とout(y)を一緒にした概念。アルファベットΔの正部分をΔ&lt;sup&gt;+&lt;/sup&gt;、負部分をΔ&lt;sup&gt;-&lt;/sup&gt;として、Δ&lt;sup&gt;+&lt;/sup&gt;上でoutが定義され、Δ&lt;sup&gt;-&lt;/sup&gt;上でinが定義される。

荷電（極性）は反転できるので、反転を使って双対構造を定義できる。コンパクト閉圏になるはずだ。コンパクト閉構造から定義されるトレース（圏論的トレース）は、時間方向のエルゴットトレースとはまったく別物。まだミステリアス。

練習問題：Mealy machine や Moore machine のエミュレーション


</body>
</day>
<day date="2009-03-26" title="">
<body>
*1238027549*[用語法][モノイド圏]バートレット・フリップ

ブルース・バートレット（Bruce Bartlett）の左右平等構造（even-handed structure）の典型例は、対称またはブレイディング（Ｘ 横向き）による入れ替えと単位／余単位（⊂、⊃）のあいだに次の関係がある状況だろう。

- ⊂Ｘ ⇔ ⊂
- Ｘ⊃  ⇔ ⊃

これはフリップと呼ぶのが一番ふさわしそうだ。

</body>
</day>
<day date="2009-03-27" title="">
<body>
*1238148309*[セミナー][論理][モノイド圏][多圏]多圏からの厳密結合圏

もうセミナーネタとは言いがたいが：

モノイド閉圏Cから作ったハロ多圏のなかでは、いくつかの結合が考えられる。

+ 右マッチ結合：多対象の列を右から順に比較して一致する部分を結合する。
+ 左マッチ結合：多対象の列を左から順に比較して一致する部分を結合する。
+ ズラシマッチ結合：多対象の列を適当にズラして比較して一致する部分（最大でなくてもいい）を結合する。
+ 厳密マッチ結合：多対象が完全に一致するときだけ結合

最後の厳密マッチ結合だけを許すと、結局は圏になる。こうやって作った圏はもとの圏（コア圏）とほとんど同じだが、微妙に違うところがむしろ面白い。絵算の観点からは、厳密マッチ結合を考えたハロ多圏こそが舞台だと考えられる。

「ハロ多圏＋厳密マッチ結合」を内側ハロと呼ぶことにする。ハロはハロだが、あまり外側に広がってない、ハロのなかでも芯のようなところ。内側ハロの射は大きなラムダ式（以下Λ式）に多値を許せば表現できる。ただし、多値で問題になるのはラムダ抽象のかかリ具合が不明になること。

例えば、&amp;lt;x, y|f(x, y), g(x, y)&gt; に対して、右ラムダ抽象Λ&amp;lt;x, y|f(x, y), g(x, y)&gt; は何を意味するかよくわからない。これは、

- Λ&amp;lt;x, y|f(x, y), g(x, y)&gt; = &amp;lt;x|λy.f(x, y), λy.g(x, y)&gt; 

とλを全体に分配するといいようだ。

論理で言うと、並行証明図になる。A⊃B, A⊃C |- A⊃(B∧C) というのがポイントになる。他にも興味深い等式とか、いろいろ出せる。絵算的にけっこう面白い。


</body>
</day>
<day date="2009-03-31" title="">
<body>
*1238472069*[リンク]面白い！

- http://golem.ph.utexas.edu/category/2009/03/firstorder_logical_duality.html
- http://folk.uio.no/jonf/HenrikFhrssell_LogicalDuality.pdf

*1238474706*[Erlang][プログラム意味論]ミーリー／メイヤー・モデル

僕はメイヤー先生のファン
- http://d.hatena.ne.jp/m-hiyama/20060403/1144025475
- http://d.hatena.ne.jp/m-hiyama/20060313/1142209318

それはいいとして、メイヤー流のクエリー／コマンド・スタイルでプログラムを書いても何も不便はない。クエリーでもコマンドでもない関数／メソッドが必要なら便利関数として書けばいいだけ。

それで、Erlangに対してメイヤー方式を定義したい。

&lt;h5&gt;ミーリー機械&lt;/h5&gt;

モデルとしてミーリー機械（Mealy machine）を採用する。ミーリー機械の状態遷移を

- (s, a) -&gt; (s', b)

の形で書く。aが入力、s, s'が状態、bが出力。遷移は S×A×S×B = A×(S×S)×B = S×(A×B)×S の部分集合となる。

Vを値（と呼ばれる何か）の集合として、{val(x) | x∈V} の形の記号を出力Bに入れておく。また、εを無音記号とする。すると：

- クエリーは (s, q) -&gt; (s, val(x)) の形の遷移
- コマンドは (s, c) -&gt; (s', ε) の形の遷移

ということになる。メイヤーによれば、たいていの便利関数は (s, c) -&gt; (s', ε); (s', q) -&gt; (s', val(x)) として実現できる。せいぜい、cの前後の状態 s, s' から計算できる程度に限定すべき。

Erlangのメッセージ生成関数は、(s, g) -&gt; (s', m) の形になる。これもコマンドとみなしてよいが、出力が無音ではないので、ジェネレータと呼ぶことにする。

&lt;h5&gt;ミーリー／メイヤー・モデル&lt;/h5&gt;

ミーリー機械（初期状態集合を持つ）Mをモデルとする。
Mのクエリーは、遷移ではなくて、状態空間上の関数だとする。コマンドは (s, c) -&gt; (s', ε) の形の遷移、ジェネレータは (s, c) -&gt; (s', m) の形の遷移だとする。

クエリー、コマンド、ジェネレータを関数で表現すると：

+ クエリー：引数に状態を渡す、戻り値は値（value）
+ コマンド：引数に状態を渡す、戻り値は状態（state）
+ ジェネレータ：引数に状態を渡す、戻り値は状態（state）、副作用が生成メッセージ列。

クエリーとコマンドは単なる関数で、何も細工する必要がない。ジェネレータでは、?send(To, Term) というマクロを必ず使うことにして、sendマクロが例えばプロセス辞書に書きこむ。戻り値である状態とメッセージ列を組にして返すラップを作ればよい。

関数が例外を出したときは、それを記録するので、次のようなデータを持つことになる。

+ Value = {value, term()} | no_value
+ State = term()
+ Message = [{To, term()}]
+ Exception = {Class, term(), Stacktrace} | no_exception

http://erlang.g.hatena.ne.jp/m-hiyama/20090331/1238463293 も参照。

*1238475398*[モナド][具体例][セミナー]イデアル完備化

順序集合のイデアル完備化はモナド。つうか、完備化ってたいていベキ等モナド。


</body>
<comments>
<comment>
<username>msakai</username>
<body>順序集合のイデアル完備化はベキ等ではなかったはずです。&lt;br&gt;完備化という名前なのに……&lt;br&gt;&lt;br&gt;例:&lt;br&gt;N = {0&lt;1&lt;…}&lt;br&gt;Idl(N) = {0&lt;1&lt;…&lt;∞}&lt;br&gt;Idl(Idl(N)) = {0&lt;1&lt;…&lt;∞&#39;&lt;∞}&lt;br&gt;&lt;br&gt;http://www.tom.sfc.keio.ac.jp/~sakai/d/?date=20070506#p02</body>
<timestamp>1238543176</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&gt; 順序集合のイデアル完備化はベキ等ではなかったはずです。&lt;br&gt;ああーー、確かに。名前から早とちりしました。&lt;br&gt;うーむ、べき等ではない「完備化」もあるのか。&lt;br&gt;ご指摘、ありがとうございます。</body>
<timestamp>1238546064</timestamp>
</comment>
</comments>
</day>
<day date="2009-04-01" title="">
<body>
*1238546665*[Erlang]メッセージのジャンクション

+ 2本のパイプをマージするようなヤツ
+ 入ってきたのをテケトー（予測不可能）に振り分けるヤツ
+ 2本のパイプからタプルを作る、zipのようなヤツ
+ コピーするヤツ

列αとβのインターリーブをα§β と書くと：

+ α, β → γ  γ∈α§β
+ α → β, γ  α∈β§γ
+ α, β → γ  γ = zip(α, β) 長すぎる分は詰まる
+ α → α, α

インターリーブは難しい。

</body>
</day>
<day date="2009-04-02" title="">
<body>
*1238662786*[論理][圏一般論][リンク]コホモロジーとかGoIとか

バエズのセミナー、以下のURLからいろいろとリンクされている。

- http://math.ucr.edu/home/baez/qg-spring2007/qg-spring2007.html

以下のGoI関係も面白そう。

- Title: Towards a Typed Geometry of Interaction
- Authors: Esfandiar Haghverdi1 and Philip J. Scott2
- URL: http://www.site.uottawa.ca/~phil/papers/csl05-104.pdf
- Pages: 16

- Title: Geometry of Recursion  (January 15, 2007)
- Author: Esfandiar Haghverdi
- URL: http://www.cse.unsw.edu.au/~rvg/ICALP/submission_6.pdf
- Pages: 15

- Title: Proofs as Polynomials
- Author: Esfandiar Haghverdi1, Philip J. Scott
- URL: https://ocics.site.uottawa.ca/~phil/papers/MFPS-ENTCS4.pdf
- Pages: 20

だが、気力／余裕がない。


</body>
</day>
<day date="2009-04-04" title="">
<body>
*1238816802*[からみ系][物理っぽい]カウフマンのテレポーテーション位相

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090116/1232081309&quot;&gt;ほったらかしてあったヤツ&lt;/a&gt;だね。

普通の平面を考える。横軸がx軸、縦軸がt軸で、時間は&lt;em&gt;下から上に&lt;/em&gt;流れるとする。ある時点 t = t&lt;sub&gt;0&lt;/sub&gt; で切ると、その瞬間の空間はx軸と同じ直線になる。ある時点で空間（1次元x軸）内に存在する粒子の数をNとする。粒子の内部状態の空間をVとする。Vは複素ベクトル空間（ヒルベルト空間）。

t = t&lt;sub&gt;0&lt;/sub&gt;での粒子数N&lt;sub&gt;0&lt;/sub&gt;、t = t&lt;sub&gt;1&lt;/sub&gt;での粒子数N&lt;sub&gt;1&lt;/sub&gt;として、時刻がt&lt;sub&gt;0&lt;/sub&gt;からt&lt;sub&gt;1&lt;/sub&gt;に発展するとき、t&lt;sub&gt;0&lt;/sub&gt;→t&lt;sub&gt;1&lt;/sub&gt;の変化を、ベクトル空間のテンソルべきの間の線形写像 V&lt;sup&gt;(N0)&lt;/sup&gt;→V&lt;sup&gt;(N1)&lt;/sup&gt; で記述するが、この変換はユニタリだとする。（よくわからんが、物理的にそういう仮定なんだそうだ。）

基本となるのは、真空からの生成（Creation）C:&lt;b&gt;C&lt;/b&gt;→V(×)V と、消滅（Annihilation）A:V(×)V→&lt;b&gt;C&lt;/b&gt;。

&lt;pre&gt;
↑
↑   ∩ A
↑   ∪ C
↑
&lt;/pre&gt;

時間を右から左にとると：

&lt;pre&gt;
←←←←←
  ⊂  ⊃
  A   C
&lt;/pre&gt;

時間の向きとは逆に、上から下、または左から右に書き下すと：

- &amp;lt;A|C&gt;

が円（circle）となる。式の中は、←方向に見るから Creation and-then Annihilation と読むわけだ。毎度ながら、方向には悩まされるぞ。

</body>
</day>
<day date="2009-04-06" title="">
<body>
*1238978773*[講座][JavaScript]オブジェクトの表示

とりあえず：
&lt;pre class=&quot;code&quot;&gt;
Object.prototype.toString = function() {
  var s = &quot;{&quot;;
  for (var p in this) {
    var v = this[p];
    if (v !== undefined) {
      s += p + &quot;=&quot; + v + &quot;, &quot;;
    }
  }
  s = s.replace(/, $/, &quot;&quot;);
  return s + &quot;}&quot;;
};
&lt;/pre&gt;

</body>
</day>
<day date="2009-04-10" title="">
<body>
*1239351477*[講座][JavaScript]参照とか繰り返しとか

&lt;pre class=&quot;code&quot;&gt;
for (var i = 0; i &lt; 10; i++) {
 print(a[i]);
}
&lt;/pre&gt;

↑のほうが次より理解しやすいようだ。

&lt;pre class=&quot;code&quot;&gt;
for (var p in obj) {
 print(obj[p]);
}
&lt;/pre&gt;

a[i]でiが変化する様子はイメージできるが、obj[p]でpの変化がイメージしにくい。

例えば、二人組にして次の実習をしてもらう。

+ 一人Aに数枚のカードを渡す。カードに単語（例えば人名）が書いてある。
+ もう一人Bに「××さんのオヒゲは素敵」とかの穴あき文を提示する。
+ Aがカードを切ってから、順に読み上げる。
+ Bはその単語を穴あき文に入れて叫ぶ。

a[b.c] のような表現に慣れるにはどうしたもんだろう？ それと、メソッドに至る道にはどうするか？ ともかくも、イメージと体でおぼえることが基本。

*1239351597*[セミナー][モナド][説明][具体例]モナドの代数

リストモナド＝列モナドの代数は、a:A&lt;sup&gt;*&lt;/sup&gt;→A だから、任意のnに対するn講演算を備えた集合。a:A&lt;sup&gt;+&lt;/sup&gt;→A なら、0項演算（特別な定数）はない。Idモナド（自明モナド）の代数は任意の自己射になる。

&lt;b&gt;R&lt;/b&gt;に対して、a:&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;*&lt;/sup&gt;→&lt;b&gt;R&lt;/b&gt;に対して、a(空) = 7, その他は平均値の2倍とか定義してもいいから、代数がよく知られた法則性を持つわけではない。単なる演算で、その&lt;em&gt;アリティが関手で与えられる&lt;/em&gt;だけ。

という事情だが、多くの場合、モナドに対して都合がいい代数、典型的な代数があるから、それを挙げておく。

|*モナド   |* 典型的な代数 |* 追加の法則 |
| リスト（列） | モノイド | 結合、単位 | 
| 非空リスト   | 半群     | 結合 |
| 有限ベキ    | 半束      | 結合、単位 |
| べき       |CPO        |最小上界に関する法則|
| バッグ    | 可換モノイド | 結合、単位 |
| 凸結合    | 凸空間 | 凸空間の公理 | 
| 線形結合  | ベクトル空間 | ベクトル空間の公理 |
| 直積スタンピング | 作用付き集合 | 作用の結合、単位 |
| 付点      | 基点付き集合 | - |


こうしてみると、モナドの関手が、アリティあるいは項集合を定義しているのがわかる。ひとつの関手の代数が構造的類をなしている。

直和スタンピングだと、例外（エラー）を正常値に押し込める“代数”がある。

*1239356564*[リンク][人物]Webで見つけた

- http://blog.sigfpe.com/  A Neighborhood of Infinity 

なにもの？ という感じ。

- http://iml.univ-mrs.fr/~lafont/papers.html

Lafontの論文。


</body>
</day>
<day date="2009-04-14" title="">
<body>
*1239675908*[子供]4月は

- 4/12(日) 練習試合 -- 終わった
- 4/15(水) 夜 早め -- 渋谷午後2時だから注意！ 終わった
- 4/19(日) 午後？？ どうなっているんだ？
- 4/16(木) たぶん僕は留守
- 4/23(木) 確実に僕は留守
- 4/24(金) 夜 早め
- 4/27(月) 夜 早め

*1239677067*[cathand]課題とか

- スコアランキングのTOP10表示
- フォームのエラーメッセージをできるだけ分かりやすく
- テーブルの行の色を変える
- 通貨や時刻の表示を適切に
- toupper -- &amp;amp;ltが&amp;amp;LTになったりしない。&amp;amp;alpha（&amp;alpha;）が&amp;amp;Alpha（&amp;Alpha;）になる。
- リスト（配列）のレンダラーはどうするか？

&lt;b&gt;[追記]&lt;/b&gt;month=4 の状況（値の環境）で、monthを&quot;4&quot;でなくて&quot;04&quot;と表示させたい。どうするか？

printfのformat文字のような仕掛けが必要だ。これは修飾子か。とすると、%ナントカを修飾子のパラメータにする必要がある。Smartyどうなっていたろう？&lt;b&gt;[/追記]&lt;/b&gt;

*1239683562*[cathand]マクロとラムダ計算

マクロ（あるいはテンプレート）は、アルファ変換ができないラムダ計算だと思えばいい。

単純置換を定義する。M, N, Lを式（項）だとして、x, y, zなどを変数だとする。単純置換をするオペレータを{L/x}のように書く。とりあえずは1個の変数だけを置換。

+ x{L/x} ⇒ L
+ y{L/x} ⇒ y （x≠y）
+ (M・N){L/x} ⇒ (M{L/x}・N{L/x})
+ (λx.M){y/x} ⇒ λy.(M{y/x})
+ (λx.M){L/x} ⇒ 未定義 （Lは変数ではない）
+ (λy.M){L/x} ⇒ λy.(M{L/x}) （x≠y）

これでいいと思う。

この単純置換は束縛変数さえも無条件で置換する。よって具合が悪い。束縛変数を考慮する置換を[L/x]とすると。

+ x[L/x] ⇒ L
+ y[L/x] ⇒ y （x≠y）
+ (M・N)[L/x] ⇒ (M[L/x]・N[L/x])
+ (λx.M)[L/x] ⇒ (λx.M)
+ (λy.M)[L/x] ⇒ λy.(M[L/x]) （x≠y）



</body>
</day>
<day date="2009-04-15" title="">
<body>
*1239754451*[リンク][セミナー]予約ページが勝手に変更された、ヒドイ

予約ページ http://www.revn.jp/grms/pub/pc/schedule.php は http://www.ginzarenoir.jp/ にリダイレクトされてしまう。

https://www.revn.jp/grms/usr/reservation.php も同じく http://www.ginzarenoir.jp/ にリダイレクトされてしまう。ブックマークしていた人はビックリだろうな。メールアドレスは登録しているのに何の連絡もないし、ちょとこれはどうなのよ？

現在 https://www.ginzarenoir.jp/grms/pub/pc/schedule.php が使える。


</body>
</day>
<day date="2009-04-16" title="">
<body>
*1239847883*[リンク][からみ系]リボングラフとか絡み目とかタングルとか

また、バエズの記事から：
- http://golem.ph.utexas.edu/category/2009/04/kamnitzer_on_categorifying_tan.html

- Title:Ribbon graphs and their invariants derived from quantum groups
- Authors: N. Yu. Reshetikhin and V. G. Turaev
- Source: Comm. Math. Phys. Volume 127, Number 1 (1990), 1-26. 
- URL: http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.cmp/1104180037
- URL PDF: http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id=pdf_1&amp;handle=euclid.cmp/1104180037
- Pages: 26

- Title: Knot homology via derived categories of coherent sheaves I, sl(2) case
- Authors: Sabin Cautis, Joel Kamnitzer
- URL: http://arxiv.org/abs/math/0701194
- Pages: 53

これの続き（II）は、

- http://arxiv.org/abs/0710.3216

*1239848542*[cathand][Erlang]タグ付き直積とタグ付き直和

ここでタグというのは、目印、マーカーのこと。タグ付き直積の例は、JSONオブジェクト、プロパティ名（キー）がタグになっている。Erlangのプロパティリストもタグ付き直積の表現と考えていい、ただし、リストはどうしても可変長になるから、その点ではタプル（直積）っぽくないけど。タグ付き直和は、Erlangのok/error方式が典型。

直積と直和なんだから次の概念を考える。

+ 射影（projection）と入射（injection）
+ 対角（複製）と余対角（折り畳み）
+ 射の直積、射の直和

Erlangのcase文やokタグについて真剣に考えてもいいかもね。


</body>
</day>
<day date="2009-04-17" title="">
<body>
*1239932942*[セミナー][モナド][M3]出演するモナドさん達

そろそろ出し物を決めないとなー。どれがいいだろう？

コレクション系モナド：
+ リスト、列、string, word
+ セット（有限）、enum、有限ベキ（共変）
+ バッグ
+ 型なし（非制限的な）レコード

スタンピング系モナド：
+ 代入（更新）
+ エラー（単純）、未定義、Maybe
+ ファイル出力
+ moveTo, moveBy による点の描画

項モナド：
+ 1次式
+ 凸結合
+ コレクションはすべて項モナドと解釈できる

その他：
+ 単純有向グラフ
+ 切り上げ

こんなもんか。&lt;b&gt;[追記]&lt;/b&gt;ツリーモナドを忘れてた。&lt;b&gt;[/追記]&lt;/b&gt;

問題は動詞だ！ &lt;b&gt;[追記]&lt;/b&gt;これは後で書き換える。&lt;b&gt;[/追記]&lt;/b&gt;

|* モナド |* 乗法   |* 単位    |* 関手の射パート |
| リスト  | flatten | single   | map |
| セット  | flatten | single   | map |
| バッグ  | flatten | single   | map |
| レコード  | flatten | single   | map |
| 代入    | perform | valueOnly   | noTouch |
| エラー  | aggregate | normal    | noError |
| ファイル出力 | perform | valueOnly | noOutput |
| moveTo, moveBy | perform | void | noMove |
| 1次式     | expand | asExpr | subst |
| 凸結合   | expand | asExpr | subst |
| 単純有向グラフ | ident | embed | induced |
| 切り上げ  | ident | inc |  ceiling |

まだ要検討。

他に、

+ アクション＝エフェクト＝作用とは何か
+ 半群、モノイド作用

*1239955421*[セミナー][モナド][M3]話題とか方針とか

- 凸結合を意図的に取り上げてみようかな。
- 凸結合モナドのクライスリ圏の自己射は確率遷移系になるね。
- かなりの数のモナドがスタンピングで説明できる。
- 代数項としても説明できる。
- ツリーモナドは親玉みたいなもんだ。
- 自然数の有限部分集合の順序集合（＝やせた圏）に対して、最小公倍数で閉じさせる操作を入れるとモナド、これも入れよう。
- 余代数っぽい例は今回は止める。
- モナドの代数は少し入れてもいいか。
- クライスリ圏は徹底的にやる。


|* モナド |* 名称 |* 乗法   |* 単位    |* 関手の射パート |
| リスト  | List | flatten | single   | map |
| セット  | Enum | flatten | single   | map |
| バッグ  | Bag  | flatten | single   | map |
| レコード| Record | flatten | single   | map |
| ツリー  | Tree | expand | single | subst |
| 代入    | Assign | aggregate | valueOnly   | noAssign |
| エラー  | Error | aggregate | normal    | noError |
| ファイル出力 |Output | aggregate | valueOnly | noOutput |
| moveTo/By| Move | aggregate | valueOnly | noMove |
| 1次式     | Affine | expand | asExpr | subst |
| 凸結合   | Convex | expand | asExpr | subst |
| 単純有向グラフ | Digraph | ident | embed | induced |
| 最小公倍数閉包 | LCMClos | ident | increasing | monotone |
| 切り上げ  | Ceiling | ident | increasing |  monotone |


</body>
<comments>
<comment>
<username>bonotake</username>
<body>あくまでご参考、ですけれど、Haskellの標準的モナドのカタログです。&lt;br&gt;http://www.sampou.org/haskell/a-a-monads/html/</body>
<timestamp>1239937313</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>bonotakeさん、ありがとうございます。&lt;br&gt;なにを取り上げるかは、前々日か前日に、僕の気分で決まると思います ^^;</body>
<timestamp>1239954325</timestamp>
</comment>
</comments>
</day>
<day date="2009-04-22" title="">
<body>
*1240359741*[JavaScript][講座]DOM操作

HTMLを手で編集してはリロード作業との対比をすれば、以外にDOM操作もわかるみたい。

バッドノウハウのinnerHTMLとかは分かりやすい。さすがだ（なにが？）

createElementとかが、作ってどこにも入ってない（配置されてない）という概念が少し難しいかも知れないが、エディタの別ペインでタグをシコシコ書いて、コピペで文書側にインサートする過程と対比すればよい。

img要素のsrc属性書き換えとかは納得感／達成感が高い。

*1240385863*[セミナー][モナド][M3]明日だよなー、、、モナドとかナニヤラ

- http://d.hatena.ne.jp/m-hiyama/20090422/1240369226

要するに不調！ あーシンド((むかし、アルシンドというサッカー選手がいたな。))。

それはそうとして、モナドの相関図を考えてみる。

- 項モナドの仲間達
-- リスト －似てる→  列挙、バッグ
-- バッグ －平均値を取る→  平等な凸結合
-- アフィン －定数を落とす→  線形 －正値、たして1→  凸結合
-- アフィン  －一般化→  多項式  －一般化→  代数式
-- 代数式  －図形化→  ツリー  －特殊化→  二分木  －特殊化→  リスト
- アクション・エフェクト系モナドの仲間達：
-- 右自明モノイド →代入
-- 連接モノイド → ファイル出力

だめだ、もう疲れたからこれはヤメ。

別なハナシ。つうか、とにかくゴチャゴチャと色々。

- 関手の例
-- Braid → Amida → Sym
-- Amida → Sym が全射（充満）であることをゴムひもで示す
-- HShiriからKShiriへのカタカナ変換、アルファベット変換はダメ
-- HShiriからNat&lt;sub&gt;+&lt;/sub&gt;への長さ関手
-- HShiriからHShirへのreverse反変関手
-- 反変／共変Pow関手、これは普通。
- FiniteOrdinal上の圏 MapFO, PMapFO, RelFO
- RelFOはブール半環上の行列圏
- 行列の応用；経路の本数、可達性、正規表現とクリーニスター
- FO上のinclusionの圏はNatと同じ
- バッグと素因数分解と約数順序
- {a, b}上の右自明半群に単位元eを加えたモノイド
- min-plus半環を使ったコストの最小化の問題
- {0, 1, 2}の足し算と螺旋階段と2の補数表示
- {1, 2, 3, ∞}の計算
- 離散有限版ファインマン経路積分

</body>
</day>
<day date="2009-04-23" title="">
<body>
*1240458923*[JavaScript]とりあえず行列掛け算

計算できればいい。

&lt;pre class=&quot;code&quot;&gt;
/* mat.js */

/*
 * 簡易行列計算（掛け算のみ）
 *
 * 行列は入れ子の配列で表す。
 * 例：[ [2, 0, 1], [0, 3, -1] ] これは2行3列の行列
 * - matMult -- 掛け算
 * - matEq -- 等値判定
 * - matPrint -- 表示
 * それぞれ、m, e, p という短縮名がある。
 */


// 行列mの列の数
function cols(m) {
  return m[0].length;
}

// 行列mの行の数
function rows(m) {
  return m.length;
}

// 行列mのi列目を取り出す
function getCol(m, i) {
  var M = rows(m);
  var c = new Array();
  for (var j = 0; j &lt; M; j++) {
    c[j] = m[j][i];
  }
  return c;
}

// ベクトルxとベクトルyの積和
function vecProd(x, y) {
  var K = x.length;
  var p = 0;
  for (var i = 0; i &lt; K; i++) {
    p += x[i]*y[i];
  }
  return p;
}

// 行列aとbの行列積
function matMult(a, b) {
  var M = rows(a);
  var N = cols(a);
  var m = new Array();
  for (var j = 0; j &lt; M; j++) {
    m[j] = new Array();
    for (var i = 0; i &lt; N; i++) {
      m[j][i] = vecProd(a[j], getCol(b, i));
    }
  }
  return m;
}

// 行列の等しさの判定
function matEq(a, b) {
  var M = rows(a);
  var N = cols(a);
  for (var j = 0; j &lt; M; j++) {
    for (var i = 0; i &lt; N; i++) {
      if (a[j][i] != b[j][i]) {
	return false;
      }
    }
  }
  return true;
}

// 行列の表示
function matPrint(m) {
  var N = rows(m);
  for (var i = 0; i &lt; N; i++) {
    print(m[i]); // for Rhino!
  }
}

// 短い名前

var m = matMult;
var e = matEq;
var p = matPrint;

// データ

var A = [ [0, 0, 0], [1, 0, 0], [1, 1, 0] ];
var B = [ [0, 0, 1], [1, 0, 0], [0, 1, 0] ];
var C = [ [0, 0, 0], [1, 0, 0], [1, 1, 1] ];
var D = [ [0, 0, 0], [1, 1, 0], [1, 1, 0] ] ;
var E = [ [0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 1], [1, 1, 1, 0] ];
&lt;/pre&gt;
</body>
</day>
<day date="2009-04-24" title="">
<body>
*1240533398*[子供]午後4時に待ち合わせ

いるように、

*1240551192*[圏一般論][具体例][説明][JavaScript][セミナー]しりとりの圏 -- JavaScriptによる実装

&lt;pre class=&quot;code&quot;&gt;
/* HSCat.js -- Hiragana Shiritori Category */

/*
 * 一般的な文字列処理関数
 */

// 文字列の連接
function concat(s, t) { // s, t は文字列と仮定
  return String.prototype.concat.call(s, t);
}

// 文字列の最初の文字（ただし文字番号が返る）
function first(s) { // s は文字列と仮定
  return s.charCodeAt(0);
}

// 文字列の最後の文字（ただし文字番号が返る）
function last(s) { // s は文字列と仮定
  return s.charCodeAt(s.length - 1);
}

// 文字列の最初の文字を除いたもの
function butfirst(s){ // s は文字列と仮定
  return s.substring(1);
}

// 特定の1文字からなる文字列（引数は文字番号）
function unit(c) { // c は整数と仮定
  return String.fromCharCode(c);
}

// ひらがな文字かどうかを判定（引数は文字番号）
function isHiraganaCharCode(c) { // c は整数と仮定
  return (
    (0x3041 &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= 0x308F) // 'ぁ' から 'わ'
    ||
    c === 0x3092 // 'を'
    ||
    c === 0x3093 // 'ん'
    ||
    c === 0x30FC // 'ー'
  );
}

// 非空（Non Empty）なひらがな文字列かどうかを判定
function isHiraganaNEString(s) { // s は文字列と仮定
  if (s.length === 0) return false;
  for (var i = 0; i &amp;lt; s.length; i++) {
    if (!isHiraganaCharCode(s.charCodeAt(i))) return false;
  }
  return true;
}

// しりとり方式の文字列連接 （sconc = Shiritori CONCat）
function sconc(s, t) { // s, t は文字列と仮定
  return concat(s, butfirst(t));
}

/*
 * 対話的に使うための便利関数
 */

// 文字の番号を返す
function ord(c) {
  return c.charCodeAt(0);
}

// 番号に対応する文字を返す
function chr(n) {
  return String.fromCharCode(n);
}

/* ================================================== */

/*
 * ひらがなのしりとり圏（HSCat）の実装
 */

// 名前空間を提供するオブジェクト
var HSCat = {
};

// この圏の対象かどうかを判定
HSCat.isObject = function(x) {
  return (
    (typeof x === 'number')
    &amp;amp;&amp;amp;
    isHiraganaCharCode(x)
  );
};

// この圏の射かどうかを判定
HSCat.isMorphism = function(x) {
  return (
    (typeof x === 'string' || x instanceof String)
    &amp;amp;&amp;amp;
    isHiraganaNEString(x)
  );
};

// 射の域
HSCat.dom = function(s) {
  if (!HSCat.isMorphism(s)) throw &quot;not a morphism&quot;;
  return first(s);
};

// 射の余域
HSCat. cod = function(s) {
  if (!HSCat.isMorphism(s)) throw &quot;not a morphism&quot;;
  return last(s);
};

// sとtが結合可能かどうかを判定
HSCat.composable = function(s, t) {
  return (
    HSCat.isMorphism(s)
    &amp;amp;&amp;amp;
    HSCat.isMorphism(t)
    &amp;amp;&amp;amp;
    HSCat.cod(s) === HSCat.dom(t) // 結合可能性の条件
  );
};

// sとtを結合（合成）
HSCat.compose = function(s, t) {
  if (!HSCat.composable(s, t)) throw &quot;canot compose&quot;;
  return sconc(s, t);
};

// 恒等
HSCat.id = function(a) {
  if (!HSCat.isObject(a)) throw &quot;not an object&quot;;
  return unit(a);
};
&lt;/pre&gt;


</body>
</day>
<day date="2009-04-25" title="">
<body>
*1240632074*[リンク][物理っぽい]Louis Crane

ルイ・クレインの偉大な論文らしい。

- http://arxiv.org/abs/gr-qc/0602120 (15ページ)
- http://www.physicsforums.com/archive/index.php/t-113145.html

*1240632392*[圏一般論][具体例][説明][JavaScript][セミナー]有限オーディナルと写像の圏 -- JavaScriptによる実装

&lt;pre class=&quot;code&quot;&gt;
/* MapFO.js -- Map Category over Finite Ordinals */

// 整数の区間を作る
// （一般的にも使えそう）
function seq(n, m) { // n, mは整数、n ≦ m と仮定
  var a = new Array();
  for (var i = 0; i &amp;lt;= (m - n); i++) {
    a[i] = n + i;
  }
  return a;
}

// 名前空間を提供するオブジェクト
var MapFO = {
};

// 内部的に使うコンストラクタ
function _MapFO(n, m, values) {
  this.dom = n;
  this.cod = m;
  this.values = values;
}

// 射の印字のために
_MapFO.prototype.toString = function() {
  var s = &quot;[&quot; + this.dom + &quot;] --&gt; [&quot; + this.cod + &quot;]\n&quot;;
  var v = this.values;
  for (var i = 0; i &amp;lt; v.length; i++) {
    s = s + (i + 1) + &quot; |--&gt; &quot; + v[i] + &quot;\n&quot;;
  }
  return s;
};

// 配列aが 0 ≦ a[i] ≦ m であるかどうか調べる
//（内部的に使用する）
MapFO._isValuesArray = function(a, m) { // aは配列、mは非負整数と仮定
  for (var i = 0; i &amp;lt; a.length; i++) {
    if (typeof a[i] != 'number') return false;
    if (a[i] &amp;lt;= 0 || m &amp;lt; a[i] ) return false;
  }
  return true;
};

// この圏の対象かどうかを判定
MapFO.isObject = function(x) { // xに浮動小数点数入れるのはカンベンして!
  return (
    typeof x === 'number'
    &amp;amp;&amp;amp;
    x &gt;= 0
  );
};

// この圏の射かどうかを判定
MapFO.isMorphism = function(x) {
  return (
    typeof x === 'object' &amp;amp;&amp;amp; x instanceof _MapFO
  );
};

// 射の域
MapFO.dom = function(f) {
  if (!MapFO.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f.dom;
};

// 射の余域
MapFO.cod = function(f) {
  if (!MapFO.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f.cod;
};

// fとgが結合可能かどうかを判定
MapFO.composable = function(f, g) {
  return (
    MapFO.isMorphism(f)
    &amp;amp;&amp;amp;
    MapFO.isMorphism(g)
    &amp;amp;&amp;amp;
    MapFO.cod(f) === MapFO.dom(g) // 結合可能性の条件
  );
};

// fとgを結合（合成）
MapFO.compose = function(f, g) {
  if (!MapFO.composable(f, g)) throw &quot;cannot compose&quot;;
  var v = new Array();
  for (var i = 0; i &amp;lt; f.dom; i++) {
    v[i] = g.values[f.values[i] - 1];
  }
  var map = new _MapFO(f.dom, g.cod, v);
  return map;
};

// 恒等
MapFO.id = function(n) {
  if (!MapFO.isObject(n)) throw &quot;not an object&quot;;
  return new _MapFO(n, n, seq(1, n));
};

// 射のコンストラクタ
MapFO.newMorphism = function(n, m, v) {
  if (!MapFO.isObject(n) || !MapFO.isObject(m)) throw &quot;not an object&quot;;
  if (!(typeof v === 'object' &amp;amp;&amp;amp; v instanceof Array))
    throw &quot;values must be an array&quot;;
  if (v.length != n) throw &quot;size not match&quot;;
  if (!MapFO._isValuesArray(v, m)) throw &quot;illegal values&quot;;
  return new _MapFO(n, m, v);
};

// 射のコンストラクタ 簡便バージョン
MapFO.mor = function(a1, a2, a3) {
  var n, m, v;
  if (typeof a3 === 'undefined') {
    n = a2.length;
    m = a1;
    v = a2;
  } else {
    n = a1;
    m = a2;
    v = a3;
  }
  return MapFO.newMorphism(n, m, v);
};

// 射が等しいかどうかを判定
MapFO.eq = function(f, g) {
  if (!MapFO.isMorphism(f) || !MapFO.isMorphism(g))
    throw &quot;not a morphism&quot;;
  if (f.dom != g.dom || f.cod != g.cod)
    return false;
  for (var i = 0; i &amp;lt; f.dom; i++) {
    if (f.values[i] != g.values[i])
      return false;
  }
  return true;
};
&lt;/pre&gt;

</body>
</day>
<day date="2009-04-28" title="">
<body>
*1240894333*[圏一般論][モノイド圏]イエッターのペースティング・スキーム

イエッター（Yetter）が線形圏・関手・自然変換の変形（deformation）とペースティング図の長めの論文を書いているが、10%くらいしか分からない。が、分かるところ（10%くらい）は面白い。

ペースティング・スキームって概念が出てくるが、コンピュータッドの幾何実現のことらしい。組合せ的でもあり幾何的でもあり、僕このみ。ペースティング・スキームとコンピュータッドくらいは分かりたいもんだ。


</body>
</day>
<day date="2009-05-01" title="">
<body>
*1241159685*[WCC]XIONの過去記事

上ほど新しい。

- [http://d.hatena.ne.jp/m-hiyama/20060819/1155971622:title]
- [http://d.hatena.ne.jp/m-hiyama/20060804/1154659122:title]
- [http://d.hatena.ne.jp/m-hiyama/20060718/1153189929:title]
- [http://d.hatena.ne.jp/m-hiyama/20060714/1152844748:title]
- [http://d.hatena.ne.jp/m-hiyama/20060614/1150249907:title]
- [http://d.hatena.ne.jp/m-hiyama/20060605/1149466907:title]
- [http://d.hatena.ne.jp/m-hiyama/20060601/1149125777:title]

おまけ。

-[http://d.hatena.ne.jp/m-hiyama/20080311/1205219856:title]

*1241136281*[からみ系]マルコフ・トレース

マルコフ・トレースってなんだっけ？ と毎回忘れる。

マルコフ・トレースの定義は、 http://d.hatena.ne.jp/m-hiyama-memo/20080702/1214966458 に書いてある。ブレイドの圏から特定の環Rへの写像。ブレイドの圏をR係数で拡張すれば、R線形圏（つうかR加群豊饒圏）上の線形代数的なトレースとなる。

一方で、ブレイドの圏に直感的かつ幾何学的にトレースを入れると、圏論的なトレースになる。これはマルコフ・トレースとは呼ばないようだ（なんて呼べばいいんだよ！！！ったく）。しかし、ブレイドから作ったトレース圏をR線形化して、そこで線型代数のトレースを考えたら結局同じことのようだけど、、、

マルコフ・トレースが中途半端な概念だから憶えにくいのかな。σを対称だとして、σとσ&lt;sup&gt;-1&lt;/sup&gt;をテンソル（横に並べる）する作用が乗法になる以外は行列のトレースと同じだ。線形代数的に考えたほうが自然なのかも。

&lt;b&gt;[追記]&lt;/b&gt;
- カウフマン・ブラケット http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%d6%a5%e9%a5%b1%a5%c3%a5%c8%20%a5%ab%a5%a6%a5%d5%a5%de%a5%f3
- 一般ブラケット http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%b0%ec%c8%cc%a5%d6%a5%e9%a5%b1%a5%c3%a5%c8
&lt;b&gt;[/追記]&lt;/b&gt;

*1241156518*[からみ系]マルコフ移動、変形、簡約

マルコフ移動は幾何学的変形だが、記号的簡約（縮約；reduction）と考えてもいい。Aがブレイドで、σが基本ブレイド、σ'はσの逆、id&lt;sub&gt;n&lt;/sub&gt;を単にn、モノイド積は並置で表すと：

+ (n σ m);A;(n σ' m) → A （n + 2 + m = dom(A) と仮定）
+ (A 1);((n-1) σ) → A (n = dom(A) と仮定）

となる。上は σσ' = id という逆元の性質、下はヤンキング。逆元の性質は&lt;em&gt;交差キャンセル&lt;/em&gt;とでも呼ぶといいだろう。

マルコフ簡約を項書き換え系とみなして、正規形（リデックスがない）の集合が結び目の集合（もちろん同値類）と同型だというのがマルコフの結果ということになる。

アルチンの結果と一緒にしてまとめると、アルチン関係式＝ヤン／バクスター関係式とマルコフ簡約を持つような項書き換え系が結び目を記述することになる。ただし、アルチン関係からは正規系の概念は出ないので、アルチン同値な項は同一視することになるだろう。

*1241144769*[圏一般論][その他代数]圏の線形化とか多項式とか

圏Cが与えられたとき、いくつかの方法で線形化できる。係数体Kはなんかに固定することにして、FV(X)は自由ベクトル空間だとする。

圏Dを |D| = |C| として、ホムセットを

- D(A, B) := FV(C(A, B))

と定義する。結合は双線形に拡張すれば、DはKベクトル空間（とテンソル積）の圏で豊饒化されるので、Cの線形化と言ってよい。

あるいは、ドカンとFV(C)を作ってしまって、圏の結合を掛け算として多元環を作る方法もある。これは、圏Cの射を1セルとみなしての1チェインの空間に自然な乗法を入れた代数ともいえる。Cから作ったK線形圏Dと、Cから作った多元環がどういう関係かはよく分からない（ほとんど同じように思えるが）。

最初の方法で作った圏を L&lt;sub&gt;K&lt;/sub&gt;(C) とする。Kが分かっていれば L(C) と書く。Lは、全ての圏からK-線形圏への関手となる。L:Cat→L&lt;sub&gt;K&lt;/sub&gt;Cat 。L&lt;sub&gt;K&lt;/sub&gt;CatからCatへの忘却関手を考えれば、Lはモナドで、自由ベクトル空間モナドとほとんど同じ（たぶん高次のモナド）。

K線形圏DとK可換環Rがあるとき、R(×)D を、次のように定義できる。

- (R(×)D)(A, B) = R(×)D(A, B)

これは単にテンソル積しただけだが、係数拡張なので、圏が拡張されたように思える。

特に、Rが不定元XのK-多項式環だとすると、圏R(×)D の射は、f&lt;sub&gt;0&lt;/sub&gt; + f&lt;sub&gt;1&lt;/sub&gt;X + ... のような多項式で、雰囲気としては、R(×)D = D[X] という、不定元XからDの射を係数として作った多項式の代数になる。二変数多項式 D[X, Y]とかも定義できる。

こんなことして何がうれしいかというと、たぶん、おそらく、クレイジー計算の舞台がD[X]あるいは無限級数D&amp;#91;[X]&amp;#93;とかだと思うのだ。それと、Xをパラメータとして圏を摂動するような話にもなる。ひょっとすると圏の無限小変形とかの概念があるのかも知れない。

*1241146051*[モノイド圏][からみ系]バートレット・フリップとヤンキング

ブルース・バートレットは、次の主張をしている。

- 双対と随伴は区別する必要はない。
- 双対概念は、大域的な割当として考えるべきではない。
- すなわち、双対が存在するのは圏の&lt;em&gt;性質&lt;/em&gt;であって構造ではない。
- 局所的な双対の割当に対してスター記号やダガー記号を使う。

なるほどねーー。たいした若者だ。

んで、バートレット・フリップがある状況でジグザグ（スネーク）を使えばヤンキングが出るって話。

+ ヤンキングの絵を描く。
+ ∩の部分をバートレット・フリップする。
+ クロスオーバーで交差をなくす。
+ ジグザグを伸ばす。

アスキー図で描いてみる。

&lt;pre&gt;
         ｜ ∩
｜∩     ｜ X
 X ｜ ⇒  X ｜ ⇒ (下へ)
｜∪     ｜∪  

 
｜ ∩          ｜ ∩
｜｜｜         ｜｜｜
 ＼ X      ⇒   ∪ ｜ 
   X  ＼           ｜
 ／ ＼／
&lt;/pre&gt;

目を細めれば、なんとか見えるのでは。

*1241146962*[からみ系]ヤン／バクスター関係式とその変種

ヤン／バクスター関係式は、ライデマイスター移動の何番かだが、番号は永久に覚えられないので、ヤン／バクスターまたはアルチンの関係式と呼ぶことにする。

ヤン／バクスター関係式は、交差している紐の交差点のところを、別な紐が通り抜けていくイメージなので、通り抜けていく紐（ストランド）をスイーピング・ストランドと呼ぶことにする。

まず、最初に与えられる交差が正か負かで2種類。スイーピング・ストランドが通り抜けていく位置（奥行き）が、手前、中間、一番奥で3種有る。となると、6種類のアニメーションができるが、これらは独立じゃなくて、どれかを仮定すれば全部でるのか？ よくわかっとらんな、僕は。

*1241156233*[気付いた][具体例]えっ!? 両側加群て線形圏だったの

CがK-線形圏だとして、RがK-多元環（代数）のとき、テンソル積R(×)Cが定義できる（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090501/1241144769&quot;&gt;前のエントリー&lt;/a&gt;に書いた）。もっと一般に、線形圏CとDのテンソル積が、|C|×|D|上に、

- (C(×)D)( (A, B), (A', B') ) = C(A, A')(×)D(B, B')

として定義できる。単一の多元環とのテンソル積はこのテンソル積の特殊ケースだ。

というわけで、多元環が対象を1つだけ持つK-線形圏であることは知っていた（圏の結合は多元環の掛け算）。それで、次に単純な線形圏として対象が2つの例を調べたら、これは両側加群だった。へーっ。当たり前だけど「ヘーッ」

R, SがK-多元環で、MがK-ベクトル空間。Rが左から、Sが右から作用してMは両側加群だとする。このとき、2つの元（なんでもいい）{1, 2}に対して：

- End(1) = R
- Hom(1, 2) = M
- End(2) = S
- Hom(2, 1) = {0}
- End(1)×End(1) はRの掛け算
- End(1)×Hom(1, 2) は左からの作用
- Hom(1, 2)×End(2) は右からの作用
- End(2)×End(2) はSの掛け算

とすると、R, S, M からなる両側加群は{1, 2}上の線形圏になる。逆にCが{1, 2}上の線形圏だと

- R = C(1, 1)
- S = C(2, 2)
- M = C(1, 2)

として両側加群ができる。M = C(2, 1)としても両側加群ができるから、一意的に加群を決めるわけではないが、C(2, 1) = 0 （潰れている）とすれば、加群と線形圏は1：1に対応すると思ってよい。

規模の小さい（対象が少数の）線形圏は、線型代数の概念と対応が付くかもしれない。だからどうというわけでもないけど、なんか面白い。

一般の圏Cと両側加群（である線形圏）とのテンソル積はどんな意味があるだろう。ブール／クリーネ加群だとどうだろう？

</body>
</day>
<day date="2009-05-02" title="">
<body>
*1241234481*[プログラム意味論]プレガードとポストガードと並行実行

p・A が、論理式pでガードされた文だとする。pが0（false）のときは、p・A = O となる。Oはクリーネ代数のゼロで、エラー、失敗、カオス、無限走行などを意味する。p・A + p'・B として if p then A else B endif を表現できる；ここで、p'はpの否定とする。

A・p をpでポストガードされた文だとする。Aが正常に実行され、かつpのときはAの結果がプログラムの結果、そうでないときはOとなる。A・p + B・p' も定義できるが、これはどういう意味だろうか？ (A and p) orelse B  みたいな感じ？

- Aをしてpならそれでよし、そうでないならBの結果を採用する。
- AとBを同時実行して、pであるならAを、そうでないならBの結果を採用する。

Aと実行した後でないとpの判定が出来ないので無駄な感じだが、通常のif文でも分岐の並行実行を行い、条件文の判定が遅れるなら同じようなものだ。なんでも並行実行の世界なら、ポストガードは別に変な概念じゃないな。

*1241239493*[セミナー][具体例][M3]色々な具体例

&lt;h5&gt;関手Sq&lt;/h5&gt;

Sq(A) = A×A, Sq(f:A→B) = (f×f:A×A→B×B) 。これは対象[2] = {1, 2} によって共変主表現される。

&lt;h5&gt;関手Double&lt;/h5&gt;

Sqの直和版。これは対象[2]のスタンピング。

&lt;h5&gt;反変ペキ集合関手&lt;/h5&gt;

Pow、これは対象[2]で反変主表現される。

&lt;h5&gt;反変3値ベキ集合関手&lt;/h5&gt;

[3]により反変主表現される関手。

&lt;h5&gt;随伴の例&lt;/h5&gt;

- Set(A+A, B) ＝ Set([2], B&lt;sup&gt;A&lt;/sup&gt;)
- Set(A+A, B) ＝ Set(A, B&lt;sup&gt;2&lt;/sup&gt;) ＝ Set(A, B×B)

&lt;h5&gt;特殊な圏&lt;/h5&gt;

- Set&lt;sub&gt;≦1&lt;/sub&gt; は基数が1以下の集合の圏。
- Set&lt;sub&gt;≦1&lt;/sub&gt;/[1]はどうなるか？ 特に直和がどうなるか？
- Bをブール代数を圏だと思ったモノだとすると、Set&lt;sub&gt;≦1&lt;/sub&gt;/[1]→B の関手を作れる

&lt;h5&gt;意外な感じだが良い例&lt;/h5&gt;

- Relの直和は直積
- ベクトル空間の直和は直積
- 圏とみなした順序集合での直積は最小上界
- 圏とみなした順序集合での直和は最大下界
- 環の圏で &lt;b&gt;Z&lt;/b&gt;の&lt;b&gt;Q&lt;/b&gt;への埋め込みはエピ
- 位相空間の圏で &lt;b&gt;Q&lt;/b&gt;の&lt;b&gt;R&lt;/b&gt;への埋め込みはエピ
- 圏と見なした順序集合で、すべての射はモノかつエピ
- 圏と見なした自然数足し算モノイドで、すべての射はモノかつエピ

*1241251672*[セミナー][具体例][M3]色々な具体例 もっと

&lt;h5&gt;関手&lt;/h5&gt;

- K&lt;sub&gt;A&lt;/sub&gt; = λX.A
- I = λX.X
- (A×) = λX.A×X
- (+B) = λX.X + B
- λX.(X×X + 1)

&lt;h5&gt;代数あるいはマグマ&lt;/h5&gt;

自己関手Fに対してF代数という言葉を使うが、あれはFマグマだろう。何の法則もないのだから。

K&lt;sub&gt;1&lt;/sub&gt; = λX.1 という定数関手に対して、K&lt;sub&gt;1&lt;/sub&gt;代数＝K&lt;sub&gt;1&lt;/sub&gt;マグマの圏は点付き集合の圏になる。直積スタンピング関手(A×)のマグマはオートマトンになる。特にRelで考えると非決定性のオートマトン。オートマトン射の定義が自動的に出てくるのがいい。

λX.(X×X + 1)のマグマは2項演算と特定元を持つマグマ。典型例はモノイド。

&lt;h5&gt;表現&lt;/h5&gt;

- 右自明モノイド{a, b, e}（eは単位）を{a, b}の自己写像で表現する。
- 1の3乗根を{1, 2, 3}のサイクリック置換で表現する。
- 自然数の約数倍数関係を約数集合の包含、倍数集合の包含で表現する

&lt;h5&gt;もっと表現&lt;/h5&gt;

Mをモノイドとして、X = (|X|, ν&lt;sub&gt;X&lt;/sub&gt;)がM-集合だとは

+ ν&lt;sub&gt;X&lt;/sub&gt;:M×|X| → |X| が作用になっている。

XとYがM-集合のとき、|X|→|Y| で作用を保つものが射として圏をなす。この圏をSet&lt;sup&gt;M&lt;/sup&gt; とする。記号 Set&lt;sup&gt;M&lt;/sup&gt; は単なる上付き添字ではなくて、実は関手圏。

特別なM-集合Eを、|E| = |M|（Mの台集合）として、左からの作用（移動）として定義する。Set&lt;sup&gt;M&lt;/sup&gt;(E, X) = |X| となる。これは米田の補題。|E| = |M|なので、|M|にはeがあるのがミソ。

&lt;h5&gt;集合的じゃない圏&lt;/h5&gt;

ブレイドとタングルの圏、コンパクト曲面のコボルディズム圏もある。コンパクト曲面のコボルディズム圏の対象は自然数だと思ってよい。ブレイドもタングルも対象が自然数だけどね。

命題と証明の圏は集合的じゃない。が、カリー／ハワード対応でデカルト閉圏だ。

カウフマン流のI, A（対消滅）、C（対生成）から作られる圏もあるな。0→0の射は円の集合。時間方向に取り方によるが、下から上なら、C=∪、A=∩、I として、並置と「；」で表した文字列を射と考えればいい。

単体圏Δなのだが、Y、I、iの3文字で作った図形に結合律と単位律で同値関係を入れたもの。

*1241252060*[JavaScript][雑感]グラデーション（グラディエント）

普通に説明すりゃいいものを、なにも秘技密教じゃあるまいし、もうほんとにバカジャナイノ。ひさびさにイライラした。


</body>
</day>
<day date="2009-05-07" title="">
<body>
*1241658219*[セミナー]声トレ

声トレというのがあるらしい。顔トレはないのか？

まーともかく、シャベリの基本としての発声は大事だと思う。健康にもいいらしいぞ。本も出ている。

*1241658220*[セミナー][具体例][圏一般論][M3]色々な具体例 さらに

&lt;b&gt;[追記]&lt;/b&gt;
順序は次のようかな。

+ MapFO
+ MapFOへの表現、1の3乗根、1の2乗根、自明モノイド＝更新モノイド
+ &lt;b&gt;N&lt;/b&gt;に関する小物圏いろいろ
+ PMapFO
+ PMapFOに関して、二項定理と付点構成（モナド）
+ RelFO
+ RelFOに関して、非決定性写像
+ RelFOに関して、RelFO = Mat&lt;sub&gt;Ω&lt;/sub&gt;(FO)

以上がミニマム。次はY&lt;sub&gt;*&lt;/sub&gt;圏。

+ 組合せ的記号計算としてのY&lt;sub&gt;*&lt;/sub&gt;圏
+ 交替律
+ コボルディズム圏としてのY&lt;sub&gt;*&lt;/sub&gt;圏
+ Y&lt;sub&gt;*&lt;/sub&gt;圏と算術回路
+ Y&lt;sub&gt;*&lt;/sub&gt;圏と証明図（ちょっと）
+ 実は&lt;del datetime=&quot;2009-05-12T15:27:47+09:00&quot;&gt;MapFOであること。&lt;/del&gt;ウソ、実はMonotFO（単調関数の圏）
+ Y&lt;sub&gt;*&lt;/sub&gt;圏の行列表現
+ MonotFOが単体と退化写像の圏であること

Y&lt;sub&gt;*&lt;/sub&gt;圏 ＝  FO圏 ＝ 単体圏Δ ということ。

Y&lt;sub&gt;*&lt;/sub&gt;圏 に対応するコボルディズム圏をYCobとすると、YCobは、Cob&lt;sup&gt;UO&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt; の広大部分圏になる。Cob&lt;sup&gt;UO&lt;/sup&gt;&lt;sub&gt;2&lt;/sub&gt; のUOはUnorientedの意味で、コボルディズム（射）が2次元なので対象は1次元。
&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;べき＝関手圏&lt;/h5&gt;

- C&lt;sup&gt;2&lt;/sup&gt;はC×C
- C&lt;sup&gt;→&lt;/sup&gt;はCの射を対象として可換四角形を射とする圏
- C&lt;sup&gt;&lt;b&gt;N&lt;/b&gt;&lt;/sup&gt;は離散力学系の圏
- CがTop上の具象圏だとして、C&lt;sup&gt;&lt;b&gt;P&lt;/b&gt;&lt;/sup&gt;は連続力学系の圏

MがモノイドのときC&lt;sup&gt;M&lt;/sup&gt;の形の圏がいろいろできる。

- M = {1, -1, *}のとき、C&lt;sup&gt;M&lt;/sup&gt;はinvolution付きの対象の圏
- M = &lt;b&gt;N&lt;/b&gt;のとき、C&lt;sup&gt;M&lt;/sup&gt;は離散力学系
- M = S&lt;sup&gt;1&lt;/sup&gt;のとき、周期的力学系の圏
- M = A&lt;sup&gt;*&lt;/sup&gt;のとき、オートマトンの圏

離散力学系の圏で Nat(1~, F) は軌道集合になる。１つの軌道が自然変換に対応する。米田の補題から Nat(1~, F) = F(1) = X（力学系の台） となり。軌道は始点で決定される事実と対応する。

&lt;h5&gt;スライス／余スライス&lt;/h5&gt;

- Set＼[1] は点付き集合の圏
- Set／[2] はC×Cと同じ

&lt;h5&gt;随伴&lt;/h5&gt;

- 圏の圏から集合の圏へのObjと、余離散圏を対応させるCodisc
- C(X, A×B)≒C&lt;sup&gt;2&lt;/sup&gt;(Δ&lt;sub&gt;X&lt;/sub&gt;, (A, B))
- 上の同型は、C(X, Lim F)≒C&lt;sup&gt;D&lt;/sup&gt;(Δ&lt;sub&gt;X&lt;/sub&gt;, F) は特殊な場合

&lt;h5&gt;Natural-Number-like Structure&lt;/h5&gt;

- 自然数
- 初期領域を持つ離散力学系
- 非決定性オートマトン
- コンピュータシステムの低水準モデル（アドレス空間上のビット模様の遷移）

&lt;h5&gt;&lt;b&gt;N&lt;/b&gt;に関係した例&lt;/h5&gt;

- NA ：Addition 足し算モノイド
- NM ：Mutltiplication 掛け算モノイド
- NO ：Order 普通の順序集合
- NMA ：Modified Addition 変形した足し算モノイド n#m = n + m - 1、|NMA| = &lt;b&gt;N&lt;/b&gt;&lt;sub&gt;+&lt;/sub&gt;
- NMT ：Multiplicative Transition 乗法的な遷移の圏
- NMO ：倍数順序の圏

NMTだけ説明する。|NMT| = &lt;b&gt;N&lt;/b&gt;、NMT = {(a, x) | a, x∈&lt;b&gt;N&lt;/b&gt;, x≧1}、等しさは普通に定義する。

- dom(a, x) = a
- cod(a, x) = a*x （掛け算）
- id&lt;sub&gt;a&lt;/sub&gt; = (a, 1)
- (a, x);(b, y) = (a, x*y)

NMT(0, 0)、NMT(0, 1)、NMT(1, 1)、NMT(1, 3)、NMT(2, 3) などを調べる。

他に、|C| = {0, 1}、C(0, 1) = &lt;b&gt;N&lt;/b&gt; でもいいし、&lt;b&gt;N&lt;/b&gt;上の離散圏（ND）、余離散圏（NCD）もある。

|*名前 |* Obj |* Morph |
|ND    | N    | N |
|NCD   | N    | N×N |
|NA    | {0}    | N |
|NM    | {0}    | N |
|NO    | N     | N×Nの部分 |
|NMA   | {0}     | N&lt;sub&gt;+&lt;/sub&gt; |
|NMT   | N    | N×N&lt;sub&gt;+&lt;/sub&gt; |
|NMO  | N    | N×Nの部分 |

&lt;h5&gt;IJY圏&lt;/h5&gt;

- 自然数が対象
- 文字I, J, Y を並べた文字列が基本射、空文字列でもよい。
- 記号Y&lt;sub&gt;n&lt;/sub&gt;を入れて、同値関係と正規形を考える。
- I:1→1, J:1→0, Y:2→1, dom, codは連接に対して加法的に定義する
- id&lt;sub&gt;n&lt;/sub&gt; = (Iをn個並べた文字列)

&lt;h5&gt;その他&lt;/h5&gt;

- 全射の圏はE集合＝settoidの圏
- 対合を持つ集合上で、非不動点集合を求めると、余等値射の例になる。
- 指数法則 (A&lt;sup&gt;C&lt;/sup&gt;)&lt;sup&gt;B&lt;/sup&gt; = A&lt;sup&gt;B×C&lt;/sup&gt; はどう示すか？
- 右自明モノイドの表現を詳しく
- RDBのjoinはファイバー積

*1241672991*[リンク][圏一般論]米田補題とか

- http://blog.sigfpe.com/2006/11/yoneda-lemma.html
- http://www.maths.gla.ac.uk/~tl/categories/index.html

下はトム・レインスター（Tom Leinster）の講義資料
&gt;&gt;
This is the main page for the Part III Category Theory course given in Cambridge in the academic year 2000-2001. 
&lt;&lt;

*1241672992*[セミナー][圏一般論]圏の誤解

どうも、圏の公理とは別に、なんらかの事例によって刷り込まれた期待、思いこみのようなものがあって、

- 圏の対象（の実体）は××○○でなくてはならない。
- 圏の射（の実体）は××○○でなくてはならない。
- その他、idは、compは、… は××○○でなくてはならない。

のような誤解がすごく根強くあるようだ。

刷り込みが起こる典型的例は集合と写像だと思うので、それをぶち壊すためにしりとりや行列を出しているのだが、しりとりを最初の例として出会った人は、しりとりからまた刷り込みを得るんだろう。ムーー、まー致し方ないか。

*1241685457*[JavaScript]変なところ

- false == 0 は成立する。
- false == undefine は成立しない。
- if (undefined) でundefinedはfalseとして評価される。
- NaN === NaN は常に成立しない。
- &quot;hello&quot; == &quot;hello&quot; は成立する。
- [1, 2] == [1, 2] は成立しない。
- [1, , 2,,] は長さが3
- docuement.writeは良くワカラン

thisの挙動とかも変かな。

*1241689297*[セミナー][M3] Y&lt;sub&gt;*&lt;/sub&gt;圏とか

iIY圏は発音しにくいのでY&lt;sub&gt;*&lt;/sub&gt;圏にしよう。

- Y&lt;sub&gt;0&lt;/sub&gt; = i
- Y&lt;sub&gt;1&lt;/sub&gt; = I
- Y&lt;sub&gt;2&lt;/sub&gt; = Y
- Y&lt;sub&gt;3&lt;/sub&gt; = (YI);Y = (IY);Y

関連することは：

- MapFO
- MapFOによる表現、1の3乗根
- MapFOによる表現、右自明モノイド＝更新（破壊的代入）モノイド
- MapFOによる表現、1の2乗根、involution、一般化した鏡映、不動点
- コボルディズム圏、さかさズボンと腹巻きと帽子
- 空間幾何グラフの円バンドル
- 足し算とゼロから生成される算術の圏とY&lt;sub&gt;*&lt;/sub&gt;圏
- 証明図とY&lt;sub&gt;*&lt;/sub&gt;圏
- Y&lt;sub&gt;*&lt;/sub&gt;圏の行列表示
- Y&lt;sub&gt;*&lt;/sub&gt;圏のMapFO表示
- Y&lt;sub&gt;*&lt;/sub&gt;圏からアミダの圏
- アミダの圏とスワップマシン
- スワップマシンと共有メモリと競合
- 並列処理と非決定性遷移と関係圏
- 関係圏とブール係数行例

*1241689298*[文献]保江邦夫さんの「量子力学と最適制御理論」

海鳴社から出ている。

- http://www.amazon.co.jp/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E3%81%A8%E6%9C%80%E9%81%A9%E5%88%B6%E5%BE%A1%E7%90%86%E8%AB%96%E2%80%95%E7%A2%BA%E7%8E%87%E9%87%8F%E5%AD%90%E5%8C%96%E3%81%A8%E7%A2%BA%E7%8E%87%E5%A4%89%E5%88%86%E5%AD%A6%E3%81%B8%E3%81%AE%E8%AA%98%E3%81%84-%E4%BF%9D%E6%B1%9F-%E9%82%A6%E5%A4%AB/dp/4875252447

</body>
<comments>
<comment>
<username>bonotake</username>
<body>こっちの方がURLカンタンですよ。&lt;br&gt;http://www.amazon.co.jp/dp/4875252447</body>
<timestamp>1242126204</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>さすがにこれは長すぎると思ってました。^^;</body>
<timestamp>1242177815</timestamp>
</comment>
</comments>
</day>
<day date="2009-05-13" title="">
<body>
*1242179272*[具体例][からみ系][セミナー]ジョーンズ／サンダー図＝平面タングル＝円環紐図

- http://www.imsc.res.in/~sunder/canq.pdf

ジョーンズ（Vaughan Jones）とサンダー（V.S. Sunder）による図だが、あれは平面タングル（planar tangle）と呼ぶ。だけど、全然実情を表してない言葉だ。平面つっても使うのは円環領域（環帯；annulus, annular domain）とか円板から穴をくり抜いた領域。タングルと言っても実は&lt;em&gt;まったくからんでない。&lt;/em&gt;

平面タングルは全体として色付きオペラッド（複圏）になるが、オペレータ（オペラッド射）の脚が1本のときは円環領域に紐を使った模様を描いた図形になる。円環紐図とでも呼ぶべきだと思う。

円環紐図で境界マーク点がゼロ個のときは、ループを使った模様（絵柄）になる。ブタの顔を順序なしツリーにすると人の形のなる。これは、豚インフルエンザが人に感染する話か（単なるジョーク）。

*1242179891*[雑感][人物]キャー、ステキッ！

ヨアヒム・コック（Joachim kock）は、何の断りも躊躇もなくサラリと f(a) を af と書く。ヨアヒム勇気あるなー、かっこいい。

*1242179892*[用語法][圏一般論]圏の骨格（スケルトン）

ヨアヒム・コックの本に骨格（スケルトン）の定義が出てきた。

Cの部分圏Sが骨格だとは：

+ 充満部分圏である。
+ 対象の同型同値類に対して、1個だけSに属する対象がある。

つまり、対象の同型同値を≡とすると、|S| = (|C|/≡)  となることが条件。

充満部分圏なので、|S|⊆|C| を選べば部分圏は決まってしまう。

</body>
</day>
<day date="2009-05-15" title="">
<body>
*1242381227*[後で消す]メガネ

処方箋書いてもらった。作ろう、明日。

*1242381228*[用語法][圏一般論]evil live

- http://ncatlab.org/nlab/show/evil

圏論における evil 、おっもしろーい。


</body>
</day>
<day date="2009-05-16" title="">
<body>
*1242464147*[後で消す]メガネ

店が土日は休みだった。ひょっとして潰れたのかな？

あそこが気に入っていたのだが、アトレでもいいかな。


</body>
</day>
<day date="2009-05-19" title="">
<body>
*1242727269*[後で消す]メガネ

作った。木曜午後に出来上がり。


</body>
</day>
<day date="2009-05-20" title="">
<body>
*1242782180*[圏一般論][WCC]圏の変種、包含部分圏

[http://d.hatena.ne.jp/m-hiyama/20090519/1242723889:title] に出てきた圏の変種に2通りの定式化を与えてみる。

1つ目は、[http://d.hatena.ne.jp/m-hiyama/20090519/1242723889:title]に書いてあることを素直にそのまま反映させた形。対象の集合Oに順序関係⊆が入っているとする。Mが射の集合だとして：

+ dom, cod:M→O
+ id:O→M
+ (;):M×M⊃→M （部分写像）

これは普通の圏と同じだが、普通の圏では：

- f;gが定義可能 ⇔ cod(f) = dom(g)

であるところを、次のように修正する。

- f;gが定義可能 ⇔ cod(f) ⊆ dom(g)

+ id(dom(f));f = f
+ f;id(cod(f)) = f
+ (f;g);h = f;(g;h)

などはそのまま成立する。

&lt;hr&gt;
別な定式化としては、圏Cにまず包含部分圏を定義する。Cの部分圏が包含部分圏だとは：

+ Iは広大部分圏（すべてのid(a)がIに入る）
+ f∈I ならば、fはCのモノ射
+ Iはとてもやせた圏

包含部分圏Iを与えるとことと、|C|に順序構造を入れることは同じ。

圏Cの結合;以外に、;; と書かれる演算があって。

- f;;g  が定義可能 ⇔ cod(f)→dom(g) となるi∈Iがある
- f;;g  = f;i;g 

であるとする。f;gが定義可能なら、当然に f;;g も定義可能だが逆は成立しない。

f;g と f;;g の2つの結合があったほうが普通の圏論の範囲で議論しやすいから、第2の定義のほうがいいかもしれない。包含部分圏を持つ圏の話は文献があるんじゃないのかな？ たーぶん。

*1242783810*[セミナー]モニャドセミナー1 から

はじまりはいつもこんな感じ。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-diagram.jpg&quot; &gt;

ボックス＆ワイヤー図、オダンゴ図、ストリング図は、本質的には同じ図式法。

&lt;hr&gt;

ワイヤリングの絵だよ。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-tuple.jpg&quot; &gt;

多入力多出力（n-in m-out）を1入力1出力だと思うにはタプルを考えるといい。絵で描くなら、何本かのワイヤーをリボンケーブルにすること。逆の操作はリボンケーブルからなかの線を引っ張り出して分けてしまうこと。

&lt;hr&gt;

圏といえば：

&lt;img src=&quot;http://www.chimaira.org/img2/m1-morphism.jpg&quot; &gt;

域、余域、射はおぼえてね。

&lt;hr&gt;

射の結合（合成、composition）。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-composition.jpg&quot; &gt;
これは、関数合成の例なんだけど、関数（写像）のイメージに引きずられないように気を付けよう！

&lt;hr&gt;

矢印、矢印、矢印。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-arrows.jpg&quot; &gt;

圏論では、いろいろな種類の矢印を使うし、激しくオーバーロード（多義的使用）するから混乱しないように。難しいんだけどね。

&lt;hr&gt;

図の描き方。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-dual.jpg&quot; &gt;

左がストリング図、右がペースティング図（グロービュラー図）。1次元のペースティング図を特にアロー（＆ドット）図と呼んでいるわけね。

&lt;hr&gt;

しりとりだ。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-shiritori-1.jpg&quot; &gt;

これに関してはいろんな反応がありました、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090427/1240792802&quot;&gt;「しりとりごっこの輪」&lt;/a&gt;参照。

&lt;hr&gt;

もっとしりとり。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-shiritori-2.jpg&quot; &gt;

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090424/1240552575&quot;&gt;「完全実装付きでもう一度お送りします、しりとりの圏」&lt;/a&gt;もね。

&lt;hr&gt;

最後のほうに写像の圏も出しました。
&lt;img src=&quot;http://www.chimaira.org/img2/m1-maps.jpg&quot; &gt;

[2]={1, 2}  から [3]={1, 2, 3} への写像は全部でこれだけありますよ。

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090425/1240640213&quot;&gt;「有限集合と写像の圏もJavaScriptで書いてみた、遊んでみてね」&lt;/a&gt;で遊んでみてね。


</body>
</day>
<day date="2009-05-21" title="">
<body>
*1242861823*[リンク]なめらか構造とか

http://golem.ph.utexas.edu/category/2009/05/smooth_structures_in_ottawa_ii.html  からリンクされている論文。僕に体力と気力と時間があるなら、読んでみたいものだが、実際は (略

まずはコレ：

- Title: A Prehistory of n-Categorical Physics (現状は DRAFT VERSION)
- Authors: John C. Baez, Aaron Lauday
- URL: http://math.ucr.edu/home/baez/history.pdf
- 60 pages

&quot;n-Categorical Physics&quot; という言葉だけでシビレルなー。タイトル通り、論文というよりは啓蒙的論説記事という感じ。いつものバエズ節。

- Title: Parallel Transport and Functors
- Authors: Urs Schreiber, Konrad Waldorf
- URL: http://arxiv.org/abs/0705.0452
- 64 pages

↑ バンドルの接続の圏論的な解釈。昔、同じようなこと考えたことがあるな。

- Title: Convenient Categories of Smooth Spaces
- Authors: John C. Baez, Alexander E. Hoffnung
- URL: http://arxiv.org/abs/0807.1704
- 41 pages

↑ なめらか構造に関するサーベイ。普通の可微分構造とはだいぶ違う。一番違うのは、台空間として位相空間を使わないことかな。単なる集合上に、いきなりなめらかな構造を載せている。モデル圏として&lt;b&gt;R&lt;/b&gt;&lt;sup&gt;n&lt;/sup&gt; の部分集合達の圏を使うが、モデル圏も相対化すると、「なめらか」とは一見無関係な圏も「なめらかな圏」となる。チャート（とアトラス）ではなくて、プロットという概念が基本。


</body>
</day>
<day date="2009-05-22" title="">
<body>
*1242952108*[セミナー][JavaScript]N上の離散圏

&lt;b&gt;[追記]&lt;/b&gt;eqObjが定義されていると仮定できるなら、SomeCat.composable(f, g)（fとgの&lt;em&gt;この順での&lt;/em&gt;結合可能性）は次のように書けますね。
&lt;pre class=&quot;code&quot;&gt;
 return SomeCat.eqObj(SomeCat.cod(f), SomeCat.dom(g));
&lt;/pre&gt;
今度からこう書こう。以前のは直さないけど。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;pre class=&quot;code&quot;&gt;
/* DiscCat.js -- Discrete Category over N */

/* 一般的にも使えそうな関数（大域関数） */

// 自然数（0を含む）かどうかを判定する
function isNaturalNumber(x) {
  return (
    typeof x === 'number' &amp;amp;&amp;amp; Math.floor(x) === x
    &amp;amp;&amp;amp;
    x &gt;= 0
  );
}

/* ここから圏の定義 */

// 名前空間を提供するオブジェクト
var DiscCat = {
};

// この圏の対象かどうかを判定
DiscCat.isObject = function(x) {
  return isNaturalNumber(x);
};

// この圏の射かどうかを判定
DiscCat.isMorphism = function(x) {
  return isNaturalNumber(x);
};

// 射の域
DiscCat.dom = function(f) {
  if (!DiscCat.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f;
};

// 射の余域
DiscCat.cod = function(f) {
  if (!DiscCat.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f;
};

// fとgが結合（合成）可能かどうかを判定
DiscCat.composable = function(f, g) {
  if (!DiscCat.isMorphism(f) || !DiscCat.isMorphism(g))
    throw &quot;not a morphism&quot;; //  今回からエラーとする
  return DiscCat.cod(f) === DiscCat.dom(g); // 結合可能性の条件
};

// fとgを結合（合成）
DiscCat.compose = function(f, g) {
  if (!DiscCat.composable(f, g)) throw &quot;cannot compose&quot;;
  return f;
};

// 恒等
DiscCat.id = function(n) {
  if (!DiscCat.isObject(n)) throw &quot;not an object&quot;;
  return n;
};

// 対象のコンストラクタ
DiscCat.obj = function(n) {
  if (!isNaturalNumber(n)) throw &quot;invalid argument&quot;;
  return n;
};

// 射のコンストラクタ
DiscCat.mor = function(n) {
  if (!isNaturalNumber(n)) throw &quot;invalid argument&quot;;
  return n;
};

// 対象が等しいかどうかを判定
DiscCat.eqObj = function(n, m) {
  if (!DiscCat.isObject(n) || !DiscCat.isObject(m))
    throw &quot;not an object&quot;;
  return n === m;
};

// 射が等しいかどうかを判定
DiscCat.eqMor = function(f, g) {
  if (!DiscCat.isMorphism(f) || !DiscCat.isMorphism(g))
    throw &quot;not a morphism&quot;;
  return f === g;
};
&lt;/pre&gt;

*1242952109*[セミナー][JavaScript]N上の掛け算による遷移の圏

&lt;b&gt;[追記]&lt;/b&gt;eqObjが定義されていると仮定できるなら、SomeCat.composable(f, g)（fとgの&lt;em&gt;この順での&lt;/em&gt;結合可能性）は次のように書けますね。
&lt;pre class=&quot;code&quot;&gt;
 return SomeCat.eqObj(SomeCat.cod(f), SomeCat.dom(g));
&lt;/pre&gt;
今度からこう書こう。以前のは直さないけど。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;pre class=&quot;code&quot;&gt;
/* MTNCat.js -- 'Multiplicative Transition over N' Category */

/* 一般的にも使えそうな関数（大域関数） */

// 自然数（0を含む）かどうかを判定する
function isNaturalNumber(x) {
  return (
    typeof x === 'number' &amp;amp;&amp;amp; Math.floor(x) === x
    &amp;amp;&amp;amp;
    x &gt;= 0
  );
}

// 正の自然数かどうかを判定する
function isPositiveNaturalNumber(x) {
  return (
    typeof x === 'number' &amp;amp;&amp;amp; Math.floor(x) === x
    &amp;amp;&amp;amp;
    x &gt; 0
  );
}

/* ここから圏の定義 */

// 名前空間を提供するオブジェクト
var MTNCat = {
};

// 内部的に使うコンストラクタ
function _MTNCat(n, x) {
  if (!isNaturalNumber(n) || !isPositiveNaturalNumber(x))
    throw &quot;invalid argument&quot;;
  this.dom = n;
  this.mult = x;
}

// 射の印字のために
_MTNCat.prototype.toString = function() {
  var s = &quot;*&quot; + this.mult + &quot; : &quot; +
    this.dom + &quot; --&gt; &quot; + (this.dom*this.mult) + &quot;\n&quot;;
  return s;
};

// この圏の対象かどうかを判定
MTNCat.isObject = function(x) {
  return isNaturalNumber(x);
};

// この圏の射かどうかを判定
MTNCat.isMorphism = function(x) {
  return (
    typeof x === 'object' &amp;amp;&amp;amp; x instanceof _MTNCat
  );
};

// 射の域
MTNCat.dom = function(f) {
  if (!MTNCat.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f.dom;
};

// 射の余域
MTNCat.cod = function(f) {
  if (!MTNCat.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f.dom * f.mult;
};

// fとgが結合（合成）可能かどうかを判定
MTNCat.composable = function(f, g) {
  if (!MTNCat.isMorphism(f) || !MTNCat.isMorphism(g))
    throw &quot;not a morphism&quot;; //  今回からエラーとする
  return MTNCat.cod(f) === MTNCat.dom(g); // 結合可能性の条件

};

// fとgを結合（合成）
MTNCat.compose = function(f, g) {
  if (!MTNCat.composable(f, g)) throw &quot;cannot compose&quot;;
  return new _MTNCat(f.dom, f.mult*g.mult);
};

// 恒等
MTNCat.id = function(n) {
  if (!MTNCat.isObject(n)) throw &quot;not an object&quot;;
  return new _MTNCat(n, 1);
};

// 対象のコンストラクタ
MTNCat.obj = function(n) {
  if (!isNaturalNumber(n)) throw &quot;invalid argument&quot;;
  return n;
};

// 射のコンストラクタ
MTNCat.mor = function(n, x) {
  // ここでパラメータチェックは不要、_MTNCatがやるから
  return new _MTNCat(n, x);
};

// 対象が等しいかどうかを判定
MTNCat.eqObj = function(n, m) {
  if (!MTNCat.isObject(n) || !MTNCat.isObject(m))
    throw &quot;not an object&quot;;
  return n === m;
};

// 射が等しいかどうかを判定
MTNCat.eqMor = function(f, g) {
  if (!MTNCat.isMorphism(f) || !MTNCat.isMorphism(g))
    throw &quot;not a morphism&quot;;
  if (f.dom != g.dom || f.cod != g.cod)
    return false;
  if (f.mult != g.mult) {
    return false;
  }
  return true;
};
&lt;/pre&gt;

</body>
</day>
<day date="2009-05-25" title="">
<body>
*1243206277*[JavaScript][圏一般論]有向グラフから作るパスの圏

コードになにか問題があれば、ここに追記します。

&lt;pre class=&quot;code&quot;&gt;
/* PathCat.js */

/*
 * グラフ（有向グラフ）のインターフェース
 *
 * isVertex(x) -- xはグラフの頂点である
 * isEdge(x) -- xはグラフの辺である
 * eqVertex(a, b) -- 頂点aと頂点bは等しい
 * eqEdge(e, f) -- 辺eと辺fは等しい
 * src(e) -- 辺eの根本の頂点
 * trg(e) -- 辺eの行き先の頂点
 * vertex(...) -- 頂点のコンストラクタ
 * edge(...) -- 辺のコンストラクタ // 今回、PathCat側では使わない
 */

/*
 * 圏のインターフェース
 *
 * isObjct(x) -- xは圏の対象である
 * isMorphism(x) -- xは圏の射である
 * eqObj(a, b) -- 対象aと対象bは等しい
 * eqMor(f, g) -- 射fと射gは等しい
 * dom(f) -- 射fの域
 * cod(f) -- 射fの余域
 * id(a) -- 対象aの恒等射
 * composable(f, g) -- 射fと射gは結合（合成）可能である
 * compose(f, g) -- 射fと射gの結合
 * obj(...) -- 対象のコンストラクタ
 * mor(...) -- 射のコンストラクタ
 */

/* 一般的にも使えそうな関数（大域関数） */

function isArray(x) {
  return (
    typeof x === 'object' &amp;amp;&amp;amp; x instanceof Array
  );
}

/* ここから圏（構成）の定義 */

// グラフから圏を作るコンストラク
function PathCat(graph) {
  this.graph = graph;
}

PathCat.prototype.isObject = function(x) {
  return this.graph.isVertex(x);
};

PathCat.prototype.isMorphism = function (x) {
  if (!isArray(x) || x.length &amp;lt; 2) {
    return false;
  }
  var n = x.length - 2; // リスト内の辺の個数
  var g = this.graph;
  if (!(
    // 両端は頂点
    g.isVertex(x[0]) &amp;amp;&amp;amp; g.isVertex(x[n + 1])
  )) return false;
  if (n == 0) {
    return x[0] === x[1];
  }
  // n &gt; 0 のケース
  var srcVertex = x[0];
  for (var i = 1; i &amp;lt;= n; i++) {
    if (!(
      g.eqVertex(srcVertex, g.src(x[i]))
    )) return false;
    srcVertex = g.trg(x[i]);
  }
  if (!(
    g.eqVertex(g.trg(x[n]), x[n + 1])
  )) return false;
  return true;
};

PathCat.prototype.eqObj = function(x, y) {
  return this.graph.eqVertex(x, y);
};

PathCat.prototype.eqMor = function(x, y) {
  if (!this.isMorphism(x) || !this.isMorphism(y))
    throw &quot;not a morphism&quot;;
  var n = x.length - 2; // リスト内の辺の個数
  var g = this.graph;
  if (!(
    g.eqVertex(x[0], y[0]) &amp;amp;&amp;amp; g.eqVertex(x[n + 1], y[n + 1])
  )) return false;
  for (var i = 1; i &amp;lt;= n; i++) {
    if (!g.eqEdge(x[i], y[i])) return false;
  }
  return true;
};

PathCat.prototype.dom = function(f) {
  if (!this.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f[0];
};

PathCat.prototype.cod = function(f) {
  if (!this.isMorphism(f)) throw &quot;not a morphism&quot;;
  return f[f.length - 1];
};

PathCat.prototype.id = function(a) {
  if (!this.isObject(a)) throw &quot;not an object&quot;;
  return [a, a];
};

PathCat.prototype.composable = function(f, g) {
  return (
    this.eqObj(this.cod(f), this.dom(g))
  );
};

PathCat.prototype.compose = function(f, g) {
  if (!this.composable(f, g))
    throw &quot;cannot compose&quot;;
  // ここで、f, gにpopやshiftを使ってはいけない！
  // もとのf, gを破壊してしまう
  var a = new Array();
  var n = f.length - 1;
  for (var i = 0; i &amp;lt; n; i++) {
    a[i] = f[i];
  }
  n--; // ここでnが減っている、注意
  for (var j = 1; j &amp;lt; g.length; j++) {
    a[n + j] = g[j];
  }
  return a;
};

PathCat.prototype.obj = function(/*varargs*/) {
  return this.graph.vertex.apply(null, arguments);
};

PathCat.prototype.mor = function(/*varargs*/) {
  var a = Array.apply(null, arguments);
  if (!this.isMorphism(a)) throw &quot;invalid argument&quot;;
  return a;
};

&lt;/pre&gt;

*1243206472*[JavaScript][圏一般論]有向グラフの例を3つ

コードになにか問題があれば、ここに追記します。

&lt;pre class=&quot;code&quot;&gt;
/* Graph1.js */

var Graph1 = {
};

Graph1.isVertex = function(x) {
  return (x === 0 || x === 1 || x === 2);
};

Graph1.isEdge = function(x) {
  return false;
};

Graph1.eqVertex = function(a, b) {
  if (!Graph1.isVertex(a) || !Graph1.isVertex(b))
    throw &quot;not a vertex&quot;;
  return a === b;
};

Graph1.eqEdge = function(e, f) {
  throw &quot;not an edge&quot;;
};

Graph1.src = function(e) {
  throw &quot;not an edge&quot;;
};

Graph1.trg = function(e) {
  throw &quot;not an edge&quot;;
};

Graph1.vertex = function(n) {
  if (!Graph1.isVertex(n)) throw &quot;invalid argument&quot;;
  return n;
};

Graph1.edge = function() {
  throw &quot;cannot create&quot;;
};
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
/* Graph2.js */

var Graph2 = {
};

Graph2.isVertex = function(x) {
  return (x === 0 || x === 1 || x === 2);
};

Graph2.isEdge = function(x) {
  return (x === &quot;a&quot; || x === &quot;b&quot;);
};

Graph2.eqVertex = function(a, b) {
  if (!Graph2.isVertex(a) || !Graph2.isVertex(b))
    throw &quot;not a vertex&quot;;
  return a === b;
};

Graph2.eqEdge = function(e, f) {
  if (!Graph2.isEdge(e) || !Graph2.isEdge(f))
    throw &quot;not an edge&quot;;
  return e === f;
};

Graph2.src = function(e) {
  if (!Graph2.isEdge(e))
    throw &quot;not an edge&quot;;
  switch (e) {
  case &quot;a&quot; : return 0;
  case &quot;b&quot; : return 1;
  default:
    throw &quot;unbelievable error&quot;;
  }
};

Graph2.trg = function(e) {
  if (!Graph2.isEdge(e))
    throw &quot;not an edge&quot;;
  switch (e) {
  case &quot;a&quot; : return 1;
  case &quot;b&quot; : return 2;
  default:
    throw &quot;unbelievable error&quot;;
  }
};

Graph2.vertex = function(n) {
  if (!Graph2.isVertex(n)) throw &quot;invalid argument&quot;;
  return n;
};

Graph2.edge = function(s) {
  if (!Graph2.isEdge(s)) throw &quot;invalid argument&quot;;
  return s;
};
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
/* Graph3.js */

var Graph3 = {
};

Graph3.isVertex = function(x) {
  return (x === 0 || x === 1 || x === 2);
};

Graph3.isEdge = function(x) {
  return (x === &quot;a&quot; || x === &quot;b&quot; || x === &quot;c&quot; || x === &quot;d&quot;);
};

Graph3.eqVertex = function(x, y) {
  if (!Graph3.isVertex(x) || !Graph3.isVertex(y))
    throw &quot;not a vertex&quot;;
  return x === y;
};

Graph3.eqEdge = function(x, y) {
  if (!Graph3.isEdge(x) || !Graph3.isEdge(y))
    throw &quot;not an edge&quot;;
  return x === y;
};

Graph3.src = function(e) {
  if (!Graph3.isEdge(e))
    throw &quot;not an edge&quot;;
  switch (e) {
  case &quot;a&quot; : return 0;
  case &quot;b&quot; : return 1;
  case &quot;c&quot; : return 1;
  case &quot;d&quot; : return 0;
  default:
    throw &quot;unbelievable error&quot;;
  }
};
Graph3.trg = function(e) {
  if (!Graph3.isEdge(e))
    throw &quot;not an edge&quot;;
  switch (e) {
  case &quot;a&quot; : return 1;
  case &quot;b&quot; : return 2;
  case &quot;c&quot; : return 2;
  case &quot;d&quot; : return 2;
  default:
    throw &quot;unbelievable error&quot;;
  }
};

Graph3.vertex = function(n) {
  if (!Graph3.isVertex(n)) throw &quot;invalid argument&quot;;
  return n;
};

Graph3.edge = function(s) {
  if (!Graph3.isEdge(s)) throw &quot;invalid argument&quot;;
  return s;
};
&lt;/pre&gt;

*1243211953*[JavaScript]はじめて触ったよ

&lt;pre class=&quot;code&quot;&gt;
/* canvaslib.js */

/*
 * 変数canvasにcanvas要素オブジェクト、
 * 変数ctxにキャンバスのグラフィックコンテキスト
 * が入っていると仮定する。
 *
 */

// 指定位置にドット（小さな矩形）を描く
function drawDot(x, y) {
  ctx.fillRect(x, y, 4, 4);
}

// 2点を結ぶ線を描く
function drawLine(x0, y0, x1, y1) {
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.stroke();
  drawDot(x1, y1);
}

// 第一象限内に座標軸に密着した正方形を描く
function drawStdBox(n) {
  ctx.fillRect(0, 0, 5, 5);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(n, 0);
  ctx.lineTo(n, n);
  ctx.lineTo(0, n);
  ctx.lineTo(0, 0);
  ctx.stroke();
}

// キャンバスを完全に再初期化する
function rc() {
  canvas.width = canvas.width + 1;
  canvas.width = canvas.width - 1;
}

// 座標を使いやすいようにセットする
function initCoord() {
  ctx.setTransform(1, 0, 0, -1,
    Math.round(canvas.width/2),
    Math.round(canvas.height/2)
  );
}

// キャンバスを再初期化し、座標系をセットする
function cc() {
  rc();
  initCoord();
}

// 点の配列に従い、折れ線を描く
function drawPolyline(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (var i = 1; i &lt; points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.lineTo(points[0].x, points[0].y);
  ctx.stroke();
}

// 点の配列に従い、多角形を塗りつぶす
function fillPolygon(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (var i = 1; i &lt; points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.lineTo(points[0].x, points[0].y);
  ctx.fill();
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
&amp;lt;html&gt;
  &amp;lt;head&gt;
    &amp;lt;title&gt;canvas&amp;lt;/title&gt;
    &amp;lt;script&gt;
      var canvas = null;
      var ctx = null;
      function initCanvas() {
        canvas = document.getElementById(&quot;canvas&quot;); 
        ctx = canvas.getContext(&quot;2d&quot;);
      }
    &amp;lt;/script&gt;
    &amp;lt;style&gt;
      #canvas {border: 1px solid blue;
    &amp;lt;/style&gt;
  &amp;lt;/head&gt;
  &amp;lt;body onload=&quot;initCanvas()&quot;&gt;
    &amp;lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot; &gt;
      &amp;lt;h1&gt;キャンバスがサポートされていません。&amp;lt;/h1&gt;
    &amp;lt;/canvas&gt;
  &amp;lt;/body&gt;
&amp;lt;/html&gt;
&lt;/pre&gt;

</body>
</day>
<day date="2009-05-27" title="">
<body>
*1243385026*[リンク][セミナー]絵算のプロモーション

知らなかったが：

- http://hibituredure.blogspot.com/2009/03/3.html

&gt;&gt;
結局、絵算というのは何がエキサイティングなんでしょう？
&lt;&lt;

これには答えたいところだ。いつの日か。

*1243385701*[セミナー][圏一般論][M3] 関手、自然変換の例

×は出してもしょうがない例、△は味付けによっては出せるかも。

+ (コ)ホモロジー、ホモトピー ×
+ TQFT △
+ しりとり圏の長さは関手
+ 構文（図式、ラベル付きグラフ）に意味を与える行為はすべて関手
+ 正規表現からオートマトンへの実現関手
+ シングルトン圏&lt;b&gt;1&lt;/b&gt;、2点圏&lt;b&gt;2&lt;/b&gt;などの離散圏からの関手は対象の族
+ 離散圏からの関手のあいだの自然変換は射の族
+ 圏(・→・)からの関手は射
+ 圏(・→・)からの関手のあいだの自然変換は可換四角形
+ 三角形、四角形図式など、ともかく図式はすべて関手
+ 文字列の連接モノイドでも長さが関手
+ Addition over &lt;b&gt;N&lt;/b&gt; の圏でn倍は関手
+ expは関手
+ &lt;b&gt;N&lt;/b&gt;→{1, -1}; n|→(-1)&lt;sup&gt;n&lt;/sup&gt;
+ 単調関数は関手
+ 単調関数のあいだの順序は自然変換
+ 離散圏、余離散圏からの任意の写像は関手
+ グラフ上の長さnの道は関手
+ フラフ上の道の、組み合わせ的ホモトピーは自然変換
+ 基底による行列表示は関手
+ オートマトンの変換（準同型）は自然変換
+ 基底変換の割り当ては自然変換
+ Y&lt;sub&gt;*&lt;/sub&gt;圏の行列表示は関手
+ しりとり文字列の中身（両端を除く）は関手
+ 行列の転置は関手
+ 関係の転置も関手
+ 可達性によるつぶしてしまうのも関手
+ E圏からその商圏への関手がある
+ ベキ集合関手、共変と反変の関手。
+ 環の単元は群になる。これ関手。
+ 列（ちなみにモナド）の反転は自己自然変換（自然同型）

双対は別エントリーにまとめるけど、今思いついたから：

- n項演算を備える代数系と非決定性オートマトンは双対


</body>
</day>
<day date="2009-05-28" title="">
<body>
*1243503423*[後で消す]キーホルダー

もうダメだと思う。もっと大きいの。


</body>
</day>
<day date="2009-05-29" title="">
<body>
*1243576292*[WCC]remoteコマンド

- remote get &quot;http://weather.example.jp/tokyo/today&quot; 

とか。

*1243578325*[モナド][プログラム意味論]モノイダル／カテゴリカル スタンピング

Cがモノイド圏として、Mがモノイド圏Cのモノイド対象のとき、X×M（×は直積とは限らない）によりC上のモノイダルスタンピングモナドができる。×が直積ではない例として：

+ 直和による自明なモノイド（フォールド・モノイド）を使うと、例外モナドになる。
+ ベクトル空間のテンソル積の圏で、代数の加群モナドになる。

直積のモノイダル・スタンピングモナドの背後には、モノイド作用があって、累積されたモノイド作用を作用させる空間（表現空間）に適用することが（プログラミングの用語で）アクションということになる。

ところで、モノイド作用とはモノイドの集合圏への表現のこと。ここで、モノイドを圏に一般化すると、カテゴリカル・スタンピングモナドとそのアクションが定義できそう。射の列を圏の具象表現上で解釈することがアクションになるだろう。

*1243578497*[WCC]JSON HeaderFormat

HTTPヘッダのような形式とJSONの折衷案。フィールドの値がJSONで書けるとけっこう便利だと思う。

あと、2つのヘッダ（フィールドの集まり）をマージするアルゴリズムも何種類か考える必要がある。

*1243579895*[プログラム意味論][TQFT]内部概念と正常値

まずは幾何っぽい話から。境界または角（かど）を許す多様体の圏を考える。Mが多様体なら、境界や角でない点の全体をM&lt;sup&gt;○&lt;/sup&gt; とする。M&lt;sup&gt;○&lt;/sup&gt; はMの内部。

M |→ M&lt;sup&gt;○&lt;/sup&gt; は関手にはならないが、f:M→N で M&lt;sup&gt;○&lt;/sup&gt;⊆N&lt;sup&gt;○&lt;/sup&gt; となるような写像だけの圏を考える。あたりまえだが、この状況では、(-)&lt;sup&gt;○&lt;/sup&gt;が関手になる。

Mがコンパクトのときは M&lt;sub&gt;⊥&lt;/sub&gt; = M 、そうでないときは M&lt;sub&gt;⊥&lt;/sub&gt; = (Mの一点コンパクト化) とする。追加した点がとがった角になるような構造を入れることができるだろう、たぶん（まったく自信ない、まーどっちでもいい）。

以上の状況で、レトラクト M→(M&lt;sup&gt;○&lt;/sup&gt;)&lt;sub&gt;⊥&lt;/sub&gt; とセクション(M&lt;sup&gt;○&lt;/sup&gt;)&lt;sub&gt;⊥&lt;/sub&gt;→M で、M&lt;sup&gt;○&lt;/sup&gt;では恒等なものが作れるかなー？ とか考えた。

多様体の代わりにデータ領域を考えても似たような話になると思う。そのとき、A&lt;sup&gt;○&lt;/sup&gt;は「正常値」の集合。f:A→B が A&lt;sup&gt;○&lt;/sup&gt;⊆A&lt;sup&gt;○&lt;/sup&gt; とは、正常値が正常値に移るので、エラーをまったく起こさない関数で、非常に強い超越的な制限になる。それで、レトラクトとは、正常値じゃない色々な値を全部「単なる個性なしのエラー」とみなすことだろう。

</body>
<comments>
<comment>
<username>everpeace</username>
<body>蒸し返し大変失礼いたします。&lt;br&gt;&lt;br&gt;モノイド圏とはmonoidal categoryの事でよいと思うのですが、&lt;br&gt;モノイド圏上のモノイド対象というのの定義は何でしょうか？&lt;br&gt;&lt;br&gt;一般にモノイド圏の対象をスタンピングするのではモナドにならないと思ったので質問してみました（モノイド積の単位対象スタンピングはunitary isoがあるのでモナドになれると思います）。</body>
<timestamp>1315414685</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&gt; モノイド圏上のモノイド対象というのの定義は何でしょうか？&lt;br&gt;集合圏で普通のモノイドを考えるのと同じように、しかし「直積の代わりにモノイド積、単元集合の代わりにモノイド単位」を使った構造です。&lt;br&gt;「モノイド圏『内』のモノイド対象」といったほうが適切かもしれません。</body>
<timestamp>1315438121</timestamp>
</comment>
<comment>
<username>everpeace</username>
<body>回答ありがとうございます。&lt;br&gt;＞集合圏で普通のモノイドを考えるのと同じように、「直積の代わりにモノイド積、単元集合の代わりにモノイド単位」を使った構造です。&lt;br&gt;なるほど。そういう対象の事をモノイド対象って言うんですね。&lt;br&gt;&lt;br&gt;モノイド圏の対象は一般にはモナドのjoinの制約を満たすM×M=&gt;Mは無いけれど、モノイド対象ってのはこれがあるやつの事を言うんですね。だからスタンピングでモナドができると。&lt;br&gt;&lt;br&gt;理解できました。ありがとうございました。&lt;br&gt;&lt;br&gt;＞「モノイド圏『内』のモノイド対象」といったほうが適切かもしれません。&lt;br&gt;そうかもしれませんね。次から僕も「内」を使っていこうと思います。</body>
<timestamp>1315483249</timestamp>
</comment>
</comments>
</day>
<day date="2009-05-30" title="">
<body>
*1243652868*[indexed/fibred圏][気付いた][山勘]関数計算のエルドラド

Cは圏。End(C)は、Cの自己関手を対象、自然変換が射、関手結合をモノイド積、関手の水平結合を射のモノイド積とするモノイド圏だとする。また、Dがモノイド圏のとき、D内のモノイドの圏をMon(D)とする。

C上のモナドの全体をMnd(C)とすると、Mnd(C) = Mon(End(C))。M∈|Mnd(C)|に対して、そのクライスリ圏を Kl[M] とする。

D = Mnd(C) とすると、Dの対象はモナド（関手圏のモノイド）で、Dの射はモナド準同型となる。M |→ Kl[M] の対応は、どうもD上のindexed圏（共変なのでcoindexed圏だが）になるようだ。

一般に、KがD上のindexed圏のとき、その平坦化（グロタンディーク構成）は次のように定義できる。

+ 平坦化の対象は、A∈D と X∈K[A] の組 (A, X)。
+ (A, X)→(B, Y)である平坦化の射は、f:A→B というDの射と、φ&lt;sub&gt;A&lt;/sub&gt;:X→Y' in K[A]、φ&lt;sub&gt;B&lt;/sub&gt;:X'→Y in K[B] の組(f, φ&lt;sub&gt;A&lt;/sub&gt;, φ&lt;sub&gt;B&lt;/sub&gt;)。ただし、φ&lt;sub&gt;A&lt;/sub&gt;とφ&lt;sub&gt;B&lt;/sub&gt;はfにより引き戻し（または押し出し）の関係になっている。

要するに、クライスリ圏がファイバーとなるバンドルがあり、そのバンドルの接続を使って全空間にも平行四辺形の対角線として射を定義できるってことだ。ファイバー方向に走る射は垂直射、底空間の射を持ち上げただけの射は水平射となる。もちろん、&lt;del datetime=&quot;2009-05-30T16:54:04+09:00&quot;&gt;垂直社も水平斜も&lt;/del&gt;垂直射も水平射も部分圏をなすが、「斜めの射」もあるってことね。Mnd(C)全体を考えるのではなくて、Mnd(C)の部分圏に対しても同じ構成ができる。

この方法を使うと、異なるモナドに関するクライスリ射を結合できる。もちろん、タダで結合できるワケじゃなくて、モナドとモナドの準同型をあいだにはさんでクライスリ圏を重ね合わせるんだけど。

まだ山勘だから勘違いの可能性もあるが、これがホントなら、出来上がった大きな圏は、関数計算のエルドラドだな。圏と幾何学の類似性としても面白い。

*1243653327*[cathand]Catyシェルの機能

cathandは&lt;em&gt;Caty&lt;/em&gt;（キャティ）にリネーム。意味は特にないが、「猫っぽい」くらいな解釈。なにがどう猫っぽいかは不明。

exec ＜ファイル名＞ でスクリプトファイルを実行する。exec は省略できて、単に ＜ファイル名＞ でも同じ。シェルの配下にはたくさんのインタプリタ＝スクリプトエンジンがいて、シェルはファイルに対して適切なインタプリタを選ぶ能力を持つ。

対話専用のコマンドはコロンではじまるとして、:inspect ＜ファイル名＞ でそのファイルのメタ情報を表示する。メタ情報としては：

- そのファイルのインタプリタ
- そのファイルに先立つべきコマンド（スクリプト）
- その他のオプションメタ情報

あるスクリプトと関係づけられたスクリプト、あるいは関係そのものをアソシエーションと呼ぶ。execはアソシエーションを考慮しないで実行する。:expand はアソシエーションを解釈して、当該のファイルの実行を含むスクリプトを書き出す。:expand --rec により再帰的に展開する。

do ＜フィイル名＞ は、ファイルのアソシエーションを再帰的に展開して、それを実行する。アソシエーションの展開は、パイプラインの出口から逆向きに後方展開される。

ちなみに、テンプレートのincludeは、do ＜テンプレートファイル&gt; と同じように働く。

*1243660386*[用語法][indexed/fibred圏]圏バンドル

「indexed圏」という言葉はどうも使いにくい。圏バンドル、あるいは単にバンドルにしようかな、&lt;em&gt;勝手に。&lt;/em&gt;

幾何学のバンドルと同じ言葉にすると、

- 底圏
- ファイバー圏
- 全圏（ただし、グロタンディーク構成）
- 接続（底圏の射に対してファイバー圏の関手が対応している）

*1243660976*[cathand]allowAdditional, extends, restricts

参考：

- [http://d.hatena.ne.jp/m-hiyama/20090519/1242723889:title]
- [http://d.hatena.ne.jp/m-hiyama/20090520/1242793175:title]
- [http://d.hatena.ne.jp/m-hiyama/20090529/1243569521:title]

JSON型システムのことだが、JSONスキーマのadditionalPropertiesはオーバースペックで、あれはいらない気がしてきた。true, falseの値をとるスキーマ属性 allowAdditional があればそれで十分だろう。プロパティワイルドカードも不要になる。デフォルト値は true。allowAdditional = false だと、finalと似てる。が、まったく変更不可能なわけではなくて、既に存在するプロパティの型を強く（厳しく）することはできる。

型システムをorder sortedにしたいなら、単一継承は許すことにして、継承辺（アーク）をinclusion morphismと考えればいいだろう。多重継承を許すと、継承辺から作った自由圏がinclusive subcategoryにならないからダメ。

型Aのインスタンス領域を仮に[A]で表すとして、A extends B のとき、[A]⊆[B] となる。extendsと言いながら、&lt;em&gt;領域は縮小している&lt;/em&gt;から注意！ 弁別子付きユニオン型にも extends と同じメカニズムを入れたい。これは restricts として、次のように書く。

&lt;pre class=&quot;code&quot;&gt;
@type userId = case {&quot;handle&quot; =&gt; string, &quot;num&quot; =&gt; integer}

@type userNumber = case(restricts = userId) 
   {&quot;handle&quot; =&gt;never, &quot;num&quot; =&gt; integer(minimum = 0)}
&lt;/pre&gt;

userNumber restricts userId という関係ができる。extendsとrestrictsは反対のようだが、実は同じで、A restricts B ならば、[A]⊆[B]。

直積に対応するobject構成と、直和に対応するcase構成があって、extends/restricts宣言によりinclusion構造ができるから、包含的半環的圏（inclusive semiringal category）ができる。圏の結合以外に、包含を利用した弱結合（weak composition）を考えると、それがパイプ結合になるだろう。

現実的にはnullの扱いとかがちょっとやっかいな問題。

*1243661096*[セミナー][モナド][M3] こたつミカン・モナド

IOと似てる気がするが、、、

こたつの上のカゴにミカンが入っている。ミカンは自分の小皿に取ってから食べるとする。

+ eat(n) -- 小皿からn個食べる
+ take(n) -- カゴから小皿にn個取る
+ back(n) -- 要らないのでカゴにn個戻す
+ put(n) -- カゴにミカンをn個供給

</body>
</day>
<day date="2009-06-04" title="">
<body>
*1244076004*[気付いた][プログラム意味論]実行と状態遷移

Aが引数値の空間、Bが戻り値の空間、Sが状態空間とすると、「副作用＝状態遷移」を伴う実行は、A×S→S×B という射で記述される。この実行が例外の可能性があり、例外値の空間をEとする。

このとき、実行は A×S→S×B + E かというと、そうではない。例外が起きても状態は消えてなくなるわけではないので、A×S→S×B + S×E だ。S×E は、例外発生後の状態と起きた例外（を表現する値）の組だ。

× と + が分配的ならば、A×S→S×B + S×E は A×S→S×(B + E) と書き直せる。B' = B + E と置けば、A×S→S×B' となり、戻り値の空間を直和スタンピングで拡張するに過ぎない。

ということは、例外があってもなくても事情が変わらないことになる。極論すれば、状態遷移の定式化は例外を考慮する必要がないし、もし必要でも値の空間を細工するだけで、状態空間は何も変わらない。

これは、かなり思考の節約になりそうだ。

*1244101591*[cathand]演算子記号の選択

いつだって悩む。

- ?&amp;lt; タギング（ラップ）演算子
- &amp;lt;! ガード演算子

にしようかな。ガードのほうはかなり感じがでている。

- ! これは壁
- &amp;lt; これは突っこむ方向

*1244101921*[cathand]JSON改2

やっぱり多少の変更は必要だな、とはいっても互換の範囲でできる。

まずはコンベンションの追加：ドル記号からはじまるプロパティ名は特殊目的なので、ユーザーレベルでは使えない、とする。アプリケーションは、知らないドルマーク・プロパティが出てきたらそれはないものとして扱う。つまり、ドル記号ではじまるプロパティはアプリケーションからは見えないし、万が一見えても見てはいけない。

それで、&quot;$case&quot; をタイプタグを入れるフィールドとして使う。&quot;$case&quot; の値はstringまたはinteger。&quot;$val&quot;と一緒に使う。

+ &quot;$case&quot; があれば、それはキー付きユニオン型のデータとみなす。
+ &quot;$val&quot; があれば、&quot;$val&quot;の値を値として採用する。
+ &quot;$val&quot; があるときは、&quot;$val&quot;以外のプロパティはすべて無視される。
+ &quot;$val&quot; がないときは、&quot;$case&quot; を取り除いたオブジェクトを値とみなす。

スキーマ側の変更としては、単なるユニオン型は認めないで、&lt;em&gt;キー付きユニオンだけ&lt;/em&gt;を認める。union {...} という形で定義する。

テンプレート側でも、
&lt;pre class=&quot;code&quot;&gt;
{case}
 {when foo} ...{endwhen}
 {when bar} ...{endwhen}
{endcase}
&lt;/pre&gt;
とか入れたほうがいいかも。Erlang同様、選択肢からはみ出したら例外が起きる。たぶん、これで整合的だと思う。

*1244103155*[cathand][モナド]コマンドの圏

今日書いた記事：
- [http://d.hatena.ne.jp/m-hiyama-memo/20090604/1244076004:title]

と、少し前に書いた：
- [http://d.hatena.ne.jp/m-hiyama-memo/20090530/1243652868:title]

を考えあわせると、直積によるモノイダルスタンピング・モナドがたくさんあるような世界は非常にうまく計算できる気がする。直積の射影と、直積へのモノイド単位を使った埋め込み（x |→ (x, e)）がモナド準同型となるので、これらのモナド準同型を使ってスタンピングモナドのクライスリ射を繋ぎ合わせることができる。

直和に関してもフォールドによる自明モノイドを使うとうまくいく気がする。（未確認）

外枠としては、分配圏を使おうと思う。分配圏は分配代数の圏化。分配代数／圏には、単位元を要求せず、それゆえに適用範囲が拡がるのだが、今回のケースでは：

- 分配圏の乗法（積）は対称モノイド積である。
- 加法にも乗法にも単位元がある。

ということで、分配圏というよりは、より強く対称半環圏（symmetric semiringal category）になっている。

*1244107528*[cathand]キャチフレーズ

- &lt;b&gt;Back To The Good Old Days&lt;/b&gt;

</body>
</day>
<day date="2009-06-05" title="">
<body>
*1244172924*[圏一般論][cathand]分配代数／分配圏

なんだかんだの理由で分配代数／分配圏が面白いんだけどな。今書いている余裕がない。

&lt;b&gt;[以下 追記]&lt;/b&gt;

例を書いておこう。

- まずは、直和と直積を持った集合圏。
- 自然数&lt;b&gt;N&lt;/b&gt;を普通に考えて分配代数
- &lt;b&gt;N&lt;/b&gt;&lt;sub&gt;+&lt;/sub&gt; に順序、足し算、掛け算で分配圏。ただし、0を入れるとちょっと変（壊れはしないか）。0を入れなければ、加法単位対象はない。
- &lt;b&gt;N&lt;/b&gt;に、max-plus代数構造、順序で圏。0が加法と乗法の単位元
- 100以上の偶数とかにしても問題ない
- ベクトル空間の圏に直和とテンソル積、テンソル積は圏論的直積ではない
- Relに直和と直積、直和が圏論的には双積（biproduct）で、&lt;em&gt;直積は圏論的直積ではない。&lt;/em&gt;
- 部分写像の圏に直積、直和。直和は圏論的直和だが、&lt;em&gt;直積は圏論的直積ではない。&lt;/em&gt;

一番最後の例が面白いし、実用上も重要。直和は普通に入射があって余デカルトペアも普通に定義できる。[f, g]を余デカルトペアリング、D(f)を有効定義域（域ではない）とすると、D([f, g]) = D(f) + D(g)。⊥を入れて基点付き集合考えると、2つの⊥を同一視した直和が圏論的直和に対応。形式的にデカルトペアリングは作れるが、デカルトペアの公理は満たさない。だが、この偽デカルトペアも重要だし役に立つ。

*1244189912*[リンク][高次圏論]コゥゼン先生登場

n-Category Cafeにデクスター・コゥゼンの名前が：

- http://golem.ph.utexas.edu/category/2009/05/metric_coinduction.html

コゥゼン先生の論文は：

- Title: Applications of Metric Coinduction
- Authors: Dexter Kozen1 and Nicholas Ruozzi
- URL: http://www.cs.cornell.edu/~kozen/papers/MetricCoind.pdf


</body>
</day>
<day date="2009-06-08" title="">
<body>
*1244418960*[cathand]簡易IDLで使う動詞

- throws もちろん、例外を投げる
- consults （管理下の）状態遷移系に対して問い合わせだけを発する
- operates （管理下の）状態遷移系に対して遷移を引き起こす
- emits イベントやメッセージを（管理外である）環境の外部に発行する

管理下とか管理外は環境＝システム境界がハッキリしないと定義できない。

&lt;pre class=&quot;code&quot;&gt;
function ensureUser :: userName:string -&gt; boolean
   throws BadArg 
   consults UserDB  operates Logging ;
&lt;/pre&gt;

*1244420399*[JavaScript]時間がねーから未完成版

&lt;pre class=&quot;code&quot;&gt;
// mccircle.js -- Monte Carlo method 

/*
 * 座標形はキャンバス中心を原点とする数学方式に
 * 設定されていることを前提とする。
 * 
 * 大域変数canvasにキャンバスが、
 * 大域変数ctxにanvasの2Dコンテキストが入っているとする。
 */

var inner = 0; // 円の内部の点の個数
var outer = 0; // 円の外部の点の個数


/*
 * 0≦x≦w, 0≦y≦h である整数乱数の組を返す。
 */
function randomPair(w, h) {
  var x = Math.random();
  var y = Math.random();
  // x, yを上書き再利用
  x = Math.floor(x*w);
  y = Math.floor(y*w);
  return [x, y];
}

/*
 * 点は長さ2の配列で表現する。
 * 最初の要素がx座標
 * 次の要素がy座標
 */
function drawPoint(pt)  {
  var x = pt[0];
  var y = pt[1];
  var color;
  if (Math.sqrt(x1*x1 + y1*y1) &amp;lt;= 200) {
    color = &quot;red&quot;;
    inner++;
  } else {
    color = &quot;blue&quot;;
    outer++;
  }
  ctx.fillStyle = color;
  ctx.fillRect(x, y, 2, 2); // 小さな四角を描く
}

function plotPoints(N) {
  for (var i = 0; i &amp;lt; N; i++) {
    drawPoint(randomPoint(400, 400));
  }
}

var tid = 0; // タイマーID

function doDraw() {
  tid = setInterval(&quot;plotPoints(1000)&quot;, 0.5*1000);
}
&lt;/pre&gt;

</body>
</day>
<day date="2009-06-10" title="">
<body>
*1244593728*[cathand]JSONスキーマ属性のスキーマ

- http://d.hatena.ne.jp/m-hiyama/20090610/1244593278

これをもとに、スキーマ属性のスキーマを書こう。


</body>
</day>
<day date="2009-06-11" title="">
<body>
*1244679146*[cathand]HTTPメソッドとコマンド

[http://d.hatena.ne.jp/m-hiyama/20090610/1244594987:title] で書いた細分化されたメソッドを使うことにして：

|* HTTPメソッド |* クライアント動詞 |* シェルコマンド |
| get | exec, edit, view, inspect | print, dump |
| put | save           | write |
| delete| delete       | delete |
| head  | inspect      | meta |
| generate| new        | new |
| append| append, insert| append |
| process| view_result | exec |
|     -  | -           | read |

まだ考えないと。

&lt;pre class=&quot;out&quot;&gt;
$ read FILE | some_command | print TEMPLATE
&lt;/pre&gt;

みたいなコマンドラインが典型例かな。

*1244679526*[cathand][リンク]最小ファイルシステム関係

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090603/1244010863 &quot;&gt;最小抽象ファイルシステムの仕様案&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090604/1244100697&quot;&gt;最小抽象ファイルシステムの仕様案 その2&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090608/1244419502&quot;&gt;最小抽象ファイルシステムの仕様案 その3&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090610/1244594987&quot;&gt;HTTPメソッドの正統的使い方と現実的対処法&lt;/a&gt;

*1244686932*[cathand]総称型とJSONスキーマ属性

Set&amp;lt;X&gt;, Bag&amp;lt;X&gt; のような型を導入は&lt;em&gt;しない&lt;/em&gt;で同じことをしたいなら：

- arrayのスキーマ属性に unique と unordered を入れる
- unique = true なら同じ項目を許さない。
- unordered = true なら項目の出現順序は気にしない。
- unorderedのときはソートしたものを正規形としてよい。
- だが、ソートの負担がかかる。
- Erlangのなんでもかんでもソートできるのはスゴイな。

*1244710433*[リンク][cathand]JSONの参照構文

- http://www.json.com/2007/10/19/json-referencing-proposal-and-library/

*1244710434*[cathand]JSONスキーマに足したい属性

[http://d.hatena.ne.jp/m-hiyama-memo/20090611/1244686932:title]にも書いたが、繰り返して、もう少し追加：

|* 適用対象|*  スキーマ属性名 |* 意味 |* 値の型 |* デフォルト値 |
| array    | unique           |重複を許さない| boolean | false |
| array    | unordered |順序を考慮しない | boolean | false |
| object | nameCaseSensitive | プロパティ名のケースを区別するか | boolean | ture |
| object | nameFormat | プロパティ名を制限する仕様名 | string | なし |
| object | namePreserveCase | ケースの正規化を行わない | boolean | true |
| object | valueRequires | requiresと同じだが値も付ける | ペアの配列 | なし |

valueRequiresの使用例：
&lt;pre class=&quot;code&quot;&gt;
&quot;endian&quot; : string(valueReauires = [[&quot;isText&quot;, true], [&quot;encodieg&quot;, &quot;utf-16&quot;]],
             enum = [&quot;big&quot;, &quot;little&quot;])
&lt;/pre&gt;

</body>
</day>
<day date="2009-06-15" title="">
<body>
*1245023879*[cathand]ファイルのネーミング

'.'、'_' ではじまる名前はやっぱり外部からはアクセス禁止だろう。それと、'--' （ハイフン2個）を含む名前のファイルは、トークン（ワンタイムチケット）なしではアクセスできない、としようかな。

- register--.cgi
- --register.cgi
- register--retry.html
- register--ok.html
- register--confirm.html
- register--finished.html

拡張子に関してはホワイトリスト方式。ホワイトリストにないならアクセスできない。

*1245023738*[説明]述語、ガード、レトラクトの相互変換

&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20090612/1244785846&quot;&gt;「Erlangのコーディングから、述語、ガード、レトラクト、そしてモナド」&lt;/a&gt;で書いた、引数チェックの3つの方式、述語、ガード、レトラクト（フィルター）ですが、当然に相互変換できます。すべての相互変換を書き下してみます（構文はJavaScript）

&lt;h5&gt;述語 → ガード&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function guard(arg) {
 if (pred(arg)) {
  return true;
 } else {
  throw &quot;error&quot;;
 }
}
&lt;/pre&gt;

&lt;h5&gt;ガード → 述語&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function pred(arg) {
 try {
  guard(arg);
  return true;
 } catch (e) {
  return false;
 }
}
&lt;/pre&gt;

&lt;h5&gt;述語 → レトラクト&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function retr(arg) {
 if (pred(arg)) {
  return arg;
 } else {
  throw &quot;error&quot;;
 }
}
&lt;/pre&gt;

&lt;h5&gt;レトラクト → 述語&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function pred(arg) {
 try {
  var x = retr(arg);
  return true;
 } catch (e) {
  return false;
 }
}
&lt;/pre&gt;

&lt;h5&gt;ガード → レトラクト&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function retr(arg) {
 guard(arg);
 return arg;
}
&lt;/pre&gt;

&lt;h5&gt;レトラクト → ガード&lt;/h5&gt;

&lt;pre class=&quot;code&quot;&gt;
function guard(arg) {
 var x = retr(arg);
 return true;
}
&lt;/pre&gt;


</body>
</day>
<day date="2009-06-16" title="">
<body>
*1245143128*[気付いた][cathand][プログラム意味論][モナド]直和自明モナド、直積自明コモナド

余対角∇:A+A→A を積、始対象からの唯一射θ&lt;sub&gt;A&lt;/sub&gt;:0→Aを単位とすると、直和に対するモノイダル・スタンピング・モナドができる。これは対象Aで添字付けられる。つまり、対象と同じだけ直和自明モナドが存在する。

同様にして、対角Δ:A→A×Aを余積、終対象への唯一射!&lt;sub&gt;A&lt;/sub&gt;:A→1を余単位とするとコモノイドができる。これにより、対象と同じだけのコモノイダル・スタンピング・コモナドができる。こっちは、直積自明コモナド。

直和自明モナドは、部分関数の表現や単純な例外処理に対応する。自明ではあるが、つまらなくはない。一方の直積自明コモナドはホントにつまらないように思える。がそうでもない、と気付いた。

メイヤー方式のQuery/Commandインターフェースを持つオブジェクトをシステムコンポネントと呼ぶことにする。Sがシステムコンポネントで、fが関数のとき、

- f:A→B consults S

は、fが明示的な引数（型はA）以外に、Sへの問い合わせも発行することを示す。Sから得られる値の集合を[S]とすると、f:A×[S]→B となる。(-)×[S]を直積スタンピング・コモノイドと考えてFとする。Fの余クライスリ圏をCoKl(F)とすると、CoKlは、ベース圏上のコモナドの圏（ベース圏上の自己関手の圏のコモノイドの圏）の上の圏バンドルになっている。とはいえ、コモナドがベース圏の対象で添字付けられているので、バンドルのベースが最初のベース圏だと思ってよい。

つまり、ベース圏（バンドルのベースとは別な概念）上に直接クライスリ圏が生えているような状況になる。この圏バンドルの平坦化がコモナド計算の舞台となるだろう。

「ベース圏」という用語が曖昧だから、用語法を工夫する必要があるが、ともかく、(対象|→直積スタンピング・コモナド) という対応があり、対象ごとに余クライスリ圏がある。余クライスリ射、直積スタンピング・コモナドFのF代数だともみなせる。

モナド／コモナドの議論としては異常に単純なのだが、プログラミングとしてはそれなりの意味があると思う。


</body>
</day>
<day date="2009-06-17" title="">
<body>
*1245213956*[cathand]空文字列の解釈

アタマ・イターー。

|* データ型 |* 空文字列 |
| integer, number    | undefined |
| string    | 不明      |
| non-empty string | undefined |
| boolean   | undefined |
| null      | undefined |

問題は、データ型がstringでデータが&quot;&quot;のときだけか。

textとかtextareaの解釈をnon-empty stringとするか。どうしても空列が欲しいときは、{e, n}×NEString を Empty + NEString にマップして使うか。textフィールド以外に フラグとなるラジオボタンが必要なる。入力はスンゲーバカバカしいが、滅多に使われないから許されるかも。

あとは、代替記号（ドルマーク一個とか&quot;&quot;とか）を使う。代替記号はその場の都合で選ぶしかないな。
&lt;pre class=&quot;code&quot;&gt;
string(nunEmpty = true)

string(emptyIndicator = &quot;\&quot;\&quot;&quot;)
&lt;/pre&gt;

*1245210255*[cathand][プログラム意味論]consults宣言

f:A→B consults S は、fがシステムコンポネントに対して問い合わせ（readアクセス）をするということ。これは、fがSをreadonlyモードで要求していることになる。Sがなければfは動かないが、Sへの書き込み（状態遷移操作）はしない。

Sへのreadonlyアクセスだけを許すってことは、Sのreadファセット（ファセットは制限された、あるいは少し改変されたインターフェース）だけを渡すってことだ。あるいは、writeアクセスを監視して、もしwriteすればfを処罰するようなことだろう。

圏論的には、fが、Sによる自明コモナドの余クライスリ射であることを宣言している。

readonlyアクセスがコモナド、writeonlyアクセスがモナドとすると、システムコンポネントのの2つのファセット（readファセットとwriteファセット）を使った、モナド／コモナド構造がシステムコンポネントの意味論になるのかな？

*1245211804*[cathand]JSON処理とカロウビ展開圏

JSONデータにundefinedも入れて、その上でホントの例外⊥も入れた領域を考える。これをJ&lt;sub&gt;⊥&lt;/sub&gt;とする。J&lt;sub&gt;⊥&lt;/sub&gt; 上の計算可能な関数を考えると、対象が1つの圏（モノイド）ができるが、これのカロウビ展開圏 KE(J&lt;sub&gt;⊥&lt;/sub&gt;)を作る。

JSON処理関数（コマンド）の最初の意味論は、このカロウビ展開圏KE(J&lt;sub&gt;⊥&lt;/sub&gt;)のなかで作れる気がする。これにモナド／コモナドを入れて、クライスリ／余クライスリ圏を生やした圏バンドルを作り、最終的には平坦化したファイバー圏を作ればいいのだろう、たぶん。

</body>
</day>
<day date="2009-06-18" title="">
<body>
*1245295583*[形式言語理論][cathand]再帰方程式系とパス方式定義

JSONスキーマ言語の話。

BNFは、再帰方程式系（Recursive System of Equations, Recursive Equational System；ベクトル記法を使うなら a recursive equation）の最小不動点による定義。このとき、基本型（外延的には基本領域）と型構成子（外延的には集合／領域に対する関数）を適当に決めるのだが、これを注意深く決めれば：

- 再帰方程式系とパス方式定義の表現力が等しくなる

ようにできる。

もちろん、型構成子のレパートリがなんでもいいなら上の条件は簡単にクリアできる。要はバランス感覚。実用的に不都合がない程度の表現力を持たせたい。

任意の正規表現を使ってしまうと無理なのだが、列（シーケンス）型について次の制限をする。

- 中間に欠損項目がないタプル（長さは固定）
- 列前半のタプルと、列の残りはクリーニ・スター

また、ユニオン型は常に弁別子付き（discriminated）だとする。

パスとしては、定数パス（固定的に場所を表す）以外に：

- プロパティ名の「その他」ワイルドカード  '*'
- 配列インデックスの「その他」ワイルドカード  '#'
- 弁別子fooによる条件 &amp;lt;foo=&gt;

再帰、または循環的定義を表すには、次の構文を使う。

- PathSpec ::= Path Label? : TypeDesc
- Label ::= '[' Name ']'

ラベルで定義された名前は、別な宣言（PathSpec）の型記述（TypeDesc）に使ってよい。

弁別子条件とラベルは、当面要らない気がする。ワイルドカードは必須だが。

*1245305924*[形式言語理論][cathand]キャズムを超えるな！

『キャズム』って本（http://www.amazon.co.jp/dp/4798101524）があったな。

キャズム（Caty's Schema Modules）では、列の正規表現を許さず強い制限を加える。これは表現力を弱くしてしまうが、安全性が高いし実装容易だし、パス形式のような構文を可能とする。その意味では、CASMの制約を超えた表現力は considered harmful だべよ。

*1245305925*[cathand]HTMLフォーム

fieldset, legend, label, optgroup とか, selectのsize, multiple属性とか、よく知らなかったわね。Webデザイナを志す僕（ウソッ）は、このくらい知らねば。

*1245306729*[プログラム意味論][cathand]consults, affects, operates

Sがシステムコンポネントで、R[S] は「Sのreadファセット」、W[S]は「Sのwriteファセット」とする。メイヤー流インターフェースで言えば、readファセット＝query部分、writeファセット＝command部分。

- f:A→B consults R[S] これは自明コモナド・スタンピングコモナド
- f:A→B affects W[S] これはモノイド・スタンピングモナド
- f:A→B operates S は、f:A→B consults R[S], affects W[S] と同じ。一般的なモナド・コモナド・ペアに制約が加わったものとして捉えられるか？

*1245313244*[気付いた][圏一般論][プログラム意味論][cathand][janus]モジュール接合言語

ゴグエン先生が、MCL（Module Connecting Language）と言っていた。なーんか、今さらではあるが、いきなり分かってしまったよ！ 大局的プログラミング（programming in the large）のMCLのなんたるかを。

記法を色々使うが、圏論記法、中間記法、実用記法としよう。対象が名前の有限集合（指標のもっとも簡単な例）、射がモジュールである圏を考える。

|＼|* 圏論記法 |* 中間記法 |* 実用記法 |
|結合 | M;N    | N[M]      | N[M]      |
|制限 | M;π&lt;sub&gt;A&lt;/sub&gt;| A.M | {a, b}M |
|弱モノイド積| M∨N | M, N | M, N |
|改名 | ρ&lt;sup&gt;a&lt;/sup&gt;&lt;sub&gt;b&lt;/sub&gt; | (b&lt;-a).M | {a'&lt;-a, b'&lt;-b}M|

中間記法と実用記法がほとんど同じだな。（a, b とかが、実用記法では名前、その他では名前の有限列の意味で使われている。こりゃ混乱するだろうが、直さないからカンベン。）

制限は（インターフェースの）ナローイング。M;π&lt;sub&gt;A&lt;/sub&gt; は、正確にはMの余域をYとして、π&lt;sup&gt;Y&lt;/sup&gt;&lt;sub&gt;A&lt;/sub&gt;:Y→A を射影としての結合 M;π&lt;sup&gt;Y&lt;/sup&gt;&lt;sub&gt;A&lt;/sub&gt;。このとき、AはYの部分集合でなくてはならない。「…の部分集合」という概念をフォーマルに定義するには inclusive categoryが必要になるが、今は不要。

改名（リネーミング）は、a, bを重複がない列として、aとbが同じサイズのとき定義される。列aの順序を忘れた集合を |a| とすると、ρ&lt;sup&gt;a&lt;/sup&gt;&lt;sub&gt;b&lt;/sub&gt;:|a|→|b| という射になる。

弱モノイド積は、dom(M)∩dom(N) = 空、cod(M)∩cod(N) = 空 のときだけ定義できるモノイド積。単に有限集合を対象とするならば、完全なモノイド積が定義できるが、実用上の制約から弱モノイド積を定義する。弱モノイド積も完全なモノイド積とほとんど変わらない。弱モノイド積で十分。

実用記法の例をだせば：
&lt;pre class=&quot;code&quot;&gt;
module M = N[{a, b, x&lt;-c}K, {y&lt;-c, d}L, Q];
&lt;/pre&gt;

実用記法では、射影によるナローイングとリネーミングは同じ記法を使う。上の例は次のようにしても実現できる。

&lt;pre class=&quot;code&quot;&gt;
from K import a, b, x&lt;-c;
from L import y&lt;-c, d;
from Q import *;
&lt;/pre&gt;

逆に、importの意味はMCLを使って定義できる。

</body>
</day>
<day date="2009-06-19" title="">
<body>
*1245377017*[気付いた][cathand][janus]モジュールの演算5つはもっと簡単になる

大局的プログラミング（programming in the large）の話題。

ゴグエン先生の論文は &quot;An Implementation-Oriented Semantics for Module Composition&quot; だった。それで、MCLは、Module Composition Language の略でした。しかし、どっかで Connectingも使っていたと思う。

さて、5つのモジュール演算とは、

+ aggrigation 弱モノイド積
+ instantiation 結合
+ renaming, 改名射の結合
+ hiding, 射影＝制限射の結合
+ enriching、内部で結合（import）を実行

これらは結局、モノイド圏の基本演算である「積と結合」、それと特殊な射との結合に還元されてしまう。ここでの特殊な射（の族）とは、

+ 制限射＝射影
+ 改名射＝同型

ということだ。

ところで、import宣言があればMCLは要らないか？ いや、MCLなしでは辛い。importはMCLがあれば別に要らない（あれば便利だ）。MDL（module description/definition language）とMCLをどう折り合い付けるか？ が課題だな。

&lt;pre class=&quot;code&quot;&gt;
package foo.bar;
module M = module {
 ...
};
&lt;/pre&gt;

↑の略記が↓
&lt;pre class=&quot;code&quot;&gt;
package foo.bar;
module M;
 ....
EOF
&lt;/pre&gt;
とか。

MCLによるモジュール定義はこんなかな。
&lt;pre class=&quot;code&quot;&gt;
package foo.bar;

profile K provides a, b, c
     and requires x, y;
profile L provides b, c, d;

module M = K, {e&lt;-b, f&lt;-c, d}L ;
&lt;/pre&gt;

*1245390567*[cathand][リンク]インターネット/Webの原点原典

- Title: Uniform Resource Identifiers (URI): Generic Syntax
- URL: http://www.ietf.org/rfc/rfc2396.txt
- または http://tools.ietf.org/html/rfc2396 (HTML版)

はちゃんと読んだほうがいいかもな、なにしろ原典（原点）中の原典。

原典／原点と言えば、

- Title: The Common Gateway Interface (CGI) Version 1.1
- URL: http://www.ietf.org/rfc/rfc3875.txt
- または http://tools.ietf.org/html/rfc3875

*1245392918*[cathand]やること

- パス形式とBNF形式がほんとに同じことを確認する
- パス形式とBNF形式のそれぞれ、または共通のバリデーションアルゴリズム
- エラーメッセージの解釈と、現実的に使いやすいエラー方式
- ヘッダ情報と環境変数に関する定式化
- XML, JSON, Xion まとめる。
- 特にXionタグを$tagで埋め込む方法。
- $tagがユニオンにも流用できるかどうか
- 直積、直和、キーガード、タグ付けなどを含むスクリプト構文と意味論
- penetrating path に関する構文と意味論

*1245401725*[モナド][プログラム意味論]例外モナドのこととか

A|→A + E が、直和スタンピングモナド、つまり例外モナドだとする。Eを固定した単一モナドでは、モナド乗法 (A + E) + E → A + E は、1回目の計算で起きた例外と、2回目に起きた例外を一緒くたにする。「ともかくも、例外起きたぞ、どこで起きたかは知らんが」ってことね。乗法＝「エラーの出現場所を忘れる」操作。忘れられるのは、エラーがどこで起きても一律一様なエラー情報だから。これが、エラー情報そのものに個性があると一律には扱えない。

別な言い方をすると、複数の計算をまとめて1つの計算とみなせる、ってことね。このためには、複数の計算が同類である必要がある。つまりは、同じクライスリ圏に属するクライスリ射である、と。

エラー情報であるEが違えば、もはや違うクライスリ圏に属するのでそのままストレートにエラー出現位置をつぶすことができない。それで、もっと系統的な計算が必要になる。一般論としては、モナドごとにクライスリ圏を生やした&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090530/1243660386&quot;&gt;圏バンドル&lt;/a&gt;になる。とはいえ、圏バンドルの底として Mnd(C) が必要なわけでもなくて、Cでも十分。

例外モナド（自明モノイドの直和スタンピングモナド）に限ると、モナドはCの対象でインデックスされる。C→Mnd(C) は埋め込みとなり、Cの直和が Mnd(C)（つうかEnd(C)）のモノイド積に移る。埋め込みの像であるEnd(C)の部分圏を考えると、それはCと同型になる（だろう）。直和の対称性が、モナド側ではベック・スワッパーになっているので、任意の２つのモナドを合成（モノイド積）できる。E + F →G のような射（写像）も、モナド側ではモナド準同型になるので、関手結合をあたかも直和のごとく扱った計算ができる。

直積スタンピングのコモナドでも事情は同じ。

裏を取るために、もっとたくさん計算を実行したいのだが、時間と気力が欠けている。

&lt;b&gt;[追記]&lt;/b&gt;計算したいという希望はあるんだけどな。その意味では気力ゼロではない。が、まとまった時間と体力がどうもね。計算て体力使うよ、ほんっとに。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2009-06-20" title="">
<body>
*1245467224*[形式言語理論][cathand]モジュールのenrichment

大局的プログラミング（programming in the large）の話題：

[http://d.hatena.ne.jp/m-hiyama-memo/20090619/1245377017:title]のモジュール演算の件だが：

enrichmentってのがイマイチわからん。が、次のようなもんだと思う。

- module M = (A+B).((from N import A;) + K)

ここで、Aは、Nがprovidesする名前の部分集合（A⊆ cod(N)）、BはKがprovidesする名前の集合（defineする名前の集合の部分集合）。MのなかにN（ただし、Aで制限している）が入り混んでいるので、containmentだとも言える。

importでいったん内側（プレべートな名前空間）に入れて、そのままprovieしている。Kで定義されたBの部分は定義を付け加えたことになる。

- module M = (A.N, B.K)

と同じ。特に、A = cod(N) のときは、

- module M = (N, B.K)

B.K の分だけ追加拡張している。

*1245470527*[セミナー][M3] 関手の例

- 圏M
- 対象 = {u, v, w, x, y z}
- ホムセット M(u, v) ≒ &lt;b&gt;Z&lt;/b&gt;、他も同じ
- 結合 掛け算
- 単位 整数1

- 圏L
- 対象 = {u, v, w, x, y z}
- ホムセット M(u, v) ≒ v = (uの整係数一次式)、他も同じ
- 結合 代入
- 単位 v = v など

- 関手 L→M ；1次の項の係数、
- 関手 M→&lt;b&gt;Z&lt;/b&gt; ；対象を1点につぶす
- 関手 L→2×2行列 ； 係数からアフィン行列を作る
- 関手 2×2行列→&lt;b&gt;Z&lt;/b&gt; ； 行列式


</body>
</day>
<day date="2009-06-22" title="">
<body>
*1245661996*[cathand]fontタグ

邪悪なfontタグにも利用価値がある。&amp;lt;font&gt;... &amp;lt;/font&gt; とすると無害で透明なラッパとして利用できる。spanでもいいのだが、spanより透明性が高い気がする。あとは無害なマイルストーンタグが欲しいが、、、


</body>
</day>
<day date="2009-06-23" title="">
<body>
*1245715673* 田辺さんの単純平面タングル（SPT）圏デモの画面ショット

&lt;span style=&quot;font-size:large&quot;&gt;&lt;em&gt;本編 http://d.hatena.ne.jp/m-hiyama/20090623/1245715012 とまったく同じエントリーですが、画面が原寸大です。&lt;/em&gt;&lt;/span&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090622/1245660033&quot;&gt;「田辺さんの圏論デモ、こりゃオモロー」&lt;/a&gt;で紹介した田辺さんのエントリーに、画面も付きました。

- http://monado.dtiblog.com/blog-entry-74.html

田辺さん、ありがとうございます。

それとは別に、某太田君が画面ショットを送ってくれました。どうもありがとね。メール文面を引用：
&lt;pre&gt;
太田です。

静止画ですが、各パターン撮ってみました
4つの円を左から　1、2、3、4としています。

あの後遊んでいたら、1，2とか3，4という組み合わせだと
延々繋がることがわかりました。

 - 1，2の組み合わせだと必ず交互
 - 3、4の組み合わせだと3、3とかも可
&lt;/pre&gt;

↓が初期状態の画面。
&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo0.jpg&quot; &gt;
&lt;/div&gt;

「&lt;b&gt;4つの円を左から　1、2、3、4としています。&lt;/b&gt;」ということです。

それで、↓は1番と2番の結合。下側に結合の結果が描いてあります。静止画だと分かりにくいけど、1番が2番の穴にはめ込まれてグリグリと回転して位置合わせして、それから境界（円環内部の円）が消えるんだよね。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo1-1_2.jpg&quot; &gt;
&lt;/div&gt;

↓は3番と4番の結合。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo2-3_4.jpg&quot; &gt;
&lt;/div&gt;

次は2番、1番の順で結合↓ 1番、2番のときと比べてください。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo3-2_1.jpg&quot; &gt;
&lt;/div&gt;

↓は4番と3番。3番と4番とは違うでしょ。

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo4-4_3.jpg&quot; &gt;
&lt;/div&gt;

3番と3番も結合可能でこんな↓ 1つ前と同じじゃないよ、星の位置に注意

&lt;div class=&quot;fig&quot;&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/sptdemo5-3_3.jpg&quot; &gt;
&lt;/div&gt;

&lt;hr&gt;

太田君の“発見”についてチョット言っておくと； 4つの射（ヒモ模様）を左から A1, A2, A3, A4 として、円周上の点の個数を勘定すれば、射の域／余域はわかります。次のとおりです。

+ A1:5→7
+ A2:7→5
+ A3:20→20
+ A3:20→20

射の結合可能性（composability）から、A1;A2、A2;A3 などは作れますが、A1;A3 とかは無理です。

太田君曰く：
- 1，2とか3，4という組み合わせだと延々繋がることがわかりました。

A1;A2;A1;A2 とか A3;A4;A4;A3;A3 とかも作れるってことです。

- 1，2の組み合わせだと必ず交互
- 3、4の組み合わせだと3、3とかも可

これは、それぞれの射の域／余域と結合可能性からの帰結です。

</body>
</day>
<day date="2009-06-24" title="">
<body>
*1245809578*[後で消す]プリンタインク

ない。雨のなか買い物はヤダなー。やんでくれ。



</body>
</day>
<day date="2009-06-25" title="">
<body>
*1245916701*[後で消す]アマゾンのレコメンド

アマゾンはよく知っているな。

- http://www.amazon.co.jp/gp/product/0691140499/

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%eb%a1%bc%a5%ea%a5%a8&quot;&gt;ルーリエ&lt;/a&gt;本だよ。


</body>
</day>
<day date="2009-06-26" title="">
<body>
*1246009184*[セミナー][M3]モニャド3 ネタ出し

分類とかイイカゲン、ともかく書き出して、後で整理すべー。

&lt;h5&gt;雑多&lt;/h5&gt;

+ 集合の直積、直和、べき（指数）
+ 特に、指数記号と指数法則； これはカリー化／反カリー化を含む
+ 付点集合の圏 と 二分割構造付き集合の圏
+ 射より、関手や自然変換のほうが具体的
+ 関手も射である。
+ 関手も点（対象）である。
+ 輪切りにすれば次元は下がる。例：膜は矢印になる。
+ 2×2行列の行列式なら力ずく計算でOK
+ すべての集合は圏であり、すべての写像は関手
+ 単調写像も関手
+ モノイド準同型も関手
+ 変形掛け算 (x*y)/2 
+ 構造は、対象物ではなくて、見方の側にある
+ トロピカル計算
+ &lt;b&gt;N&lt;/b&gt;上の更新モノイド
+ 1の3乗根とサイクリック置換

&lt;h5&gt;基本概念&lt;/h5&gt;

+ Obj(C) = Ob(C) = |C|
+ Morph(C) = Mor(C) =~ C  （=~ は乱用）
+ dom, cod, id, comp = ; = ・
+ 図式（条件なし）
+ 可換図式
+ 等式系による記述
+ ホムセット
+ 図式による記述と等式系による記述

&lt;h5&gt;自然数でも見方を変えれば&lt;/h5&gt;

+ 離散圏 |C| = C = &lt;b&gt;N&lt;/b&gt;
+ 余離散圏 |C| = &lt;b&gt;N&lt;/b&gt;, C = &lt;b&gt;N&lt;/b&gt;×&lt;b&gt;N&lt;/b&gt;
+ 普通の順序でやせた圏 |C| = &lt;b&gt;N&lt;/b&gt;, C⊆&lt;b&gt;N&lt;/b&gt;×&lt;b&gt;N&lt;/b&gt;
+ 約数倍数順序でもやせた圏 |C| = &lt;b&gt;N&lt;/b&gt;, C⊆&lt;b&gt;N&lt;/b&gt;×&lt;b&gt;N&lt;/b&gt;
+ 足し算でモノイド |C| = {*} , C = &lt;b&gt;N&lt;/b&gt;、以下同様
+ 掛け算でモノイド
+ 変形足し算でモノイド
+ maxでモノイド （minでは？）
+ 右自明演算でもモノイド （0は単位）

&lt;h5&gt;モノイドで準備体操&lt;/h5&gt;

モノイド＝単対象の圏 射だけ考えればよい。

+ &lt;b&gt;Q&lt;/b&gt;&lt;sub&gt;≧0&lt;/sub&gt; に掛け算を考えたモノイド
+ 変形掛け算 x△y = (x*y)/2 
+ 変形足し算から変形掛け算への指数関数

...[まだ続く、後で。]...


</body>
</day>
<day date="2009-07-11" title="">
<body>
*1247301939*[セミナー][具体例][計算]クライスリ圏ともとの圏

MをC上のモナドとして、K = Kl(C, M)をクライスリ圏とする。対応(-)&lt;sup&gt;--&lt;/sup&gt;:C→K と (-)&lt;sup&gt;∨&lt;/sup&gt;:K→C を次のように定義する。

- X&lt;sup&gt;--&lt;/sup&gt; = X
- (f:X→Y)&lt;sup&gt;--&lt;/sup&gt; = f;ε&lt;sub&gt;Y&lt;/sub&gt;:X→M(Y) (X→Y in K)

- X&lt;sup&gt;∨&lt;/sup&gt; = M(X)
- (k:X→M(Y))&lt;sup&gt;∨&lt;/sup&gt; = M(k);μ&lt;sub&gt;Y&lt;/sub&gt;:M(X)→M(Y)

(-)&lt;sup&gt;--&lt;/sup&gt;と(-)&lt;sup&gt;∨&lt;/sup&gt;が実際に関手であることを計算してみる。単位律と関手性／自然性は使うんだが、結合律使ってないような？


</body>
</day>
<day date="2009-07-13" title="">
<body>
*1247441787*[モナド][計算][山勘]両代数と両クライスリ圏

FがC上のコモナド、Gがモナドのとき、F(X)→G(Y) というCの射を X→Y という射だと思って、両クライスリ圏を構成したい。どうしたらいいか？ という話。

F = (F, δ, ε), G = (G, μ, η) だとする。ほかに、τ::FG⇒GF があるとする。τはスワッパーと呼ぶ。f:F(X)→G(Y), g:F(Y)→G(Z) に対して、

- δ&lt;sub&gt;X&lt;/sub&gt;;F(f);τ&lt;sub&gt;Y&lt;/sub&gt;;G(g);μ&lt;sub&gt;Z&lt;/sub&gt;

として両クライスリ結合が定義できそうだが、τに条件を付けないと両クライスリ圏の構成はできない。

まったくの山勘なのだが、ベックの法則をヒントにすると、次のような等式ではないかと思われる。「|」は自然変換の縦結合、&lt;em&gt;モノイド積としての結合は反図式順の並置&lt;/em&gt;。「|」の優先順は弱い。

- τ|Gε = εG
- Fη|τ = Fη
- δG|Fτ|τF = τ|Gδ
- τG|Gτ|μF = Fμ|τ

ほとんど根拠がないので、当たっていたらラッキー。当たっていたら計算で確認できるが、当たってないと悲惨。

&lt;b&gt;[追記]&lt;/b&gt;計算には、手前味噌だがヤッパリ&lt;a target=&quot;_blank&quot; href=&quot;http://www.chimaira.org/docs/DOTN.htm&quot;&gt;DOTN&lt;/a&gt;が一番強力そうだ。コモノイド法則を書いてみると：

+ δ|εF = F^
+ δ|Fε = F^
+ δ|Fδ = δ|δF

うーん、コンパクト。インデックスxを入れて具体化すると：

+ x.δ ; x.ε.F = (x.F)^
+ x.δ ; x.F.ε = (x.F)^
+ x.δ ; x.F.δ = x.δ ; x.δ.F

&lt;b&gt;[/追記]&lt;/b&gt;

*1247478725*[モナド][計算][山勘]両クライスリ圏構成の準備

とりあえず使う予定の等式を列挙。ここでは&lt;em&gt;反図式順は一切使わずDOTN&lt;/em&gt;。（http://www.chimaira.org/docs/DOTN.htm）

μ::GG⇒G の自然性
- f.G.G ; y.μ = x.μ ; f.G

η::I⇒G の自然性
- f ; y.η = x.η ; f.G

δ::F⇒FF の自然性
- f.F ; y.δ = x.δ ; f.F.F

ε::F⇒I の自然性
- f.F ; y.ε = x.ε ; f 

τ::GF⇒FG の自然性
- f.G.F ; y.τ = x.τ ; f.F.G

Fがコモナドであること
+ δ|εF = F^
+ δ|Fε = F^
+ δ|Fδ = δ|δF

+ x.δ ; x.ε.F = (x.F)^
+ x.δ ; x.F.ε = (x.F)^
+ x.δ ; x.F.δ = x.δ ; x.δ.F

Gがモナドであること
+ ηG|μ = G^
+ Gη|μ = G^
+ Gμ|μ = μG|μ

+ x.η.G ; x.μ = (x.G)^
+ x.G.η ; x.μ = (x.G)^
+ x.G.μ ; x.μ = x.μ.G ; x.μ

ベックの法則
+ τ|εG = Gε
+ ηF|τ = Fη
+ Gδ|τF|Fτ = τ|δG
+ Gτ|τG|Fμ = μF|τ

+ x.τ ; x.ε.G = x.G.ε
+ x.η.F ; x.τ = x.F.η
+ x.G.δ ; x.τ.F ; x.F.τ = x.τ ; x.δ.G
+ x.G.τ ; x.τ.G ; x.F.μ = x.μ.F ; x.τ

</body>
</day>
<day date="2009-07-14" title="">
<body>
*1247534110*[モナド][計算][山勘]両クライスリ圏、ひょとすると、、

ムフフフ、今回の山勘は当たりかもなー。

両クライスリ圏の単位律は証明できた。

まず、両クライスリ圏の恒等 x.ι（恒等もDOTNで書く）を次のように定義する。

- x.ι :=  x.(ε|η) = x.ε ; x.η

図式順両クライスリ結合を f # g として、x.ι # f = f を示せばいい。

&lt;pre&gt;
x.ι # f
// 両クライスリ結合の定義
= x.δ ; (x.ι).F ; x.τ ; f.G ; x.μ
// x.ιの定義
= x.δ ; (x.ε ; x.η).F ; x.τ ; f.G ; x.μ
// Fの関手性
= x.δ ; (x.ε).F ; (x.η).F ; x.τ ; f.G ; x.μ
// Fのコモナド余単位律； x.δ ; (x.ε).F
= (x.F)^  ; (x.η).F ; x.τ ; f.G ; x.μ
// 恒等だから
= x.η.F ; x.τ ; f.G ; x.μ
// ベックの法則・単位律； x.η.F ; x.τ
= x.F.η ; f.G ; x.μ
// ηの自然性； x.F.η ; f.G
= f; x.G.η ; x.μ
// Gのモナド単位律
= f ; (x.G)^
// 恒等だから
= f
&lt;/pre&gt;

この計算で、「Fのコモナド余単位律」「ベックの法則・単位律」「Gのモナド単位律」が、この順で適用されている点に非常に強い必然性を感じる。

まだ安心はできないが、両クライスリ圏が存在する状況証拠は揃ったな。

*1247560042*[モナド][計算][山勘]両クライスリ圏、出来た！

ビンゴッ！！ やったーっ、ひさびさの大当たり。

ベックの法則と簡単な補題を3つ使って結合律を証明できた。分かってしまえば、単純計算。いやー、DOTNは強力だ。絵算とDOTNがなければ、とても計算できかったろう、僕には。

念のためもう一度確認してから書く。両モナド（コモナド＋モナド＋ベックの法則）とその両クライスリ圏の存在は間違いない。コモナドF, モナドGに対して、その両クライスリ圏を DiKl(F, G; C)と書こう。Cが分かっていれば DiKl(F, G)。標準的な関手 C→DiKl(F, G; C) と DiKl(F, G; C) → C を構成しないとね。

*1247563448*[モナド][計算]両モナドと両クライスリ圏

計算手順をざっと書いておこう。

まず、ベックの法則（全部で4つ）のうちの2つ
+ Gδ|τF|Fτ = τ|δG （ベックの法則・余乗法スワップ）
+ Gτ|τG|Fμ = μF|τ （ベックの法則・乗法スワップ）

成分表示なら：
+ x.G.δ ; x.τ.F ; x.F.τ = x.τ ; x.δ.G （ベックの法則・余乗法スワップ）
+ x.G.τ ; x.τ.G ; x.F.μ = x.μ.F ; x.τ （ベックの法則・乗法スワップ）

仮定する3つの両クライスリ射：

+ f:x.F→y.G
+ g:y.F→z.G
+ h:z.F→w.G

変換の自然性の図式に、さらに関手を適用して示せる補題を3つ。

+ f.F ; y.G.δ = x.δ.F ; f.F.F
+ g.G.F ; z.G.τ = y.F.τ ; g.F.G
+ z.F.μ ; h.G = h.G.G ; w.μ.G

定義とベックの法則を使って平坦にしておく。
&lt;pre&gt;
  (f#g) # h 
= x.δ ; (f#g).F ; z.τ ; h.G ; w.μ
// f#g の定義
= x.δ ; (x.δ ; f.F ; y.τ ; g.G ; z.μ).F ; z.τ ; h.G ; w.μ
// Fの関手性
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; z.μ.F ; z.τ ; h.G ; w.μ
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; (z.μ.F ; z.τ) ; h.G ; w.μ
// 括弧内をベックの法則・乗法スワップで展開
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; (z.G.τ ; z.τ.G ; z.F.μ) ; h.G ; w.μ


  f # (g#h)
= x.δ ; f.F ; y.τ ; (g#h).G ; w.μ
// g#h の定義
= x.δ ; f.F ; y.τ ; (y.δ ; g.F ; z.τ ; h.G ; w.μ).G ; w.μ
// Gの関手性
= x.δ ; f.F ; y.τ ; y.δ.G ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
= x.δ ; f.F ; (y.τ ; y.δ.G) ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
// 括弧内をベックの法則・余乗法スワップで展開
= x.δ ; f.F ; (y.G.τ ; y.τ.F ; y.F.τ) ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
&lt;/pre&gt;

f # (g#h) の展開形を、(f#g) # h の展開形まで変形することにして：

&lt;pre&gt;
  x.δ ; f.F ; y.G.τ ; y.τ.F ; y.F.τ ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
= x.δ ; (f.F ; y.G.τ) ; y.τ.F ; y.F.τ ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
// 括弧内に補題(1)
= x.δ ; (x.δ.F ; f.F.F) ; y.τ.F ; y.F.τ ; g.F.G ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; (y.F.τ ; g.F.G) ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
// 括弧内に補題(2)
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; (g.G.F ; z.G.τ) ; z.τ.G ; h.G.G ; w.μ.G ; w.μ
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; z.G.τ ; z.τ.G ; (h.G.G ; w.μ.G) ; w.μ
// 括弧内に補題(3)
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; z.G.τ ; z.τ.G ; (z.F.μ ; h.G) ; w.μ
= x.δ ; x.δ.F ; f.F.F ; y.τ.F ; g.G.F ; z.G.τ ; z.τ.G ; z.F.μ ; h.G ; w.μ
&lt;/pre&gt;

</body>
</day>
<day date="2009-07-15" title="">
<body>
*1247630005*[オフトピック][映画] 映画「レスラー（THE WRESTLER）」を見た

もっとエンタテイメント性があるかと思ったら、辛い、痛い、しんどい映画だったなー。全然元気が出る感じじゃないわ。

しかし、ミッキー・ロークってあんな顔だったかぁ？ 探してみると：

- http://www.youtube.com/watch?v=wRHmXdcA28c

おー、これこれ。伊達男だよな。それが、

- http://www.youtube.com/watch?v=AHJW2GEkF3M&amp;feature=fvw

これだよ。顔も体もモンスターで、レスラーにはホントにはまり役だけど。あれ（後述）以来ボクシングをやっていて、顔が潰れて整形したとか。随分と変わるもんだ。

彼は1952年9月16日生まれ、僕より少し上だ。それで、あの体と動きはたいしたもんだ。スタロンの超・還暦ロッキー＆ランボーもすさまじいけど。

ミッキー・ロークと言えば、なんといっても日本でやった「ボクシングの試合」（1996）だよなー、猫パンチ。オフザケかと思ったが、結局プロボクサーになったらしい。ボクサーで成功したわけでもないようだが、顔はボコボコになったわけだ。

で、ともかく、映画としての出来はだいぶいい。辛く、痛く、しんどいけど。老いたレスラー・ランディ（ラム、劇中の本名は確かラムジンスキー）とその娘ステファニーとストリッパーのパム（店での芸名はキャシディだったかと）のお話。娘に嫌われ拒絶されるシーンは、ほんとに泣けるよ。パムのギゴチナイ献身も泣ける。プロレスラー仲間のはかない友情も泣ける。ラストに流れるブルース・スプリングスティーンの曲も泣ける。泣いてばかりだな。

背中から人を追うカメラがやたらに多いんだけど、あれは気になってイヤだった。ドキュメンタリー風にしたかったのか？ 

*1247631238*[モナド][用語法]（ベックの）分配法則

F, Gがモナドのとき、結合FGをモナドにするため、自然変換τ::FG⇒GFが必要だが、この自然変換自体を分配法則（distributive law）と呼ぶ。変な用語法だがそうなっている。これはやっぱり、LMN 80のJ. Beckの論文&quot;Distributive laws&quot; 1969 が源泉らしい。

「Beckによる」ということを込めて、Beck distributivity とか distributive law in the sense of Beck とかもいう。マクレーン本に、Beck criterion つうのが出てるそうだ -- 見つけられない。

分配法則τの形から（FGとGFの入れ替え）スワッパーとかフリップと呼ばれることもある。僕はベック（Beck）のスワッパーと呼ぶことが多い。実際、スワッパーは片方向不可逆ブレイドという側面がある。スワッパーが可逆だとブレイドにかなり近い。

*1247631704*[用語法]dissociative

あれっ、dissociativeって解離って意味じゃなくて、

- distributive + associative = dis + sociative = dissociative

か。分配結合法則＝分合律。

*1247632646*[モナド][課題]両クライスリ圏の周辺

両モナドと両クライスリ圏の存在がわかったら、課題も大量に出てきたな。

+ C上の両モナドの圏DiMnd(C)の上に両クライスリ圏バンドルを作り、この圏バンドルを調べる。
+ 両クライスリ圏バンドルの平坦化を調べる。
+ DiMnd(C)は、DiMon(End(C))のハズ。で、両モノイドの圏DiMon(D)とは何か？
+ 両モノイドを使って、両クライスリ圏の構成を整理できないか？
+ 随伴とはどういう関係だろう？ 二重随伴（double adjoint）とかもろ手随伴（ambijunction）とかがあるけど。
+ 標準的な関手 C→DiKl(F, G)、DiKl(F, G)→C を作れば事情がわかるかも。
+ 両モナドがあると、アイレンベルク／ムーア圏も構成できると思うのだが。

</body>
</day>
<day date="2009-07-16" title="">
<body>
*1247700676*[リンク][モナド]ベック分配法則関係

アイレンベルク／ムーアと森田も関係する。

- Title: BECK DISTRIBUTIVITY -- Dedicated to the memory of Jon Beck
- Author: MICHAEL BARR
- URL: ftp://ftp.math.mcgill.ca/pub/barr/pdffiles/distlaw.pdf
- 5ページ

- Title: THE EILENBERG-MOORE CATEGORY AND A BECK-TYPE THEOREM FOR A MORITA CONTEXT
- Authors: TOMASZ BRZEZI'NSKI, ADRIAN VAZQUEZ MARQUEZ, AND JOOST VERCRUYSS
- URL: http://arxiv.org/abs/0811.4304?context=math
- 32ページ

- Title: Internal bialgebroids, entwining structures and corings
- Authors: Gabriella Bohm
- URL: http://arxiv.org/abs/math.QA/0311244
- 18ページ

- Title: Operads, clones, and distributive laws
- Author: P-L. Curien
- URL:	http://www.pps.jussieu.fr/~curien/Operads-Strasbourg.ps
- 25ページ

- Title: Homotopy-theoretic aspects of 2-monads
- Authors: Stephen Lack
- URL: http://arxiv.org/abs/math.CT/0607646
- 26ページ
- 注: http://www.emis.de/journals/JHRS/volumes/2007/n2a12/v2n2a12.ps は32ページ

- Title: COALGEBRAS, BRAIDINGS, AND DISTRIBUTIVE LAWS To Aurelio Carboni on his 60th birthday
- Authors: STEFANO KASANGIAN, STEPHEN LACK, AND ENRICO M. VITALE
- URL: http://www.emis.ams.org/journals/TAC/volumes/13/8/13-08.pdf
- 19ページ

*1247700837*[用語法]module, bimodule, algebra

プロ関手（profunctor, distributor）をbimoduleだかmoduleだかと呼ぶ習慣が一部にあるが、これはいくらなんでもヒドイ。論外としておこう。

古典的には、環Rと環Sがあって、アーベル群Aが、左R加群かつ右S加群のとき、R-S両側加群と呼ぶはずだが、両側加群を双加群とも呼ぶのかな？ http://en.wikipedia.org/wiki/Bimodule を読んでみると：both a left and a right module, such that the left and right multiplications are compatible.  -- やっぱり両側加群のことだね。というわけで、bimoduleの標準的な用法は両側加群ということでいいとしよう。

加群または双加群（やっぱり両側加群がシックリ来るな、僕には）の係数環を多元環まで一般化すると、多元環上の双加群概念ができる。ここで多元環と書いたが、普通はalgebraと呼ぶ。この多元環というのは、圏Abにおけるモノイド対象である。このことから、圏のモノイド対象＝内部モノイドを（その圏の）代数と呼ぶことがある。

Cのモノイドを代数と呼ぶことがあるのだから、CのモノイドAとCの対象X、それと左（または右）スカラー乗法 A□X→X をCの加群と言ってよいだろう。このとき、CのモノイドAは代数といったほうが自然。つまり、モノイド圏Cの「代数A上の加群X」という言い方になる。同様に、「代数A, B上の双加群X」とう言い方もできる。

Cが多様体の圏なんかだと、加群という言い方はさすがに変なので、「モノイドAが作用する空間X」と言ったりする。モノイドより群が多いが。スカラー乗法の代わりに作用という。双加群に相当する概念は、2つのモノイド（や群）が左右から作用する空間。

さて、こっからがちょっと困った話。モナドFがあると、F-代数という概念がある。単なる関手Fに対するF-代数も定義できるが、モナドFの代数はモナド演算と協調する公理を備えている。モナドFの代数の全体はAlg(F)と書かれて、Fのアイレンベルク／ムーア圏となる。

問題は、圏CがAbであって、モナドFが圏Cのモノイド（つまり、代数）Aによるスタンピングモナドのときだ。モナドの代数は、F(X)→X という形、つまり、A×X→X で公理を満たす。これは、代数Aの加群のこと。

混乱しそうだから、アイレンベルク／ムーア構成の代数を、EM代数と呼ぶことにすると。圏Cのモナド＝代数AによるスタンピングモナドのEM代数が、「代数Aの加群」なのだ。さらに、モナドがEnd(C)のモノイドだから、End(C)内で、モナド＝モノイド＝代数の加群を考えることが出来る。

+ 代数はモノイドである（同義語として使う）
+ 代数＝モノイドのスタンピングモナドのEM代数を考えられる
+ スタンピングモナドのEM代数は、代数（多元環）の加群である
+ スタンピングモナド自体がモノイドである
+ モナド（代数）の加群を考えることもある

もうまったく無茶苦茶なんだが、歴史的経緯からはしょうがない点もある。最後に、事実だけ述べると：

+ 圏Abのモノイドは、歴史的に代数と呼んでいた。
+ モナドの代数（EM代数）は、作用を持つ集合／空間概念である。
+ モナドの代数（EM代数）は関手の代数と同じ用法だが、関手の代数を代数と呼ぶのは一理ある。
+ 圏Ab上のスタンピングモナドの代数は加群となる。作用はスカラー乗法。
+ モナドもモノイドだから、モノイド＝代数とみなして加群が考えられる。

*1247712311*[用語法][モナド][モノイド圏]H-comodule algebra

Hが余代数（coalgebra）という仮定で、H-comodule algebra という概念が出てきた。なんのことか分からなかったが、順番に考えるとなんとか推測可能。

ベースとなる圏Cはモノイド圏。集合と直積とか、ベクトル空間とテンソル積とか。ここでは、記号×とIを使う。Hが（Cにおいて）余代数ということは、δ:H→H×H という余乗法を持つこと（あと余単位も）。これはコモノイドに他ならないが、Cがベクトル空間＋テンソル積の圏なら余代数と呼ぶのがふさわしい。

余代数H上の余加群Sとは、余作用（coaction）とか余スカラー乗法と呼ばれるΔ:S→H×S を持っていること。代数（モノイド）上の加群概念の双対概念。余代数Hを固定すれば、Comod(H) という圏ができる。射は、余作用を保存する射（例えば線形写像）。

圏Comod(H)のなかで、代数（モノイド）を考えることができる。つまり、Sが余加群だとして、余加群の射 m:S×S→S、e:I→S があって結合律と単位律を満たすこと。

H上の余加群代数の典型例は、Hが双代数のときのH自身。Δ:H→H×H をもとの余乗法として定義すると、Hは余加群。もともと存在していたHの乗法m:H×H→H により代数となる。つまり、双代数は、余代数上の余加群の圏の代数を定める。

*1247715141*[用語法][モナド][その他代数]双代数上の余加群のスワップ

あーそれと、&quot;COALGEBRAS, BRAIDINGS, AND DISTRIBUTIVE LAWS&quot;に載っていた例なんだけど：

Hが双代数のとき、乗法と余単位を組み合わせて r:H×H→I を作れる。これを普遍形式（universal form）と呼ぶらしい。なんで普遍なのかわからんが。τ:V×W→W×V を標準ツイスト（standard twist）とする -- これは直積やテンソル積の順序入れ替え。

VとWが双代数H上の余加群のとき、スワップ V×W→W×V を次のように定義できる。

- τ;(Δ×Δ);(H×τ×V);r×W×V


</body>
</day>
<day date="2009-07-18" title="">
<body>
*1247879743*[用語法][モナド][その他代数][圏一般論]モノイドと作用

加群＝モノイド作用、あるいは、とある圏におけるモノイド作用を加群と呼ぶってことだろう。必ずしも一般的な用語ではないが：

|* 圏     |* モノイド |* 左作用 |* 右作用 |* 両側作用|
|集合     | モノイドM | 左M集合 | 右M集合 | (M, N)集合 |
|k上のベクトル空間   |k-多元環A | 左A加群 | 右A加群 | (A, B)両側加群 |
|アーベル群   | 環R | 左R加群 | 右R加群 | (R, S)両側加群 |
|多様体   | リー・モノイドM | 左M空間 | 右M空間 | (M, N)両側空間 |
|自己関手圏 | モナドF | 左F加群 | 右F加群 | (M, N)両側加群 |


*1247879926*[後で消す]渋谷のマイスペース確認

早めに。


</body>
</day>
<day date="2009-07-21" title="">
<body>
*1248161357*[モナド][モノイド圏]ベックの分配律（Beckスワッパー）の対称性の高い模様

ベックの分配律（Beckスワッパー）を使って複合モナドの結合律を示す途中での対称性の高い図形が出てくる。A = FG だとして、τ:GF⇒FG がスワッパーとして、AAA⇒A（つまり、FGFGFG⇒FG という自然変換の定義なのだが：

- FττG | μτμ | μμ

左端のFと右端のGを垂直な直線で描くと、左右対称で単純な模様ができる。

&lt;img src=&quot;http://www.chimaira.org/img2/beck-swap-unbiased.jpg&quot; &gt;

それがどうした -- こういう綺麗な模様ってのはたいてい何か意味があるもんだよ。




</body>
</day>
<day date="2009-07-22" title="">
<body>
*1248218984*[高次圏論]今、OCatが面白い

「今」とかいう惹句はどうでもいい悪のり。

&lt;b&gt;Ord&lt;/b&gt;を順序集合（poset）と単調写像の圏とする。&lt;b&gt;Ord&lt;/b&gt;で豊饒化された圏、つまり&lt;b&gt;Ord&lt;/b&gt;-CatをOcatとする。固有名詞だから&lt;b&gt;OCat&lt;/b&gt;とすべきだろうが、めんどうだから普通字体。

(後で続き)

*1248222268*[モナド][モノイド圏]Beckスワッパーを使って公平な掛け算

[http://d.hatena.ne.jp/m-hiyama-memo/20090721/1248161357:title]にて：
&gt;&gt;
こういう綺麗な模様ってのはたいてい何か意味があるもんだよ。
&lt;&lt;

綺麗な模様を使って、unbiasedな乗法を定義できる。

- n = 4 のとき： FτττG | μττμ | μτμ | μμ
- n = 5 のとき： FττττG | μτττμ | μττμ | μτμ | μμ
- 以下同様


</body>
</day>
<day date="2009-07-23" title="">
<body>
*1248312941*[リンク][モナド][TQFT]Laudaの絵算論文

Aaron Laudaの論文、Frobenius algebras and planar open string topological field theories 。

- http://arxiv.org/PS_cache/math/pdf/0508/0508349v1.pdf

印刷しようかな。でも66ページあるから、綴じるのに困る。

*1248320980*[お絵描き][モナド]ストリング図、基本のキ

F:C→D、G:D→C のとき、G:C←D と書いてもいいだろう。このアロー図の双対を描くとき、アローから双対ワイヤーへの平面内での向きを時計回りか反時計回りか決めないといけない。これは趣味と習慣以外のナニモノでもないが、アローを時計回りに回してワイヤと決めると：
&lt;pre&gt;
    F
 C ↓ D

   G
 C ↑ D
&lt;/pre&gt;
となる。

F:C→D, G:D→C, α::G;F⇒D ならば、

&lt;pre&gt;
   G      F
D  ↑ C  ↓ D
   ↑    ↓
    ＼＿／
      α
    D 
&lt;/pre&gt;


*1248320981*[高次圏論][モナド]随伴の中間的な定義

2-圏でモナドを定義するときは、ホムセットは使えない。「単位／余単位 ＋ ジグザグ（スネーク）等式」を使う、そのほうが本質的な定義かもしれない。しかし、ホムセットを使った C(X, UA) ≒ D(FX, A) も捨てがたい。

それで、中途半端っちゃそうなんだが、次のような定義を使ってみる。例としては、C=&lt;b&gt;Set&lt;/b&gt;、D = &lt;b&gt;Vect&lt;/b&gt;、Fを自由生成関手、Uを忘却関手とかをイメージ。記法はDOTN使う。

まず余単位 ε:: U;F⇒D  を考える。成分表示では、a∈Dに対して、a.ε:a.U.F→a 。クライスリ圏のときと少し似た感じで、x∈|C|, a∈|D| に対して x→a.U という射を考える。xからaに向かう矢印を、C内で表現したようなもの。Fで、x→a.U をDに送ると、x.F→a.U.F 。余単位 a.U.F→a があるので、次の結合が作れる。

- x.F→a.U.F→a

余単位成分の後結合により、(x→a.U)｜→(x.F→a) という対応が作れる。この対応を、余単位から誘導されたメイト写像と呼ぶ。メイト写像はアジャンゲート（agangate）とも呼ぶが、ホムセット間のメイト関係を定義するからメイト写像でいいだろう。

- 余単位から誘導されたメイト写像が双射であるとき、その余単位の構造を随伴と呼ぶ。

単位から同様にして逆向きのメイト写像が定義できる。単位と双射メイト写像でも随伴が定義できる。

まだ、単位、余単位、2つのメイト写像の関係をハッキリさせないとイカンけれども。
 
</body>
</day>
<day date="2009-07-24" title="">
<body>
*1248391193*[用語法]モノイダルラベリング／スタンピング

-  [google: &quot;monoidal (labelling|labeling|stamping)&quot;]

*1248391981*[リンク][モナド][プログラム意味論]バルボサの長い論文（本？）

- Title: Components as Coalgebras  (2001)
- Author: Luis Manuel Dias Coelho Soares Barbosa
- URL: http://repositorium.sdum.uminho.pt/bitstream/1822/356/1/cac.pdf
- 449ページ

*1248415299*[モナド][プログラム意味論][雑感]ベック・スワッパーで見えるもの

ベック・スワッパーを意図的に使うようになって、なんかが見えてきた気がする。今、Circ-Kleisli（回路クライスリ圏）の再計算を少しずつやっている。以前と違うのは、テンソル強度（tensorial strength）がベック・スワッパーだと理解したこと。

Circ構成（回路構成）を一般化した構成（関手の族を使う）ができるような気がする。これに対称性（包合）を入れたりなんだりで、強度と強モナドの議論を再現できそうだ。いたるところで関手の順序を入れ替える自然変換＝スワッパーが登場する。これはどうも、「弱いブレイド」の理論のようだ。

*1248416514*[モナド]Circ構成の一般化、スワップ公式とスワップ構造

Cが圏で、MとKをEnd(c)の部分モノイドとする。つまり、

- F, F'∈M ならば、FF' = F;;F' もMに入る。
- Cの恒等関手（IとかCとか書く）はMに入る。
- G, G'∈K ならば、GG' = G;;G' もKに入る。
- Cの恒等関手（IとかCとか書く）はKに入る。

K×M でインデックスされた自然変換の族τがある。G∈K, F∈Mに対するτの成分は [G, F]τ と書くことにする。[G, F]τ :: GF⇒FG であり、[G, F]τをGとFのスワッパーと呼ぶ。スワッパー（の族）は次の公理を満たす。

- [I, F]τ, [G, I]τは、それぞれF, Gの恒等自然変換になる。
- [G, FF']τ = ([G, F]τ)F' | F([G, F']τ)
- [GG', F]τ = G([G', F]τ) | ([G, F]τ)G'

これは、対称（置換）やブレイディングに対する同種の公式を弱くしたものである。対称性はなく、片方向だけの主張になっている。

F∈M, G∈K、a, b∈|C| のとき、f:a.F→b.G を両マグマ（通常、両代数と呼ぶが、「代数」を使いすぎなので）と呼ぶ。すべてのF, G, a, bの組み合わせで作られた両マグマの全体をDiMagとする。上記の公理を満たすスワッパー族があれば、DiMagは圏になる。
&lt;hr&gt;

ということをちゃんと述べたいんだけど、まず、End(C)の2つの（同じでもいい）部分モノイドとスワッパー族からなる構造に名前が必要だ -- 思いつかん、暫定的にスワップ構造でいいや。典型例は、モノイド積の掛け算関手達（対象でパラメータ付けされる）とブレイディングによるスワップ。

S = (C, M, K, τ)を、圏C上のスワップ構造とする。両マグマはSから作られるので、DiMag(S)と書く。これを圏にするために、とりあえあず D = DiMag(S) として、|D| = |C| とする。対象はベースの圏と変わらない。a→b である射は、a.F→b.G という両マグマ。この定義ではホムセットが集合であるかどうか保証されないが、まーいいとする。

D = DigMag(S) における恒等射 a→a は、a^:a.I→a.I  として定義する。恒等もCと変わらない。次に結合だが：

- f:a.F→b.G
- g:b.F'→c.G'

に対して、次の定義をする。

- f#g = (f.F' ; [G, F']τ ; g.G) : a.F.F'→c.G'.G

単位律は直ちに示せる。h:c.F''→d.G'' を加えて結合律を示すが、定義より次の2つの式が出てくる。

+ (f.F' ; b.[G, F']τ ; g.G).F'' ; c.[G'G, F'']τ ; h.G'.G
+ f.F'.F'' ; b.[G, F'F'']τ ; (g.F'' ; c.[G', F'']τ ; h.G').G

関手性により展開して：

+ f.F'.F'' ; b.[G, F']τ.F'' ; g.G.F'' ; c.[G'G, F'']τ ; h.G'.G
+ f.F'.F'' ; b.[G, F'F'']τ ; g.F''.G ; c.[G', F'']τ.G ; h.G'.G

両端は揃っているから、次の2つが等しいことを示す。

+ b.[G, F']τ.F'' ; g.G.F'' ; c.[G'G, F'']τ
+ b.[G, F'F'']τ ; g.F''.G ; c.[G', F'']τ.G

まずは、スワップ公式による展開。

+ [G'G, F']τ = G'([G, F']τ) | ([G, F']τ)G
+ [G, F'F'']τ = ([G, F']τ)F'' | F'([G, F'']τ)

これを具体化して、ひとつ上の式に代入すると：

+ b.[G, F']τ.F'' ; g.G.F'' ; c.G'([G, F']τ) ; c.([G, F'']τ)G
+ b.([G, F']τ)F'' ; b.F'([G, F'']τ) ; g.F''.G ; c.[G', F'']τ.G

また両端は等しくなるんで、問題は次の2つの式の等しさになる。

+ g.G.F'' ; c.G'.[G, F'']τ
+ b.F'.[G, F'']τ ; g.F''.G

&lt;hr&gt;

最後に残った等式

- g.G.F'' ; c.G'.[G, F'']τ = b.F'.[G, F'']τ ; g.F''.G

は、τの自然性から得られる。b.F'-(g)→c.G' に対してGF''を適用してみると、

-   b.F'.G.F'' --(g.G.F'')---&gt; c.G'.G.F''

これの自然性を考えると：

&lt;pre&gt;
  (b.F').G.F'' --(g.G.F'')---&gt; (c.G').G.F''
  |                              |
  | [G, F'']τ                   | [G, F'']τ
  |                              |
  v                              v
  (b.F').F''.G --(g.F''.G)---&gt; (c.G').F''.G
&lt;/pre&gt;

書き下してみると：

- g.G.F'' ; (c.G').[G, F'']τ = (b.F').[G, F'']τ ; g.F''.G

目的の等式が得られた。

*1248419326*[モナド][プログラム意味論][課題]次の計算

圏C上のスワップ構造は、End(C)の部分モノイドM, Kと、スワッパーの族{[G, F]τ::GF⇒FG} で与えられる。Cがスワップ構造を持つなら、用語を乱用して、Cはスワップ構造付き圏（category with swap structure）だということにする。ブレイド付きモノイド圏は、自動的にスワップ構造付き圏となる。

Cがスワップ構造付きのとき、C上のモナドTを使って、両マグマ（ダイマグマ）の値域を T で持ち上げたような射を作る。つまり、a.F→b.G.T が射となる。F = G = I のときはクライスリ構成になる。TがIのときは回路構成（の拡張版）となる。つまり、回路構成とクライスリ構成を含むより一般の構成を作る。

次に、コモナドSから同じように回路余クライスリ圏を作る。

それから両クライスリ圏を作ってみる。

双代数上の余加群とかの例も一般化する。

モナド、コモナド、加群（作用）、スワッパーなどをすべて含むような枠組みを探す。

</body>
</day>
<day date="2009-07-25" title="">
<body>
*1248496223*[モナド][雑感]遍在するコモナド、それは計算における空気か

[http://d.hatena.ne.jp/m-hiyama/20090714/1247537588:title]
&gt;&gt;
実際には、副作用を表現するモナドと一緒に、たいていはコモナドも出てきているのですが、ちょっと影が薄いんですよね。
&lt;&lt;

コモナドは影が薄くて目立たない。注目もされない。なぜだろう？ コモナドが珍しいからではなくて、コモナドがあまりにもどこにでもあるせいだろう。コモナドは環境である。仮に純粋関数でも、それが定数を持てば環境（その定数が何であるかの意味）を必要とする。環境を一切必要としないのは、定数をまったく持たない純粋ラムダ計算くらいだ。

コモナドは遍在する。いたるところに存在する。ほとんどいつでも存在する。それとは意識しないが存在する。つまり、空気のようなものだ。空気は影が薄く(?)目立たず注目もされない。あまりにも当たり前の存在だからだ。

コモナドは空気なのだ。空気は目立たないが、だからといって「重要でない」とは言えない。なしで済ませることはできない。実は重要なのだ。

そう、コモナド、重要。

*1248504503*[雑感][モナド][計算][山勘]山勘がまた当たった、好調、それにしても

モナドの計算でヤン・バクスター方程式（＝ライデマイスター移動のIII番）が出て来るだろうとは、なんとなく予想はしていた。だが、えらくアッサリとご登場。あまりにもアッサリ、なにげに登場したので、僕はかえって&lt;em&gt;出会い頭でビックリ&lt;/em&gt;してしまった。

やっぱりそうかぁーーー、という思いはあるんだが、なんつうか、不気味というか、なにかの因縁／必然性を感じてプチ感動というか、、、不思議に複雑な気分だわ。

事情は、それほど難しい話じゃないけど&lt;em&gt;忘れるに決まっている&lt;/em&gt;から、これに関しては近々丁寧に書くつもりだ。

&lt;hr&gt;

写真を撮ってあるので、それを提示して今ザックリとしたメモを書いておこう。

次↓は、スターバックスのナプキン。一度丸めて捨てようとしたのだが、記念(?)にしようと持って帰った（写真を撮った後に捨てたが）。

&lt;img src=&quot;http://www.chimaira.org/img2/ybe-napkin.jpg&quot; &gt;

実際はモナドの計算なんだが、線形代数的な用語で言うと：多元環A上の左加群Mがあるとき、逆転（opposite）乗法を持つ多元環A&lt;sup&gt;op&lt;/sup&gt;上の右加群を構成する話。さまざまなスワップ（ツイストと呼びたい人もいる）と、スワップに関して演算がすり抜け（pass-through）できるという法則が登場する（公理や定理として）。その法則のなかに、次↓のような形のものがある（ナプキンの一部）。

&lt;img src=&quot;http://www.chimaira.org/img2/ybe-napkin-ybe.jpg&quot; &gt;

これはヤン・バクスター方程式に他ならない。普通の結び目の場合とは違い、スワッパー（交差）が2種類ある。絵ではシルシで区別しているが分かりにくい。この「種類」はブレイドの正負（奥行き）とはまったく違う。ほんとに2種類：F-F交差とG-F交差。2種類の交差も含めてのヤン・バクスター型の等式となっている。

ノートに書き写したのが次↓。Fの逆転乗法○とFの右からの作用（スカラー乗法）* を定義している。多元環の乗法○と、右スカラー乗法 * に関して結合律を証明したい、という状況。紙面一番下の絵図等式が示すべき等式だ。

&lt;img src=&quot;http://www.chimaira.org/img2/ybe-right-assoc-1.jpg&quot; &gt;

すり抜け法則を使って変形すると、図の下半分は一致する。結合法則の等式を示すためには、上半分の等しさがあればいいのだが、これがヤン・バクスター型の方程式となっている（紙面の右側に縦に等式が書いてある）。

&lt;img src=&quot;http://www.chimaira.org/img2/ybe-right-assoc-2.jpg&quot; &gt;

つまり、スワップの基本公式（僕は、バニッシング法則とバンドル／アンバンドル法則と名付けた；いつか書く）といくつかのすり抜け（pass through）法則、それとヤン・バクスター型の等式（ライデマイスター移動IIIの類似）があると、左加群から右加群を構成できる。この左から右（あるいは右から左）は、構造のスワップ（ミラー・イメージ）とも言える。

なんで「左から右」（あるいは「右から左」）へのスワップが必要かというと、モナド上の加群（作用）をベースにしてクライスリ構成（の類似）をやろうと思うと、スワップなしではできないからだ。

ベックの分配法則による複合モナドの構成、&lt;del datetime=&quot;2010-06-05T13:23:07+09:00&quot;&gt;モッギ&lt;/del&gt;モッジのテンソル強度（tensorial strength）によるCirc-Kleisli構成、コモナド・モナド対からの両クライスリ構成など、すべて同じ方法を使っている。スワッパー（分配法則、テンソル強度）を使ってクライスリ結合を定義している。

&lt;hr&gt;

2006年1月&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060120/1137724144&quot;&gt;「ソースコードの形式化」&lt;/a&gt;でCirc-Kleisli構成に言及している（もっと前から意識していたと思う）。2006年5月に&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561238&quot;&gt;「懸案のCirc-Kleisli構成をやっと確認できた。」&lt;/a&gt;と書いている。Circ-Klisli構成を作るには、何ヶ月もかかった。しかも、テンソル強度に関しては納得感がないままに計算していた。テキストに書き下す方法も持っていなかった（絵だけ）。

両クライスリ構成（diKleisli構成、biKleisliという言葉が既にあるけど）は、思いついた翌日に計算は終わった（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20090715/1247634707&quot;&gt;「両クライスリ圏が構成できた」&lt;/a&gt;）。

モナド上の加群に関しては、30分程度で確認できた。オマケとしてヤン・バクスター方程式が付いてきた。絵算とDOTNに関してちっとは上達したってことかな。
&lt;hr&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090724/1248419326&quot;&gt;「次の計算」&lt;/a&gt;で書いたように、
&gt;&gt;
モナド、コモナド、加群（作用）、スワッパーなどをすべて含むような枠組みを探す。
&lt;&lt;
この作業が（膨大に）残っている。なにをやっても許される、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090725/1248506622&quot;&gt;天国のような計算体系&lt;/a&gt;があるに違いない。

*1248506622*[モナド]親鸞／フレーゲ天国とクライスリ往生

親鸞つうと、『歎異抄』に出てくるという悪人往生譚ですな：
&gt;&gt;
善人なほもて往生をとぐ、いはんや悪人をや。しかるを、世のひとつねにいはく、悪人なを往生す、いかにいはんや善人をやと
&lt;&lt;

僕にはよく分からん！ が、とりあえず、「ボクは悪い子だ、邪悪なんだ、不純なんだ」と思っている不純計算君がいるとする。そんな不純で汚らわしく悪い子でも、往生できるんだよ、ってハナシ。（と&lt;em&gt;勝手に解釈&lt;/em&gt;する。）

さて、往生するとどこに行くのか？ 極楽だね、あるいは洋風に言えば天国だ。天国では、どんな不純な子でも天使になれる。純粋な存在になれる。

&lt;a target=&quot;_blank&quot; href=&quot;http://en.wikipedia.org/wiki/Gottlob_Frege&quot;&gt;フレーゲ（Frege）&lt;/a&gt;というと、フレーゲの原理（Frege's Principle）というのがある。&lt;a target=&quot;_blank&quot; href=&quot;http://en.wikipedia.org/wiki/Principle_of_compositionality&quot;&gt;Principle of compositionality&lt;/a&gt;だね。フレーゲの「構成性の原理」とか「合成の原理」とかとも言う。「全体は部分の総和である」ということらしい（よく知らん）が、Compositionalityのcompositionを圏論の「結合」と思うと、「何でもちゃんと結合できる、結合からなんでも組み立てられる」と&lt;em&gt;勝手に解釈&lt;/em&gt;。

Compositionalityが成立する世界をフレーゲ天国と呼ぶと、親鸞が言うように悪い子もフレーゲ天国にいけて、そこではピュアな天使になれるのだよ（宗教に関わりのある人は無視してくれ！）。どうやって往生するか？ それは（一般化された）クライスリ構成だよ。

つまり、クライスリ構成で往生すれば、どんな悪人でも天使になりフレーゲの原理を満足できる世界＝「親鸞／フレーゲ天国」に行ける。

</body>
</day>
<day date="2009-07-28" title="">
<body>
*1248747728*[モナド][計算][セミナー][具体例]作用付き両クライスリ圏の行列計算

改行を「/」で表して行列を書くことにする。

W(f) = [1, 0 / f, f+1] がラッピング対応になる。反図式順クライスリ結合を g%f とすると、g%f = g + gf + f となる。gf はgとfの反図式順結合。次が成立する。

- W(g%f) = W(g)・W(f)

普通に計算すれば出る。

</body>
</day>
<day date="2009-07-30" title="">
<body>
*1248911372*[モナド][計算]左右の掛け算（スタンピング）関手と指数法則

関手の結合は図式順とするとき、

- R&lt;sup&gt;A&lt;/sup&gt;(X) = X×A
- &lt;sup&gt;A&lt;/sup&gt;L(X) = A×X

とすると、指数法則の記述がうまくいく。指数法則を記述すると、自然に結合律同型（associator）と単位律同型（unitor）が出てくる。まー、やってみそ。

</body>
</day>
<day date="2009-07-31" title="">
<body>
*1249020278*[モナド][JavaScript]カウンターモナドの演算表を作る

&gt;|javascript|

// モノイド演算（乗法）
function mult(x, y) {
  var r0, r1, r2;
  r0 = y[x[0]];
  r1 = y[x[1]];
  r2 = y[x[2]];
  return [r0, r1, r2];
}

// オペレータの名前
var opName = {
  &quot;u&quot; : [1, 2, 2],
  &quot;d&quot; : [0, 0, 1],
  &quot;U&quot; : [2, 2, 2],
  &quot;D&quot; : [0, 0, 0],
  &quot;X&quot; : [0, 1, 1],
  &quot;Y&quot; : [1, 1, 2],
  &quot;V&quot; : [1, 1, 1],

  &quot;&quot; : [] // dummy
};

// オペレータの名前を探す
function findName(x) {
  for (var n in opName) {
    var y = opName[n];
    if (x[0] == y[0] &amp;&amp; x[1] == y[1] &amp;&amp; x[2] == y[2]) {
      return n;
    }
  }
  return null;
}

// 名前によるモノイド演算
function multByName(a, b) {
  var x = opName[a];
  var y = opName[b];
  var r = mult(x, y);
  var name = findName(r);
  if (name) {
    return name;
  } else {
    return r;
  }
}

// 掛け算九九の表を作る
function makeTable() {
  var names = [&quot;u&quot;, &quot;d&quot;, &quot;U&quot;, &quot;D&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;V&quot;];
  var table = [];
  for (var i = 0; i &lt; names.length; i++) {
    var row = [];
    for (var j = 0; j &lt; names.length; j++) {
      row.push([names[i] ,names[j], multByName(names[i], names[j])]);
    }
    table.push(row);
  }
  return table;
}

// はてなテーブル形式（に近い形）出力
function convertToHatenaTable(table) {
  var textList = [];
  for (var i = 0; i &lt; table.length; i++) {
    var row = table[i];
    var rowText = &quot;|&quot;;
    for (var j = 0; j &lt; row.length; j++) {
      rowText += &quot; &quot; + row[j][2] + &quot; |&quot;;
    }
    rowText += &quot;\n&quot;;
    textList.push(rowText);
  }
  return textList;
}
||&lt;

</body>
</day>
<day date="2009-08-01" title="">
<body>
*1249094276*[セミナー][圏一般論]Basic, Basic, Basic! なこと

人生50年以上やって、やっと納得することもある。いやっ、これは若者に納得してもらわないと困ることなんだが、

- &lt;b&gt;学校の先生が言うことはけっこう正しい。&lt;/b&gt;

曰く：

- 基本が大事だ。
- 一見つまらなそうなことでも、おろそかにしないでやれ。

セミナーの経験から、次のようなことが確実に分かってないことが理解の大きな障壁になっている感じがする。

+ 単元集合（singleton set）ってなに？
+ 単元集合はいくつあるの？
+ 単元集合が同じってどういうこと？
+ 単元集合の元は何でもいいの？
+ どうやって単元集合の元を選ぶの？
+ 単元集合からの写像ってなに？
+ 単元集合への写像ってなに？
+ 単元集合と任意の集合の直積はどうなる？
+ 2つの単元集合の直積は？
+ 2つの単元集合の直和は？
+ 空集合はいくつあるの？
+ 空集合からの写像ってなに？
+ 空集合への写像ってなに？
+ 空集合と任意の集合の直積はどうなる？
+ 空集合と任意の集合の直和はどうなる？
+ 2つ(?)の空集合の直積は？
+ 2つ(?)の空集合の直和は？
+ 定数と関数は違うの？
+ 定数関数ってなに?
+ 定数関数が同じってどういうこと？
+ 関数の引数がないってどういうこと？
+ 関数の戻り値がないってどういうこと？
+ 戻り値がない関数を他の関数に合成できるの？
+ 引数がない関数に引数を渡せるの？
+ 引数を無意味に増やして（水増し）、ほんとに無意味じゃないの？
+ 引数を無視する関数って、役に立つの？
+ 計算は関数なの？
+ 関数は計算なの？
+ 計算式と関数って違うの？

あまりBasicじゃないけど：

+ 文（statement, sentence）とか指令（instruction）、コマンドとかも関数なの？
+ Lispのprognとか、Erlangの「,」ってダメなの？
+ さすがにprint文は関数じゃないでしょ？

</body>
</day>
<day date="2009-08-03" title="">
<body>
*1249260533*[連絡的][講習]サルになる

名前が長めなのは、既存コマンドと名前がかち合わないように。

順不同。すべてフィルターコマンド

+ compact-text
+ find-word word
+ replace-chars chars1 chars2 
+ replace-word word1 word2
+ fold-text width
+ format-col width
+ split-to-words
+ unique-word
+ count-lines
+ line-number width
+ tsv-to-csv
+ csv-to-lsv など
+ select-col colno
+ reverse-str str
+ reverse-file
+ sort-file
+ add-prepost pre post
+ encode-base64

アスキー文字と日本語のギャップは常に問題になる。常に問題になるから、そのうち慣れる。最初は無理せずアスキー限定でOK。

*1249292844*[モナド]コモナドは空気 -- 状況証拠

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090725/1248496223&quot;&gt;コモナドは空気&lt;/a&gt;説を唱えたが、アレはけっこうあっている気がしてきた。

コモナドの圏、つうかむしろセリンガーが言っていた&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=category%20with%20diagonals&quot;&gt;対角付きの圏（category with diagonals）&lt;/a&gt;なのだが、ここでモノイドと加群（モノイド作用）を考えると、なんか具合がいい。双代数法則とか、それの加群版とかが自然に出てくるし、それがまた役に立ったりする。


</body>
</day>
<day date="2009-08-04" title="">
<body>
*1249347220*[圏一般論][具体例]双対風の関手と圏同値

一般的な状況で考えることにして、Cが圏、F:C→C が自己反変関手、δ::Id⇒F;F という自然同型があるとする。このとき、「もとの圏C」と「Fの像となっている圏」は圏同値。具体例は、Cが有限次元ベクトル空間の圏&lt;b&gt;FdVect&lt;/b&gt;で、Fが双対空間／写像を対応させる反変関手。

Cのなかで、あるX∈|C|によりF(X)と書ける対象の全体と、あるf∈CによりF(f)と書ける射の全体は部分圏になるから、これをDとする。D⊆C。DからCへの包含関手をJとする。J:D→C 。&lt;b&gt;FdVect&lt;/b&gt;の例では、Dは、だいたい「なんかの空間の双対空間であるベクトル空間」の圏。

Y∈|D|に対して F(Y)∈|D| となり、g∈D に対して F(g)∈ D となる。したがって、F;F:C→C の余域圏をDに制限することができる。余域圏をDとしたF;FをPとする。P:C→D。

まず、P;J が Id&lt;sub&gt;C&lt;/sub&gt; と同値（関手の自然同型）であることを示す。X∈C に対して、(P;J)(X) = F(F(X))、Xごとに、δ&lt;sub&gt;X&lt;/sub&gt;:Id(X)→F(F(X)) があり自然同型だったので、P;J はId&lt;sub&gt;C&lt;/sub&gt;と同値。

次に、J;P が Id&lt;sub&gt;D&lt;/sub&gt; と同値であることを示す。Y∈D に対して、(J;P)(Y) = F(F(Y))、Yごとに、δ&lt;sub&gt;Y&lt;/sub&gt;:Id(Y)→F(F(Y)) があり、自然同型だったので、J;P はId&lt;sub&gt;D&lt;/sub&gt;と同値。

*1249347221*[モナド][モノイド圏]双モノイド法則

双モノイドを考えると、次の8つの法則候補がある。

+ 乗法は余乗法を保つ。
+ 乗法は余単位を保つ。
+ 単位は余乗法を保つ。
+ 単位は余単位を保つ。
+ 余乗法は乗法を保つ。
+ 余乗法は単位を保つ。
+ 余単位は乗法を保つ。
+ 余単位は単位を保つ。

これらが2つずつペアになって、結局は4つの法則になる。そのなかで、(単位);(余単位) = (自明) という法則はあんまり使わないし地味なので、法則は3つと言ってもいいだろう。んっ？ 無視された1つが可哀想。そうですか、4つにします。

*1249348212*[モナド][JavaScript]カウンター・モナド

&gt;|html|
&lt;html&gt;&lt;!-- counter-monad.html --&gt;
&lt;head&gt;
  &lt;title&gt;Counter Monad&lt;/title&gt;

  &lt;script src=&quot;CounterMonad.js&quot; &gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;Counter Monad&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
||&lt;

&gt;|javascript|
/* CounterMonad.js */

// オペレーション・モノイド
var CounterOp = {
  // 定数
  UP : 117, // 'u' = upオペレーション
  DOWN : 100, // 'd' = downオペレーション

  // モノイド単位
  unit : function() {
    return &quot;&quot;;
  },
  // モノイド乗法
  mult : function(x, y) {
    return (&quot;&quot; + x + y);
  }
};

// カウンター・オブジェクト（シングルトン）
var Counter = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイングする
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  UPPER_BOUND : 9,
  // LOWER_BOUNDは0に固定する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _value : undefined, // 状態値
  _operations : undefined, // 累積オペレーション値
  _action : undefined // オペレーション・リクエストの実行方式

};

/* カウンター・リクエストの実行方式（ストラテジー） */

// 有界カウンタ方式
var BoundedCounterAction = {
  /* カウンターはシングルトンなので、名前で直接参照している。
   * 行儀がいいとは言えないが、よしとする。
   */
  // カウンタのアップ
  doUp : function() {
    if (Counter._value &lt; Counter.UPPER_BOUND) Counter._value++;
  },
  // カウンタのダウン
  doDown : function() {
    if (Counter._value &gt; 0) Counter._value--;
  },
  name : &quot;BoundedCounterAction&quot; // 識別用
};

// サイクリック・カウンタ方式
var CyclicCounterAction = {
  // カウンタのアップ
  doUp : function() {
    if (Counter._value &lt; Counter.UPPER_BOUND) {
      Counter._value++;
    } else {
      Counter._value = 0;
    }
  },
  // カウンタのダウン
  doDown : function() {
    if (Counter._value &gt; 0) {
      Counter._value--;
    } else {
      Counter._value = Counter.UPPER_BOUND;
    }
  },
  name : &quot;CyclicCounterAction&quot; // 識別用
};

/*  以下にメソッド群 */

Counter.init = function(action) {
  Counter._mode = Counter.QUEUE_MODE;
  Counter._value = 0;
  Counter._operations = CounterOp.unit();
  if (action) {
    Counter._action = action;
  } else {
    Counter._action = BoundedCounterAction;
  }
};

Counter.setMode = function(mode) {
  Counter._mode = mode;
};

Counter.operate = function (op) {
  var old = Counter._operations;
  Counter._operations = CounterOp.mult(old, op);
  if (Counter._mode == Counter.DIRECT_MODE) {
    Counter.execOperations();
  }
};

// キューイングされたオペレーションの実行
Counter.execOperations  = function() {
  var ops = Counter._operations;
  for (var i = 0; i &lt; ops.length; i++) {
   var op = ops.charCodeAt(i);
   switch (op) {
    case CounterOp.UP:
     Counter._action.doUp(); break;
    case CounterOp.DOWN:
     Counter._action.doDown(); break;
    default: throw &quot;Unbelievable!&quot;;
   }
 }
 // 累積されたカウンタ操作リクエストをクリアする
  Counter._operations = CounterOp.unit();
};

/* 対話的に使用する便利関数 */
/*
 * start(a) -- 初期化
 *             aにはカウンタ操作の実装を渡す
 *             デフォルトは、BoundedCounterAction
 *             他に、CyclicCounterAction が使える
 * u()      -- カウントアップ
 * d()      -- カウントダウン
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キューの表示
 * v()      -- 値の表示
 * qmode(f) -- キューイングするかどうかの設定
 *             fがtrueならキューイングモードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start(a) {
  Counter.init(a);
}

function u() {
  Counter.operate(&quot;u&quot;);
}

function d() {
  Counter.operate(&quot;d&quot;);
}

function x() {
  Counter.execOperations();
}

function q() {
  return Counter._operations;
}

function v() {
  return Counter._value;
}

function qmode(f) {
  if (f) {
    Counter.setMode(Counter.QUEUE_MODE);
  } else {
    x(); // キューをフラッシュする
    Counter.setMode(Counter.DIRECT_MODE);
  }
};
||&lt;

*1249348301*[モナド][JavaScript]サイクリック・カウンター・モナド

&gt;|javascript|
/* CyclicCounterMonad.js */

// オペレーション・モノイド
var CounterOp = {
  // モノイド単位
  unit : function() {
    return 0;
  },
  // モノイド乗法
  mult : function(x, y) {
    return x + y;
  }
};

// カウンター・オブジェクト（シングルトン）
var Counter = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイング(?)する
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  UPPER_BOUND : 9,
  // LOWER_BOUNDは0に固定する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _value : undefined, // 状態値
  _operations : undefined // 累積オペレーション値
};

/* カウンター・リクエストの実行 */
/*
 * ストラテジーを使わずに、Counter内に直接記述
 */

Counter._action_do = function(ops) {
  Counter._value = (Counter._value + ops) % (Counter.UPPER_BOUND + 1);
};

/*  以下にメソッド群 */

Counter.init = function() {
  Counter._mode = Counter.QUEUE_MODE;
  Counter._value = 0;
  Counter._operations = CounterOp.unit();
};

Counter.setMode = function(mode) {
  Counter._mode = mode;
};

Counter.operate = function (op) {
  var old = Counter._operations;
  Counter._operations = CounterOp.mult(old, op);
  if (Counter._mode == Counter.DIRECT_MODE) {
    Counter.execOperations();
  }
};

// キューイング(?)されたオペレーションの実行
Counter.execOperations  = function() {
  var ops = Counter._operations;
  Counter._action_do(ops); // 実行
 // 累積されたカウンタ操作リクエストをクリアする
  Counter._operations = CounterOp.unit();
};

/* 対話的に使用する便利関数 */
/*
 * start()  -- 初期化
 * u()      -- カウントアップ
 * d()      -- カウントダウン
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キュー(?)の表示
 * v()      -- 値の表示
 * qmode(f) -- キューイング(?)するかどうかの設定
 *             fがtrueならキューイング(?)モードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start() {
  Counter.init();
}

function u() {
  Counter.operate(&quot;u&quot;);
}

function d() {
  Counter.operate(&quot;d&quot;);
}

function x() {
  Counter.execOperations();
}

function q() {
  return Counter._operations;
}

function v() {
  return Counter._value;
}

function qmode(f) {
  if (f) {
    Counter.setMode(Counter.QUEUE_MODE);
  } else {
    x(); // キュー(?)をフラッシュする
    Counter.setMode(Counter.DIRECT_MODE);
  }
};
||&lt;

*1249348511*[モナド][JavaScript]タートル・モナド

&gt;|html|
&lt;html&gt;&lt;!-- turtle-monad.html --&gt;
  &lt;head&gt;
    &lt;title&gt;Turtle Monad&lt;/title&gt;

    &lt;script src=&quot;TurtleMonad.js&quot; &gt;&lt;/script&gt;
    &lt;script&gt;
      var _canvas = null;
      var _ctx = null;
      function initCanvas() {
        _canvas = document.getElementById(&quot;canvas&quot;); 
        _ctx = _canvas.getContext('2d');
      }
    &lt;/script&gt;

    &lt;style&gt;
      #canvas {border: 1px solid blue;
    &lt;/style&gt;

&lt;/head&gt;

&lt;body onload=&quot;initCanvas()&quot;&gt;
&lt;h1&gt;Turtle Monad&lt;/h1&gt;

&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot; &gt;
  &lt;h1&gt;キャンバスがサポートされていません。&lt;/h2&gt;
&lt;/canvas&gt;

&lt;/body&gt;
&lt;/html&gt;
||&lt;

&gt;|javascript|
/* TurtleMonad.js */

// オペレーション・モノイド
var TurtleOp = {
  // 定数
  GO : 1, // 直進
  ROTATE : 2, // 回転

  // モノイド単位
  unit : function() {
    return [];
  },
  // モノイド乗法
  mult : function(a, b) {
    return Array.concat(a, b); // firefox用
  }
};

// タートル・オブジェクト（シングルトン）
var Turtle = {
  // 定数
  QUEUE_MODE : 1, // オペレーション・リクエストをキューイングする
  DIRECT_MODE : 0, // オペレーション・リクエストをすぐに実行する

  // フィールド、ここでは宣言しているだけ、初期化はinitで行う
  _mode : undefined, // 実行モード
  _canvas : undefined, // 描画キャンバス
  _width : undefined, // キャンバス幅
  _height : undefined, // キャンバス高さ
  _ctx : undefined, // 描画コンテキスト
  _x : undefined, // 現在位置のx-座標
  _y : undefined, // 現在位置のy-座標
  _dir : undefined, // 頭が向いている方向（弧度法）
  _operations : undefined // 累積オペレーション値
};


/*  以下にメソッド群 */

Turtle.init = function() {
  Turtle._mode = Turtle.QUEUE_MODE;
  // 大域変数 _canvas, _ctx はHTML側でセットしてくれている
  Turtle._canvas = _canvas;
  Turtle._ctx = _ctx;
  Turtle._width = Turtle._canvas.width;
  Turtle._height = Turtle._canvas.height;
  Turtle._x = 0;
  Turtle._y = 0;
  Turtle._dir = (1/2)*Math.PI;
  Turtle._operations = TurtleOp.unit();
  // 座標を使いやすいようにセットする
  Turtle._ctx.setTransform(1, 0, 0, -1,
    Math.round(Turtle._width/2),
    Math.round(Turtle._height/2)
  );
  // 初期状態の描画
  Turtle.draw();
};

Turtle.setMode = function(mode) {
  Turtle._mode = mode;
};

Turtle.operate = function (op) {
  var old = Turtle._operations;
  Turtle._operations = TurtleOp.mult(old, op);
  if (Turtle._mode == Turtle.DIRECT_MODE) {
    Turtle.execOperations();
  }
};

Turtle.draw = function() {
  // パラメータの設定
  var dirHead = Turtle._dir;
  var dirRight = Turtle._dir + (Math.PI* (3/4));
  var dirLeft = Turtle._dir - (Math.PI* (3/4));
  var x = Turtle._x;
  var y = Turtle._y;
  var r = 10;

  // 描画の実行
  var ctx = Turtle._ctx;
  ctx.clearRect(-Turtle._width/2, -Turtle._height/2,
			Turtle._width, Turtle._height);
  ctx.beginPath();
  ctx.moveTo(x + r*Math.cos(dirHead),  y + r*Math.sin(dirHead));
  ctx.lineTo(x + r*Math.cos(dirRight), y + r*Math.sin(dirRight));
  ctx.lineTo(x + r*Math.cos(dirLeft),  y + r*Math.sin(dirLeft));
  ctx.lineTo(x + r*Math.cos(dirHead),  y + r*Math.sin(dirHead));
  ctx.fill();
};

// タートルの直進 （アクションの実行）
Turtle._action_go = function (r) {
  var x = Turtle._x;
  var y = Turtle._y;
  var dir = Turtle._dir;
  Turtle._x = x + r*Math.cos(dir);
  Turtle._y = y + r*Math.sin(dir);
};

// タートルの回転 （アクションの実行）
Turtle._action_rotate = function (arc) {
  var dir = Turtle._dir;
  Turtle._dir = dir + arc;
};

// キューイングされたオペレーションの実行
Turtle.execOperations  = function() {
  var ops = Turtle._operations;
  for (var i = 0; i &lt; ops.length; i++) {
    var op = ops[i];
    var action = op[0];
    var param = op[1];
    switch (action) {
      case TurtleOp.GO:
	Turtle._action_go(param); break;
      case TurtleOp.ROTATE:
	Turtle._action_rotate(param); break;
      default: throw &quot;Unbelievable!&quot;;
    }
  }
  // 累積されたタートル操作リクエストをクリアする
  Turtle._operations = TurtleOp.unit();
  // 描画
  Turtle.draw();
};


/* 対話的に使用する便利関数群 */
/*
 * start()  -- 初期化
 * fd(r)    -- タートル前方に直進 forward
 * bk(r)    -- タートル後方に直進 back
 * rt(a)    -- タートル右に回転 right 角度aは360度方式
 * lt(a)    -- タートル左に回転 left 角度aは360度方式
 * x()      -- 溜まっているオペレーション・リクエストの実行
 * q()      -- キューの表示
 * qmode(f) -- キューイングするかどうかの設定
 *             fがtrueならキューイングモードになる
 */

// initって名前はナニカとかち合っているようだ（恐い）
function start() {
  Turtle.init();
}

function fd(r) {
  Turtle.operate([[TurtleOp.GO, r]]);
}

function bk(r) {
  Turtle.operate([[TurtleOp.GO, -r]]);
}

function rt(a) {
  Turtle.operate([[TurtleOp.ROTATE, -(a/360)*(2*Math.PI)]]);
}

function lt(a) {
  Turtle.operate([[TurtleOp.ROTATE, (a/360)*(2*Math.PI)]]);
}

function x() {
  Turtle.execOperations();
}

function q() {
  return Turtle._operations;
}

function qmode(f) {
  if (f) {
    Turtle.setMode(Turtle.QUEUE_MODE);
  } else {
    x(); // キューをフラッシュする
    Turtle.setMode(Turtle.DIRECT_MODE);
  }
};
||&lt;

</body>
</day>
<day date="2009-08-05" title="">
<body>
*1249461085*[セミナー][講習]偏見、誤解、曲解など

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090801/1249094276&quot;&gt;「Basic, Basic, Basic! なこと」&lt;/a&gt;の続きみたいな。

次のような傾向がある。困ったことだとも言えるが、だいたいは致し方ないこと。

+ プログラミング言語を通してしか概念や現象を見られない。
+ ハードウェアとしてのコンピュータや、大粒度コンポネントからなるシステム構造などは、単一プログラミング言語では理解できないから、まったくダメ。
+ 関数とか変数とかも、プログラミング言語の定義しか見えてない。
+ モナドやクロージャも言語機能と思っている。
+ 早い段階で習った概念は強い刷り込みになる。
+ 集合／写像が強烈に刷り込まれているのは驚き。
+ 集合／写像に強く縛られているが、実はその概念は曖昧。
+ 写像を考えても、余域は考えてなかったり。
+ 写像の同一性もハッキリと意識してない。
+ 余域と像がゴッチャ。
+ X→Y のとき、X=Y のケースを考えない。考えられない。
+ X→X なんてないと思う。代入や状態遷移の定式化ができない。
+ 引数は、構文上の引き数だけだと思っている。
+ 戻り値は、構文上の戻り値だけだと思っている。
+ メモリの上書き変更は関数じゃないと思っている。
+ それゆえ、破壊的代入やデバイスとのIOは関数で定式化できないと思っている。
+ X→X は id&lt;sub&gt;X&lt;/sub&gt; しかないと思っている。
+ 写像は、単射か全射のどちらかだと思っている。
+ 集合圏で、cod(f)⊆dom(g) なら結合可能だと思っている。（致し方ない）
+ a|→f(a) と f:X→Y がゴッチャ。（致し方ない）
+ 関数そのものと、個別の値-値対応と、式が区別できない。（致し方ない）


</body>
</day>
<day date="2009-08-06" title="">
<body>
*1249531668*[子供][オフトピック]レシピ

材料：豚肉とトウモロコシ

+ 豚肉を、比率 酢1:ケチャップ1 量は適当のタレに付けておく。
+ フライパンに油を引き、つぶしたニンイクも入れる。
+ 豚肉をタレから出して炒める。
+ トウモロコシを包丁でそぎ落としてばらまく。

トウモロコシは事前に処理しておいてもよいが、丁寧にむく必要はない。そぎ落とす。

*1249535952*[用語法][モノイド圏]代数と加群と双対が混じった用語法

阿部さんのホップ代数の本をペラペラめくっていた（読んでいたのではない）。

kが体で、Kはk上の双代数のとき、次のような概念が出てくる。

+ 右K余加群k代数
+ 右K加群k余代数
+ 右K加群k双代数

左も同様に存在する。これらはいったい何かというと： すべてはk上のベクトル空間の圏で考えるとして、次のように記号を約束する。

+ Mon(C) -- 圏Cのモノイドの圏
+ Comon(C) -- 圏Cのコモノイドの圏
+ Bimon(C) -- 圏Cの双モノイドの圏
+ Mod[K] -- 代数K上の加群の圏
+ Comod[K] -- 余代数K上の余加群の圏

双代数は、必要に応じて代数とも余代数とも見る。これだけ準備があれば、話は簡単で：

+ 右K余加群k代数 -- Mon(Comod[K])
+ 右K加群k余代数 -- Comon(Mod[K])
+ 右K加群k双代数 -- Bimon(Mod[K])

ようするに、Mod[-], Comod[-] と Mon, Comon, Bimonの組み合わせで色々な概念が定義できる、ってこと。

</body>
</day>
<day date="2009-08-07" title="">
<body>
*1249616108*[子供][後で消す]待ち合わせ

午後2:30から3:00

*1249616109*[子供][オフトピック]昔のお友達

ボグディンとJJ（ジョセフ・ジロー）とか、あと、ライフの上のマンションにいた子は？アキちゃんだ。

マーヤちゃん、ナオキ君、ゆいちゃん（妹はりなちゃん）、レン君、ヒロキ君、お下げ髪の床屋さんの娘さんは誰だっけ？ メガネかけていた彼？

*1249617352*[モナド][モノイド圏]双モノイド法則の一般化

まず、双モノイド法則（双代数法則）、Δが余乗法でmが乗法だとする。

-  m;Δ = (Δ&lt;sub&gt;A&lt;/sub&gt;×Δ&lt;sub&gt;A&lt;/sub&gt;);(A×τ&lt;sub&gt;A,A&lt;/sub&gt;×A);(m×m)

τはスワッパー。対称性が高いし、絵に描くと綺麗な模様になる。

これを一般化するのに、次の状況を考える。

- Mはモノイド
- Vはコモノイド
- Sは左M加群 作用m
- Sは右V余加群 余作用p
- Vは左M加群 作用n

このとき、

- m;p = (Δ&lt;sub&gt;M&lt;/sub&gt;×p);(M×τ&lt;sub&gt;M,S&lt;/sub&gt;×V);(m×n)

これは、双モノイドに関する双モノイド法則と同じ図形（絵）になっている。

さらに一般化するために、次の仮定をする。

- Mはモノイド
- Vはコモノイド
- Kはモノイド
- Sは左M加群 作用m
- Sは右V余加群 余作用p
- Vは左K加群 作用n
- f:M×S →K という、S側を固定してモノイド射である射がある

このとき、

- m;p = (Δ&lt;sub&gt;M&lt;/sub&gt;×Δ&lt;sub&gt;S&lt;/sub&gt;);(M×f×p);(M×τ&lt;sub&gt;K,S&lt;/sub&gt;×V);(m×n)

ちょと図形は歪む。

他にも法則の候補はある。

*1249632022*[臨時]Jsonic型システム：ユーザー定義のスカラー型

&lt;em&gt;※ 後で本編に移す。&lt;/em&gt;

JSONのスカラー型には、日付時刻や金額などの型がありません。将来的に仕様に導入される可能性はありますが、当面は必要な型をーザー定義して利用することになります。型をユーザー定義できるメカニズムが必要です。ここでは、スカラー型についてだけ述べます。複合型のユーザー定義については別な機会に述べます。

&lt;h5&gt;表現空間&lt;/h5&gt;

JSONにユーザー定義型を導入するとはいっても、JSON構文から逸脱するのは&lt;em&gt;論外&lt;/em&gt;なので、構文的な型式としては、JSONの範囲内に収めます。しかし、意味的にはJSON仕様にはない型を定義することになります。

このような状況をスッキリと説明するために、&quot;XML Schema Datatypes&quot;仕様では、字句空間（lexical space）と値空間（value space）という概念を使っています。これに倣い、JSONベース型システムでも、構文表現の空間と値の空間を区別することにします。ただし、「字句空間」の代わりに「表現空間」（representation space）という用語を使うことにします。「空間」という語に図形的な意味は何もなく、値の集合と同義です。

ユーザー定義型の表現空間は、既存のJSONスカラー型でなくてはなりません。例えば、テストの点数を表す型scoreをユーザー定義するとき、点数は整数で表現するのが妥当でしょうから、表現空間にはintegerを選びます。郵便番号を表す型zipCodeの場合は、文字列で表現するなら表現空間はstring、もし整数値にエンコードして表現するなら表現空間はintegerです。

ユーザー定義型のインスタンスも、その表現はJSONスカラー値となります。例えば、テストの点数47点は、整数 47 で表現されます。郵便番号153-0051は文字列 &quot;153-0051&quot; で表現されます。表現のレベルでは、必ずJSONインスタンスなのです。

&lt;h5&gt;タグ付き値&lt;/h5&gt;

表現を見ただけでは、テストの点数47点と単なる整数47、 郵便番号153-0051と単なる文字列&quot;153-0051&quot;との区別はできません。与えられた表現、例えば 47 や &quot;153-001&quot; が特定のユーザー定義型のインスタンスであることを示すには、次の2つの方法があります。

- インスタンス内に型情報を書き込む
- 外部にあるスキーマとして型情報を与える

インスタンス内に書き込まれたタイプ情報（を示唆する名前）をタグと呼びます。XML要素のタグ名と類似の概念です。ただし、スカラーに対してもタグを付けることができます。タグ付き（メタ情報付き）の値をタグ付き値（tagged value）と呼びます。

タグ名の構文は次のとおり：

- TagName ::= [a-zA-Z][a-zA-Z0-9]*

タグ付き値は、次のようにJSONオブジェクト形式にエンコードされます。

&lt;pre class=&quot;code&quot;&gt;
{
 &quot;$tag&quot; : &quot;score&quot;,
 &quot;$val&quot; : 47
}

{
 &quot;$tag&quot; : &quot;zipCode&quot;,
 &quot;$val&quot; : &quot;153-0051&quot;
}
&lt;/pre&gt;

ドルマークからはじまる特殊なプロパティ名を使っています。「特殊」とは言ってもコンベンション（お約束）のレベルでのことです。ドルマークからはじまるプロパティ名はシステム側で予約するよ、ってこと。

$tag がない {&quot;$val&quot; : 47} は単なるスカラー 47 と同義です。$tagだけがあって $val がないときは undefined ですが、JSON内でundefinedを明白に表現はできないのでエラーです。

見てのとおり、タグ付き値を人が読み書きするのは愉快ではありません。説明のときは、次の形で書くことにします。

- '(' タグ名 ')' 値の表現

例えば、(score)47, (zipCode)&quot;153-0051&quot; など。丸括弧を使ったのは、プログラミング言語のキャストとの類似からです。このキャスト風記法は、単なる説明用ではなくて、生のJSON構文の上位構文として採用するかもしれません（まだ未定）。


</body>
</day>
<day date="2009-08-08" title="">
<body>
*1249699652*[気付いた]絵図不等式

双方向の（可逆な）変形が絵図等式なんだから、片方向（不可逆）の変形は絵図不等式だよね。

OCat内では、絵図不等式が意味を持つ。射が証明のとき、証明の変形を2セルと考えたりすると、絵図不等式が使えそうだが。あるいは、非決定性関数の圏とか。

*1249700352*[雑記]あやとり公式

双モノイド法則（双代数法則）は、モノイド積を+、恒等を1で書くと

- ∇;Δ = (Δ+Δ);(1+X+1);(∇+∇)

と書けて一番見た目がきれいだろう。+も省略すると：

- ∇;Δ = (Δ Δ);(1 X 1);(∇ ∇)

縦書きすると：

&lt;pre&gt;
 ∇ 
 Δ

 ∥

Δ Δ
1 X 1
∇ ∇
&lt;/pre&gt;

オオー、素晴らしい。

それはそうとして、この法則の類似が、加群、余加群、それらが混じった構造などでも頻繁に登場する。双モノイド法則という呼び名は適当ではない。なんか見た感じがあやとりっぽいので、&lt;span style=&quot;font-size:large&quot;&gt;あやとり公式&lt;/span&gt;はどうかな。

*1249721965*[モナド][モノイド圏]あやとり公式の一例

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090807/1249617352&quot;&gt;「双モノイド法則の一般化」&lt;/a&gt;の状況の別な定式化。まー、本質的には同じだと思うのだが。「あやとり」については[http://d.hatena.ne.jp/m-hiyama-memo/20090808/1249700352:title]参照。

コモノイドの圏、あるいは対角付き圏のなかで考えるので、すべての対象XにΔ&lt;sub&gt;X&lt;/sub&gt;は付いているとする。

- Mはモノイド
- Kはモノイド
- Vは対象（コモノイド）
- Sは左M加群 作用m:M×S→S
- Sは右V余加群 余作用p:S→S×V
- Vは左K加群 作用n:K×V→V
- f:M×S →K という、S側を固定してモノイド射である射がある

m;p が次のように展開される。展開型を縦書きする。
&lt;pre&gt;
   Δ&lt;sub&gt;M&lt;/sub&gt; p
  M M Δ&lt;sub&gt;S&lt;/sub&gt; V
 M τ&lt;sub&gt;M,S&lt;/sub&gt; S V
   M S f V
    m   n
&lt;/pre&gt;

*1249722894*[モナド][モノイド圏][プログラム意味論]ホーア加群

ホーア論理を加群／余加群の枠組みで定式化できないかと考えて、ホーア加群というものをひねり出した。ただし、このままでは現実性がない、やたらに理想的な状況でしか意味を持たない構造。だがそれでも、より先を考えるための道具とはなるはず。

いずれ書く（つもり）。

</body>
</day>
<day date="2009-08-11" title="">
<body>
*1249948021*[cathand][型検査]型のタグ集合と排他的ユニオン

Tが型表現、またはその意味であるインスタンス領域だとして、tags(T) は、Tのインスタンスに付いている可能性のあるタグの集合。次のことを保証したい。

- tags(T) は空ではない。
- x∈T ならば tag(x) ∈ tags(T)

そうなれば、S|T に対して、tags(S)∩tags(T) = 空 という命題が意味をもつから、排他性を定義できる。

*1249948454*[JavaScript]親のものを乗っ取ることは、継承とは言わないかもね

&gt;|javascript|
/* test-inher-1.js */

// コンストラクタ
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.moveTo = function (x, y) {
  this.x = x;
  this.y = y;
};

Point.prototype.toString = function () {
  return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
};

/* サブクラス?? */

// コンストラクタ
function ColoredPoint(x, y, color) {
  this.x = x;
  this.y = y;
  this.color = color;
}
// 継承??
ColoredPoint.prototype = Point.prototype;
// サブクラスのメソッド定義
ColoredPoint.prototype.setColor = function(color) {
  this.color = color;
};
ColoredPoint.prototype.toString = function() {
  return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;; &quot; + this.color + &quot;)&quot;;
};
||&lt;

&gt;|javascript|
/* test-inher-2.js */

// コンストラクタ
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.moveTo = function (x, y) {
  this.x = x;
  this.y = y;
};

Point.prototype.toString = function () {
  return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
};

/* サブクラス */

// コンストラクタ
function ColoredPoint(x, y, color) {
  this.x = x;
  this.y = y;
  this.color = color;
}
// 継承
ColoredPoint.prototype.__proto__ = Point.prototype;
// サブクラスのメソッド定義
ColoredPoint.prototype.setColor = function(color) {
  this.color = color;
};
ColoredPoint.prototype.toString = function() {
  return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;; &quot; + this.color + &quot;)&quot;;
};
||&lt;

</body>
</day>
<day date="2009-08-13" title="">
<body>
*1250127293*[雑記]「後で書く」のメモ

+ 「Aという性質を持つものに注目し調べましょう」は、「Aという性質を持たないものは意味がない」とか「Aという性質を持たないものを調べる価値がない」とかを含意しない。
+ Vを固定して、V値関手コボルディズムの圏を作る
+ アロー図で見ると、fとgからf;gを作ることは、境界点を消して、アローを1本にして、ラベルを付け替えること。
+ 関手コボルディズムは、「境界を消す」事と自然変換のアイディアを組み合わせた概念。
+ 公平な（unbiased）演算をちゃんと考えてみる、平均値とか総和、総積とか。
+ types as &lt;a target=&quot;_blank&quot; href=&quot;http://en.wikipedia.org/wiki/Setoid&quot;&gt;setoids&lt;/a&gt; 概念
+ [cathand]コマンドライン引数と標準入力の統合
+ 型生成（production）を構成（construction）と制限（restriction）に分類する。
+ ⊥（undefined）を含む正規表現の処理
+ 図式、錐の圏、極限
+ RDBのテーブル・ジョイン
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090808/1249722894&quot;&gt;ホーア加群&lt;/a&gt;＝模倣加群
</body>
</day>
<day date="2009-08-14" title="">
<body>
*1250241049*[圏一般論]たかだか可算の部分圏

集合圏Setに対して、埋め込み（対象上で単射な忠実関手）が指定されているような圏Cを考える。要するに標準的な忘却関手を持っているので、Cは集合・写像ベースの圏と言える。

Cの対象の濃度をその台集合（忘却関手の値）の濃度とする。すると、濃度がたかだか可算である対象の全体が特定できる。さらに充満部分圏をとることもできる。充満部分圏のホムセットが可算でなくなると困るので、ホムセットも可算なケースを考える。

そのような部分圏が取れると、たかだか可算な部分圏と呼んでいいだろう。計算関係で出てくる圏はたいていたかだか可算な圏。


</body>
</day>
<day date="2009-08-16" title="">
<body>
*1250413553*[JavaScript]秘密を持った点

&gt;|javascript|
/* PointWithSecret.js */

var Point = function (x, y, secret_)
{
    this.x = x;
    this.y = y;

    var secret = (secret_ || &quot;confidence&quot;);
    this.getSecret = function()
    {
      return secret;
    };
};
Point.prototype =
{
    moveTo : function (x, y)
    {
        this.x = x;
        this.y = y;
    },
    toString : function ()
    {
        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
    }
};
||&lt;

*1250413554*[JavaScript]継承方式と見やすさ

&lt;h5&gt;hacker's&lt;/h5&gt;
&gt;|javascript|
/* test-inher-3-hacker.js */
// コンストラクタ
var Point = function (x, y)
{
    this.x = x;
    this.y = y;
};
var PointPrototype = function ()
{
    this.moveTo = function (x, y)
    {
        this.x = x;
        this.y = y;
    };
    this.toString = function ()
    {
        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
    };
};
Point.prototype = new PointPrototype();
/* サブクラス */
// コンストラクタ
var ColoredPoint = function (x, y, color)
{
    this.x = x;
    this.y = y;
    this.color = color;
};
// サブクラスのメソッド定義
var ColoredPointPrototype = function (x, y)
{
    this.setColor = function (color)
    {
        this.color = color;
    };
    this.toString = function ()
    {
        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;; &quot; + this.color + &quot;)&quot;;
    };
};
// 継承
ColoredPoint.prototype = new ColoredPointPrototype();
ColoredPointPrototype.prototype = new PointPrototype();
||&lt;

&lt;h5&gt;hiyama's&lt;/h5&gt;

&gt;|javascript|
/* test-inher-3-hiyama.js */
// コンストラクタ
var Point = function (x, y)
{
    this.x = x;
    this.y = y;
};
Point.prototype =
{
    moveTo : function (x, y)
    {
        this.x = x;
        this.y = y;
    },
    toString : function ()
    {
        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
    }
};

/* サブクラス */
// コンストラクタ
var ColoredPoint = function (x, y, color)
{
    this.x = x;
    this.y = y;
    this.color = color;
};
// サブクラスのメソッド定義
ColoredPoint.prototype =
{
    setColor : function (color)
    {
        this.color = color;
    },
    toString : function ()
    {
        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;; &quot; + this.color + &quot;)&quot;;
    }
};
// 継承
ColoredPoint.prototype.__proto__ = Point.prototype;
||&lt;

</body>
</day>
<day date="2009-08-18" title="">
<body>
*1250556008*[説明][小咄]面白い双対性

I = [0, 1] を単位区間とする。Xの柱体Cyl(X)は、X×I として定義される。一方、Yのパス空間Path(Y)は Y&lt;sup&gt;I&lt;/sup&gt; として定義される。例えば位相空間の圏Topで考えて、

- Top(X×I, Y) = Top(X, Y&lt;sup&gt;I&lt;/sup&gt;)

という随伴があるんで、Cyl(X)とPath(Y)が相関しているのは明か。だが、次は知らなかった。

- X+X → Cyl(X) → X

これは、床と天井を柱に埋め込み、その後で柱をベチャとつぶす写像。結果は、∇:X+X→X となる。

- Y → Path(Y) → Y×Y

これは、点を自明なパスとして埋め込み、両端点のペアを取る写像。結果は、Δ:Y→Y×Y となる。

あーーー、幾何学ではこんなの無意識に使っていたかも。なんかスッゲー面白い。

</body>
</day>
<day date="2009-08-21" title="">
<body>
*1250833598*[具体例][モナド][小咄]一般的なIO代数

集合圏かCPOの圏で考えるとして（デカルト閉圏ならいい）、ωは自然数（順序付き）か似たようなモンだとして、Aは勝手な対象。

- in:A&lt;sup&gt;ω&lt;/sup&gt;→A
- out:A→A&lt;sup&gt;ω&lt;/sup&gt;

とすると、ストリームIOの雰囲気がする。inとoutの間には通常はなにかしら関係があるが、特に関係は考えないとする。さらに、ωをV（ただし固定）にすると、

- in:A&lt;sup&gt;V&lt;/sup&gt;→A
- out:A→A&lt;sup&gt;V&lt;/sup&gt;

というオペレーションの組が一般的なIO代数と呼ばれるもの。一般的過ぎる気もするが。

F(A) = A&lt;sup&gt;V&lt;/sup&gt; とすると、inはF-代数、outはF-余代数を定義するので、IO代数は、両代数となる。in+out:F(A)+A →A+F(A)として定義できる。G(A) = F(A)+A, H(A) = A+F(A) とすると、個別のinoutは、G(A)→H(A)なので、(G, H)-両代数。(G, H)-両代数の圏がIO代数の圏。

*1250837739*[プログラム意味論][cathand]posetoid

順序を≦、同値関係を～とすると、条件は：

+ a≦b, a～a' ⇒ a' ≦ b
+ a≦b, b～b' ⇒ a ≦ b'

くらいかな。Aの商Q(A)にも「≦が落とせる」と言えばいいのか。

</body>
</day>
<day date="2009-08-22" title="">
<body>
*1250905336*[プログラム意味論][cathand]JcentricTS, 現状わかったこと

[http://d.hatena.ne.jp/m-hiyama/20090821/1250817550:title]の意味論のほうの話。

+ Posetoidの導入は避けられない。Posetoid自体はデカルト閉っぽい。
+ Posetoidの圏の変種は、必ずしもデカルト閉にはならない。
+ category with embeddings という概念が必要。
+ embedding := projectable（造語）な射として埋め込み概念を定義する。
+ アイソトピーが定義できる。
+ アイソトピー＝通常のアンビエントアイソトピーかどうかまだ分からない。
+ 直和に関するアイソトピー定理を示せる。
+ 直積に関するアイソトピー定理を示せる。
+ Cを背景圏、Aをアンビエント対象、K⊆|EO(C, A)| として、Kから生成されたCの部分圏は、EO(C, A)にup-to-isotopyで埋め込める。「アイソトピー埋め込み定理」と言っていいだろう。
+ あとはinclusion structureを明確に作る。

なんだかんだ考えているうちに、新しい概念／用語をイッパイ作ることになったなー。

+ setoidがクリスプ（crips） :⇔ 同値関係がイコール
+ posetが平坦 :⇔ (x≦y ならば、x = y または x = ⊥)
+ posetが強平坦 :⇔ 平坦で⊥がない
+ posetが離散的 ＝ 強平坦
+ setoidが離散的 ＝ クリスプ
+ posetoidが離散的 ＝ クリスプかつ強平坦
+ posetが厳密 :⇔ ⊥を持つ
+ 射が厳密 :⇔ ⊥を保存する
+ f, g:X→←Y が劣同型ペア :⇔  f;g ≦X, g;y≦Y
+ fがプロジェクタブル :⇔ (f, p)がEPペアとなるpが存在する
+ fが埋め込み ＝ fがプロジェクタブル
+ 2つの埋め込みがアイソトピック :⇔ アンビエント対象の劣同型ペアで互いに移れる

*1250905337*[形式言語理論][cathand]スキーマモジュールの種類

provide/require方式だから、requireがあるか・ないかで分類できる。開いたモジュール、閉じたモジュールとでも言えばいいのか。

- Mが閉じたモジュール ⇔ モジュールを射とする圏で dom(M) = &lt;b&gt;1&lt;/b&gt;

*1250910778*[プログラム意味論][cathand]Setoid, Posetoidの部分対象

Setoid, Posetoidもトポスにはならない。部分対象に関して：

- 充満である -- 埋め込みを関手とみなして充満
- 推移的である -- x∈D, x～y ⇒ y∈D
- 完全である -- 充満かつ推移的

計算可能な述語で定義される部分対象を定義可能と呼べば、定義可能なら完全である。その逆が成立するかどうかはよくわからない。性質の良い圏を作れば、「定義可能⇔完全」だと思うが。

完全部分対象だけを相手にしていれば、かなり幸せなんだけど、そううまくいくかな？

*1250912038*[プログラム意味論][cathand]型の意味

JcentricTSのような簡単な型システムでも、型の意味はけっこう複雑で、Uをアンビエント対象＝JSON領域だとして：

+ 台型の表現空間R、これはposetoid
+ 台型の表現空間上で定義された3値述語p、⊥付きbooleanへのposetoid射
+ 台型の値空間V Q(R)と同型だが同じとは限らない
+ 値写像v:R→V
+ 台型の表現空間RのUへの埋め込みe:R→U

むずかしいはずだわ。

*1250927902*[プログラム意味論][cathand]続・型の意味

背景圏としては、Posetoidを使うが、次のような組 (X, p)を考える。

+ Xはposetoid
+ pはXからΩ={true, false, ⊥}への射

スライス圏を考えるわけではない。射はPosetoidと同じ。ただし、次のような演算を考えることができる。

+ (X, p) | (Y, q) = (X+Y, [p, q])
+ (X, p) * (Y, q) = (X×Y, p(*)q)
+ (X, p) &amp;amp; (X, q) = (X, p∧q)

[p, q]は余デカルトペア、(*)は∧（かつ）を使ったテンソル積、∧は単にブール演算。inclusion structureがあれば、&amp;amp の定義はもう少し拡張できて：

+ (X, p) &amp;amp; (Y, q) = (X∩Y, p∧q)

∩の定義は、XとYの共通アンビエント領域への埋め込みを使って定義する。

</body>
</day>
<day date="2009-08-24" title="">
<body>
*1251072311*[連絡的]思いついた遊び小物

10桁×10行のテキストファイルに、空白文字と星印('*')で描いたアスキーアートを、13バイトのファイルにエンコード／デコードするプログラムを書け。

*1251072312*[プログラム意味論][cathand]optionalが定式化できない

Tが型表現のとき T? はオプショナル型だが、この意味がわからない。モナドはもとより関手にさえならない。値空間が表現空間の外にあるときに、T? が何をすることなのか、サッパリわからない。embedded objectsの圏EO(C, A)の中なら解釈できるのか？

CとEO(C, A)を行ったり来たりしないとダメのような気もする。

*1251072313*[プログラム意味論][cathand]型のインターセクション

&gt;&gt;
∩の定義は、XとYの共通アンビエント領域への埋め込みを使って定義する。
&lt;&lt;

そりゃそうなんだが、共通アンビエント領域を探すのが難しい。∩という絶対的な演算はどうも無理で、∩&lt;sub&gt;Z&lt;/sub&gt;のような演算しか有効じゃない気がする。

</body>
</day>
<day date="2009-08-25" title="">
<body>
*1251160875*[cathand]分配偏代数

partialの訳語に「偏」を使う。「部分」だとsubと区別がつかないので。

集合Aとその上の二項演算 +, * の組(A, +, *)が次を満たすなら分配代数。

+ (a + b) + c = a + (b + c)
+ a + b = b + a
+ (a*b)*c = a*(b*c)
+ a*(b + c) = a*b + a*c
+ (a + b)*c = a*c + b*c

0（加法単位元）、1（乗法単位元）の存在は要求しない（もちろん、あってもいいが）。掛け算*の可換性も仮定しない。掛け算が可換なら、可換分配代数。

足し算（+）, 掛け算（*）は部分的に定義された偏演算（partial operations）でもいいとして、上の法則のイコールをすべて&lt;a target=&quot;_blank&quot; href=&quot;http://www.chimaira.org/docs/PartialEquality.htm&quot;&gt;クリーネの等号&lt;/a&gt;と解釈すると、分配偏代数（distributive partial algebra）となる。

例：Xが無限集合として、A = Powfin&lt;sub&gt;+&lt;/sub&gt;(X) は、Xの非空有限部分集合の全体とする。a, b∈Aに対して、

- a∩b = &lt;b&gt;0&lt;/b&gt; のときに限り a + b = a ∪ b
- a∩b ≠ &lt;b&gt;0&lt;/b&gt; のときに限り a * b = a∩b

0が存在すれば半環、1も存在すれば単位半環（unital semiring）、ただし、1があるケースを半環と呼ぶ流儀もある -- そのときは、1がなければ non-unital semiring。掛け算が可換なら可換半環。それぞれのpartial版は偏半環、単位偏半環など。ベキ等性があれば、加法ベキ等半環、乗法ベキ等半環など。

上の例の分配偏代数は、可換で乗法ベキ等。また、もともとの順序があるから、順序付き可換乗法ベキ等分配偏代数。

(A, +, *) と (B, +, *)が2つの分配偏代数のとき、f:A→B が全域写像で、+と*を保存するとき全域準同型。偏写像であるとき準同型と呼ぶ。分配偏代数は、偏写像（部分写像）の圏における代数の例である。

&lt;hr&gt;

Catyでは、型表現の全体に、構文的にUnionとIntersection演算が入る。これは意味を考えない演算。tagsという写像は、全域的に定義できて、型表現の世界とPowfin(Tag)の代数構造を結ぶ役割を果たす。

</body>
</day>
<day date="2009-08-26" title="">
<body>
*1251242446*[cathand]拡張ポイントの作り方

&lt;pre class=&quot;code&quot;&gt;
module public 
 provides [person]; // personは公開型名となる

type person = @person 
 object {
  &quot;name&quot; : string,
  &quot;age&quot; : integer(minimum=0),
  * : any
 }
 &amp; // インターセクション演算子
 personExt // 拡張ポイント
 ;

// 拡張ポイントの実体を外部参照にする
type personExt = @person user.Ext:personExtObj;
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
module user.Ext
 provides [personExtObj]; // user.Ext:personExtObjを提供

// 拡張部分をオブジェクトとして書く
type personExtObj = object {
 &quot;mailAddress&quot; : @mail string,
 * : any
};
&lt;/pre&gt;

*1251243967*[cathand][型検査]タグの解釈

タグの基本はラベル（マーカー）。型情報としての利用は付随的／二次的であり、ラベルをインスタンス型情報として流用しているに過ぎない。利用可能な範囲も限定的である。

バリデータをvalidateとすると：

+ 基本は、validate(x, T) Tは型表現
+ validate(x) → validate(x, tag(x)) と補完する。
+ tag(x) = t （タグ名）として、tをレジストリから探す
+ tが見つからないときの処理を細工する

- validate(x, t)のときは、tが見つからないなら、人間またはプログラムのミスと判断する。
- validate(x, t = tag(t)) のときは、見つからなくてもエラーとはしない。

&lt;pre class=&quot;code&quot;&gt;
function validate(x, schema) {
 if (schema) {
   validateAgainst(x, schema);
 } else {
   validateSolely(x);
 }
}

function validateSolely(x) {
 var t = tag(x);
 var schema = findSchema(t); // 名前からなんらかの検証用実体を探す
 if (schema) {
   return validateAgainst(x, schema);
 } else {
   true;
 }
}
&lt;/pre&gt;

*1251259922*[cathand][論理][型検査]型推論のための定理

たいした内容ではないけど、名前を付けておこう。

+ タグ排他性の原理：α≠β ⇒ (@α A)∩(@β B) = &lt;b&gt;0&lt;/b&gt;
+ 単調性の原理：S ⊆T ⇒ tags(S)⊆tags(T)
+ ハテナ定理：正規形の式なら、一番外側の'?'で確定型か不確定型か判断できる。
+ ν（nu）定理：ν(T) ≧ 1、ν(T) = n なら、Tはn成分のユニオンとして書ける。
+ 排他的包含の原理：(α=&gt;A) ⊆ (β1=&gt;B1 | ... |βn=&gt;Bn) ⇔ α = βi で (α=&gt;A) ⊆ (βi=&gt;Bi)

タグ排他性の原理は、もっともベーシックな事実。単調性の原理と排他的包含の原理は、そうなるように作りましょう、という指導原理。ν定理も指導原理に近い。が、ハテナ定理は定理だ。

*1251259923*[cathand][型検査]領域の構成

制限の追加ではなくて、領域（型の意味）の構成となっている演算は7種。

+ 配列構成
+ オブジェクト構成
+ バッグ構成 （追加）
+ ?演算 オプショナル構成
+ |演算 ユニオン構成
+ @演算 タギング構成 （追加）
+ &amp;amp;演算 インターセクション構成 （追加）

配列、オブジェクトが一番基本的な構成。オプショナル、ユニオンはJSONスキーマ仕様にある。バッグ、タギング、インターセクションの3つはCatyで追加。

構造に関する帰納法を使うときは、スカラー領域をベースにして、以上の７つの構成に対してステップを組み立てればよい。

*1251259924*[cathand][型検査]型表現の正規化

+ A?? → A?
+ (A?|B) → (A|B)? など
+ A? &amp;amp; B → A &amp;amp; B など
+ A? &amp;amp; B? → (A &amp;amp; B)?
+ bag [A?] → bag [A] (ハテナ定理には不要)
+ @name A? → @name A (ハテナ定理には不要)

ハテナ定理に必要なのは、演算子?, |, &amp;amp; に関する正規化だけ。


</body>
</day>
<day date="2009-08-27" title="">
<body>
*1251336227*[圏一般論][具体例][説明]始対象と直和を持たないデカルト閉圏

最小元を持つ順序集合の圏を考える。射は任意の単調写像で、&lt;em&gt;最小元を保存することは要求しない。&lt;/em&gt;集合直積が圏論的直積、単元集合が終対象を与え、単調写像の集合が再び最小元を持つ順序集合になる。

この圏では、evと(-)^が定義できてデカルト閉になるが、始対象と直和は存在しない。

デカルト閉圏は、連言と含意の論理の表現になっているが、選言を導入できることは保証されないってことになるな。

*1251338342*[cathand][プログラム意味論][論理][型検査]分解還元法による演繹系

Catyの型推論のために、分解還元法というのを考えた。シーケント計算とタブローの中間のような感じのもの。推論は逆向きに（結論から仮定へと）行われるので、次の用語を導入する。

- 分解図 -- 推論図（1ステップ）の逆
- 還元図 -- 証明図（nステップ）の逆

シーケントに対応するのは、有限個(n≧0)の原子論理式をカンマで区切った列。列式、または単に式と呼ぶ。列式のなかの原子論理式は次のいずれか：

+ 真であるとすぐに判断できる。
+ 偽であるとすぐに判断できる。
+ 分解できる。

「真であるとすぐに判断できる」原子論理式は、aを基本型記号（basic type symbol）だとして、a⊆a か a⊆any のどちらかの形。あきらかに偽の論理式は色々ある。

分解とは、列式のなかの1個の原子論理式に注目して、それを1個以上の別な原子論理式の集合（構文的にはカンマ区切り列）に置き換えること。分解が p→q1, ..., qk のとき、次の性質が成立している。

+ |= p ⇔ |= (q1∧...∧qk)
+ rank(p) ＞ rank({q1, ..., qk})

上の主張が確認できるためには、原子論理式に対する意味論が定義されていることと、rankが定義されていることが必要。

意味論は意味領域がないとしょうがないが、rank関数は構文的に定義される。

+ 基本型記号のrankは0
+ 型項（型表現）のrankは、含まれる型関数記号、型演算子記号の総数。
+ 原子論理式のrankは、左右のrankの和
+ 列式のrankは、原子論理式rankの最大値

分解図では、上の式と下の式が意味論的には等価で、下の式のほうが確実にランクが下がっていることになる。常に分解可能性が保証できれば、ランクはゼロに落ちるから、列式の決定可能性が（メタ）証明できる。

意味論を適切に構成すれば、完全性（complete = sound and adequate）が成立する。完全になるように意味論を組み立てる、ってのがホントウのところだけど。

以上の話は、述語pに対する λx:A.p というラムダ式の定義域Aの議論。領域計算と呼びたいが、領域が多用されているから、台領域（キャリア；carrier）計算とでもするか。台の計算をもとにして、その上のラムダ式の計算が可能となる。ラムダ式の計算のほうが制限（restriction）計算となる。制限の実体はスキーマ属性だから属性計算と呼んでもいいかもしれない。

*1251349683*[cathand][プログラム意味論][論理][型検査]分解還元法の分解図

u = undefined として、記号の乱用で u = {u}。ブラケット内の数値はランクが減少する量。

&lt;pre&gt;
●opt-right

          A ⊆ B+u
[u!∈A] -----------[-1]
          A ⊆ B

●opt-both
                A+u ⊆ B+u
[u!∈A, u!∈B] -----------[-2]
                 A ⊆ B

●object

  object {pi: Ai} ⊆ object {pi: Bi}
 ------------------------------------[-2]
       Ai ⊆ Bi  (i=1, ..., n)

●array

  array [Ai] ⊆ array [Bi]
 ------------------------------------[-2]
       Ai ⊆ Bi  (i=1, ..., n)

●union-left

  A|B ⊆ C
 ----------------[-1]
  A ⊆ C, B ⊆ C

●union-right

  α=&gt;A ⊆ (α=&gt;B | C)
 ----------------------[-1]
  A ⊆ B

●bag

   bag [A] ⊆ bag [B]
 --------------------[-2]
      A ⊆ B

●tagging

  @α A ⊆ @α B
 ----------------[-2]
   A ⊆ B

●intersection-right

  A ⊆ B &amp;amp; C
 ------------------[-1]
  A ⊆ B, A ⊆ C

●intersection-left

  α=&gt;A &amp;amp; α=&gt;B ⊆ α=&gt;C
 ------------------------------[-1]
      α=&gt;X ⊆ α=&gt;C 
&lt;/pre&gt;

最後の「α=&gt;X」のところをちゃんとやる必要がある。

それと次は「すぐに偽だとわかる」ケース。

&lt;pre&gt;
                 A+u ⊆ B
[u!∈A, u!∈B] -----------
                  false
&lt;/pre&gt;

</body>
</day>
<day date="2009-08-28" title="">
<body>
*1251434533*[小咄][説明]スコット・ブラケット

意味論のときに使う太い括弧を the &quot;Scott-brackets&quot; notation というらしい。Scottって、どのスコットだろう？ ダナ・スコット (Dana Stewart Scott) だな。

*1251436086*[cathand][プログラム意味論]JSONの外の圏とJSON領域

JSONの意味論を展開するときの外の圏＝背景圏（background category）は、次のような圏がよかろう。

+ 対象はセットイドである。
+ 射は部分的セットイド写像。
+ 直和、直積は集合ベースで考える。&lt;em&gt;圏論的な直和・直積にならなくてもいい。&lt;/em&gt;
+ 直和と直積で分配圏、できれば半環圏になっている。
+ 包含的圏（inclusive category）である。
+ デカルト閉である必要はない（あきらめた）

この外の圏に対して、制限（と呼ぶ述語概念）を付け加える。pがX上の制限だとは：

- p:X→{true, false}は全域的なセットイド写像

{true, false}は普通にブール代数だと思う。(X, p)という組を対象として、セットイド全域写像 f:X→Y で、p(x) = true ⇒ q(f(x)) = true を満たすものを射とする圏を考える。この圏で意味論を考える。ほんとは情報順序が必要になるだろうが、まー、いいとする。新しい圏をRS（Restricted Setoids）とする。

RS内に次の演算を入れる。

+ (X, p)|(Y, q) := (X + Y, [p, q]) （[q, q]は余デカルトペア）
+ (X, p)*(Y, q) := (X×Y, p(*)q) （p(*)qは∧によるテンソル積）
+ (X, p)&amp;amp;(Y, q) := (X∩Y, p∧q)

RS内にJSONデータの領域Jがある。JにRSをスノーグローブ風に埋め込むのだが、Jは完全なスノーグローブじゃなくて、&lt;em&gt;曇ったスノーグローブ&lt;/em&gt;、いろいろと問題があるのだけど、あまり気にしないで、RS内の対象をJに埋め込んで、それをまた対象と思った圏EO(RS, J)を考える。EOは、embedded objectsの略。

*1251438577*[cathand][形式言語理論][論理]形式系の微妙なところ

意味じゃなくて、もっぱら記号の話。

+ 定数とarity 0の関数
+ 関数と演算子
+ fooとfoo()の区別
+ 関数の引数渡しのバリエーション：可変引数、省略とデフォルト値、名前付き引数
+ 関数記号と関係記号の区別
+ ソートを入れるか、特に真偽値のソート
+ 真偽値のソートがあれば、関係記号も論理記号も関数記号じゃ

</body>
</day>
<day date="2009-09-01" title="">
<body>
*1251775004*[圏一般論]分配圏

分配代数の圏バージョンである分配圏。2つのモノイド積を持つ。

とりあえず、分配法則と結合法則のあいだの結び付きは次の可換図式で表現されるだろう。

&lt;pre&gt;
a[(b + c) + d] → a[b + (c + d)]
 ↓                ↓
a(b + c) + ad     ab + a(c + d)
 ↓               ↓
(ab + ac) + ad → ab + (ac + ad)
&lt;/pre&gt;

&lt;pre&gt;
ab(c + d)      → a[b(c + d)]
  ↓               ↓
(ab)c + (ab)d    a[bc + bd]
    ↓           ↓
 a(bc) + a(bd)=a(bc) + a(bd)
&lt;/pre&gt;

</body>
</day>
<day date="2009-09-04" title="">
<body>
*1252044702*[用語法]集合の用語／訳語

- The comprehension principle  「包括原理」
- The axiom of comprehension (CA) 「包括の公理」かな
- specification とか separation とも呼ばれる。
- The axiom of separation は「分出公理」。
- The axiom of specification 訳？
- restricted, relative, bounded あたりは同じ意味だろう。
- The axiom of replacement 「置換公理」だ
- The axiom of collection 置換公理と同じようだが、訳語はわからん

*1252054196*[雑感]閉世界仮説と完全性

Prologの意味論で、閉世界仮説とかいうのがあったけど、アリャいったい何だったんだろう。いまだにわからん、つうか、一度も考えた事ないからわからんで当たり前だが。

「Aの証明が失敗する」と「Aが証明できない」と「￢Aが真]を同一視するような話だったと思う。この３つはまったく別物だよね、ふつうに考えれば。

- Aの証明が失敗したのは、たまたまかもしれない。他の戦略では成功するかも。
- 「Aが証明できない」は構文論的な（メタな）言明。Aが証明できないことが、「￢Aが証明できる」を保証しない。
- 「￢A が真」は意味論的な主張。

演繹系とモデルがあって、完全なら、

- Aが真 ⇒ Aが証明できる

となるから、対偶をとって二値論理として計算すると

- Aが証明できない ⇒ （Aが真でない ≡ Aが偽 ≡ ￢Aが真）

となる。ってことは、閉世界ってのは、完全性が成立しているってこと？ さらに、

- ある方法でAの証明が失敗する ⇒ Aは証明できない

であるためには、証明のアルゴリズムに停止性とか決定性とかが要求されそうだ。

閉世界ってのは、アルゴリズムで何でも決定できるような、メチャクチャ都合がいい世界ってことか？ Prologの意味論の本が一冊あったような気もする。探してみるか？ いや、めんどい。

</body>
</day>
<day date="2009-09-05" title="">
<body>
*1252117484*[cathand][気付いた]えっ、二重に分配圏

Catyのモデルとなる圏って、分配圏をイッパイ含んだ分配圏か？ スタンピングでモナド、コモナドを作るときに使う演算と、JSONデータを細工するときの演算は明らかにレベルが違うのだけど、どっちも分配代数の構造を持つ。

なんか、やっぱりマトリョーシカつうかスノーグローブつうか。


</body>
</day>
<day date="2009-09-09" title="">
<body>
*1252474666*[cathand][気付いた][小咄]直和に関する右自明モノイドは？

集合の直積を考えたモノイド圏では、右自明（左自明）モノイドを作れる。集合の直和について同じことをしようと思うとうまくいかない。射を部分写像にすると、右自明積の類似を定義できる。A+A→A を左成分では未定義、右成分では恒等とすればいい。

ところが面白いことに（あるいは、面白くないことに）単位律を満たさない。モナドもクライスリ圏も作れない。が、セミモナド、セミクライスリ圏なら作れる。セミクライスリ圏でも別に問題ないような気もする。

</body>
</day>
<day date="2009-09-16" title="">
<body>
*1253058808*[小咄][雑感]知っておくと便利な記号

スコットブラケットとゲーデルの記号（あの記号そのものはなんていうんだ？）は知っておいて損はない。つうか、知っておくべきだし日常的に使うといいと思う。

しかーし、手書きじゃないと書けないのが困る！

-  スコットブラケットを強いて書けば、【…】
-  ゲーデルの記号を強いて書けば、… ダメだ、似た記号もない。'「'の鏡映図形があればいいんだが。



</body>
<comments>
<comment>
<username> </username>
<body>Quineのcorner-quotationのことでしょうか？</body>
<timestamp>1253481402</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>(無名)さん、&lt;br&gt;&gt; corner-quotation&lt;br&gt;そう呼ぶのですか。なるほど、角の形の引用符か。&lt;br&gt;&gt; Quineの&lt;br&gt;えっ、クワイン。知らなかった。</body>
<timestamp>1253664035</timestamp>
</comment>
</comments>
</day>
<day date="2009-09-25" title="">
<body>
*1253854676*[cathand]分岐のwhen構文

&lt;pre class=&quot;code&quot;&gt;

 when {number =&gt; &quot;this is number&quot;, string =&gt; &quot;this is string&quot;}

&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
function output(x) { 
 alert(&quot;output: &quot; + x); 
}

if (typeof input === 'number') {
  output(&quot;this is number&quot;)
} else if (typeof input === 'string') {
  output (&quot;this is string&quot;) 
}
&lt;/pre&gt;

*1253861967*[cathand][メモ]ファイルシステム関係

- dirname, basename, ext, trunk の定義
- ノード概念、ノードの種別
- パス名の接頭辞順序
- ツリー領域、またはツリー形状の定義
- ツリー形状の上で定義された関数としてツリー
- ノード属性と関数値

- パスの存在確認
- パスの実体の生成
- パスの属性を読む
- パスの属性を書く（上書き更新）
- 部分読み出し（アドレッシングとチャンク単位）
- 部分書き込み＝置換
- 挿入
- 追記
- ストリーミング
- オープン／クローズ
- キューイングとトランザクション
- 占有と共有

*1253862682*[cathand][メモ]3つのinclusions

本編に書くべきなんだが、面倒でなー。

+ {ただのHTMLファイル} ⊆ {HTMLテンプレートファイル} （一般には {静的コンテンツ} ⊆ {動的コンテンツ}）
+ {JSONデータリテラル} ⊆ {Catyスクリプト}
+ {HTTPリクエスト} ⊆ {Catyコマンドライン}

これの左側だけを取ると：

+ HTMLファイル タグ構文やCSS
+ JSONデータ 構文と意味
+ HTTPリクエスト GETとPOSTのこと

という知識が前提になり、⊆ だから、自然に拡張となっている。追加の知識は

+ テンプレート構文
+ コマンド呼び出し
+ パイプライン
+ 変数

くらいかな。データの流れ方、経路を把握するのがミソかな。

*1253868425*[cathand][メモ]JSON図

たしか、Subject-Property-Value図とか、そんなんがあったな。

- Subject 丸印
- Property 名札が付いた矢印
- Value 四角とか、あるいは再帰的にSPV

スカラー（基本データ）は四角か楕円とか。

細長い四角形で配列を表せばJSONの図示となる。[1, 2] は次の図。

&gt;||
+--------------------+
|   +----+   +----+  |
|&gt;&gt;&gt;| 1  |--&gt;| 2  |  |
|   +----+   +----+  |
+--------------------+
||&lt;

外側の箱を省略すると：

&gt;||
   +----+   +----+
&gt;&gt;&gt;| 1  |--&gt;| 2  |
   +----+   +----+
||&lt;

とこうなる。無名の矢印が next item。配列の入り口を「&gt;&gt;&gt;」で示している。配列の場合は、番号がプロパティ名となっているオブジェクトともみなせる。その見方をするときは、番号をラベルとした点線を使えばいいかな。

ともかく、Simple Json Path (SJPath) の学習がしやすい図が必要だ。

</body>
</day>
<day date="2009-10-13" title="">
<body>
*1255420143*[雑感][復習]「トレース付き」を検索

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?of=60&amp;word=%a5%c8%a5%ec%a1%bc%a5%b9%c9%d5%a4%ad

ビックリするくらいイッパイ書いている。

*1255420629*[セミナー]企画：圏論とソフトウェア実務

次のような項目：

+ 名前とラムダ束縛：対角Δ、終射!が名前によって実現される。
+ 関数とメソッドの相互トランスレーション
+ 関数、クラスメソッド、インスタンスメソッドの定式化
+ 継承、委譲、DI などが、射影、indexed category、スタンピング関手で定式化できる。
+ 状態と例外の双対性
+ コピー可能性がデカルト性と直結すること
+ 同一性、識別可能性がコピー可能性の双対
+ 状態、自己射とミュータビリティ概念

*1255420883*[メモ]Emacsの改行、コーディング関係

MeadowはWindowsなので、改行コードを表す記号が：

|* 記号 |* 改行 |
|(Mac)  | CR  |
| (Unix)| LF  |
|\      |CR+LF  |

それと：

|* キー      |* コマンド |
| C-x RET f  | set-buffer-file-coding-system |
| C-x RET c  | universal-coding-system-argument |
| C-x C-v RET | find-alternate-file |

*1255425111*[雑感]ルーリエは凄い

ルーリエ（Jacob Lurie）は、やっぱり21世紀の（少なくとも21世紀前半）のグロタンディークだと思う。

分野横断的な遠大で包括的な構想力、神がかりというか天の啓示みたいにスルスルと新しい概念とアイディアを出してくるし。そして、千ページ単位の書き物を平気で産出する腕力。

世間的には普通の優等生みたいだから、グロタンディークみたいに伝説やゴシップのネタにはならんだろうが、特別な知性の持ち主なのは間違いないだろう。


</body>
</day>
<day date="2009-10-15" title="">
<body>
*1255593091*[メモ][cathand]忘れないように

メモ編にも書くべき事も山盛りあるんだけどなあ、、、 あー手が間に合わない。しかし、記録しないとドンドン忘却するし、、、うーむ。

とりあえず、モノイド圏上に、3項または4項のhomを定義して、それで圏の集まり（indexed family of categories）みたいなものを作った。indexed categoryとしても定式化できるが、3項（または4項）homのほうが分かりやすい感じがする。notion of process とも似た定式化だし。

デカルト分配圏（半環圏）をベースに4項homを作ると、うまいことCatyに応用できそう。もっと計算しないとダメだけど。

*1255598077*[メモ][課題]量子モノイド

量子群は、ホップ代数の最近の名称。であるなら、対蹠を落とした双代数は量子モノイドってことになる。コンピュータにとっては、群よりモノイドが自然な状況が多い。つまり、量子モノイド＝双代数によるモデルを考えるべきだろう。


</body>
</day>
<day date="2009-10-17" title="">
<body>
*1255742676*[連絡的]ラップアラウンド現象

&gt;|c|
/* wrap-around.c */

#include &lt;stdio.h&gt;


/* この動作をなにがあっても一生忘れないように、
 * 1日数回実行して、通算千回ほどは眺めること。
 */
main()
{
  signed char sc = 100;
  unsigned char uc = 100;

  int i;
  for (i = 0; i &lt; 200; i++) {
    printf(&quot;%03d:%4d %4d\n&quot;, i, sc++, uc++);
  }
}
||&lt;


&gt;|c|
/* add.c */
#include &lt;stdio.h&gt;


/* 足し算してみよう 200 + 200 */

main()
{

  signed char sc = 200; /* コンパイラは何と言うだろう？ */
  unsigned char uc = 200;

  signed char a = sc + uc;
  printf(&quot;%d + %d = %d\n&quot;, sc, uc, a);

  /* こういう中間での宣言ができない処理系もある */
  unsigned char b = sc + uc;
  printf(&quot;%d + %d = %d\n&quot;, sc, uc, b);
}
||&lt;

*1255742677*[連絡的][雑感]あー、そうか、自転車と同じなのか

長男に自転車の練習をさせていた時のことを思い出した。

+ 補助輪を使うかどうか悩んだ
+ 補助輪は止めたけど、ひたすらバランスを取る練習
+ あぶないので付きっきり
+ ブレーキ、信号、左右確認などはずっと後
+ PCゲームで交通ルールは学んだ（が、たぶん身に付いてない）
+ そのうちバランスは無意識化した

+ 補助輪を使ったほうが習得が早い可能性はあるが、補助輪はいつか取る。
+ 本やPCゲームで交通ルールは学ぶのが、どんな意味があるか？
+ バランスを取る練習は不要か？
+ 1度も転ばずに乗れるようになるか？
+ ずっといつまでもバランスを意識しているのか？
+ 乗れるようになっても倒れることはある
+ 乗らずに乗れるようになるか？

参考リンク：
- 16進を知らない子供達へ http://d.hatena.ne.jp/m-hiyama/20060606/1149560150 (コメント欄も)
- 思弁よりトレーニング http://d.hatena.ne.jp/m-hiyama/20081020/1224461181
- ペラペラの表層、シッカリした内実 http://d.hatena.ne.jp/m-hiyama/20091015/1255580321

</body>
</day>
<day date="2009-10-19" title="">
<body>
*1255908191*[cathand]catchじゃなくてwatch

戻り値Bでエラー（丸括弧で囲む）がEの関数は、A→B+(E)。Eをcatchすると、A→B+E。となると、もともと A→B+E である例外しない関数を A→B+(E) とするのが、場合分けthrowってことになる。when { y∈B =&gt; return y, y∈E =&gt; throw y}。

ある範囲内の射を全部に場合分けthrowを付けて、その範囲を見張ってcatchすることができる。場合分けthrowとcatch（古典的なcatch式）を一緒にしたのをwatchとして使ったらいいかもしれない。

ただし、大問題は、NGのようなタグを全部同一視してしまうので、エラーの発生源を特定できない。特定するには、エラーごとに別なタグを付ける必要がある。これが実用的かどうか？ watchの出番もワンポイントつうか限定的になりそう。ホントにいるかどうか分からん。

</body>
</day>
<day date="2009-11-02" title="">
<body>
*1257155351*[cathand][論理]あれ、こんなこと書いていた

- http://d.hatena.ne.jp/m-hiyama/20061115/1163573135


</body>
</day>
<day date="2009-11-10" title="">
<body>
*1257809638*[その他代数][圏一般論]ガブリエル／ローゼンバーグの定理

代数幾何の枠組みを他分野に応用するには、ガブリエル／ローゼンバーグ（Gabriel Rosenberg）の再現定理（reconstruction theorem）というのがどうも鍵らしい。可換環からなにやらかにやらして作ったアーベル圏から、もとの環を再構成できる、ということらしい。らしい、らしい、らしい、、、

「なにやらかにやら」の部分がサッパリわからん。

</body>
</day>
<day date="2009-11-13" title="">
<body>
*1258069750*[cathand][caty][セミナー][基本スキル][型検査]関数型としての配列とレコード、それに関連すること

+ モノ（値）かコト（事態、動作）か
+ モノとコトの相互変換
+ soft-nothing と hard-nothing
+ ⊥の追加、厳密射、リフト

結局は、バンドルと層を使うことになるな。

+ 集合圏の始対象／終対象の非対称性
+ 関数と関数型（べき、指数）
+ 特異値と非特異台
+ 外延的記法による関数記述、外延的に記述可能とは？
+ 有限値域性
+ 概有限領域への有限分割
+ 無限領域を1つに制限、値も1つに制限
+ コンパクト台の関数、大前提としての台のコンパクト性
+ 正常値としてのundefined値、undefined型
+ 歯抜け配列とレコード（JSONオブジェクト）
+ マジメな(solid)配列と index out of range
+ optional型の意味、undefined = never? （undefined不要）
+ [A*], [#:A], {*:A}, [#:A]&lt;sub&gt;solid&lt;/sub&gt;

+ A&lt;sup&gt;2&lt;/sup&gt; = A&lt;sup&gt;1+1&lt;/sup&gt; = A×A
+ A&lt;sup&gt;1&lt;/sup&gt; = 1, A&lt;sup&gt;0&lt;/sup&gt; = 1
+ 0&lt;sup&gt;0&lt;/sup&gt; は？

+ バンドルとセクション
+ セクション集合とヘテロな総積
+ 空ファイバーによるセクション消滅
+ 部分バンドル（制限バンドルにあらず）
+ 同じ底集合上のバンドルの演算
+ バンドル（ファイバー）積、バンドルミート
+ バンドル演算とセクション集合と指数法則
+ Γ(A×B) = Γ(A)×Γ(B)、Γ(A∩B) = Γ(A)∩Γ(B)
+ クリーネスターとdefault指定の共通性

大域セクションがないバンドルはΓ関手で一緒くたになってしまう。空ファイバーやネジレを持つバンドルも、層を使えば「なにも引かず」に定式化できる。

*1258083265*[cathand][caty][型検査]構文的なdom/cod

これは、あくまで構文的であり、決して&lt;em&gt;意味的ではない&lt;/em&gt;ことに注意。意味的な議論は解釈を決めないとできないし、解釈は色々あり、解釈ごとに定義は変わる。

基底：コマンド呼び出しと定数

+ Dom(f::S -&gt; T) = S
+ Dom(c) = null

+ Cod(f::S -&gt; T) = T
+ Cod(c) = sing(c)

帰納ステップ：

+ Dom(E | F) = Dom(E)
+ Dom([E, F]) = Dom(E)∩Dom(F) （∩は &amp;amp; に還元可能）
+ Dom({α:E, β:F}) = Dom(E)∩Dom(F)
+ Dom(when {α=&gt;E, β=&gt;F}) = (@α Dom(E) | @β Dom(F))
+ Dom(each{E}) = list[Dom(E)]
+ Dom(@α E) = Dom(E)

+ Cod(E | F) = Cod(F)
+ Cod([E, F]) = tuple [Cod(E), Cod(F)]
+ Cod({α:E, β:F}) = object {α: Cod(E), β:Cod(F)}
+ Cod(when {α=&gt;E, β=&gt;F}) = Cod(E)∪Cod(F) （還元不可能）
+ Cod(each{E}) = list[Cod(E)]
+ Cod(@α E) = @α Cod(E)

集合の合併∪は、型表現に還元不可能なので、プロファイルは一般に次の形になる。

- S -&gt; T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, ..., T&lt;sub&gt;n&lt;/sub&gt;

*1258085116*[cathand][caty][型検査]安全性判定の分解規則

式Eの計算が、&lt;em&gt;すべての部分式の計算も含めて&lt;/em&gt;安全に行われる（と予測できる）とき、《E》 と書く。式Eのすべての部分式とパイプ記号には、番号（一意的ならなんでもいい）が振ってあるとする。異なる番号が同じ場所を指す可能性がある。（&lt;b&gt;[追記]&lt;/b&gt;そんなにイッパイ番号いらねー&lt;b&gt;[/追記]&lt;/b&gt;）

分解規則（逆推論規則）を ⇒｜ で示す。□ は空の目印。

基底：コマンド呼び出しと定数

+ 《f》 ⇒｜ □
+ 《c》 ⇒｜ □

帰納ステップ：

+ 《E |&lt;sub&gt;i&lt;/sub&gt; F》 ⇒｜ 《E》 [Cod(E)⊆Dom(F)]&lt;sub&gt;i&lt;/sub&gt; 《F》
+ 《[E, F]》 ⇒｜ 《E》  《F》
+ 《{α:E, β:F}》 ⇒｜ 《E》  《F》
+ 《when {α=&gt;E, β=&gt;F}》 ⇒｜ 《E》  《F》
+ 《each{E}》 ⇒｜ 《E》
+ 《@a E》 ⇒｜ 《E》

- 例外：void規則 《E |&lt;sub&gt;i&lt;/sub&gt; F》 ⇒｜ 《E》 《F》 （Dom(F) = void のとき）

制限付き安全性：iは式の入り口番号、jは式の出口番号

+ S《E》 ⇒｜ [S⊆Dom(E)]&lt;sub&gt;i&lt;/sub&gt; 《E》
+ 《E》T ⇒｜ 《F》  [Cod(E)⊆T]&lt;sub&gt;j&lt;/sub&gt;
+ S《E》T ⇒｜[S⊆Dom(E)]&lt;sub&gt;i&lt;/sub&gt; 《F》  [Cod(E)⊆T]&lt;sub&gt;j&lt;/sub&gt;

&lt;b&gt;[追記]&lt;/b&gt;なんであれ、名前を付けてあげないとそれを指し示すことができないので、[http://d.hatena.ne.jp/m-hiyama-memo/19990829/1251511893:title] で触れている演繹系を &lt;strong&gt;SIL&lt;/strong&gt; と呼ぶことにした。Simple Inclusion Logic 、発音は「汁」。&lt;b&gt;[/追記]&lt;/b&gt;

安全性の主張（証明ターゲット）は、SIL（Simple Inclusion Logic）命題の有限集合まで還元される。それぞれのSIL命題には、パイプ番号、式入り口番号、式出口番号が付いている。SIL命題（原子論理式）を、SIL演繹系で証明し、失敗した命題番号に対応する位置にマークして、あとは目的に応じて対処する。

*1258163868*[後で消す]カロウビ展開圏の定義

[http://d.hatena.ne.jp/m-hiyama/20091109/1257727780:title]のコピー
&lt;hr&gt;

与えられた圏Cに対して、新しい圏Kを作ります。その作り方を順に述べます。まず、Kの対象は、Cのベキ等射とします； a∈|K| ⇔ aはCのベキ等射 ⇔ a;a = a inc C。Kの射 f:(A,a)→(B, b) は次の条件を満たすCの射だとします

- f:A→B in C
- a;f:b = f

Kにおける射の結合は、Cにおける射の結合をそのまま使います。この定義を正当化するには、次を示す必要があります。

- f∈K(a, b), g∈K(b, c) ならば、f;g∈K(a, c)

言い換えると：

- f∈C(A, B), g∈(B, C) で a;f;b = f, b;g;c = g ならば、a;(f;g);c = f;g

これは簡単に示せますね。Kにおける「;」の結合律は、Cにおける結合律から従います。

a∈|K| に対して、Kにおける id&lt;sub&gt;a&lt;/sub&gt; は、a:A→A in C で定義します。id&lt;sub&gt;a&lt;/sub&gt;∈K(a, a) とは次のことですから、あきらかです。

- a;a;a = a in C

id&lt;sub&gt;a&lt;/sub&gt; がKにおける恒等になっているとは：

- f∈K(a, y) ならば id&lt;sub&gt;a&lt;/sub&gt;;f = f
- g∈K(x, a) ならば g;id&lt;sub&gt;a&lt;/sub&gt; = g

これをC内の命題で表現すれば：

- f∈C(A, Y), a;f;y = f ならば、a;f = f
- g∈C(X, A), x;g;a = g ならば、g;a = g

これもすぐに分かります。

こうして作った圏Kを、Cの&lt;strong&gt;カロウビ展開圏&lt;/strong&gt;と呼び、K = KE(C) と書くことにします。

*1258166827*[cathand][caty][型検査]シグニチャとそのパターンマッチ

「文字列（名前）の集合と非負整数値」の組をシグニチャと呼ぶ。次の形で書く； {&quot;foo&quot;, &quot;bar&quot;; 2}, {; 3}, {&quot;baz&quot;; 0}, {;0}。

シグニチャパターンはオプションシグニチャパターンと引数シグニチャパターンの組である。オプションシグニチャパターンは：

- 文字列 または 文字列? の有限集合

{&quot;foo&quot;?, &quot;bar&quot;, &quot;baz&quot;?} はオプションシグニチャパターンで、次の要素からなる集合を表す。

+ {&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}
+ {&quot;foo&quot;, &quot;bar&quot;}
+ {&quot;bar&quot;, &quot;baz&quot;}
+ {&quot;bar&quot;}

引数パターンは：

+ ハイフン、疑問符、アスタリスクからなる文字列
+ 一度疑問符が出ると、疑問符かアスタリスク
+ アスタリスクが出るとオシマイ。

例：&quot;--??*&quot;, &quot;?*&quot;, &quot;-?&quot;, &quot;---&quot;, &quot;*&quot;。1個の引数パターンは、ハイフンだけの文字列の集合を表す。&quot;--??&quot; なら、{&quot;--&quot;, &quot;---&quot;, &quot;----&quot;} である。無限集合もありえる。ハイフン文字列の長さは非負整数の集合を作る。

シグニチャパターンは、文字列有限集合の有限集合Optと非負整数値（無限かも知れない）集合Arityを定める。与えられたシグニチャの文字列集合の部分がOptに入り、整数値がArityに入れば、そのシグニチャはそのパターンにマッチする。

</body>
</day>
<day date="2009-11-16" title="">
<body>
*1258361072*[cathand][caty][型検査]型解析のアルゴリズム

「勝たす異論」じゃねーよ。

型推論とかいうとつっこまれそうだから、型解析にする。問題はパイプ結合だけ。

+ 型ユニフィケーションをして、SIL命題のセットを出力する
+ SIL命題セットを整理、計算（簡約）する。
+ SIL命題セットから代入を取り出して、再帰的に（伝搬的に）適用する。
+ 残ったSIL命題を、SILエンジンにかける。
+ SILエンジンの結果を構文木にマークする。

これだけじゃ、わかんねーだろうけど。備忘。

&lt;b&gt;[追記]&lt;/b&gt;

型ユニフィケーション Unify(S, T) では、次のどれかを出力する。

+ (S, y) -- yは変数、Sは任意の型項
+ (x, T) -- xは変数、Tは任意の型項
+ (a, b) -- a, b はスカラー型（定数項）

これは、連立不等式系のようなものだと考えられる。項Tに含まれる変数をVar(T)とすると、

+ Var(S) にyは含まれない。
+ Var(T) にxは含まれない。

ので再帰的な不等式系にはならない。

次の方式で“集約”する。

- (S, y), (S', y) ⇒  (S∪S', y)
- (x, T), (x, T') ⇒  (x, T∩T')

S∪S'と T∩T' は簡約する。

- tags(S)∩tag(S') = φ なら (S | S') を作り、そうでないならそのまま残す。
- T&amp;amp;T' を簡約計算ができなくなるまで計算する。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2009-11-19" title="">
<body>
*1258611884*[セミナー][Mx]コパスタ余会ネタ

[http://d.hatena.ne.jp/m-hiyama-memo/19990802/1249464085:title]も参照。

- 足し算ぽい：ブーリアンのOR演算 -- 足し算ぽいね、うんうん
- 足し算ぽい：集合の合併 -- 以下同様
- 足し算ぽい：max, min
- 足し算ぽい：特に平坦束、この圏の線形写像はなにか？
- 足し算ぽい：集合、部分写像、関係圏に共変べき関手を作用させて作った圏。なんでも線形。素朴な型構成子
- 足し算ぽい：削除の代数
- 足し算じゃないぞ：代入作用
- 足し算じゃないぞ：文字列（データなんでも）連接

- 余足し算：まずは対角
- 余足し算：非決定性写像圏で、だいたい公平なchoice
- 余可換な余作用：だいたい公平なchoiceと、間抜けな例外キャチャー
- 余足し算じゃないぞ：部分写像（を含む）圏で、だいたい不公平な片側choice
- 非余可換な余作用：だいたい不公平なchoiceと、ちゃんとした例外キャチャー

- 参考：フロベニウス代数法則
- 本命：余代数法則（名前がないのか？） あやとり法則（coined by 檜山）
- 本命：余代数、余加群のあやとり法則

- 参照コモノイドと変更リクエスト・モノイドによる両加群構造 ≒ ストレージ
- その双対：フォールド・モノイドとchiceコモノイドによる両加群構造 ≒ 例外

</body>
</day>
<day date="2009-11-20" title="">
<body>
*1258683874*[セミナー][Mx]コパスタ余会ネタ 2

注意：distributorは用語的に問題があって、distributivityとか言うほうが望ましいだろう。が、-er, -or って語尾はコンピュータ／ソフトウェア屋さんは好きだから、distributor使う。

まず普通の足し算に関して：

- associator自然同型 (A+B)+C ⇒ A+(B+C)
- 左unitor自然同型 0+A ⇒ A
- 右unitor自然同型 A+0 ⇒ A

掛け算も同様。それで、

- 左distributor自然同型 A×(B+C) ⇒ A×B + A×C
- 右distributor自然同型 (B+C)×A ⇒ B×A + C×A

対称性の用語が山ほどあって、

- symmetry, symmetric braiding, flip, twist, swap, cross, crossing, interchange, exchange, ...

足し算も掛け算も対称だが、足し算のほうが印象としては対称性が強い。

左右を強く区別する足し算を環和(+)で表して、

- associator自然同型 (A+B)(+)C ⇔ A(+)(B+C)
- 左unitor自然同型 0(+)A ⇔ A
- 右unitor自然同型 A(+)0 ⇔ A

unitorに関しては、A ⇒ 0(+)A という埋め込みしか意味ないかも。

A(+)B ⇔ B(+)A というフリップはあるけど、これはすごいね。えぐいね。

普通の和+と環和(+)が混じった和を混合和として、環積(×)は次を基本に定義：

- (A(+)B)(×)C = A(+)(B(×)C)

dissociative法則だな（dis-sociative）。

それはそうとして：

- 嫌われ者ユニオン型は再認識すべきだ。
- 例外で本質的なのはキャッチャー（フィルター）のみ。
- 例外ハンドラーは通常コードであり、なんら特殊なことはない。
- キャッチャーは、tryスコープを引数にする関手とみなせる。
- ハンドラや後続コードをひっつけて関手作っても、まー、それは別に自由。
- キャッチャーは、和と環和を持つ圏のasscociatorだとも言える。
- 環和は対称性を持たない！ 入れ子にできるが、解釈はやや面倒。
- やや面倒だが、現象の説明には使える。
- ok-error方式、monitor-throw 構文、catch-return 構文、とassociator
- まさに正常、ちょっと異常っぽい、異常入っている、普通に異常
- 普通に例外、どうしようもなく例外、とんでもなく例外、想像を絶する例外

</body>
</day>
<day date="2009-11-24" title="">
<body>
*1259050816*[セミナー][caty][モノイド圏]圏論のお勉強なら、Catyスクリプトでやってミソ

ステファネスクに従って、用語法をデカルト分配圏から&lt;em&gt;デカルト半環圏&lt;/em&gt;（cartesian semiringal category）に変える。

記号の説明：
- θ -- 空集合を域とする唯一の射
- ι --  標準入射
- ∇ -- 直和のフォールド＝余対角
- λ -- 左unitor自然同型
- ρ -- 右unitor自然同型
- α -- associator自然同型
- プライム付き -- 直和に関するunitor, associator

|* デカルト半環圏 |* Catyスクリプト  |
| &lt;b&gt;1&lt;/b&gt;        | null             |
| !               | void             |
| &amp;lt;f, g&gt;       | [f, g]           |
| π&lt;sub&gt;1&lt;/sub&gt;  | nth 1            |
| π&lt;sub&gt;2&lt;/sub&gt;  | nth 2            |
| f×g            | [nth 1 &amp;#124; f, nth 2 &amp;#124; g] |
|  Δ             | [pass, pass]     |
| λ              | nth 2           |
| λ&lt;sup&gt;-1&lt;/sup&gt; | [null, pass]    |
| ρ              | nth 1           |
| ρ&lt;sup&gt;-1&lt;/sup&gt; | [pass, null]    |
| α             | [nth 1&amp;#124;nth 1, [nth 1&amp;#124;nth 2, nth 2]&amp;#93;  |
| α&lt;sup&gt;-1&lt;/sup&gt;| &amp;#91;[nth 1, nth 2&amp;#124;nth 1], nth 2&amp;#124;nth 2]  |
| &lt;b&gt;0&lt;/b&gt;        | never            |
| θ              | 許可しない((when{} は構文エラー))       |
| [f, g]          | when {1=&gt;f, 2=&gt;g}     |
| ι&lt;sub&gt;1&lt;/sub&gt;  | @1 pass            |
| ι&lt;sub&gt;2&lt;/sub&gt;  | @2 pass            |
| f + g           | when{1=&gt;@1 f, 2=&gt;@2 g} |
| ∇              | when{1=&gt;pass, 2=&gt;pass} |
| λ'              | pass           |
| λ'&lt;sup&gt;-1&lt;/sup&gt; | pass    |
| ρ'              | pass           |
| ρ'&lt;sup&gt;-1&lt;/sup&gt; | pass    |
| α'             | when{1=&gt;when{1=&gt;@1 pass, 2=&gt;@2 @1 pass}, 2=&gt;@2 @2 pass} |
| α'&lt;sup&gt;-1&lt;/sup&gt;| when{1=&gt;@1 @1 pass, 2=&gt;when{1=&gt;@1 @2 pass, 2=&gt;@2 pass}} |

肝腎の分配法則＝distributor自然同型が簡単には書けない。

- [http://d.hatena.ne.jp/m-hiyama/20090903/1251966927:title]
- [http://d.hatena.ne.jp/m-hiyama/20090904/1252051446:title]

本編ではオブジェクトを使っているが、配列を使うことにする。%は値変数、_は型変数を表す接頭辞として：

- val :: @%t _T -&gt; _T
- tagged :: [string %t, _T] -&gt; @%t _T

このような val, taggedを使えば：

- 左分配 δL &amp;#91;[nth 2 | when{1=&gt;&quot;1&quot;, 2=&gt;&quot;2&quot;}], [nth 1, nth 2|val]&amp;#93; | tagged
- 左分配逆 when{1=&gt;[nth 1, @1 nth 2], 2=&gt;[nth 1, @2 nth 2]}
- 右分配 δR &amp;#91;[nth 1 | when{1=&gt;&quot;1&quot;, 2=&gt;&quot;2&quot;}], [nth 1, nth 2|val]&amp;#93; | tagged
- 右分配逆 when{1=&gt;[@1 nth 1, nth 2], 2=&gt;[@2 nth 1, nth 2]}

パス式による分岐を with-when構文とすれば、

- 左分配 with $[1] when{1=&gt;@1 [nth 1, nth 2|val], 2=&gt;@2 [nth 1, nth 2|val]}

と短く書ける。実用上使う機会がどのくらいあるかは疑問だが、魅力的な構文だなー。

&lt;hr&gt;
話が前後するが、デカルト半環圏の定義と記号法：

+ 終対象&lt;b&gt;1&lt;/b&gt;と直積×を持つ。
+ 終対象への唯一射を ! とする。
+ デカルトペアリングを &amp;lt;-, -&gt; とする。
+ 直積の射影をπ&lt;sub&gt;1&lt;/sub&gt;、π&lt;sub&gt;2&lt;/sub&gt;とする。
+ 直積を射に対しても拡張して二項関手とする。同じく(-)×(-) で表す。
+ Δは対角とする。
+ 直積に対する左単位律の自然同型をλとする。
+ 直積に対する右単位律の自然同型をρとする。
+ 直積に対する推移律の自然同型をαとする。

+ 始対象&lt;b&gt;0&lt;/b&gt;と直和+を持つ。
+ 始対象から唯一射を θ とする。
+ 余デカルトペアリングを [-, -] とする。
+ 直和の入射をι&lt;sub&gt;1&lt;/sub&gt;、ι&lt;sub&gt;2&lt;/sub&gt;とする。
+ 直和を射に対しても拡張して二項関手とする。同じく(-)+(-) で表す。
+ ∇は余対角とする。
+ 直和に対する左単位律の自然同型をλ'とする。
+ 直和に対する右単位律の自然同型をρ'とする。
+ 直和に対する推移律の自然同型をα'とする。

+ 直積と直和の左分配律の自然同型をδLとする。
+ 直積と直和の右分配律の自然同型をδRとする。

それほど一般的な用語法ではないが：

- left unitor ： 左単位律を与える自然同型
- right unitor ： 右単位律を与える自然同型
- associator ： 推移律を与える自然同型
- left distributor ： 左分配律を与える自然同型
- right distributor ： 右分配律を与える自然同型

□は × か + のどちらかを表すとして：

- 左単位律 1□A ⇒ A
- 右単位律 A□1 ⇒ A
- 推移律 (A□B)□C ⇒ A□(B□C)
- 左分配律 A×(B + c) ⇒ A×B + A×C
- 右分配律 (A + B)×c ⇒ A×C + B×C

</body>
</day>
<day date="2009-11-25" title="">
<body>
*1259118267*[セミナー][プログラム意味論][圏一般論][Mx]双対に関する表

左←→右 は、同じ圏のなかでの双対性、ただし、右は非決定性（ND）な圏なので、決定性の圏を非決定性の圏に埋め込んで双対を考える。

上←→下 は、直積・直和の双対性から導かれる対応。異なるモノイド圏のあいだの対応関係（関手ではない）。

| ＼   |* 自明な構造   |* 非決定性で自明な構造 |
| 直積 |  対角Δ       |  合併∨（∪）   |
| 直和 |  フォールド∇ |  公平な分岐∧   |

対角は自明にコモノイド、フォールドは自明にモノイド。表を横向きに見て：

+ Δ;∨ = 1
+ ∧;∇ = 1

それと、あやとり公式。

</body>
</day>
<day date="2009-11-27" title="">
<body>
*1259298307*[caty][プログラム意味論][論理]コゥゼンを勉強しなきゃ

- http://www.cs.cornell.edu/~kozen/papers/papers_collapsed.htm

ここからいろいろな論文が取れる。

set expressionはtype expressionで、set constraintsはtype constraintsだから、そのまま型推論に使える。しかし、termset代数が、エルブラン方式理論であってタルスキー方式理論じゃないのは問題だ。ちなみに、エルブラン方式（Hrbrand -）、タルスキー方式（Tarskian -）ってのもコゥゼン先生の造語だと思う。エルブラン方式は、ようするに構文的なコンストラクタしか考えない理論。集合は、項の集合に限るし、関数は型構成子に対応するものだけ。

*1259304758*[圏一般論][モノイド圏]公平なマグマ、ベックの法則

ベックの法則の定式化がけっこう分かってきた。これはさすがに書いておかないとな。忘れるからな。

基本的に（メンタルに）想定しているのは多元環Rと加群Mなんだが、モノイドとモノイド作用なら何でも同じこと。ここでは、モノイド構造さえ考えないでマグマを使う。

モノイド圏を固定して、そのなかで考える。×はモノイド積で、繰り返し積は累乗形式で示す。R&lt;sup&gt;n&lt;/sup&gt;→R というn項演算を備えた対象を&lt;strong&gt;n-マグマ&lt;/strong&gt;と呼ぶ。より一般に、(2, 4)-マグマとは、2項演算と4項演算を備えたもの。(0-2)-マグマは、0項から2項までの演算を備えたマグマ。すべての非負整数kに対してk-マグマになっている構造を公平なマグマ（unbiased magma）と呼ぶ。平均値とかはその例。

公平なマグマRと対象Mに関して、ベックのスワッパーとは、β&lt;sub&gt;n&lt;/sub&gt;:M×R&lt;sup&gt;n&lt;/sup&gt;→R&lt;sup&gt;n&lt;/sup&gt;×M という射の族。いちいち下付きnは書かないことにする。

まず、バンドリング（バンドル／アンバンドル）条件を満たさなきゃならない。n = m + k だとして（図の見方は後）：

&lt;pre&gt;
   M×(R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;)
  ---------------
     β
  ---------------
   (R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;)×M

 ==================

   M×(R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;)
  ---------------
      α
  ---------------
   (M×R&lt;sup&gt;m&lt;/sup&gt;)×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
      β×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
  (R&lt;sup&gt;m&lt;/sup&gt;×M)×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
      α
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×(M×R&lt;sup&gt;k&lt;/sup&gt;)
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×β
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×(R&lt;sup&gt;k&lt;/sup&gt;×M)
  ---------------
      α
  ---------------
   (R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;)×M
&lt;/pre&gt;

これは、イコールで区切った上下が同じあることを主張する。で、上下の部分は証明図風だが、射の記述。上から下に流れ落ちる図式を、適当な水平面でスライスしながら描いている。ハイフンの横線は水平面を表す。各段（横線のあいだ、フロア）に射を書く。対象も書いてあるが、対象と恒等射を同一視すれば、全部射（縦方向に描いたワイヤー）だと思ってよい。

下側の図は複雑に見えるが、アソシエータαを律儀に書いてるからで、次でも十分。

&lt;pre&gt;
   M×R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
    β×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×M×R&lt;sup&gt;k&lt;/sup&gt;
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×β
  ---------------
   R&lt;sup&gt;m&lt;/sup&gt;×R&lt;sup&gt;k&lt;/sup&gt;×M
&lt;/pre&gt;

さて、バンドリング条件はスワッパーと呼ぶために必須だが、次にベックの法則。Rが公平マグマで、μがその乗法だとする。正確には、μ&lt;sub&gt;n&lt;/sub&gt;:R&lt;sup&gt;n&lt;/sup&gt;→R の集まりだが、下付きは省略。以下の等式がすべてのnで成立することを主張するのがベックの法則。

&lt;pre&gt;
   M×R&lt;sup&gt;n&lt;/sup&gt;
  --------
   M×μ
  --------
    β
  --------
   R×M

 =============

   M×R&lt;sup&gt;n&lt;/sup&gt;
  --------
    β
  --------
   μ×M
  --------
   R×M
&lt;/pre&gt;

n = 0, 1, 2 で調べると実感が湧く。マグマがモノイドのときは、普通のベックの分配法則に近い。

以上の公平マグマに対するマグマ作用（加群の原始的な概念）を入れると、かなり一般的な枠組みになると思う。

あと参考：

- [http://d.hatena.ne.jp/m-hiyama-memo/20090722/1248222268:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20090721/1248161357:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20090724/1248415299:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20090725/1248504503:title]
- http://d.hatena.ne.jp/m-hiyama-memo/20090714 (複数記事) 両モナドの計算

*1259305986*[caty][プログラム意味論][型検査]型推論の規則

総称ラムダとかを参考にすると、次のようになる。ただし、これは厳密結合の推論で、型制約が出てこない。残念ながら、これでは実用にならないが、キレイにまとまる感じはある。

S, Tなどは型項（または型表現）、f, gなどはコマンド項、M, Nなどは式（formula）だとする。構文の定義は：

+ 名前はコマンド項である。
+ f, gがコマンド項なら、f|g もコマンド項である。（これで定義オシマイ）
+ S, Tが型項なら、S-&gt;T はプロファイルである。
+ αがプロファイル、tが型変数のとき、(t).α はプロファイルである。α内のtは束縛される。
+ fがコマンド項、αがプロファイルのとき、f:α は式である。
+ Mが式でtが型変数のとき、(t).M は式である。
+ Mが式、Sが型項のとき、M[S] は式である。

型項S, プロファイルα≡S-&gt;T に対して、置換作用 [U/t] が定義できる。[U/t]は、&lt;em&gt;自由な&lt;/em&gt;型変数tを型項Uで置き換えること。型のベータ変換は以下のとおり。

- M≡f:S-&gt;T として、M[U/t] = f:S[U/t]-&gt;T[U/t]
- (&amp;#40;t).M)[U] ⇒ M[U/t]

以上の準備のもとで、次の推論規則が意味を持つ。Γは、型環境で、スキーマに対応する。

&lt;pre&gt;
   Γ(f) = α のとき
  ------------------[base]
       f:α
 
   M:S-&gt;T  N:T-&gt;U
  ----------------[comp]
   M|N :S-&gt;U

   M:α （tは自由型変数）
  ----------------------[tabs]
    (t).M : (t).α

   M : (t).α
  -----------------[tapp]
   M[U] : α[U/t]
&lt;/pre&gt;

M:S-&gt;T  N:T-&gt;U という前提を M:S-&gt;T  N:U-&gt;V  T⊆U にするのが安全結合。M:S-&gt;T  N:U-&gt;V で、安全になるための再弱条件を求めるのが非安全結合。非安全結合の推論がやりたいこと。

</body>
</day>
<day date="2009-11-28" title="">
<body>
*1259376829*[復習][課題]圏上のチェーン

- [http://d.hatena.ne.jp/m-hiyama/20090107/1231314845:title]
- [http://d.hatena.ne.jp/m-hiyama/20090108/1231407534:title]

もう一度ちゃんと考える価値がある。


</body>
</day>
<day date="2009-12-04" title="">
<body>
*1259917417*[caty][論理]JSON問い合わせ言語

説明文書としてはメチャクチャ出来が悪い。まーいいや。いつか書き直す。

&lt;b&gt;[追記]&lt;/b&gt;あんまり意味がないところは取消線を付けた。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h4&gt;●基本事項&lt;/h4&gt;

&lt;h5&gt;関係から述語へ&lt;/h5&gt;

JはJSONデータ全体の集合だとして、f:J&lt;sup&gt;n&lt;/sup&gt;→Boolean （Boolean = {true, false}）を関係の特性関数と呼ぶ。以下、関係の特性関数を単に関係と呼ぶ。関係は&lt;em&gt;部分関数でもよい&lt;/em&gt;。n = 0 のとき、つまり0項関係はブール定数なので相手にしない。n = 1 のときは述語、n = 2 なら二項関係、以下同様。

n項関係（ただし、n≧1）Fを、次の方法で、すべて二項関係fとみなす。

+ F(x) に対して、f(x, 0) := F(x) とする。f:J×{0}→Boolean
+ F(x, y)はそのまま。f(x, y) := F(x, y)
+ F(x, y&lt;sub&gt;1&lt;/sub&gt;, ..., y&lt;sub&gt;k&lt;/sub&gt;) に対して、f(x, [y&lt;sub&gt;1&lt;/sub&gt;, ..., y&lt;sub&gt;k&lt;/sub&gt;]) :=  F(x, y&lt;sub&gt;1&lt;/sub&gt;, ..., y&lt;sub&gt;k&lt;/sub&gt;) とする。f:J×Array → Boolean

fは二項関係、aを定数として、φ(x) := f(x, a) の形で定義されるφをfの述語化と呼ぶ。φは1変数ブール値関数であると同時に、後で構文構成素としても使う。任意のn項関係Fから出発して、F→f、f→φ とすることにより、述語＝一項関係が得られる。

φ をラムダ記法で書くと、φ = λx.f(x, a) となり、変数xは束縛され、自由変数（パラメータ）として残るのはaのみ、そこれで、φを @f a と書く。次が成立する。

- φ(x) = (@f a)(x) = f(x, a)

&lt;h5&gt;パス修飾を持つ論理式&lt;/h5&gt;

次が論理式の定義：

+ 述語φは論理式である。
+ Aが論理式のとき、￢A は論理式である。
+ A, Bが論理式のとき、A∧B は論理式である。
+ A, Bが論理式のとき、A∨B は論理式である。
+ Aが論理式、pが単純JSONパスのとき、[p]A は論理式である。

[p]A 以外の論理式の解釈は通常通り。

Aが論理式のとき、JSONデータxに対して、A(x)が定義できる。not, and, or はブール演算だとする。x.p は、get(x, p) のようなパス式pによるアクセスの略記である。

+ Aが述語φのとき、A(x) = φ(x)
+ (￢A)(x) = not(A(x))
+ (A∧B)(x) = and(A(x), B(x))
+ (A∨B)(x) = or(A(x), B(x))
+ ([p]A)(x) = A(x.p)

&lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;TはJの部分集合として、{x∈T | A(x)} を select from T where A とも書く。Tが集合でなく、リスト、バッグのときも同様の記法を使う。&lt;/del&gt;

&lt;h4&gt;●論理式のJSON表現&lt;/h4&gt;

&lt;h5&gt;翻訳規則&lt;/h5&gt;

+ fが二項関係のとき、述語φ = λx.f(x, a) を @f a で示す。実際の構文では、関係名をすべて大文字にして先頭にアンダスコアを付ける。
+ (￢A) の翻訳は、Aの翻訳にタグ @_NOT を付けたものである。
+ (A∧B) の翻訳は、@_AND [Aの翻訳, Bの翻訳] である。
+ (A∨B) の翻訳は、@_OR [Aの翻訳, Bの翻訳] である。

([p]A) の翻訳は、単純JSONパス式の構成に従って：

+ pが名前αのとき、[α]A  の翻訳は {α: Aの翻訳}
+ pがインデックスiのとき、[i]A  の翻訳は [..., Aの翻訳]（i番目の項目）
+ pがq.r の形のとき、[p]A の翻訳は、[q]X の翻訳に [r]A の翻訳を入れ子にする。 

これは分かりにくいので、逆向きの翻訳と一緒に考えたほうがいい。

&lt;h5&gt;基本関係&lt;/h5&gt;

基本関係を示す。

- eq:J×J→Boolean は等号関係
- like:String×String→Boolean はパターンマッチ（右がパターン）
- tag:J×String→Boolean は、tag(x) == a のこと。
- &lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;type:J×Strig→Boolean は、typeof(x) が a とマッチすること。typeofはタグを無視して型名を返す。typeofの値は、&quot;null&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;array&quot;, &quot;object&quot; のいずれか。ただし、typeには、&quot;integer&quot;, &quot;any&quot; も渡せる。&lt;/del&gt;

&lt;h4&gt;●逆翻訳&lt;/h4&gt;

aがJSONリテラルのとき、aを論理式に逆翻訳したものを【a】で示す。

&lt;h5&gt;スカラーリテラル&lt;/h5&gt;

JSONスカラーcは、eq(x, c) を意味する。

- 【c】 = λx.eq(x, c)

&lt;h5&gt;オブジェクトとプロパティ&lt;/h5&gt;

α&lt;sub&gt;1&lt;/sub&gt;などは、プロパティ名（文字列）、v&lt;sub&gt;1&lt;/sub&gt;などはプロパティ値として：

- 【{α&lt;sub&gt;1&lt;/sub&gt;: v&lt;sub&gt;1&lt;/sub&gt;, ..., α&lt;sub&gt;n&lt;/sub&gt; : v&lt;sub&gt;1&lt;/sub&gt;} 】 = λx.(【v&lt;sub&gt;1&lt;/sub&gt;】(x[α&lt;sub&gt;1&lt;/sub&gt;])∧...∧【v&lt;sub&gt;n&lt;/sub&gt;】(x[α&lt;sub&gt;n&lt;/sub&gt;])

プロパティ名 &quot;*&quot; は予約されていて、&quot;*&quot; : v は、明示されてないプロパティ名すべてに【v】を適用することを示す。

&lt;h5&gt;配列と項目&lt;/h5&gt;

- 【[v&lt;sub&gt;0&lt;/sub&gt;, ..., v&lt;sub&gt;n&lt;/sub&gt;] 】 = λx.(【v&lt;sub&gt;0&lt;/sub&gt;】(x[0])∧...∧【v&lt;sub&gt;n&lt;/sub&gt;】(x[n]))

ただし、最後の項目に特殊タグ @_REST が付いていたときは、次の解釈になる。

- 【[v&lt;sub&gt;0&lt;/sub&gt;, ..., @_REST v&lt;sub&gt;n&lt;/sub&gt;] 】 = λx.(【v&lt;sub&gt;0&lt;/sub&gt;】(x[0])∧...∧【v&lt;sub&gt;n-1&lt;/sub&gt;】(x[n-1])∧【v&lt;sub&gt;n&lt;/sub&gt;】(x[n])∧【v&lt;sub&gt;n&lt;/sub&gt;】(x[n+1])∧...)

nより先のインデックスにはすべて【v&lt;sub&gt;n&lt;/sub&gt;】が適用される。&lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;項目が1つしかないときは、@_REST の代わりに @_ALL が使える。&lt;/del&gt;

&lt;h5&gt;タグ&lt;/h5&gt;

アンダスコアからはじまるタグは予約されていて、ユーザーレベルデータの中では使えないとする。αが通常のタグなら：

- 【@α v】 = λx.[tag(x) = α ∧ 【v】(val(x))]

&lt;h5&gt;特殊タグ&lt;/h5&gt;

述語に対応するタグは、プラグイン可能である（が、ユーザーにはたぶん解放しない）。次は予約された特殊タグになり、述語名には使えない。

+ @_REST データ（配列の末尾のみ）
+ &lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;@_ALL データ（配列の先頭のみ）&lt;/del&gt;
+ @_NOT データ
+ @_AND 配列
+ @_OR 配列
+ &lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;@_XOR 配列&lt;/del&gt;
+ @_ANY &lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;0&lt;/del&gt;
+ &lt;del datetime=&quot;2009-12-08T11:56:20+09:00&quot;&gt;@_ 0 （@_ANY 0 の短縮形）&lt;/del&gt;

&lt;hr&gt;
&lt;b&gt;[追記]&lt;/b&gt;ブツブツブツブツ：

@_TYPE &quot;typename&quot; はやめて、@_OBJECT, @_NUMBER などを使うほうがいい。

- [@_INTEGER, @_INTEGER, @_REST @_STRING]

は、スキーマにすると：

- array [integer, integer, string*]

だが、

- [@_INTEGER, @_INTEGER]

は、tuple [integer, integer]を意味しない。array [integer, integer, any*] と同じ意味になる。

- @_AND [@_LENGTH 2, [@_INTEGER, @_INTEGER]&amp;#93;

は酷すぎる。@_REST と対になる @_END（明示的に配列を終端する）を入れて

- [@_INTEGER, @_INTEGER, @_END]

のほうがいいだろう。

キーボードを打った感触では、全部大文字はシフト押しっぱなしが嫌だな。

- [@_Integer, @_Integer, @_End]

しかし、他のところで、$_CONTEXT とか使っているし。

- [@_integer, @_integer, @_end]

これ書きやすい。が、視認性が悪い。

- [@_REST @_GTEQ 0 ]

これは、合法だが気持ち悪い。

- @_ALL @_GTEQ 0
- [@_ALL @_GTEQ 0]
- @_ALL [@_GTEQ 0]
- @_EACH @_GTEQ 0
- @_EACH [@_GTEQ 0]
- @_LIST [@_GTEQ 0]

Catyスクリプトをしばらく使っていれば、@_EACH [@_GTEQ 0] が書きやすい気がする。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2009-12-05" title="">
<body>
*1259981093*[TQFT][雑感]カーラー／リュウバシェンコの本とか

abstractだけ眺めて捨て置きな論文がゴミとなってたまるばかりで、なんかゲンナリしている昨今。

カーラー／リュウバシェンコ（Thomas Kerler, Volodymyr V. Lyubashenko）の本がなかなか入手できなかった（http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%a5%ab%a1%bc%a5%e9%a1%bc）が、入手できた。せっかく届いたけど、これも捨て置きかなー。哀しい。

でも、この本はものすごく絵が多い。絵を見てるだけで楽しい。まったく字は読んでないけど、眺めたら読んだ気がする。素晴らしい（オイッ！）。

手書きの絵が何枚かそのまま掲載されている。清書が間に合わなかったとかの事情だと思うが、かえっていいよね、これ。p.80, 85, 86, 94 あたり。もっとあるかも。

</body>
</day>
<day date="2009-12-07" title="">
<body>
*1260147299*[連絡的]OS機能を直接使ってみる

システムコールwriteを使って、stdout（のファイルハンドル）に整数を10進表記で出力する関数 putn(int) を書きましょう（戻り値はどうでもいい）。printfもそのようにして作られている。


</body>
</day>
<day date="2009-12-08" title="">
<body>
*1260241578*[TQFT][雑感]カーラー／リュウバシェンコ本の付録

付録は短くて独立して読める。

- Aは物理的背景、これはダメだ。僕にはチンプンカンプン。
- Bは二重圏の形式的な話。例がないが、まー、なんとかなりそう。
- Cは厚いタングルの計算、これが一番読みやすそう。絵も山盛りある。


</body>
</day>
<day date="2009-12-14" title="">
<body>
*1260752093*[プログラム意味論][雑感]エルゴット／コンウェイ双対性

エルゴット繰り返しとコンウェイ不動点の関係をもっとちゃんと理解しないと駄目だ。これは、余デカルト圏とデカルト圏におけるトレースの問題。


</body>
</day>
<day date="2009-12-15" title="">
<body>
*1260863564*[連絡的]説教的

上が新しい。

- [http://d.hatena.ne.jp/m-hiyama/20091208/1260234655:title]
- [http://d.hatena.ne.jp/m-hiyama/20091015/1255580321:title]
- [http://d.hatena.ne.jp/m-hiyama/20080729/1217293157:title]


</body>
</day>
<day date="2009-12-18" title="">
<body>
*1261108350*[プログラム意味論][雑記][説明]仕様の話

かつて、次のURLsで書いた短い記事群をまとめてみた。文章はそのまま。

+ [http://d.hatena.ne.jp/m-hiyama/20050506/1115349342:title]
+ [http://d.hatena.ne.jp/m-hiyama/20050629/1120038898:title]
+ [http://d.hatena.ne.jp/m-hiyama/20050629/1120039074:title]
+ [http://d.hatena.ne.jp/m-hiyama/20050629/1120039331:title]

&lt;h4&gt;論理（学）と仕様&lt;/h4&gt;

僕は、マークアップとプログラミング（i.e. XML構文とソフトウェア）をつなぐものは&lt;em&gt;仕様技術&lt;/em&gt;だと思っています。よって当然、仕様の理論に興味があるわけ。

仕様技術についてヨーク考えてみると、それは結局、論理（logic）((「論理学」と書いたほうが誤解が少ないかもしれない。「論理」や「ロジック」はいろいろな意味で使われるから。))と同じことに気がつきます。元来は論理的な概念である充足（satisfaction）と伴意（entailment）が、&lt;em&gt;仕様においても核心&lt;/em&gt;となる概念です。

α、βなどが何らかの表明／条件式（たとえばホーア論理式で書かれた制約）だとして、実装Mに対して、「M satisfies α」という言明（メタ表明、judgement）にハッキリした意味を持たせない限り、仕様の議論は何もできません。

「M satisfies α」は論理（モデル論）における「M |= α」とまったく同じこと（だと定義できます）。まー、実際には、仕様（制約）が1個の論理式で書けるとは限らないので、A = {α1, α2, ...}を論理式の集合（これが仕様記述に対応する）として、「M satisfies A」を、「A satisfies α1 かつ A satisfies α2 かつ … 」として定義しておきましょう。

そうすれば、仕様における伴意（entailment）「A entails B」は、

- M satisfies A となるようなMに対しては常に M satisfies B

であること、として定義できます。言い換えれば、

- 仕様Aを満たす実装Mは、常に仕様Bも満たしている

そのときに、A entails B なわけですね。

&lt;h4&gt;仕様の話(1)：いつもはじまりはホーア式&lt;/h4&gt;

ソフトウェア技術のなかで僕が一番興味を持っているのは&lt;em&gt;仕様技術&lt;/em&gt;です。正確に適切な仕様を記述すること、そしてその仕様をもとに検証ができること、それを望んでいるのですけど、まー、難しいですね、イロイロと。

で、仕様に関して最近思っていることなどを少し書いてみます。

「仕様を書く」という作業では、記述言語が必要ですね。その記述言語の基本単位を文（sentence）と呼びます。ここで、「文」という語は技術用語ですよ、なんとなく使っているわけでもないし、国語辞書的な用法でもないですからご注意。でも、「文」だけだと短すぎるので、以下「記述文」にします。

一番有名な記述文（の構文）はホーア式でしょう。事前条件P、実行部E、事後条件Qを組み合わせて {P}E{Q} という形で書きますが、現在のプログラミング言語との相性からは、中括弧の使用法を逆にして P{E}Q がいいと僕は思います（ので、こっちを使います）。P{E}Q の意味は、「条件Pを満たしている状態で、Eを実行したら、実行後には条件Qを満たす」というものです。

例えば、 (value() &gt;= 0){inc();}(value() &gt; 0) ならば、「value()が&lt;em&gt;0以上&lt;/em&gt;の状態で、inc(); を実行したら、実行後にはvalue()は&lt;em&gt;0より大きく&lt;/em&gt;なる」です。テストコードに直せば：
&lt;pre class=&quot;code&quot;&gt;
if (value() &gt;= 0) {
  inc();
  if (value() &gt; 0 ) {
    return true;
  } else {
    return false;
  }
} else {
  return true;
}
&lt;/pre&gt;

このコードは&lt;strong&gt;仕様違反があったときにだけfalse&lt;/strong&gt;を返します。事前条件が成立してないことは仕様違反ではないのでtrueを返すことに注意してください。事前条件を調整するのはテスターの仕事ですから、(value() &gt;= 0)じゃないから仕様違反だ、は理不尽すぎますね。

[追記]このケースだと、(value() &gt;= 0) が不変条件のような雰囲気がありますが、ほんとに不変条件なら、(true){}(value() &gt;= 0) と書かないと&lt;em&gt;いけません&lt;/em&gt;。

&lt;h4&gt;仕様の話(2)：呼び出しからメッセージへ&lt;/h4&gt;

条件PやQを書くには副作用のない関数（のようなメソッド）が必要です。条件の評価のときに副作用があると、話がとんでもなくややこしくなります。また、条件評価で例外が生じたりするのも望ましくないので、副作用がなくエラーしない関数的メソッドが欲しいわけで、そういうメソッドは&lt;em&gt;アクセッサ、オブザーバー、クエリー&lt;/em&gt;などと呼んだりします。

一方、実行部のところには、メソッド呼び出しか単純代入文（var = method();）を並べるだけにします。これも話をややこしくしないためです。実行部に並べるメソッドのほうは、&lt;em&gt;アクション、コマンド、ミューテータ&lt;/em&gt;などと呼びます。（ここまでの話は、何度かしたことがあります。）

さて、最近、実行部のところをもう少し抽象化したいと思っています。メソッド呼び出しだけでなくて、たとえば、HTTP GET/POSTでやってきたリクエスト＋パラメータとかも同じ枠組みで考えたいのですね。そこで、実行部のところには、外部からやって来たメッセージ（あるいはシグナル）の列を書くのだ、と考えます。メソッド呼び出しもメッセージだと思えばいいので、言葉使いとそれに伴う雰囲気が変わるだけ、とも言えます（が、その効果は無視できないものがあります。）

メッセージとメッセージが引き起こす内部効果は別物なので、MESSAGE causes EFFECTのような書き方をしましょう。さらに、EFFECTは状態遷移と外部へのメッセージ（イベントと言ったほうがお馴染み？）発信に分けて、例えば、次のように書きます（別に記述構文はどうでもいいのですが）。
&lt;pre class=&quot;code&quot;&gt;
on (value() &gt;= 0) receiving {inc();}
  results (value() &gt; 0)
  emits {valueChanged();}
&lt;/pre&gt;

これは、「(value() &gt;= 0)の状態で、{inc();}というメッセージを受け取ると、(value() &gt; 0)の状態になり、{valueChanged();}というメッセージ（イベント）が発行される」ということです。

&lt;h4&gt;仕様の話(3)：仕様のパイプライン結合&lt;/h4&gt;

一般的には、事前条件P、受け取るメッセージ列M、状態遷移（move）m、発行されるメッセージ（イベント）列Nを使って、on P receiving M causes m emits N が仕様記述文てことになります。が、状態遷移は、遷移後の状態が満たす条件＝事後条件を書けば指定できるので、on P receiving M results Q emits N でもいいでしょう。

受信も送信もメッセージとして抽象化してあるので、パイプラインの記述が自然にできます。
&lt;pre class=&quot;code&quot;&gt;
spec Counter {
 // 安全なとき
 on (value() &lt; 100) receiving {inc();}
   emits {valueChanged();}
 // 限界を超えているとき
 on (value() &gt;= 100) receiving {inc();}
   emits {overflow();}
}

spec Alarm {
 on (true) receiving {valueChanged();}
   emits {} // 何も起きない
 on (true) receiving {overflow();}
   emits {warn();}
}
&lt;/pre&gt;

CounterとAlarmを直列結合したものは、次の仕様を満たすことがわかるでしょう。
&lt;pre class=&quot;code&quot;&gt;
spec CounterWithAlarm {
 // 安全なとき
 on (value() &lt; 100) receiving {inc();}
   emits {} // 何も起きない
 // 限界を超えているとき
 on (value() &gt;= 100) receiving {inc();}
   emits {warn();}
}
&lt;/pre&gt;

とまー、こういう仕様の計算が自由にできたらいいな、と思っているのです。

*1261108351*[プログラム意味論][雑記][説明]もっと仕様の話

かつて、次のURLsで書いた短い記事群をまとめてみた。文章はそのまま。

+ [http://d.hatena.ne.jp/m-hiyama/20050630/1120103689:title]
+ [http://d.hatena.ne.jp/m-hiyama/20050630/1120112492:title]
+ [http://d.hatena.ne.jp/m-hiyama/20050701/1120181067:title]

&lt;h4&gt;もっと仕様の話(1)：かたいことばっかり言ってると…&lt;/h4&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050629&quot;&gt;昨日、仕様の話をした&lt;/a&gt;のだけど、もう少し書いておこうかと。この話題になると長くなりがちですね、ヤッパリ。

昨日より：
&gt;&gt;
とまー、こういう仕様の計算が自由にできたらいいな、と思っているのです。
&lt;&lt;
けれども、
&gt;&gt;
まー、難しいですね、イロイロと。
&lt;&lt;
なんです。

「難しい」という話だけだとつまらないので、楽しそうなこと(?)や少しは現実的な話をすることにします。

実際には1人だけで作業するにしても、&lt;em&gt;仕様を書く&lt;/em&gt;（設計）、&lt;em&gt;実装する&lt;/em&gt;、&lt;em&gt;テストする&lt;/em&gt;という3つの立場、役割は区別する必要があります。そうしないと、仕様技術の意義は全然理解できないでしょう。

以下では、仕様を書く人（役割）はあまり考えないで、実装者とテスターについて考えます。-- すごく大事な前提があります。

テスターと実装者のお約束：
+ 実装者は、仕様に書いてあることは守る。だが、仕様に書いてないことはどのように実装してもよい。
+ テスターは、仕様に書いてあることと明白に違う動作にはクレームをつける。だが、仕様に書いてないことでトヤカク言ってはいけない。

つまり、実装者とテスターは、共通の仕様記述以外の手段では情報交換しないことになります。

が、実際には、実装者とテスターの直接コミュニケーションを断っても、それでも、暗黙の情報が流れてしまいます。

例えば、昨日のエントリーで僕は、Counter, value(), inc()のような名前を使いました。これを見て、「incはインクリメント（increement）のことで、カウンタの値を1増やすのだろう」とだいたいの人は思うわけです。つまり、名前を通じて情報が&lt;em&gt;勝手に&lt;/em&gt;流れます。

このことは、名前の付け方が大事であるという教訓を導くと同時に、名前やコメントの印象が「実装とテスト」の役割を曖昧にしてしまう危険性も示唆＜しさ＞します。

例えば、次の2つの記述文（制約）しかない状況を考えます。
&lt;pre class=&quot;code&quot;&gt;
  // 制約1
  on (value() &lt; 100) receiving {inc();}
   emits {valueChanged();}
  // 制約2
  on (value() &gt;= 100) receiving {inc();}
   emits {overflow();}
&lt;/pre&gt;

メッセージ受発信はメソッド呼び出しだとして、次の実装は完全に仕様を満たします。
&lt;pre class=&quot;code&quot;&gt;
int value() {
 return 1;
}

void inc() {
 valueChanged();
}
&lt;/pre&gt;

制約1に従って、inc()が来たらvalueChanged()を発行してます。この実装では、(value() &gt;= 100)という条件が満たされることは絶対にないので、制約2を根拠にクレームされることはあり得ません。つまり、テスターがどんなテストをしようと、クレームを付けられません（完璧！）。

フォーマルな立場からは、「もっと精密に仕様を記述せよ」ということになりますが、そればっかり言うと、仕様技術を&lt;em&gt;誰も使わなくなります&lt;/em&gt;。現実的には：

+ 自然言語記述や、自然言語の意味を利用した伝達を許す。
+ しかし、形式的記述も併用し、形式的に書かれた仕様の充足は絶対条件とする。
となるでしょうか。

今の例では、第3の仕様記述文として「inc()の後では、value()が返す値が1だけ増える」という自然言語文を加えます。すると、いつでも1ばっかり返している当該の実装はダメということになります。

&lt;h4&gt;もっと仕様の話(2)：インクリメント仕様をどう書くの&lt;/h4&gt;

「インフォーマルな記述や伝達は許しましょうね」と言いました。そうでないと、たいてい破綻します。そのことは踏まえた上で、なるべくフォーマルに書くことを引き続き考えます。例は、&lt;em&gt;カウンターのインクリメント&lt;/em&gt;。

inc()が実際にインクリメントであることを正確に書くのはけっこう難しいのです。事前条件は「value()の値が n」で、事後条件は「value()の値が n + 1」ですから、ホーア式では &lt;code&gt;(value() == n){inc();}(value() == n + 1)&lt;/code&gt; です。

が、変数nの扱いが難しい。論理（学）の言葉でいえば、nは、for all n として使われる束縛変数ですから、制約全体の意味は：
&lt;pre&gt;
どんなnに対しても
  「value()の値が n ならば、
    inc(); の後では、
    value() == n + 1」
となる。
&lt;/pre&gt;
となります。

「どんなnに対しても」だから、いろいろな値を片っ端からnに入れてテスト、ってのはバカバカしいですね。実際的には、等号（==）の意味を、「値未定の変数があれば代入操作をして、真とみなす」と解釈すればいいでしょう（これはPrologのユニフィケーションと同じです）。あるいは、汚い記述だけど、&lt;code&gt;(true){n = value(); inc();}(value() == n + 1)&lt;/code&gt; で済ます手もあります。

値の代入がされてないなら代入を行う等号を「:==」とでもして、とりあえず次の形を採用しましょう。（:==の論理的な意味はあくまで「等しい」です。）
&lt;pre class=&quot;code&quot;&gt;
 forall(int n) {
   on (n :== value()) receiving {inc();}
     results (value() == n + 1)
     emits {valueChanged();}
 }
&lt;/pre&gt;

これに対するテストコードは、（メッセージ発信は別にして）次のようにでもすればいいでしょう。
&lt;pre class=&quot;code&quot;&gt;
public boolean testInc(int n) {
 if (n == value()) { // :== の論理的解釈
   inc();
   if (value() == n + 1) {
     return true;
   } else {
     return false;
   }
 } else {
   return true;
 }
}

public boolean testInc() {
  int n;
  n = value(); // :== の手続き的解釈
  return testInc(n);
}
&lt;/pre&gt;

&lt;h4&gt;もっと仕様の話(3)：テストメソッドとテスター&lt;/h4&gt;

仕様記述文のメッセージ受発信をメソッド呼び出しと解釈するなら、&lt;code&gt;on (P) receiving {E} results (Q)&lt;/code&gt; に対して、
&lt;pre class=&quot;code&quot;&gt;
if (P) {
  {E}
  return (Q);
} else {
  return true;
}
&lt;/pre&gt;
としてテストメソッドが書けます。

emits（メッセージ送信）の部分のチェックは、スタブメソッドを作って呼び出しログを取って、ログとつきあわせて検証することにします（ちょっとダサイけど）。

すると、仕様記述文 &lt;code&gt;on (P) receiving {E} results (Q) emits {F}&lt;/code&gt; にテストメソッド（＋ログチェック）が対応します。&lt;code&gt;forall(変数宣言) {文}&lt;/code&gt; のときは、&lt;code&gt;{文}&lt;/code&gt;のところだけをメソッド化して、束縛変数はメソッド引数として人が具体化指定することで我慢しておきましょう（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050630/1120112492&quot;&gt;昨日のtestIncの例&lt;/a&gt;参照）。

さて、仕様記述からテストメソッド一式を準備できたとして、テスターは：
+ テストメソッドを（引数があれば適当な引数で）呼び出す。テストメソッドがfalseを返したら、即座に実装者にクレームする。
+ テストメソッド実行中のスタブ呼び出しログをemits部分と比較して、食い違いがあったら、即座に実装者にクレームする。
+ それ以外では、実装者に何も言わない。

これがテスターの作業です。

こういう前提のもとで、「&lt;strong&gt;テスターや実装者に無駄／無意味な作業をさせない、彼（女）らの労力をできるだけ減らすには、どうしたらいいか？&lt;/strong&gt;」と、そういう問題意識を持つと、仕様技術（の一側面）を理解しやすくなります。特に、&lt;em&gt;仕様技術で論理（学）がヘビーに使われる&lt;/em&gt;理由が納得できると思います。


</body>
</day>
<day date="2009-12-19" title="">
<body>
*1261123136*[caty]スキーマ構文の変更案（ラフ）

他の構文との整合性がなくなってきたとかの理由で、スキーマ構文を変更の予定。

将来的には型関数（型変数を持つ型構築子、総称型）も認める方針として、現状では型演算子を多用することにする。

&lt;h5&gt;構文構成素&lt;/h5&gt;

+ 型定数：意味が定まった型の名前。string, null, anyなど。
+ 型変数：未定な型を意味する。
+ 型関数：型変数を含む型表現、型を受け取り型を返す関数（多くの場合、関手の対象部分）を意味する。
+ 型演算子：型関数と同じだが、特殊な構文。

&lt;h5&gt;型定数&lt;/h5&gt;

+ integer
+ number
+ string
+ boolean
+ null
+ array (新規)
+ object (新規)
+ never
+ any

&lt;h5&gt;型演算子&lt;/h5&gt;

+ '?' オプショナル演算子（単項後置）
+ '|' 排他的ユニオン演算子（2項中置）
+ '&amp;amp;' インターセクション演算子（2項中置）
+ '*' クリーニスター演算子（単項後置）
+ '[', ']' 配列生成演算子（n項前後置）
+ '{', '}' オブジェクト生成演算子（n項前後置）
+ '@' タギング演算子（2項前置）
+ '(', ')' 属性付加演算子（2項特殊）

&lt;h5&gt;型演算子の注意事項&lt;/h5&gt;

+ ユニオン演算子の被演算項は、複数のリテラル、または複数のタグ付き（暗黙タグ含む）型で、排他的でないといけない。
+ クリーニスター演算子は、配列の内部、しかも最後でないと使えない。
+ 属性付加演算子は、関数呼び出しと似た形式で型表現を修飾する。グルーピング用の丸括弧との区別は文脈で行う。

&lt;h5&gt;型ラムダ式&lt;/h5&gt;

「type&amp;lt;型変数の並び&gt; 型表現」という形を型ラムダ式と呼ぶ。typeの直後の型変数は束縛変数になる。型定数と型変数に本質的な違いはないが、型定数はラムダ束縛（型抽象）が禁止されている変数である。

通常のラムダ計算と同じように型ラムダ計算が定義できる。

&lt;h5&gt;型代入&lt;/h5&gt;

構文上は、「型の名前」は型定数と同じである。単に事前に定義されてない名前がユーザー定義型の名前として使える。定義されてない、つまりまだ意味が定まってない型の名前には、自由に型を代入してよい。

aが型の名前（まだ定義されてない）、Eが型表現なら、a = E　は合法な型代入文である。特に、a = type&amp;lt;_X1, ..., _Xn&gt;E; を type a&amp;lt;_X1, ..., _Xn&gt; = E; とも書く。これによって、aという名前の型関数が定義できる。

型引数リストが空 &amp;lt;&gt; のときは常に省略する。スキーマ属性による修飾（あれば）は型引数の直後に付ける。

&lt;h5&gt;例&lt;/h5&gt;

&lt;pre&gt;
type list&amp;lt;_T&gt; = [_T*];
type listMax100&amp;lt;_T&gt; = [_T*](maxItems = 100);
type pair&amp;lt;_X, _Y&gt; = [_X, _Y];
type objPair&amp;lt;_X, _Y&gt; = {&quot;fst&quot;:_X, &quot;snd&quot;:_Y};
&lt;/pre&gt;

array, objectはもはや型名で、次のように事前定義されている。

&lt;pre&gt;
type array = [any*];
type object = {*: any}; // 厳密にはany?だが、?は省略可能というコンベンション
&lt;/pre&gt;

上記のlist型関数（型引数が1つ）は、使用頻度が高いので事前定義としてもいいだろう。従来と違うのは、角括弧が山形括弧に変わることだけ。

&lt;h5&gt;問題&lt;/h5&gt;

- このままでは、任意の高階型（通常の関数型（ベキ）を含めた高階型とは違う。型関数もまた型とみます高階型）が定義出来てしまうので制限しなくてはならない。
- 構文解析が破綻しないか検討する必要がある。


</body>
</day>
<day date="2009-12-21" title="">
<body>
*1261354135*[連絡的]また過去エントリーへの参照

+ [http://d.hatena.ne.jp/m-hiyama/20060131/1138679648:title]
+ [http://d.hatena.ne.jp/m-hiyama/20060201/1138757577:title]

*1261354226*[プログラム意味論][雑記][説明]HoareRules

かつて、次のURLsで書いた短い記事群をまとめてみた。文章はそのまま。

- [http://d.hatena.ne.jp/m-hiyama/20061115/1163573135:title]
- [http://d.hatena.ne.jp/m-hiyama/20061116/1163643653:title]
- [http://d.hatena.ne.jp/m-hiyama/20061116/1163644945:title]
- [http://d.hatena.ne.jp/m-hiyama/20061120/1163981261:title]
- [http://d.hatena.ne.jp/m-hiyama/20061123/1164247264:title]

&lt;h4&gt;HoareRules 記述構文&lt;/h4&gt;

ホーア論理、ホーア式については何度か触れたことがあります（例えば、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060407/1144378577&quot;&gt;「デュアルプログラミングとエクソシストゲーム」&lt;/a&gt;、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20060713/1152758152&quot;&gt;「極小プログラミング言語とホーア論理」&lt;/a&gt;）。ホーア式（ホーア論理における論理文）を記述する構文と実行フレームワークがあると便利そうです。ホーア式というと、その用途として単体テスト／振る舞い記述が思い浮かびますが、その他の用途でも意外に広く適用できるような気がしてきました。

まず構文ですが、JavaScriptやJSON構文を参考にした簡単なものにします。構文上は、明確なデータ型はありません。

字句 -- 文字と名前：
&lt;pre&gt;
nameStartChar ::= [_a-zA-Z] // 英字とアンダスコア
nameChar ::= [_a-zA-Z0-9] // 英数字とアンダスコア
name  ::= nameStartChar nameChar* // 予約語は除く
nmToken ::= nameChar+
&lt;/pre&gt;

名前は、変数名、関数名、定数名に使われます。名前トークンnmTokenはラベル（ルール名）として（それだけに）使用します。字句解析段階でnameとnmTokenの区別は曖昧なので（name⊆nmTokenだから）、字句としてはnmTokenだけでいいかもしれません。

字句 -- リテラル：
&lt;pre&gt;
integer ::= {JSONと同じ}
decimal ::= {JSONと同じ}
number ::= integer | decimal
string ::= {JSONと同じ}
boolean ::= 'true' | 'false'
null ::= 'null'
/* true, false, nullは予約語となる*/
&lt;/pre&gt;

JavaScriptでいうところのオブジェクト／配列のリテラルは当面は入れません（いつか入れる可能性はある）。ここから先のBNFでは、空白と区切り記号で字句に切り分けた後の構文を記述します。

変数と関数：
&lt;pre&gt;
variable ::= name
function ::= name '(' args ')'
&lt;/pre&gt;

値を表す式：
&lt;pre&gt;
value ::= number | string | boolean | null | variable | function
&lt;/pre&gt;

関数の引数：
&lt;pre&gt;
args ::= EMPTY | arg (',' arg)*
arg ::= value
&lt;/pre&gt;

さて、構文的には関数呼び出し（function）なのですが、意味的な区別として、述語とコマンドがあります。
&lt;pre&gt;
precicate ::= boolean | function
command ::= function
&lt;/pre&gt;

条件式（論理式）：
&lt;pre&gt;
condition ::= predicate | andExp | orExp | notExp | '(' condition ')'
andExp ::= condition '&amp;amp;&amp;amp;' condition
orExp ::= condition '||' condition
notExp ::= '!' condition
&lt;/pre&gt;

文とアクション（複文）：
&lt;pre&gt;
statement ::= EMPTY | command | variable '=' function
action ::= '{' statement (';' statement)* '}'
&lt;/pre&gt;

ルール：
&lt;pre&gt;
label ::= '[' nmToken ']'
preCondition ::= '(' condition ')'
postCondition ::= '(' condition ')'
rule ::= label preCondition action postCondition ';'
&lt;/pre&gt;

&lt;h5&gt;注意：セミコロンの使い方&lt;/h5&gt;

アクション（複文）のなかで、セミコロンは文の終端記号ではなくて分離記号です。しかし、空文があるので&lt;code&gt;{foo();}&lt;/code&gt;は&lt;code&gt;{foo();＜空文＞}&lt;/code&gt;と解釈でき、終端記号として使っても問題ありません。&lt;code&gt;{}&lt;/code&gt;も&lt;code&gt;{;}&lt;/code&gt;もOKです。

一方、ルール（ホーア式全体）ではセミコロンが終端記号になっています。空ルールを認めれば、セミコロンを分離記号扱いでもいいのですが、とりあえずこれでいくことにします。（アンバランスさには目をつむる。）

&lt;h5&gt;拡張や変更をするかも&lt;/h5&gt;

- '&amp;amp;&amp;amp', '||', '!' 以外の演算子はいれてません。'=='とかはあったほうがいいかもしれません。
- 事前条件やアクションの省略を許したほうが書きやすいかもしれません。
- パーズ結果のデータ・モデルは定義するもつもりです。

&lt;h5&gt;実装上の問題&lt;/h5&gt;

条件式（論理式）には演算子が入っているので、パージングのとき、演算子の優先順位／結合性、それと括弧の影響を考慮しないとキチンとしたパーズ・ツリーが作れないでしょう。そのへんのところって、パーザー・ジェネレータがやってくれるんだっけ？

&lt;h4&gt;HoareRulesのラベル&lt;/h4&gt;

nmTokenを&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061115/1163573135&quot;&gt;ああいう定義&lt;/a&gt;にすると、name⊂nmToken、integer⊂nmTokenになってしまって、どうも気持ち悪いですね。

しかし、たいていのレクサー・ジェネレータは文脈により字句解析規則を切り替えることができるだろうから、ラベルの認識は別な文脈にすることにしましょう。つまり：
&lt;pre&gt;
/* ルール全体のトップレベルでのみ認識される字句 */
labelChar ::= [-._a-zA-Z0-9] // ハイフンとピリオドも許すことにした
labelToken ::= labelChar+

/* ルール全体の構文定義 */
rule ::= '[' labelToken ']' preCondition action postCondition ';'
&lt;/pre&gt;

labelTokenの定義はルール・トップレベルの、'['から']'のあいだだけで有効。nameやnumberは別な文脈で認識されるので、かぶることはなくなります。

&lt;h4&gt;HoareRulesの関数構文、その意味的区別&lt;/h4&gt;

構文的には関数呼び出しであっても、用途／役割、あるいは型（タイプ）により、次の3種に分類されます。

+ 述語 -- 戻り値はboolean、副作用なし。
+ （狭義の）関数 -- 戻り値の型は任意、値を必ず戻す。副作用なし。
+ コマンド -- 戻り値の型は任意、値がなくてもよい(void戻り値）。副作用があってもよい。

使い方と制限は：

+ 条件式のトップレベルに出現できるのは述語だけ。
+ 条件式の述語引数内に出現できるのは（狭義の）関数だけ。ただし、述語も関数の一種とみなす。
+ アクション（複文の）のトップレベルに出現できるのはコマンドだけ。
+ アクションのコマンド引数内には何でも出現できるが、値を返さないコマンドはまずい。

以後、混乱を避けるために、関数呼び出し構文に対応する実体を&lt;strong&gt;コーラブル&lt;/strong&gt;と呼び、狭義の（副作用なし、値を戻す）関数を単に&lt;strong&gt;関数&lt;/strong&gt;と呼びましょう。原理的には、関数をコマンドとして使っても何の問題もないのですが、&lt;em&gt;ここでは関数とコマンドは排他的概念&lt;/em&gt;としておきます。まとめると：

- 述語⊂関数⊂コーラブル
- コマンド⊂コーラブル
- 関数∩コマンド = 空 （互いに排他的）
- コーラブル = 関数∪コマンド

&lt;h4&gt;HoareRulesの実行フレームワーク&lt;/h4&gt;

構文だけを示しても実感がないでしょうから、どのように実行されるかを記述します。実装言語はJavaということにします。

&lt;h5&gt;コーラブルの実装方式&lt;/h5&gt;

コーラブル（述語、関数、コマンド）に組み込みのものは&lt;em&gt;存在しません&lt;/em&gt;。すべてユーザー定義です。次のようなインターフェースの実装クラスとしてコーラブルを定義します。

&lt;pre class=&quot;code&quot;&gt;
public interface Callable {
 public Object call(Object[] args) throws Exception;
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
public interface Function extends Callable {
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
public interface Predicate extends Function {
 Boolean call(Object[] args) throws Exception;
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
public interface Command extends Callable {
}
&lt;/pre&gt;

コーラブルの名前は、getName()を設けるとかアノテーションで書くとかの方法もありますが、ここでは素朴に“設定ファイル”を使うことにします。設定ファイルの1行は、「種別 名前 クラス名」とでもしておきましょう。例えば：

&lt;pre class=&quot;code&quot;&gt;
predicate empty org.example.hoge.Empty
predicate less org.example.hoge.Less
function add org.example.hoge.Add
command doUpdate com.example.foo.DoUpdate
&lt;/pre&gt;

この方式では次の点を注意する必要があります。

+ 設定ファイルには引数・戻り値の情報がないので、引数の個数・型のチェックはコーラブル実装側の責任になる。
+ ==, &amp;lt;, + などの基本的演算子もないので、コーラブルとして実装する必要がある。
+ コーラブルが所属する名前空間はフラットなので、名前の衝突に気を付ける。

いずれも好ましくない特徴ですが、まー、これでもいいとします。ユーザー定義の（プラグインの）コーラブルは、引数なしコンストラクタで生成されて、設定された種別と名前で使用されます。

問題や要求があれば、コーラブルに関する情報を（アノテーションを含む）リフレクションにより取得して、精密な引数・戻り値情報に基づいた型チェックをフレームワーク側で行うことも考慮します（ってことは、問題／要求がなければ&lt;em&gt;やらない&lt;/em&gt;ってこと）。

&lt;h5&gt;フレームワークの仕事&lt;/h5&gt;

構文解析によって作られたルールのデータ構造をたどりながら、次のチェックをします。

+ 条件式のトップレベルに出現するコーラブルが“存在する述語”であるかどうか。
+ アクションのトップレベルに出現するコーラブルが“存在する”かどうか。
+ 引数内に出現するコーラブルが“存在する関数”であるかどうか。

以前と考えが変わったのは、「アクションのトップレベルはコマンド」の制限をはずして、どんなコーラブルでもよい、としたところです。

次に、式とアクションの評価ですが：

+ 変数は出現したら生成し（データ構造をたどったときに作っておいてもいいが）、初期値はnullとする。
+ リテラルはそれ自身に評価される。
+ コーラブルの呼び出しは、事前に全ての引数を評価して引数リスト（配列）を作り、生成したコーラブル実体のcallを呼び出す。
+ 代入文は、右辺を評価した結果を変数としてセットする。代入文以外の“文の値”は捨てる。

変数とコーラブルは、名前をキーとしてマップで管理するでしょうが、変数とコーラブルで別なマップを使うことにします。つまり、同じ名前の変数とコーラブルを許します（この事を後で使うかもしれない）。

&lt;h5&gt;それから&lt;/h5&gt;

以上のような評価に便利なようにパーズ結果データ構造を考えることにします。それと、ルールの成功・失敗に応じた処理についても考える必要があります。

&lt;h4&gt;HoareRules CallableLibrary&lt;/h4&gt;

コーラブルはすべてユーザー（利用者）定義となるわけだが、このコーラブル群とHoareRules実行フレームワークは切り離そう。適当なインターフェースを仕切りにして、コーラブルの詳細は隠蔽する。
&lt;pre class=&quot;code&quot;&gt;
public interface CallableLibrary {
 // 実行フレームワークから呼ぶ必要があるメソッド群
}
&lt;/pre&gt;

絶対に必要なのは：
&lt;pre class=&quot;code&quot;&gt;
 // 名前をキーとしてコーラブルを取得、なければnullが返る。
 // 僕はgetXxx()よりxxx()が好き

 public Callable callable(String name);
 public Function function(String name); // 述語も関数に含まれることに注意
 public Predicate predicate(String name);
 public Command command(String name);
&lt;/pre&gt;

記事&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20061120/1163981261&quot;&gt;「HoareRulesの実行フレームワーク」&lt;/a&gt;の「フレームワークの仕事」のところを見れば、これだけでも仕事ができるはず（commandは不要とも言える）。

別な考え方としては、「&lt;em&gt;コーラブル実体を取得する必要はない&lt;/em&gt;」点に注目するのもある。ほんとに欲しいのは：

+ 名前からコーラブルの存在確認ができること（検証のとき）
+ 名前と引数配列によりコーラブルを呼び出せること（評価・実行のとき）

&lt;pre class=&quot;code&quot;&gt;
 // 存在確認
 public boolean hasCallable(String name);
 public boolean hasFunction(String name);
 public boolean hasPredicate(String name);
 public boolean hasCommand(String name);

 // 呼び出し
 public Object call(String name, Object[] args) throws Exception;
&lt;/pre&gt;

こっちの方法だと、実行フレームワークはコーラブル実体に触れないので、CallableLibrary内部にコーラブルコードをインラインコーディング（埋め込み）で書き込んだりできて、安直さが増す。
&lt;pre class=&quot;code&quot;&gt;
public Object call(String name, Object[] args) throws Exception {
 if (name.equals(&quot;foo&quot;)) {
  // fooのコード
 } else if (name.equals(&quot;bar&quot;)) {
  // barのコード
 } else {
  throw new CallableNotFoundException(name);
 }
}
&lt;/pre&gt;

絶対必須ではないのだけど、CallableLibraryはコレクション（モノの集まり）だから、メンバー列挙があるほうがいいかも。いまどきのメンバー列挙はイテレータでしょう。が、例えば、lib.allPredicates() で述語が列挙されてもうれしくない。なぜなら、コーラブル実体はメタデータを（名前さえも）持たないので正体不明。そもそも「実行フレームワークはコーラブル実体に触れない」方式とは相容れないし。

名前（文字列）を列挙する、Iterable&amp;lt;String&gt; callableNames(), functionNames(), predicateNames(), commandNames() あたりが妥当かな。まー、実行時にメンバー列挙が必要な状況になるまでは入れなくていいけど（ミニマリスト発想、別名手抜き主義）。


</body>
</day>
<day date="2010-01-04" title="">
<body>
*1262564275*[caty][型検査]Conjunctive Positive Set Constraints

原子論理式（atomic formula）ってのがなんか決まっているとき、それら原子論理式をベースに、∧（連言）、∨（選言）、￢（否定）を使って組み立てた式（formula）の全体が古典論理の式。ド・モルガンの法則を使えば、∧と∨のどちらかと￢だけでも古典論理の式はできる。

原子論理式から∧だけで組み立てた式は連言的論理（conjunctive logic）の式。だが、連言だけではいくら何でも弱いので、普通は連言＋含意（conjunctive implicative logic）まで考える。それに普通の自然演繹があれば、それでラムダ計算と同等（カリー／ハワード対応）。が、連言だけの論理も意味を持つことがある。以下のケースは連言だけを使う事例。

集合を表すつもりの定数記号や変数記号を準備して、集合の演算として∩（ミート、インターセクション）、∪（ジョイン、ユニオン）、＼（集合差）とかを考える。他に、単調な集合関数（を表す記号）を入れてもいい。定数、変数、演算、関数の各種記号を組み合わせて作った表現を項と呼ぶ。さらに、包含（inclusion）を意味する記号⊆を入れて、「項 ⊆ 項」の形を原子論理式とする。

通常の用語法とはまったく違う（論理特有だ）が、原子論理式を正リテラル、原子論理式の否定を負リテラルと呼ぶ。集合を表す項と⊆（等号を入れてもいい）から作られた正リテラル、負リテラルを set constraint という。正リテラル、つまり positive set constraint を連言∧を使って組み立てた論理式を conjunctive positive set constraints と呼ぶ。これはいわば、集合に関する連立不等式系（system of inclusion inequalities）である

conjunctive positive set constraints をCPSCと略記することにして、A、BなどでCPSCを表すとする。このとき、A、Bなどは包含関係式（集合の不等式）の集合であり、変数を含むかもしれない。CPSC Aの変数の集合をVar(A)とする。Var(A) = 空 なら変数を含まない関係式なので、定数や関数の意味が与えられれば真偽が決まる。定数や関数の意味は与えられているとして、連立不等式系としてのCPSCが解を持つとき、充足可能、変数にどんな集合を割り当てても常に成立するならそのCPSCは普遍妥当と呼ぶ。

CPSCはシーケントの左辺と似たもんだと思ってよい。が、コゥゼンのシーケント計算をそのまま採用できるかどうかはわからない（たぶん、そうはしない）。

実際には、CPSC Aに含まれる変数を2組に分けて、x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;; y&lt;sub&gt;1&lt;/sub&gt;, ..., y&lt;sub&gt;m&lt;/sub&gt; として、∀x&lt;sub&gt;1&lt;/sub&gt; ... x&lt;sub&gt;n&lt;/sub&gt;.A を満たす最小のy&lt;sub&gt;1&lt;/sub&gt;, ..., y&lt;sub&gt;m&lt;/sub&gt;を求めたいことが多い。

*1262565171*[連絡的]いいこと言うなー

- http://kaede.to/~canada/doc/issues-of-this-year

</body>
</day>
<day date="2010-01-05" title="">
<body>
*1262664094*[caty]移動予定

やっぱり、現在の日付で書くと取り扱いが面倒だ。今日の分は、過去に引っ越すだろう。

実際引っ越した。
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/19100105&quot;&gt;移動先（100年前）&lt;/a&gt;


</body>
</day>
<day date="2010-01-09" title="">
<body>
*1263025526*[caty][論理][型検査][プログラム意味論][その他代数]Σコゥゼン σ-順序代数

デクスター・コゥゼンの &quot;A Complete Gentzen-style Axiomatization for Set Constraints&quot; とか読んで思ったこと。

「Σコゥゼン σ-順序代数」という概念を考えた。Σ-kozen σ-ordered algebra, あるいは、Σ-kozen ordered σ-algebra かな。コゥゼンの termset algebra の一般化なんだけど、単に一般化しました、ってわけじゃなくて&lt;em&gt;必要性があった&lt;/em&gt;。まずは、σ-順序代数から説明する。

等式的論理に、定数記号 0, 1 と 演算記号∩、∪、関係記号⊆（記号は何でもいい、'≦'とかでもいい）を入れて、束と順序の公理を付け加えた等式的理論（equational theory）を考える。0, 1 は最小元と最大元。∪は無限個の項を取ってもいいとする。この理論（公理系）のモデルは束；もちろん、等号'='は実際の「等しい」として解釈する。σは、演算記号の集合だとする。σは空であってもかまわない。σは指標、コゥゼンは ranked alphabet と呼んでいる。

演算子記号（関数記号と本質的に同じ）としてσを加えて、σの演算に関する法則を等式、または不等式（'⊆'を使った論理式）で与えた理論を考える。このようにして定義される理論のモデルを総称してσ-順序代数と呼ぶ。⊆（場合によっては=さえも）他の演算や関係の組み合わせで定義されてもかまわない。演算が先か順序が先かは問わない。

σ-順序代数の例には、束、ブール束、分配則、加法的ベキ等な可換半環、クリーネ代数などがある。これらの例は、演算が先にあれば順序を事後的に定義できる。その他、順序が事前または事後的に定義できるならなんでもいい。σには、補集合、集合差、クリーネスターなどが入る。

Σは、σとは別に与えられた指標（ranked alphabet）。こっちは、コンストラクタ記号の集まりだと考える。σ-順序代数の理論に対して、Σの記号も入れて項の定義を拡張する。さらに、次の公理を付け加える。x, yなどは任意の項だが、理論（の言語）内に変数があり、自由変数の置換ができるなら、x, yなどは変数だとしてもよい。f, gなどはΣに含まれる関数記号。

+ [ジョイン演算の保存]f(..., x∪y, ...) = f(..., x, ...)∪f(..., y, ...)
+ [全射性（生成性）] ∪f(1, ...,1) = 1、ただしすべてのf∈Σに関して合併をとる。fには定数記号も含まれる。
+ [分離性（排他性）] f≠g ならば、f(1, ..., 1)∩g(1, ..., 1) = 0。f, gには定数記号も含まれる。
+ [非退化性] 有限個のx&lt;sub&gt;i&lt;/sub&gt;に関して ∧(x&lt;sub&gt;i&lt;/sub&gt; ≠ 0) ならば、f(x&lt;sub&gt;&lt;/sub&gt;, ..., x&lt;sub&gt;&lt;/sub&gt;) ≠ 0

σ-順序代数を、Σにより拡張して、上記の公理系を付け加えた理論を、もとの理論の&lt;strong&gt;Σコゥゼン拡張&lt;/strong&gt;と呼ぶ。Σコゥゼン拡張のモデルを&lt;strong&gt;Σコゥゼン σ-順序代数&lt;/strong&gt;と呼ぶことにする。σに含まれる演算に関する法則を追加することがある。コゥゼンのもとの例では、任意のfが集合差を保存することを公理に入れている。

Catyの文脈では、JSONインスタンス領域上の型（部分集合）の代数がΣコゥゼン順序代数になる（σが空のときは、「σ-」を省略する）。Σは以下の集合の合併である。

+ スカラーリテラル（定数）
+ {[-*], [-, -*], [-, -, -*], ...}（配列構成子）
+ {α&lt;sub&gt;1&lt;/sub&gt;:-, ..., *:-?}, α&lt;sub&gt;1&lt;/sub&gt;:-, ..., α&lt;sub&gt;n&lt;/sub&gt;∈プロパティ名 （オブジェクト構成子）
+ @α -, α∈タグ名 （タギング演算子）


</body>
</day>
<day date="2010-01-13" title="">
<body>
*1263366406*[caty][型検査][論理][プログラム意味論][用語法]型解析がだんだんわかってきた

100年前の日付を付けてなんだかんだ書いている（例えば、http://d.hatena.ne.jp/m-hiyama-memo/19100110）。

コゥゼンの集合制約（set constraints）を参考にしているが、types as sets の立場の型理論なので、type constraintsといったほうが実情にあっている。関係記号が⊆だから、type inclusion または type inequality（どっちも略称はTI）の連言的コレクション（conjunctive collection）なので、CCTIとか呼ぼうかとも思ったが、アクロニムは覚えにくいので type constraints でもいいか。

がしかし、別なところで用語法で困った。コゥゼンに従えば、S⊆T が正の制約で、￢(S⊆T) が負の制約になる。原子論理式とその否定を、正リテラル／負リテラルと呼ぶ習慣があるから、まー当然。だけど、僕の用途では：

+ 正の命題 S⊆T 
+ 否定命題 ￢(S⊆T)
+ 負の命題 S∩T = &lt;b&gt;0&lt;/b&gt;

となる。ここで、&lt;b&gt;0&lt;/b&gt;は空集合。S∩T = &lt;b&gt;0&lt;/b&gt; は S⊥T と書き、￢(S⊆T) は S!⊆T と書くと短く書ける。

あくまでCatyと僕の状況での話だが、正の命題 S⊆T を否定した命題 S!⊆T だけでは不十分で、より強い負の命題 S⊥T が必要。この意味（コゥゼンじゃなくて僕の意味）での負の命題は、正の命題とほとんど排他的になる。S⊆T と S⊥T を仮定して：

- S∩S ⊆ T∩S
- S ⊆ T∩S
- S ⊆ &lt;b&gt;0&lt;/b&gt;
- S = &lt;b&gt;0&lt;/b&gt;

となるので、正の命題と負の命題が両立するのは S = &lt;b&gt;0&lt;/b&gt; のときに限られて、空でないSを考えれば、どちらか一方しか成立しない。互いに否定の関係ではないのだが、排他的となる。

正の命題、負の命題、それぞれの否定の現実的な意味は：

+ S⊆T 何の問題もない、素晴らしい。
+  ￢(S⊆T) 問題がある、要注意だ。
+ S∩T = &lt;b&gt;0&lt;/b&gt; 全然ダメ。ハナシにならない。絶望的。
+ S∩T ≠ &lt;b&gt;0&lt;/b&gt; なんともいえないが、望みはある。試してみよう。

Catyの型解析では、証明ターゲットは S⊆T なんだが、この正の命題を証明するのがほんとの目的ではなくて、負の命題の成否のほうが重要。もし、全然ダメが分かったら実行してはいけないのだから。正の命題の証明が失敗しても、実は希望があって、負の命題の否定「望みはある」ならば、実行時チェック条件を付けて実行に回せる。

自分で言うのもなんだが、Catyの型システムとそれに伴う演繹系（SILと呼んでいる）はよく出来ていて、帰納的構成の基底の部分では：

- 正の命題の否定が負の命題と一致する。

この性質はモデル論からいえることだが、公理に入れてしまえばいい。すると、ボトムアップな構成から正の命題も負の命題も証明できる。

正の命題と負の命題を別々に証明する必要はなくて、正の命題が証明できないことから負の命題の成立を帰結できる。基底部分では、「正の命題の否定が負の命題」なんだが、さらにSIL演繹系はあるモデルに対して完全なので、

- 正の命題の証明がない
- 正の命題は成立しない
- 負の命題が成立する

と言える。基底部分から（ボトムアップに）ステップを踏むアルゴリズムもある。

問題は2つあって：

+ 都合のよいモデルを作ること
+ 「証明できない」ことを判定するメタアルゴリズムを作ること

モデルは、とある論理系（SILとは別）によりdefinableな集合の全体を取ればいいことが分かっている。メタアルゴリズムも目星は付いているのだが、最初は手作業と目視しか手段がないので、作業的にシンドイ。ハッキリ言って疲れている。

</body>
</day>
<day date="2010-01-21" title="">
<body>
*1264036514*[後で消す][子供]4時に美容院

3:30にはうちに帰る。


</body>
</day>
<day date="2010-01-22" title="">
<body>
*1264128518*[caty-depl]Pythonをビルド

[caty-depl] というタグで、Catyの配備に関するメモを書くことにした。時間順（今日は、上から下に向かう順でエントリーを書く）が前後してしまうことになるが、とりあえずPythonのビルドから。

さくらサーバー（さくらの専用サーバSempron）を使っているが、/usr/bin/python は、2.3.4だった。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ which python
/usr/bin/python
[hiyama@microapplications ~]$ python -V
Python 2.3.4
[hiyama@microapplications ~]$ ls -lFi /usr/bin/py*
1103933 -rwxr-xr-x  2 root root 5396 Jul 26  2008 /usr/bin/python*
1103853 lrwxrwxrwx  1 root root    6 Oct  7  2008 /usr/bin/python2 -&gt; python*
1103933 -rwxr-xr-x  2 root root 5396 Jul 26  2008 /usr/bin/python2.3*
[hiyama@microapplications ~]$ python
Python 2.3.4 (#1, Jul 25 2008, 14:24:21)
[GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path (以下、折り返した)
['', 
'/usr/lib/python2.3/site-packages/setuptools-0.6c7-py2.3.egg', 
'/usr/lib/python2.3/site-packages/TracXMLRPC-0.1-py2.3.egg', 
'/usr/lib/python2.3/site-packages/Genshi-0.4.4-py2.3.egg', 
'/usr/lib/python23.zip', 
'/usr/lib/python2.3', 
'/usr/lib/python2.3/plat-linux2', 
'/usr/lib/python2.3/lib-tk', 
'/usr/lib/python2.3/lib-dynload', 
'/usr/lib/python2.3/site-packages', 
'/usr/lib/python2.3/site-packages/PIL', 
'/usr/lib/python2.3/site-packages/gtk-2.0']
&gt;&gt;&gt;
&lt;/pre&gt;

suして、なんやかんや。

&lt;pre class=&quot;out&quot;&gt;
# wget http://www.python.org/ftp/python/2.6.4/Python-2.6.4.tgz
# tar zxvf Python-2.6.4.tgz
# cd Python-2.6.4
# ./configure --prefix=/usr/local/python
# make
# make install
&lt;/pre&gt;

これで、

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ /usr/local/python/bin/python -V
Python 2.6.4
&lt;/pre&gt;

prefixを、/usr/local/python じゃなくて /usr にすると、以下にインストールされる。

+ /usr/bin/python
+ /usr/lib/python2.6/
+ /usr/include/python2.6/

標準的な利用では、/usr直下におくべきだろうが、とりあえずはこのままにして、パスを追加しておこう。

&lt;pre class=&quot;code&quot;&gt;
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=/usr/local/python/bin:$PATH:$HOME/bin

export PATH
unset USERNAME
&lt;/pre&gt;

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ . ~/.bash_profile
[hiyama@microapplications ~]$ which python
/usr/local/python/bin/python
[hiyama@microapplications ~]$ python -V
Python 2.6.4
[hiyama@microapplications ~]$ python
Python 2.6.4 (r264:75706, Jan 21 2010, 23:22:41)
[GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', 
'/usr/local/python/lib/python26.zip', 
'/usr/local/python/lib/python2.6', 
'/usr/local/python/lib/python2.6/plat-linux2', 
'/usr/local/python/lib/python2.6/lib-tk', 
'/usr/local/python/lib/python2.6/lib-old', 
'/usr/local/python/lib/python2.6/lib-dynload', 
'/usr/local/python/lib/python2.6/site-packages']
&gt;&gt;&gt;
&lt;/pre&gt;

*1264128519*[caty-depl]使っているシステムは

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ uname -a
Linux microapplications.net 2.6.9-78.0.5.plus.c4 #1 Wed Oct 8 13:39:28 EDT 2008 i686 athlon i386 GNU/Linux
[hiyama@microapplications ~]$ cat /proc/version
Linux version 2.6.9-78.0.5.plus.c4 (mockbuild@builder16.centos.org) (ここで折り返した)
(gcc version 3.4.6 20060404 (Red Hat 3.4.6-10)) #1 Wed Oct 8 13:39:28 EDT 2008
[hiyama@microapplications ~]$ cat /etc/redhat-release
CentOS release 4.7 (Final)
[hiyama@microapplications ~]$ gcc --version
gcc (GCC) 3.4.6 20060404 (Red Hat 3.4.6-10)
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

[hiyama@microapplications ~]$
&lt;/pre&gt;

*1264128520*[caty-depl]ユーザーの追加

sudo useradd -g member m-hiyama がうまくいかない。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ sudo useradd -g member m-hiyama
hiyama@microapplications Password:
sudo: useradd: command not found
[hiyama@microapplications ~]$
&lt;/pre&gt;

hiyamaからsuしてみると：

&lt;pre class=&quot;out&quot;&gt;
# echo $PATH
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/python/bin:/usr/bin:/bin:/usr/local/bin:/home/hiyama/bin
&lt;/pre&gt;

なんかパスが足りないみたいな。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ su -
Password:
Script started, file is /root/log/root_20100122-10:37:54.log

[root@microapplications ~ 10:37:54]
# echo $PATH
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin

[root@microapplications ~ 10:38:01]
# which useradd
/usr/sbin/useradd

[root@microapplications ~ 10:38:04]
# useradd -g member m-hiyama

[root@microapplications ~ 10:39:07]
# passwd m-hiyama
Changing password for user m-hiyama.
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.

[root@microapplications ~ 10:39:24]
#
&lt;/pre&gt;

これで、hiyama以外にm-hiyamaもできた。

&lt;pre class=&quot;out&quot;&gt;
hiyama@microapplications ~]$ su - m-hiyama
Password:
[m-hiyama@microapplications ~]$ ls -al
total 40
drwx------   3 m-hiyama member 4096 Jan 22 10:40 .
drwxr-xr-x  18 root     root   4096 Jan 22 10:40 ..
&amp;#45;w-r--r--   1 m-hiyama member   24 Jan 22 10:40 .bash_logout
&amp;#45;w-r--r--   1 m-hiyama member  191 Jan 22 10:40 .bash_profile
&amp;#45;w-r--r--   1 m-hiyama member  124 Jan 22 10:40 .bashrc
&amp;#45;w-r--r--   1 m-hiyama member  383 Jan 22 10:40 .emacs
&amp;#45;w-r--r--   1 m-hiyama member  120 Jan 22 10:40 .gtkrc
drwxr-xr-x   2 m-hiyama member 4096 Jan 22 10:40 .xemacs
&amp;#45;w-r--r--   1 m-hiyama member  658 Jan 22 10:40 .zshrc
[m-hiyama@microapplications ~]$
&lt;/pre&gt;

普通のユーザーのパスに/usr/sbinがないのね。PATH=/usr/sbin:$PATH; sudo ... とすればいいのか。どうもそうらしい。

*1264133296*[caty-depl]次は、、、

Mercurialをインストールしたほうがよさそう。だが、easy_installを使うのがよさそう。easy_install自体はyumでインストールできるらしいが、rpmを直接使ってみようか。

- # rpm -qa  インストール済みのパッケージを列挙
- # rpm -qi pkg 特定パッケージの情報
- # rpm -ql pkg 特定パッケージがインストールされているディレクトリ情報

インストール作業は

- # rpm -i rpm 新規インストール
- # rpm -ivh rpm 進捗を'#'で表示（1個で2%）
- # rpm -U rpmアップグレード
- # rpm -Uvh rpm 進捗表示
- # rpm -e pkgfull アンインストール

yumに関してもメモしておく。

- $ yum info パッケージ情報、けっこうな量の出力
- $ yum check-update アップデート可能なパッケージの一覧を表示
- $ yum list 利用可能なパッケージの一覧を表示
- $ yum list installed インストール済みパッケージの一覧を表示
- $ yum list updates アップデート可能なパッケージの一覧を表示
- $ yum search keyword キーワードでパッケージを検索する。

必要なソフトウェアスタックを自分で構成するって作業がなー、好きな人にはいいだろうが、僕みたいなモノグサには苦痛以外のなにものでもないな。あーー、嫌だイヤだ。

やっぱり、Amazon EC2を使って出来上がりマシンイメージを保存して使いまわすのがいいのかもしれないな。

*1264142010*[caty-depl]サーバーを調べる

とにかく僕はサーバー管理／システム管理が&lt;em&gt;大嫌い&lt;/em&gt;だから、さくらサーバーもH君に完全に任せていた。で、こいつは未知のマシンも同様。

「なにがどうなっているんじゃい？？」を調べるために、使った／使うであろうコマンドやファイルを列挙。

+ hostname この機械の名前
+ uname -a もっと詳しく
+ cat /proc/version OSに関する情報
+ cat /etc/sysconfig/network ネットワーク基本情報、HOSTNAMEも入っている
+ /sbin/service network status ネットワークがおよそどうなっているか？
+ ls /etc/sysconfig/network-scripts/ifcfg-* どんなインターフェースがあるかな？
+ cat /etc/sysconfig/network-scripts/ifcfg-eth0 IPアドレスとネットマスクが分かる
+ cat /etc/sysconfig/network-scripts/ifcfg-lo こっちはローカル・ループバック
+ cat /etc/resolv.conf ネームサーバーが書いてある
+ less /etc/nsswitch.conf 情報を調べるバックエンドを何使っているか？
+ cat /etc/hosts とりあえず見ておく
+ /sbin/ifconfig ここにもIPアドレス
+ top 走っているプロセス
+ ps -lA | grep XXX プロセスを探す
+ sudo /usr/sbin/lsof -i | less ソケットを使っているプロセス
+ df ディスクはどんな感じ
+ cat /etc/mtab  マウントは？
+ cat /etc/fstab ファイルシステムは？
+ rpm -ql httpd | less Apacheのインストール状況

*1264147649*[caty-depl]ドメインとWebサーバー

ドメインの制度的なことがさっぱりわからん。さくらにドメインオプション付けているけれど、、、

https://secure.sakura.ad.jp/menu/top/ のメニューから分かる情報は：

|*ドメイン名            |*状態  |*種別       |*有効期限日|
| microapplications.net |利用中 |ネームサーバ| - |
| commuworld.org        |利用中 |ネームサーバ | - |

&lt;b&gt;microapplications.net&lt;/b&gt;
| シリアル 	|2008061600|
| 更新間隔(Refresh) 	|3600|
| リトライ(Retry) 	|900|
| 有効期限(Expire) 	|3600000|
| 最小TTL 	|3600|

ゾーン情報：
|*エントリ名  	|*タイプ  	|*データ|
| @ 	 |NS 	 |ns1.dns.ne.jp.|
|        |NS 	 |ns2.dns.ne.jp.|
|        | A 	 |219.94.153.157|
|        | MX 	 |10 @ |
| www 	 |CNAME | @|
| mail 	 |CNAME | @|
| ftp 	 |CNAME | @|
|juncture| CNAME| @|

&lt;b&gt;commuworld.org&lt;/b&gt;も同様だが
|*エントリ名  	|*タイプ  	|*データ|
| @  	 |NS  	| ns1.dns.ne.jp.|
|        | NS 	| ns2.dns.ne.jp.|
| www 	 |A 	| 219.94.153.157|
| dev 	 |CNAME | www |

これが情報の全て。新しいドメインを貼りつけたいときは、さくらに申請するようだ。
&gt;&gt;
登録担当者が申請情報確認し、作業が終了しましたら  ×××＠chimaira.org 宛てにご報告差し上げます。 
&lt;&lt;

それはそうとして、
&lt;pre class=&quot;out&quot;&gt;
$ service httpd status
httpd (pid 25779 25778 25777 25776 25775 25774 25773 25772 4220) is running...
&lt;/pre&gt;

httpd = Apatche は走っているようだ。これから、/etc/httpd/ を調べるわ。


</body>
</day>
<day date="2010-01-23" title="">
<body>
*1264205853*[caty-depl]今日も調べる試す

今日もCatyの配備に関して調べたり試したりする。エントリーは、時間順に上から下に向かって書いていく（アペンド方式）。

それにしても、たいして興味の無いことを調べたり試したりは苦痛だ。この苦痛な感じが、僕は人より強いか、あるいは苦痛への耐性がとても弱いのだろう。だから、学校とか会社とかには全く適性がなかったのだろうな。しかし最近、「仕事とは、ようするにやりたくも無いことをやることだ」と説教された、という経緯もあるから、まー我慢すべ。

*1264212019*[caty-depl]Catyの配備に関するおよその方針

網羅的に調べたり、徹底的に考えたわけではないが、現状におけるおよその方針を書いておく。考えがまとまったら本編にも書くだろうが、今はまだ叩き台。

Catyが圧倒的に重視しているのは「分かりやすさ」「単純さ」だ。そのために他のことを犠牲にすることに、僕はなんの躊躇も感じない。が、「欠点を自慢するな」とも説教された（いや、ご忠告いただいた）。

主に犠牲になるのはパフォーマンスと柔軟さ。しかし、中小サイトで問題になることはないだろうと思う。ある程度の規模とアクセスを持つサイトではどうか？ それをこれから考える。本音を言えば「大規模サイトはスコープ外」なんだが、小規模で始めたら意図せずにアクセスが爆発したらどうする？ に対する答を用意しておかないと、さすがにマズイ。

&lt;h5&gt;プラットフォーム・アダプターは不要だろう&lt;/h5&gt;

当初の計画では、プラットフォーム・アダプターと称して、次のような実行形態に対応する予定だった。

+ CGI
+ FastCGI
+ mod_python
+ mod_wsgi

今あらためて考えると、CGIはもう無理ムリ。FastCGIも何がうれしいか分からない。mod_pythonは既に死んでいる。やるにしてもmod_wsgiだけだろう。だが、mod_wsgiだって別に要らん気がする。

僕もKuwataさんも「世間はやっぱりApacheだし」という強迫観念があったのだが、もうイイヤ。今（Sat Jan 23 2010）僕は、nginx（http://wiki.nginx.org/Main）で十分だと思っている。とはいっても、Apacheを無視はできないので別途考えるが、推奨はnginx。

外部からのHTTPリクエストを受けるサーバーをフロントサーバーと呼ぶ（普通はフロントエンド・サーバー）ことにして、フロントサーバーにnginxを使い、ひとつまたは複数のCatyサーバーをその背後に置く -- これをCatyの標準構成／推奨構成としたい。

&lt;h5&gt;フロントサーバーへの期待&lt;/h5&gt;

フロントサーバーに何を使うかはともかくとして、次のことはフロントに任せたい。

+ SSL -- Catyサーバー単体での運用を考えると、SSLくらいはCaty本体にもあったほうがいいだろうが、ポート443番のlistenはフロントがやって、Catyサーバーは単に80番から入って来たように扱えばいいなら、楽だ。
+ 静的コンテンツのキャッシュ -- Catyは静的コンテンツと動的なコンテンツを区別しない。静的・動的を別な場所に置いて重ね合わせる方式も極めてわかりにくいので嫌だ。つまりはURLを見ても静的・動的の区別はできない。というわけで、事情がめんどくさいのだが、キャッシュはフロントでやって欲しい。
+ ロードバランシング -- 複数のCatyサーバーへのリクエストの振り分け。セッションとストレージ（mafs含む）の共有が問題になるが、パフォーマンスを上げるために必要。

http://wiki.nginx.org/NginxModules を見ると次のようなモジュールがある。

- HTTP Access : Allow/deny based on IP address.
- HTTP Auth Basic : Basic HTTP authentication.
- HTTP Headers : Set arbitrary HTTP response headers.
- Log : Customize access logs.
- Image Filter : Transform images with Libgd
- Substitution : Replace text in pages

こんなゴタゴタをCatyサーバーにやらしたくはない。フロントさんお願いします。

&lt;h5&gt;全体の構成案&lt;/h5&gt;

フロントにnginxまたはApacheを置く。フロントはポート80番と443番を見てる（「聞いてる」か）。背後にCatyサーバーが数個いるが、例えば次のような構成。

- localhost:8000 フロントと同じ機械
- localhost:8001
- localhost:8002
- www2.private.lan:8000 LAN内の別な機械にいるCatyサーバー
- www3.private.lan:8000

これらのサーバー間では、セッション、ファイルシステム（mafs）、JSONストレージ、場合により普通のRDBを共有しなくてはいけない。

- mafsとJSONストレージは、完全に抽象化されているので、バックエンドは何でもいい。最近いろいろあるKey-Value Storeを選んで、それでmafs、JSONストレージを実装すればよい。特に、カウチDBが有望。
- セッションは共通ストレージに入れてもいいが、クッキーにセッションデータ（＝状態値）自体を入れてしまう方法を考慮すべきだろう。

&lt;h5&gt;フロントでのキャッシュ&lt;/h5&gt;

Catyがサービスするコンテンツがフロントでキャッシュ可能かどうかはCatyじゃないと分からない。フロントにキャッシュを任せたいなら、次のような仕掛けが必要。

- Catyにリクエストが来たら、キャッシュ可能かどうかを判断して、レスポンスヘッダに情報を書き込む。
- フロントがその情報を読んで、キャッシュ可能なコンテンツは手元に取っておく。
- キャッシュ期限が切れるまでは、フロントが直接返す。このため、Catyサーバーに負担がかからない。
- キャッシュの期限が切れれば、再びCatyにリクエスが行く。コンテンツの更新があっても、この期間は更新されないが、それはキャッシュなんだからしょうがない。

Catyサーバーがすることは、コンテンツがキャッシュ可能かどうかを判断して、適切なキャッシュ期間を設定すること。

&lt;h5&gt;URLのマッピング&lt;/h5&gt;

「URLを書き換えたりマップしたりしない」はCatyの原則である。フロントが書き換えるのは勝手、ともいえるが、Catyクラスター構成でも、URLのマッピングは最小限に留めるべきだろう。

例えば、//example.jp/ をフロントで受けて、//example.jp/hiyama/ だけを1つのCatyでサービスするなら、//example.jp/hiyama/ --&gt; //localhost:8000/ とマップされ、//example.jp/hiyama/ より下のパスはすべてCatyが扱う。//localhost:8000/ じゃなくて、//caty.private.net:8000/ （LAN内の他の機械）でもいい。

2つのCatyサーバーが完全なコピーとして動いているときは、//example.jp/ が、//localhost:8000/, //localhost:8001/ に（例えばラウンドロビンで）マップされる。

複数のアプリケーションを別々なCatyサーバーで実行することもあるだろう。//example.jp/docs/ --&gt; //localhost:8000/, //example.jp/blog/ --&gt; //localhost:8001/ とか； この場合は、2つのCatyのルートアプリケーションがそれぞれ、docsとblogになる。ちょっと分かりにくいので、//example.jp/docs/ --&gt; //localhost:8000/docs/, //example.jp/blog/ --&gt; //localhost:8001/blog/ のほうがいいと思う。このとき、Caty側のルートは無意味になるが、開発時にだけルートを使い、捨て置けばいい。

ただし、CatyのアプリケーションはCatyのルート直下にしかマウントできないから、//example.jp/hiyama/blog/ を //localhost:8000/hiyama/blog/ にはマップできない。このときは、//example.jp/hiyama/blog/ --&gt; //localhost:8000/blog/ とマップするか、hiyamaを1つのCatyアプリケーションと考えて、//example.jp/hiyama/ --&gt; //localhost:8000/hiyama/ とするしかない。

その他、いろいろなマップ方式があるだろうが、Catyサーバーは単純に800x番からのHTTPリクエスを処理する以外に「何も考えなくていい」という構成にしたい。

&lt;h5&gt;コマンドに影響があってはダメ&lt;/h5&gt;

コマンドが構成に影響されのは最悪。コマンド作者は作法を守る必要があるが、フレームワーク側も次の情報を抽象化しなくてはならない。

+ ファイルシステム（mafs API）
+ JSONストレージ（strg API）
+ セッション（環境変数？、独立したファシリティ？）

クラスター環境でセッション・リプリケーションは面倒だしやりたくない。コマンドプログラマから見てもセッションはいじりたくない。セッションには、もっと工夫が必要だ。

&lt;h5&gt;Apacheの考慮&lt;/h5&gt;

フロントとしてApacheを使えるようにすべき理由は：

- なんだか分からない理由でApacheしか使えないことは多いだろう。
- なんとなくApacheがいいという人も多いだろう。
- Apacheモジュールがいっぱいあるから、フロントでのキャシュのように、Catyが要求している機能を探しやすいかもしれない。

*1264214522*[caty-depl]制作作業と配備作業

「サイトがとにかく簡単に作れる」に関して、Catyはけっこう実現出来てきた。が、Catyは業務用ツールなんで、業務の最初から最後までサポートしないといけない。サイト作成段階での顧客とのコミュニケーションや、納品物の作成、本番カットオーバー、更新・メンテナンスまで。

Catyが推奨するワークフローでは、制作の最初からサイトを顧客と共有する。この方法は、今のWeb業界からは嫌われそうな要素を含むんだが、そうすべきだと思う。これが嫌なら、出来上がってからまとめて納品することももちろん可能だし。

「サイトを顧客と共有」にも色々なやり方がある。

- それぞれのローカルPCにCatyをインストールして、サイトデータを適宜交換する。
- 顧客はLAN内にテスト＆ステージング・サーバーを持ち、サイトデータを適宜交換する。
- 同一のテスト＆ステージング・サーバーにアクセスする。

いずれにしてもデータの交換が発生する。

メール添付やFTPはさすがにないだろうと。リビジョン管理システムを利用すれのがよかろうと。僕らがMercurial使っているからこれがよかろうと。

CatyのパッケージにMercurialも同梱してしまい（ライセンス上どうか？）、Catyのプロジェクトディレクトリを生成（初期化）するとき、hg initもしてしまうと。一部のCatyツール（OSのコマンド、「コマンド」と呼ぶと混乱する）がhgコマンドを呼んでリポジトリを維持するようにすればいいのではないか。

僕の経験では、みんなあんまりcommitしてくれないのだが、少なくとも顧客とデータを交換するタイミングではcommitする。顧客側がMercurialを使ってくれないなら、hg archiveしたファイルを送ればいいのではないか。diffでもいいし。いずれにしても、制作側はMercurial使ったほうがいい。

本番サーバーにもリポジトリを置いて、本番への配備・更新はリポジトリからupdateをするのがよいと思う。SSHでリモートコマンド実行ができると楽そうだな。このへんは有りモノが使える気がする。

*1264228772*[caty-depl]nginx for Windows

http://www.nginx.org/en/download.html を見ると、最近のリリースにはWindows版も付いている。例えば、http://www.nginx.org/download/nginx-0.7.64.zip 。

zipを展開するだけで簡単。だが、いわゆるWindowsインストーラーにはなってないし、GUIも付いてない。この点で嫌われてしまうかもしれない。だけど、これは僕好みのUIだなー。起動終了は非常に簡単。

- NGINX_HOME&gt;start nginx
- NGINX_HOME&gt;nginx -s stop

nginx -h でヘルプが出る。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\nginx\nginx-0.7.64&gt;nginx -h
nginx version: nginx/0.7.64
Usage: nginx [-?hvVt] [-s signal] [-c filename] [-p prefix] [-g directives]

Options:
  -?,-h         : this help
  -v            : show version and exit
  -V            : show version and configure options then exit
  -t            : test configuration and exit
  -s signal     : send signal to a master process: stop, quit, reopen, reload
  -p prefix     : set prefix path (default: NONE)
  -c filename   : set configuration file (default: conf/nginx.conf)
  -g directives : set global directives out of configuration file


C:\Installed\nginx\nginx-0.7.64&gt;
&lt;/pre&gt;

&amp;#45;c にいろいろ指定して実験すればいいわけだ。設定に関しては http://wiki.nginx.org/NginxConfiguration に記述がある。

*1264230116*[caty-depl]nginx for Windows 続報

やっぱり、Windowsってのはムリあるかもな。

&lt;pre&gt;
  -s signal     : send signal to a master process: stop, quit, reopen, reload
&lt;/pre&gt;

シグナルってどうやっているんだろう？ うまく動いてない感じだ。stopしてもプロセスが消えてくれない。ゾンビが溜る。タスクマネージャでも消せないようだし。プロセスのエミュレーションとかはCygwinを使っているのか？（&lt;b&gt;[追記]&lt;/b&gt;Cygwinとは無関係だった。&lt;b&gt;[/追記]&lt;/b&gt;）

仮に多少の問題があるにしても、非常に軽くて単純なWebサーバーがWindowsでCatyと一緒に使えればメッケものだ。

*1264232430*[caty-depl]nginxの設定例

http://xhtml.net/scripts/Django-CherryPy-server-DjangoCerise からの例。（しかし、すげードメイン名を取ったもんだ。）

&lt;pre class=&quot;code&quot;&gt;
http {
   include       /etc/nginx.mime.types;
   default_type  application/octet-stream;
   access_log  /var/log/nginx/access.log combined;
   sendfile        on;
   keepalive_timeout  65;
   tcp_nodelay        on;
   server {
       listen 80;
       server_name yourserver.com;
       access_log  /var/log/nginx/yourserver.com-access.log combined;
       error_log  /var/log/nginx/yourserver.com-error.log;
       location / {
           proxy_pass http://localhost:8088;
           proxy_set_header X-Forwarded-Host $server_name;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $remote_addr;
       }
   }
   server {
   	other... like to serve the media files
   }
}
&lt;/pre&gt;

http://www.rkblog.rk.edu.pl/w/p/pylons-and-nginx/ にも、リバースプロキシーの例がある。

http://wiki.nginx.org/NginxLikeApache も参考になる。SSLの例は http://wiki.nginx.org/NginxHttpSslModule 。

</body>
</day>
<day date="2010-01-26" title="">
<body>
*1264477076*[caty-depl]キャッシュのパージ

http://wiki.nginx.org/Nginx3rdPartyModules にサードパーティモジュールがある。このなかに、キャッシュをパージする http://labs.frickle.com/nginx_ngx_cache_purge/ なんてのがある。他にも使えるのがありそう。



</body>
</day>
<day date="2010-01-28" title="">
<body>
*1264641850*[caty-depl]さくらサーバーの状況

以前使っていた https://dev.commuworld.org:7999/ は、Apache+Tracで動いていたが、Apacheを止めたので、これはもう動かない。Subversionは動いているかも。Apacheの再起動には、SSL証明書（ナンチャッテ証明書）の再構成が必要；作業を中途でうっちゃってある。

http://microapplications.net/ とか http://microapplications.net:8007/* は動いている。これらはいくつかのYAWSプロセスが走り続けているから。こいつらも止めて、8000番台のポートも閉じることにする。

sudo lsof -i で現在動いてるプロセスを見ると、imap, pop3, smpt, ssh, ntp, ssl 関係以外は

&lt;pre class=&quot;out&quot;&gt;
COMMAND     PID     USER   FD   TYPE   DEVICE SIZE NODE NAME
beam       3407     yaws   12u  IPv4     8161       TCP localhost.localdomain:32802 (LISTEN)
beam       3407     yaws   13u  IPv4     8163       TCP *:webcache (LISTEN)
epmd       8500   oxxxxx    3u  IPv4   863167       TCP *:4369 (LISTEN)
epmd       8500   oxxxxx    4u  IPv4   863488       TCP localhost.localdomain:4369-&gt;localhost.localdomain:33202 (ESTABLISHED)
beam       8590     root    8u  IPv4   863485       TCP *:33201 (LISTEN)
beam       8590     root    9u  IPv4   863487       TCP localhost.localdomain:33202-&gt;localhost.localdomain:4369 (ESTABLISHED)
beam       8590     root   16u  IPv4   863491       TCP localhost.localdomain:33204 (LISTEN)
beam       8590     root   18u  IPv4   863497       TCP *:http (LISTEN)
beam      23174 k-yyyyyy   12u  IPv4 10760147       TCP localhost.localdomain:34339 (LISTEN)
beam      23174 k-yyyyyy   13u  IPv4 10760149       TCP *:8007 (LISTEN)
beam      32301   oxxxxx   12u  IPv4  8148126       TCP localhost.localdomain:34007 (LISTEN)
beam      32301   oxxxxx   13u  IPv4  8148128       TCP *:8004 (LISTEN)
&lt;/pre&gt;

EPMDとErlangの仮想機械だ。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ sudo ps -A | egrep '(PID|beam)'
  PID TTY          TIME CMD
 3407 ?        00:31:19 beam
 8590 ?        00:28:58 beam
23174 pts/1    00:19:41 beam
32301 ?        00:22:44 beam
[hiyama@microapplications ~]$ sudo ps -A | egrep '(PID|epmd)'
  PID TTY          TIME CMD
 8500 ?        00:00:01 epmd
[hiyama@microapplications ~]$
&lt;/pre&gt;

EPMDは問題ないが、4つあるYAWSをグレースフルに止めるスクリプトはどこだか？

&lt;hr&gt;
しょうがないのでkillした。

&lt;pre class=&quot;out&quot;&gt;
# ps -A | egrep '(PID|beam)'
  PID TTY          TIME CMD
 3407 ?        00:31:20 beam
 8590 ?        00:28:58 beam
23174 pts/1    00:19:41 beam
32301 ?        00:22:44 beam

# kill -s TERM 3407

# ps -A | egrep '(PID|beam)'
  PID TTY          TIME CMD
 8590 ?        00:28:58 beam
23174 pts/1    00:19:41 beam
32301 ?        00:22:44 beam

# kill -s TERM 8590

# ps -A | egrep '(PID|beam)'
  PID TTY          TIME CMD
23174 pts/1    00:19:41 beam
32301 ?        00:22:44 beam

# kill -s TERM 23174

# kill -s TERM 32301

# ps -A | egrep '(PID|beam)'
  PID TTY          TIME CMD

#
&lt;/pre&gt;

*1264645644*[caty-depl]nginxをインストール、と思ったら

次の手順でパッケージ化されたngixを準備してみた。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications DOWNLOAD]$ wget http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-3.noarch.rpm
&amp;#45;-10:59:00--  http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-3.noarch.rpm
           =&gt; `epel-release-5-3.noarch.rpm'
Resolving download.fedora.redhat.com... 209.132.183.67
Connecting to download.fedora.redhat.com|209.132.183.67|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 11,989 (12K) [application/x-rpm]

100%[=================================================================================&gt;] 11,989        47.54K/s

10:59:01 (47.53 KB/s) - `epel-release-5-3.noarch.rpm' saved [11989/11989]

[hiyama@microapplications DOWNLOAD]$ sudo rpm -Uvh epel-release-5-3.noarch.rpm
hiyama@microapplications Password:
warning: epel-release-5-3.noarch.rpm: V3 DSA signature: NOKEY, key ID 217521f6
Preparing...                ########################################### [100%]
   1:epel-release           ########################################### [100%]
[hiyama@microapplications DOWNLOAD]$ rpm -qi epel-release
Name        : epel-release                 Relocations: (not relocatable)
Version     : 5                                 Vendor: Fedora Project &lt;http://bugzilla.redhat.com/bugzilla&gt;
Release     : 3                             Build Date: Sat Apr 26 03:16:23 2008
Install Date: Thu Jan 28 10:59:35 2010      Build Host: ppc2.fedora.redhat.com
Group       : System Environment/Base       Source RPM: epel-release-5-3.src.rpm
Size        : 22091                            License: GPL
Signature   : DSA/SHA1, Sat Apr 26 09:03:47 2008, Key ID 119cc036217521f6
Packager    : Fedora Project &lt;http://bugzilla.redhat.com/bugzilla&gt;
URL         : http://download.fedoraproject.org/pub/epel
Summary     : Extra Packages for Enterprise Linux repository configuration
Description :
This package contains the Extra Packages for Enterprise Linux (EPEL) repository
GPG key as well as configuration for yum.
[hiyama@microapplications DOWNLOAD]$ rpm -ql epel-release
/etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL
/etc/yum.repos.d/epel-testing.repo
/etc/yum.repos.d/epel.repo
/usr/share/doc/epel-release-5
/usr/share/doc/epel-release-5/GPL
[hiyama@microapplications DOWNLOAD]$ cd /var
..
.. ゴチャゴチャ、雑用
..
[hiyama@microapplications var]$ sudo yum list
hiyama@microapplications Password:
Setting up repositories
epel                      100% |=========================| 3.4 kB    00:00
kbs-CentOS-Extras         100% |=========================|  951 B    00:00
kbs-CentOS-Misc           100% |=========================|  951 B    00:00
update                    100% |=========================|  951 B    00:00
base                      100% |=========================| 1.1 kB    00:00
sakura                    100% |=========================|  951 B    00:00
contrib                   100% |=========================|  951 B    00:00
centosplus                100% |=========================|  951 B    00:00
addons                    100% |=========================|  951 B    00:00
extras                    100% |=========================| 1.1 kB    00:00
Reading repository metadata in from local files
a78199c898af49c31a1717393 100% |=========================| 1.3 MB    00:00
epel      : ################################################## 4001/4001
primary.xml.gz            100% |=========================| 172 kB    00:00
sqlite cache needs updating, reading in metadata
update    : ################################################## 538/538
primary.xml.gz            100% |=========================| 611 kB    00:00
sqlite cache needs updating, reading in metadata
base      : ################################################## 1599/1599
primary.xml.gz            100% |=========================| 4.8 kB    00:00
sqlite cache needs updating, reading in metadata
sakura    : ################################################## 14/14
primary.xml.gz            100% |=========================|  92 kB    00:00
sqlite cache needs updating, reading in metadata
centosplus: ################################################## 283/283
primary.xml.gz            100% |=========================|  36 kB    00:00
sqlite cache needs updating, reading in metadata
extras    : ################################################## 141/141
Installed Packages
4Suite.i386                              1.0-3                  installed
Canna-libs.i386                          3.7p3-7.EL4            installed
FreeWnn-libs.i386                        1:1.10pl020-6.el4      installed
GConf2.i386                              2.8.1-2.el4            installed
MAKEDEV.i386                             3.15.2-3               installed
..
..
..
..
zziplib.i386                             0.13.49-1.el5.1        epel
zziplib-devel.i386                       0.13.49-1.el5.1        epel
zziplib-utils.i386                       0.13.49-1.el5.1        epel
[hiyama@microapplications var]$ yum list | grep nginx
collectd-nginx.i386                      4.5.3-2.el5.1          epel
nginx.i386                               0.6.39-2.el5           epel
[hiyama@microapplications var]$ yum search nginx
Searching Packages:
Setting up repositories
Reading repository metadata in from local files


nginx.i386                               0.6.39-2.el5           epel
Matched from:
nginx
Nginx [engine x] is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3
proxy server written by Igor Sysoev.

One third party module, nginx-upstream-fair, has been added.
http://nginx.net/


collectd-nginx.i386                      4.5.3-2.el5.1          epel
Matched from:
collectd-nginx
Nginx plugin for collectd
This plugin gets data provided by nginx.
[hiyama@microapplications var]$
&lt;/pre&gt;

バージョンが 0.6.39 か、これは古いなー。0.7が欲しい。

*1264648564*[caty-depl]nginxを手動でインストール

$ wget http://sysoev.ru/nginx/nginx-0.7.64.tar.gz して $ tar zxvf nginx-0.7.64.tar.gz する。

ビルド／インストールに関しては、http://wiki.nginx.org/NginxInstall と、 http://wiki.nginx.org/NginxInstallOptions を読めばいい。SSIとFastCGIは要らないので、次のcofigureオプションにする。sslとssiを絶対に間違えないように！！

&lt;pre&gt;
./configure \
 --with-http_ssl_module --with-debug \
 --without-http_ssi_module  --without-http_fastcgi_module
&lt;/pre&gt;

ビルド。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications nginx-0.7.64]$ ./configure \
&gt;  --with-http_ssl_module --with-debug \
&gt;  --without-http_ssi_module  --without-http_fastcgi_module
checking for OS
 + Linux 2.6.9-78.0.5.plus.c4 i686
...
...

Configuration summary
  + using system PCRE library
  + using system OpenSSL library
  + md5: using OpenSSL library
  + sha1 library is not used
  + using system zlib library

  nginx path prefix: &quot;/usr/local/nginx&quot;
  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;
  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;
  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;
  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;
  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;
  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;
  nginx http client request body temporary files: &quot;client_body_temp&quot;
  nginx http proxy temporary files: &quot;proxy_temp&quot;
  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;

[hiyama@microapplications nginx-0.7.64]$
&lt;/pre&gt;

あとは、make; sudo make install 。

インストール直後のシンプルさは感激もの。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications nginx]$ ls -Rl
.:
total 16
drwxr-xr-x  2 root root 4096 Jan 28 12:07 conf
drwxr-xr-x  2 root root 4096 Jan 28 12:07 html
drwxr-xr-x  2 root root 4096 Jan 28 12:07 logs
drwxr-xr-x  2 root root 4096 Jan 28 12:07 sbin

./conf:
total 36
&amp;#45;rw-r--r--  1 root root  909 Jan 28 12:07 fastcgi_params
&amp;#45;rw-r--r--  1 root root  909 Jan 28 12:07 fastcgi_params.default
&amp;#45;rw-r--r--  1 root root 2837 Jan 28 12:07 koi-utf
&amp;#45;rw-r--r--  1 root root 2223 Jan 28 12:07 koi-win
&amp;#45;rw-r--r--  1 root root 3128 Jan 28 12:07 mime.types
&amp;#45;rw-r--r--  1 root root 3128 Jan 28 12:07 mime.types.default
&amp;#45;rw-r--r--  1 root root 2726 Jan 28 12:07 nginx.conf
&amp;#45;rw-r--r--  1 root root 2726 Jan 28 12:07 nginx.conf.default
&amp;#45;rw-r--r--  1 root root 3610 Jan 28 12:07 win-utf

./html:
total 8
&amp;#45;rw-r--r--  1 root root 383 Jan 28 12:07 50x.html
&amp;#45;rw-r--r--  1 root root 151 Jan 28 12:07 index.html

./logs:
total 0

./sbin:
total 3228
&amp;#45;rwxr-xr-x  1 root root 3297507 Jan 28 12:07 nginx
[hiyama@microapplications nginx]$
&lt;/pre&gt;


</body>
</day>
<day date="2010-01-29" title="">
<body>
*1264725312*[caty-depl]テンプレートの使いどころ

nginx.confを書くのにテンプレート使いたいなー。

&gt;||
&lt;%* 静的サイト達 *%&gt;
&lt;%foreach from=sites item=site %&gt;
    #
    # &lt;%$site%&gt;
    #
    server {
        listen       80;
        server_name  &lt;%$site%&gt;
        access_log  logs/&lt;%$site%&gt;.access.log  main;

        location / {
            root   &lt;%$sites_top%&gt;/&lt;%$site%&gt;;
            index  index.html index.htm;
        }

        error_page  404              /404.html;
        error_page   500 502 503 504  /50x.html;
    }
&lt;%/foreach%&gt;
||&lt;

デリミタが'{'と'}'はさすがにダメだから、'&amp;#60;%'と'%&gt;' とかだろう。

*1264735884*[caty-depl]vsftpdの設定はどうかしている

/etc/vsftpd.user_list の冒頭
&lt;pre&gt;
# vsftpd userlist
# If userlist_deny=NO, only allow users in this file
# If userlist_deny=YES (default), never allow users in this file, and
# do not even prompt for a password.
# Note that the default vsftpd pam config also checks /etc/vsftpd.ftpusers
# for users that are denied.
&lt;/pre&gt;

/etc/vsftpd/vsftpd.conf には次のように書くわけ：
&lt;pre&gt;
userlist_enable=YES
userlist_deny=NO
&lt;/pre&gt;

こりゃ、どう考えてもオカシイだろう。間違うだろうよ、これは。何考えているんだ？

</body>
<comments>
<comment>
<username>ardbeg1958</username>
<body>最近 vsftpd.conf を編集するはめになりましたが、この仕様は（歴史的経緯があるとしても）許しがたいものだと思いました。&lt;br&gt;それに加えて /etc/vsftpd.ftpusers for users that are denied. とは一体どういう料簡なのかと、問い詰めたい気分です（笑）</body>
<timestamp>1265240602</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>ardbeg1958さん、&lt;br&gt;放置すべき仕様じゃないですよね。&lt;br&gt;vs って、very secure でしょ、人間のミスに対する耐性もないとsecureじゃないと思うけど。&lt;br&gt;ほんとに、どういう料簡だか。</body>
<timestamp>1265241407</timestamp>
</comment>
</comments>
</day>
<day date="2010-02-01" title="">
<body>
*1264982756*[caty-depl]Dotster側でもネームサーバー変更手続きが必要だった

caty-sites.net がなんで見えないのかな？ と思っていたら、さくらインターネットの手続きだけじゃなくて、Dotsterの手続きも必要だった。ドメイン自体は移管されずに、Dotster管理下なので、さくらだけではダメなんだが、このへんの制度とか手続きって、なんだかワカラン。一元的にできないのかな？ あー、メンドクサ。

後々のために手順を書いておく。

+ まず、さくらにドメイン名を通知して、ドメイン追加依頼。
+ メールで返事がくる。
+ Webのメニュー（UIが極悪）からドメインがセットされているか確認。
+ 実は今回はさくらが間違っていたので、再度メール。
+ やり直して、やっとドメインの操作ができるようになった。
+ ドメイン追加依頼からメニューに表示されるまでに、なにが行われているか僕には不明。
+ ゾーンデータを入力。
+ これで終りかと思った。が、ダメだった。
+ Dotsterにログインして、ネームサーバーの追加変更みたいなメニューをたどる。
+ そこでさくらが使っているネームサーバー名を入力。
+ ゾーン設定の時は、最後のピリオドが付くのでコッチも付けてみたら、それはダメだった。
+ ピリオド無しで再入力、やっとできた。

&lt;pre&gt;	
Name Server Update Results

Update completed with the following results:
CATY-SITES.NET:Name Servers Successfully Updated
DAPHNIA.ORG:Name Servers Successfully Updated


If you have problems completing your update and need to contact customer service, please report the following code with your request
Code: 5t6Az2izvBV6GXXBhbd4jCDf
&lt;/pre&gt;

僕（檜山）がcaty-sites.netの持ち主だってことはどうやって確認しているんだろう？ さくらとDotsterの個人情報を比較しているのか？ あー気持ち悪い。

*1264982931*[caty-depl]現在使えるドメイン名／ホスト名

+ microapplications.net
+ www.microapplications.net
+ mail.microapplications.net
+ ftp.microapplications.net
+ juncture.microapplications.net
+ admin.microapplications.net

+ commuworld.org
+ www.commuworld.org
+ dev.commuworld.org
+ chimaira.commuworld.org

+ caty-sites.net
+ www.caty-sites.net
+ mail.caty-sites.net
+ ftp.caty-sites.net
+ caty.caty-sites.net
+ secure.caty-sites.net

+ daphnia.org
+ www.daphnia.org
+ ftp.daphnia.org
+ mail.daphnia.org
+ secure.daphnia.org
+ chimaira.daphnia.org


</body>
</day>
<day date="2010-02-02" title="">
<body>
*1265070159*[caty-depl]iptablesにムカつく私

コマンドラインは好きだけど、わけわからんコマンド・インターフェースは嫌いだ。iptablesは相当にひどい水準。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications ~]$ sudo iptables  -L INPUT --line-numbers -n
Chain INPUT (policy DROP)
num  target     prot opt source               destination
1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED
2    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0
3    ACCEPT     icmp --  192.168.10.100       0.0.0.0/0
4    ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           udp spts:1024:25534 dpt:53
5    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp spts:1024:65534 dpt:53
6    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22 state NEW
... (省略)
&lt;/pre&gt;

1番と2番に注目すると；

+ state が RELATED,ESTABLISHED ならば ACCEPT
+ なんでもかんでも ACCEPT

と解釈できる。チェーン内では、ルールは番号順に実行（検査）されるから、2番ですべてのパケットが受理されてしまう。と、この表示をみる書限りそう思える。

が、実際は違う。-v （--verbose）オプションを付ければ分かることは分かるんだが：

- 2番のルールはローカル・ループバック・インターフェース（lo）入力にだけ適用される。

in/out条件はものすごく重要な情報なのに、デフォルトでは表示しない。in/outネットワークインターフェイスごとのルール表示も（僕が探した限り）できないようだ。ルールがどのインターフェース（両端）に適用されるかを無視してフラットに表示するって、混乱するだろうよ。

ルール番号はチェーンごとにシーケンシャルだが、異なるインターフェースに対するルールを混ぜて連番を付ける。実装がそうなっているからって、UIにそのまま露出させるこたーない。なんか表示に工夫があってもいい。つうか、表示コマンドは別（iptables-showとか）にして、検索や表示形式指定をねんごろにサポートスべきじゃないのか。

それと、範囲指定に':'と'-'が混じっているのにもスゲー腹がたった。':'は addr:port という使い方もされている。いくらなんでもヒドすぎないか、同じコマンド内なのに。

次に、テーブルとチェーンという概念についてだが； テーブルは、概念的にはパケット操作の種類に対応する。これは悪くはない。チェーンは、パケットが通過する経路の空間的構造を形成するから分かりやすい。が、テーブルとチェーンとの関連がわかりにくい。いっそ、テーブルという概念をなくすことも一案かもしれない（ネーミングがiptablesなのにテーブルがない、つうのもナンだが）。

テーブルの種類を、チェーンにかかる修飾語として使うのはどうだろう。filterチェーン、natチェーンのように。種類（filter, nat, mangle）が違えばチェーンに同じ名前を付けてもいい。つまり、種類＝テーブル名がチェーン名の名前空間となっている。INPUT filteチェーンとかFORWARD natチェーンと呼ぶ； 逆順で、filter INPUTチェーン、nat FORWARDチェーンがいいかな？ filter:INPUT とか filter/INPUT とか表現してもいいかも。

いずれにしても、チェーンが中核概念であり、チェーンを繋いで、入り口から出口にむかう経路を作る。経路の上にはルール群が配置される。いきなりルール群から長い経路全体を作るのは大変だから、チェーンというモジュール単位で繋ぐ。チェーンは、ルール群の構造化の単位。プログラムが関数や手続きで構成されるのと同じ。

- 処理のアトム（構成素、単位）はルール
- 制御構造が順序（シーケンス）とターゲット（アクション）
- 手続きに対応するのがチェーン
- テーブルは用途ごとの名前空間
- 実行時には、チェーンが連接されて経路が作られる。
- 個々のパケットは、経路上のルールで操作されルーティングされる。

なんつーか、概念レベルのモデルをすっ飛ばして実装を露出させる、それをまた個別ケースごとに経験論と現象論で対処している、ってその感じが、僕の神経をいたく逆なでする。こういうところは、[UL]*x の悪い文化だ。

</body>
</day>
<day date="2010-02-03" title="">
<body>
*1265179736*[caty-depl][雑感]設定ファイル構文の地獄

僕がサーバー管理とかシステム管理が苦手で嫌いなのは、次の理由からだろう。

+ モノグサ、極端にめんどくさがり屋。
+ 記憶力が非常に弱い。
+ 注意力もかなり欠けている。

なかでも、「概念的にはほぼ同じ対象に、似てるけど少しずつ違う構文」という状況がものすごくイヤ！ キライでキライでしょうがない。腹立たしくなってストレスがたまるのだ。

Wiki構文が典型例で、いつも僕を苛立たせる。システム管理で扱うべき設定ファイルというヤツも似た状況で、似てるが微妙に異なる構文が大量に出てくる。当然ながらイヤになる。記憶力があるならさして苦にならないのだろうが、記号や数値を3つ以上憶えるのが不可能な僕には辛いよ。

構文の微妙な差が出る所は：

+ 名前の構文
+ 文字列リテラルの構文
+ エスケープの方式
+ 空白入りのパスや名前をどう書くか
+ 名前・値の区切りが、=, :, 空白、その他のどれか
+ ; か改行か
+ コメント構文
+ ブロック／セクションをどう表現するか

ほとんどが、空白、改行、記号類をどう使うか、ってことで本質的な差がない。

</body>
</day>
<day date="2010-02-05" title="">
<body>
*1265356917*[caty-depl]iptablesのメモ

man見りゃ書いてあるが、自分の手でまとめておこう。

&lt;h5&gt;テーブルに対するオペレーション&lt;/h5&gt;

+ -A append チェーン名 ルール
+ -D delete チェーン名 番号
+ -D delete チェーン名 ルール（マッチ条件として）
+ -I insert チェーン名 番号 ルール （番号省略時は1）
+ -R replace チェーン名 番号 ルール
+ -N new-chain チェーン名
+ -X delete-chain チェーン名（チェーン名を省略すると全てのユーザー定義チェーン）
+ -E rename-chain 旧名 新名

&lt;h5&gt;ルール記述／ルールマッチ条件（パターン）&lt;/h5&gt;

+ -p protocol (tcp|udp|icmp|all)
+ -s source, src addr[/mask]
+ -d destination, dst addr[/mask]
+ -i in-interface 名前
+ -o out-interface 名前

&lt;h5&gt;tcpモジュール&lt;/h5&gt;

&amp;#45;p tcp で自動的にロードされる。

+ --source-port sport 元ポート
+ --desctination-port dport 宛先ポート
+ --tcp-flags フラグは SYN ACK FIN RST URG PSH ALL NONE。指定はmanを見て。

&lt;h5&gt;stateモジュール&lt;/h5&gt;

+ --state カンマ区切りで、カンマはORの意味。指定できる定数は ESTABLISHE, RELATED, NEW。

&lt;h5&gt;その他&lt;/h5&gt;

LOGのオプションがあるな。

*1265362835*[Caty]パス構文と複数アプリケーション

とりあえずメモをここに書いておこう。

|* ＼           |* ファイルシステム |* コマンドシステム |
| 区切り文字    | '/'               | '.' |
| 中間ノード    | ディレクトリ      | パッケージ |
| 末端ノード    | ファイル          | モジュール |
| フラグメント文字| '#'             | ':' |
|フラグメント   | 章や節            | コマンド |

これは、記号が違うだけで対応してるといってよい。ただし、無名のファイルはないが、無名のモジュールを1つ認めている。仮に無名のファイルがあるとしたら、それはどう書くべきか？/a/#foo ディレクトリと区別できない。ディレクトリごとに1個ずつは無名ファイルがあってもよいのか？ いや、それだとディレクトリと同一視してもいいような気がする。

foo.bar:hello は、foo/bar#hello に対応する。なら、/foo/bar#hello は、.foo.bar:hello か。それでもいいか。

ファイルシステムにはボリューム概念を入れられる。で、複数のボリュームが1つのアプリケーションにぶら下がる。コマンドにはボリューム概念はないし、今後入れることはないだろう。が、アプリケーション概念はある。

異なるアプリケーション間の参照は、一種のリモーティングになるのだろうか？

</body>
</day>
<day date="2010-02-08" title="">
<body>
*1265588391*[リンク]ザリスキー幾何学

書名で検索できるから、ほんとのリンクじゃないけど：

- Zariski Geometries: Geometry from the Logician's Point of View (London Mathematical Society Lecture Note Series) 
- Boris Zilber 
- ￥6,255

ジルバーって、この方面で有名な人（大家）だと思った。


*1265588392*[caty-depl]vsftpd, iptables

これだとパッシブで繋がらないようだ。

&lt;pre class=&quot;out&quot;&gt;
# grep '^[^#]' /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_file=/var/log/vsftpd.log
xferlog_std_format=NO
ascii_upload_enable=YES
ascii_download_enable=YES
pam_service_name=vsftpd
userlist_enable=YES
userlist_deny=NO
listen=YES
tcp_wrappers=YES
use_localtime=YES
&lt;/pre&gt;

あと、iptables の -I chain-name number の意味は insert-before で、新しいルールが指定された番号になる。



</body>
</day>
<day date="2010-02-09" title="">
<body>
*1265701219*[caty-depl][雑感]「すぐさまメモ」をおこたると

設定関係の調査結果や作業メモって、1文字間違えてもエラいこと（Copy/Pasteして実行したら洒落にならないときもある）。

だから、正確にすぐさまメモしないといけない（log_sessionとか仕掛けてはあるんだが）。だけど、メモし忘れて、いま困っている。

*1265701833*[リンク]無限遷移系の正規性かぁー

アマゾンのレコメンドはいい線いってるなー。

- Automata for Branching and Layered Temporal Structures: An Investigation into Regularities of Infinite Transition Systems (Lecture Notes in Computer Science / Lecture Notes in Artificial Intelligence) 
- Gabriele Puppis 


</body>
</day>
<day date="2010-02-10" title="">
<body>
*1265766519*[後で消す]忘れそうだ、今日中

+ インストール
+ 校正添削
+ 支払い
+ 買い物（渋谷）
+ 送別会（新宿） 19：30～ http://www.hotpepper.jp/strJ000001724/map/#mapTop
+ 解約手続き
+ いや、その前に解約手続きの仕方を調べる http://www.linkclub.jp/ 
+ サーバー設定
+ ハードウェア貸出申し込み or 購買
+ 連絡 Kk


*1265757939*[caty-depl]サーバー管理、なんやかんやメモ

こっち方面シロートのメモ。
&lt;hr&gt;
僕が見ているサーバーはCentOSだから、rpm, yumでパッケージ管理だが、dpkg, apt, aptitude系列もあるらしい。RedHat, Debianの系譜ってことらしい。

yumでは、http://wiki.livedoor.jp/nadai14/d/yum%A4%CEMissing%20Dependency%A5%A8%A5%E9%A1%BC%A4%C8rpm%A4%CE%A5%C0%A5%A6%A5%F3%A5%B0%A5%EC%A1%BC%A5%C9 に書いてある現象は僕も経験。なんかショウモナイナーという印象。自動化できない作業があるのはわかるけど、、、

&lt;hr&gt;
monit（モニット？ モンイット？）で監視するといいらしい。

&lt;hr&gt;
vsftpdの設定項目は、http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/ja/ref-guide/s1-ftp-vsftpd-conf.html にある。

&lt;hr&gt;
tcpdumpはダンプしすぎだー。

*1265769680*[caty-depl]FTPメモ

[http://d.hatena.ne.jp/m-hiyama-memo/20100209/1265701219:title]に書いた自戒に従い、忘れる前に記録を残す。

FTPの設定なんて簡単そうでしょ。だが、僕のように慣れてないと色々と困難がある。

+ まず、portモード（アクティブモード）とpasvモード（パッシブモード）があるのさえ知らんかった。
+ portモードだとファイアーウォール内のクライアントからうまく接続できない。
+ で、最近のクライアントはたいていpasv対応。なるほど。
+ vsftpdもデフォルトでpasv対応（pasv_enable ― 有効な場合、パッシブモードの接続を 許可します。デフォルトの値は YESです。 ）
+ &lt;em&gt;ところがだ&lt;/em&gt;、pasv_max_port と pasv_min_port の設定が必要。
+ とりあえず根拠もなく pasv_min_port=23000 /改行/pasv_max_port=24000
+ これにあわせてiptablesで穴を開けておかないとパケットが通れないし。

はまるポイントは：

+ 設定ファイルを書き換えて、service vsftpd restart を忘れる。
+ 間違った／不適切な設定でもデーモンが黙って上がる。

あたり。

実は、pasv_max_port=23000 /改行/pasv_max_port=24000 と書いていたが、誰も文句を言わない。FTPハマリで一番大きかったのはここかな。

試行錯誤中に余計なポートを開けすぎた気がする。pasvのFTPって、21/tcp しかいらないようだ。20/tcp, 21/udp, 20/udp は不要だろう。ランダムポートも千個も要らんわ。

今回ははまらなかったけど、設定ファイルの空白とかもヤバイ； 

&gt;&gt;
ディレクティブ内では&amp;lt;directive&gt; とイコールマーク と&amp;lt;value&gt; の間にスペースがあってはいけません。 
&lt;&lt;

カーッ、バカバカしい。

*1265775573*[caty-depl]tcpdumpメモ

tcpdumpの説明では、http://www.wakhok.ac.jp/~kanayama/summer/02/site/node201.html がわかりやすかった。

表示のフィールド：

+ タイムスタンプ　
+ 送信ホスト名(IP アドレス).ポート番号
+ '&gt;'
+ 受信ホスト名.ポート番号:
+ フラグ
+ シーケンス番号
+ 'ack' ack番号 
+ win ウィンドウサイズ 
+ urgent フラグオプション 

'-q' オプション指定時：

+ タイムスタンプ　
+ 送信ホスト名(IP アドレス).ポート番号 
+ '&gt;'
+ 受信ホスト名.ポート番号: 
+ プロトコル
+ バイト数 

プリミティブ と呼ばれる要素式。http://www.wakhok.ac.jp/~kanayama/summer/02/site/node201.html から引き写し。

- dst host ホスト名&lt;br&gt; 指定した送信先のホスト宛のパケット 
- src host ホスト名&lt;br&gt; 指定した発信元のホストからのパケット 
- host ホスト名&lt;br&gt; 指定したホスト宛／からのパケット ； host の前にキーワード ip, arp, rarp をつけることが できる。
- gateway ホスト名&lt;br&gt;  ホストを gateway として使用するパケット ； したがって、ホスト名で指定したルーターを通るパケットに対して真。
- dst net ネットワーク・アドレス&lt;br&gt; 指定ネットワーク宛のパケット ； ネットワーク・アドレスは、例えば 202.11.100.1 のホストならば、 202.11.100 がネットワーク・アドレスとなる。
- src net ネットワーク・アドレス&lt;br&gt; 指定ネットワークからのパケット 
- net ネットワーク・アドレス&lt;br&gt; 指定ネットワーク宛／からのパケット 
- dst port ポート番号&lt;br&gt; TCP/UDP の指定したポート番号宛のパケット 
- src port ポート番号&lt;br&gt; TCP/UDP の指定したポート番号からのパケット 
- port ポート番号&lt;br&gt; TCP/UDP の指定したポート番号宛／からのパケット 
- ether broadcast&lt;br&gt; イーサネット・ブロードキャスト ； ether は省略可。
- ip broadcast&lt;br&gt; IP ブロードキャスト ； all 1 および　all 0 もチェックする。サブネットマスクも考慮してくれる。

要するに、原子論理式を構成する基本述語がプリミティブ。tcp などは単独で述語として使える；proto = tcp の意味。

プリミティブ（述語）への値の例：

| IPアドレス／ホスト |	192.168.1.1, 名前もOK |
|ネットワークアドレス | 192.168.1.0/24, 192.168.1.0/255.255.255.0, 名前もOK|
|ポート番号 | 23, 54, 80, 110, 名前もOK |
|プロトコル | tcp, udp, icmp |

論理結合子は：

- ! または not
- &amp;#38;&amp;#38; または and
- || または or
- '('と')'

オプションは（http://home.k05.itscom.net/aperuto/tcpdump.htmlから）

|* オプション |* 説明   |
| -F (file)    | 条件式を file から読み込む。|
| -i (name)   | モニタリングするインタフェースを指定。-i ed0 や -i ppp -i loなど。|
| -n          | アドレスを名前に変換しない。これは IP アドレスだけでなく、ポート番号なども数字のまま出力する。|
| -w (file)   | ネットワークに流れるパケットをそのままファイルに保存する。 |
| -r (file)   | これは前もって -w オプションなどで作成したファイルからパケットを読み込む。|
| -s (size)   | パケットから取り出すデータの長さ。-s 1600 なら1600バイト |
| -x          | パケットの中身を 16 進数で表示する。|
| -X          | パケットの中身を ASCII で表示する。これは大抵 16 進数も同時に表示する。 |


</body>
</day>
<day date="2010-02-12" title="">
<body>
*1265934929*[caty-depl]シグナル

kill -l でシグナルのリストが出る。

|* 番号 |* 名前 |* 意味 |
| 1     | SIGHUP| 再起動、リセット |
| 2     | SIGINT | 割り込み |
| 3     | SIGQUIT | 終了＋コアダンプ |
| 9     | SIGKILL |  強制終了 |
| 15    | SIGTERM | 終了（デフォルト）|
| 19    | SIGSTOP | 中断 |

nohup で起動すると、SIGHUP（ハングアップ）とSIGQUIT（中止、中断）を受け付けなくなる。SIGTERMならOK。

*1265935055*[caty-depl]個人環境へのMercurialインストールまで

状況の確認：
&lt;pre class=&quot;out&quot;&gt;
$ python -V
Python 2.3.4

$ which python
/usr/bin/python

$ /usr/local/python/bin/python -V
Python 2.6.4

$
&lt;/pre&gt;

virtual-pythonのインストール：
&lt;pre class=&quot;out&quot;&gt;
$ wget http://peak.telecommunity.com/dist/virtual-python.py

$ ls *.py
virtual-python.py

$ /usr/local/python/bin/python ./virtual-python.py \
  --prefix=/home/caty/python2.6.4 \
  --no-site-package
Creating /home/caty/python2.6.4/lib/python2.6
Creating /home/caty/python2.6.4/lib/python2.6/site-packages
Creating /home/caty/python2.6.4/include/python2.6
Creating /home/caty/python2.6.4/bin
Copying /usr/local/python/bin/python to /home/caty/python2.6.4/bin
You're now ready to download ez_setup.py, and run
/home/caty/python2.6.4/bin/python ez_setup.py

$ 
&lt;/pre&gt;

ez_setupの実行＝setuptoolsのインストール：
&lt;pre class=&quot;out&quot;&gt;
$ wget http://peak.telecommunity.com/dist/ez_setup.py

$ ls *.py
ez_setup.py  virtual-python.py

$ ~/python2.6.4/bin/python ./ez_setup.py
Downloading http://pypi.python.org/packages/2.6/s/setuptools/setuptools-0.6c11-py2.6.egg
Processing setuptools-0.6c11-py2.6.egg
Copying setuptools-0.6c11-py2.6.egg to /home/caty/python2.6.4/lib/python2.6/site-packages
Adding setuptools 0.6c11 to easy-install.pth file
Installing easy_install script to /home/caty/python2.6.4/bin
Installing easy_install-2.6 script to /home/caty/python2.6.4/bin

Installed /home/caty/python2.6.4/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg
Processing dependencies for setuptools==0.6c11
Finished processing dependencies for setuptools==0.6c11

$
&lt;/pre&gt;

.bash_profileの編集：
&lt;pre class=&quot;code&quot;&gt;
# .bash_profile

PATH=$HOME/python2.6.4/bin:$HOME/bin:$PATH
&lt;/pre&gt;

確認：
&lt;pre class=&quot;out&quot;&gt;
$ which python
~/python2.6.4/bin/python

$ which easy_install
~/python2.6.4/bin/easy_install

$
&lt;/pre&gt;

Mercurialのインストール：
&lt;pre class=&quot;out&quot;&gt;
$ easy_install mercurial
Searching for mercurial
Reading http://pypi.python.org/simple/mercurial/
Reading http://www.selenic.com/mercurial
Best match: mercurial 1.4.3
Downloading http://mercurial.selenic.com/release/mercurial-1.4.3.tar.gz
Processing mercurial-1.4.3.tar.gz
Running mercurial-1.4.3/setup.py -q bdist_egg --dist-dir /tmp/easy_install-3T2s_G/mercurial-1.4.3/egg-dist-tmp-iQgrM2
zip_safe flag not set; analyzing archive contents...
mercurial.lsprof: module references __file__
mercurial.templater: module references __file__
mercurial.help: module references __file__
mercurial.extensions: module references __file__
mercurial.i18n: module references __file__
Adding mercurial 1.4.3 to easy-install.pth file
Installing hg script to /home/caty/python2.6.4/bin

Installed /home/caty/python2.6.4/lib/python2.6/site-packages/mercurial-1.4.3-py2.6-linux-i686.egg
Processing dependencies for mercurial
Finished processing dependencies for mercurial

$ which hg
~/python2.6.4/bin/hg

$ hg help
Mercurial Distributed SCM

list of commands:

 add          add the specified files on the next commit
 ...[snip]
 extensions   Using additional features

use &quot;hg -v help&quot; to show aliases and global options

$
&lt;/pre&gt;

Mercurialのrcファイル：
&lt;pre class=&quot;out&quot;&gt;
$ cat ./.hgrc
[ui]
username=Caty

$
&lt;/pre&gt;

*1265939469*[caty-depl]ネームサーバー変更手順

[http://d.hatena.ne.jp/m-hiyama-memo/20100201/1264982756:title]に書いた件だが、さくらもDotsterもWeｂインターフェースが最低だから、書いておかないと毎回迷う。

さくら：

- 契約情報 → ドメインメニュー →ゾーン設定； ネームサーバーは「ns1.dns.ne.jp.」と「ns2.dns.ne.jp.」

Dotster：

- STEP 1. CHOOSE ONE OR MORE DOMAINS BY CHECKING THE BOXES ここで対象とするドメインにチェックを入れる。
- STEP 2. SELECT WHICH MANAGEMENT OPTION YOU WANT TO PERFORM THEN CLICK &quot;GO&quot; ドロップダウンメニューから Modify Nameservers を選んで、GO。

報告メール：
&lt;pre&gt;
Output from your name server update request:
CATY-SITES.NET:Name Servers Successfully Updated



Nameserver updates can take up to 72 hours to become active.

Thank You!
&lt;/pre&gt;

*1265940368*[caty-depl]SQLite3が使えない、Python作り直し

[http://d.hatena.ne.jp/m-hiyama-memo/20100122/1264128518:title]の方法でビルドすると、SQLite3が使えない。

&lt;pre class=&quot;out&quot;&gt;
$ python
Python 2.6.4 (r264:75706, Jan 21 2010, 23:22:41)
[GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sqlite3
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/usr/local/python/lib/python2.6/sqlite3/__init__.py&quot;, line 24, in &lt;module&gt;
    from dbapi2 import *
  File &quot;/usr/local/python/lib/python2.6/sqlite3/dbapi2.py&quot;, line 27, in &lt;module&gt;
    from _sqlite3 import *
ImportError: No module named _sqlite3
&gt;&gt;&gt;
&lt;/pre&gt;

こうなる。DLL（so）モジュール _sqlite3 がないと言っている。Pythonをmakeするとき、事前にSQLite3がインストールされてないと組み込まないようだ。作り直しの必要がある。

まずSQLite3を持ってくる。
&lt;pre class=&quot;out&quot;&gt;
$ wget http://www.sqlite.org/sqlite-amalgamation-3.6.22.tar.gz

$ tar zxvf sqlite-amalgamation-3.6.22.tar.gz

$ cd sqlite-3.6.22/

$ ls
INSTALL      README        config.sub    depcomp     missing    sqlite3.c   sqlite3.pc.in
Makefile.am  aclocal.m4    configure     install-sh  shell.c    sqlite3.h   sqlite3ext.h
Makefile.in  config.guess  configure.ac  ltmain.sh   sqlite3.1  sqlite3.pc

$
&lt;/pre&gt;

configureの--prefixにPythonと同じインストールプレフィックスを指定する。

&lt;pre class=&quot;out&quot;&gt;
# ./configure --prefix=/usr/local/python
... 省略 ...

# make
... 省略 ...

# make install
make[1]: Entering directory `/home/caty/DOWNLOAD/sqlite-3.6.22'
test -z &quot;/usr/local/python/lib&quot; || mkdir -p -- &quot;/usr/local/python/lib&quot;
 /bin/sh ./libtool --mode=install /usr/bin/install -c  'libsqlite3.la' '/usr/local/python/lib/libsqlite3.la'
/usr/bin/install -c .libs/libsqlite3.so.0.8.6 /usr/local/python/lib/libsqlite3.so.0.8.6
(cd /usr/local/python/lib &amp;&amp; { ln -s -f libsqlite3.so.0.8.6 libsqlite3.so.0 || { rm -f libsqlite3.so.0 &amp;&amp; ln -s libsqlite3.so.0.8.6 libsqlite3.so.0; }; })
(cd /usr/local/python/lib &amp;&amp; { ln -s -f libsqlite3.so.0.8.6 libsqlite3.so || { rm -f libsqlite3.so &amp;&amp; ln -s libsqlite3.so.0.8.6 libsqlite3.so; }; })
/usr/bin/install -c .libs/libsqlite3.lai /usr/local/python/lib/libsqlite3.la
/usr/bin/install -c .libs/libsqlite3.a /usr/local/python/lib/libsqlite3.a
chmod 644 /usr/local/python/lib/libsqlite3.a
ranlib /usr/local/python/lib/libsqlite3.a
libtool: install: warning: remember to run `libtool --finish /home/caty/python2.6.4/lib'
test -z &quot;/usr/local/python/bin&quot; || mkdir -p -- &quot;/usr/local/python/bin&quot;
  /bin/sh ./libtool --mode=install /usr/bin/install -c 'sqlite3' '/usr/local/python/bin/sqlite3'
/usr/bin/install -c .libs/sqlite3 /usr/local/python/bin/sqlite3
test -z &quot;/usr/local/python/include&quot; || mkdir -p -- &quot;/usr/local/python/include&quot;
 /usr/bin/install -c -m 644 'sqlite3.h' '/usr/local/python/include/sqlite3.h'
 /usr/bin/install -c -m 644 'sqlite3ext.h' '/usr/local/python/include/sqlite3ext.h'
test -z &quot;/usr/local/python/share/man/man1&quot; || mkdir -p -- &quot;/usr/local/python/share/man/man1&quot;
 /usr/bin/install -c -m 644 './sqlite3.1' '/usr/local/python/share/man/man1/sqlite3.1'
test -z &quot;/usr/local/python/lib/pkgconfig&quot; || mkdir -p -- &quot;/usr/local/python/lib/pkgconfig&quot;
 /usr/bin/install -c -m 644 'sqlite3.pc' '/usr/local/python/lib/pkgconfig/sqlite3.pc'
make[1]: Leaving directory `/home/caty/DOWNLOAD/sqlite-3.6.22'
... 省略 ...

#
&lt;/pre&gt;

Pythonを作り直す。

&lt;pre class=&quot;out&quot;&gt;
# make
...[snip]

Failed to find the necessary bits to build these modules:
_tkinter           bsddb185           sunaudiodev
To find the necessary bits, look in setup.py in detect_modules() for the module's name.

running build_scripts


#
&lt;/pre&gt;

いくつか失敗しているが、大丈夫だろう。

どうも、PREFIX/lib/python*/lib-dynload/ に .soモジュールが入っているらしい。PREFIX/lib/python2.6/lib-dynload/_sqlite3.so が問題のブツだった。

&lt;b&gt;[追記]&lt;/b&gt;ちなみに、pysqliteとかいうのは古いPython用だから要らないよ。

*1265941306*[caty-depl]Catyの起動から確認まで

ダウンロードと展開。

&lt;pre class=&quot;out&quot;&gt;
$ wget http://www.chimaira.org/archive/caty-python-proto1-3.0.0-UNTESTED.zip

$ unzip caty-python-proto1-3.0.0-UNTESTED.zip
&lt;/pre&gt;

まず、日本語の問題がある。

&lt;pre class=&quot;out&quot;&gt;
$ python caty-console.py
Traceback (most recent call last):
  File &quot;caty-console.py&quot;, line 11, in &lt;module&gt;
    caty.shell.console.main(sys.argv[1:])
  File &quot;./python/caty/shell/console.py&quot;, line 321, in wrapped
    tb = unicode(traceback.format_exc(), _encoding)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe3 in position 499: ordinal not in range(128)

$
&lt;/pre&gt;

LANGを設定する。

&lt;pre class=&quot;out&quot;&gt;
$ echo $LANG
C

$ LANG=ja_JP.UTF-8

$ echo $LANG
ja_JP.UTF-8

$ python caty-console.py
microblog の設定を読み込んでいます
sample の設定を読み込んでいます
tutorial の設定を読み込んでいます
&amp;#42; tutorial は起動しないように設定されています
test-cmd の設定を読み込んでいます
wiki の設定を読み込んでいます
_ROOT の設定を読み込んでいます
Caty interactive shell

caty:&gt;
&lt;/pre&gt;

バックグラウンドで起動して、wgetで文書を取ってみる。
&lt;pre class=&quot;out&quot;&gt;
$ python caty-server.py &amp;
[1] 2867
[caty@microapplications caty-python-proto1-3.0.0-UNTESTED]
$ microblog の設定を読み込んでいます
sample の設定を読み込んでいます
tutorial の設定を読み込んでいます
&amp;#42; tutorial は起動しないように設定されています
test-cmd の設定を読み込んでいます
wiki の設定を読み込んでいます
_ROOT の設定を読み込んでいます
Serving on port 8000...


$ pgrep python
2867

$ wget http://localhost:8000/
&amp;#45;-10:27:16--  http://localhost:8000/
           =&gt; `index.html'
localhost をDNSに問いあわせています... 127.0.0.1
localhost|127.0.0.1|:8000 に接続しています... 接続しました。
HTTP による接続要求を送信しました、応答を待っています... 200 OK
長さ: 1,118 (1.1K) [text/html]

100%[==============================================&gt;] 1,118         --.--K/s

10:27:16 (4.96 MB/s) - `index.html' を保存しました [1118/1118]


$ cat index.html
&amp;#60;?xml version=&quot;1.0&quot;?&gt;&amp;#60;!-- -*- coding:utf-8 -*- --&gt;

  ... [snip] ...

 &amp;#60;/body&gt;
&amp;#60;/html&gt;

$
&lt;/pre&gt;

一時的に8000番ポートを開ける。

&lt;pre class=&quot;out&quot;&gt;
$ sudo /sbin/iptables --line-numbers -L INPUT

$ sudo /sbin/iptables -I INPUT 15 -p tcp --dport 8000 -m state --state NEW -j ACCEPT

$ sudo /sbin/iptables --line-numbers -L INPUT
&lt;/pre&gt;

ログアウトしても動くようにする。

&lt;pre class=&quot;out&quot;&gt;
$ nohup python caty-server.py &amp;

$ logout
&lt;/pre&gt;

*1265942012*[caty-depl]TotoiseHG

TortoiseHGダウンロード：
- http://bitbucket.org/tortoisehg/stable/wiki/download

日本語マニュアル：
- http://tortoisehg.bitbucket.org/manual/0.9-ja/

PuTTY（パティ）：
- http://www.putty.org/
- http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html ダウンしている、ダメだ。
- http://www.stackasterisk.jp/tech/engineer/putty01_01.jsp 解説

PuTTYの一部はトータスHGに同梱されている。Puttyのplink.exeは、TortoisePlink.exe となっている。

パスにC:\Installed\TortoiseHgを勝手に加えていた。これがいいやり方かもしれない。add_path.exe というコマンドを使っているようだ。add_path --help でライセンスが出る。もとは http://www.barisione.org/files/add_path.zip 。

トータスHGは確かによくできている感じだ。これなら使ってもらえるかも。

&lt;b&gt;[追記]&lt;/b&gt;文殊堂さん語録から：

+ TortoiseHG経由でしかやらない。
+ push,pull,commit,merge以外はやらない。
+ topic branchは使う。
+ rebaseはdefaultからのmergeで行う。

「こういう使い方だと割とMercurialをメンバに展開できる。」そうだ。

*1265944168*[caty-depl] http://caty.caty-sites.net/ 稼働中

とりあえず、こうする。

&lt;pre class=&quot;out&quot;&gt;
$ nohup python caty-server.py &amp;

$ logout
&lt;/pre&gt;

後はnginxがやってくれる。

&lt;pre class=&quot;code&quot;&gt;
    #
    # caty.caty-sites.net
    #
    server {
        listen       80;
        server_name  caty.caty-sites.net;
        access_log  logs/caty.caty-sites.net.access.log  main;

        location / {
            proxy_pass http://localhost:8000/;

            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Server $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        error_page  404              /404.html;


        #
        error_page   500 502 503 504  /50x.html;
    }
&lt;/pre&gt;

もし、8000番が落ちていれば、nginxが &lt;b&gt;502 Bad Gateway&lt;/b&gt; を出す。（nginx設定；error_pageとかは不要だな）

ちゃんとデーモンにするとか、監視（monitの予定）を付けるとかはそのうちやる。

ところで、Google Chorome の「DNSプリフェッチ」をオフにしないと、DNS変更がなかなか検出できない。

*1265959591*[caty-depl]必要なものと作業順序

&lt;h5&gt;クライアント側（Windows）&lt;/h5&gt;

+ Python 2.5 or 2.6 これだけは必須
+ nginx Windows上でサーバー動作を確認したいとき
+ OpenSSL SSLの動作をWindows上で確認したいとき
+ Mercurial/TortoiseHG バージョン管理、ファイル転送
+ PuTTY ファイル転送にSSHを使うとき
+ FTPソフト FTPでファイル転送をするとき

まとめると：

+ Pythonは必須
+ nginxとOpenSSLはオプション
+ なにかファイル転送ソフト（TortoiseHGがお勧め）

&lt;h5&gt;サーバー側（Linux）&lt;/h5&gt;

+ SQLite3
+ Python 2.5 or 2.6
+ virtual-python システム全体に影響を与えたくないとき
+ easy_install Mercurialのインストールのため
+ Mercurial 
+ nginx リパースプロキシー
+ vsftpd ファイル転送がFTPのとき

</body>
</day>
<day date="2010-02-13" title="">
<body>
*1266035860*[caty-depl][リンク]PuTTY

PuTTyの本家ダウンロードサイトが落ちているので、次から取ろう。

- http://hp.vector.co.jp/authors/VA024651/PuTTYkj.html -- putty-0.60-jp20070603.zip
- http://yebisuya.dip.jp/Software/PuTTY/ -- putty-0.60-JP_Y-2007-08-06.zip

*1266043681*[caty-depl]MercurialのためのSSHの設定と実験

サーバー側で、ssh-keygenを使ってキーペア（秘密、公開）を作る。

&lt;pre class=&quot;out&quot;&gt;
$ ssh-keygen -t rsa -C 'hiyama@chimaira.org'
Generating public/private rsa key pair.
Enter file in which to save the key (/home/caty/.ssh/id_rsa):
Created directory '/home/caty/.ssh'.
Enter passphrase (empty for no passphrase):&lt;b&gt;パスフレーズ入力&lt;/b&gt;
Enter same passphrase again:&lt;b&gt;パスフレーズ入力&lt;/b&gt;
Your identification has been saved in /home/caty/.ssh/id_rsa.
Your public key has been saved in /home/caty/.ssh/id_rsa.pub.
The key fingerprint is:
4b:67:4c:f2:1e:c3:8b:80:1e:4e:20:97:ad:5c:e6:b0 hiyama@chimaira.org

$ ls ~/.ssh/
id_rsa  id_rsa.pub

$ chmod 0700 ~/.ssh

$
&lt;/pre&gt;

その後、公開キーをオーソライズされたキーとして保管する。

&lt;pre class=&quot;out&quot;&gt;
$ cd ~/.ssh/

$ cat id_rsa.pub &gt;&gt; authorized_keys

$ chmod 0600 authorized_keys

$
&lt;/pre&gt;

秘密キーをなんらかの方法でWindowsクライアントに持ってくる。「-----BEGIN RSA PRIVATE KEY-----」行と「-----END RSA PRIVATE KEY-----」行で挟まれたアスキーテキストなので、移動は簡単。そのアスキーテキストファイルを、Windowsの ~/.ssh に置く（どこでもいいが、サーバー側と同じ習慣に従うのが吉）。拡張子は .key にした。

puttygen.exe を起動して、[Load an existing private key file] を選ぶ。~/.ssh/*.key のファイルを指定する。このとき、パスフレーズを聞かれる。その後で、[Save private key] をして、PuTTY形式で保存する。このときの拡張子は .ppk (PuTTY Private Key File) が吉。

PuTTY Private Key File は次の形式。
&lt;pre class=&quot;code&quot;&gt;
PuTTY-User-Key-File-2: ssh-rsa
Encryption: aes256-cbc
Comment: imported-openssh-key
Public-Lines: 4
1
2
3
4
Private-Lines: 8
1
2
3
4
5
6
7
8
Private-MAC: xxx
&lt;/pre&gt;

plink.exeをパスが通った場所に置いて、次のバッチファイルを作った。

&lt;pre class=&quot;code&quot;&gt;
@echo off
rem This is ssh.bat
setlocal

if NOT &quot;%SSH_USER%&quot;==&quot;&quot; goto SSH_USER
set _KEY=%1
shift
goto DO

:SSH_USER
set _KEY=%SSH_USER%
goto DO

:DO
echo plink.exe -ssh -i &quot;%HOME%\.ssh\%_KEY%.ppk&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9
plink.exe -ssh -i &quot;%HOME%\.ssh\%_KEY%.ppk&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9

endlocal
&lt;/pre&gt;

最初の実行は次のようになる。

&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net date
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@cay-sites.net date
The server's host key is not cached in the registry. You
have no guarantee that the server is the computer you
think it is.
The server's rsa2 key fingerprint is:
ssh-rsa 1024 71:3b:12:16:99:12:f4:32:09:b5:35:d9:2e:ce:38:59
If you trust this host, enter &quot;y&quot; to add the key to
PuTTY's cache and carry on connecting.
If you want to carry on connecting just once, without
adding the key to the cache, enter &quot;n&quot;.
If you do not trust this host, press Return to abandon the
connection.
Store key in cache? (y/n) y
Passphrase for key &quot;imported-openssh-key&quot;:
Sat Feb 13 15:11:52 JST 2010
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

二度目の実行は：

&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net date
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@caty-sites.net date
Passphrase for key &quot;imported-openssh-key&quot;:
Sat Feb 13 15:16:49 JST 2010
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

*1266043682*[caty-depl]MercurialのためのSSHの設定と実験 (続き)

サーバー側hgを実行してみる。

&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net hg version
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@caty-sites.net hg version
Passphrase for key &quot;imported-openssh-key&quot;:
bash: hg: command not found
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

http://sh1.2-d.jp/b/2007-10-18-00-05.html によると：
&gt;&gt;
色々調べてたら、sshでリモートからコマンドを実行する時には、 $HOME/.xxxファイル は読み込んでくれないんだね。hgコマンドは、 $HOME/local/bin/hg に置いてあって .zshrcにてPATHに追加してるので、そんなん知らないって言われちゃってると。

sshd_configのmanとか見ると、PermitUserEnvironmentが有効なら、 $HOME/.ssh/environment とかにPATHを追加したらいけそうなことが書いてあったので試してみたけど、どうやら駄目っぽい。まぁレンタルサーバだし有効じゃぁないわな。 /etc/ssh/sshd_config はPermission deniedで見れなかったのでわからんけど。

で、じゃあどのPATHなら有効なんだろうと思って、下記コマンドを実行してみたところ、うちのレンタルサーバでは、 $HOME/bin がユーザ用のPATHとして設定されていた。...(以下略)...
&lt;&lt;

パスを調べてみる。
&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net echo $PATH
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@caty-sites.net echo $PATH
Passphrase for key &quot;imported-openssh-key&quot;:
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

サーバー側のSSHD設定。

&lt;pre class=&quot;out&quot;&gt;
$ sudo cat /etc/ssh/sshd_config | grep Permit
#PermitRootLogin yes
PermitEmptyPasswords no
# PasswordAuthentication, PermitEmptyPasswords, and
# &quot;PermitRootLogin without-password&quot;. If you just want the PAM account and
#PermitUserEnvironment no

$
&lt;/pre&gt;

PermitUserEnvironment yes にする。

&lt;pre class=&quot;out&quot;&gt;
$ printenv | egrep '^PATH='
PATH=/home/caty/python2.6.4/bin:/home/caty/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin

$ printenv | egrep '^PATH=' &gt; ~/.ssh/environment
&lt;/pre&gt;

environmentファイルを作った。X11R6は編集して消した。

SSHDに設定を読ませる。
&lt;pre class=&quot;out&quot;&gt;
$ sudo /sbin/service sshd status
sshd (pid 22770 4769 4767) is running...

$ sudo /sbin/service sshd reload
Reloading sshd:                                            [  OK  ]

$
&lt;/pre&gt;

パスをもう一度確認。
&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net echo $PATH
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@caty-sites.net echo $PATH
Passphrase for key &quot;imported-openssh-key&quot;:
/home/caty/python2.6.4/bin:/home/caty/bin:/usr/kerberos/bin:/usr/local/bin:/bin:
/usr/bin
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

Mercurialは？
&lt;pre class=&quot;out&quot;&gt;
C:\Documents and Settings\Hiyama&gt;ssh caty@caty-sites.net hg version
plink.exe -ssh -i &quot;C:\Documents and Settings\Hiyama\Work\.ssh\caty.ppk&quot; caty@caty-sites.net hg version
Passphrase for key &quot;imported-openssh-key&quot;:
Mercurial Distributed SCM (version 1.4.3)

Copyright (C) 2005-2010 Matt Mackall &lt;mpm@selenic.com&gt; and others
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
C:\Documents and Settings\Hiyama&gt;
&lt;/pre&gt;

動いた。


</body>
<comments>
<comment>
<username>soda</username>
<body>zsh なら $HOME/.zshenv で設定できませんか？$HOME/.zshrc は対話的シェル専用です。</body>
<timestamp>1266099260</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>sodaさん、ありがとうございます。&lt;br&gt;僕はzshを使ってないんですよ。sshdの設定を変えてしまったので、まー、これでいいかな、と。</body>
<timestamp>1266195989</timestamp>
</comment>
</comments>
</day>
<day date="2010-02-18" title="">
<body>
*1266465636*[後で消す]後で消せない

[http://d.hatena.ne.jp/m-hiyama-memo/20100210/1265766519:title]のなかで残っているのがある。

+ インストール -&gt; 失敗した。アンインストールして再インストールが必要。
+ 校正添削 -&gt; 終わったが次が来てる。
+ 支払い-&gt; 終わったが、なんか手違いで請求が来てる。
+ 買い物（渋谷） -&gt; 終わった
+ 送別会（新宿） -&gt; 終わった
+ 解約手続き -&gt; 終わったが、ドメイン移管手続きをしないと
+ サーバー設定 -&gt; 終わったが、運用してるとは言い難い。
+ ハードウェア貸出申し込み or 購買 -&gt; やってない。
+ 連絡 Kk  -&gt; やってない。

*1266486037*[caty-depl][雑記]ドメインの移管手順 -- 簡単すぎてワケワカラン

リンククラブの解約手続きをしたら、AuthInfo（認証コード）とレジストリキーというものがメールで来た。

+ で、Dotsterにログインする。
+ My Domains を選ぶ。
+ Other Domain Tools から Transfer Domains を選ぶ。
+ ドメイン名を入れる：chimaira.org
+ 会計処理に入った。$11.95 取られた。
+ 長い長い Registration Agreement を読めと、https://secure.dotster.com/order/register/agreement.php ウゲー。
+ いいや、読んだことにしてサブミット。

&gt;&gt;
Congratulations! We are processing your order. We will notify you by email when it is complete.

|*Domain      |*Message|
|CHIMAIRA.ORG |This item is being processed. We will notify you when processing is complete.|
 
If you have any questions about this order, please contact our customer support. Please mention the following order code: &lt;b&gt;session ID: 4182614&lt;/b&gt;
&lt;&lt;

ええーっ、認証コードもレジストリキーも必要なかったぞ。どういうこと？？

*1266486634*[caty-depl][雑記]PuTTY plink で作った ssh

&lt;pre class=&quot;code&quot;&gt;
@echo off
rem This is ssh.bat
setlocal

if &quot;%HOME&quot;==&quot;&quot; goto ConstructHome
set _HOME=%HOME%
goto SetKey

:ConstructHome
set _HOME=%HOMEDRIVE%%HOMEPATH%
goto SetKey

:SetKey
if NOT &quot;%SSH_KEY%&quot;==&quot;&quot; goto UseSSH_KEY
set _KEY=%1
shift
goto CheckArg

:UseSSH_KEY
set _KEY=%SSH_KEY%
goto CheckArg

:CheckArg
if &quot;%1&quot;==&quot;&quot; goto Usage

:Do
echo plink.exe -ssh -i &quot;%_HOME%\.ssh\%_KEY%.ppk&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9
plink.exe -ssh -i &quot;%_HOME%\.ssh\%_KEY%.ppk&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9

goto End

:Usage
echo.
echo Usage: %0 [SSHKeyName] Host [Command]
echo.
echo SSHKeyName   : SSHの秘密キーファイルの名前（拡張子なしのベース名）です。
echo                環境変数SSH_KEYが定義されていれば、その値を使います。
echo Host         : ホストのドメイン名を指定します。ユーザー名@ドメイン名 も使えます。
echo Command      : ホストで実行すべきコマンドです。指定しないとシェルログインします。
echo.
goto End

:End
endlocal
&lt;/pre&gt;

</body>
</day>
<day date="2010-02-19" title="">
<body>
*1266539224*[caty-depl][雑記]続・ドメイン移管

[http://d.hatena.ne.jp/m-hiyama-memo/20100218/1266486037:title] の件。次のメールがきた。

&gt;&gt;
Domain Transfer Initiated - Thank You!
差出人:	 info@dotster.jp
宛先:	檜山＠ほっとけ

Thanks for taking the first steps to transfer your domain(s) to us. There are just a few more steps to go before your transfer succeeds:

1) You will need to request &lt;b&gt;a transfer Authorization Code&lt;/b&gt; from your prior Registrar. Typically, you receive this Authorization Code via email.

2) We will email the Administrative Contact's email address with Transfer links to complete the process.

3) The Administrative Contact (typically you) clicks the Transfer link in the email mentioned above in Step 2. On our site, you will enter the Authorization Code issued by your prior Registrar.

4) Your prior Registrar releases your domain. This process takes up to seven (7) calendar days.

5) Your domain appears in our Account Management with the Name Server settings preserved from your prior Registrar.

6) Your credit card is charged and we send you an invoice.

Please remember:

- This process can take up to seven (7) days as we work with your prior Registrar to transfer your domain.

- Make sure you verify the email address for the Administrative Contact for your domain since that is where we will send the transfer email with links to finish the process.

If you have questions, please visit our website here: https://secure.registerapi.com/KM/script_login.php?XXXXXXXX. Thank you for your business.

Best Regards,
Customer Care Team
&lt;&lt;

&gt;&gt;
csupport@registerapi.com To 自分

Attention: 檜山＠痔滅入る

Re: Transfer of CHIMAIRA.ORG

CHIMAIRA.ORG

You have received this message because you are listed as the Registered Name Holder or Administrative contact for this domain name in the WHOIS database.

Please read the following important information about transferring your domain name:

       - You must agree to enter into a new Registration Agreement with us. You can review the full terms and conditions of the Agreement at https://secure.registerapi.com/order/register/agreement.php?XXXXXXXX

       - Once you have entered into the Agreement, the transfer will take place within five (5) calendar days unless the current registrar of record denies the request.

       - Once a transfer takes place, you will not be able to transfer to another registrar for 60 days, apart from a transfer back to the original registrar, in cases where both registrars so agree or where a decision in the dispute resolution process so directs.

If you WISH TO PROCEED with the transfer, you must respond to this message via one of the following methods (note if you do not respond by Feb 28, 2010, 21:33 GMT, CHIMAIRA.ORG will not be transferred to us.).

Please go to our website, https://secure.registerapi.com/order/trx/auth.php?XXXXXXXX to confirm.

If you DO NOT WANT the transfer to proceed, then don't respond to this message.

If you have any questions about this process, please contact Customer Care: https://secure.registerapi.com/KM/script_login.php?XXXXXXXX
&lt;&lt;

で、Please go to our website, https://secure.registerapi.com/order/trx/auth.php?XXXXXXXX to confirm. って指示にしたがって、Web画面から認証コードを入れた。

&gt;&gt;
Confirm Domain Transfer

Your confirmation has been recorded. The person requesting the transfer can log into their account at this registrar and view the status of domain transfer orders.
&lt;&lt;

今までの経緯から言うと：

+ 現在のレジストラに解約申し込みをする。
+ 現在のレジストラから認証コードが送られてくる。
+ 移管先レジストラに移管申し込みをする。
+ しばらくして、移管先レジストラが、認証コードの入力を要求する。
+ 認証コード（またはレジストリキー）を入力する。

という手順らしい。

あとは作業完了メールを待つだけか（だといいな）。

&lt;hr&gt;
追記：完了したらしい。

&gt;&gt;
Domain Transfer Complete - Welcome!
差出人:	 info@dotster.jp
送信日時:	2010年2月19日 1:43:09
宛先:	檜山＠ほっとけ

Good news - Transfer of the following domain(s) is now complete:

CHIMAIRA.ORG

You can now login into Account Management to manage this domain under the &quot;My Domains&quot; tab. Expect an invoice and charge to your credit card soon.

Please note that your registration information is published to the WHOIS Directory by default (this includes your name and email address). We can help keep this information private with our WHOIS Privacy service.

To add this to your domain, go the &quot;My Domains&quot; tab, check the box next to the desired domain(s), then select &quot;Add WHOIS Privacy&quot; in the &quot;Select Domain Management Task&quot; list.

Best Regards,
Customer Care Team
&lt;&lt;

*1266540118*[雑記][メモ]信頼できない証明書に関する操作 firefox

GUIの操作指示を文章で書くのはバカみたいだなー。

しょうがない： [ツール]メニュー - [オプション]項目 - [詳細]タブ - [証明書を表示]ボタン - [証明書マネージャ]ダイアログ - [サーバー証明書]タブ

- [例外を追加]ボタン でURLを追加
- 選択して[削除]ボタン でURLを削除

同じタブの[インポート]ボタンでインポートしてもらってもいいのか。

*1266559968*[後で消す]後で消せない

+ 祐天寺だっけ？ 来週かな
+ インストール -&gt; 失敗した。アンインストールして再インストールが必要。明日か。
+ 校正添削 -&gt; 終わったが次が来てる。今日と月曜。
+ 解約手続き -&gt; 終わった。
+ 解約手続き -&gt; 別なの。あと、もう一つ残っている。
+ ハードウェア貸出申し込み or 購買 -&gt; 終わった。
+ 連絡 Kk  -&gt; やってない。連絡関係が増えた。
+ 保険証でなんか言われた、確認。

</body>
</day>
<day date="2010-02-20" title="">
<body>
*1266636361*[雑感]カニンガムも悩んでいたんだろうな

本編でFITを少し紹介した。

- http://fit.c2.com/wiki.cgi?IntroductionToFit

このページの第一段落：

&gt;&gt;
Great software requires collaboration and communication. During development, how can customers know that their programmers are producing the right thing? How can programmers know what the customers really want? How can testers know what's right and what's wrong? Getting these groups to communicate effectively and precisely should be a goal for teams creating great software.
&lt;&lt;

まさにその通り、なんにも言うことはない。第二段落には、次のような言葉がある（太字強調は檜山）。

- Fit creates &lt;b&gt;a feedback loop between customers and programmers&lt;/b&gt;.
- building &lt;b&gt;a simple and powerful bridge between the business and software engineering worlds&lt;/b&gt;.

customers/the business ってのがカニンガムがなんとかしようとしたターゲットなんだと思う。HTMLテーブルを選んだのは、Word/ExcelがHTMLテーブルなら吐き出せることが理由だろう（推測だが）。つまり、

- Word/Excelでも、仕様や受け入れテストを書けますよ

ってのがFITの最大のウリだろう。こういうアイディアに至る過程では、推測するに、かなりの苦悩があったように思う。

*1266642253*[caty-depl][メモ]さらにドメイン移管

Dotsterにログインして、chimaira.org のネームサーバを見てみた。ドメインにチェック（選択）して、下のメニューから Modify nameservers 選んでGoね。現状は何もセットされてない。nslookupすると：

&lt;pre&gt;
Non-authoritative answer:
Name:    www.chimaira.org
Address:  219.118.71.45
&lt;/pre&gt;

whois引いてみた。太字はコメント。

&lt;pre&gt;
Domain ID:D99682150-LROR
Domain Name:CHIMAIRA.ORG
Created On:22-Aug-2003 07:04:44 UTC  &lt;b&gt;（2003年、けっこう古い）&lt;/b&gt;
Last Updated On:19-Feb-2010 01:43:10 UTC
Expiration Date:22-Aug-2011 07:04:44 UTC  &lt;b&gt;（来年夏まで）&lt;/b&gt;
Sponsoring Registrar:Dotster, Inc. (R34-LROR)
Status:TRANSFER PROHIBITED
Status:TRANSFERPERIOD

Registrant ID:DOT-PEMRK7BNG32O
Registrant Name:Masayuki HIYAMA &lt;b&gt;（僕だ）&lt;/b&gt;
Registrant Organization:HMO
Registrant Street1:kamimeguro 3-6-2
Registrant Street2:
Registrant Street3:
Registrant City:meguro-ku
Registrant State/Province:Tokyo
Registrant Postal Code:153-0051
Registrant Country:JP
Registrant Phone:+81.0357207950
Registrant Phone Ext.:
Registrant FAX:+81.0357207951
Registrant FAX Ext.:
Registrant Email:hiyama99@hotmail.com &lt;b&gt;（ホットメールか、変更しようかな）&lt;/b&gt;

Name Server:USR-NS1.LINKCLUB.JP &lt;b&gt;（リンククラブ）&lt;/b&gt;
Name Server:USR-NS2.LINKCLUB.JP

DNSSEC:Unsigned
&lt;/pre&gt;

ちなみに：

&lt;pre&gt;
Non-authoritative answer:
Name:    USR-NS1.LINKCLUB.JP
Address:  219.118.70.40


Non-authoritative answer:
Name:    USR-NS2.LINKCLUB.JP
Address:  219.118.70.50
&lt;/pre&gt;

219.118.{70,71} あたりがリンククラブか。

3月いっぱいはリンククラブに料金も払っているから問題なく名前は引けるはず。適当なタイミングで、DotsterのModify nameserversでネームサーバを新しく割り当てればいい、と。ただし、リンククラブへの情報が残っているうちに旧サーバーがなくなるとまずいから、早めにしないと。一週間余裕みておけばいいだろう。

メールを受け取れるようにするのが残作業。

*1266642930*[メモ][caty-depl] TortoiseHGとコマンドライン版HG

TortoiseHGのMercurila.iniにこんなことが書いてある。

&lt;pre&gt;
; !!!  Do Not Edit This File !!!
;
; This file will be replaced by the installer on every upgrade.
; Editing this file can cause strange side effects on Vista.
;
; http://bitbucket.org/tortoisehg/stable/issue/135
;
; To change settings you see in this file, override (or enable) them in
; your user Mercurial.ini file, where USERNAME is your Windows user name:
&lt;/pre&gt;

ムーー。Mercurial.iniの内容は：

&lt;pre class=&quot;out&quot;&gt;
$ grep '^[^[;]' Mercurial.ini
editor = notepad
ssh = &quot;C:\Installed\TortoiseHg\TortoisePlink.exe&quot; -ssh -2
kdiff3.priority=-1
kdiff3.args=-L1 base --L2 local --L3 other $base $local $other -o $output
kdiff3.regkey=Software\KDiff3
kdiff3.regappend=\kdiff3.exe
kdiff3.fixeol=True
kdiff3.gui=True
beyondcompare3.priority=-2
beyondcompare3.args=$local $other $base $output /ro /lefttitle=local /centertitl
e=base /righttitle=other /automerge /reviewconflicts /solo
beyondcompare3.regkey=Software\Scooter Software\Beyond Compare 3
beyondcompare3.regname=ExePath
beyondcompare3.gui=True
diffmerge.priority=-7
diffmerge.args=--nosplash --merge --title1=base --title2=local --title3=other $base $local $other
diffmerge.checkchanged=True
diffmerge.gui=True
p4merge.priority=-8
p4merge.args=$base $local $other $output
p4merge.regkey=Software\Perforce\Environment
p4merge.regname=P4INSTROOT
p4merge.regappend=\p4merge.exe
p4merge.gui=True
tortoisemerge.priority=-9
tortoisemerge.args=/base:$output /mine:$local /theirs:$other /merged:$output
tortoisemerge.regkey=Software\TortoiseSVN
tortoisemerge.gui=True
winmergeu.regkey=Software\Thingamahoochie\WinMerge\
winmergeu.regname=Executable
winmergeu.priority=-10
winmergeu.args=/e /ub /dl other /dr local $other $local $output
winmergeu.fixeol=True
winmergeu.gui=True
extdiff =
cmd.vdiff = C:\Installed\TortoiseHg\kdiff3
opts.vdiff = $parent1 $child $parent2

&lt;/pre&gt;

コマンドライン版のHGと統合することはできないのかな？ 以下は、コマンドライン版のini。

&lt;pre class=&quot;out&quot;&gt;
$ grep '^[^[;]' Mercurial.ini
editor =  emacsclient

username = Masayuki HIYAMA

# Some default global settings for common merge tools
kdiff3.args=--auto --L1 base --L2 local --L3 other $base $local $other -o $outpu
t
kdiff3.regkey=Software\KDiff3
kdiff3.regappend=\kdiff3.exe
kdiff3.fixeol=True
kdiff3.gui=True
gvimdiff.args=--nofork -d -g -O $local $other $base
gvimdiff.regkey=Software\Vim\GVim
gvimdiff.regname=path
gvimdiff.priority=-9
merge.checkconflicts=True
merge.priority=-10
gpyfm.gui=True
meld.gui=True
tkdiff.args=$local $other -a $base -o $output
tkdiff.gui=True
tkdiff.priority=-8
xxdiff.args=--show-merged-pane --exit-with-merge-status --title1 local --title2
base --title3 other --merged-filename $output --merge $local $base $other
xxdiff.gui=True
xxdiff.priority=-8
diffmerge.args=--nosplash --merge --title1=base --title2=local --title3=other $b
ase $local $other
diffmerge.checkchanged=True
diffmerge.gui=True
p4merge.args=$base $local $other $output
p4merge.regkey=Software\Perforce\Environment
p4merge.regname=P4INSTROOT
p4merge.regappend=\p4merge.exe
p4merge.gui=True
p4merge.priority=-8
tortoisemerge.args=/base:$base /mine:$local /theirs:$other /merged:$output
tortoisemerge.regkey=Software\TortoiseSVN
tortoisemerge.checkchanged=True
tortoisemerge.gui=True
ecmerge.args=$base $local $other --mode=merge3 --title0=base --title1=local --ti
tle2=other --to=$output
ecmerge.regkey=Software\Elli\xc3\xa9 Computing\Merge
ecmerge.gui=True
filemerge.executable=/Developer/Applications/Utilities/FileMerge.app/Contents/Ma
cOS/FileMerge
filemerge.args=-left $other -right $local -ancestor $base -merge $output
filemerge.gui=True
beyondcompare3.args=$local $other $base $output /ro /lefttitle=local /centertitl
e=base /righttitle=other /automerge /reviewconflicts /solo
beyondcompare3.regkey=Software\Scooter Software\Beyond Compare 3
beyondcompare3.regname=ExePath
beyondcompare3.gui=True
winmerge.args=/e /u /dl local /dr other /wr $local $other $output
winmerge.regkey=Software\Thingamahoochie\WinMerge
winmerge.regname=Executable
winmerge.checkchanged=True
winmerge.gui=True

&lt;/pre&gt;

*1266647231*[メモ][caty-depl]続 TortoiseHGとコマンドライン版HG

混ぜて一緒にするのはやめておこう、別々においても、とりあえず実害はないようだから。

PATHはこんな：
&lt;pre class=&quot;out&quot;&gt;
$ echo $PATH | sed 's/:/\
/g'
.
/usr/local/bin
/mingw/bin
/bin
/c/PROGRAM FILES/THINKPAD/UTILITIES
/c/WINDOWS/system32
/c/WINDOWS
/c/WINDOWS/System32/Wbem
/c/Program Files/ATI Technologies/ATI Control Panel
/c/Program Files/PC-Doctor for Windows/services
/c/Program Files/imagemagick-6.2.8-q16
/c/Installed/Python26
/c/Installed/Mercurial
/c/Installed/meadow3/bin
/mingw/bin
/usr/bin
/c/Program Files/java/jdk1.6.0_18/bin
/c/Program Files/java/jre6/bin
/c/Installed/TortoiseHg
/c/Documents and Settings/Hiyama/Work/bin
/c/Installed/erl5.7.4/bin
&lt;/pre&gt;

なので：

&lt;pre class=&quot;out&quot;&gt;
$ which hg
/c/Installed/Mercurial/hg.exe

Hiyama@TP-T42-HIYAMA ~
$ which hgtk
/c/Installed/TortoiseHg/hgtk.exe

Hiyama@TP-T42-HIYAMA ~
$ ls /c/Installed/TortoiseHg/hg*
/c/Installed/TortoiseHg/hg.exe  /c/Installed/TortoiseHg/hgtk.exe

&lt;/pre&gt;


</body>
</day>
<day date="2010-03-08" title="">
<body>
*1268011330*[メモ][caty-depl]続・続 TortoiseHGとコマンドライン版HG

再掲しておくと：

&lt;pre&gt;
; !!!  Do Not Edit This File !!!
;
; This file will be replaced by the installer on every upgrade.
; Editing this file can cause strange side effects on Vista.
;
; http://bitbucket.org/tortoisehg/stable/issue/135
;
; To change settings you see in this file, override (or enable) them in
; your user Mercurial.ini file, where USERNAME is your Windows user name:
;
; XP or older    - C:\Documents and Settings\USERNAME\Mercurial.ini
; Vista or later - C:\Users\USERNAME\Mercurial.ini
&lt;/pre&gt;

環境変数HOMEは見てくれないようだ。最終的な設定を確認するには、hg showconfig ui.editor とかすればいい。

で、結局、USERNAME\Mercurial.ini の側にすべての設定を書くことにする。特にSSHの設定だな。

&lt;b&gt;[追記 date=&quot;翌日&quot;]&lt;/b&gt;

ウーン、問題があるなー。コマンドラインHGでは、コマンドライン版のplink.exeをSSHコマンドにに設定しても問題ないけど、GUI版だとコンソール出力ができないのでうまくない。GUI用に設定して、それをコマンドラインでも使うことになるだろう。GUI用の設定がわからん。

*1268011331*[メモ]firefoxのコマンドラインオプション

'-new-tab' だけ知っている。他は知らない。



</body>
</day>
<day date="2010-03-09" title="">
<body>
*1268101579*[メモ]パソコンの画面切り替え

こんな表があった。古いかな？

|*メーカー	|*ノートPC機種名	|*画面切り替えキー操作|
|SONY	|VAIO	|[Fn]キーと[F7]キー|
|IBM	|ThinkPad	|[Fn]キーと[F7]キー|
|HITACHI	|Prius	|[Fn]キーと[F3]キー、または[F7]キー、または[F8]キー|
|NEC	|Lavie	|[Fn]キーと[F3]キー|
|FUJITSU	|FM-V　BiBLO　/　LOOK|[Fn]キーと[F10]キー|
|Panasonic	|HITO　/　Let's note|[Fn]キーと[F3]キー|
|TOSHIBA	|Dynabook / libletto	|[Fn]キーと[F5]キー|
|SHARP	|Mebius	|[Fn]キーと[F5]キー|
|HP/Compaq	|Evo Notebook	|[Fn]キーと[F4]キー|
| ?|アルマダ	|[Fn]キーと[F3]キー|
|DELL	|Insprion	|[Fn]キーと[F8]キー|
|Victor	|InterLink	|[Fn]キーと[F10]キー|
|CASIO	|CASSIOPEIA FIVA	|[Fn]キーと[F10]キー|
|EPSON	|　	|[Fn]キーと[F8]キー|
|GATEWAY|	　	|[Fn]キーと[F3]キー|
|iiyama	|　	|[Fn]キーと[F3]キー|
|APPLE	|PowerBook / Mac Book 各種	|キー操作必要なし|


</body>
</day>
<day date="2010-03-11" title="">
<body>
*1268276067*[メモ][Caty]ソフトウェアの説明は難しい

一般論として：

+ ソフトウェアは、使ってみないとわからない
+ 説明を聞いてもわからない
+ 下手な説明ではなおさらわからない

さらに、次の動機がないと興味は持たない

+ 自分が困っていることを解決できそう
+ 自分がやりたいことが実現できそう

つまり、right-person, right-place, right-occasion でなくては話が噛み合わない。

説明に関しては、分かりやすさや適切さ以外にたぶん&lt;del datetime=&quot;2010-03-11T17:38:50+09:00&quot;&gt;2つ&lt;/del&gt;3つの追加的要求があって：

+ なにかキレイなもの（絵とかパンフレットとかスライドとか）
+ 多少のハッタリやら権威付けやら
+ 最近の流行りもの（バズワードでもOK）

ダハハハハ、この3つは僕が一番苦手なものだわな。

しかし、人と話てみることは常に収穫をもたらす。次のような要求の実現は、労力の割にはハッタリの効果がありそうだ。

+ ウィジェット、トランスクルード
+ Ajax
+ Webサービスのアグリゲーション
+ パーソナライズ

どれも一時バズワードっぽかったが、それなりに定義や意味が確定して技術的な曖昧性は少なくなっている。今の時期なら、忌避する理由もないかな。

&lt;b&gt;[追記]&lt;/b&gt;

あーなんか分かった。今日になってわかったような気がする。

うーんと、Plaggerのようなことをしたい。で、それがWebページのように表示可能、あるいはウィジェット（ブログパーツ）みたいな貼付け可能なモノとして欲しい。と、そういうことか。であるなら、簡単じゃん、それ。いや待て待て。利用場面とかも含めて何が難しいかを考えないとな。

HTTPフェッチャー（サーバー側にいるHTTPクライアント）はコマンドにすればいい。が、もしJSONじゃないと、JSONへの変換が必要だ。HTMLをスクレイピングする必要さえあるかもしれない。定期的なリフレッシュとかは面倒かもな。複数のウィジェットの調定も必要か。

まー、だけど原理的に困難なところはない気がする。

&lt;b&gt;[追記 その2]&lt;/b&gt;

あーまた分かった。分かるのが遅いが。

Webインターフェースで完結したいとは、基本はフォームだな。けど、JavaScriptとかFlashで頑張ればデスクトップみたいにできる。で、UIがどうであっても、普通のPOSTかAjaxのPOSTで送ればいいわけだ。それで、問題というか核心は、そのPOSTデータが通常のリソース状態（サーバー側の永続性がある状態）つうよりはシステム状態（サーバー側の状態だが、コンテンツというよりはシステムに関連する永続データ）への変更に関わるってことか。Web経由でschemataを書き換えるとか。

ともかく、受け口は同じだから、ちょっと超越的な（あるいはイリーガルな）コマンドを準備すれば済む話だ。モラルと安全面からどうかと思うが、結局はそういうことをしたい！ つう話なのだと思う。

それでしかも、ドラッグ＆ドロップとか言っているのだから、採用できる手段はメタテンプレートしかないわな。結論的には、メタテンプレートやれ、ってことか。メタテンプレートがあれば、イリーガルなことしなくてもイケるケースはかなりありそうだ。

*1268277406*[メモ][Caty]URL紙芝居

人の希望・要望を聞くのは役に立つし、アイディアの源泉かも。つっても、まーくだらないけど：

JSON WebサービスでもRSSでも何でもいいのだけど、URLのリストを配信する場所がある。クライアントは、そのURLリストを取ってくる。で、クリックして次々とURLを見ていく、というだけ。

「URLのリストを配信する場所」のリストとか「「URLのリストを配信する場所」のリスト」のリストとかがあって、一枚のWebページで、紙芝居のようにドンドンと見ていけたら便利かも。

</body>
</day>
<day date="2010-03-12" title="">
<body>
*1268364911*[メモ]自分に関する順位

統計みたいな資料があるのか。

- http://tophatenar.com/ranking/subscriber/1?blog=hatena
- http://b.hatena.ne.jp/entrylist?sort=count&amp;url=http%3A%2F%2Fd.hatena.ne.jp%2Fm-hiyama


</body>
</day>
<day date="2010-03-15" title="">
<body>
*1268612173*[メモ]CSSの配置に関して

次がわかりやすかった。

- http://www.css-lecture.com/log/css/037.html
- http://d.hatena.ne.jp/elm200/20080203/1202009300


</body>
</day>
<day date="2010-03-18" title="">
<body>
*1268880557*[メモ][caty-depl]hgがリモートに接続できなくなった

理由がサッパリわからない。困った。

後でもう少し調べるけど。

*1268880558*[メモ][JavaScript]スタイルプロパティとかナニヤラとか

スタイルシートの設定より、JavaScriptで someElm.style.someProperty = someValue; とやったほうが効く。まー、あたりまえと言えるが、良かったー。これで、スタイルシートでの邪魔な指定をプログラム側でオーバライドできる。

コンテントエリア、パディング、ボーダー、マージンとかの概念はいいんだけど、結局座標原点はどこよ、ってのがあんまり書いてないのが癪に障る！ もうちょっと幾何学的に書いてくれないかな。と僕は思う。自然言語で曖昧にウダウダ書くのやめてくれよ、もうホントに。

で実験したら、ボックスの原点はボーダーエッジの左上。このため、ボーダー幅分だけパディング矩形（パディングエッジで囲まれる面分）は右下にずれることになる。当然に、コンテント矩形もずれる。通常の感覚では、ボックスの矩形とはボーダー矩形（ボーダーエッジが囲む面分）のことだろう。left, topに関してはこの直感が反映されるが、パディングが0だとしても、width, height はボックス矩形の寸法ではない。

仮に、ボックス矩形＝ボーダー矩形として、パディングは常に0とすれば：

- ボックス矩形の幅＝border-left-width + width + border-right-width

*1268880707*[メモ]依頼のプロトコル

+ request 依頼 customer --&gt; supplier
+ offer 提案 customer &lt;-- supplier
+ request 再依頼 customer --&gt; supplier
+ offer 再提案 customer &lt;-- supplier
+ ... (一度以上の繰り返し)
+ accept 提案受け入れ customer --&gt; supplier
+ commit 確定（通知）  customer &lt;-- supplier

または：

- cancel 依頼の中止 customer --&gt; supplier
- canceled 何もしない（通知） customer &lt;-- supplier


</body>
</day>
<day date="2010-03-19" title="">
<body>
*1268981289*[後で消す]歯医者

- 03-5489-0418

次は4月1日。11時半


</body>
</day>
<day date="2010-03-23" title="">
<body>
*1269331231*[Caty]これを解け

- 問題：すでに存在する静的サイトに対して、アンケートや連絡（コンタクト）フォームを付けたくなった。
- 前提：静的サイトしか作れない。プログラミングはできない。レンタルサーバーの変更なんてとんでもない。
- 要求：自分のサイト内に設置したようにしたい。デザイン・雰囲気も他のページと完全にマッチするようにしたい。

とりあえず、この問題を解くことに集中！

*1269331274*[メモ][Caty]概念＆用語いろいろ

ものごとをハッキリさせるには造語するしかないなー。

- フロントパート：アプリケーションの部分で、原則的にクライアントサイドで実行されるところ。
- バックパート：アプリケーションの部分で、原則的にサーバーサイドで実行されるところ。
- バックステージ：アプリケーションのバックパートをホスティングするサーバーやサイト
- バックステージ・プロバイダ： バックステージの提供者
- ロード：アプリケーションがページ内でセットアップされること。
- ローダー：ロードするための方式や実装
- 配備：ページやアプリケーションを物理的に適切な位置に格納してセットアップすること。
- フラグメント（素材、イングリィディエント）：フロントパートを構成するさらに細分された部品。バックパートで使うか？
- ジェネレータ：フロントパートを生成するプログラム、または単に静的なファイル。バックステージで実行されることが多い。
- ビュー・ジェネレータ：特にビューを生成するジェネレータ。実体はテンプレートエンジン。
- リアクター：フロントパートと通信して、継続的なデータ処理を受け持つプログラム。バックステージで実行されることが多い。
- ビュー、スクリプト、スタイル：フラグメント（イングリィディエント）の種類
- テーマ：ビューの見た目を制御するCSSスタイルシートと画像群
- HTMLP (HTMP with padding)：HTML文字列データをJavaScript関数の引数にした形式
- オーナー：ページの所有者
- ビジター、ビューワー：ページの閲覧者
- サプライヤー：アプリケーションの提供者
- セレクター仕様、画像仕様：アプリケーションのビューを制御するためのCSSセレクターと、画像のロール名の意味記述
- ページ遷移仕様、状態遷移仕様：名前のとおり、まんま
- DOM仕様：アプリケーションのビューHTMLのDOM構造の仕様、スクリプトフラグメントを作るときに必要。
- APIリクエストフォーワーダー：Web APIへのリクエストをプロクシするサーバー側HTTP中継クライアント。
- 内部トランスクルード：同じドメイン内でのトランスクルード、ロード方法のひとつ
- 外部トランスクルード：違うドメイン（クロスドメイン）間のトランスクルード、ロード方法のひとつ
- メッセージトランスレート：HTTP、メール、その他のメッセージの変換
- アプリケーション個別プロトコル：まんま（通信のやりとりの規約）

Catyはバックパートを作る道具として適切。

どんなアプリケーションがあるだろうか？


+ 無料イベントの参加申し込み（有料は別な考慮が必要）
+ コンタクトフォーム、メールへのゲートウェイ
+ パーソナルメッセージ（難しいかも）
+ ミニアルバム（写真数枚）
+ 私の予定カレンダー （変更はオーナーのみ）
+ 私のつぶやき（twitter）
+ ブログ更新情報
+ 最近のソーシャルブックマーク
+ メールで一言、メールで最新ニュース
+ なんらかの検索ボックス
+ ログイン／ログアウト
+ 挨拶
+ 占い、ことわざ、運勢 etc.

&lt;b&gt;[追記]&lt;/b&gt;

+ コメント欄（テキストのみ）
+ トラックバック欄
+ レビュー（hReview）



</body>
</day>
<day date="2010-03-24" title="">
<body>
*1269413696*[メモ][Caty]ウィジェットアプリケーションをページにロードする方法

ODJS=OnDemandJavaScript, HTMLP=HTML with Padding

+ SSI、テンプレート処理
+ Ajax
+ scriptタグ+document.write
+ ODJS+JSONP
+ ODJS+HTMLP
+ frame, iframe
+ 別ウィンドウ
+ 画像ビーコン（サーバーへの送信のみ）

それぞれに特徴があるが、次のような評価分類の観点がありそうだ。

+ ウィジェットは単体でURLを持てるか？
+ クロスドメインで利用可能か？
+ ページ表示後にロードやリロードができるか？
+ フロント側にサーバーサイドプログラムが必須か
+ JavaScriptが必須か
+ フロント側の（サイト内）ページ遷移をサポートするか

scriptタグ＋document.writeでは、次の方法で動的にHTMLコードを挿入できる（ブラウザ側）。

&gt;|javascript|
thisUrl = document.URL;
// thisUrlからなんらかの情報を取る
// 他に、cookie使うとかもあるかも
jsUrl = // thisUrlから動的に作る
document.write(&quot;&lt;script src='&quot; + jsUrl + &quot;'&gt;&lt;&quot; + &quot;/script&quot;&gt;);
||&lt;

*1269425140*[メモ][Caty][msched]microformatsのデータをテーブルにすると

テーブル名は複数形にしようかと思ったが結局単数形。

- hCard -- person
- veventの最小部分 -- event
- eventのその他の部分 -- eventInfo
- addrとかgeoとか -- location

これに、人が行事（イベント）に参加したことを表現する attend（これだけ動詞、名詞はparticipationか）を入れると：

- person, event, attend, location, eventInfo

eventとeventInfoを別にするのはどうか？という話もあるが、eventには時空区間としての最小の情報がいいような気がする。

</body>
</day>
<day date="2010-03-29" title="">
<body>
*1269817216*[メモ][Caty](続)ウィジェットアプリケーションをページにロードする方法の分類

ローディング処理が行われる場所・タイミングによる分類：

| ＼             |*   サーバーサイド処理  |*  ブラウザサイド処理  |
|* 単一ドメイン  | ローカルSSI            | Ajax                  |
|* 複数ドメイン  | リモートSSI            | ODJS, iframe          |

ドメインの単一／複数は、アプリケーションの配備レイアウトがドメインで閉じているか跨っているかの違い。

共通して次のテンプレートが使える。
&gt;|html|
&lt;html&gt;
 &lt;head&gt;
  &lt;!-- ... --&gt;
  {include file=&quot;some/styles.tpl&quot;}
  &lt;!-- ... --&gt;
  {include file=&quot;some/scripts.tpl&quot;}
  &lt;!-- ... --&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;!-- ... --&gt;
  {include file=&quot;some/view.tpl&quot;}
  &lt;!-- ... --&gt;
 &lt;/body&gt;
&lt;/html&gt;
||&lt;

iframeを使うときは：
&gt;|html|
&lt;html&gt;
 &lt;head&gt;
  &lt;!-- ... --&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;!-- ... --&gt;
  {include file=&quot;some/ifview.tpl&quot;}
  &lt;!-- ... --&gt;
 &lt;/body&gt;
&lt;/html&gt;
||&lt;

フロント側の外部CSSスタイルシートURLs（ときに画像URLs）、外部カスタムスクリプトのURLsがあればページを生成できるだろう。これも分散配備レイアウトの情報。divとiframeでは大分様子が違う。しかし、SSIとCSI（client side include）ではあまり違わない。

ODI（On-Demand Include）とOII（On-Initial Include）という分類もあるな。

| ＼   |*  サーバーサイド処理  |*  ブラウザサイド処理  |
|* OII |   SSI                 | OIJS (OnInitial JS), iframe |
|* ODI |  -                    | Ajax, ODJS, OD-iframe      |


リモート・マイクロアプリケーション（ReMApp）として使えるのは：

+ リモートSSI (OIIに限定）
+ OIJS (OIIに限定）
+ ODJS（SSI, OIJSと組み合わせ可能）
+ iframe（SSI, OIJSと組み合わせ可能、OD-iframeも可能）

初期ビューのジェネレータとレスポンダはシッカリ区別しよう。処理の本質はレスポンダのロジックにある。レスポンダ設計の方法論もキッチリしないと、だな。

*1269817217*[メモ][Caty][msched]Common World Model

- 人、組織
- 場所、施設、建物
- 話題、分類カテゴリー
- タスク、行動
- 出来事、行事、事件
- 文書、画像

などを識別可能な属性付き実態として定義する。

実体間の関係は、別に関係要素実体として定義するが、関係要素実体には関与者を表現するデータを含む。また、関与者は、その関係要素に自分が関与していることを認識（把握）できなくてはならない。

このためには双方向リンクが必要。片方向（順方向）は自然に実現できるから、逆方向リンクをメンテナンスすることが問題。

- changed通知（関係要素の属性が変更された）
- invalidated通知（リンクが無効になった）
- removed通知（関係要素が削除された）

*1269822814*[メモ][Caty][JavaScript]なんか使える？

&gt;|html|
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv='Content-Type' content='text/html; charset=shift_jis'&gt;
    &lt;title&gt;ShowCatyScript&lt;/title&gt;
    &lt;script&gt;

function showCatyScript() {
 var caty = document.getElementById(&quot;caty&quot;);
 var text = caty.innerHTML;
 text = text.replace(&quot;&lt;?caty-scrit&quot;, &quot;&quot;);
 text = text.replace(&quot;?&gt;&quot;, &quot;&quot;);
 alert(text);
}
    &lt;/script&gt;
    &lt;style&gt;
      #caty {display: none}
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;textarea id=&quot;caty&quot;&gt;
      &lt;?caty-scrit
	 
	 {&quot;foo&quot;: 1, &quot;bar&quot;: &quot;hello&quot;}
	 
     ?&gt;
    &lt;/textarea&gt;

    &lt;button onclick=&quot;showCatyScript();&quot;&gt; Show Caty Script&lt;/button&gt;

&lt;/body&gt;
||&lt;

*1269822815*[メモ][Caty]クエリパラメータ

システムパラメータとアプリケーションパラメータに分けて、システムはアンダスコアで始まる。

- _verb -- 動詞
- _method -- HTTPメソッドの置き換え（非推奨）
- _lang -- 応答に使用する言語
- _fmt -- 応答に使用するフォーマット、ファイルタイプ（XML、JSON、HTML、PDFとか）
- _qsl -- クエリ文字列の長さ（確認よう）
- _md --  クエリ文字列のメッセージダイジェスト
- _apik -- APIキー

</body>
</day>
<day date="2010-03-30" title="">
<body>
*1269924191*[メモ][Caty][MicroApp]マイクロアップの概念

マイクロアップ（microapplications）に関して、2005年からの考え方の変化、今（2010年）の考え：

+ マイクロ文書（マイクロアップのビュー）は必ず1つの要素として埋め込まれるべき。
+ サーバーサイド部分をバックパートと呼ぶ。
+ フロントバートとバックパートの通信方式とデータ形式も規定すべき。
+ プレフェレンスとプレフェレンス・ストアの概念
+ マイクロアップのクラスとインタスタンスを区別する。
+ 名前空間の使用法を厳密に定義する。
+ ジェネレータとレスポンダ（リアクタ）という概念
+ マイクロセッション（マイクロアップが、そのバックパートと通信するときのセッションもどき）
+ クリーンHTMLとCSSデザインの考え方
+ バックステージという概念
+ データ型とマークアップの対応関係の厳密化
+ マークアップとセレクタの対応の厳密化
+ バックパートをリソースと考える事

*1269924192*[メモ][Caty][MicroApp]bodyにscript方式のバリエーション

ビューの生成をscriptタグで行うととき：

リモートソースだけを使う。
&gt;|html|
&lt;script src=&quot;javascriptURL&quot;&gt;&lt;/script&gt;
||&lt;

リモートソースに対して変数によりパラメータを渡す。
&gt;|html|
&lt;script&gt;
  var example_foo = 1;
  var example_bar = &quot;hello&quot;;
&lt;/script&gt;
&lt;script src=&quot;javascriptURL&quot;&gt;&lt;/script&gt;
||&lt;

リモートソースに対して動的なパラメータをクエリ文字列で渡す。
&gt;|html|
&lt;script&gt;
 var params;
 // paramsを作る
 var jsUrl = &quot;baseURL?&quot; + params;
 document.write('&lt;script src=&quot;' + jsUrl + '&quot;&gt;&lt;' + '/script&gt;');
||&lt;

次は、はてなスターの例。まずは読み込んでから設定。
&gt;|html|
&lt;script src=&quot;javascriptURL&quot;&gt;&lt;/script&gt; 
&lt;script&gt; 
Hatena.Star.EntryLoader.headerTagAndClassName = ['h3','entry-header'];
Hatena.Star.Token = 'xxxxxxxxxxxxxa125a8a7107c9yyyyyyyyyyyyy0ea8';
&lt;/script&gt; 
||&lt;

あとは、これらの適当な組み合わせ。

*1269930476*[メモ][Caty][MicroApp]マイクロアップの概念・用語、流儀・作法・掟

基本的に、マイクロアップを分散アプリケーションと考える。Web上に分散されたデータとコードからアプリケーションが構成されている。何をどう分散させるかが問題だ。実は普通のWebアプリケーションと変わらないし、変わるべきではない。

+ データリソース、データオブジェクト、リソースストレージ、データソース； まー、だいたい同じこと
+ リソース抽出器：URIに対応するデータリソースをリソースストレージ（データソース）から取り出す機能
+ データリソース内容の表現形式はJSON
+ 構造ビュー（structure view）＝クリーンHTML
+ クリーンHTML：装飾、デザインを含まない。純粋なセマンティック・マークアップされたHTML。
+ 構造ビュー生成器：JSONデータからクリーンHTMLを生成する、ほぼテンプレートエンジンのこと
+ サービスエンドポイント：今（マイクロアップ）のケースでは、リソース抽出器、構造ビュー生成器にアクセスするURLのこと。
+ 最終ビュー（final view）＝スタイルドビュー（styled view）：ページ閲覧者が目にするビュー
+ JSONベースRESTスタイルAPI：データ形式としてJSONを利用する
+ HTMLベースRESTスタイルAPI：データ形式としてクリーンHTMLを利用する
+ Microformats方式マークアップ：データリソースのJSON形式表現からクリーンHTMLを生成するときの流儀と作法。可逆性がキモ。
+ 生成リクエスト：マイクロアップのロードと初期化のときに使うリクエスト。ビュー生成用に、JSONまたはHTMLを要求する。
+ 対話リクエスト：マイクロアップが動作中に使うリクエスト。ほぼ非同期メソッドコール。
+ サブミットリクエスト：ページまたはマイクロアップが、終了して次のページに遷移するときに使うリクエスト
+ レスポンダ：マイクロアップからの対話リクエストに応えるサーバーサイドプログラム・モジュール。API実装プロバイダ。
+ マイクロアップの表示エリア：div, iframe, 別ウィンドウなど。
+ マイクロアップの寿命： 通常は、ページと同じか、ベージ寿命の一部分。長寿命マイクロアップはページをまたいで生きる。
+ ポーリング：天気予報、株価、チャットなどに使う。
+ ポーリングライブラリ：これはフィーチャとして必要だろう。
+ 通信ライブラリ：WCCのTranceiver.jsに相当。maTranceiver.jsとかを作るか。maTranceiver-ajax-0.1.js などが具体例。
+ フィーチャ確認コード：ビュー生成（ローダー）のJavaScriptコード内でフィーチャの存在は確認した方がいいかもしれない。
+ 分散配備：マイクロアップの素材を適切な場所に配備すること。
+ リロケーション：分散配備の配備レイアウトを変えること。
+ リロケーション対策：リロケーションの影響を最小化する方策
+ 通信方式：現状でサポートできるのは、ページ遷移、Ajax、ODJSの3種
+ マイクロセッション：マイクロアップとサーバーサイドプログラム（レスポンダ）の間のセッション概念。まだ未定。

流儀・作法・掟：

+ データリソース、コードリソースにはできるだけ細かくURLを割り当てる。
+ 拡張子は、.json, .html, .cgi（コードリソース）を使う。他に意味的な拡張子を使ってもよい。
+ データ表現は必ずJSONを使い、スキーマを書く。
+ データであるJSONに対して、表示の骨格を与えるクリーンHTMLを設計する。
+ クリーンHTMLはMicroformats方式でマークアップして、可逆変換（JSONへ戻し）ができるようにする。
+ JSON -&gt; HTML はテンプレートで定義する
+ HTML -&gt; JSON はCSSデータ抽出言語（別に記述）で定義する。
+ CSSデザインに必要な要素、ID、クラスを追加してもよい。CSSセレクタ仕様を明確化。
+ データオブジェクトに対する抽象メソッドを定義する。
+ 抽象メソッドはメイヤーのクエリー・コマンド方式にする。
+ 生成（コンストラクタ）と対話リクエスト（メソッド呼び出し）のプロトコルを設計する
+ プロトコルと状態遷移の関係を明らかにする。
+ 状態には、フロントパートの状態とバックパートの状態があるが、全状態（トータル状態）に注目する。
+ 全状態のフロント・バック分解は恣意的かもしれない。
+ そもそもフロント・バック境界が恣意的。
+ 分散配備レイアウト、通信方式は具体個別的だから、できるだけ切り離し、影響を受けないようにする。
+ マイクロアップのローディング方式はさらに具体個別的・物理的だから注意。

集中すべきことは：

+ データの単位的実体（unit entity）であるオブジェクトをJSONスキーマで定義する
+ データオブジェクトのコレクション編成方式を考える。
+ コレクション編成は、リスト、バッグ、セット、マトリックス、ツリー、グラフなどと、それらの組み合わせ。
+ コレクションもJSONスキーマで定義する。（できるはず！）
+ データオブジェクト（通常はJSONオブジェクト）に対するメソッドを考える。
+ コレクションに対するメソッドを考える（まずはCRUD）。
+ 以上の設計要素をまとめて内部的抽象インターフェースを確定する。
+ データオブジェクトとコレクションに対してMirocformtsマークアップ（テンプレート）を定義する。
+ 「JSON⇔HTML」可逆性を保証するために、CSSデータ抽出仕様を定義する。
+ CSSデータ抽出をもとにCSSセレクター仕様も書く。これがCSSデザイナとの合意事項になる。
+ 内部抽象インターフェースをURLにマップする。
+ URL群は外部インターフェース（公開API）となる。
+ 内部抽象インターフェースと外部インターフェースの差はできるだけ小さくする。
+ URLの拡張子は、.json, .html, .cgiとするが、.cgiをできるだけ使わないように心掛ける。
+ ODJSを使う場合は拡張子を、.json.js, .html.js とする。単なるコードライブラリは、副拡張子を使わない。

URLと拡張子の掟：

+ JSON（で表現した）データを .json とする。
+ クリーンHTMLフラグメント（で表現した）データを .html とする。
+ 同じベース名の .json と .html は等価でなくてはならない。
+ コード実行を提供するプロセッサ・リソースは .cgi とする。
+ プロセッサ実行結果がキャッシュ可能なら、.json, .html として提供する。
+ コレクショリソースに対するPUT, POST, GETはディレクトリURLを使う。
+ 動詞は _verbパラメータ。
+ JSONP, HTMLPのコールバック名は _cbパラメータ。
+ クエリ文字列の長さは _qsl パラメータ。壊れていると、BadRequestになるだろう。
+ チェックサム（ダイジェスト）を入れたい場合は、_csパラメータ。
+ APIキーを入れたい場合は、_apikパラメータ。これはPOSTでも使う。
+ JSONPを提供するURLは、foo.json.js?_cb=mycb
+ HTMLPを提供するURLは、foo.html.js?_cb=mycb
+ foo.html.jsの_cbパラメータが省略された場合は、HTML body内での展開をするようにする。
+ JSONデータ、またはHTMLデータを受け取ってビューの初期化をするJavaScriptメソッドの命名は、initViewとする。
+ foo.json.js, foo.html.js, foo.json.js?_cb=hoge.initView, foo.html.js?_cb=hoge.initView の結果は等価とする。
+ ただし、foo.html.js がinitViewを呼び出すわけではない。foo.json.js はデフォルトでグローバル関数 initViewを呼び出す。
+ 同一ページ内で複数のマイクロアップを共存させるために、名前空間の規則を守らなくてはならない。

キモと問題点：

- 一番大事なのは、データ構造（基本データオブジェクトとコレクション階層）に対するスキーマを定義して、内部的抽象インターフェースを策定すること。スキーマ言語はあるが、インターフェース定義言語（IDL)がないのが問題。当面はJavaで代用か？
- 内部抽象インターフェース（スキーマ定義を含む）があれば、URL設計の指針が得られる。
- JSONスキーマがあれば、クリーンHTML（＝構造ビュー）設計の指針が得られる。CSSデータ抽出定義で可逆性を保証できる。
- フロント・バック間通信のプロトコルとページ遷移に対する良い記述言語（図解法）がない。
- セッション、マイクロセッション、長寿命マイクロアップの概念が曖昧。
- ユーザーアカウントとマイクロアップの関係が曖昧

CSSデータ抽出：

+ cssdx.element(selector) -- 要素そのもの（1個）
+ cssdx.content(selector) -- 要素コンテントのデータ
+ cssdc.attrVal(selector, attrName) -- 属性値のデータ
+ cssdx.childElements(selector) -- 要素内容の子要素だけをリストにしたもの
+ cssdx.as(expr, typeName) -- exprの値をtypeName型とみなしたもの

単純JSONパスと組み合わせて、対応を完全に記述する。

*1269931363*[Caty]IDL for Web

Webサイトに関しては：

+ Webサイトの全体的URL構造を記述できる。
+ 各Webページ（タイプ）のデータ構造を記述できる。
+ Webサイト内のページ遷移を記述できる。

WebAPIに関しては：

+ WebAPIのインターフェースを記述できる。
+ WebAPIで使うデータ型を記述できる。
+ WebAPIのプロトコル（手順、インタラクション図）を記述できる。
+ WebAPIの状態遷移を記述できる。

</body>
</day>
<day date="2010-03-31" title="">
<body>
*1270002082*[メモ][雑感]ハイパーhogehoge、関連する概念・用語、ものすごく雑多

- ハイパーテキスト
- ハイパードキュメント
- ハイパーメディア

聞いたことあるな。

- ハイパーオブジェクト

なんとなく分かるような分からないような。

- ハイパークラス
- ハイパーインターフェース

これは新語かな。でも、ハイパークラスはなんかメタクラスと同義な感じもする。

データオブジェクト（データ転送オブジェクト；DTO）に比較して、より機能性を持つオブジェクトをなんと呼ぶか？ 機能オブジェクト、振る舞いオブジェクト、アクションオブジェクト、アクターオブジェクト、サービスオブジェクト、、、？？

プロパティ、クエリー、狭義メソッド（コマンド）って分類もある。プロパティ（抽象化されたフィールド）とクエリーは統合できるかも。狭義メソッドはアクションと呼ぶこともあるな。用語「アクターオブジェクト」は悪くないが、アクター理論とかぶる。やっぱサービスオブジェクトかぁ。

サービスの発見と選択と、サービスへのナビゲーションは関連する。「ハイパー」はナビゲーションを含む、というような意味でいいだろう。

メッセージドキュメントは次を含む：

+ なんらかの実行の結果（execution outcome）
+ 実行後＝現在の状態の表現
+ 現在の状態の文脈情報
+ この状態で実行が許されている操作（オペレーション）のセット
+ ナビゲーションリンク

「現在の状態の表現」と「現在の状態の文脈情報」は、状態空間の状態点の部分情報（＝射影した値）だ。何をもって「当該の状態」と「文脈」に分けるかは恣意的かも知れない。「ナビゲーションリンク」はオペレーションセットの一部と考えてもいいが、実行の結果がないことが特徴。んじゃ、（メイヤー）クエリーもナビゲーションリンクみたいなもんだが、あれは値を取り出す。ナビゲーションは、別なメッセージドキュメント（＝ハイパーオブジェクト）を出現させる。

となると、値とオブジェクトの違いって何だ？ってことになる。イミュータブルでアイデンティティを持たずビジブルなのが値で、そうでないのがオブジェクトか？ それとあと、さらにアトミックな値がスカラーってことだろう。

ようするに、システムってのは状態空間と状態遷移。状態点が複雑、状態空間が巨大、といった問題への対処として色々な方法論がある。状態の表現とは、状態点の部分情報の表現で、要するに座標値だ。点を特定できるだけの座標値のセットを揃えるのは難しい。だから、部分座標を使う。部分座標は点を特定しない、部分空間を指定するだけ。部分空間の広がりの分が、曖昧さや未知な情報として残る。

だから、経路とか履歴とか文脈とかが、曖昧さや未知情報を解決するヒントになる。

昔、状態遷移系のステージって概念を考えたことがある。ステージは状態空間の部分空間だが、その部分空間内の内部遷移と他のステージに飛ぶ遷移に分けて考えることができる。全状態空間における遷移の種類は膨大になるが、ステージ分割すれば、少数の内部遷移とステージ間遷移にモジュール化できるのではないか、と考えた。ステージごとに内部インターフェースと、ステージ間遷移インターフェースを持てる。これは、一枚岩インターフェースより扱いやすい。

このステージって概念は、メッセージドキュメントやWebページとけっこう近い概念だ。状態点、部分座標（表現）、ステージ（部分空間）、状態遷移とかをもう一度整理してみるべきだ。


</body>
</day>
<day date="2010-04-01" title="">
<body>
*1270108294*[メモ][雑感][Caty]ハイパーhogehoge、関連する概念・用語、ものすごく雑多 (2)

JSONスキーマのRFC候補にハイパースキーマって言葉が出てくる。なんかカッコツケスギ、ハイパーリンク・スキーマのほうがいいと思う。

- http://tools.ietf.org/html/draft-zyp-json-schema-01

RESTの本のなかで、接続性って言葉が出てくるが、これはハイパーリンク接続性がいいと思う。そのほうが分かりやすい。

情報担体（information bearing object）って言葉が気に入っている。例えば、http://d.hatena.ne.jp/m-hiyama/20050820/1124512522 。「体」がobjectの訳語だが、これは情報担体オブジェクトと言った方がいいだろ。データ転送オブジェクトとかデータアクセスオブジェクトと大差ない概念だが、「担っている」のだ。アクセスにも転送にも使える。

サービスリクエスタ、サービスリクエスタオブジェクトってのもいいと思う。サービス機能自体を運ぶのではなくて、サービスのインターフェースを運ぶのがサービスリクエスタオブジェクト。情報担体オブジェクト（データ転送オブジェクト）＋サービスリクエスタオブジェクトが分散アプリケーションの肝だ。

肝といえば、アプリケーション状態がクラアントにより保持されるっても肝だ。それで、アプリケーション状態の変更はサーバーが行う、ってのも変な話だが、そうなっている。そうなっているんだからしょうがない。

結局、転送されるオブジェクトの一般形は：

+ データプロパティ群（情報担体として）
+ ハイパーリンク群（関係記述として）
+ 問い合わせ群（副作用のないサービス要求）
+ アクション群（副作用のあるサービス要求）

と、これだけの構成要素。ハイパーリンクと問い合わせの違いは微妙で恣意的だが、それでも区別したほうがいいと思う。ハイパーリンク、問い合わせ、アクションは戻り値（応答）を持つが、それがまた転送オブジェクト（transfer object?）となる。転送オブジェクトを受信・受理すると、クライアント状態が変更されう。

リクエスト処理中にサーバー状態は変更され、レスポンス受理処理中にクライアント状態が変更される。よって、リクエスト＋レスポンスをトランザクションと考えると、トランザクション処理が双方の状態（直積空間）を変更する。

トランザクションとはいえ、サーバ側状態遷移の後でクライアント側状態遷移が起きるので、この時間順制約は外せない。

</body>
</day>
<day date="2010-04-02" title="">
<body>
*1270186949*[メモ][雑感][Caty]ハイパースキーマ

- http://json-schema.org/json-ref
- http://json-schema.org/interfaces

json-refは間違っているだろ。

*1270187497*[メモ][雑感][Caty]オリジン・リソースとその転送コピー

データの転送を伴うときは、転送元になったリソースと、転送により別な場所にコピーされたリソースが一致するのは一瞬で、全然同期が取れないかもしれない。しかし、まー、それはしょうがないのだ。同期がとれない離れた2つのモノとして取り扱うのが基本。でも、一応は関連している。可能なら同期しているとうれしい、というスタンス。


</body>
</day>
<day date="2010-04-05" title="">
<body>
*1270449920*[雑記][リンク]主にJSONスキーマ

JSONスキーマ関係
- http://tools.ietf.org/html/draft-zyp-json-schema-01
- http://json-schema.org/draft-hyperschema.txt
- http://www.sitepen.com/blog/2009/09/02/json-namespacing/ これはブログ
- http://json-schema.org/hyper-schema
- http://json-schema.org/json-ref 前も引用した実例
- http://json-schema.org/interfaces 前も頻用した実例

HTTPヘッダとか表示：
- http://web-sniffer.net/


</body>
</day>
<day date="2010-04-07" title="">
<body>
*1270600060*[Caty][メモ]ペイパル

小額決済はペイパルかな。

- ペイパル： http://www.paypal.jp/jp/ （http://www.paypal.jp/jp/cgi-bin/webscr?cmd=_home と展開される）
- 定期購読、定期支払いに関しては： https://www.paypal.com/jp/cgi-bin/webscr?cmd=p/xcl/rec/subscr-intro-outside

それにしても、URLが汚い。

https://developer.paypal.com/ にアクセスすると開発者アカウントが取れる。けど、通常アカウントと別なメールアドレスが必要。次のメールが来た。

&gt;&gt;
Hello Masayuki HIYAMA,

Congratulations!You've just created an account to enable Sandbox access.

But you're not finished yet.

To activate your account and confirm ownership of this email address, click the link below and re-enter your login information on the following page:

https&amp;#58;//developer.paypal.com/devscr?cmd=_signup-el&amp;xxxxxxxxxxxxxx


Remember to confirm your email address today, so you can start using your new account.


Sincerely,
PayPal
&lt;&lt;

*1270610515*[メモ][JSON]ハイパースキーマ

[JSON]タグを追加。

ハイパースキーマ仕様はしょうもないなー。なんかミソもクソも一緒。

評価できるポイントを挙げれば：

+ URI Templates仕様によりURI設計を記述する方向はいいと思う。
+ URI Templateのコンテキストオブジェクト自身を {-this} と書くのはまーいいか。
+ となると、ハイフンで始まる名前は特殊扱いだな。
+ HTMLフォーム機能を入れようとしている。

ダメなのは：

+ URI Templatesのプレースホルダー内の式言語が定義されてない。
+ 型システムを使うべき部分とアノテーションが区別されてない。
+ ともかくアドホック過ぎる。

「self（自分）が、http://example.jp/people/{name}.json だ」とかの記述は型システムとは無関係。hrefの指す対象の型とかは明らかに型システム。だが、relは微妙だ。型システムに入れてもいいような気がする。

フォームのデータ型はたぶん次のようだろう。

&lt;pre class=&quot;code&quot;&gt;
type Person = {
 &quot;fn&quot; : string,
 &quot;email : [string, string*],
 * : any?
};

type PersonParam = Person &amp; {
  &quot;fn&quot; : string refers &quot;{fn}&quot;,
  &quot;email&quot; : string refers &quot;{email}&quot;,
  * : any?
};
&lt;/pre&gt;

PersonとPersonParamは型としては同じだが、refersが付いた分だけ違う。これはアノテーションかもしれない。

&lt;pre class=&quot;code&quot;&gt;
type PersonParam = {
  &quot;fn&quot; : @[refers(&quot;{fn}&quot;)] string ,
  &quot;email&quot; : @[refers(&quot;{email}&quot;) string,
  * : any?
};
&lt;/pre&gt;

プロパティへの修飾は、キーワード構文を使うかアノテーションを使うか微妙。

*1270628905*[メモ][JSON]ハイパースキーマ 続

というわけで、JSONハイパースキーマの気持ちつうか動機つうか、を尊重しながら、全面的に改変することにする。

URIテンプレートはたぶん使う。

- http://bitworking.org/projects/URI-Templates/
- http://bitworking.org/projects/URI-Templates/spec/draft-gregorio-uritemplate-03.html

*1270629214*[メモ][caty-depl][リンク]Putty

パティとCVSに関して：

- http://rumble-jp.sourceforge.jp/putty-howto/putty-doc.html

CVSじゃなくても同じだろう。

</body>
</day>
<day date="2010-04-10" title="">
<body>
*1270889739*[メモ][Caty]名前ってなんだよーーー

正規表現の解説ならなんでもいいが：

- \w -- 英数字。[0-9A-Za-z_] と同じ。多バイト文字に対応した正規表現では、日本語のいわゆる全角文字（ひらがな・カタカナ・漢字・全角記号）にもマッチします。
- \W -- 非英数字。\w 以外の一文字。
- \s -- 空白文字。[ \t\n\r\f] と同じ
- \S -- 非空白文字。[ \t\n\r\f] 以外の一文字。
- \d -- 数字。[0-9] と同じ。こちらはいわゆる全角文字には決してマッチしません。
- \D -- 非数字

\w（たぶんwordのw）って英数字にアンダスコアが入るんだ。非アスキー文字を入れちゃうのもまーいいか。

問題はハイフンマイナスなんだよなー。これを名前文字に入れるかが大問題。

- 名前先頭文字は、英字またはアンダスコアまたは非アスキー文字。数字とハイフンはダメ。
- 名前文字は、英字数字またはアンダスコアまたは非アスキー文字またはハイフン。

ってのが暫定案だが、非アスキーにも空白や記号はいくらでもあるし。あああああー、やだやだ。

&lt;b&gt;[追記]&lt;/b&gt;

/([_a-zA-Z]|[^\u007f])([-_a-zA-Z0-9]|[^\u007f])*/ を名前ってことにするか。きたねーーー。

&lt;pre class=&quot;code&quot;&gt;
pattern WellName = /([_a-zA-Z]|[^\u007f])([-_a-zA-Z0-9]|[^\u007f])*/;

type wellnamedObject = {
  WellName : any?
};
&lt;/pre&gt;

*1270889740*[メモ][JSON]URI template

URI templateについては、REST本P.299にもあった。 9.3.1節。


*1270860783*[メモ][Caty][MicroApp]拡張子のネーミング

[http://d.hatena.ne.jp/m-hiyama-memo/20100330/1269930476:title] の拡張子ネーミング規則を変更する。

+ JSON（で表現した）データを .json とする。
+ クリーンHTMLフラグメント（で表現した）データを .htm, または .hfrag とする。
+ 完全なHTML文書は、.html とする。
+ 同じベース名の .json と .hfrag, .html は等価でなくてはならない。
+ コード実行を提供するプロセッサ・リソースは .cgi とする。
+ プロセッサ実行結果がキャッシュ可能なら、.json, .hfrag, .html として提供する。
+ コレクショリソースに対するPUT, POST, GETはディレクトリURLを使う。
+ 動詞は _verbパラメータ。主にPOSTの細分に使う。
+ JSONP, HTMLPのコールバック名は _cbパラメータ。
+ クエリ文字列の長さは _qsl パラメータ。壊れていると、BadRequestになるだろう。
+ メッセージダイジェストを入れたい場合は、_mdパラメータ。
+ APIキーを入れたい場合は、_apikパラメータ。これはPOSTでも使う。
+ JSONPを提供するURLは、foo.json.js?_cb=mycb
+ HTMLPを提供するURLは、foo.html.js?_cb=mycb, foo.hfrag.js?_cb=mycb
+ foo.html.jsの_cbパラメータが省略された場合は、HTML body内での展開をするようにする。document.write(...)
+ JSONデータ、またはHTMLデータを受け取ってビューの初期化をするJavaScriptメソッドの命名は、initViewとする。
+ foo.json.js, foo.hfrag.js の結果、foo.json.js?_cb=hoge.initView, foo.hfrag.js?_cb=hoge.initView の結果はそれぞれ等価とする。
+ ただし、foo.hfrag.js がinitViewを呼び出すわけではない。foo.json.js はデフォルトでグローバル関数 initViewを呼び出す。
+ 同一ページ内で複数のマイクロアップを共存させるために、名前空間の規則を守らなくてはならない。

+ foo.hfrag はHTMLフラグメント
+ foo.json はJSONデータ
+ foo.hfrag.js は document.write() で foo.hfrag を書き出す。
+ foo.json.js は initView()にfoo.jsonが渡される。
+ foo.hfrag.js?_cb=bar.initView は bar.initViewにfoo.hfragのテキストが渡される。
+ foo.json.js?_cb=bar.initView は  bar.initView()にfoo.jsonが渡される。

予定では次のように書けるはず。JSONデータさえ置いておけばよい。

&lt;pre class=&quot;code&quot;&gt;
// ファイルフルパスを分解、加工する
doset {
 ecoh %0 | fname:ext &gt;: &quot;ext&quot;,
 echo %0 | fname:subext &gt;: &quot;subext&quot;,
 echo %0 | fname:replace-ext .json &gt;: &quot;jsonData&quot;,
};
// テンプレートファイル名を作る
doset {
 [&quot;tpl&quot;, echo %%subext, echo %%ext] | text:join &gt;: &quot;templateFile&quot;
};
// 実行
expand --resolve %%jsonData | print --place=include %%templateFile

&lt;/pre&gt;

*1270874823*[メモ]CSS layout-grid

なんて変なプロパティがあったのね。

</body>
</day>
<day date="2010-04-13" title="">
<body>
*1271126410*[メモ][caty-depl]機械とOSを変えてもダメって？

繋がらなくなったのは、この日からだろう。

- http://d.hatena.ne.jp/m-hiyama-memo/20100318/1268880557

&lt;pre class=&quot;out&quot;&gt;
C:\Users\hiyama&gt;python -V
Python 2.6.5

C:\Users\hiyama&gt;hg --version
Mercurial Distributed SCM (version 1.4.3+20100201)

Copyright (C) 2005-2010 Matt Mackall &lt;mpm@selenic.com&gt; and others
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

C:\Users\hiyama&gt;hg -v clone http://bitbucket.org/m_hiyama/catydocs/
destination directory: catydocs

&lt;/pre&gt;

あとはうんともすんとも言わない。

ほんとに身動き取れない。

*1271148591*[paypal]開発アカウント

Test Accountsの
- Create a preconfigured buyer or seller account.
を選んでみた。

ダミーbuyerアカウントを作る。国名で日本がない。サンドボックス内だから、taro, 12345678 と hiyama, 87654321 とか。


&lt;pre&gt;
Country:	 	 United States
Business Name:	 	 None
Credit Card:	 	 Visa	   4501133963324673	
Exp Date:  4/2015	
Bank Account:	 	 Checking (Confirmed) 
Routing Number: 325272063	
Bank Account Number: 381563555210544
Balance:	 	100.00 USD
Email:	 	Confirmed


Country:	 	 United States
Business Name:	 	 Masayuki HIYAMA's Test Store
Credit Card:	 	 Visa	   4433935466861040	
Exp Date:  4/2015	
Bank Account:	 	 Checking (Confirmed) 
Routing Number: 325272063	
Bank Account Number: 602723228423105
Balance:	 	500.00 USD
Email:	 	Confirmed


Test Account:	hiyama_1270907313_biz@hotmail.com
API Username:	hiyama_1270907313_biz_api1.hotmail.com
API Password:	1270907319
Signature:	 AFcWxV21C7fd0v3bYYYRCpSSRl31A75DDOqYXQSUYUTUIfa9j3A1HnLJ
&lt;/pre&gt;


*1271148592*[メモ]コミュワールドの仮想ホスト

ドメイン一覧は http://d.hatena.ne.jp/m-hiyama-memo/20100201/1264982931 にある。

- riso.commuworld.org を追加。

+ コンピューティングの科学
+ プログラミングとプログラミング言語
+ ソフトウェア工学
+ 数学
+ 応用数学
+ 物理
+ 科学論
+ 理系の教養
+ サイエンスフィクション

誰かに書いて欲しいネタ：

- ガウス／ボンネの定理の周辺
- ベクトル解析からストークスの定理まで
- 量子情報学・入門

*1271148634*[Caty]XJX（エックスジェイエックス）

XJSON-encoded XML のことだ。XJS⊆XJSON はプロパーな包含になる。ただし、XMLの有象無象の情報はすべて切り捨てる。

スッキリしていて、けっこういいな、これは。

</body>
</day>
<day date="2010-04-14" title="">
<body>
*1271209582*[メモ][docu] TeXのインストール

あべ・のりゆきさん（http://www.ms.u-tokyo.ac.jp/~abenori/index.html）の kakuto3.exe を使ってTeXのインストールをした。
楽は楽だが、アーカイブだけで51ファイルもダウンロードする。そもそもこの状況が、なんかおかしいのではないか？

*1271214204*[メモ][docu] TeX、LyXのインストール （途中まで）

- http://www.ms.u-tokyo.ac.jp/~abenori/mycreate/ の TeXインストーラ3

これを実行した結果、次のディレクトリができる。

- \Installed\Ghostgum\
- \Installed\Ghostgum\gsview\
- \Installed\Ghostgum\pstotext\
- \Installed\gs\
- \Installed\tex\
- \Installed\tex\bin\
- \Installed\tex\dviout\
- \Installed\tex\share\

次のサイトに色々ある。

- http://www.int.otaru-uc.ac.jp/lyx-howto/

このサイトからGS用フォントをダウンロード：

- http://www.int.otaru-uc.ac.jp/lyx-howto/install/win/gs/ ここから、gs-urw-fonts-1.0.7pre22.zip をダウンロード

展開結果のなかにある fonts\ を、\Installed\gs\gs8.71\ の下に展開する。

次は、適切なディレクトリを作って、kanji.mapを作成。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed&gt;cd tex

C:\Installed\tex&gt;dir
 ドライブ C のボリューム ラベルは Windows7_OS です
 ボリューム シリアル番号は AE11-25C2 です

 C:\Installed\tex のディレクトリ

2010/04/12  18:20    &amp;lt;DIR&gt;          .
2010/04/12  18:20    &amp;lt;DIR&gt;          ..
2010/04/12  18:16    &amp;lt;DIR&gt;          bin
2010/04/12  18:20    &amp;lt;DIR&gt;          dviout
2010/04/12  18:15    &amp;lt;DIR&gt;          share
               0 個のファイル                   0 バイト
               5 個のディレクトリ  210,921,934,848 バイトの空き領域

C:\Installed\tex&gt;mkdir sharetexmf\fonts\map\dvips\base

C:\Installed\tex&gt;dir
 ドライブ C のボリューム ラベルは Windows7_OS です
 ボリューム シリアル番号は AE11-25C2 です

 C:\Installed\tex のディレクトリ

2010/04/14  11:40    &amp;lt;DIR&gt;          .
2010/04/14  11:40    &amp;lt;DIR&gt;          ..
2010/04/12  18:16    &amp;lt;DIR&gt;          bin
2010/04/12  18:20    &amp;lt;DIR&gt;          dviout
2010/04/12  18:15    &amp;lt;DIR&gt;          share
2010/04/14  11:40    &amp;lt;DIR&gt;          sharetexmf
               0 個のファイル                   0 バイト
               6 個のディレクトリ  210,921,934,848 バイトの空き領域

C:\Installed\tex&gt;
&lt;/pre&gt;

kanji.mapは http://wiki.lyx.org/Windows/Japanese にあった。

&lt;pre class=&quot;code&quot;&gt;
% Japanese
rml         Ryumin-Light--H
rmlv        Ryumin-Light--V
gbm         GothicBBB-Medium-H
gbmv        GothicBBB-Medium-V

nrml        Ryumin-Light-H
ngbm        GothicBBB-Medium-H

% Morisawa
ryumin-l    Ryumin-Light-H
ryumin-l-v  Ryumin-Light-V
gtbbb-m     GothicBBB-Medium-H
gtbbb-m-v   GothicBBB-Medium-V
futomin-b   FutoMinA101-Bold-H
futomin-b-v FutoMinA101-Bold-V
futogo-b    FutoGoB101-Bold-H
futogo-b-v  FutoGoB101-Bold-V
jun101-l    Jun101-Light-H
jun101-l-v  Jun101-Light-V

MJKanji     KozMinStd-Bold-90pv-H
MJKanji-v   KozMinStd-Bold-90pv-V
MJKata-h    MojikumiKata-EB-90pv-H
MJKata-v    MojikumiKata-EB-90pv-V
&lt;/pre&gt;

フルパスは、C:\Installed\tex\sharetexmf\fonts\map\dvips\base\kanji.map。

updmap を実行すると：

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex&gt;updmap -add kanji.map
I don't add kanji.map to the configuration file, because I cannot find it.
Working with cm.map ...
Working with cmextra.map ...
Working with cyrillic.map ...
Working with euler.map ...
Working with latxfont.map ...
Working with symbols.map ...
Working with bakoma-part.map ...
Working with lm.map ...
Working with fpls.map ...
I updated dvipsfnt.map.
I updated pdftex.map.
I updated pdfmfnt.map.
I updated pspksupp.map.
I updated mpost.map.

C:\Installed\tex&gt;
&lt;/pre&gt;

ありゃ、ダメだ。mktexlsrも残っているのに。

とりあえず中断。後で調査。

*1271217579*[メモ][docu] TeX、LyXのインストール （完了）

場所が、C:\Installed\tex\sharetexmf\fonts\map\dvips\base\kanji.mapじゃなくて、c:\Installed\tex\share\texmf\fonts\map\dvips\base\kanji.map のような気がする。やってみたが、改善しない。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex&gt;updmap -add kanji.map
I don't add kanji.map to the configuration file, because I cannot find it.
Working with cm.map ...
Working with cmextra.map ...
Working with cyrillic.map ...
Working with euler.map ...
Working with latxfont.map ...
Working with symbols.map ...
Working with bakoma-part.map ...
Working with lm.map ...
Working with fpls.map ...
I updated dvipsfnt.map.
I updated pdftex.map.
I updated pdfmfnt.map.
I updated pspksupp.map.
I updated mpost.map.
&lt;/pre&gt;

試しに、c:\Installed\tex\share\texmf\fonts\map\dvips\updmap\kanji.map を作ってみた。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex&gt;dir /s/b kanji.map
C:\Installed\tex\share\texmf\fonts\map\dvips\base\kanji.map
C:\Installed\tex\share\texmf\fonts\map\dvips\updmap\kanji.map
C:\Installed\tex\sharetexmf\fonts\map\dvips\base\kanji.map

C:\Installed\tex&gt;dir /s/b mpost.map
C:\Installed\tex\share\texmf\fonts\map\dvips\updmap\mpost.map
&lt;/pre&gt;

これでもダメだ。

http://glc.l.u-tokyo.ac.jp/pukiwiki/index.php?TeX/Font/MapFile にヒントがあった。

&gt;&gt;
まず、必要な .map ファイルをしかるべき場所に置いた後、mktexlsr を実行して .map ファイルがある場所を教えます。そのあとで updmap-sys コマンドを実行して .map ファイルを登録します。
&lt;&lt;

しかるべき場所がわからん！ 適当な推量で：

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex&gt;dir /s/b kanji.map
C:\Installed\tex\share\texmf\fonts\map\dvips\base\kanji.map
C:\Installed\tex\sharetexmf\fonts\map\dvips\base\kanji.map

C:\Installed\tex&gt;mktexlsr
mktexlsr: Updating C:/Installed/tex/share/texmf-local/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf-local/ls-R.
mktexlsr: Updating C:/Installed/tex/share/texmf/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf/ls-R.
mktexlsr: Done.

C:\Installed\tex&gt;updmap -add kanji.map
I added kanji.map to the configuration file
Working with cm.map ...
Working with cmextra.map ...
Working with cyrillic.map ...
Working with euler.map ...
Working with latxfont.map ...
Working with symbols.map ...
Working with bakoma-part.map ...
Working with lm.map ...
Working with fpls.map ...
Working with kanji.map ...
I updated dvipsfnt.map.
I updated pdftex.map.
I updated pdfmfnt.map.
I updated pspksupp.map.
I updated mpost.map.

C:\Installed\tex&gt;
&lt;/pre&gt;

ふー、できたようだ。

次は、日本語対応バベルの導入。

- http://www.int.otaru-uc.ac.jp/lyx-howto/install/win/babel からbabel-japanese.zipをダウンロード

これを、C:\Installed\tex\babel-japanese\に展開。次を実行。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex\babel-japanese\japanese&gt;dir /b
INSTALL.BAT
japanese.ldf
japanese.zip
README
sample.dvi
sample.pdf
sample.tex

C:\Installed\tex\babel-japanese\japanese&gt;INSTALL.BAT C:\Installed\tex
Babel japanese オプションのインストールを開始します。
サブディレクトリまたはファイル C:\Installed\tex\share\texmf\tex\generic\babel は
既に存在します。
japanese.ldf を C:\Installed\tex\share\texmf\tex\generic\babel にコピーします。
        1 個のファイルをコピーしました。
README を C:\Installed\tex\share\texmf\doc\ptex\babel\japanese にコピーします。
        1 個のファイルをコピーしました。
sample.tex を C:\Installed\tex\share\texmf\doc\ptex\babel\japanese にコピーしま
す。
        1 個のファイルをコピーしました。
sample.dvi を C:\Installed\tex\share\texmf\doc\ptex\babel\japanese にコピーしま
す。
        1 個のファイルをコピーしました。
sample.pdf を C:\Installed\tex\share\texmf\doc\ptex\babel\japanese にコピーしま
す。
        1 個のファイルをコピーしました。
mktexlsr を実行します。
mktexlsr: Updating C:/Installed/tex/share/texmf-local/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf-local/ls-R.
mktexlsr: Updating C:/Installed/tex/share/texmf/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf/ls-R.
mktexlsr: Done.

C:\Installed\tex\babel-japanese\japanese&gt;
&lt;/pre&gt;

やっとLyXだ。

- http://www.lyx.org/WebJa.Download
- http://wiki.lyx.org/Windows/Windows

本家サイトが落ちているので、次にアクセス。

- ftp://ftp.u-aizu.ac.jp/pub/tex/lyx/bin/1.6.5

LyX-165-4-22-AltInstaller-Small.exe をダウンロード。

実行。悩むのは一箇所だけ、latex.exeへのパスだが、僕の場合は：

- C:\Installed\tex\bin と設定。

スペルチェッカー用の追加辞書は次からダウンロードするようだ。

- http://developer.berlios.de/project/showfiles.php?group_id=5117&amp;release_id=12973

ああー、長い道のりだった。

</body>
</day>
<day date="2010-04-15" title="">
<body>
*1271295035*[メモ][docu] LyXの使用開始

パス名はWindows方式とUnix方式が混じるけど、Windowsでの話。

起動しても、なにやらかにやらの設定がある。

- c:/Installed/LyX 1.6.5/Resources/ui/stdtoolbars.inc を編集して、PDFの設定を変更する必要がある。
- c:/Installed/LyX 1.6.5/Resources/bind/ にキーバインドがある。emacs.bindがいいだろう。

どうも困難が予想されるなーー。

が、これを使うことにしよう。

*1271295036*[メモ][docu] LyXの使用

HTML to LaTex が必要です。って、なんでや？

-  http://htmltolatex.sourceforge.net/

listings.sty が必要だというので、

- http://tug.ctan.org/tex-archive/macros/latex/contrib/listings/

ここからZIPをダウンロード。そしたら、Makefileで作れと。ハァー？

これは普通の人に使えるわけねーな。みんなが普通に使えるようになるのに、あと10年くらいはかかる。

*1271306190*[メモ][docu] LyX listing.sty

CTANから取ってきたlistings.zipを展開。makeをする。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex\packages\listings\listings&gt;dir /b *.sty
listings.sty
lstdoc.sty
lstlang1.sty
lstlang2.sty
lstlang3.sty
lstmisc.sty

C:\Installed\tex\packages\listings\listings&gt;
&lt;/pre&gt;

できた。だけど、どうすりゃいいの？

*1271307168*[メモ][docu] LyX 

ウーム、TeX/LaTeXの知識は不要とかは嘘八百だな。

LaTeXのスタイルは、$TEX_HOME/share/texmf-local/tex/latex/ にインストールするらしいが、c:/Installed/tex/share/texmf-local/ の下ってことになるか。  c:/Installed/tex/share/texmf-local/tex/latex/を作った。その下に listings/ を配置。

&lt;pre class=&quot;out&quot;&gt;
C:\Installed\tex\share&gt;mktexlsr
mktexlsr: Updating C:/Installed/tex/share/texmf-local/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf-local/ls-R.
mktexlsr: Updating C:/Installed/tex/share/texmf/ls-R...
mktexlsr: Updated C:/Installed/tex/share/texmf/ls-R.
mktexlsr: Done.

C:\Installed\tex\share&gt;
&lt;/pre&gt;

これで、TeXレベルでは再認識できた。

LyXで、[ツール - 再初期設定]。それから終了して再起動。

これでやっとlistings.styが使える、、、、いやダメだ。日本語が使えない。まったくショーモナイ。

*1271316505*[メモ][docu] さらにLyX listings日本語問題の顛末

listingsで日本語を使えない時はjlistingを併用？

&lt;pre class=&quot;code&quot;&gt;
\documentclass{jbook}
\usepackage{color}
\usepackage{listings,jlisting}

\lstset{% 
language={C++}, 
backgroundcolor={\color[gray]{.85}},% 
basicstyle={\small},% 
identifierstyle={\small},% 
commentstyle={\small\ttfamily \color[rgb]{0,0.5,0}},% 
keywordstyle={\small\bfseries \color[rgb]{0,0,1}},% 
ndkeywordstyle={\small},% 
stringstyle={\small\ttfamily}, 
frame={tb}, 
breaklines=true, 
columns=[l]{fullflexible},% 
numbers=left,% 
xrightmargin=0zw,% 
xleftmargin=3zw,% 
numberstyle={\scriptsize},% 
stepnumber=1, 
numbersep=1zw,% 
morecomment=[l]{//}% 
} 

\begin{document}

\begin{lstlisting}[caption={\texttt{C}言語},label={numbers}]
int main()  /* C言語プログラムはmain関数から始まる */
{
       return 0;  /* main関数を終了させる */
// コメント
// //という形のコメントが存在しています。
}
\end{lstlisting}

\begin{lstlisting}[caption={\texttt{C}言語},label={numbers2}]
int main()  /* C言語プログラムはmain関数から始まる */
{
       return 0;  /* main関数を終了させる */
// コメント
//という形のコメントが存在しています。
}
\end{lstlisting}

\verb+//+の後に半角空白必要。

\end{document}

&lt;/pre&gt;

ふーん。次が参考になる。

- http://www.biwako.shiga-u.ac.jp/sensei/kumazawa/tex/listings.html
- http://mytexpert.sourceforge.jp/index.php?Listings#i1f895a0
- http://oku.edu.mie-u.ac.jp/~okumura/texwiki/?TeX%E5%85%A5%E9%96%80/%E5%90%84%E7%A8%AE%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E5%88%A9%E7%94%A8
- http://www.akita-nct.ac.jp/yamamoto/comp/latex/make_doc/source/source.html

TeX/LaTeXの一般論として、パッケージをインストールして、\usepackage{NAME} を使うらしい。

例：
&lt;pre class=&quot;code&quot;&gt;
\documentclass{jarticle}
\usepackage{multicol}

\begin{document}
% ...
&lt;/pre&gt;

listings/ と同じ位置に jlistings.sty を置いて mktexlsrを実行。またLyXを再初期化して再起動。

LyXの[文書 - 設定]のLaTeXプリアンブルでパッケージ指定をしてみる。

&lt;pre class=&quot;code&quot;&gt;
\usepackage{jlistings}
&lt;/pre&gt;

&lt;pre class=&quot;out&quot;&gt;
LaTeX Error: File `jlistings.sty' not found.
&lt;/pre&gt;

ダメだー。いや、綴り字の間違いだった。's'が付かない。

&lt;pre class=&quot;code&quot;&gt;
\usepackage{jlisting}
&lt;/pre&gt;

しかし、LyXが日本語を削り落としてしますのでダメ。ムー。

今のところ、ソースリストは生のLaTeXコードとして書くしか方法がない。ひどい、ひど過ぎる！！

LyXを絶賛している人もけっこういるが、ほんとに使っているんだろうか？印象で言ってるんじゃないの。


</body>
</day>
<day date="2010-04-16" title="">
<body>
*1271375012*[docu]LyXの操作性

- レイアウト設定が画面のことか最終出力のことかがわかりにくい。
- 日本語の扱いが色々と、、、
- 組版が基本的に欧文組版だし
- TeXコードを生で入れると、HTMLにはできない。
- が、このへんのカスタマイズはわからんし。

*1271375013*[docu]LyXの論理マークアップ

LyXとかTeXとかのネタは[docu]というタグにする。

- http://www.mail-archive.com/lyx-users@lists.lyx.org/info.html

で探すとけっこう対処があるかも。

［文書 設定］でモジュールを追加できる。論理マークアップを追加した。その後どうしていいかわからんかったが、［編集 文字様式］にメニューが追加される。

*1271379718*[docu]LyXサーバー

LyXにサーバーモードがあることを発見。僕の目的で一番使えるのはコレかもな。対話的に使うには辛いから。

が、Windows上ではLyXサーバーが使えない。通信方式は2本のnamed pipesを使う。プロトコルはテキストベースで非常に単純。クライアントを書くのはそれほど難しくないだろう。ただし、LyXの内部的な機能に関する深い理解が必要な点では難しい。

*1271383876*[docu] LyXのヘルプ文書をHTML表示

[ツール 設定]の下のHTMLからLaTeX変換子を次にようにした。

- java -jar c:/Installed/htmltolatex-1.0-all/htmltolatex.jar

これでヘルプ文書をHTML表示ができるようになった。しかし、DVIやPDFへの変換の時は相変わらずエラーが出る。エラーログがないので、追跡ができない。エラーログを書かせる方法があるはず。

</body>
</day>
<day date="2010-04-20" title="">
<body>
*1271733633*[docu] LaTeXパッケージ

どっかから持ってきたら、.insファイルをlatexする。次に、.dtxをlatexする。

出来上がりをインストールするんだが、それがよくわからん。


</body>
</day>
<day date="2010-04-22" title="">
<body>
*1271914105*[docu] TEXMFツリー

texのスタイルとかをインストーリするファイルシステムツリーをTEXMFツリーと呼ぶらしい。

&gt;&gt;
$TEXMF (= {$TEXMFLOCAL,$TEXMFMAIN,$TEXMFDIST}) は，/usr/local/teTeX/share/{texmf-dist,texmf-local,texmf} (ptetex3) だったり /usr/share/{texmf-dist,texmf-local,texmf} (ptetex3 in Vine Linux) だったり /usr/local/share/{texmf-local,texmf} (W32TeX) だったり。
&lt;&lt;

TEXMFツリー（の集まり）がどう構成されるかは、c:/Installed/tex/share/texmf/web2c/texmf.cnf  に書いてあった。

&lt;pre&gt;
%  Part 1: Search paths and directories.

% You can set an environment variable to override TEXMF if you're testing
% a new TeX tree, without changing anything else.
% 
% You may wish to use one of the $SELFAUTO... variables here so TeX will
% find where to look dynamically.  See the manual and the definition
% below of TEXMFCNF.

% The main tree, which must be mentioned in $TEXMF, below:
TEXMFMAIN = $SELFAUTODIR/share/texmf

% A place for local additions to a &quot;standard&quot; texmf tree.  For example:
TEXMFLOCAL = $SELFAUTODIR/share/texmf-local

% The main distribution tree:
TEXMFDIST = $SELFAUTODIR/share/texmf-dist

% Var tree:
% TEXMFVAR = $SELFAUTODIR/share/texmf-var

% User texmf trees can be catered for like this...
TEXMFHOME = ~/texmf

% Now, list all the texmf trees. If you have multiple trees you can
% use shell brace notation, like this:
% TEXMF = {$TEXMFLOCAL,$TEXMFMAIN,$TEXMFDIST}
% The braces are necessary.  If you set TEXFMVAR and/or TEXMFHOME, you can also
% list $TEXFMVAR and/or $TEXMFHOME in the TEXMF definition.
%

%
% If we use TEXMFVAR
%
% TEXMF = {$TEXMFVAR,$TEXMFLOCAL,$TEXMFMAIN}
%
TEXMF = {$TEXMFHOME,$TEXMFLOCAL,$TEXMFMAIN}

% Where to look for ls-R files.  There need not be an ls-R in the
% directories in this path, but if there is one, Kpathsea will use it.
% By default, this is only the !! elements of TEXMF, so that mktexlsr
% does not create ls-R files in the non-!! elements -- because if an
% ls-R is present, it will be used, and the disk will not be searched.
% This is arguably a bug in kpathsea.
TEXMFDBS = {$TEXMFLOCAL,$TEXMFMAIN};$MAKETEXPK_TOP_DIR

% The system trees.  These are the trees that are shared by all the users.
SYSTEXMF = $TEXMF

% Where generated fonts may be written.  This tree is used when the sources
% were found in a system tree and either that tree wasn't writable, or the
% varfonts feature was enabled in MT_FEATURES in mktex.cnf.
VARTEXFONTS = c:/var/tex/fonts

% It may be convenient to define TEXMF like this:
%   TEXMF = {$TEXMFHOME,!!$TEXMFLOCAL,!!$TEXMFMAIN,$HOME}
% which allows users to set up entire texmf trees, and tells TeX to
% look in places like ~/tex and ~/bibtex.  If you do this, define TEXMFDBS
% like this:
%   TEXMFDBS = $TEXMFHOME;$TEXMFLOCAL;$TEXMFMAIN;$VARTEXFONTS
% or mktexlsr will generate an ls-R file for $HOME when called, which is
% rarely desirable.  If you do this you'll want to define SYSTEXMF like
% this:
%   SYSTEXMF = $TEXMFLOCAL;$TEXMFMAIN
% so that fonts from a user's tree won't escape into the global trees.
%
% On some systems, there will be a system tree which contains all the font
% files that may be created as well as the formats.  For example
%   TEXFMVAR = /var/lib/texmf
% is used on many Linux systems.  In this case, set VARTEXFONTS like this
%   VARTEXFONTS = $TEXFMVAR/fonts
% and do not mention it in TEXMFDBS (but _do_ mention TEXFMVAR).

%
% ConTeXt
%
TEXMFCACHE = $SELFAUTODIR/share/ctxdir
&lt;/pre&gt;

七メンドクセー。

</body>
</day>
<day date="2010-04-26" title="">
<body>
*1272237334*[メモ][後で消す]4月30日

金曜日に電話があるので、待ってなくてはならない。
朝10時から午後5時のあいだ。時間指定はできない。ゲ。

これは終わり。5月8日の午後1時から午後5時のあいだに待っていなくてはならない。

0120-500-171

*1272238234*[caty-depl]またドメイン追加とDNS変更

何度やってもサクラのメニュー操作はわかりにくい！

https://secure.sakura.ad.jp/menu/top/ メニュートップから、「契約情報 ＞ ドメインメニュー」。脇にある「ネームサーバ新規登録」をクリック。そこで新ドメイン名を入力。

&lt;pre&gt;
ゾーン追加の申請を受付致しました
弊社にて確認の上、問題が無ければ登録作業に移らせて頂きます。
なお、登録作業については、数営業日以内にさせて頂き、
お客様のメールアドレスへご返答致します。 
&lt;/pre&gt;

ここまではWebの手続き。後はメールを待つ。

&lt;hr&gt;
以下は決まりもの。
&lt;pre&gt;
プライマリDNSサーバ： NS1.DNS.NE.JP （ 210.188.224.9 ）
セカンダリDNSサーバ： NS2.DNS.NE.JP （ 210.224.172.13 ）
&lt;/pre&gt;

DNS設定はこうしよう。

| @	| NS	 |ns1.dns.ne.jp.|
|       | NS	 |ns2.dns.ne.jp. |
|       | A	 | 219.94.153.157 |
|       | MX	 | 10 @ |
| www	| CNAME	 | @ |
| secure| CNAME	 | @|
| ftp	| CNAME	 | @|
| hmo	| CNAME	 | @|
| hiyama| CNAME	 | @|

dotster側は、http://d.hatena.ne.jp/m-hiyama-memo/20100212/1265939469 に書いてある。

*1272238917*[caty-depl]dotster の Name Server Update Results

&lt;pre&gt;
Name Server Update Results

Update completed with the following results:
CHIMAIRA.ORG:Name Servers Successfully Updated


If you have problems completing your update and need to contact customer service, please report the following code with your request
Code: Bwlj0ywFWIyNg1A861ZphyFg
&lt;/pre&gt;

*1272239007*[caty-depl][メモ]grepでコメント除去など

/etcの下の多くのファイルでは、

- egrep '^[^#]' config-file | less

あと、PS1=&quot;\n[\u@\h \W]\\$ &quot; がいいような気がする。システムデフォルトは：

&lt;pre class=&quot;out&quot;&gt;
$ cat /etc/bashrc | grep PS1
if [ &quot;$PS1&quot; ]; then
    [ &quot;$PS1&quot; = &quot;\\s-\\v\\\$ &quot; ] &amp;&amp; PS1=&quot;[\u@\h \W]\\$ &quot;
$
&lt;/pre&gt;

*1272274832*[caty-depl]Postfixを調べる

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications postfix]$ grep myhostname main.cf | grep '^[^#]'
myhostname = microapplications.net
myorigin = $myhostname
mydestination = $myhostname, localhost.$mydomain, localhost

[hiyama@microapplications postfix]$ grep mydomain main.cf | grep '^[^#]'
mydomain = microapplications.net
mydestination = $myhostname, localhost.$mydomain, localhost

[hiyama@microapplications postfix]$ grep mynet main.cf | grep '^[^#]'
mynetworks = 127.0.0.1

[hiyama@microapplications postfix]$ grep smtpd main.cf | grep '^[^#]'

[hiyama@microapplications postfix]$ grep smtpd main.cf
# through Postfix.  See the smtpd_recipient_restrictions parameter
# relay mail to.  See the smtpd_recipient_restrictions description in
# The smtpd_banner parameter specifies the text that follows the 220
#smtpd_banner = $myhostname ESMTP $mail_name
#smtpd_banner = $myhostname ESMTP $mail_name ($mail_version)

[hiyama@microapplications postfix]$ service postfix status
master (pid 3654) is running...

[hiyama@microapplications postfix]$
&lt;/pre&gt;

とかやってみたが、次が楽。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications postfix]$ postconf -n
alias_database = hash:/etc/aliases
alias_maps = hash:/etc/aliases
command_directory = /usr/sbin
config_directory = /etc/postfix
daemon_directory = /usr/libexec/postfix
debug_peer_level = 2
html_directory = no
inet_interfaces = all
mail_owner = postfix
mail_spool_directory = /var/mail
mailq_path = /usr/bin/mailq.postfix
manpage_directory = /usr/share/man
mydestination = $myhostname, localhost.$mydomain, localhost
mydomain = microapplications.net
myhostname = microapplications.net
mynetworks = 127.0.0.1
myorigin = $myhostname
newaliases_path = /usr/bin/newaliases.postfix
queue_directory = /var/spool/postfix
readme_directory = /usr/share/doc/postfix-2.2.10/README_FILES
sample_directory = /usr/share/doc/postfix-2.2.10/samples
sendmail_path = /usr/sbin/sendmail.postfix
setgid_group = postdrop
unknown_local_recipient_reject_code = 550

[hiyama@microapplications postfix]$
&lt;/pre&gt;


</body>
</day>
<day date="2010-05-17" title="">
<body>
*1274051864*[子供][メモ]子供用のスパイク、自転車

渋谷のカモの&lt;strong&gt;マキノさん&lt;/strong&gt;のアドバイス：FGという種類のスパイクは刺が長いので足に負担がかかって、初めての子向きじゃない。プーマはFG仕様なので、アディダスのキッズのほうがいいだろう。後ろはゴムが吉。

ドン・キホーテ本店で自転車：03-5768-6311


</body>
</day>
<day date="2010-05-20" title="">
<body>
*1274318309*[高次圏論]ルーリー（ルーリエ）の言葉

ヤコブ・ルーリー（Jacob Lurie; 発音はルーリーのほうが近いようだ）は、ほんとにクリアで鋭い。

&gt;&gt;
we need a class of mathematical objects which can behave both like categories and like topological spaces. 
&lt;&lt;

なるほど！！

*1274319139*[indexed/fibred圏]擬射

C、Bが圏でPが関手 P:C→B、このとき、CをB上の圏と考える。&lt;b&gt;Cat&lt;/b&gt;内でベース圏B上の対象だとみなす。

A∈|C|, X∈|B|のとき、A→X という射はどこにも存在しない。が、P(A) = X であるとき、A→X という射のようなモノが存在すると考えると具合がいい。この射のようなモノを&lt;strong&gt;垂直擬射&lt;/strong&gt;とよぶことにする。必ずしも垂直とは限らない“斜め”の擬射 B→X は、垂直擬射 B→Y と、ベース射 Y→X の組として定義する。

次の図式で縦方向は擬射だとする。

&lt;pre&gt;
   f
 A → B
↓   ↓
 X → Y
   t
&lt;/pre&gt;

このような擬射を含む矩形が可換であるとは、P(f) = t であることだと定義する。この矩形の図は A→Y という斜め擬射の存在も示しているから、可換な三角図式だとも言える。擬射を含むので、擬可換図式と呼ぶべきかもしれない。

*1274333812*[雑記]バックスラッシュ

|* 入力  |*表示 |
| &amp;amp;#x5c;  | &amp;#x5c; |
| ＼          | ＼ |



</body>
</day>
<day date="2010-05-21" title="">
<body>
*1274414374*[子供]カモ営業時間 10:00～21:00

で、今日（土曜）カモに行く。

</body>
</day>
<day date="2010-05-22" title="">
<body>
*1274505713*[メモ]葉書がなくなる超常現象

紛失ともいう。が、信じられないよなー。

月曜に電話かWebで問い合せるしかない。

*1274512504*[メモ]月曜に

来週はやたらに外出が多いから、月曜のウチに問い合わせ。

あっ、ドンキの自転車も忘れているし。

</body>
</day>
<day date="2010-05-24" title="">
<body>
*1274657833*[indexed/fibred圏]vistoliの言葉

Fはファイバリングの全体圏、Cはベース圏のとき：

&gt;&gt;
we can pull back objects of F along any arrow of C.
&lt;&lt;

ファイバリングの本質だな。

</body>
</day>
<day date="2010-05-28" title="">
<body>
*1275021726*[メモ]いったん家に帰る

予定を確認。


</body>
</day>
<day date="2010-05-31" title="">
<body>
*1275262965*[メモ]カメラのケース

次男に取られたから、買う。買った。

あと、自転車どうなっている？ 明日時間あるかな？？
</body>
</day>
<day date="2010-06-01" title="">
<body>
*1275352873*[indexed/fibred圏]ファイバー圏の幾何学的な定義

http://d.hatena.ne.jp/m-hiyama/20100520/1274324275#c に書いた用語法で、ファイバー圏（fibred/fibered category）の定義を書き換えてみよう、っと。なるべく幾何学的なイメージを使うことにする。関手柱と擬射の概念を使う。後で絵を入れることにしよう（先に文章）。


&lt;h5&gt;関手柱と擬射&lt;/h5&gt;

F:C→D が任意の関手として、&lt;strong&gt;関手柱&lt;/strong&gt; Cyl(F) を次のように作る。

+ C, Dの台となる有向グラフを同じ記号C, Dで表す。
+ 有向グラフ C + D を作る。
+ F(a) = b であるとき、aからbに至る有向辺を1本付け加える。この辺は&lt;strong&gt;母線&lt;/strong&gt;と呼ぶ。
+ C + D にすべての母線を加えた有向グラフを Cyl(F) とする。

関手柱Cyl(F)から自由圏を作る。自由圏の射はグラフのパスだから、パスに同値関係を入れて、商を取ることにする。最終的には商が圏になるようにするが、圏構造をあまり気にしないで順次構成していく。

パスの始点と終点は次のどれか：

+ CからC
+ CからD
+ DからD

母線がCからDへの方向にしか走ってないので、DからCへのパスはない。また、パスのなかに母線は高々1本しか現れないし、母線を含むパスは必ず「CからD」のパスになっている。逆に、CからDのパスは、1本の母線を含む。

+ CからCへのパスは、Cの結合により簡約する。
+ CからDへのパスの簡約は後述。
+ DからDへのパスは、Dの結合により簡約する。

母線はギリシャ文字小文字で表す事にして、[f1, ..., fn, α, g1, ..., gk] の形のパスを、[f1;...;fn, α, g1;...;gk] と簡約する。この形のパスを擬射と呼ぶ。擬射は、[Cの射, 母線, Dの射] の三組で表現される。擬射を含めた「一般化射」は次の3種になる。

+ Cの射
+ CからDに至る擬射
+ Dの射

擬射[f, α, g]で、fもgも恒等射であるとき、&lt;strong&gt;垂直擬射&lt;/strong&gt;と呼ぶ。垂直擬射は、母線と同じであり、F(a) = b である (a, b) とも同じである。

ところで、母線て、ジェネラトリックス（generatrix）というらしい。

&lt;h5&gt;擬可換な矩形と擬射の同値&lt;/h5&gt;

次の矩形を考える。

&lt;pre&gt;
    f
  A →  B
  ↓   ↓
  X → Y
    u
&lt;/pre&gt;

ここで、fはCの射、uはDの射で、縦の2本の矢は母線＝垂直擬射である。この矩形で F(f) = u であるとき&lt;strong&gt;擬可換&lt;/strong&gt;と呼ぶ。擬可換矩形があるとき、AからYへの擬射があると考える。この擬射は、2通りの分解（矩形の左回りと右回り）を持つことになる。

擬射[f, α, g]があるとき、擬可換矩形による同値関係を使うと、[β, g] または、[f, γ] の形にできる。以下では、[β, g]の形を正規形として採用する。βは母線でgはDの射である。

以上から次の3種の射を定義できた。

+ Cの射 f
+ CからDに至る擬射 [β, g]
+ Dの射 g

擬可換矩形による同値関係を利用すると、これらの射のあいだに結合を定義できて、結合律を証明できる。この圏を&lt;strong&gt;関手柱圏&lt;/strong&gt;と呼ぶ。

&lt;h5&gt;持ち上げと水平射&lt;/h5&gt;

Fを C→D な関手として、F(A) = X のとき、Aを&lt;strong&gt;X上の対象&lt;/strong&gt;と呼ぶ。Dの射gに対して、Bがdom(g)上の対象であるとき、Bを&lt;strong&gt;gの斜め上の対象&lt;/strong&gt;と呼ぶことにする。F(f) = g のとき、fは&lt;strong&gt;g上の射&lt;/strong&gt;、またはfは&lt;em&gt;gの持ち上げ&lt;/em&gt;であるという。

Dの射gと、gの斜め上の対象Bを固定した上で、gの持ち上げ f:A→B を考える。Bを固定しているので、持ち上げの余域はBとなる。オーバー圏（スライス圏）と同じ要領で、持ち上げの全体 Lift(g, B) は圏となる。圏Lift(g, B)の終対象を、gのBにおける&lt;strong&gt;普遍持ち上げ&lt;/strong&gt;、または&lt;strong&gt;標準持ち上げ&lt;/strong&gt;と呼ぶ。

終対象は、upto-isoで一意的なので、普遍持ち上げも（それがあれば）upto-isoで一意的に決まる。Cの射 f:A→B が、g = F(f) のBにおける普遍持ち上げになってるとき&lt;strong&gt;水平射&lt;/strong&gt;と呼ぶ。水平射と水平射の結合が水平射になるとは限らないことは、HANDBOOK Vol2の最後にある反例からわかる。一般的には、水平射の全体はクラスとなるだけで、部分圏を構成しない。

&lt;h5&gt;プレファイブレーションとファイブレーション&lt;/h5&gt;

関手F:C→Dが、次の性質を持つとき&lt;strong&gt;プレファイブレーション&lt;/strong&gt;と呼ぶ。

- Dの任意の射gとgの斜め上の対象Bに対して、水平射＝普遍持ち上げ f:A→B が存在する。

さらに、次を満たすなら&lt;strong&gt;ファイブレーション&lt;/strong&gt;と呼ぶ。

- Cの射f, f' が結合可能な水平射のとき、結合f;f'も水平射である。

この性質により、D内の図式や部分圏を考えたとき、それをCに標準的に持ち上げることができる。

&lt;hr&gt;
続きはソノウチ。


</body>
</day>
<day date="2010-06-02" title="">
<body>
*1275441802*[お絵描き][高次圏論]2セルの図

&lt;img src=&quot;http://www.chimaira.org/img2/pictorial2cell.jpg&quot; /&gt;

*1275455056*[形式言語理論][Caty]正規言語の包含の判定

ホブランド（Dag Hovland）の方法は良さそうだな。

- http://www.ii.uib.no/~dagh/

マーク、アンマーク方式はいらないのじゃないのかな。構文図の直接比較でもいける気がする。

</body>
</day>
<day date="2010-06-03" title="">
<body>
*1275552931*[形式言語理論][Caty][リンク]「明瞭」関係

Bruggemann-Klein &amp; Wood の似たようなものが２つ

- http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.6882&lt;br&gt;Deterministic Regular Languages (1992) （実際には1991）
- http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.3277&lt;br&gt;One-Unambiguous Regular Languages (1997) 

1997を読めば十分だろう。

教科書っぽいやつ。これも  Bruggemann-Klein

- http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.9232&lt;br&gt;Regular Expressions into Finite Automata (1996)

↓これは役立つ！ これを実装予定。

- http://www.ii.uib.no/~dagh/reinclusionBORA.pdf&lt;br&gt;The Inclusion Problem for Regular Expressions&lt;br&gt;Author: Dag Hovland

あとは色々。

- http://ww2.cs.mu.oz.au/~sulzmann/talks/aplas04-talk.pdf&lt;br&gt;An Implementation of Subtyping among Regular Expression Types
- http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.1456&amp;rep=rep1&amp;type=pdf&lt;br&gt;XHaskell - Adding Regular Expression Types to Haskell 
- http://www.stringology.org/event/CIAA2007/pres/Mon2/Yu.pdf&lt;br&gt;DETERMINISTIC CATERPILLAR EXPRESSIONS
- http://webdb2004.cs.columbia.edu/papers/6-1.pdf&lt;br&gt;DTDs versus XML Schema: A Practical Study
- http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.1178&lt;br&gt;Valuations and unambiguity of languages, with applications to fractal geometry (1994) 

&quot;BOLTZMANN SAMPLING OF UNLABELLED STRUCTURES&quot;てのもあったけど、関係ないよね。

*1275557099*[形式言語理論][Caty]「明瞭」に向けて FollowLast集合

LがアルファベットA上の言語だとして、FollowLast集合が重要だ。

FollowLast(L)⊆A で、次が定義。

- x∈FollowLast(L) ⇔ ∃u, v∈A&lt;sup&gt;*&lt;/sup&gt;.[u∈L ∧ uxv∈L]


</body>
</day>
<day date="2010-06-05" title="">
<body>
*1275703275*[モナド][モノイド圏]モッジのテンソル強度とベックの分配律

あーー、やっぱり&lt;em&gt;絵算は面白い。&lt;/em&gt; &lt;del datetime=&quot;2010-06-05T18:30:31+09:00&quot;&gt;絵はあとで追加、今はリンク切れ状態。&lt;/del&gt;

モッジのテンソル強度とベックの分配律は似てるわけだけど、テンソル強度は系統的に割り当てられた分配律（スワッパ）なのだ。Cがモノイド圏だとして、対象Aごとにスワッパ σ[A] が与えられていて、スワッパ族σが適当な条件を満たすせばテンソル強度となる。

テンソル強度の公理は4つの等式（同型）を含む（「[http://d.hatena.ne.jp/m-hiyama-memo/20060123/1137978147:title]」参照）が、そのうちの2つがベックの分配律の公理になっている。残りの2つはもっと基本的で、スワッパがアクションとして働いていることを主張していて、これは以前次の記事で書いた構造だ。

- [http://d.hatena.ne.jp/m-hiyama-memo/20091127/1259304758:title] これはいいよ、再読しよう。

Cが対称とは限らないモノイド圏として、自己関手と自然変換の圏 D = End(C) を考えると、Dは関手結合をモノイド積、恒等自己関手Iをモノイド単位とするモノイド圏となる。だが、DはC上に構成されているので、Cのモノイド関とモノイド単位をある程度はDまで持ち上げることができる。この持ち上がる様が実に面白い。

&lt;em&gt;前もって注意するが、圏をイタリックにするのがメンドクサイからローマンで書く。よって、C∈|C| となることがあるが、適当に解釈せよ。&lt;/em&gt;

&lt;h5&gt;Cの対象類のモノイド構造がDに持ち上がる&lt;/h5&gt;

|C|はモノイドになる。A∈|C| に対して、関手A&lt;sub&gt;・&lt;/sub&gt;を次のように定義する。

- A&lt;sub&gt;・&lt;/sub&gt; := λX.(A×X)

同様に：

- &lt;sub&gt;・&lt;/sub&gt;A := λX.(X×A)

とりあえずはA&lt;sub&gt;・&lt;/sub&gt;だけを考える。

A |→ A&lt;sub&gt;・&lt;/sub&gt; という対応で、|C|は|D|に埋め込める（いや、埋め込みとは限らないかも）。このとき、次が成立する。

- (A×B)&lt;sub&gt;・&lt;/sub&gt; = B&lt;sub&gt;・&lt;/sub&gt;;A&lt;sub&gt;・&lt;/sub&gt;
- 1&lt;sub&gt;・&lt;/sub&gt; = I

ま、ようするに、モノイドの準同型。この準同型はC全体に拡張できるかもしれないが、今はいいや。

ここで大事なことは、

- Cの対象はDの対象だと思ってよい、Cの積はDの積だと思ってよい

Dの積は関手の結合なので、演算としては全然別物だが、ともかく「思ってよい」。

&lt;h5&gt;スワップ構造&lt;/h5&gt;

FがCの自己関手、つまりDの対象だとする。Cの対象でインデックス付けられた自然変換の族 (σ[A] | σ∈A) を考える。

- σ[A] :: F;A&lt;sub&gt;・&lt;/sub&gt; ⇒ A&lt;sub&gt;・&lt;/sub&gt;；F

&lt;img src=&quot;http://www.chimaira.org/img2/family-of-swaps.jpg&quot; /&gt;

これが、ある種の単位律と結合律を満たすときにスワップ構造と（僕は）呼んでいる。ある種の単位律をバニッシング法則、ある種の結合律をバンドル／アンバンドル法則と呼ぶことにする。

あっ、その前に； 1（Iじゃない！）をモノイド単位対象として、1&lt;sub&gt;・&lt;/sub&gt;はI（恒等関手＝Dのモノイド単位対象）と同じことなので、次の点線で表されるような（単位律を与える）自然同型＝Dの同型が存在する。

&lt;img src=&quot;http://www.chimaira.org/img2/unital-iso.jpg&quot; /&gt;

ここらへんの事情を等式的に真面目に記述するとめんどうなので、上の絵算で済ませる。

それで、スワップ構造のバニッシング法則は次のよう。

&lt;img src=&quot;http://www.chimaira.org/img2/swap-vanishing.jpg&quot; /&gt;

バンドル／アンバンドル法則は次。

&lt;img src=&quot;http://www.chimaira.org/img2/swap-unbundle.jpg&quot; /&gt;

左側の帯状の太い紐は、(A×B)&lt;sub&gt;・&lt;/sub&gt; を示す。んっ、順序の調整が必要か？ 適当に調整せよ。バンドル-スワップ-アンバンドルが、スワップ-スワップと等しい。

ともかくも、次の素材がスワップ構造を定義する。

+ 自己関手F
+ Cの対象でインデックスされた自然変換の族
+ バニッシング法則
+ バンドル／アンバンドル法則

モッジのテンソル強度の公理の一部（2つの等式）は、モナドFのテンソル強度を与える自然変換族が、スワップ構造であることを主張している。

&lt;h5&gt;ベックの法則&lt;/h5&gt;

Fがモナドならモナド乗法（白丸で表す）とモナド単位（白三角で表す）がある。関手＝Dの対象であるA&lt;sub&gt;・&lt;/sub&gt;が、Fに対してベックの法則を満たすとは次のこと。

&lt;img src=&quot;http://www.chimaira.org/img2/swap-beck-unit.jpg&quot; /&gt;
&lt;img src=&quot;http://www.chimaira.org/img2/swap-beck-mult.jpg&quot; /&gt;

要するに、モナドの白丸と白三角が、A&lt;sub&gt;・&lt;/sub&gt;のワイヤーに対して「すり抜け可能」ということだ。

モッジのテンソル強度の公理の残りの等式は、ベックの法則＝すり抜け変形の存在を主張している。

&lt;h5&gt;テンソル強度&lt;/h5&gt;

結局、Fにテンソル強度σがあるとは、Fに対してスワップ構造が与えられていて、関手A&lt;sub&gt;・&lt;/sub&gt;達がすべて、Fに対してベックの法則を満たすこと。

オリジナルのベックの法則は、2つのモナドに関して記述するが、1つのモナドと1つの関手があれば記述可能。「1つの関手」を、モナド上の加群だとすると、「[http://d.hatena.ne.jp/m-hiyama-memo/20090725/1248504503:title]」の話になると思う。

*1275729823*[モナド][モノイド圏]モッジのペアリング

T = (T, μ, η) が対称モノイド圏 C = (C, ×, 1) 上のモナドで、σはCの対称だとする。さらに、τ = (τ[A] | A∈|C|) をT上のテンソル強度だとする。(T, τ) = (T, μ, η, τ) は強モナド（むしろ「強度付きモナド」がいいと思う）となる。

以上の状況で、モッジのペアリング π[A, B] : T(A)×T(B)→T(A×B) を次のように定義する。

&lt;pre&gt;

   T(A)×T(B)
  -----------σ
   T(B)×T(A)
  -----------τ
   T(T(B)×A)
  -----------T(σ)
   T(A×T(B))
  -----------T(τ)
   T(T(A×B&amp;#41;)
  -----------μ
   T(A×B)
&lt;/pre&gt;

f:X→T(A), g:Y→T(B) があるとき f#g :X×Y→T(A×B) を (f×g);π により定義できる。演算 (- # -) はクライスリ圏のペアリングとなる。このペアリングがモノイド積になるかどうかは計算しないと分からない。今度元気なときに計算しよう。

具体的な強度付きモナドでモッジのペアリングが何になるかを調べると面白い。

*1275729824*[モナド][モノイド圏][具体例]典型的なモナドとは

具体的な強度付きモナドとして、計算関係では何があるか？

計算（コンピューティングとソフトウェア）で出てくるモナドは、たいていコレクション系かモノイドスタンピング系。

コレクション系：

+ リストモナド + 直積
+ 有限パワーセットモナド + 直積

スタンピング系：

+ Maybeモナド + 直和
+ カウンターモナド + 直積 （自然数足し算のモノイドスタンピング）
+ タートルモナド + 直積 （アフィン変換の群スタンピング）

その他：

+ 切り上げモナド + 実数の足し算（非負実数の掛け算でもOK）

この6つの例で試せばだいたいの感じはつかめるだろう。

*1275731051*[お絵描き][高次圏論]リントは糸くず

lintの本来の意味は糸くずか。

両端にノードを持たないグラフ辺をリントと言ってもいいかもしれない。2-圏のストリング図ではリントが登場する。アロー図のループは、ストリング図のリント。ループからループへの2セルは、2本のリントが出たノード。

</body>
</day>
<day date="2010-06-07" title="">
<body>
*1275867296*[モナド][モノイド圏]余強度

T(A)×B → T(A×B) が余強度ってことじゃないな。やっぱり右強度と左強度が必要か。T(A×B)→T(A)×B で可換図式を全部ひっくり返したんが余強度ってことらしい。

*1275867334*[モナド][モノイド圏]強度対、両側強度、可換性

bistrengthという言葉があるのは知っているが意味は知らない。bistrengthと同じかもしんない概念を考えたが、2-side strengthで両側強度と呼ぶことにする。以下に説明。

C = (C, ×, 1) をモノイド圏とする。対象Aに対して、2つの関手を定義する。

- A&lt;sub&gt;・&lt;/sub&gt; := λx.(A×x)
- &lt;sub&gt;・&lt;/sub&gt;A := λx.(x×A)

モノイド積に関する性質から、これらの関手の性質が導ける。

- B×(A×X) = (B×A)×X -- A&lt;sub&gt;・&lt;/sub&gt;;B&lt;sub&gt;・&lt;/sub&gt; = (B×A)&lt;sub&gt;・&lt;/sub&gt;
- (X×A)×B = X×(A×B) -- &lt;sub&gt;・&lt;/sub&gt;A;&lt;sub&gt;・&lt;/sub&gt;B = (A×B)&lt;sub&gt;・&lt;/sub&gt;
- (A×X)×B = A×(X×B) -- A&lt;sub&gt;・&lt;/sub&gt;;&lt;sub&gt;・&lt;/sub&gt;B = &lt;sub&gt;・&lt;/sub&gt;B;A&lt;sub&gt;・&lt;/sub&gt;

Tがモナドだとして、τは強度で τ[A] :A×T(X)→T(A×X)、τ' は τ'[A] :T(X)×B→T(X×B) の形で余強度と呼ぶことにする。右とか左とか言っても分からなくなるので、τとτ'の組を&lt;strong&gt;強度対&lt;/strong&gt;と呼ぶ。

強度対があると、モッジ・ペアリングは簡単に定義できる。

&lt;pre&gt;

   T(A)×T(B)
  ------------τ
   T(T(A)×B)
  ------------T(τ')
   T(T(A×B))
  ------------μ
   T(A×B)


   T(A)×T(B)
  ------------τ'
   T(A×T(B))
  ------------T(τ)
   T(T(A×B))
  ------------μ
   T(A×B)
&lt;/pre&gt;

この2つの定義が一致するとき、強度対は可換と呼べばよいだろう。

A×T(X)×B→T(A×X×B) で然るべき公理を満たすものを両側強度と呼ぶことにする。両側強度から強度対は簡単に構成できる。強度対からの両側強度の作り方は2種類ある。

&lt;pre&gt;

   (T;A&lt;sub&gt;・&lt;/sub&gt;);&lt;sub&gt;・&lt;/sub&gt;B
  ------------------------------------
   (A&lt;sub&gt;・&lt;/sub&gt;;T);&lt;sub&gt;・&lt;/sub&gt;B
  ------------------------------------
   A&lt;sub&gt;・&lt;/sub&gt;;(T;&lt;sub&gt;・&lt;/sub&gt;B)
  ------------------------------------
   A&lt;sub&gt;・&lt;/sub&gt;;(&lt;sub&gt;・&lt;/sub&gt;B;T)


   (T;&lt;sub&gt;・&lt;/sub&gt;B);A&lt;sub&gt;・&lt;/sub&gt;
  ------------------------------------
   (&lt;sub&gt;・&lt;/sub&gt;B;T);A&lt;sub&gt;・&lt;/sub&gt;
  ------------------------------------
   &lt;sub&gt;・&lt;/sub&gt;B;(T;A&lt;sub&gt;・&lt;/sub&gt;)
  ------------------------------------
   &lt;sub&gt;・&lt;/sub&gt;B;(A&lt;sub&gt;・&lt;/sub&gt;;T)
&lt;/pre&gt;

この2つが一致するときも可換と呼びたい。２つの定義は同値だろうか？

ベースとなるモノイド圏が対称じゃなくても、強度対が付いたモナドに関して可換性が定義できて可換モナド概念も定義できる。どの程度意味があるかは分からない。

*1275867476*[モナド][モノイド圏]左ドット、右ドット記法は役に立つかも

強度ペア(τ, τ')があれば、モッジペアリングはこう定義する。

&lt;pre&gt;
 TA × TB
 ---------τ
 T(TA×B)
 -----------T(τ)
 T(T(A×B)&amp;#41;
 -----------μ
 T(A×B)
&lt;/pre&gt;

Bを変数とすると

&lt;pre&gt;
 TA × T-
 ---------τ
 T(TA×-)
 -----------T(τ)
 T(T(A×-)&amp;#41;
 -----------μ
 T(A×-)
&lt;/pre&gt;

ドット記法を使う：
&lt;pre&gt;
 T- ; (TA)&lt;sub&gt;・&lt;/sub&gt;
 ------------τ
 (TA)&lt;sub&gt;・&lt;/sub&gt; ; T
 ------------T(τ)
 A&lt;sub&gt;・&lt;/sub&gt; ; T; T
 ------------μ
 A&lt;sub&gt;・&lt;/sub&gt; ; T
&lt;/pre&gt;

この例から、次が強度の表現になっていることがわかる。

&lt;pre&gt;
 (TA)&lt;sub&gt;・&lt;/sub&gt;
 ------------
 A&lt;sub&gt;・&lt;/sub&gt; ; T
&lt;/pre&gt;

*1275867813*[Caty][形式言語理論]First, Last, FollowLast、概ね明瞭

オートマトンMがハッキリと与えられれば、First(M), Last(M), FollowLast(M) を求めるのは簡単だ。状態点sごとに Out(s), In(s) を求めてそれを寄せ集めるに過ぎない。あとは集合の排他性の判断。

- 連接明瞭条件 FollowLast(M)∩First(N) = φ
- 合併明瞭条件 First(M)∩First(N) = φ

うん、簡単簡単。あっ、star-normalのチェックがあるのか。もちっと考えよう。

それと,概ね明瞭という概念を考えた。概ね明瞭では、連接と合併に明瞭条件を付けない。?, * に条件を付ける。

*1275904105*[Caty][形式言語理論]明瞭性条件

なんか等式的に定義できたな。&lt;b&gt;[追記]&lt;/b&gt;だがこれは間違っているな。[http://d.hatena.ne.jp/m-hiyama-memo/20100609/1276065813:title] に訂正がある。&lt;b&gt;[/追記]&lt;/b&gt;

+ A, B 連接-1 FollowLast(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;
+ A, B 連接-2 ε(A)First(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;
+ A | B ユニオン ε(A) = 0, ε(B) = 0, First(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;
+ A? オプション ε(A) = 0
+ A* 繰り返し ε(A) = 0, First(A)∩FollowLast(A) = &lt;b&gt;0&lt;/b&gt;

+ First[A, B] = First(A)∪ε(A)First(B)
+ First[A | B] = First(A)∪First(B)
+ First[A?] = First(A)
+ First[A*] = First(A)

+ FollowLast[A, B] = FollowLast(B)∪ε(B)FollowLast(A)
+ FollowLast[A | B] = FollowLast(A)∪FollowLast(B)
+ FollowLast[A?] = FollowLast(A)
+ FollowLast[A*] = FollowLast(A)∪First(A)


</body>
</day>
<day date="2010-06-09" title="">
<body>
*1276065813*[Caty][形式言語理論]明瞭性条件 訂正

間違っていたから。

+ A, B 連接 FollowLast(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;
+ &lt;del datetime=&quot;2010-06-09T15:43:33+09:00&quot;&gt;A, B 連接-2 ε(A)First(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;&lt;/del&gt;
+ A | B ユニオン ε(A) = 0, ε(B) = 0, First(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;
+ A? オプション ε(A) = 0
+ A* 繰り返し ε(A) = 0, First(A)∩FollowLast(A) = &lt;b&gt;0&lt;/b&gt;

+ First[A, B] = First(A)∪ε(A)First(B)
+ First[A | B] = First(A)∪First(B)
+ First[A?] = First(A)
+ First[A*] = First(A)

+ FollowLast[A, B] = FollowLast(B)∪ε(B)FollowLast(A)
+ FollowLast[A | B] = FollowLast(A)∪FollowLast(B)∪ε(A | B )(First(A)∪First(B))
+ FollowLast[A?] = FollowLast(A)∪First(A)
+ FollowLast[A*] = FollowLast(A)∪First(A)

ε(A) = 1 のとき、First(A)⊆FollowLast(A) となる。よって、FollowLast(A)∩First(B) = &lt;b&gt;0&lt;/b&gt; があれば、ε(A)First(A)∩First(B) = &lt;b&gt;0&lt;/b&gt;&lt;/del&gt; が出るので不要。

一番の間違いは FollowLast[A | B] の公式。単純に和になるわけじゃなかった。

*1276075124*[高次圏論][雑感]まずい！！ 

バートレットのダガーについてサッパリ思い出せない。

http://arxiv.org/abs/0901.3975 のPDF、p.81からp.110を急遽印刷して読むんだ！

</body>
</day>
<day date="2010-06-10" title="">
<body>
*1276146815*[Caty][形式言語理論]オートマトンの連接

オートマトンを連接するとき、2種類の連接がある。

- JSONの配列やオブジェクトを表すオートマトンでは、終状態から出るエンドマーカー（終端記号）の辺をそのまま残す。
- 正規表現を部分式から構成するときは、終状態から出るエンドマーカー（終端記号）の辺は全部削除して、終状態と次の開始状態を張り合わせる。

2番目のやり方の問題は、逆流が生じるかも知れないことだ。MとNがオートマトンとして、連接オートマトン内でNの（旧）始状態から、もう通り過ぎたはずのMの内部状態に戻ることができてしまう。これを防ぐには、逆流止めにイプシロン辺を入れるが、イプシロン辺はまた別な問題を引き起こす。イプシロン辺とは別なブリッジ辺／ワープ辺を設けるか。

イプシロン記号じゃなくてワープ記号というのを入れて、ワープ記号も含めて決定性ならいいのか。ニードル（カレント状態ポインタ）は、入力記号を保持した状態（＝インスタンス側のニードルを動かさないで）ワープ辺を必要なだけたどれる。

つまり、（何種類かの）終端記号と1つのワープ記号を準備すればいいのだな。これらの特殊記号もディスパッチラベルとして使えばいいのだ。ディスパッチラベルは：

+ 型名 integer, boolean, ...
+ タグ名 @foo, @*
+ プロパティ名 &quot;foo&quot;: *:
+ スカラーリテラル 1, &quot;hello&quot; など
+ 終端記号、'}', ']', '$'
+ ワープ記号 #warp

このなかでユニオン弁別子に使えるのは：

+ 型名 integer, boolean, ...
+ タグ名 @foo
+ スカラーリテラル 1, &quot;hello&quot; など。

*1276147685*[Caty][形式言語理論]ガードとコミット選択

あれっ、遷移辺に貼られたディスパッチラベルが一種のガードで、どれかを選んでGOというわけで、これはコミット選択（comitted choice）になっているな。もともとが決定性なんだから、コミットもへったくれもないと言えばまーそうだ。決心をしたり運を天に任せて選択するんじゃなくて、選択が必然なんだからコミットメントはない。逐次処理だし、、、、^^;

まままままっ、そうだけど； 雰囲気的には、ガードがついたプロセッサノードがグラフ形状に集まった処理系。そのなかをCS（current state）ポインタ＝ニードルがゴール目指して走り回る。

*1276150016*[Caty][形式言語理論]イプシロン辺は除去しない

イプシロン辺の除去は、手間の割に効果ないのではないか。ワープ記号をちゃんとした一人前の記号としてアルファベットにいれておいて、ワープのルールを入れておけば、特に何もしなくても十分に速いような気がする。

もちろん、まったく無駄なワープは削除してもいいけど、実行系はワープ付きで考えるべきだ。後から、コンパイラががんばってワープを減らすことはできるんだから。

*1276151619*[Caty][形式言語理論]結局できたような気がする、アルゴリズム

ガードのようなディスパッチラベルのような辺ラベルと、ノードからなるグラフを考えればいい。

- スキーマ属性に対応する述語ノード。台型でガードされている。真偽が、成功（通過）失敗（失格）に対応。
- 子オートマトンノード。objectオートマトンかarrayオートマトン。型名object, arrayでガードされている。
- 単純分岐ノード。union型に対応する。単なる状態ノード。

属性なしのスカラー型は辺（ワイヤー）だけ。シングルトン型はディスパッチラベルと考えても、特殊な述語ノードでも同じ。分岐ノードの都合もあるから、ディスパッチラベルでいいか、これも辺だけ。シングルトン含めてスカラー型は辺だけか。

- シングルトン含めたスカラー型 -- 辺だけ
- object型 -- objectオートマトン
- arrayt型 -- arrayオートマトン
- union型 -- 分岐ノード
- tagged型 -- 辺 ＋ 値のノード（サブグラフ）


</body>
</day>
<day date="2010-06-12" title="">
<body>
*1276315149*[Caty][形式言語理論]オートマトンのゴールノード

正規表現の部分式に対応するオートマトンと完全な構文単位に対応するオートマトンを区別する必要があるのだった。

最初に、終状態ノードとゴールノードを区別することからはじめる。終状態はそこで終端記号が入力すると受理が成功するような状態のこと。これはいいよね。ゴールノードとは、終状態において実際に終端記号の入力が起きた時の遷移先。よって、ゴールノードとは、次の条件を満たす。

+ 入る辺のラベルはすべて'$'。
+ 出る辺はない。
+ 終状態からゴールノードに至る辺以外では'$'は出現しない。

別な言い方をすると：

+ 終状態とは、'$'でラベルされた出る辺を持つノードである。
+ '$'でラベルされた辺の先は必ず特定のノードでなくてはならない。

形式的に書くために次を定義しておく。

+ グラフのノードpに対して、in(p) は、pのin-次数
+ グラフのノードpに対して、out(p) は、pのout-次数
+ 辺ラベル付きグラフのノードpに対して、InL(p) は、pへ入る辺のラベルの集合
+ 辺ラベル付きグラフのノードpに対して、OutL(p) は、pから出る辺のラベルの集合

'-'はスタートノード、'+'はゴールノードも表すとする。で、先の条件をもう一度記述すると：

+ InL('+') = {$}
+ out('+') = 0
+ 任意のpに対して、$∈InL(p) ならば p = '+'

- pが終状態 ⇔ $∈OutL(p)

終状態から$による遷移先が'+'に限ることはすぐ出る。

*1276316111*[Caty][形式言語理論]S型オートマトンとT型オートマトン

オートマトンの連接問題は「S型オートマトンとT型オートマトン」を考えるとケリが付く。Sはsubexpression、Tはtotal expressionから。

&lt;h5&gt;S型オートマトン&lt;/h5&gt;

アルファベットA上のS型オートマトンとは、無音記号（εと同じ）を#として、A∪{#}で辺ラベル付けされた有向グラフで、スタートノード'-'とゴールノード'+'が特定されているもの。次の条件を満たす。

+ out('+')= 0 ゴールでオシマイ、もう後はない。
+ In('+') = {#} ゴールには無音記号でのみ到達できる。

アルファベットA上のS型オートマトンの全体は S-Aotom&lt;sub&gt;A&lt;/sub&gt; とする。Aがわかっているなら省略する。S-Automは連接演算でモノイドとみなす。MとNの連接は、M;N または MNと記す。

- MのゴールノードとNのスタートノードを同一視することが連接
- モノイド単位オートマトンは、('-' - # --&gt; '+')

実際には、これでは&lt;em&gt;モノイドにならない&lt;/em&gt;けど、それでいいのだ。オートマトンを1セルとみなして、自然同値を与える2セルにより、擬モノイドとなる。2セルは双模倣だろうが、#辺を消去する手続きとその逆を考えるだけでもいいと思う。先に2セルの亜群構造があり、その亜群による弱等号に関してのモノイド概念。E集合＝セットオイドの圏内でのモノイドでもあるな。


&lt;h5&gt;T型オートマトン&lt;/h5&gt;

アルファベットA上のT型オートマトンとは、無音記号（εと同じ）を#、終端記号を$として、A∪{#, $}で辺ラベル付けされた有向グラフで、スタートノード'-'とゴールノード'+'が特定されているもの。次の条件を満たす。

+ out('+')= 0 ゴールでオシマイ、もう後はない。
+ InL('+') = {$} ゴールには無音記号でのみ到達できる。
+ $∈InL(p) ならば p = '+'

アルファベットA上のT型オートマトンの全体は T-Aotom&lt;sub&gt;A&lt;/sub&gt; とする。Aがわかっているなら省略する。T-Automには自然な連接演算は定義できない。

MがS型オートマトンで、XがT型オートマトンのとき、モノイド作用（スカラー積）を定義できる。

- M*X は、MのゴールノードとXのスタートノードを同一視したもの

等号を弱い等号と解釈して、次が成立する。

- (MN)*X = M*(N*X)
- I*X = X

&lt;h5&gt;相互変換&lt;/h5&gt;

MがS型オートマトンのとき、Mのゴールノードに至る辺の#を$に書き換えるとT型オートマトン。この変換を M&lt;sup&gt;$&lt;/sup&gt; で表す。

- (-)&lt;sup&gt;$&lt;/sup&gt; : S-Automo→T-Autom

$を#に書き換える変換を (-)&lt;sup&gt;#&lt;/sup&gt;: T-Automo→S-Autom とすると、互いに逆変換で：

+ (M&lt;sup&gt;$&lt;/sup&gt;)&lt;sup&gt;#&lt;/sup&gt; = M
+ (X&lt;sup&gt;#&lt;/sup&gt;)&lt;sup&gt;$&lt;/sup&gt; = X

S-Automがベクトル空間、T-Automがベクトル空間と同型なアフィン空間に類似している。

次は重要。

- (M*X)&lt;sup&gt;#&lt;/sup&gt; = M(X&lt;sup&gt;#&lt;/sup&gt;)

&lt;h5&gt;T-Automの連接&lt;/h5&gt;

2項演算 (-・-):T-Autom×T-Autom→T-Autom を次のように定義する。

- X・Y := X&lt;sup&gt;#&lt;/sup&gt;*Y 

すると次が成立する。

+ (X・Y)&lt;sup&gt;#&lt;/sup&gt; = X&lt;sup&gt;#&lt;/sup&gt;Y&lt;sup&gt;#&lt;/sup&gt;
+ I&lt;sup&gt;#&lt;/sup&gt; = I （厳密には、左右のIは違うもの）
+ (MN)&lt;sup&gt;$&lt;/sup&gt; = M&lt;sup&gt;$&lt;/sup&gt;・N&lt;sup&gt;$&lt;/sup&gt;
+ I&lt;sup&gt;$&lt;/sup&gt; = I （厳密には、左右のIは違うもの）

つまり、S-Autom×S-Autom, S-Autom×T-Autom, T-Autom×T-Autom にそれぞれ積があり、うまいこと同調している。

なお、T-Automには左自明モノイド演算を定義することもできるが、これはEOFによりファイルが切れてしまう現象に対応する。あるいは、'\0'まで込めたconcat-copyの例も同じ。

&lt;b&gt;[追記]&lt;/b&gt;シーケンスデータのインスタンスは特殊なオートマトンであることを忘れないように。&lt;b&gt;[/追記]&lt;/b&gt;

*1276319996*[Caty][形式言語理論]leadFirst集合

- 言語Lに関して、ξがstrong postfix  (suffix) ⇔ α∈L かつ αξ ∈L となるαがある
- 言語Lに関して、ηがstrong prefix ⇔ α∈L かつ ηα ∈L となるαがある

- strong postfixの先頭文字はfollowLast集合に入る。
- strong prefixの末尾文字はleadFirst集合に入る。

- 終状態pに関する OutL(p)の合併がfollowLast集合
- 始状態pに関する InL(p)の合併がleadFirst集合

followLast, leadFirstは、逆流、混線、曖昧性などのもとになる集合だ。

</body>
</day>
<day date="2010-06-14" title="">
<body>
*1276474704*[Caty][形式言語理論]明瞭オートマトン

扱いやすい決定性オートマトンのこと。

+ スタートノードがひとつだけある。
+ ゴールノードがひとつだけある。
+ スタートノードとゴールノードは異なる（他の条件から出るが）。
+ すべてのノードはスタートノードから可達。（空集合は認識機械は除外）
+ すべてのノードからゴールノードに可達。
+ in(p) = 0 ⇔ p はスタートノード。
+ out(p) = 0 ⇔ p はゴールノード。
+ 上の2つから、すべての中間ノードは出る辺と入る辺の両方を持つ。
+ イプシロン辺はあってもよいが、各ノードから出るイプシロン辺は高々1本。
+ イプシロン辺からなるサイクルは存在しない。

１本のイプシロン辺からなるオートマトン (- → +) を単位オートマトン、1本の基本記号ラベル付きノードからなるオートマトンを基本オートマトンと呼ぶ。単位オートマトンと基本オートマトンは明瞭である。

次の条件を定義する。

+ 明瞭連接条件
+ 明瞭ユニオン条件
+ 明瞭オプショナル条件
+ 明瞭繰り返し条件

これらの条件を満たすときの連接、ユニオン、オプショナル、繰り返しが明瞭性を保存することを証明する。

されに次の条件を考える。

- 行き先がゴールノードでないイプシロン辺は存在しない。

この条件を満たすとき、最小イプシロン形と呼ぶ。イプシロン辺の可能なら縮約（両端のノードを同一視）、除去（辺だけ取り除く）により、最小イプシロン形にできる。行き先がゴールであるイプシロン辺には手を付けない。

+ イプシロン辺を見つける
+ まとめて処理するためにイプシロン辺の最長チェーン（パス）を作る。サイクルがないので、最長チェーンは作れる。
+ チェーンの先の方から逆向きに見ていく。
+ 辺の行き先がゴールなら何もしない。
+ 行き先に入る辺がないなら縮約する
+ 短絡辺を生成してイプシロン辺を取り除く

pから出る辺のラベルを集めて OutL(p)を作れる。pからイプシロン辺でたどれるノードの OutL(q) を全部集めてNexL(p)を作る。最小イプシロン形なら、OutL(p)とNextL(p)が一致する。ほんとに重要なのはこの点で、次が望ましい。

+ 任意のノードpに関して NexL(p) = OutL(p)
+ Next(p)（OutL(p)である）上で定義された遷移先ノードを値とする関数が決定性になる。

これなら、遷移を表すデータにハッシュマップの配列を使える。カレントノード番号をインデックスとしてアクセスし、得られたハッシュテーブル（ディクテーション、オブジェクト）を入力記号で引いて遷移先を一意に決められる。

*1276476054*[Mx][説明][プログラム意味論]Δの意味は難しいし面白い

双デカルト圏の余加法Δ（加法は∇）を考える。これをデータフロー計算または状態書き換え計算の文脈でどう解釈するか？ これは勘違いしやすい。僕も勘違いしていた。トレース付き双デカルトで計算処理（プロセス）をモデル化するとき、逐次計算と並列計算の違いは定式化できない。つまり、ある種の逐次計算と並列計算は、双デカルト圏のなかで同じ射でモデル化できる。&lt;em&gt;つまり、同じに見えちゃう。&lt;/em&gt;

双デカルト圏は、逐次処理と並列処理の区別ができるほどに精密ではないということだが、逆に逐次処理と並列処理の違いを捨象した結果を得ることができる。もともと、双デカルト圏は、非決定性計算の最終結果をモデル化するもので、計算の途中経過はあまり問題にしない。

双デカルト性は、直和と直積を同じに扱うことなので、Δは「直積の対角＝複製」と「直和の重ね合わせ（フォールド）の逆＝ベキ等加法の逆＝公平なランダム弁」の両方の解釈を持つ。複製器と考えれば並列処理による解釈、ランダム弁と考えれば（非決定性の）逐次処理的な解釈。

非決定性の逐次処理的のときは、順次多数回の試行結果の蓄積またはバックトラックによるトライアンドエラーの蓄積を結果とする。並列処理のときは、バックトラックはしないで失敗プロセスは単に破棄（または放置）する。多数回試行は、同時に行い、それらの結果を集約する。

いずれにしても、結果の集約にはある程度の時間がかかる。結果の集約だけを見てる立場では、逐次処理と並列処理を区別できない。

Δは、データフローならデータの複製、状態書き換え計算なら状態（計算環境）の複製を意味する。逐次計算なら、公平なサイコロによる実行経路選択になり、バックトラックまたは多数回試行を問題にする。多数のプロセッサの空間的な集約と、多数回試行の時間的な集約の結果は一致する、という仮説（これはエルゴード仮説かな？）を信じる定式化が双デカルト性（直積と直和の一致）。

非決定計算んの枠組みでなかでは、逐次処理と並列処理の区別が見えなくなる。特に、∇がベキ等加法だから、空間的な寄せ集めも、時間的な履歴の蓄積の違いを吸収してしまう。タプルとストリームとセットの関係をよく考えると、タプルをストリームにする方法はイッパイあるが、セットにするとストリームの違いがわからなくなる。

それと、混乱しがちなのは、状態空間の直和の上で並列処理を走らせると、2つのプロセッサが見ている空間は直積となる。その直積空間の一部が運動の相空間となる。静的な構成の状態空間は運動の場＝配位空間で、実行時に多体系として見える動的な相空間とは違う。直和配位空間の入出力は直積となる。



</body>
</day>
<day date="2010-06-15" title="">
<body>
*1276557119*[紛失物]本とマニュアル

- ペラペラ（5ミリくらい）のグラフ理論の本
- ICレコーダのマニュアル

*1276570048*[形式言語理論][DFD][物理っぽい]フーム、驚いた、もろに離散物理

最近、Catyでの必要性から、明瞭正規表現と明瞭オートマトンつう概念を考えて、その同値性とか包含関係とかを考えていたが、離散物理とかDFD（Discrete Field Dynamics）とかに関係する、つうか、&lt;em&gt;離散物理そのもの&lt;/em&gt;だということが分かって驚いている。

言語の包含関係（正規表現型のサブタイプ関係）を示すために、決定性オートマトンの包含関係を調べるのだが、このとき2つのオートマトンのあいだに模倣対応関係（ラベル付きグラフの圏の射）を構成する。2つのオートマトン上で同時にダイクストラ法を実行する。ダイクストラ法で区別が付かないなら、同値なオートマトンである。

- ダイクストラ法&lt;br&gt; http://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95
- ベルマン-フォード法&lt;br&gt; http://ja.wikipedia.org/wiki/%E3%83%99%E3%83%AB%E3%83%9E%E3%83%B3-%E3%83%95%E3%82%A9%E3%83%BC%E3%83%89%E6%B3%95

オートマトン（のグラフ）上でダイクストラ法を実行することは、実はスタートノードを波源とする波を発生させることで、波頭集合とすべてのパスを追跡することになる。波頭集合のあいだに対応を付けることを繰り返すと、グラフ全体の対応が作れる。波頭集合の局所的対応がどこかで失敗するなら、目的の対応は作れない。

現状で分かったことは、明瞭オートマトンX、Yに対して、Lang(X)⊆Lang(Y) ならば、X→Yという模倣対応（ラベル付きグラフの圏のモノ射）を構成出来ること。（逆は自明。）

ダイクストラ法で使う波頭集合の運動をダイクストラ波（波動）とでも呼ぶと、ダイクストラ波の進行に伴うすべての“音”（時間的に並んだ記号列）を聴くと、音だけから「形状＋力学」の「ある種の同値類」の判定が可能となる。2つのオートマトン（グラフ上の場の力学系）の音データがまったく同じなら、図形的な対応を音のデータ（言語）をもとに構成できる。

実は、マスロフ脱量子化の話が絡んでいたりするんだよなー。マスロフ代数（正確には代数族）はプランク定数でパラメータ付けされた可換半環の族。最大値（または最小値）からの寄与だけが効いてくる世界では、測地線だけが生き残り、ダイクストラ波動は、測地線だけを残しながら進行する。波頭集合は絞り込まれて粒子系に見える（Winner takes All）、掃過域は軌跡に見える。

グラフの重み付き隣接行列って、ベクトルバンドルのセクションに対応する。必ずじも接バンドルである必要はない。底空間を零セクション（グラフなら長さ0のパス）で埋め込むと、全空間のなかで、底空間の無限小運動を定義する。接バンドルなら無限小変形。特異点を許した無限小変形を積み重ねると、コボルディズムを構成できる。離散状況では、ベクトルバンドルも球体（円板）バンドルも区別がない。接球体に対応するのがステップ1で移行できる隣接ノードから作られる星状部分グラフ。表面である球面と放射半径の束として実現される。

- 音像定位&lt;br&gt; http://www.ais.riec.tohoku.ac.jp/Lab2/localization/index.html

すごく不正確な言い方だが、キャッチフレーズとしては「音像から形状を判定する」か。

*1276575727*[形式言語理論][DFD][物理っぽい][お絵描き]いろいろな絵

絵を描いた。が、切り分けたり、説明書くのは今日はできない。とりあえず貼っておく。

- &lt;a href=&quot;http://www.chimaira.org/img2/discrete-phys.jpg&quot; &gt;画像へのリンク&lt;/a&gt;

&lt;img width=&quot;700&quot; src=&quot;http://www.chimaira.org/img2/discrete-phys.jpg&quot; &gt;



</body>
</day>
<day date="2010-06-16" title="">
<body>
*1276647181*[Caty]Simple API for XJSON

SAX風にXJSONデータにアクセスする。まったくsimple。start/endDataは要らないかもな。

|* コールバック関数 |* 説明  |
| startData()      |ファイルなどのストリームの開始 |
| endtData()       |ストリームの終り |
| numberValue(num)  | 数値 |
| stringValue(str)  | 文字列 |
| booleanValue(flag)| ブール値 |
| nullValue()       | null値 |
| binaryValue(bin)  | バイナリ値（Caty拡張）|
| tag(tagName)     | タグ（Caty拡張）|
| startObject()    | オブジェクの開始 |
| property(name)   | プロパティの開始 |
| endObject()    | オブジェクの終了 |
| startArray()   | 配列の開始 |
| endArray()   | 配列の終了 |

[http://d.hatena.ne.jp/m-hiyama/20060614/1150249907:title]と基本的には同じだが：

+ タグ出現を独立イベントとして構文の自由度を上げた。
+ keyをpropertyにした（リネーム）。
+ integerValueとdecimalValueをnumberValueに統合。
+ atomicValueをbooleanValueとnullValueに分けた。

いつもの例：
&lt;pre class=&quot;code&quot;&gt;

@person {
  &quot;name&quot; : &quot;坂東トン吉&quot;,
  &quot;age&quot; : @age 26,
  &quot;hobbies&quot; : [&quot;釣り&quot;, &quot;盆栽&quot;]
}

&lt;/pre&gt;

+ tag(&quot;person&quot;)
+ startObject()
+ property(&quot;name&quot;)
+ stringValue(&quot;坂東トン吉&quot;)
+ property(&quot;age&quot;)
+ tag(&quot;age&quot;)
+ numberValue(26)
+ property(&quot;hobbies&quot;)
+ startArray()
+ stringValue(&quot;釣り&quot;)
+ stringValue(&quot;盆栽&quot;)
+ endArray()
+ endObject()

*1276661167*[Caty]XJSON - JSON

&lt;em&gt;http://d.hatena.ne.jp/m-hiyama/20100616/1276648245 に投稿してしまったが、本来はコッチの記事。&lt;/em&gt;

表面的な拡張：

+ コメント（保存されない）
+ 余分なカンマ
+ 三重引用符

構造的な拡張：

+ タグ
+ 組み込みのバイナリー型 {&quot;$data&quot; : &quot;image/jpeg;base64, ...&quot;}
+ ハイパーリンク（未定）{&quot;$ref&quot; : &quot;http&amp;#58;//d.hatena.ne.jp/&quot;, &quot;$rel&quot; : &quot;top&quot;}

マーシャリング：

- コメントを除いて、すべての拡張部分は情報欠損無しで通常JSONに変換出来る。
コメントは削除されるので、もとに戻せない。

</body>
</day>
<day date="2010-06-17" title="">
<body>
*1276763504*[メモ]忘れている

- クリーニング
- 防犯ベルの電池 OR ベル本体
- 支払い関係
- 掃除機の充電器
- あと、あああああああ、自転車だぁー。
- なにかあったかな？ありそう、、、、

*1276745426*[Caty][形式言語理論][DFD]ブルゾゾウスキイ導分とダイクストラ波動

ブラグマンクライン＆ウッド（Bruggemann-Klein - Wood）に、1非曖昧言語のクラスは、ブルゾゾウスキ導分（Brzozowski derivative）で閉じてるとか書いてあった。これは、始点または始境界からダイクストラ波動を走らせて、掃過域を切り取って、切り取った切り口を新しい始境界にしてオートマトンを作る、ってことだと思う。

始境界が1点ではないようなオートマトンも認める。すると、ダイクストラ波動の波頭集合により、状態空間内に縞模様ができる。この縞模様の縞（ストライプ）のひとつで空間を輪切りにする。その片割れが再び1非曖昧、それは当たり前だよな、後知恵で言えば。

ブルゾゾウスキイ導分で空間を削っていくのと、ダイクストラ波動の掃過域を削り落としていくのは、ほとんど同じ。

*1276750068*[形式言語理論][DFD][物理っぽい][マンダラ]ダイクストラはめ込みから離散物理とマンダラの圏へ

計算の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%DE%A5%F3%A5%C0%A5%E9%20%B7%F7&quot;&gt;マンダラ圏&lt;/a&gt;を昔から考えていた。いろいろな定式化があるが（そもそも、多数のマンダラがあるだろう）、それが二重圏や半環圏である可能性が高い。

最近、必要があって明瞭オートマトンを考えて、ホイヘンス原理に従いダイクストラ波動に沿ってはめ込みを構成した。はめ込みとは、局所的には単射だが、全域的には単射性を要求しない写像。ラベル付きグラフ（正確には、辺ラベル付き有向グラフ）とは、台であるグラフ（underlying graph）に、半環係数の1-形式（1-ラベリング）を与えたものだと思って良い。1-形式が力学系の生成元を与えるので、ラベル付きのグラフは、力学系が載っている離散空間だと思って良い。この力学系の長時間挙動は、生成行列の指数関数＝プロパゲータ＝クリーネスターで与えられる。

- Prop&lt;sub&gt;A&lt;/sub&gt;(n; j←i) = (1 + A)&lt;sup&gt;n&lt;/sup&gt;[j, i] 時間的に効果が蓄積する場合の伝搬記述

ダイクストラ波動に沿ったはめ込みを&lt;strong&gt;ダイクストラはめ込み&lt;/strong&gt;と呼ぶとすると、ダイクストラはめ込みは明瞭オートマトン固有のものではなかった。どんな状況であっても、ダイクストラはめ込みは構成できる； 構成できる可能性があるならいずれは構成できるし、そうでないなら構成はどうやっても失敗する。そもそも、文字列（語）の認識問題が「ダイクストラはめ込みの構成問題」だったのだ。長さnの文字列は、長さnの有向竹グラフ上の素元係数の力学系になる（半環の素元は、掛け算でも足し算でも合成できない元； 超素元とでも呼ぶべきかも）。

さらに、適当な定義をしてオートマトン（グラフ上の境界つき力学系）の圏Automを作ると、Automの射（模倣写像）はダイクストラはめ込みで尽くされるようだ。つまり、境界を考慮してダイクストラはめ込みが作れないなら、そもそも圏Automでの射が存在しない。

- 2つのオートマトンXとYに対して、射f:X→Y が存在する ⇔ ダイクストラはめ込みf:X→Y が構成できる

あるいは：

- 圏Automのすべての射は、実はダイクストラはめ込みである。

明瞭オートマトンでは、ダイクストラはめ込みの構成が一意的で、異常に簡単だったという事情。一般的には、ダイクストラはめ込み（つまり射）はたくさんあるだろうし、決定性のアルゴリズムで構成できるわけでもない。しかし、構成の可能性は有限的に尽くされるので、トライアンドエラーでいつかは作れるか、完全に失敗するかのどちらか。

さらに、オートマトンと言語の半環から、いろいろと面白い現象を観察できる。まず、オートマトンを境界付きリグラフに一般化しておくと、リグラフの連接を結合、リグラフの直和を双積として、双デカルト圏になる。このとき、0対象が離散空間、1対象＝射がリグラフになる。りグラフのあいだの準同型（いろいろな定義ができる）が2対象＝2セルとなる。全体としては二重圏。

言語の半環は、1圏部分がトレース付き双デカルト圏である二重圏の雛形になっている。

+ 対象はただ1つ
+ 射が言語
+ 双積 (+) から作ったΔ;(+);∇は和
+ 結合は積
+ 2セルは順序
+ 双デカルト圏のトレースから作ったクリーネスターが*

二重圏の(1, 2)部分が再び圏となるが、直和＝双積は対称モノイド積に持ち上がる。1圏部分のEndo射だけを考えれば、結合は非対称なモノイド積を与える。このモノイド積を2セルに拡張して、非対称なモノイド圏を定義できる。0対象がなんであっても、End(S) から半環を作れる。

任意のリグラフにプロパゲーター行列を対応させる部分がベキ等モナドで、ビヘイビア関手と呼ばれているヤツじゃないのか。特に、1行1列の行列はスカラーだから、End(1, 1)上でビヘイビア関手を考えると、オートマトンの言語関手（正確には、言語線形変換を値とする関手）だろう。

*1276756450*[Mx][形式言語理論][DFD][説明]矮小化された数学と物理

矮小化も、それはそれで面白い。

|* 普通           |* 矮小化 |
| 集合            | 有限集合または番号 |
| 位相空間／多様体| 有向グラフ、完全グラフでもいい |
| 実数／複素数    | 0, 1 真偽値 |
| 空間上の関数    | 頂点の部分集合 |
| 接ベクトル空間  | スター近傍 |
| 接ベクトル束    | スター近傍束 |
| 余ベクトル束の断面| スター近傍の部分バンドル |
| 力学系          | 部分グラフ  |
| プロパゲーター  | クリーネスター |


</body>
</day>
<day date="2010-06-18" title="">
<body>
*1276846959*[メモ][形式言語理論][DFD]細かいけど大事なこと

+ 始境界上の点のin次数は0でなくてはならない。
+ 終境界上の点のout次数は0でなくてはならない。
+ ようするに、境界は境界のようでなくてはならない。
+ 辺ラベルは、文字や文字列ではなくて言語なのだ。したがって、いろいろと演算ができる。
+ 境界を1点にすれば便利だが、それだけを考えているのはまったくダメ。
+ イプシロン遷移、無音記号は排除しないほうがいい。

*1276846960*[形式言語理論][DFD][Caty]エライ見落とし！！

明瞭オートマトンの包含性決定問題だが、ダイクストラ波動を、サイクルを持つような空間で走らせると永久に走っている。これは困る。アルゴリズムが止まらない。それは分かっていたんだが、サイクルはすぐに消せると、サイクルの扱いを甘く見ていたなーー。ダメだよ＞自分

それでまず、正規形を考えた。サイクルを持つ空間を、サイクルを持たない部分とサイクル群（帯状の並行サイクルの集まり）に分ける。で、n重サイクル標準型（正規形）はできる。n（0以上の整数）が小さいほど扱い易いので、できる限りnを小さくする努力をする。で、任意の空間つうか力学系だが、それは、サイクルを持たない境界付き力学系のn重サイクル標準形に書ける。

で、そこでダイクストラ波動を走らせる。これは、(n + 1)回やらなくてはならない。ここが痛い勘違い。nが大きいとそれなりの負荷だ。失敗するときは早めにわかるけど。成功の判定には作業を全部やる必要がある。

もうひとつの勘違いは、ダイクストラ波動がはめ込みを定義するところ。局所的に単射なのは間違いないが、「局所的」には時間も含まれる。つまり長時間の蓄積を取ると、同じ場所&lt;del datetime=&quot;2010-06-18T16:45:14+09:00&quot;&gt;に戻る&lt;/del&gt;を何度も通ることがあるので、空間の点の対応としては写像にさえならない。これを管理するには、2つのオートマトンのサイズをかけ算したサイズの2次元テーブルが必要になる。ここでまたメモリーがいるし、手順も複雑化する。

まーともかく、サイクルなし空間内のダイクストラ波動は境界まで達してそこで消えてくれる。波頭集合はいずれは境界に吸収されてなくなる。その結果として、空間の点（ノード）のあいだの対応を作る。この対応が模倣になっていりゃいいってことだろう。

模倣／双模倣／一様性は気にしていたのだが、ちゃんと勉強してないからなー。最後の判定条件に模倣／双模倣／一様性を使う気がする。

どうもハナシがうまく行き過ぎると思った。簡単な問題なら誰かが解いているよな。今の状況では、これはかなり難しい。解けたらエライ、と言える。ダイクストラ波動を(n +1)回走らせるのはいいんだが、その結果の解釈が難しい。どうなったら成功なんだろう？

参考： http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163147851 長谷川の一様性原理：
&lt;pre&gt;

 f:A+X→B+X, g:A+Y→B+Y, ψ;X→Y,  f;(B+ψ) = (A+ψ);g
 -----------------------------------------------------[HU]
 Tr(f)  = Tr(g) : A→B
&lt;/pre&gt;

*1276849178*[形式言語理論][DFD][Caty]模倣による定式化

s, s'∈S, t, t'∈T、状態空間のあいだの関係をR⊆S×T、遷移（1ステップ）を矢印で表す。また xRx' を x～x' で示す。次が、「SがTを模倣できる」の定義。

- s～t, t-(a)→t' ならば、s'～t', s-(a)→s' となるs'がS内にある。

それで、

- SがTを模倣できる ⇔ L(T)⊆L(S)

を示したい。「⇒」は当たり前だが、逆が難しい。模倣Rを構成しないといけない。

- L(T)⊆L(S) ⇒ SがTを模倣できる。
- SがTを模倣できない ⇒ L(T)⊆L(S) ではない。

</body>
</day>
<day date="2010-06-19" title="">
<body>
*1276924772*[Caty][メモ][形式言語理論][DFD]報告になってない現状報告

ウーンと、、、うまくいくか、それともダメか？ わからん。はっきりとダメなわけでもないが、困難。ほんとにメモで、後で読んでもワカラン可能性があるが書いておく。

半環係数の行列とブール係数の行列の計算のなかで一様性と模倣を理解することが大事。ダイクストラ法は行列のべき乗を求める計算法だと理解できる。となると、行列計算としての一様性と模倣を完全に理解できれば、ダイクストラ法をどう使うかも見えてくるだろう、たぶん。

A:1+n →1+n, B:1+m →1+m を正方行列だとして、長谷川さんの一様性は：
&lt;pre&gt;

 A:1+m→1+m, B:1+m→1+m, S;m→n,  A;(1+S) = (1+S);B
 -----------------------------------------------------[HU]
 Tr(A)  = Tr(B) : 1→1

&lt;/pre&gt;

と書ける。ただし、+は行列の足し算じゃなくて直和（対角和）。

一方で、スタート／ゴールを考えないで、単なる遷移系と考えての模倣という概念を行列で書くと次のようになる；B:m→m が A:n→n を S:m→n により模倣できるとは：

&lt;pre&gt;

   A[j←i]S[i←k] = a
  ------------------------------
  ∃α. S[j←α]B[α←k] = a

&lt;/pre&gt;

別な書き方をすると：

- ∀i, j∈[n], k∈[m].( A[j←i]S[i←k] = a ⇒ ∃α∈[m]. S[j←α]B[α←k] = a)

Σ(i: A[j←i]S[i←k]) ⊆ Σ(α: S[j←α]B[α←k]) と書けるか？ だとすると、AS ⊆ SB。


</body>
</day>
<day date="2010-06-21" title="">
<body>
*1277075600*[Caty][メモ][形式言語理論][DFD]模倣と行列計算

一応次のことはわかった。

Kは足し算がべき等な半環、Kはブール代数を半環とみなしたものを含むと考える。AとBはKを係数とする正方行列で、行列のインデックスの集合はグラフの頂点とみなす。A:n→n, B:m→m、A、Bは隣接行列か、それのベキだの和を取ったりした、ともかくも経路を表現する行列だとする。行列の順序は、成分ごとの比較で考える（バカ順序）。

S:m→n はブール値行列で、普通の行列掛け算の記法で AS ≦ SB が成立するとき、「BはSによりAを模倣する」という。なんで、これが模倣なのか、ということを以下に説明する。ちなみに、図式順で書けば S;A ≦ B;S 。

i,j を[n] = {1, 2, .., n}を走る変数、同じくα, βなどは[m]を走る変数だとする。このような記号を使ったのは、[n]と[m]を完全に区別したいから。AとBを[n]上と[m]上のラベル付き遷移系だとみなす。Sは、[n]と[m]との関係。向きはどっちもいいが、i ～ α などで、iとαがSで関係付けられていることを示す。

Sが模倣関係だと言う定義は：

- i～α, i -(a)-&gt;j ならば、「j～β かつ α-(a)-&gt;β」となるβが存在する。

これを行列計算と論理式で書けば：

&lt;pre&gt;

    S[i←α] = 1 ∧ A[j←i] = a
  -------------------------------
  ∃β.( S[j←β] ∧ B[β←α] = a
&lt;/pre&gt;

aはゼロでなくてSがブールであることから、

&lt;pre&gt;

    A[j←i]S[i←α] = a
  -------------------------------
  ∃β.( S[j←β]B[β←α] = a )
&lt;/pre&gt;

下側の∃βは、a ≦ Σ(β: S[j←β]B[β←α]) という不等号で書ける。a = A[j←i]S[i←α] を使えば：

- A[j←i]S[i←α] ≦ Σ(β: S[j←β]B[β←α])

ここで、iを動かして足し算する、ベキ等性から右辺はいくら足しても変わらないから：

- Σ(i: A[j←i]S[i←α]) ≦ Σ(β: S[j←β]B[β←α])

これは行列の掛け算になっていて、

- (AS)[j←α] ≦ (SB)[j←α]

jとαは任意だったから

- (AS) ≦ (SB)

(AS) ≦ (SB) を仮定すれば、そのまま逆にたどって A[j←i]S[i←α] ≦ Σ(β: S[j←β]B[β←α]) が出る。a ≦ Σ(β: S[j←β]B[β←α]) から ∃β.( S[j←β] ∧ B[β←α] = a は行列計算だけでは出ない。a が素元（超素元）が必要そう。が、むしろ a ≦ Σ(β: S[j←β]B[β←α]) のまま使ったほうがいいような気もする。aが任意の元でこれが成立する。

A[j←i]S[i←α] ≦ Σ(β: S[j←β]B[β←α]) は、Aによる遷移の可能性は、SによりBへ対応付けて考えればすべて尽くされることを示している。

- AS ≦ SB ならば A* ≦ SB*

は、順番にやっていけば出そう、この形でいいのかは自信ないが。欲しいのは、

- A(1(+)S) ≦ (S(+)1)B ならば Tr(A) ≦ Tr(B)

いや、ほんとに欲しいのは：

- Tr(A) ≦ Tr(B) ならば A(1(+)S) ≦ (S(+)1)B となるSが存在する
- ダイクストラ法は、A(1(+)S) ≦ (S(+)1)B となる最大のSを求めることができる。

とりあえず、(a + b)* = (a*b)*b* とか (ab)* = 1 + a(ba)*b とかが機械的に示せないと。


</body>
</day>
<day date="2010-06-22" title="">
<body>
*1277179071*[flash]ビックリしたこと

- お絵描きツールとしての独特さ
- フレームアクションとOnEnterFrameイベントが異なるメカニズムなこと
- シンボルという不思議な概念（プロトタイプ方式のクラス？ リソースセット？）
- 深度とレイヤーが別だったこと
- 深度といいながら、数値が大きいと手前（高さやんけ）
- レイヤーが単にIDEの管理とUIの都合による概念だったこと
- シェイプもどうやらIDEの都合のような
- object階層（OCH）が未だに分からない
- _level0, _level1が未だに分からない

本来統合不可能なIDE（GUI)とプログラミング言語を統合しようとして面妖な物件となったらしい。

</body>
</day>
<day date="2010-06-23" title="">
<body>
*1277253970*[メモ]あとで書く

遷移系について。

*1277253104*[メモ][形式言語理論][DFD][Caty]明瞭オートマトンと近傍とイプシロンパス

ダイクストラ波動を走らせるためには、グラフにサイクルがあってはダメ。正確に言えばあってもいいのだけど（つうか、ないと使い物にならない）、サイクルの原因が一箇所に集中しているようなグラフ。背景は、トレース付き圏の正規形だが、明瞭性とマッチするかどうかが今の問題。

それはともかく、明瞭オートマトンにおけるスター近傍は次の概念にしようかな。まずはout側の近傍の定義

- コスト1以下で中心から到達できるノードの集合と、中心から各ノードに至るパスを構成する辺からなる部分グラフ

in側の近傍は

- コスト1以下で中心へと到達できるノードの集合と、ノードから中心に至るパスを構成する辺からなる部分グラフ

「コストが1」じゃなくて、&lt;em&gt;コスト1以下&lt;/em&gt;が非常に重要。これにより、有用なイプシロン辺を排除せずに済む。

pをノードだとして、Out(p)とIn(p)を次のように定義できる。

- out側の近傍の辺ラブベルを合併した集合 = Out(p)
- in側の近傍の辺ラブベルを合併した集合 = In(p)

Out(p) = 空 と out(p) = 0 が違うところがミソ。境界で止まるイプシロンパスや、境界から出るイプシロンパスは、Out, In に関係しない。

サイクルの入り口にはイプシロンパスが入っても大丈夫みたい。同じく、サイクル出口からイプシロンパスが複数出てもいいのかな？ イプシロンパスが分岐してツリーになるのは許せるけど、イプシロンサイクルはやっぱりダメだな。「イプシロンサイクルを持たない」は死守。

まてよ、イプシロンチェーンとイプシロンツリーの中間に、境界でないない到達点がたかだか1個って条件があるな。これなら、事実上はチェーンのように扱える。境界はスタートノード、サイクル入り口、サイクル出口、ゴールノード。

*1277253739*[雑感][用語法]計算屋さん

コンピュータ技術者を計算機屋さんと呼ぶことがある。カタカナ語じゃなくて良いと思う。が、ハードウェアとしての計算機に興味がない僕などは計算『機』屋さんとは呼べないだろう。計算現象に興味があるのだから、計算屋さん（computing guy）とでも呼んで欲しい。

でも、自称・計算屋さんというと、数値計算を実務としている人みたいで「算盤は得意なんでしょ？」とか聞かれそう。算盤どころか、暗算も筆算もモノスゴク苦手で小学生のドリルもできないな、僕は。計算はできないけど、自称・計算屋さん -- ワケワカラン。

</body>
</day>
<day date="2010-06-24" title="">
<body>
*1277345313*[DFD][高次圏論][プログラム意味論]模倣と一様性

このエントリーの言葉使いは、セリンガーに従う（Categorical Structure of Asynchrony）。

まず、双模倣と単なる模倣、それと2方向模倣は別な概念なんだけど、僕はよくわかってない。セリンガーは双模倣（bisimulation, bisimilar）を扱っているが、ここでは片方向の模倣（simulation, simulable）を考える。

とりあえず、強模倣と弱模倣の定義。ラベル付き遷移系があって、アルファベットに&lt;strong&gt;無音記号&lt;/strong&gt;（silent, unobservable なsymbol, label）があるとする。

&lt;img src=&quot;http://www.chimaira.org/img2/strong-simulation.jpg&quot; /&gt;

遷移系Sが、関係Rにより遷移系Tを強模倣できる（strongly simulable, can simulate strongly）とは、無音記号も含む任意のα, t, t' に対して、上の図のような遷移 s -(α)-&gt; s' in S が存在すること。

弱模倣を定義するには、s -*-&gt; s' と s =(α)=&gt; s' の概念が必要。

- s = s' であるか、sからs'への無音記号だけの遷移列が存在するなら s -*-&gt; s'
- αが無音記号なら、s =(α)=&gt; s' は s -*-&gt; s' のこと、
- そうでないなら、s -*-&gt; s0 -(α)-&gt; s1 -*-&gt; s' となるs0, s1 があるとき s =(α)=&gt; s'

&lt;img src=&quot;http://www.chimaira.org/img2/weak-simulation.jpg&quot; /&gt;

遷移系Sが、関係Rにより遷移系Tを弱模倣できる（weakly simulable, can simulate weakly）とは、無音記号も含む任意のα, t, t' に対して、上の図のような遷移 s =(α)=&gt; s' in S が存在すること。

弱模倣を単に&lt;strong&gt;模倣&lt;/strong&gt;と呼び、関係Rを&lt;strong&gt;模倣関係&lt;/strong&gt;（simulation relation）と呼ぶ。

&lt;strong&gt;初期状態&lt;/strong&gt;（initial state）が1点として指定されている遷移系 (s0, S) , (t0, T)で、(s0, t0)∈R である模倣関係Rがあれば、初期状態付き遷移系における模倣概念になる。

セリンガーの用語で&quot;Hasegawa's uniformity property of traces&quot; とは、トレース付きモノイド圏Cにモノイド部分類（monoidal subclass）Uが付いている状況で、「とあるh∈Uに対して f;(h + X) = (h + Y);g ならば Tr(f) = Tr(g)」が成り立つことである。

- セリンガーはUをモノイド部分圏としているが、長谷川さん自身は圏でない例を出している。
- Uに属する射は一様射（uniform morphism）と呼ぶ。
- この性質を持つトレース、またはトレース付き圏に、一様（uniform）という形容詞を付ける。uniformly traced も使う。
- 一様性（uniformity）は、類Uに対して相対的（with respect to U）に定義される。
- トレースの等しさを主張する命題は、一様性原理（uniformity principle）とも呼ばれる。
- 一様性原理は証明原理で、帰納法（induction）に近い。つまり、一様性原理≒帰納法の原理
- 一様トレース付き圏では、一様性原理を使った証明ができる。

圏Cがトレース付き圏で、さらに順序で豊穣化されているとする。そのとき、

- とあるh∈Uに対して f;(h + X) ⊆ (h + Y);g ならば Tr(f) ⊆ Tr(g)

も一様性原理と呼ぶ。一様射が二重圏の垂直射で与えられる状況が面白いだろう。不等号を2セルで与えれば、もっと一般化できるが、いまんところ事例がない。

*1277367790*[トレース／コンパクト閉圏][メモ][説明]自然性と強度

セリンガーが、トレースの公理に自然性（naturality）、強度（strength）と名付けている。なんで？ と思ったが納得。

タイトニングを自然性と呼んでいるんだけど、Cはモノイド圏（積は+で書く）として、まずは次のような関手を考える。

+ C(A +X, ・+X) : C → Set
+ C(・+X, B +X) : C&lt;sup&gt;op&lt;/sup&gt; → Set
+ C(・+X, ・+X) : C&lt;sup&gt;op&lt;/sup&gt;×C → Set
+ C(A, ・) : C → Set
+ C(・, B) : C&lt;sup&gt;op&lt;/sup&gt; → Set
+ C(・, ・) : C&lt;sup&gt;op&lt;/sup&gt;×C → Set

すると、Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt; は次のような自然変換になっている。

+ Tr&lt;sub&gt;A,・&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt; :: C(A +X, ・+X) ⇒ C(A, ・) : C → Set
+ Tr&lt;sub&gt;・,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt; :: C(・+X, B +X) ⇒ C(・, B) : C&lt;sup&gt;op&lt;/sup&gt; → Set
+ Tr&lt;sub&gt;・,・&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt; :: C(・+X, ・+X) ⇒ C(・, ・) : C&lt;sup&gt;op&lt;/sup&gt;×C → Set

3番目が一番一般的で、左タイトニングと右タイトニングを一緒に表現している。Xはパラメータとして残る。

次に、スーパーポージング公理の簡易版を強度公理と言っている。

- Tr&lt;sub&gt;A+C,B+D&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f + g) = Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f) + g

は、次のように略記できる。

- Tr&lt;sup&gt;X&lt;/sup&gt;(f + g) = Tr&lt;sup&gt;X&lt;/sup&gt;(f) + g

なるほど、うるさいことを言わなければモノイド積に関する強度になっている。ただし、強度をτとすると、

- τ&lt;sub&gt;A,B;C,D&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt; : Tr&lt;sub&gt;A+C,B+D&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f + g) → Tr&lt;sub&gt;A,B&lt;/sub&gt;&lt;sup&gt;X&lt;/sup&gt;(f) + g

と、やたらにイッパイ添字が付く。

セリンガーの定義は、アラン・ジェフリイ（Alan Jeffrey）から引用しているようだが、不思議なことにバニッシングとスライディングがない。対称に関するスライディンだけがあって、それから他のスライディングが出るらしいのだが、どうするのかサッパリわからない。

&lt;b&gt;[追記]&lt;/b&gt;ジェフリイ／セリンガー流だと：

+ 自然性（タイトニング）
+ 強度（スーパーポージング）
+ 対称のスライディング
+ ヤンキング

の4つの公理で済む。ヤンキングを要求しないときは、トレースをフィードバックというから、フィードバック付き圏なら3つしか公理がない。

- http://fpl.cs.depaul.edu/ajeffrey/papers/premonA.pdf

これを読めば書いてある？？

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
<comments>
<comment>
<username>bonotake</username>
<body>僕の理解だと、双模倣は模倣関係がisomorphicになっているもの、です。2方向の模倣というのは互いに模倣関係になっているもの、ということだと思いますが、これだとisoであることまでは要請されません。</body>
<timestamp>1277346596</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>bonotakeさん、ありがとうございます。&lt;br&gt;&gt; 2方向の模倣というのは互いに模倣関係になっているもの、ということだと思います&lt;br&gt;そういうことだと思います。&lt;br&gt;&lt;br&gt;&gt; 双模倣は模倣関係がisomorphicになっているもの、です。&lt;br&gt;これがわからんのですよ。isoってのはどの圏でisoでしょうか？&lt;br&gt;関係圏Relだとしても、isoは全単射になってしまうので、それでは強すぎると思うのです。&lt;br&gt;&lt;br&gt;2方向の模倣では、AがBを模倣するときの関係（状態対応）と、BがAを模倣するときの関係が異なってもいいんでしょうが、&lt;br&gt;同時に（1つの関係で）互いを模倣できるなら双模倣なんかな？ と。&lt;br&gt;&lt;br&gt;他に、{観測的に, 振る舞い的に}{同値, 識別不能} とかの言葉があって、それこそ「区別できません！」</body>
<timestamp>1277354468</timestamp>
</comment>
<comment>
<username>bonotake</username>
<body>何かいい加減なこと書いちゃってすいません。&lt;br&gt;＞関係圏Relだとしても、isoは全単射になってしまうので&lt;br&gt;ですね。圏論の射として考えると、よく考えるとそうなってしまいます。isoと書いたのは不用意でした（ってそう思い込んでいたのですが）。&lt;br&gt;実際には関係のtransposeを考えればいいので、1対1にはならないのですけれど。&lt;br&gt;&lt;br&gt;この文献の2.2節に、双模倣の圏論的な定義が出てます。&lt;br&gt;http://tnt.math.se.tmu.ac.jp/pub/ac03/Hasuo/Hasuo.pdf&lt;br&gt;＞{観測的に, 振る舞い的に}{同値, 識別不能}&lt;br&gt;の定義（と双模倣の違い）も一緒に載ってます。</body>
<timestamp>1277359738</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>bonotakeさん、&lt;br&gt;&lt;br&gt;&gt; この文献の2.2節に、双模倣の圏論的な定義が出てます。&lt;br&gt;&gt; http://tnt.math.se.tmu.ac.jp/pub/ac03/Hasuo/Hasuo.pdf&lt;br&gt;&lt;br&gt;お、これは比較的ページ数少ないから読めそう。&lt;br&gt;ありがとうございます。</body>
<timestamp>1277366050</timestamp>
</comment>
</comments>
</day>
<day date="2010-06-25" title="">
<body>
*1277422136*[メモ][人物][リンク]最近のジェフリイさん

アラン・ジェフリイは随分と実務的なことをやっているんですね。http://ect.bell-labs.com/who/ajeffrey/research-index.html

プロトコルとかXMLとか。覗くとネタが見つかるかも。

*1277422838*[Caty][リンク][MicroApp]microデータモデル

順番に読むと事情がわかる。

- [http://d.hatena.ne.jp/m-hiyama/20100403/1270264048:title]
- [http://d.hatena.ne.jp/m-hiyama/20100412/1271032800:title]
- [http://d.hatena.ne.jp/m-hiyama/20100413/1271120399:title]
- [http://d.hatena.ne.jp/m-hiyama/20100623/1277256666:title]

*1277429520*[Caty]アノテーションデータ

|* 構文       |* 値 |
|foo          | @foo {} |
|foo(&quot;hello&quot;) | @foo {&quot;value&quot; : &quot;hello&quot;} |
|foo(bar=23)  | @foo {&quot;bar&quot; : 23} |
|foo(baz=&quot;hello&quot;, zot=false) | @foo{&quot;baz&quot;:&quot;hello&quot;, &quot;zot&quot;:false} |

&lt;pre class=&quot;code&quot;&gt;
@[internal]
type AnnotationBase = @* {
 &quot;$description&quot; : string? ,
 &quot;$predefined&quot; : {*:any?}? ,
 * : any?
};

@[annotation]
type foo = @foo {
 &quot;baz&quot; : string,
 &quot;zot&quot; : boolean? 
} &amp; AnnotationBase;
&lt;/pre&gt;

*1277429521*[Caty]プロパティとプロパティリスト

プロパティの出現性（occurrence）は次のようになる。

|* 名前       |* 正規表現 |* Caty表現 |
| once        | X         | X または [X]  |
| optional    | X?        | X? または [X]?|
| one-or-more | X+        | [X, X*]   |
| any-times   | X*        | [X, X*]?  |

X* を [X, X*]? と書く理由は、Web入力（フォーム入力）では、空リスト[]の表現方法がないから。

*1277430043*[Caty]aka宣言

&lt;pre class=&quot;code&quot;&gt;
module my
 aka [&quot;http://www.chimaira.org/schema/my&quot;, &quot;http://caty.caty-sites.net/types/my&quot;]
;
&lt;/pre&gt;

とか？

</body>
</day>
<day date="2010-06-26" title="">
<body>
*1277526668*[復習][モナド][形式言語理論]モナドの作用乗法って？

- [http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561239:title]

ここらのことが、今読むとどうも分からないなー。

Lは集合圏の上で定義された言語自己関手を意図しているんだろう； L(S) = Pow(S&lt;sup&gt;*&lt;/sup&gt;)。Mは適当な指標Σによる項生成関手かな、M(S) = Term&lt;sub&gt;Σ&lt;/sub&gt;(S) とか。ρは、なにか標準的な項の評価；たぶん正規表現の標準的な意味とかだろう。ρ:Term&lt;sub&gt;Σ&lt;/sub&gt;(S) → L(S) は、アルファベットS上の正規表現を同じS上の言語に対応させる。

τは、言語から生成した正規表現を言語として解釈することか。

*1277529223*[その他代数][気付いた][小咄]標数1の代数の圏、掛け算から足し算

コンヌとか黒川さんが、「標数1」とか言っている。標数が1の体を生真面目・杓子定規に考えれば自明。「いったい何を言ってんだろう？？」と不思議でしょうがなかった。あんまり不思議なんで興味が湧かなかったよ。

生真面目・杓子定規に考えてはダメで、半体（semi-field）とか半環（semi-ring）の圏で考えるのだ。Field ⊆ SemiField ⊆ SemiRing だから、標数pの体に関しては、Field&lt;sub&gt;p&lt;/sub&gt; ⊆ SemiField&lt;sub&gt;p&lt;/sub&gt; ⊆ SemiRing&lt;sub&gt;p&lt;/sub&gt; 。SemiRing&lt;sub&gt;1&lt;/sub&gt; とかなら自明にならない。

体の単元（0以外）の群の代わりに、半環の乗法モノイドとかを考える。 0 = 1 だと0を除くと1もなくなるので、モノイドにもならなくなるが、別にそれならそれでかまわん、と。引き算もできないが、それもかまわん、と。

そもそも、モノを集合と要素で考えている限りダメそうだ。モノに要素が全然ないとか1個しかないというのは、集合圏で点の集合をみてるだけだから、それでモノが空だとか単元だとか断言はできない。外延的点の双対側で、基礎体Kと座標環Rで考えると、R→K が点で、Kを変えれば点のあるなしも変わる。体Kと環Rを半体／半環にまで一般化すると、今まで点をもたないと思っていた対象物にも点が見つかるかもしれない。

それはそうと、コンヌが掛け算から足し算を作る方法をすごく丁寧（馬鹿丁寧と言えるほど）に書いていて、基点つき集合Xに群Gが作用しているとき、s:X→X がサクセッサらしきものである条件は：

- sは全単射
- s(x&lt;sup&gt;-1&lt;/sup&gt;・y・x) = x&lt;sup&gt;-1&lt;/sup&gt;・s(y)・x
- s(0) ≠ 0 （0は前もって特定されている基点）

だいたい、x + y := x・s(x&lt;sup&gt;-1&lt;/sup&gt;・y) のように定義する。

あーそうそう（と脈絡がメチャクチャだが）、次のものは標数1だ。

+ 0以上の実数の、max-plus代数
+ 0以化の実数の、min-plus代数
+ 1以上の実数の、max-times代数
+ 1以下の正実数の、min-times代数

*1277542461*[Caty][形式言語理論][DFD]ふうううううう、なんとかなりそう、ダイクストラ法

ふううううううーーーーーーーーー、ふうううううううううーーーーーーーーーーーー。

正規言語の包含性判定にダイクストラ法を使うアイディアはなんとか救えそうだ、、、実に紆余曲折だったが。

実行用のオートマトンと判定用のオートマトンはまったく違ったアィディアで作らないとダメだった。

- 実行用では、無音遷移も決定性があったほうがいい。無音遷移パスはチェーンとなる。
- 判定用は、無音遷移が長いのが問題、長さ1の無音遷移に限定すべき。決定性は犠牲にする。

判定用のオートマトンの条件：

+ スタートノードとルーピング始境界は区別される。
+ ゴールノードとルーピング終境界は区別される。
+ スタートと始境界は入る辺を持たない。
+ ゴールと終境界は出る辺を持たない。
+ 長さが2以上の無音遷移パスを持たない。

無音遷移で決定性を壊しているので、アルゴリズムは非決定性でも通用しそうだ。が、無音遷移以外は決定性であるオートマトンを対象とする。

グラフ上でステップ1以下の近傍を考える。このなかでコスト0（入力なし）で行ける範囲が無音近傍（と定義する）。自分自身（近傍の中心）は明らかの無音近傍に入るので、無音近傍は空ではない。

状態点s（in S）と状態点t（in T）が、既に模倣対応で結ばれているとき、sの無音近傍とtの無音近傍も模倣で結ぶ。このとき、完全二部グラフを作る。無音近傍に含まれる状態点の個数を n, m （それぞれS内、T内）とすると、模倣関係グラフは n×m 本の辺を含む。1本は既に存在するので、新たに加える関係辺は n×m - 1 。

ステップ1以下の近傍で、無音でない点の全体を有音近傍と呼ぶ。有音近傍は決定性。有音近傍の点の個数をkとすると、新しい模倣関係辺はk本。無音と有音を足すと、n×m - 1 + k 本の関係辺を加えることになる。ダイクストラ波動のホイヘンス原理による進行は、n + k個の新しい波頭集合（既に通ったところを再度通るかも知れない）を作る。

今言ったような手順を、ダイクストラ波動の波頭集合のそれぞれの点、それぞれの関係辺ごとに行う。波頭集合の点の個数より関係辺は多くなるのが普通。無音辺があると、そこで完全二部グラフを作るので、関係辺は増える。この部分が手間になっているので、できるだけ無音辺を減らすようにすべきだ。

波頭集合は、無音遷移で来た点と有音遷移で来た点では扱いが異なる。無音遷移のみで到着した状態点では模倣の構築が失敗しても許される。失敗した点は、単に波頭集合から取り除かれるだけ。有音遷移で到着した点では失敗すればただちにアルゴリズム全体が失敗して終了する。ここでの失敗は模倣構築の失敗で、正常処理なのは言うまでもない。

波頭集合内で、失敗を許される点と許されない点を識別する必要がある。相手方を走るダイクストラ波動は、相手方の終境界を超えて走る可能性があるので、ルーピング（ワープ）して追跡する。

全体的な失敗成功の判定だが：

+ スタートノードからのゴールまたは終境界まで到達できたか？ 到達前に模倣構築が行き詰まれば失敗。
+ 終境界の各点を始境界の対応点と同一視する。始境界の点を選んで、同じ手順を繰り返す。
+ L0とL1をルーピング境界として、I:L0→L1⊆S を同一視対応。構築した模倣関係をRとして、RのL0への制限が、I;R で与えられるなら模倣は整合的。

まだまだ細部の場合分けがあるんだけど、方針はこんな感じかな。

&lt;b&gt;[追記]&lt;/b&gt;背景はこんなだろう。

+ 都合のいいオートマトンのクラスを決める。
+ ルーピング境界付きのオートマトンつうもんを定義する。
+ ルーピング境界付きのオートマトンに対して閉包演算を考える。
+ ルーピング境界付きのオートマトンMがあり、別なオートマトンNがMを模倣し、かつ模倣関係がルーピング整合的なとき、Lang(cl(M))⊆lang(N)
+ ルーピング整合的な模倣関係と閉包オートマトンの模倣関係は1：1に対応する。特に、最大のルーピング整合的な模倣関係と、閉包オートマトンの最大模倣関係は対応する。
+ 適当な条件下で、「Lang(cl(M))⊆lang(N) ならば、NはMをルーピング整合的に模倣できる」。
+ 適当な条件下で、「ダイクストラ法は、最大のルーピング整合的な模倣を求めることができる」。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2010-06-28" title="">
<body>
*1277684532*[Caty][形式言語理論][DFD]拡張ダイクストラ法：波頭集合の作り方

波頭集合はステップベースじゃなくて、やっぱりコストベースのほうがいいみたいだ。ステップは、遷移グラフの辺を通るごとに1ステップと勘定する。コストは入力した（あるいは通過した）記号の数。無音遷移はステップ1でコスト0。

ある点からの次の波頭集合は、コスト1で行ける点の全体。ただし、コスト0で境界に行ければ、それはそれでよい。オートマトンの標準形として、長さ2以上の無音遷移パスがないようにしておけば、コスト1の波頭集合までのステップ数は1または2に限られる。オートマトンの決定性（無音遷移は非決定的だが有音遷移は決定的）から、中心＝波源から波頭までのコスト1放射線は一意に決まる。これは、球面を（ニュートン流に）粒子の散乱放出（爆発？）と考えていいことになる。各粒子の軌跡が確定的に（あるいは古典的に）決まる。

「球面波＝粒子群の炸裂」描像は局所的で、これを繋ぎ合わせ／寄せ集めると、決定性から古典軌道の束が描ける。局所的な情報から「粒子の古典軌道の束」の統計的量を作り出す操作がファインマン／クリーネ総和（有限離散的経路積分）。

&lt;em&gt;具体的なアルゴリズムについても書いておく。&lt;/em&gt;

関係辺（模倣関係の要素）の集合を2つ考える -- 候補辺の集合Cと確定辺の集合D。オートマトンをM, Nとすると、CもDも |M|×|N| （状態の直積）の部分集合。初期値は、C={(s0, t0)}, D=空集合。候補辺のそれぞれに対してダイクストラ法を適用して、確定辺を増やし、次の候補辺の集合を求める。確定辺は、1回のアルゴリズム・ステップで1, 2 4本（のいずれか）ずつ増える。確定した候補辺はCから除外され、次の候補辺群がCに追加される。次の候補辺は、ダイクストラ波動の波頭集合（コスト1近傍の境界）から決まる。

ダイクストラ法を進めていくと、いずれは終境界まで達してしまう。終境界点での候補辺集合を記録してラウンド0を終える。ラウンドとは、ダイクストラ波動を1回走らせる試行のこと。ラウンド0の最後で得られた候補辺の集合を始境界側に移して、ラウンド1を始める。ラウンド1の開始点は、ラウンド0で到達した終境界の点を1つ選ぶ。

ラウンド0で通過した点はマークしておく。ラウンド1は、“ラウンド0で通過した点または終境界”に到着したら終了である。ラウンド2は、それまでのラウンドで到着して、まだやってない終境界の点を1つ選んで実行する。&lt;b&gt;[追記]&lt;/b&gt;&lt;em style=&quot;font-size:x-large&quot;&gt;いや、この記述は間違っているな。正確には…、後で書く。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

終境界の点（始境界と考えても同じ）は有限個しかないから、ラウンドも有限回で終わる。すべてのラウンドによって得られた確定辺の蓄積が最大の模倣を与える。途中で失敗すれば、模倣不可能を意味する。ラウンドって概念は、実際には不要だと思う。今のところ、僕が考えやすいから使っている。アルゴリズムをキチンと書き下せば、&lt;em&gt;ラウンドはなくなる&lt;/em&gt;ハズだ。

遅延波の到着、あるいは同じことだが波頭が複数回の通過すること（多重掃過）をよく考えないといけない。遅延波を無視してはいけないが、有限回通過するうちに、必ず状況が完全に再現される。つまり、無限回の通過でも有限周期をもつわけだ。これはポンプの補題に対応する。

*1277684743*[Caty][形式言語理論][DFD]拡張ダイクストラ法の参考になったこと

妄想をたどるために使った概念や事実や定理：

+ ブラーグマンクライン＆ウッド（Bruggemann-Klein - Wood）の1-非曖昧性（出発点）
+ マクノートン／山田／グラシュコフの方法
+ Hovlandアルゴリズム（ライバルとして）
+ ホイヘンスの原理
+ ダイクストラ法
+ ファインマン／クリーネの総和公式
+ 加法的トレースの概念（セリンガー）
+ 長谷川の一様性原理
+ 強・弱の双模倣、模倣の概念
+ 結び目のマルコフの定理とその絡み目（タングル）版
+ マルコフ・トレース
+ マスロフ脱量子化
+ コボルディズム圏
+ 太鼓の形を聞き分ける話

ところで、長谷川真人さんの次の2つはいい読み物だ。

- 論説「再帰プログラムの意味論について」 http://www.kurims.kyoto-u.ac.jp/~hassei/papers/sugaku07.pdf
- スライド「再帰プログラムの幾何」 http://www.kurims.kyoto-u.ac.jp/~hassei/slides15sep06s.pdf

</body>
</day>
<day date="2010-06-30" title="">
<body>
*1277872470*[Caty][形式言語理論][DFD]拡張ダイクストラ法を記述する

N、Mがオートマトン、S=|N|, T=|M|は状態集合。s0, t0はスタートノード。次がアルゴリズムのステップごとの入力になる。

+ 候補辺集合 C⊆S×T、Cは空ではない。
+ 確定辺集合 D⊆S×T、Dは空でもよい。
+ 調べるべき候補辺 r∈C

CとDを更新してステップの結果とする。

+ r∈D ならば、Cからrを削除して終り。
+ r = (s, t) として、sにダイクストラ法（ホイヘンス原理）を適用する。
+ 失敗したら、アルゴリズム全体が失敗。サヨナラ。
+ 成功したら、rと他の辺（1本または3本）をDに追加する。
+ Cからrを削除する。
+ 新しい波頭集合をCと合併する（波頭集合は空かもしれない）。

全体の制御は：

+ 初期状態は、C = {(s0, t0)} D = {} とする。
+ ステップの実行後にCが空になれば成功。Dが最大模倣を与える。
+ ゴールノードの対を (s1, t1) として、(s1, t1)∈D を調べる。YESなら成功、NOなら失敗。
+ ステップ内で失敗すれば、N上のダイクストラ波動に対するM上の模倣波動（simulation wave）を作れないことだから、アルゴリズム全体が失敗。

と、こうしてみると、拡張ダイクストラ法のキモは、お膳立ての部分だな。事前にオートマトンをいじって標準形にしておけば後は造作無い。特に無音遷移パスの長さを1に限定するのがポイント。これによって、複雑化と計算負荷の元凶である無音遷移の取り扱いを現実的にしている。

無音遷移は単なる悪者ではなくて、遷移の逆流や混線を防いでくれる。無音遷移なしでサイクルの処理はできない。本質的に役に立つヤツなんだが、いかんせんコストが高いので無駄に増やしたくはないのだ。

ここまで煮詰まれば、後は知的&lt;em&gt;肉体労働&lt;/em&gt;あるのみ。

+ 実験
+ 改善と変更
+ テスト
+ 完全に場合分けして、細部まで証明

改善に関しては、実行用オートマトンと共用にする手段だな。それができれば、コンパイラ実装の手間はだいぶ減る。

最終的には割とコンパクトな実務的アルゴリズムになりそうだ。（が、まだ安心はできん）

</body>
</day>
<day date="2010-07-01" title="">
<body>
*1277942031*[リンク][高次圏論] The Power of Negative Thinking

次の文書の2章がネガティブシンキングの話です。

- http://math.ucr.edu/home/baez/cohomology.pdf

10ページから17ページまで。

*1277942282*[Caty][形式言語理論][DFD]無音近傍の形状

無音近傍とは、近傍の中心点からコスト0で行ける点の集合。中心点そのものが入るから、常に無音近傍は空ではない。

で、今の問題は、この無音近傍の形状と標準形をどう定めるか。標準形状を決めたら、それを扱うアルゴリズムも決まる。標準形状としては、スター型とチェーン型の2つの候補がある。

*1277947580*[お絵描き][トレース／コンパクト閉圏][形式言語理論]絵算の定石

最近またお絵描きしている。頻繁に使う絵算手法をまとめておく。

まずはトレースに関するスライディング。(∇;f) をまとめてスライドしているが、こういう感じのスライディングは多い。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/sliding.jpg&quot; /&gt;

次はアンワインディング。箱に巻き付いているワイヤーをほどくのだが、箱をクロス（対称）にそってスライドしてからヤンキングで伸ばすことだ。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/unwind.jpg&quot; /&gt;

クリーネスターの表現として、Tr[(1(+)a);∇;Δ] = a* というのがあるが、これもよく使う。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/kleene-star.jpg&quot; /&gt;

このクリーネスター公式の証明は、次のスター積公式の証明の一部として示す。

さて、コンウェイのスター積公式 (ab)* = 1 + a(ba)*a は次のようになる；前半で Tr[(1(+)a);∇;Δ] = a*  を示している。これには、∇;Δ = |X|、Δのスライディング、アンワインディング（ヤンキング）を使っている。この結果を使って後半でスター積公式。Δの余線形性（コピー）、∇のベキ等線形性（マージ）も使っている。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/conway-prod-star.jpg&quot; /&gt;

A = [0 1/ 1 a] という行列だとして、加法的トレースを取るとクリーネスターとなる。つまり、Tr(A) = a* 。行列を使わないなら、Tr[(1(+)Δ);(X(+)a);(1(+)∇)] = a* 。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/additive-trace.jpg&quot; /&gt;


</body>
</day>
<day date="2010-07-02" title="">
<body>
*1278052178*[用語法][圏一般論]なんだ、algebroidって線形圏か

- http://ncatlab.org/nlab/show/algebroid

</body>
</day>
<day date="2010-07-03" title="">
<body>
*1278135312*[圏一般論][用語法]零付き圏

吸収元（absorbing element）を零と呼ぶのは混乱と誤解のもとになる。例えば、実数加法群で0は単位元だが吸収元ではない。∞を入れれば吸収元となる。&lt;em&gt;それは承知で&lt;/em&gt;、吸収元の別名として零（ゼロ）を使うことにする。ただし、吸収元は（0, Oではなくて）zかZで表すことにする。

圏Cと射のクラス Z⊆C の組 (C, Z)が零付き圏（category with zeros）だとは：

+ 任意のC(A, B)内に、Zの射がただ1つだけある。
+ z, z'∈Z で結合可能なら、z;z'∈Z
+ 任意のCの射fに対して、z, z'∈Z で結合可能なら、z;f ∈Z、f;z'∈Z

部分半圏の言葉を使えば：

+ ZはCの部分半圏
+ Zは広い（broad）部分半圏である。
+ Zはやせた半圏である。
+ Zに属する射は吸収的（absorbing）である。

零付き圏（吸収射付き圏）は、吸収元付きモノイドの圏化バージョンとなる。基点付き集合の圏、行列圏がその例となる。


</body>
</day>
<day date="2010-07-05" title="">
<body>
*1278287625*[圏一般論]米田埋込みと関手のモデル圏

Cが圏で、Cからの集合圏への共変関手を単にC-関手と呼ぶことにする。C-関手の全体は&lt;b&gt;Set&lt;/b&gt;&lt;sup&gt;C&lt;/sup&gt; だが、上付きが嫌なら [C, &lt;b&gt;Set&lt;/b&gt;] を使う。Cを[C, &lt;b&gt;Set&lt;/b&gt;]に米田埋め込みできるが、埋め込み自体は&lt;em&gt;反変関手&lt;/em&gt;になる。A∈|C|として、Aの埋め込み像をA_ とすると、関手 A_ は共変関手である。

- A_(X) = C(A, X) or A_ = C(A, -)
- A^(X) = C(X, A) or A^ = C(-, A)

普通は、A|→A^ を使うことが多い。このとき、埋め込み自体は共変で、A^はCから&lt;b&gt;Set&lt;/b&gt;への反変歌手となる。

米田の補題は、

- Nat(F, C(-, A)) = F(A) or Nat(F, A^) = F(A)
- Nat(C(A, -), F) = F(A) or Nat(A_, F) = F(A)

F∈[C, &lt;b&gt;Set&lt;/b&gt;]を固定して、Fのオーバー圏を考える。[C, &lt;b&gt;Set&lt;/b&gt;]/F ね。特に、ρ:A_ → F という形のオーバー圏の対象は、A_ と ρ∈F(A) の組で与えられる。AとA_を同一視すれば、Aとρ∈F(A)の組。

すると、Cを米田埋め込みした先で、特定のC-関手をベースとしたオーバー相対対象を考えることは、Aとρの組を考えることに等しい。Cの米田埋め込みの像をC_ として、C_/F をFモデルの圏とコンヌは呼んでいる。

*1278287811*[Caty][形式言語理論][DFD]無音近傍の形状はチェーンに決めた

決めた。実行が速いし簡単。推論が大変になるけど、トレードオフ。

&lt;img src=&quot;http://www.chimaira.org/img2/silent-chain.jpg&quot; &gt;

*1278289932*[DFD][トレース／コンパクト閉圏][お絵描き]力学、トレース、行列

だいぶ前に、スターバックスのナプキンに絵を描いてスキャンした（そんとき説明も付けていたんだった）。なんか&lt;em&gt;古代の壁画&lt;/em&gt;みたいだが。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/dynamics-additive-trace_2.jpg&quot; &gt;

&lt;a href=&quot;http://www.chimaira.org/img2/dynamics-additive-trace.jpg&quot; &gt;絵のみ：dynamics-additive-trace.jpg&lt;/a&gt;

左から右、上から下の順で説明をする； 自分で納得してこれだけの絵を描けるようになるまで何年かかったことか（ため息）。

最初の絵は、連続空間（多様体）上の境界付き力学系。トーラスに2個穴を開けた図形の上に力学系＝ベクトル場がある。赤でA、Bと書いてあるところは、本来は力学系自体を構成しない。境界である穴（の円周）をキレイな形に調整するために襟（カラー）を着けている。Aが入り口の襟で、Bが出口の襟。コボルディズムで繋ぐときも襟があったほうが作業しやすい。

このような境界付き力学系の離散版を考える。連続力学系を実際に離散近似するのとは&lt;em&gt;違う&lt;/em&gt;が、概念的に参考にする。n, m, k は、離散版における点の個数。入り口境界上にn個の点、出口境界上にm個の点、力学現象が起きている内部Xにk個の点。

最初に、行列の2部グラフ表示で考える。n+k→m+k の行列。入り口の襟をAで表し、内部力学をX、出口の襟をBで表す。矩形方陣としての行列は最後の絵にある。二部グラフ表示を描きやすいように簡略化すると右側のワイヤー図。A, B, Xは適当な符丁（団子とか）にしている。

ワイヤー図のトレースは何度もやっている（例えば、http://d.hatena.ne.jp/m-hiyama-memo/20100701/1277947580 とかもヒントになる）。Tr[(A + Δ);(σ + X);(B + ∇)] = A;X*;B という公式。

通常の行列を使って書くと、一番下の形。ここで、ブロックA, Bの位置がいつもと違うが、ブロックの配置はあんまり問題にならない。A、B、X の役割が問題。Aが入力、Bが出力、Xが遷移系。

</body>
</day>
<day date="2010-07-06" title="">
<body>
*1278378385*[復習]代数、余代数、双代数

ここらへんのことって、なんとか纏まりがつかないのかな？ ホップ代数とかになるんじゃねえの？

- [http://d.hatena.ne.jp/m-hiyama/20090121/1232524019:title]
- [http://d.hatena.ne.jp/m-hiyama/20090212/1234421662:title]
- [http://d.hatena.ne.jp/m-hiyama/20090109/1231471946:title]
- [http://d.hatena.ne.jp/m-hiyama/20100610/1276135800:title]

*1278381395*[雑記]DotsterのUIは相変わらずヒドイ

いつも画像はリンク切れだし、、、

アンカーと説明文がまったく区別つかない。マウスポインタを動かしてアンカーをさがす。宝探しか？

わざとらしいボタンとかは下品に見えると思っているのか？それにしてもお上品すぎて、情報不足。タブもまったくタブに見えないし（単なるテーブルの見出しに見える）。どのタブがカレントかの表示も一切ない。マウスに反応しないタブがカレントってだけ。

メインメニューの位置が画面ごとに変わるのか、、、そもそもメニュー構成が分かりにくい。サブメニューのデザイン（レイアウト）がバラバラなのも問題。すべて統一されていれば、慣れれば操作できるが、画面ごとに操作性が違う。って、なに考えているかワカラン。最悪の選択ばっかりしている。

*1278381810*[復習][その他代数]いまいち分からんが、ホップ代数っぽいかもなー

- [http://d.hatena.ne.jp/m-hiyama/20090109/1231471946:title]

「・」で積（乗法）、Δで余乗法を表すとして、次の公式は成立する。

- Δ(α・β) = Δ(α)・(1(×)β) + (α(×)1)・Δ(β)

α, βはグラフ上のパス。積は連接で与えられる。積を適当な係数のベクトル空間に拡張しているけど、連接ができないときは0にする。Δ(x) は、パスxを“因数分解”した結果（複数）をテンソル積と和で列挙した形。左辺に登場する「・」は、もとの積をテンソル積空間に拡張したもの。モノイドの直積に積を入れるのと同じ。

この等式の背景は簡単で、α・βの因数分解は、αの分解にβを掛けたものと、βの分解にαを掛けたものの合併だから。

&lt;img src=&quot;http://www.chimaira.org/img2/path-factors.jpg&quot; &gt;

これを見ていると、ツリーの接木演算も足し算で表現可能だな。因数分解と整合するかどうかわからんが。

&lt;img src=&quot;http://www.chimaira.org/img2/tree-mult.jpg&quot; &gt;

*1278384581*[プログラム意味論][マンダラ]マンダラ0

マンダラ仮説は僕の作業仮説で妄想かもしれない。

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%DE%A5%F3%A5%C0%A5%E9

マンダラ圏（マンダラケではない）は、仮説的、あるいは空想上の圏だ。が、実在するだろうと信じている。信じているだけではラチがあかないので、なんとか構成しよう。一度に構成しようとしても無理があるので、最初は叩き台。

最初の叩き台をマンダラ0とする。マンダラ0への要求は：

+ 直和（双積）と直積（テンソル積）を持つ。
+ 和と積に関して、半環圏である。
+ 加法的なトレースと乗法的なトレースを持つ。
+ 状態空間のグルーイングに関してコボルディズム類似の圏となる。
+ 模倣を矩形2セルとして二重圏となる。
+ 双模倣は亜群となる。
+ 入出力結合がある。
+ 入出力結合と状態空間の関係をモナド類で記述できる。
+ インターフェース（指標）とアルファベット（アクションラベルセット）の概念を持つ。
+ 並列性や非同期の説明ができる。
+ 入出力結合からコンパクト閉圏が作れる。

以下のような概念も組み入れないとな：

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=System%28
- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=System%28

あと、これとかも：

- [http://d.hatena.ne.jp/m-hiyama-memo/20070602/1180759386:title]

いろいろ考慮するとドンドン難しくなるけど、、、

</body>
</day>
<day date="2010-07-07" title="">
<body>
*1278460684*[プログラム意味論][マンダラ]マンダラの綴り

マンダラの綴りはmandala、mandaraではない（が、地名Mandaraがある）。


</body>
</day>
<day date="2010-07-08" title="">
<body>
*1278550171*[DFD]ホイヘンスの原理の局所版と大域版

ホイヘンスの原理には、1ステップ近傍だけを相手にする局所版と、始点から終境界までを問題にする大域版があると思った。どっちも重ねあわせの原理が成立することがガンモク。

ところで、1ステップ近傍って概念が無音遷移のせいで不安定なのだ。この不安定性が定義の多様性（悪く言えば混乱）につながっている。ただしこれは、ステップ近傍で空間をスライスしていくときの自由度にもなるので必ずしも悪いことではない。

連続空間では、1ステップ近傍に相当するのが無限小近傍で、無限小近傍の表現は接空間になる。無限小近傍＝接空間は安定した概念だが、有限離散ではそうでもない。面白いといえば面白い。

*1278550332*[プログラム意味論][高次圏論][マンダラ]マンダラ0の表記

マンダラ0は、Mandと書こう。いちいち0は要らないだろう、しばらくは0だからな。

まずは、Aを入力仕様、Bを出力仕様、Pを内部仕様とする遷移変換系（トランスデューサ）の圏をMand(A, B; P)と書くことにする。Mand(A, B; P)は3項のホムセットの形をしているが、実際にこれはホム二重圏になっている。Mandは、トレース付き半環二重圏で豊饒化された圏（疑圏かな）という、とんでもない構造を持っている（と思われる）。

Mand(A, B; P)とMand(B, C; Q)の対象は結合可能で、Mand(A, C; P×Q)の対象を与える。が、この定義は当然にとても複雑だ。マンダラだからなー。どんだけの等式、不等式を書き下したらいいか見当つかん。整合性の条件だけでもとにかくイッパイある。



</body>
</day>
<day date="2010-07-09" title="">
<body>
*1278633461*[DFD]ホイヘンスの原理のスライス版

ホイヘンスの原理の局所版と大域版と中間のようなものが欲しい。次のような定式化になるはずだ。

Sが状態空間で、この上に力学系Xが載っている。IとFがそれぞれ始境界、終境界とする。IとFは無共分で、襟（カラー）付きだとする。別な言い方をすると、Iの点はすべて湧き出し点で、Fの点はすべて吸い込み点。

力学系Xの(I→F)のS行列をs&lt;sub&gt;X&lt;/sub&gt;(I, F) とする（ンギャ、状態空間のSとかぶった、S行列を小文字にする）。BをSの部分集合として、s(I, F) = s(I, B);s(B, F) と因数分解できないか？ ってこと。Bの形状が良い形状ならできると思う。

「良い形状」って何よ？ ってことだが、Bが波頭集合であるときは、ホイヘンス原理＝ダイクストラのアルゴリズムそのものと言ってよい。波頭集合より少し崩れた形でも使えると便利。

実際に使うときは、IとBで挟まれる帯状の領域をスライスされた領域と考えて、空間のスライス分解が行列の因数分解に対応するという形で使うだろう。だから、スライス版。

*1278634931*[DFD]経路和公式の確認

グリーン関数Gって、f'(x）= ∫G(x,y)f(y)dy といった使い方するらしい。プロパゲーターって、まーグリーン関数なんでしょ。たぶん。で、ファインマン・クリーネの公式（経路和）は次の形に書ける。

- Prop&lt;sub&gt;A&lt;/sub&gt;(q←p;n) = A&lt;sup&gt;(n)&lt;/sup&gt;[q←p]
- SMat&lt;sub&gt;A&lt;/sub&gt;(q←p) = Prop&lt;sub&gt;A&lt;/sub&gt;(q←p;∞) = A&lt;sup&gt;(∞)&lt;/sup&gt;[q←p] = A&lt;sup&gt;*&lt;/sup&gt;[q←p]

S行列は、プロパゲーターの時間パラメーターを無限の未来にしたものと解釈。



</body>
</day>
<day date="2010-07-10" title="">
<body>
*1278733964*[物理っぽい][その他代数]マスロフのプランク定数と標数1の代数

k = 1/h として、マスロフ和の定義は：

- x [+]&lt;sub&gt;k&lt;/sub&gt; y = (x&lt;sup&gt;k&lt;/sup&gt; + y&lt;sup&gt;k&lt;/sup&gt;)&lt;sup&gt;1/k&lt;/sup&gt;

もちろん、

- x [+]&lt;sub&gt;k&lt;/sub&gt; y = (x&lt;sup&gt;1/h&lt;/sup&gt; + y&lt;sup&gt;1/h&lt;/sup&gt;)&lt;sup&gt;h&lt;/sup&gt;

となる。マスロフのプランク定数hよりは、その逆数のほうが（僕は）どうも扱いやすいので、kを使う。とりあえず次の事実がある。

+ k = 1 でマスロフ和は普通の和
+ k→ +∞で、マスロフ和はmaxになる。
+ k→ -∞で、マスロフ和はminになる。
+ k = 0 でマスロフ和は定義できない。

k = 0 に近づく方向として、k→ +0 と k→ -0 があるが、0ではないxを固定して、x&lt;sup&gt;ε&lt;/sup&gt; （ε≒0）は、符号の影響を受けなくて x&lt;sup&gt;ε&lt;/sup&gt; ≒ 1 となる。εの絶対値が小さい時は、εの逆数の近似値を（絶対値が）巨大な整数Nだとして、共に0ではないx, yに対して：

- x [+]&lt;sub&gt;ε&lt;/sub&gt; y ≒ (1 + 1)&lt;sup&gt;N&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;

つまり、

- ε＞0  ならば、x [+]&lt;sub&gt;ε&lt;/sub&gt; y ≒ ∞
- ε＜0  ならば、&lt;del datetime=&quot;2010-07-10T18:58:31+09:00&quot;&gt;x [+]&lt;sub&gt;ε&lt;/sub&gt; y ≒ 1&lt;/del&gt;

プランク定数hに戻れば、

- h→ +∞ でマスロフ和は発散する。
- h→ -∞ でマスロフ和は自明化する。&lt;del datetime=&quot;2010-07-10T18:58:31+09:00&quot;&gt;（x≠0, y≠0 なら、x + y = 1）&lt;/del&gt;

k = 0 の付近で、kが正負の両方の場合を考慮して0-マスロフ和を定義することは本質的にできない。不定となる。コンヌが&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;での和は「0/0 みたいな不定」と言ったのはこんな事情かもしれない。

*1278745868*[人物][メモ]デイトマー

Deitmerは「デイトマー」でいいようだ。

&lt;b&gt;[追記]&lt;/b&gt;間違った、Deitmarだ。でもたぶんデイトマーだろう。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2010-07-13" title="">
<body>
*1278984305*[圏一般論][人物][雑記]スキームなんて空気 -- という感覚に驚くオジジ

&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;に関連して、アルベルト・ヴェッザニ（Alberto Vezzani）という人が、デイトマー（Deitmar）とトゥエン／ヴェキ（Toen-Vaquie）のスキーム論を比較して解説している。チラリと眺めた。

- http://arxiv.org/abs/1005.0287

これらの人々はみんな若いのだと思う。その感覚にオジジ（僕＝檜山）は驚いてしまう。彼らにとって、スキームなんて空気のようなもので、たぶんあえて意識したりしないのだろう。トゥエン／ヴェキ流（ヴェッザニが脚色しているかも）のアフィンスキームの定義はなんと：

- Ringを可換環の圏だとして、Ring&lt;sup&gt;op&lt;/sup&gt;をアフィンスキームの圏と呼ぶ。

これだけ！ すごい割り切りようだ。前層の定義は、もちろん [C&lt;sup&gt;op&lt;/sup&gt;, &lt;b&gt;Set&lt;/b&gt;]である（これはそうビックリはしないが）。

一方で、素朴集合論と点概念を平気で使ったりする。エタールと同じような開はめ込み（open immersion）という概念があるのだが、その定義は素朴で：

- U⊆X が開集合のとき、U→X を開包含（open inclusion）と呼ぶ。
- YがUと同型で、具体的な同型 i:Y→U が与えられている。
- iと開包含の結合を開はめ込みと呼ぶ。

開はめ込みの族 (i&lt;sub&gt;α&lt;/sub&gt; | α∈Λ) がザリスキー被覆だとは、単に「Σ(i&lt;sub&gt;α&lt;/sub&gt; | α∈Λ) → X が全射」というだけである。で、幾何学的な背景とは、ザリスキー被覆の全体が圏のグロタンディーク前位相を定義するんだ、という主張でほぼ尽きている。技巧的なことはせずに、単純な定義を採用して、とにかくアッサリしている。そのアッッサリさに驚いてしまうのですよ。

さて、トゥエン／ヴェキ流のスキーム論だが： Abをアーベル群の圏として、適当な圏C上の可換モノイドの圏をCMon(C) と書けば、Ring = CMon(Ab)  となる。アフィンスキームの圏は、Ring&lt;sup&gt;op&lt;/sup&gt; = [CMon(Ab)]&lt;sup&gt;op&lt;/sup&gt; なので、Abを任意の（ただし都合がいい）圏Cにしてしまえば、[CMon(C)]&lt;sup&gt;op&lt;/sup&gt; がCベースのアフィンスキームの圏。アフィンスキームの張り合わせが一般のスキームとなる。Cは動かしていいので、Cごとにスキーム論ができることになる。

それと、加群のテンソル積の定義もアッサリ。当たり前だといえば、まーそうなんだが、対称モノイド圏のなかで、Aはモノイドで、(M, φ:M×A→M) が右A加群、(N, ψ:A×N→N) が左A加群のとき、M×ψ, φ×N : M×A×N→M×N が定義できるので、これの等値核としてテンソル積を定義する。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20091127/1259304758&quot;&gt;バンドリング構造&lt;/a&gt;と&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090725/1248504503&quot;&gt;ヤン・バクスター方程式&lt;/a&gt;があれば、非対称なモノイド圏でも定義できる可能性がある。テンソル積がいつでも定義できる必要はない。

*1278987344*[からみ系][DFD][説明][Mx][講習]アミダの絵算とか

アミダの圏はブレイドの圏より簡単。ヤン・バクスター（Yang-Baxter）方程式に相当する等式の絵を描いた。（スターバックスナプキンはこんな色、しゃーない）

&lt;img src=&quot;http://www.chimaira.org/img2/amida-yang-baxter.jpg&quot; &gt;

最後の絵は、特異点の変動という感じ。似た絵として、ライデマイスター移動の特異点ぽい解釈：

&lt;img src=&quot;http://www.chimaira.org/img/singulars-and-moves.gif&quot;&gt;

可換律とヤンキング。

&lt;img src=&quot;http://www.chimaira.org/img2/singularities.gif&quot; &gt;

結合律も似たようなもの：X字(2→2)型の特異点の変動がヤン・バクスターで、Y字(2→1)型の変動が結合律。
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/assoc-diagram.gif&quot; &gt;

それはそうと、バンドリングとクロッシング（クロスに沿ったスライディング）を使ってヤン・バクスター方程式を示す：
&lt;img src=&quot;http://www.chimaira.org/img2/swap-to-artin.gif&quot; &gt;

なーるほど、&lt;em&gt;スッカリ忘れていた。&lt;/em&gt;

次の絵算もスゲー。

- [http://d.hatena.ne.jp/m-hiyama-memo/20080105/1199516424:title]

</body>
</day>
<day date="2010-07-14" title="">
<body>
*1279092946*[メモ][後で消す]

インクを買ってこないといけない。


</body>
</day>
<day date="2010-07-15" title="">
<body>
*1279161033*[圏一般論][DFD][雑記][プログラム意味論][リンク]ハランの非加法幾何

&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;-幾何の定式化のひとつに、ハラン（Haran）の非加法幾何（non-additive geometry）てのがあるらしい。紹介を読んだだけだが、離散有限的な状況、コンピュータの話とかにはこれは使いやすそう。

トゥエン／ヴェキ（Toen-Vaquie）のモノイド圏構成と関手圏をバキバキに使う方法も一般性がいいが、ハラン幾何は具体性があって、今すぐに使える。

&lt;b&gt;[追記]&lt;/b&gt;HaranのNon-Additive Geometryは次から取れる。

- http://matrix.cmi.ua.ac.be/fun/library/ShaiHaran2007.pdf
- 71ページ

さらに追加：

- title: Nonstandard Mathematics and New Zeta and L-Functions
- author: B. Clare
- URL: http://arxiv.org/abs/0808.1965
- 163ページ

これは、ベンジャミン・クレアの学位論文らしいが、ハラン幾何に触れている。130ページからはじまる第7章 &quot;CHAPTER 7 TheWork of Shai  Haran&quot; 。

&lt;b&gt;[/追記]&lt;/b&gt;

*1279168816*[人物][雑記]シャイ・ハラン

Non-Additive Geometry（http://matrix.cmi.ua.ac.be/fun/library/ShaiHaran2007.pdf 71ページ）のシャイ・ハラン（Shai Haran）、興味を惹かれて調べた。

- http://www.math.technion.ac.il/Site/people/process.php?id=695

イスラエルの人だな。ここにプロファイルがあるんだが、写真以外なーんにも書いてない。まったくやる気がないようだ。この写真見るとけっこう若いのかなー。

2005年秋から2006年冬まで九州大学にいたらしい。

|名前 |所属|期間|専門 |
|M.J.Shai Haran|Technion (Israel Institute of Technology)|2005 Fall-2006 Winter|Number Theory, Representation Theory, Algebraic Geometry|

本を書いているんだよね。

- http://www.amazon.co.jp/gp/product/0198508689
- The Mysteries of the Real Prime [ハードカバー]
- London Mathematical Society Monographs New Series 
- M. J. Shai Haran (著) 

間違いない、この人だ。ハードカバー本で高いなー。

次の論文も入手可能だ。

- Quantizations and symbolic calculus over the $p$-adic numbers
- http://aif.cedram.org/item?id=AIF_1993__43_4_997_0

- Analytic potential theory over the $p$-adics
- http://aif.cedram.org/item?id=AIF_1993__43_4_905_0


</body>
</day>
<day date="2010-07-16" title="">
<body>
*1279241023*[F1][DFD][プログラム意味論]トゥエン／ヴェキとハランの方法

7月13日にみつけたペーニャ／ロアシャイド（Javier Lo'pez Pen~a, Oliver Lorscheid）の Mapping F1-land（http://arxiv.org/abs/0909.0069）は素晴らしい解説。デイトマー（Deitmar）の方法が一番普通な感じなのはわかったが、コンピュータで使うならトゥエン／ヴェキ（Toen-Vaquie）とハラン（Shai Haran）の方法だろうな。特にシャイ・ハランの発想はものすごく面白い。ハランの&lt;b&gt;F&lt;/b&gt;は拡張アミダ圏だから、拡張ブレイド圏から出発すると別なナニカになるかもしれない。

ハランは有限行列を扱い、作用素ノルムを計量に使うのだけど、計算可能な無限（加算まで）行列を使ってもいいような気がする。すると、計算論からハラン幾何を構成できるんじゃないだろうか。


</body>
</day>
<day date="2010-07-20" title="">
<body>
*1279584561*[DFD]境界と全空間

力学法則が乗った空間（正方行列H）があるとき、空間全体の時間発展（exp(Ht), t≧0）が&lt;em&gt;完全に&lt;/em&gt;分かれば、特定の始境界／終境界と時区間を指定した伝搬現象は当然ながら完全に分かる。境界や時間を特定することとは、全空間の全歴史のごく一部を取り出すことに過ぎないから。

一方で、特定の始境界／終境界、特定の時刻、時区間の情報を知りたいなら、全空間の全歴史が必要なわけではない。&lt;em&gt;無駄な計算&lt;/em&gt;になるから、必要なことだけやればいい。

まとめると：

- 全空間の全歴史（大域的な時間発展）がわかれば、どんな始境界／終境界、時間を指定しても分かる。
- 特定の始境界／終境界、時間に関する情報を知るには、全空間の全歴史を知る必要はない。

この2つは当たり前だが、アルゴリズムを考えるときの指導原理としてはすごく重要。理論的には、&lt;em&gt;全空間の全歴史を記述できる形式を求める&lt;/em&gt;のだ。が、実際的には効率を上げるために&lt;em&gt;できるだけ無駄な計算をしない&lt;/em&gt;ようにする。

時刻tからt'に状態を発展させる作用素を P(t, t') とする。発展法則に重ね合わせが許される形なら、P(t, t')は加法的作用素、まー行列と思ってよい。時刻tでの状態がψ(t)なら、P(t, t')ψ(t) = ψ(t') でt'の状態が与えられる。法則が時刻によらないなら、発展作用素は時間推移の加法に関して指数法則を見たす。P(s + s') = P(s')P(s) 。

*1279584750*[圏一般論][形式言語理論][トレース／コンパクト閉圏]パリク関手

パリクベクトルとパリク写像の一般化としてパリク関手が定義できそうだな。Σがアルファベットとして、V = &lt;b&gt;N&lt;/b&gt;&lt;sup&gt;Σ&lt;/sup&gt; をパリク・ベクトル空間または単にパリク空間と呼ぶ。パリク空間を可換モノイドとみて、ベキ集合の半環（ブール代数係数の畳込み積の半環）をパリク代数&lt;b&gt;P&lt;/b&gt;と呼ぶ。パリク代数を係数とする行列の圏Mat&lt;sub&gt;&lt;b&gt;P&lt;/b&gt;&lt;/sub&gt; = Mat[&lt;b&gt;P&lt;/b&gt;] を考える。行列の加法的トレースによりトレース付き圏とみなせる。

Σをアルファベットとする境界付きオートマトンの圏をAutom(Σ)として、これもトレース付き圏と考える。Mat[L(Σ)]を経由して、Mat[&lt;b&gt;P&lt;/b&gt;]へのパリク関手を組み立てることができそう。これで、パリクの定理は自明になる。


</body>
<comments>
<comment>
<username>hiroki_f</username>
<body>＞発展法則に重ね合わせが許される形なら、P(t, t&#39;)は加法的作用素、まー行列と思ってよい。&lt;br&gt;&lt;br&gt;量子力学ですね。量子力学は重ね合わせが成り立つのに、古典になると成り立たない例がいっぱい出てくるから不思議です。&lt;br&gt;&lt;br&gt;線形的部分でしか量子力学は議論してないのか、本質的に量子力学は重ね合わせが成り立つのか、よく分からないです。</body>
<timestamp>1279610978</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>hiroki_fさん、&lt;br&gt;&lt;br&gt;&gt; 量子力学ですね。&lt;br&gt;これがさ、実はアルゴリズムの話をしているのよ。&lt;br&gt;不思議なんだけど、ある種の実用アルゴリズムを議論していると、まるで物理の話をしているようになってしまう。&lt;br&gt;&lt;br&gt;&gt; 量子力学は重ね合わせが成り立つのに、古典になると成り立たない例がいっぱい出てくるから不思議です。&lt;br&gt;アルゴリズムの話では、古典的にしても、つまり波動描像から粒子描像に切り替えても、やっぱり重ね合わせは成立している。&lt;br&gt;もっとも、行列表示の係数環がまるっきり変わってしまうのだけど。重ね合わせが崩壊するんじゃなくて、係数環が変形するのが脱量子化なんじゃないのかな？ よくわからんが。&lt;br&gt;&lt;br&gt;&gt; 線形的部分でしか量子力学は議論してないのか、本質的に量子力学は重ね合わせが成り立つのか、よく分からないです。&lt;br&gt;最近本編で触れているF1の線形代数だと、そもそも足し算がないので、加法性という意味の線形性は最初からない、それでも線形性なる概念が生き残るから不思議だ。直線とか部分ベクトル空間とかも足し算がなくても定義できるし。</body>
<timestamp>1279615224</timestamp>
</comment>
</comments>
</day>
<day date="2010-07-22" title="">
<body>
*1279789956*[人物][物理っぽい][雑感]マニンの構想

マニンの言うことはあまりにも壮大で、、、とてもついていけない。

とりあえず、アルゴリズムの全体がホップ代数になるところは理解したいなー。ルンゲクッタ法の話とは一応独立かもしれない。より一般的に、アルゴリズムがホップ構造を持つのだろう、たぶん。

*1279761492*[用語法][人物][物理っぽい]マニンのグラフに関する用語法

マニンのグラフに関する用語法で&lt;em&gt;まいった&lt;/em&gt;。ファインマングラフだと、こういう言葉を使うのか？

- フラグ -- 片一方だけが頂点と接続している無向辺。ただし、2つのフラグが組になって通常の辺を作ることもある。
- カローラ（corolla） -- 花びらの輪ですかね。一つの頂点に接続しているフラグの集合
- エッジ -- 2つのフラグがくっついて構成された無向辺。

フラグは「矢印の形をした付箋」の意味があるらしいから、そんな感じだろう。フラグの境界は必ず1個の頂点になっていて、頂点を持たないフラグは許されてない。

フラグに境界頂点を対応させる写像と、エッジを形成するフラグペアの指定でグラフ構造が定まる。さらにマニンは、組み合わせグラフと幾何グラフの厳密に区別することを注意している。フラグの幾何実現は、片一方が開いた線分。

*1279755216*[DFD][プログラム意味論][リンク][人物]計算関係の不思議な論文達

まずはコンヌ御大がクレイマーと書いている論文。こんなかでルンゲクッタ法に触れている。

- Title: Lessons from Quantum Field Theory -- Hopf Algebras and Spacetime Geometries
- Autors: A. Connes,  D. Kreimer
- URL: http://www.alainconnes.org/docs/lessons.pdf

ルンゲクッタ法がホップ代数（量子群）をなすという話。もとは次らしい。

- Title: Runge-Kutta methods and renormalization
- Authors: Christian Brouder
- URL: http://fr.arxiv.org/abs/hep-th/9904014

「繰り込み」がキーワードになるのだが、なんとマニン御老公も繰り込みと計算に注目している。2009年から計算（再帰関数とかチューリングマシンとか）を扱いだした、繰り込みと関連付けて。

- Title: Renormalization and computation I: motivation and background
- Authors: Yuri I. Manin
- URL: http://arxiv.org/abs/0904.4921

- Title: Renormalization and Computation II: Time Cut-off and the Halting Problem
- Authors: Yuri I. Manin
- URL: http://arxiv.org/abs/0908.3430

マニン論文から引用されていたヤノフスキーのアルゴリズムの話。要するにフローチャート理論だと思う。

- Title: Towards a Definition of an Algorithm
- Authors: Noson S. Yanofsky
- URL: http://arxiv.org/abs/math/0602053

ヴォエヴォドスキーも計算に興味を持ち始めている。ホモトピーラムダ計算。

- Title: A very short note on homotopy lambda calculus (October 2, 2006)
- URL: http://www.math.ias.edu/~vladimir/Site3/home_files/2006_09_Hlambda.pdf

そしてヴォエヴォドスキーの型理論。

- Title: Notes on type systems (working notes)
- URL: http://www.math.ias.edu/~vladimir/Site3/home_files/expressions_current.pdf

アウォーディにいたっては、マーチンレフ型理論がホモトピー理論だと言い出している。

- Title: Martin-Lo:f complexes.    
- Authors: S. Awodey, P. Hofstra, M. Warren, 2009.
- URL: http://www.andrew.cmu.edu/user/awodey/preprints/MLC.pdf 

そいえば、アブラムスキー一派のダンカンも計算とホモトピーを扱っていた。

- http://d.hatena.ne.jp/m-hiyama-memo/20070223/1172190951

シーケンと計算はホモトピーっぽいしなー、確かに。



</body>
</day>
<day date="2010-07-23" title="">
<body>
*1279842040*[用語法][人物][物理っぽい][雑感]おいおい、いくらなんでもそれはないだろう：グラフのリーフ

グラフ、特にツリーのリーフ（葉）といえば、末端の頂点のことだろうよ、普通。が、例のマニン（だけではないだろうが）の用語法では、グラフ全体のなかでエッジ（フラグのペア）になってないフラグのこと。ヒドイ！

さすがに尻尾（テイル）とか脚（レッグ）とかいう同義語もあるらしい。リーフはやめてくれ！ 脚が一番しっくりくるかな、僕には。ファインマングラフだと外線とかいっているやつが脚なのか？ 無限の彼方まで伸びている辺が脚だと考えてもいいだろう。球面上にグラフを描いて（幾何実現）、すべての脚を仮想的に一点（無限遠点）のカローラと思えばいい。

マニンはファインマングラフを計算デバイスだと思っているのだろう。チューリングマシンやブール回路と同じようなもの。摂動計算も繰り込みも、物理じゃなくて計算論として扱える、と（おそらく）言いたいのだろう。ただし、今の計算論じゃダメで、可逆計算や随時（any-time）計算も扱えて、古典計算（モデルは可算集合の圏）と量子計算（モデルはヒルベルト空間の圏）に対する共通のフレームワークが必要。

マニンは、&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;上の解析関数を問題にしていたけど、再帰関数（計算可能関数）をなんらかの意味で解析関数だと捉えて、本物の複素多変数解析関数と関係付ける気でいるんじゃなかろうか。マニンの、あるいは僕の妄想かもしれないが。

ところで、マニン（1937年2月16日生まれ）は73歳だよなー（2010年夏）。このジイサマはとんでもない。長生きして統合計算論（GUT for Computations）を完成させてくれ。

*1279842950*[DFD][トレース／コンパクト閉圏]閉包は全トレースと呼びたい

次の図：

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/trace-of-matrics.jpg&quot; &gt;

全トレースを取ると、観測的には見えなくなるけど、図形としてはちゃんと存在している。実は、モノイド積（テンソル積）とスカラーの取り方によっては、観測的にも見えることがある。
</body>
</day>
<day date="2010-07-26" title="">
<body>
*1280105074*[メモ]今日の大事なこと

もう出かける時間だ。項目だけ。

+ 圏のイデアルを真面目に考える必要がある。
+ 加法圏という概念は、&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;b&gt;F&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;b&gt;B&lt;/b&gt;上の加群の圏で豊饒化すると一般化できる。
+ 豊穣圏も、集合をモノイド圏（対称とは限らない）に一般化すると、PROPとかも一度に扱える。
+ 階数(grade)付き圏はけっこう重要かも。
+ サブ関手の概念も重要そうだ。


</body>
</day>
<day date="2010-07-27" title="">
<body>
*1280206224*[メモ][リンク][お絵描き][トレース／コンパクト閉圏]テンパリー・リーブ圏化 色付き絵算だ

- Title: A Diagrammatic Temperley-Lieb Categorification
- Authors: Ben Elias (Submitted on 17 Mar 2010)
- URL: http://arxiv.org/abs/1003.3416
- Pages: 45 pages

色が付いてる。スゲーぞ。
</body>
</day>
<day date="2010-07-29" title="">
<body>
*1280360183*[メモ]病院

- とうぶちいきびょういん
- 東部地域病院 03-5682-5111

</body>
</day>
<day date="2010-07-30" title="">
<body>
*1280449470*[メモ]雑用のたぐい

- 自転車問題にケリをつける
- 市役所に手続き
- 健康診断二箇所、皮膚科がないからもう一箇所か？
- 歯医者
- 薬屋も

*1280449582*[圏一般論][リンク]豊穣圏を一般化する、プロップ（PROP）とかオペラッドとか

PROPは PRoduct Operations and Permutations らしい。もはや語源はどうでもよくて、PROPが豊穣圏の一般化であることが重要だと思う。

X = (X, +, 0)がモノイド圏（対称とは限らない）、V = (V, ×, 1) が対称モノイド圏のとき、&lt;strong&gt;X上のV-豊穣圏&lt;/strong&gt;を定義できる。これは通常の豊穣圏の定義を含み、PROPの定義と事実上同じである。以下では、用語「PROP」を「X上のV-豊穣圏」の意味で用いる。

PROPは、ホム対象を対応させる H:X→V という写像とVの射の族として与えられる。

- H:X→|V|  (f:a→b) |→ H(f)
- γ&lt;sub&gt;f,g&lt;/sub&gt; :H(f)×H(g)→H(f;g) in V
- μ&lt;sub&gt;f,g&lt;/sub&gt; :H(f)×H(g)→H(f+g) in V
- ι&lt;sub&gt;a&lt;/sub&gt; :1→H(a) （a = id&lt;sub&gt;a&lt;/sub&gt;）

Aが単なる集合のとき、Aのタプルの集合A&lt;sup&gt;*&lt;/sup&gt;に上に完全グラフを作るとモノイド圏Xとなる。通常はこのようにして作ったモノイド圏の上にV-豊穣圏を作る。特にAが単元のときは、Xは自然数の完全グラフの圏となる。

オペラッドはPROPの部分系だと思ってよい。次が詳しいようだ（読んでないが）。

- Title: Operads and PROPs
- Authors: Martin Markl 
- URL: http://arxiv.org/abs/math/0601129
- Pages: 49pages

</body>
</day>
<day date="2010-07-31" title="">
<body>
*1280542959*[圏一般論]圏のイデアル

イオネスクが次の論文を書いている。

- Title: On Ideals and Homology in Additive Categories
- Authors: Lucian M. Ionescu (Kansas State University)
- URL: http://arxiv.org/abs/math/9906039
- Pages: 10 pages

反図式順で考えて、fが生成する左単項イデアルを＜f|、右単項イデアルを|f＞、両側イデアルを＜f＞と書く。

- ＜g・f＞ = ＜g| ∩ |f＞

はキレイな式だが、これ嘘だろうよ。

*1280543630*[圏一般論][用語法]圏のイデアルの左右、核、余核とか

圏の文脈で右イデアル／左イデアルは最悪の用語法だな。悲惨すぎる。前方イデアル、後方イデアルとかだろうな。

線形代数の次の用語は使える。f:A→Bとして

- i = ker(f): Ker(f)→A
- p = coker(f): B→B/Im(f)
- im(f) : Im(f)→B, im(f) = ker(coker(f))
- coim(f) : A→A/Kef(f) = coker(ker(f))



</body>
</day>
<day date="2010-08-02" title="">
<body>
*1280706151*[DFD][用語法]ファインマングラフの定義

誰もちゃんとした定義を書いてないのでは？ 2009年になって、アンドレ・ジョイアルとヨアヒム・コックが、&lt;b&gt;very natural&lt;/b&gt; で &lt;b&gt;it seems to be new&lt;/b&gt; （当社比か？）な定義を与えているが、よくわからん。半分辺（half-edge）の集合Hが出てくるのいいのだが、次の構造で定義する。Vが頂点集合、Eは普通の辺の集合。

+ t:H→V 半分辺の端点だと思う。
+ s:H→E これがわからん。
+ i:E→E 辺（両端を持つ）の方向を逆転させる写像

sが単射らしいので、半分辺を辺に埋め込んでいる。って、それが理解できん。百聞は一見にしかず、だから絵があればいいのだけど、絵がないし。

&lt;em&gt;伝達可能で正確な定義って、ほんとに大事だなー。&lt;/em&gt;
</body>
</day>
<day date="2010-08-03" title="">
<body>
*1280798206*[DFD][用語法]ファインマングラフの定義、これでいいのか

昨日のファインマングラフの定義を解読したけど、これがnaturalなんかなー？

ファインマングラフって無向グラフなのね。で、外線を持つと。少なくともジョイアルとコックの定義はそうなっている。無向グラフの定義に有向辺を持ち出すのが分かりにくかったし、もとのグラフに有向辺があったら（有向ファインマングラフか？）どうするのだろう？ それにサークルの表現方法もないし。

ポートの定義もひどく不自然に思える。もっと見たまんまに、ポート頂点と内部頂点の2種の集合を準備して、その頂点に関するグラフで十分だと思うが、グラフのエタール写像（局所同相）の定義が簡単だ、というメリットはあるが、そのためにここまでするか？


</body>
</day>
<day date="2010-08-04" title="">
<body>
*1280883620*[リンク]スピシーズの本？

- Title: Monoidal Functors, Species and Hopf Algebras
- Authors: Marcelo Aguiar, Swapneel Mahajan
- URL: http://www.math.tamu.edu/~maguiar/a.pdf 836ページ！

巨大。出版された（される）本のPDFなのかな

*1280883549*[お絵描き][DFD]ファインマングラフの定義、こんな

アンドレ・ジョイアルとヨアヒム・コックのファインマングラフの定義。

&lt;img src=&quot;http://www.chimaira.org/img2/feynman-graph.jpg&quot; &gt;

ここで言っているファインマングラフとは、開いた辺を持つ&lt;em&gt;無向グラフ&lt;/em&gt;、それだけのこと。多重辺も許すし、ループも許す。が、サークル（頂点をまったく持たないループ）は持てない。開いた辺の、頂点でないほうの端点をポートと呼ぶ。図の白丸がポート。

Gがファインマングラフ。集合Eは、Gの無向辺に方向を付けた有効辺の集合、本数は２倍になる。向きだけが違う辺がペアになっているが、このペアリングをインボリューションで表現する。集合Hは、半分の辺（フラグ）の集合。半分の辺の根元は必ず頂点であり、ポートが根元であることはない。頂点を結ぶ無向辺は2つの半分辺として表現できる。HはEに埋め込めるので、この埋込みでEの部分集合とみてよい。EにおけるHの補集合がポート集合となる。

&lt;img src=&quot;http://www.chimaira.org/img2/graph-morphism.jpg&quot; &gt;

ファインマングラフの圏は色々と定義できるが、次のルールが簡単。

+ 頂点は頂点に移す。
+ ポートは頂点またはポートに移す。
+ 辺は辺に移す。

さらに価数（valence; degree）を保存する（各頂点のカローラで全射）とき、エタール射と呼ぶ。エタール射の族がjointly surjectiveのとき被覆と呼び。被覆の全体でグロタンディーク位相（サイト）を定義する。

</body>
</day>
<day date="2010-08-10" title="">
<body>
*1281408162*[お絵描き][モナド]テンソル強度の証明図とストリング図

モナドのテンソル強度からペアリングを作って、それが結合法則や単位法則を満たすことを証明するには、ストリング図が一番だが、ストリング図に入る前に等式を変形する前処理が必要になる。

ひとつの前処理は、対象aを (+a) := λx.(x + a) （Haskellのセクション記法借用）という関手に変換すること。もうひととは、 (+Fa) を +a;F に直すこと。ここで早速にテンソル強度を使うことになる。

&lt;pre&gt;
 +(Fa)  λx.(x + Fa)
 -------------------
 +a;F   λx.F(x + a)
&lt;/pre&gt;

対象 Fa + Fb + Fc は +(Fa + Fb + Fc) という関手になるが、次のように変形できる。

&lt;pre&gt;
   +(Fa + Fb + Fc)
  ------------------
   +(Fa);+(Fb);+(Fc)
  ------------------
   +a;F ; +b;F ; +c;F
&lt;/pre&gt;

(+a) と a を同一視、図式順結合を単なる併置にすると、 a F b F c F と書ける。ここからスタートすれば、ペアリングの結合律は容易に示せる。

この前処理が思いつかなくて、なかなか絵算に持ち込めなかったのだった。この場合は、本番計算よりは前処理のほうが重要つうかキモ。
  

</body>
</day>
<day date="2010-08-11" title="">
<body>
*1281501525*[お絵描き][モノイド圏][高次圏論]モノイド圏が作用する圏の圏

モノイドが作用する集合の圏化。

Mがモノイドのとき「M作用を持つ集合」の圏は &lt;b&gt;Set&lt;/b&gt;&lt;sup&gt;M&lt;/sup&gt; = [M&lt;sup&gt;+1&lt;/sup&gt;, &lt;b&gt;Set&lt;/b&gt;]&lt;sub&gt;&lt;b&gt;Cat&lt;/b&gt;&lt;/sub&gt; と書ける。ここで、[-, -]&lt;sub&gt;C&lt;/sub&gt;は、Cが閉圏のときのベキ（指数）。M&lt;sup&gt;+1&lt;/sup&gt;は、モノイドMに0セルの単元集合を足して圏とみなしたもの。

同様に、Vがモノイド圏のとき「V作用を持つ圏」の圏は &lt;b&gt;Cat&lt;/b&gt;&lt;sup&gt;V&lt;/sup&gt; = [V&lt;sup&gt;+1&lt;/sup&gt;, &lt;b&gt;Cat&lt;/b&gt;]&lt;sub&gt;&lt;b&gt;W2-Cat&lt;/b&gt;&lt;/sub&gt; と書ける、と思われる。V&lt;sup&gt;+1&lt;/sup&gt;は、モノイド圏Vに０セルの単元集合を足して2-圏とみなしたもの。&lt;b&gt;W2-Cat&lt;/b&gt;は、弱2圏の圏だが、&lt;b&gt;W2-Cat&lt;/b&gt;自身は、弱3圏になると思われる。[V&lt;sup&gt;+1&lt;/sup&gt;, &lt;b&gt;Cat&lt;/b&gt;]&lt;sub&gt;&lt;b&gt;W2-Cat&lt;/b&gt;&lt;/sub&gt; は、弱2圏のあいだの関手(0セル）と自然変換（1セル）と変形（2セル）からなる弱2圏。

ここらへんまではギリギリなんとか計算が可能だか、これ以上の高次圏になるとツライ。

*1281501526*[お絵描き][モノイド圏][リンク]前モノイド圏

前モノイド圏の組み合わせ的／図式的な基礎論だろう。

- URL: http://arxiv.org/abs/math/0306371
- Title: Braided Premonoidal Coherence
- Author: W. P. Joyce
- Pages: 28pages


</body>
</day>
<day date="2010-08-17" title="">
<body>
*1282008054*[DFD][その他代数][リンク]ツリーのホップ代数

- URL: http://arxiv.org/abs/0806.2238
- Title: Two interacting Hopf algebras of trees
- Authors: Damien Calaque, Kurusch Ebrahimi-Fard, Dominique Manchon
- Pages: 24pages

*1282008125*[DFD][その他代数][リンク]ホップ代数の対蹠

- http://en.wikipedia.org/wiki/Hopf_algebra

この記事に、対蹠射（antipode）Sの可換図式が載っている。

- Δ;(S×id);∇ = ε;η
- Δ;(id×S);∇ = ε;η

ということで、ほぼ予想通り。ε;ηはゼロ射と同じものだろうからθと置くと：

- Δ;(S×id);∇ = Δ;(id×S);∇ = θ

となり、逆元の定式化に近くなる。

*1282010025*[Caty][モノイド圏][リンク]ペトリネット

これは10ページ：

- http://eprints.ecs.soton.ac.uk/11952/1/P-of-N-conf.pdf


</body>
</day>
<day date="2010-08-18" title="">
<body>
*1282095709*[Caty]略語 stone（ストーン）

コジツケ：

- State-Transition Oriented Network Element

*1282096719*[モナド][お絵描き][リンク]ホップモナド

手早く入門。

- http://www.cirm.univ-mrs.fr/videos/2006/exposes/23/Bruguieres.pdf スライド

教科書的。

- URL: http://arxiv.org/abs/math.QA/0604180
- Title: Hopf monads
- Authors: Alain Bruguie`res, Alexis Virelizier
- Pages: 47 pages

ウィラートンの例の超絶絵算論文は：

- URL: http://arxiv.org/abs/0807.0658
- Title: A diagrammatic approach to Hopf monads
- Pages: 26ページ、絵がたくさん

</body>
</day>
<day date="2010-08-19" title="">
<body>
*1282178720*[Caty][雑感]Webストーン

問題は、サブシステム境界。境界はとじていてはダメだ。細胞膜みたいなもので、新陳代謝しないと。で、境界を設定はするが、境界を通しての出入りが問題となる。出入りとはつまりインターフェース。

グラフ的／図形的には、入り込む矢印、出て行く矢印。これを、切断されたリクエスト辺（request arc）と切断された内部辺（internal arc）を使うことにする。切断された内部辺とは、通常のパイプラインのインターフェース（内部ポート）に他ならない。

Webストーン（状態遷移モジュール）を射とする圏はモノイド圏になるが、モノイド積は直和。エルゴット流ルーピングとしてトレースも入る。が、半環圏にするのは難しそうだし、必要もない気がする。


</body>
</day>
<day date="2010-08-20" title="">
<body>
*1282261763*[Caty][雑感]Webストーンの雑多なヒント

refererが綴り間違いだという話はともかく。

- [http://d.hatena.ne.jp/m-hiyama/20100318/1268871956:title]

とかとの関係を考えてみる。

ペトリネットは関係あるのか？

指標グラフと項グラフとコボルディズムの関係（一見謎だが、形式言語理論とTQFTの類似の源泉かと）

</body>
</day>
<day date="2010-08-21" title="">
<body>
*1282371918*[お絵描き][Caty]ファインマングラフの外線、内線

external edge, internal edge という言い方はやっぱりある。外線、内線というらしいが、ほんとは外辺、内辺だよね。

*1282372422*[気付いた][DFD][モナド]記号回路は自由構成モナドなり

一時期、記号回路というものを定式化しようとして、どうもうまくいかなかった。今考えたら、実はモナド（のクライスリ圏）だった。

Aが有向グラフとして、その自由圏FC(A)、自由モノイド圏FMC(A)、自由対称モノイド圏FSMC(A)などが定義できて有向グラフの圏上にモナドとなる（忘却関手と組み合わせて）。これらのモナドのクライスリ射が記号回路だった。

Cが圏として、α:A→C が有向グラフの射になっているとき、(A, α)をC上のレパートリ（プログラム的にはモジュールのセマンティクス）と呼ぶことにする。自由構成の特徴から、FC(A)→C となる。これが記号回路の意味論を与える。FC(A)→C はFC代数でもあり、アイレンベルク／ムーア圏の対象になっている。← いや、なんか違うな。後で考える。


</body>
</day>
<day date="2010-08-23" title="">
<body>
*1282522622*[Caty]Webストーンの二重圏

|* セル  |* 名前         |* 演算     |
| 0-セル |ワイヤータプル | +         |
| 1-セル |Webストーン    | +, ;, Tr  |
| 2-セル |ストーン写像   | +, ;, ;;  |

ちょっと記号が変わっているんが「;;」、写像の結合。Webストーンの連結に「;」を使ってしまったのでこうした。

Webストーン写像は、有向グラフの準同型だが、ノードと辺に付いている属性に関して色々と条件が付く。その現実的な意味は、パターンの特殊化（具体化）と一般化（抽象化）。2セルの写像としての向きが (特殊)→(一般) である点に注意。

ジャンクションには次がある。

+ I -- ストレート、パススルー
+ ∇ -- 合流
+ X, σ -- 対称
+ Δ -- 公平な振り分け（非決定性だから）

Web特有の概念としてリダイレクト辺がある。

次のような現実的な概念に形式的な意味付けを与えなくては。

+ モジュラー化（modularize）
+ 特殊化と一般化（具体化と抽象化）
+ 組み立て（アセンブリング）
+ 配置（位置決め）と接続（コンフィギュレーションとコネクション）
+ URL特殊化、型特殊化（バインディングを「特殊化」と解釈する）

2セル（Webストーン写像）を射とする圏のなかで項モナド（項グラフモナド）を作れると思うんだけど、なんかよく分からん。

*1282519323*[Caty] cay-python-pp-0.1.0 files

&gt;||
cay-python-pp-0.1.0 files

|   .hgtags
|   .hg_archival.txt
|   caty.py
|   CONTRIBUTORS.txt
|   EXCUSE.txt
|   files.txt
|   INSTALL.txt
|   LICENSE.ja-utf8.txt
|   LICENSE.txt
|   new-project.bat
|   new-project.sh
|   README.txt
|   RELEASE.txt
|   RUNTIME_FILES.txt
|   update-project.bat
|   update-project.sh
|   _global.xjson
|   
+---common
|   +---commands
|   |   +---behaviors
|   |   |       builtin.beh
|   |   |       file.beh
|   |   |       index.beh
|   |   |       json.beh
|   |   |       list.beh
|   |   |       literal.beh
|   |   |       resid.beh
|   |   |       secure.beh
|   |   |       strg.beh
|   |   |       text.beh
|   |   |       user.beh
|   |   |       
|   |   \---pub
|   |           template.txt
|   |           template.txt.caty
|   |           
|   +---fit-view
|   |   |   _manifest.xjson
|   |   |   
|   |   +---commands
|   |   |       fit.py
|   |   |       
|   |   +---include
|   |   |       fit-result.html
|   |   |       test-list-for-index.html
|   |   |       test-list.html
|   |   |       
|   |   +---pub
|   |   |       fit.css
|   |   |       index.html
|   |   |       
|   |   \---schemata
|   |           public.casm
|   |           
|   \---user
|       \---scripts
|               rc.caty
|               
+---develop
|   +---bad-manifest
|   |       README.txt
|   |       _manifest.xjson.BAD
|   |       
|   +---fit-example
|   |   +---behaviors
|   |   |       index.beh
|   |   |       nth.beh
|   |   |       validate-01.beh
|   |   |       validate-02.beh
|   |   |       validate-03.beh
|   |   |       
|   |   +---pub
|   |   |       index.html
|   |   |       
|   |   \---schemata
|   |           t02.casm
|   |           
|   +---misc
|   |   |   _manifest.xjson
|   |   |   
|   |   +---behaviors
|   |   |   |   constant.beh
|   |   |   |   file.beh
|   |   |   |   fit-output.beh
|   |   |   |   index.beh
|   |   |   |   literal.beh
|   |   |   |   macro.beh
|   |   |   |   script.beh
|   |   |   |   templ-2.beh
|   |   |   |   templ.beh
|   |   |   |   test.beh.NOUSE
|   |   |   |   xjson.beh
|   |   |   |   
|   |   |   \---cmd
|   |   |           cmdtest1-1.beh
|   |   |           cmdtest1-2.beh
|   |   |           cmdtest2-1.beh
|   |   |           cmdtest2-2.beh
|   |   |           index.beh
|   |   |           
|   |   +---commands
|   |   |       testcmd.py
|   |   |       
|   |   +---pub
|   |   |       foo.data
|   |   |       foreach.html
|   |   |       index.html
|   |   |       show-data.html
|   |   |       sites.html
|   |   |       systemvars.html
|   |   |       
|   |   +---schemata
|   |   |       tc.casm
|   |   |       
|   |   \---scripts
|   |           concat.caty
|   |           const.caty
|   |           cout.caty
|   |           echo.caty
|   |           
|   +---specdocs
|   |   |   _manifest.xjson
|   |   |   
|   |   +---include
|   |   |       footer.html
|   |   |       
|   |   +---pub
|   |   |   |   array-node.jpg
|   |   |   |   ExceptionHandling.wiki
|   |   |   |   index.html
|   |   |   |   IpAddrs.wiki
|   |   |   |   object-node.jpg
|   |   |   |   PathMatch.wiki
|   |   |   |   RequestCmd.wiki
|   |   |   |   scalar-node.jpg
|   |   |   |   show.html
|   |   |   |   show.txt
|   |   |   |   style.css
|   |   |   |   t01.wiki
|   |   |   |   tag-node-2.jpg
|   |   |   |   tag-node.jpg
|   |   |   |   tree-traverse.jpg
|   |   |   |   ValidationError-2.wiki
|   |   |   |   ValidationError.wiki
|   |   |   |   WebInput.wiki
|   |   |   |   xjson-tree.jpg
|   |   |   |   XJSONPath.wiki
|   |   |   |   XJSONTree.wiki
|   |   |   |   XJSONValidate.wiki
|   |   |   |   
|   |   |   \---XMaton
|   |   |           index.html
|   |   |           TokenAndLabel.wiki
|   |   |           tree-traverse.jpg
|   |   |           XMaton.wiki
|   |   |           
|   |   \---scripts
|   |           cout.caty
|   |           show-wiki.caty
|   |           
|   +---template
|   |   +---behaviors
|   |   |       index.beh
|   |   |       template-01.beh
|   |   |       template-02.beh
|   |   |       
|   |   +---pub
|   |   |       echo.txt
|   |   |       foreach.txt
|   |   |       foreachelse.txt
|   |   |       index.html
|   |   |       ref01.txt
|   |   |       
|   |   \---scripts
|   |           echo.caty
|   |           foreach.caty
|   |           foreachelse.caty
|   |           
|   \---validate
|       +---behaviors
|       |       array.beh
|       |       attrs.beh
|       |       ComplexDef.beh
|       |       enum.beh
|       |       ext.beh
|       |       FormData.beh
|       |       index.beh
|       |       inline-schema.beh
|       |       junk.txt
|       |       never.beh
|       |       objattr.beh
|       |       object.beh
|       |       recurs.beh
|       |       string.beh
|       |       tagged.beh
|       |       tagwild.beh
|       |       trans-basic.beh
|       |       TypeVar.beh
|       |       union.beh
|       |       
|       +---pub
|       |       index.html
|       |       
|       \---schemata
|               edit.casm
|               extBase.casm
|               extExt.casm
|               gen.casm
|               htw.casm
|               htwExt.casm
|               mf.casm
|               shape.casm
|               t01.casm
|               t02.casm
|               t03.casm
|               t04.casm
|               t05.casm
|               t06.casm
|               
+---DOCS
|       bpstudy26-v2.odp
|       
+---examples
|   +---files
|   |   +---commands
|   |   |       uploader.py
|   |   |       
|   |   +---pub
|   |   |       index.html
|   |   |       index.html.caty
|   |   |       upload.cgi
|   |   |       
|   |   \---schemata
|   |           public.casm
|   |           
|   +---schema_plugin
|   |   +---commands
|   |   |       ymd.py
|   |   |       
|   |   \---schemata
|   |           formats.xjson
|   |           public.casm
|   |           
|   +---security
|   |   \---pub
|   |           login.cgi
|   |           login.html
|   |           logout.cgi
|   |           
|   +---templates
|   |   +---include
|   |   |       footer.html
|   |   |       framework_404.html
|   |   |       framework_500.html
|   |   |       global_menu.html
|   |   |       
|   |   \---pub
|   |           index.html
|   |           
|   \---wiki
|       |   _manifest.xjson
|       |   
|       +---include
|       |       edit.html
|       |       newpage.html
|       |       page.html
|       |       recent.html
|       |       
|       +---pub
|       |       all.html
|       |       FrontPage.wiki
|       |       HelpPage.wiki
|       |       index.cgi
|       |       new.cgi
|       |       wiki.css
|       |       
|       +---schemata
|       |       public.casm
|       |       
|       \---scripts
|               edit.caty
|               post.caty
|               read.caty
|               
+---lib
|       win32cls.py
|       
+---python
|   +---caty
|   |   |   __init__.py
|   |   |   
|   |   +---command
|   |   |       builtin.py
|   |   |       debug.py
|   |   |       file.py
|   |   |       fit.py
|   |   |       jsonlib.py
|   |   |       listlib.py
|   |   |       secure.py
|   |   |       strg.py
|   |   |       test.py
|   |   |       text.py
|   |   |       user.py
|   |   |       __init__.py
|   |   |       
|   |   +---core
|   |   |   |   application.py
|   |   |   |   async.py
|   |   |   |   exception.py
|   |   |   |   facility.py
|   |   |   |   finder.py
|   |   |   |   handler.py
|   |   |   |   resource.py
|   |   |   |   shebang.py
|   |   |   |   template.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---casm
|   |   |   |   |   finder.py
|   |   |   |   |   loader.py
|   |   |   |   |   module.py
|   |   |   |   |   plugin.py
|   |   |   |   |   __init__.py
|   |   |   |   |   
|   |   |   |   \---language
|   |   |   |           ast.py
|   |   |   |           casmparser.py
|   |   |   |           commandparser.py
|   |   |   |           schemaparser.py
|   |   |   |           util.py
|   |   |   |           xcasmparser.py
|   |   |   |           __init__.py
|   |   |   |           
|   |   |   +---command
|   |   |   |       exception.py
|   |   |   |       profile.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   +---schema
|   |   |   |       array.py
|   |   |   |       base.py
|   |   |   |       binary.py
|   |   |   |       bool.py
|   |   |   |       enum.py
|   |   |   |       errors.py
|   |   |   |       number.py
|   |   |   |       object.py
|   |   |   |       string.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---script
|   |   |           builder.py
|   |   |           node.py
|   |   |           parser.py
|   |   |           proxy.py
|   |   |           __init__.py
|   |   |           
|   |   +---env
|   |   |       __init__.py
|   |   |       
|   |   +---fit
|   |   |   |   behparser.py
|   |   |   |   runner.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---document
|   |   |           base.py
|   |   |           literal.py
|   |   |           section.py
|   |   |           setup.py
|   |   |           triple.py
|   |   |           __init__.py
|   |   |           
|   |   +---front
|   |   |   |   console.py
|   |   |   |   profiler.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---web
|   |   |       |   app.py
|   |   |       |   __init__.py
|   |   |       |   
|   |   |       \---simple
|   |   |               __init__.py
|   |   |               
|   |   +---jsontools
|   |   |   |   jstypes.py
|   |   |   |   model.py
|   |   |   |   xjson.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---path
|   |   |           query.py
|   |   |           validator.py
|   |   |           __init__.py
|   |   |           
|   |   +---mafs
|   |   |   |   authorization.py
|   |   |   |   builder.py
|   |   |   |   fileobject.py
|   |   |   |   metadata.py
|   |   |   |   overlay.py
|   |   |   |   pathname.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---appengine
|   |   |   |       fileobject.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---stdfs
|   |   |           __init__.py
|   |   |           
|   |   +---session
|   |   |       base.py
|   |   |       memory.py
|   |   |       value.py
|   |   |       __init__.py
|   |   |       
|   |   +---storage
|   |   |       query.py
|   |   |       sqlite.py
|   |   |       __init__.py
|   |   |       
|   |   +---template
|   |   |   |   builder.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---core
|   |   |   |       compiler.py
|   |   |   |       context.py
|   |   |   |       exceptions.py
|   |   |   |       filter.py
|   |   |   |       instructions.py
|   |   |   |       io.py
|   |   |   |       loader.py
|   |   |   |       renderer.py
|   |   |   |       st.py
|   |   |   |       template.py
|   |   |   |       vm.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   +---genshi
|   |   |   |       htmlverifier.py
|   |   |   |       translator.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---smarty
|   |   |           parser.py
|   |   |           __init__.py
|   |   |           
|   |   +---testutil
|   |   |       setup.py
|   |   |       testcase.py
|   |   |       __init__.py
|   |   |       
|   |   +---util
|   |   |       cache.py
|   |   |       collection.py
|   |   |       cx.py
|   |   |       optionparser.py
|   |   |       path.py
|   |   |       web.py
|   |   |       __init__.py
|   |   |       
|   |   \---vcs
|   |           __init__.py
|   |           
|   +---lib
|   |   +---antlr
|   |   |   |   LICENSE.txt
|   |   |   |   
|   |   |   \---antlr
|   |   |           antlr.py
|   |   |           __init__.py
|   |   |           
|   |   +---BeautifulSoup
|   |   |       BeautifulSoup.py
|   |   |       COPYRIGHT.txt
|   |   |       PKG-INFO
|   |   |       README
|   |   |       
|   |   +---creole
|   |   |   |   LICENSE
|   |   |   |   
|   |   |   \---creole
|   |   |       |   tree.py
|   |   |       |   __init__.py
|   |   |       |   
|   |   |       \---syntax
|   |   |               anchor.py
|   |   |               base.py
|   |   |               blockquote.py
|   |   |               br.py
|   |   |               deflist.py
|   |   |               em.py
|   |   |               heading.py
|   |   |               horizonal.py
|   |   |               image.py
|   |   |               lists.py
|   |   |               nowiki.py
|   |   |               paragraph.py
|   |   |               preformat.py
|   |   |               section.py
|   |   |               strong.py
|   |   |               sub.py
|   |   |               sup.py
|   |   |               table.py
|   |   |               tt.py
|   |   |               url.py
|   |   |               __init__.py
|   |   |               
|   |   +---csslib
|   |   |   |   LICENSE
|   |   |   |   
|   |   |   \---csslib
|   |   |           selector.py
|   |   |           __init__.py
|   |   |           
|   |   +---pbc
|   |   |   |   LICENSE
|   |   |   |   
|   |   |   \---pbc
|   |   |           __init__.py
|   |   |           
|   |   +---simplejson
|   |   |   |   LICENSE.txt
|   |   |   |   PKG-INFO
|   |   |   |   
|   |   |   \---simplejson
|   |   |           decoder.py
|   |   |           encoder.py
|   |   |           scanner.py
|   |   |           tool.py
|   |   |           _speedups.c
|   |   |           __init__.py
|   |   |           
|   |   \---topdown
|   |       |   LICENSE
|   |       |   
|   |       \---topdown
|   |               __init__.py
|   |               
|   \---test
|       |   exec-test.py
|       |   script-test.py
|       |   testsuite.py
|       |   
|       +---sites
|       |   |   _global.xjson
|       |   |   
|       |   +---test
|       |   |   \---include
|       |   |           test.html
|       |   |           
|       |   \---_ROOT
|       |       |   _manifest.xjson
|       |       |   
|       |       +---include
|       |       |       test.html
|       |       |       
|       |       +---pub
|       |       |   |   empty.txt
|       |       |   |   index.html
|       |       |   |   
|       |       |   \---subdir
|       |       |           empty.txt
|       |       |           include.html
|       |       |           normal.html
|       |       |           placeholder.html
|       |       |           placeholder.html.caty
|       |       |           placeholder2.html
|       |       |           placeholder2.html.caty
|       |       |           
|       |       +---res
|       |       |       empty.txt
|       |       |       
|       |       +---schemata
|       |       |       public.casm
|       |       |       
|       |       +---scripts
|       |       |       hello.caty
|       |       |       
|       |       \---testfiles
|       |               lsdir.json
|       |               pass.json
|       |               user.json
|       |               
|       +---template_test
|       |       smarty1.html
|       |       smarty2.html
|       |       
|       \---unit
|           |   __init__.py
|           |   
|           \---caty
|               |   __init__.py
|               |   
|               +---command
|               |       builtin.py
|               |       strg.py
|               |       __init__.py
|               |       
|               +---core
|               |   |   __init__.py
|               |   |   
|               |   +---casm
|               |   |   |   __init__.py
|               |   |   |   
|               |   |   \---language
|               |   |           casmparser.py
|               |   |           commandparser.py
|               |   |           schemaparser.py
|               |   |           util.py
|               |   |           __init__.py
|               |   |           
|               |   \---schema
|               |           array.py
|               |           base.py
|               |           bool.py
|               |           enum.py
|               |           number.py
|               |           object.py
|               |           string.py
|               |           __init__.py
|               |           
|               +---fit
|               |   |   behparser.py
|               |   |   __init__.py
|               |   |   
|               |   \---document
|               |           __init__.py
|               |           
|               +---jsontools
|               |   |   __init__.py
|               |   |   
|               |   \---path
|               |           JsonPathLexer.py
|               |           query.py
|               |           validator.py
|               |           __init__.py
|               |           
|               +---mafs
|               |   |   authorization.py
|               |   |   builder.py
|               |   |   fileobject.py
|               |   |   __init__.py
|               |   |   
|               |   \---stdfs
|               |           __init__.py
|               |           
|               +---shell
|               |   |   shebang.py
|               |   |   __init__.py
|               |   |   
|               |   \---script
|               |           builtin.py
|               |           parser.py
|               |           __init__.py
|               |           
|               +---storage
|               |       sqlite.py
|               |       __init__.py
|               |       
|               +---template
|               |   |   __init__.py
|               |   |   
|               |   +---core
|               |   |       context.py
|               |   |       st.py
|               |   |       vm.py
|               |   |       __init__.py
|               |   |       
|               |   +---genshi
|               |   |       translator.py
|               |   |       __init__.py
|               |   |       
|               |   \---smarty
|               |           parser.py
|               |           __init__.py
|               |           
|               +---util
|               |       cache.py
|               |       collection.py
|               |       __init__.py
|               |       
|               \---web
|                       util.py
|                       __init__.py
|                       
\---windows
        keysyms.py
        keysyms.py.20100108.diff
        pyreadline-1.5-win32-setup.exe
        README.Patch.txt
        README.txt
        
||&lt;

</body>
</day>
<day date="2010-08-27" title="">
<body>
*1282886710*[Caty]Webストーンの圏の構造

二重圏なだけじゃないな。

- 1セルを射としてトレース付き圏になる。Int構成もできる。
- 余対角は最初から持っているが、「公平な分配」として対角を持つ。これらは、加法と余加法と呼んだほうがいいかもしれない。
- 有限余完備である。特にファイバー和が存在するので、張り合わせができる。

ここまで豊かな構造を持つと、取り扱いはかえって難しい。モジュール＝1セルと考えるのが楽だが、一種の継承があるので、継承で作られたモジュールはむしろ2セルとみなしたい。1セル-2セルの圏のほうが主体になるようだ。
 


</body>
</day>
<day date="2010-08-31" title="">
<body>
*1283230669*[Caty][トレース／コンパクト閉圏]Webストーンの圏は最初からコンパクト閉圏

Int構成とかしなくても、Webストーン圏は、メッセージ型がリクエストかレスポンスかの区別が極性で、その極性に関して最初からdom/codは極性付きになっている。つまり、Int構成が既に終わってる。あとはアブラムスキー流のタスキがけ対話結合を定義すればいいだけ。

リクエストかレスポンスでもない内部データはどうするか？というと、極性が中性のポートを考えて、そのポートから入出力すればいいのだろう。つまり、方向（通常は上下方向）、境界、三極性を持つ箱を考えればいい。


</body>
</day>
<day date="2010-09-03" title="">
<body>
*1283502703*[Caty][トレース／コンパクト閉圏][多圏]スパイダー亜圏

亜圏（categoroid）って言葉はやっぱり圏もどきという意味。トレース付き圏とそこから作ったコンパクト閉圏を一緒に計算する計算デバイスとしてスパイダー亜圏ってのを考えることにした。ネーミングはどうにもアレだが、いい名前が思い浮かばない。

スパイダー亜圏Cには、Ob(C), Mor(C), dom, cod, idなどがあるが圏にはなってない。演算は、縦結合;、対象モノイド積+、トレース、横結合* の4種類。圏とほとんど同じだし、意味論は圏なんだが、計算は微妙にずれている。ズレの原因は、ボックスのポート（ピン）に名前が付いているから。よって、リネームという操作とリネーム同型が本質的に重要な概念になる。

余対角＝加法と単位がついた対象モノイド圏が舞台。いずれちゃんと書かないとな。


</body>
</day>
<day date="2010-09-07" title="">
<body>
*1283835633*[Caty][トレース／コンパクト閉圏]ヘビの等式とたらい回し定理

コンパクト閉圏を特徴付けるアノ公理。僕が最初に習ったとき（白旗さんの論理の論文だろうか？）は三角等式と呼ばれていたが、最近の若い人は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090307/1236389022&quot;&gt;ヘビの関係式&lt;/a&gt;（snake relation）とか呼ぶらしい。僕もヘビの等式とかヘビの公理とか呼ぶことにする。

Int構成（GoI構成）でヘビの公式を確認すると、やたらにたらい回しした挙句に何もしないという言語道断なお役所みたいなワイヤリングが登場する。ここらを証明した結果は「たらい回し定理」と言ったらよさそう。

たらい回しの凄まじさは絵に描くとよく分かる。目で追えないくらいのたらい回しだ。

*1283835568*[トレース／コンパクト閉圏][モナド][課題]GoI構成はモナドかもしれない

トレース付きモノイド圏の圏を TrMonCat、コンパクト閉圏の圏を CompCCat とする。

GoI構成を G:TrMonCat→CompCCat とする。CompCCatを、標準トレースをトレースとするトレース付きモノイド圏とみなす関手をU（一種の忘却）CompCCat→TrMonCat とする。GとUって随伴じゃないのか？ だとすると、GとUをこの順で結合して、TrMonCat上のモナドができる。

もしGoI構成が（忘却と組み合わせて）モナドだとすると、クライスリ圏とかも作れる。


*1283815906*[caty-depl]Catyが使えるユーザーの設定（2010夏 版）

CentOS上にCatyを使えるユーザーを作る作業をまたやっている。

+ useraddでユーザー追加。 http://d.hatena.ne.jp/m-hiyama-memo/20100122/1264128520 参照
+ FTPアクセスを許可するなら、/etc/vsftd.user_list にユーザー名を追加。

次にMercurialのインストール http://d.hatena.ne.jp/m-hiyama-memo/20100212/1265935055 参照。
念のため繰り返すと：

+ /usr/local/python/bin/python ./virtual-python.py --prefix=$HOME/python2.6.4 --no-site-package
+ ~/python2.6.4/bin/python ./ez_setup.py
+ $HOME/python2.6.4/bin: をパスに加える。
+ 再ログインするか、$ . ./.bash_profile する。
+ easy_install mercurial
+ Mercurialのrcファイル ~/.hgrc を作成OR編集する。[ui]セクションに username=Mercurialのユーザー名 を入れる。hg showconfig で確認可能。

最近は、virtual-pythonよりいいヤツがあるらしいが、、、、

次、Catyリポジトリのクローン：

+ $ hg clone https://m_hiyama@bitbucket.org/project_caty/caty_mainline
+ その他固有なリポジトリがあれば同様にクローンする。

2010-09-06の時点で：

&lt;pre class=&quot;out&quot;&gt;
$ hg clone https&amp;#58;//m_hiyama@bitbucket.org/project_caty/caty_mainline
http authorization required
realm: Bitbucket.org HTTP
user: m_hiyama
password:
destination directory: caty_mainline
requesting all changes
adding changesets
adding manifests
adding file changes
added 1440 changesets with 4910 changes to 1475 files
updating to branch default
436 files updated, 0 files merged, 0 files removed, 0 files unresolved
&lt;/pre&gt;

コンソールが日本語を通さないと次のようになる：

&lt;pre class=&quot;out&quot;&gt;
$ python ./caty.py
Traceback (most recent call last):
  File &quot;./caty.py&quot;, line 15, in &lt;module&gt;
    sys.exit(caty.main(sys.argv[1:]))
  File &quot;./python/caty/__init__.py&quot;, line 8, in main
    return console.main([])
  File &quot;./python/caty/front/console.py&quot;, line 350, in wrapped
    cout.write(traceback)
  File &quot;./python/caty/util/__init__.py&quot;, line 88, in write
    self.stream.write(tb.encode(self.encoding))
UnicodeEncodeError: 'ascii' codec can't encode characters in position 429-443: ordinal not in range(128)
$
&lt;/pre&gt;

http://d.hatena.ne.jp/m-hiyama-memo/20100212/1265941306 にも書いてあるが： LANG=ja_JP.UTF-8 とする。

&lt;pre class=&quot;out&quot;&gt;
$ python ./caty.py
システム情報を読み込んでいます
commands の設定を読み込んでいます
commands に commands が存在しません。自動生成します
commands に schemata が存在しません。自動生成します
commands に scripts が存在しません。自動生成します
commands に include が存在しません。自動生成します
commands に data が存在しません。自動生成します
user の設定を読み込んでいます
user に behaviors が存在しません。自動生成します
user に commands が存在しません。自動生成します
user に pub が存在しません。自動生成します
user に schemata が存在しません。自動生成します
user に include が存在しません。自動生成します
user に data が存在しません。自動生成します
fit-view の設定を読み込んでいます
fit-view に behaviors が存在しません。自動生成します
fit-view に scripts が存在しません。自動生成します
fit-view に data が存在しません。自動生成します
アプリケーショングループ main が存在しません。自動生成します
ルートアプリケーションが存在しません。自動生成します
root の設定を読み込んでいます
root に behaviors が存在しません。自動生成します
root に commands が存在しません。自動生成します
root に pub が存在しません。自動生成します
root に schemata が存在しません。自動生成します
root に scripts が存在しません。自動生成します
root に include が存在しません。自動生成します
root に data が存在しません。自動生成します
アプリケーショングループ extra が存在しません。自動生成します
アプリケーションの設定を適用しています
user の起動スクリプトを実行しています
Caty interactive shell

caty:root&gt;
&lt;/pre&gt;

ポートを開けるためには、iptablesを使う必要がある。以下は、一時的に8000番ポートを開ける例（このとおりにやらないこと、適宜確認と変更）。

&lt;pre class=&quot;out&quot;&gt;
$ sudo /sbin/iptables --line-numbers -L INPUT

$ sudo /sbin/iptables -I INPUT 15 -p tcp --dport 8000 -m state --state NEW -j ACCEPT

$ sudo /sbin/iptables --line-numbers -L INPUT
&lt;/pre&gt;

ポート8080で、ログアウトしても動くようにする。

&lt;pre class=&quot;out&quot;&gt;
$ nohup python caty.py server --port=8080 &amp;

$ logout
&lt;/pre&gt;

nginxの設定例、外部からは8000番でアクセス。それをなかの8080番に流す。ここで使っている8000とか8080とかはあくまで例なので、実際には適当な番号に直す。

&lt;pre class=&quot;code&quot;&gt;
    #
    server {
        listen       8000;
        server_name  www.example.net;
        access_log  logs/www.example.net.access.log  main;

        location / {
            proxy_pass http://localhost:8080/;

            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Server $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
&lt;/pre&gt;

Catyのmain/root/pub/ 内に&lt;em&gt;index.htmlを作っておく。&lt;/em&gt;（最近は自動生成しないので。）

最初は&lt;em&gt;フォアグラウンド&lt;/em&gt;で実行して起動を確認する。 

&lt;pre class=&quot;out&quot;&gt;
$ python caty.py server --port=8080

...
&lt;/pre&gt;

http://www.example.net:8000/にアクセス。もし、8080番のサーバーが落ちていれば、nginxが 502 Bad Gateway を出す。

フォアグラウンドのCatyはキーボード割り込みで終了できる。次にバックグラウンドで実行してみる。

&lt;pre class=&quot;out&quot;&gt;
$ python caty.py server --port=8080 &amp;
[2] 376
...
Serving on port 8080...

$ pgrep python
376
$ wget http://localhost:8080/
&amp;#45;-00:09:19--  http://localhost:8080/
           =&gt; `index.html'
localhost をDNSに問いあわせています... 127.0.0.1
localhost|127.0.0.1|:8080 に接続しています... 接続しました。
HTTP による接続要求を送信しました、応答を待っています... 200 OK
長さ: 76 [text/html]

100%[==============================================&gt;] 76            --.--K/s

00:09:19 (346.82 KB/s) - `index.html' を保存しました [76/76]

$ cat index.html
&amp;#60;html&gt;
&amp;#60;head&gt;&amp;#60;title&gt;hello&amp;#60;/title&gt;
 &amp;#60;body&gt;
  &amp;#60;h1&gt;Hello&amp;#60;/h1&gt;
 &amp;#60;/body&gt;
&amp;#60;/html&gt;
$
&lt;/pre&gt;

バックグラウンドのCatyを停止はプロセス番号とkillコマンドを使う。

</body>
</day>
<day date="2010-09-09" title="">
<body>
*1283987716*[モノイド圏][TQFT]K-L-2001の4章を読もう

なかなか入手できなかった&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/archive?word=%A5%AB%A1%BC%A5%E9%A1%BC&quot;&gt;カーラー／リューバシェンコ（Kerler, Lyubashenko）の本&lt;/a&gt;だが、入手できても読んでない。いかんじゃないの？

第4章だけ単独に読めそうだから、ここだけでも読もうかな。

- 4. Monoidal categories and monoidal 2-categories (p.217 -- p.259; 43pages)

で、主に用語をザッと並べる。

- Deligneのカタカナ書きは「ドリーニュ」か。ドリーニュ・テンソル積 [×] が出てくる。
- BTCは braided abelian tensor categoryの略。なんでBATCじゃないのだ？ どうやら、tensor categoryと呼ぶときは、直和（双積）の存在を前提にしているらしい。abelianだと核と余核が取れる。モノイド積なら直和とは独立な積。
- rigid は双対があることね。右双対対象と左双対対象があって、左右の単位、余単位があってヘビ関係式を満たす。
- rigidの定義では、単位、余単位って言葉を使ってなくて、左右のev, coev だな。評価射、余評価射。
- N-foldのドリーニュ・テンソル積の関手は S&lt;sub&gt;N&lt;/sub&gt;:C×...×C→C、これも使うらしい。
- 絵算は graphical calculi と呼んでいる。いくつかの種類の絵算があるから複数形calculiなんだろう。
- graphical calculiのひとつに、thic braided graphs ってのが登場するらしい。
- tensor categoryとは別に、braided monoidal categoryという概念がある。
- balanced braided monoidal categoryもある。balancingってのが重要らしい。
- C×C→C×Cで、タプルの順序を入れ替えるだけの関手をpermutation functor（置換関手）と呼ぶ。これはいいかも。
- σがn個の入れ替え（n次対称群の元）のとき、置換関手P&lt;sub&gt;σ&lt;/sub&gt;:C×...×C→C×...×C が定義できる。
- 結合律を与える同型射（自然同値）を associativity constraintと呼んでいる。法則性を規定する自然同型を制約と言いたいらしいな。
- 体上の有限次元結合代数の上の加群の圏と圏同値になる圏（アーベル圏か）をbounded categoryと呼んでいる。
- 形容詞として、ribbon, tortile, balancedは同じ。ribbonが使われている。
- ribbon圏にはbalancingがある。balancingが大事らしいよ。

という感じなので、balancingの定義を理解するのが最初の目安かな。

*1283989102*[子供][映画]魔法使いの弟子

次男がいたく気にいってる。彼は登場人物を記憶してるが、僕はサッパリ覚えられない。

- マーリン一派（マーリニアン）
++デイブ 主人公の物理オタク
++ベッキー  デイブの恋人
++バルサザール・ブレイク 師匠（ニコラス・ケイジ）
++ヴェロニカ バルサザールの元恋人（モニカ・ベルッチ）
- モルガナ一派（モルガニスト）
++ ホルヴァート 悪役、コートにネクタイ、小太り
++ ドレイク・ストーン 金髪の若者・手品師
++ サン・ロック 中国人の竜使い
- グリムホールド 魔法使いを閉じ込める入れ子人形（マトリョーシカ）

*1284001638*[モノイド圏][TQFT][用語法]K-L-2001の形容詞の使い方

カーラー／リュウバシェンコでは、形容詞の連続を避けようとしているらしい。例えば：

- rigid category
- braided category
- ribbon category

剛性（rigidity）を定義するには、ベースにモノイド圏が必要だから、rigid monoidal categoryとか言わなくてもいいだろう、という発想。ブレイディングもモノイド圏でしか定義できない。この流儀でいくと、対称圏、トレース付き圏でもいいわけだ。

ところで、rigid categoryの訳語は困るなー。このブログでは「堅い圏」を使っているが、「固い」「硬い」って字もあるし、一時は「rigid=剛」で「剛テンソル圏」「剛圏」とかも使っていた。ゴウケン（剛圏）ってのも何だか剛健質実みたいだしな。

で、バランシングは硬い組み紐付き圏（rigid braided category）でしか定義できないので、バランシングを持つ圏は単にバランスされた圏（balanced category）と呼ぶ。日本語はバランス付き圏でもいいかも。バランス付き硬い組み紐付きモノイド圏（balanced rigid braided monoidal category）は確かに長すぎるよな。

さらに、まだ定義がよくわかってないが、バランシングとリボンツイストが同値なので、リボンツイストを持つ圏＝リボン圏はバランスされた圏と同じ概念なんだとか。

ツイストは「ひねり」と訳していたかな。リンクが「からみ」で、タングルは「もつれ」、tortileは「ねじれ」だったか。ウギャー、区別できるわけねーじゃん。

とりあえず、リボンひねりだけは覚えよう。&lt;em&gt;リボンひねりを持つ圏がリボン圏&lt;/em&gt;だから。

そういえば、自立とか自律も硬いと同義だった。http://d.hatena.ne.jp/m-hiyama-memo/20080830/1220074778 に書いてあるように、形容詞「コンパクト」も「自立＝硬い」と同義だと言っていい。

形容詞の相互関係を理解するのは大変だなー。

+ 対称
+ 組み紐付き（ブレイド付き）
+ 堅い（硬い、固い）、剛
+ 自立、自律
+ コンパクト
+ 閉
+ リボン
+ バランス
+ ねじれ（tortile）



</body>
</day>
<day date="2010-09-24" title="">
<body>
*1285291483*[用語法][トレース／コンパクト閉圏][モノイド圏]余代数の演算を表す言葉

Δと!（またはε）をなんて呼ぶかってことだが、主にモノイド積が直和のときの話。∇はΔの双対、ηとか0は！の双対。

- Δは対角、duplicator, ramificator、重複器、分岐器とか； 分流器がいいような気もする。
- !はdischarger, 放電器； 消流器ってのはどうか？
- ∇は、merger、合流器がいいかな。
- 回路のアナロジーだと複製器、放電器がいいだろうが、制御だと分流器、消流器のほうが語感がいい。
- ηは定数発生器の特殊なもので、零発生器とか単位発生器と呼べばいいだろう。

*1285299098*[用語法][モノイド圏]双対、随伴、転置、左右

[http://d.hatena.ne.jp/m-hiyama-memo/20090114/1231896638:title]に書いたようなことを再び。

バカキリ本以外に、絵算が載っている本としてK-L本（カーラー／リュウバシェンコ）、それとShahn Majidの「量子群プライマー」ってのを持っている。

K-L本の219ページとQGプライマーの70ページの定義を比べてみる。この2冊では、右とか左とかは使わない。単に dual という言葉を使っているだけ。モノイド積は単にカンマで並べるだけで書く、そのほうが絵算に近い。

K-L本：

- ev    : X, X&lt;sup&gt;∨&lt;/sup&gt; → 1
- ev'   : &lt;sup&gt;∨&lt;/sup&gt;X, X → 1
- coev  : 1 → X&lt;sup&gt;∨&lt;/sup&gt;, X
- coev' : 1 → X, &lt;sup&gt;∨&lt;/sup&gt;X

QGプライマー：

- ev    : V&lt;sup&gt;*&lt;/sup&gt;, V → 1
- coev  : 1 → V, V&lt;sup&gt;*&lt;/sup&gt;

K-L本の射の双対は左右の転置、ただし左右という言葉は使わないで記号だけ：

- f&lt;sup&gt;t&lt;/sup&gt; : Y&lt;sup&gt;∨&lt;/sup&gt; → X&lt;sup&gt;∨&lt;/sup&gt;
- &lt;sup&gt;t&lt;/sup&gt;f : &lt;sup&gt;∨&lt;/sup&gt;Y → &lt;sup&gt;∨&lt;/sup&gt;X

QGプライマーでは、随伴（adjoint）と呼んでる：

- f&lt;sup&gt;*&lt;/sup&gt; : W&lt;sup&gt;*&lt;/sup&gt; → V&lt;sup&gt;*&lt;/sup&gt;

後で、白旗さん、バカキリ、セリンガーと一緒にして表にしようかな。

&lt;hr&gt;

表にしてみた。

- &quot;A sequent calculus for compact closed categories&quot; -- http://www.fbc.keio.ac.jp/~sirahata/Research/cmll.pdf
- &quot;A survey of graphical languages for monoidal categories&quot; -- http://www.mscs.dal.ca/~selinger/papers/graphical.pdf

|* -       |* 双対対象     |* 呼び名    |* evの域        |* 双対射      |* 呼び名 |
| 白旗     | A&lt;sup&gt;*&lt;/sup&gt; | Aの左随伴  |A&lt;sup&gt;*&lt;/sup&gt;,A | -            | -       |
|バカキリ  | A&lt;sup&gt;*&lt;/sup&gt; | Aの右双対  |A&lt;sup&gt;*&lt;/sup&gt;,A | f&lt;sup&gt;*&lt;/sup&gt;| fの双対 |
|セリンガー| A&lt;sup&gt;*&lt;/sup&gt; | Aの右双対  |A,A&lt;sup&gt;*&lt;/sup&gt; | f&lt;sup&gt;*&lt;/sup&gt;| fの随伴メイト  |
| K-L      | A&lt;sup&gt;∨&lt;/sup&gt;| なし       |A,A&lt;sup&gt;∨&lt;/sup&gt;| f&lt;sup&gt;t&lt;/sup&gt;| なし  |
|プライマー| A&lt;sup&gt;*&lt;/sup&gt; | 双対       |A&lt;sup&gt;*&lt;/sup&gt;,A | f&lt;sup&gt;*&lt;/sup&gt;| 随伴  |

K-Lでは、&lt;sup&gt;∨&lt;/sup&gt;A と &lt;sup&gt;t&lt;/sup&gt;f も導入する。言葉としては、左右も双対も随伴もあえて使わないという方式。


</body>
</day>
<day date="2010-10-02" title="">
<body>
*1285995171*[メモ]歯医者からの忠告

昨日歯医者に行ったのだった。メモしておこう、忘れるからな。歯磨きに関するアドバイス。

- 上の奥歯はマーマー。
- 左下の奥歯がダメ。もっと奥まで、歯茎もマッサージするように。ウゲーッとなる直前まで押しこむ。
- 前歯の上は縦磨きして、歯茎をマッサージ。
- 全般に歯と歯茎のあいだがダメなので、歯茎を意識すること。


</body>
</day>
<day date="2010-10-09" title="">
<body>
*1286609231*[リンク][からみ系]ゴールドマンとカウフマンの有理タングル（もつれ）

読み物っぽい。

- http://www.math.uic.edu/~kauffman/RTang.pdf

分子生物学の話が出てくるが、Webに応用できないだろうか。

ちなみに、arXivのKauffmanの論文リスト：

- http://arxiv.org/find/math/1/au:+Kauffman_L/0/1/0/all/0/1

*1286613255*[リンク][からみ系][TQFT][物理っぽい]カウフマンとかの論文

元気が無いとき、虚しくなったときに、カウフマンはけっこういいのだ。

- Title: Anyonic Topological Quantum Computation and the Virtual Braid Group
- Authors: H. A. Dye, Louis H. Kauffman
- URL: http://arxiv.org/abs/0909.1672

連休中の娯楽に。元気が出るかもよ。

</body>
</day>
<day date="2010-10-18" title="">
<body>
*1287358225*[Caty]CatyScript 2.0

とりあえず予定つうか希望を。

+ ワード概念とワードの解釈の明確化（文字列解釈、名前解釈、値解釈）
+ when分岐の拡張（疑似タグ分岐と値分岐）
+ 変数参照の明確化（構文、メカニズム、意味論）
+ スコープの明確化（環境変数、パラメータも含めて）
+ set, doset構文の導入
+ ハイフン変数の導入（名前が'-'である特殊変数）
+ 制御用パイプ記号 ';', '|&amp;', '||' の導入
+ コマンド宣言からコマンド定義に
+ begin/repeat制御構造（エルゴット・イテレーション）

最大の変化とウリは、begin/repeat制御。repeat単独でも使えるが、ともかく繰り返しの構文。goto-with-data を実行するおそらくは&lt;em&gt;一番安全な構文&lt;/em&gt;で、エルゴット・イテレーションにより意味論が完璧に作れる。ただし、tame CatyScript にはrepeat&lt;em&gt;入れない&lt;/em&gt;。Webで長時間処理は困るから。

エルゴット・イテレーションはコンウェイ不動点演算子の双対。直和によるモノイド圏の、単位対象（空集合）、余対角（fold）、トレースを使って定義される。エルゴット・イテレーションからトレースを再現可能。これは、不動点からのトレース再現の双対。

*1287358319*[Caty][トレース／コンパクト閉圏]エルゴット・イテレーション付きのCatyScript

CatyScript 2.0 で何ができるか？ まずは例から：

&lt;pre class=&quot;code&quot;&gt;
/** 整数値の階乗を求める
 * 入力として負の整数を許す、負の入力に対する出力はその数
 */
command fact :: integer -&gt; integer {
  [dec, pass] | fact2
};

command fact2 :: [integer, integer] -&gt; integer {
 doset {
  nth 1 &gt;= n,
  nth 2 &gt;= m
 };
 %n | zero-p || negative-p |
 when {
  OK =&gt; %m,
  NG =&gt; [(%n | dec), ([%n, %m] | mul)] | repeat // 繰り返し
 }
};

&lt;/pre&gt;

機能も視認性も普通のプログラミング言語と&lt;em&gt;遜色ない&lt;/em&gt; -- 慣れの問題はあるだろうが。比較にJavaScript版。

&lt;pre class=&quot;code&quot;&gt;
function fact(k) {
    return fact2(k -1, k);
}

function fact2(n, m) {
    if (n &amp;#60;= 0) {
	return m;
    } else {
	return fact2(n - 1,  n * m);
    }
}
&lt;/pre&gt;

以下に補足：

&lt;h6&gt;コマンド&lt;/h6&gt;

事前定義されたコマンドは：

+ dec :: integer -&gt; integer //* 入力から1引く
+ mul :: [number, number] -&gt; number //* 掛け算をする
+ zero-p :: number -&gt; @(OK|NG) number //* ゼロかどうか判断する
+ negative-p :: number -&gt; @(OK|NG) number //* 負の数かどうか判断する

&lt;h6&gt;変数参照&lt;/h6&gt;

変数参照はパーセントを使う。ほとんどどこにでも変数参照を書ける。

&lt;h6&gt;set, doset構文&lt;/h6&gt;

set構文は、set { varname = expression, ...}。JSONオブジェクトを使うのはやめた、変数名は裸で書いて、代入記号はイコール使う。doset構文は、set構文の diagrammatice order (do)版。'&gt;=' は&lt;em&gt;不等号じゃない&lt;/em&gt;のよね！（クレーム来そうだが） 変数が1個のときに、set varname = expression を許すか？ 許したほうが使いやすそうだが、expressionの終端が問題（大丈夫かな）。

&lt;h6&gt;制御構造&lt;/h6&gt;

+ '|' は単なるパイプ
+ ';' は左側からの入力を捨てるパイプ、f ; g は f | void | g
+ '||' は短絡ORを意味するパイプ f || g は f | (when {OK==&gt;pass, NG=&gt;g})
+ '|&amp;' は短絡ANDを意味するパイプ f |&amp; g は f | (when {OK=&gt;g, NG==&gt;pass})
+ repeatはスコープの最初に戻る。スコープはトップレベルブロック、beginブロック、eachブロックで作られる。repeatの入力は、そのまま次の繰り返しの入力となる。繰り返しに入る直前でブロック内の局所環境は&lt;em&gt;完全にクリアされる&lt;/em&gt;。ループカウンタなどは入出力で渡すかファシリティを使うしか無い。異なる繰り返し実行において局所状態は共有できない。

&lt;h6&gt;注目！&lt;/h6&gt;

注目すべきはrepeatで、beginと共に（beginはなくてもいいが）エルゴット・イテレーションを実現する。エルゴット・イテレーションは、コンウェイ不動点の双対であり、直和をモノイド積とするモノイド圏のトレースと余対角で表現できる。

実行モデルは、一方向に進むだけ。ルーピングする繰り返しはあっても、「呼ばれて戻る」という概念はない。したがって、戻るために何かを覚えておくこともない。スコープごとの束縛環境はあるが、コールスタックはない。

エルゴット・イテレーション（goto-with-data; 行きっぱなし制御）を使った言語ってあんまりないと思うが、call/return方式と比べて、goto-with-data方式のほうが有利な点がある。

+ 意味論が単純。
+ 完全に図式的な表現ができる。（レイアウトが難しいが。）
+ スタックフレームを使わないので、スタックオーバーフローはない。（無限走行はある。積極的に無限走行してもよい。）
+ 現在のコンピュータハードウェアによる処理に向いているので、低水準での最適化がしやすい。可能性としては、少ないメモリで高速に実行できる。

call/returnではないのにも関わらず、考え方は再帰である。one-way recursion（一方向再帰）とでも呼ぼうか。累積変数を使う（last-call最適化された）末尾再帰だと思えばよい。リストの逆転を書いてみる。図式的に、つまり&lt;em&gt;厳密に型付けされたフローチャートで考えるのがコツ&lt;/em&gt;。

&lt;pre class=&quot;code&quot;&gt;

command reverse&lt;T&gt; :: [T*] --&gt; [T*] {
  [ [ ], pass ] | reverse2
};

command reverse2&lt;T&gt; :: [ [T*] , [T*] ] --&gt; [T*] {
 doset {
   nth 1 &gt;= acc, // 累積変数
   nth 2 &gt;= rest // 残っている処理対象
 };

 %rest | list:empty-p |
 when {
   OK =&gt; %acc,
   NG =&gt; doset {list:car &gt;= first, list:cdr &gt;= rest2};
         [ ([%first, %acc] | list:cons), %rest2 ] | repeat // 繰り返し
 }
};

&lt;/pre&gt;

JavaScript版、補助関数付き。

&lt;pre class=&quot;code&quot;&gt;
function list_empty_p(lis) {
    return lis.length == 0;
}

function list_car(lis) {
    return lis[0];
}

function list_cdr(lis) {
    lis.shift();
    return lis;
}

function list_cons(x, lis) {
    lis.unshift(x);
    return lis;
}

// ここからが本チャン

function reverse(lis) {
    return reverse2([], lis);
}

function reverse2(acc, rest) {
    if (list_empty_p(rest)) {
	return acc;
    } else {
	var first = list_car(rest);
	var rest2 = list_cdr(rest);
	return reverse2(list_cons(first, acc), rest2);
    }
}
&lt;/pre&gt;

beginブロックを使って1つにまとめれば：

&lt;pre class=&quot;code&quot;&gt;

command reverse&lt;T&gt; :: [T*] --&gt; [T*] {
  [ [ ], pass ] | 
  begin {
    doset {
      nth 1 &gt;= acc, // 累積変数
      nth 2 &gt;= rest // 残っている処理対象
    };

    %rest | list:empty-p |
    when {
      OK =&gt; %acc,
      NG =&gt; doset {list:car &gt;= first, list:cdr &gt;= rest2};
            [ ([%first, %acc] | list:cons), %rest2 ] | repeat // 繰り返し
            // beginブロックの最初から繰り返す
    }
  }
};

&lt;/pre&gt;

簡単なカウントダウンも挙げれば：

&lt;pre class=&quot;code&quot;&gt;
/* e.g. caty&gt; 10 | countdown  */

command countdown :: integer -&gt; void {
  zero-p || negative-p |
  when {
    OK =&gt; void,
    NG =&gt; dump | dec | repeat 
  }
};

&lt;/pre&gt;

あと、無限ループ：

&lt;pre class=&quot;code&quot;&gt;

command forever :: void -&gt; void {
  do-something; repeat
};

&lt;/pre&gt;

&lt;h6&gt;その他&lt;/h6&gt;

ハイフン変数とパス記法は入れてもいい気がする。%- は input、%-.1 は input[1]。%-1 は %_ARGV[-1]。%foo[1].a.bとかもみたまんま。


</body>
</day>
<day date="2010-10-22" title="">
<body>
*1287725345*[メモ]アホでもノロマでも少しずつ前に進む方法

同じことを延々と考え続ける／やり続ける／言い続ける。

同じこと：檜山の場合はお絵描き圏論で計算やデータを記述できるということ。

</body>
</day>
<day date="2010-10-26" title="">
<body>
*1288061974*[Caty]注意！

完全かつ網羅的、しかもソフトウェアと同期したリファレンスがないと、チュートリアルは役に立たない。

*1288062272*[Caty]名前

名前は難しい。

+ タグ名 -- 先頭数字許す Nmtoken
+ パスセグメント -- 非負整数表現を許したい、ピリオドはダメ、「2a」とかは？
+ 変数名 -- 先頭数字と先頭ハイフンはダメ、ハイフン許したい
+ コマンド名 -- 先頭数字と先頭ハイフンはダメだろう、ハイフン許している
+ 型名 -- コマンド名となんか違うのか、ハイフン許したい
+ オプション名 -- 先頭数字許したい。先頭ハイフンはダメ、ハイフン許している
+ モジュール名 -- 型名と同じかな
+ パッケージ名 -- 型名と同じかな
+ 外部（Web）から見えるファイル名 -- 先頭ピリオドと先頭アンダスコアはダメだろう

&lt;h5&gt;名前と文字の関係&lt;/h5&gt;

+ '-' -- 特別な意味はないが禁止している
+ '=' -- 左に同じ
+ '○' -- 許す
+ WSC -- Word Start Char
+ WC -- Word Char


|* 文字 |* XJSONパス  |* XJSON   |* スクリプト   |* スキーマ |* WSC |* WC |
|0x21 ! |  -          |   -      | -             | -         |      |     |
|0x22 &quot; |文字列       |文字列    | =             | =         |      |     |
|0x23 # |数値ワイルド | -        | ハッシュ記法'#('| -       |      | ○  |
|0x24 $ |ルート       | -        | when条件      | -         |      | ○  |
|0x25 % | -           | -        | 変数          | -         |      |     |
|0x26 &amp;amp; | -           | -        |ANDパイプ'&amp;#124;&amp;'| AND演算|      |     |
|0x27 ' | -           | -        | -             | -         |      |     |
|0x28 ( | -           | -        | グルーピング  | グルーピング |   |     |
|0x29 ) | -           | -        | グルーピング  | グルーピング |   |     |
|0x2a * |文字列ワイルド|-        | -             | クリーネスター | |     |
|0x2b + | -           | -        | -             | Rマージ++  |     | ○  |
|0x2c , | -           | 区切り   | =             | =          |     |     |
|0x2d - | -           | -        | 特殊な名前    | -          | ○  | ○  |
|0x2e . | -           | -        | -             | -          | ○  | ○  |
|0x2f / | -           | -        | -             | -          | ○  | ○  |
|0x3? 数字|インデックス| 数値    | =             | =          | ○  | ○  |
|0x3a : | -           | 区切り   | =             | =, '::'    |     | ○  |
|0x3b ; | -           | -        | voidパイプ    | 終端       |     |     |
|0x3c &lt; | -           | -        | -             | 括弧       |     |     |
|0x3d = | -           | -        | 代入          | 代入       | ○  | ○  |
|0x3e &gt; | -           | -        | リダイレクト  | 括弧       |     |     |
|0x3f ? | -           | -        | -             | オプション |     |     |
|0x40 @ | 予約        | タグ     | =             | =, '@['    |     | ○  |
|0x5b [ |括弧         | 括弧     | =             | =          |     |     |
|0x5c \ | -           | -        | -             | -          |     |     |
|0x5d ] |括弧         | 括弧     | =             | =          |     |     |
|0x5e ^ |予約         | -        | -             | -          |     | ○  |
|0x5f _ | -           | -        | -             | -          | ○  | ○  |
|0x60 ` | -           | -        | -             | -          |     |     |
|0x7b { | -           |括弧      | =             | =          |     |     |
|0x7c &amp;#124; | =      | =        | パイプ        | ユニオン   |     |     |
|0x7d } | -           |括弧      | =             | =          |     |     |
|0x7e ~ | -           | -        | -             | -          |     | ○  |


- ワード列を終端させる記号： ')', '}', ']', ';' |', '|&amp;amp;' '||', ','
- ワード列中でエラーとなる記号：'(', '{', '[', '&lt;', '&gt;', &quot;'&quot;, '&quot;', '%', '&amp;amp;', '*', '?', '\'

名前の定義を http://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name より：

&lt;pre&gt;
Name ::= NameStartChar (NameChar)*

NameStartChar ::= &quot;:&quot; | [A-Z] | &quot;_&quot; | [a-z] |
   [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | 
   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | 
   [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | 
   [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::= NameStartChar | &quot;-&quot; | &quot;.&quot; | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]

Nmtoken  ::= (NameChar)+
&lt;/pre&gt;

これを参考にすると：

&lt;pre&gt;
I18NNameChar :: =  [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | 
   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | 
   [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | 
   [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]


Name ::= NameStartChar (NameChar)*

NameStartChar ::= [A-Z] | &quot;_&quot; | [a-z] | I18NNameChar

NameChar ::= NameStartChar | &quot;-&quot; | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]

Nmtoken  ::= (NameChar)+
&lt;/pre&gt;

とか？

</body>
</day>
<day date="2010-10-29" title="">
<body>
*1288313233*[Caty]ストーンて、なんだっけ？

ストーンは、 State-Transition Oriented Network Element の略語のつもりだった。しかし、Webモジュールとかでいいかな。

reQurst-Input, reSponse-Input, reQurst-Output, reSponse-Output の4つの面を持つ。面にはチャネルが付いていて、チャネルには名前が付いている。入力チャネルと出力チャネルに同じ名前を付けるのはかまわないが、入力内と出力内でチャネル名は一意。チャネルはものすごくいっぱい付いていて、ワイヤーの束はすごいことになっているかもしれない。

*1288314381*[Caty]Catyスクリプトでモノイド圏の基本

リダイレクト記号を使ってみる。

&lt;pre class=&quot;code&quot;&gt;
command codiag&lt;T&gt; ::  @1 T | @2 T -&gt; T {
 when {
   1 =&gt; pass,
   2 =&gt; pass
 }
};

command diag&lt;T&gt; :: T -&gt; @1 T | @2 T {
 pass &gt;in;
 randomint 1 2 &gt;tag;
 %in | tagged %tag
};

command assoc&lt;A,B,C&gt; :: @1 (@1 A | @2 B) | @2 C -&gt; @1 A | @2 (@1 B | @2 C) {
 when {
  1 =&gt; when {
        1 =&gt; /*@1 @1*/ @1 pass,
        2 =&gt; /*@1 @2*/ @2 @1 pass,
       },
  2 =&gt; @2 @1 pass
 }
};

command assoc-inv&lt;A,B,C&gt; :: @1 A | @2 (@1 B | @2 C) -&gt; @1 (@1 A | @2 B) | @2 C {
 when {
  1 =&gt; @1 @1 pass,
  2 =&gt; when {
        1 =&gt; /*@2 @1*/ @1 @1 pass,
        2 =&gt; /*@2 @2*/ @2 pass,
       }
 }
};
&lt;/pre&gt;

</body>
</day>
<day date="2010-11-02" title="">
<body>
*1288667966*[Caty][プログラム意味論][圏一般論]Catyと圏論いろいろ

+ データ領域は実は集合&lt;em&gt;ではない&lt;/em&gt;。setoid。だから、ほんとはsetoidの圏を使わないといけない。かなりめんどくさい。
+ 基礎の圏は双デカルト圏であり半環圏である。これは基本のキ。
+ 基礎の圏はskeletalかもしれない。（http://en.wikipedia.org/wiki/Skeleton_%28category_theory%29）
+ ファシリティでモナドが定義され、クライスリ圏に拡張される。ここは難しい。クライスリ拡張が良い性質を持つかどうか不明。複数のモナドの関係もあるし。難しい。
+ 包含付き圏（catigory with inclusions）である。包含（subcategory of inclusions）がないと、パイプが定義できない。
+ ListモナドとMaybeモナド（Option型）は組み込まれている。
+ 直和に関するトレースが存在する。直積のトレース？ いまいち分からない。
+ 例外に関して4項ホムセット（二車線データフロー）を持つ。
+ トレースと例外はファントムタグ（#next, #except）で扱う。たぶん。
+ evalを有効化すれば閉圏になるのだが、ここの考察は不十分。今まで、ベキ（指数）型をそれほど真面目に考えてなかった。

*1288668784*[Caty][メモ]そもそもURI構文

&quot;Uniform Resource Identifier (URI): Generic Syntax&quot; というタイトルのRFCは2つある。

- RFC2396（1998年発行）http://www.ietf.org/rfc/rfc2396.txt, http://tools.ietf.org/html/rfc2396
- RFC3986（2005年発行）http://www.ietf.org/rfc/rfc3986.txt, http://tools.ietf.org/html/rfc3986

それと：

- http://www.w3.org/DesignIssues/MatrixURIs.html

歴史的資料として：
                 
- Universal Resource Identifiers in WWW  http://tools.ietf.org/html/rfc1630 
- Uniform Resource Locators (URL) http://tools.ietf.org/html/rfc1738


</body>
</day>
<day date="2010-11-05" title="">
<body>
*1288942164*[メモ][リンク]BCP = Best Current Practice 14

- http://tools.ietf.org/html/rfc2119 Key words for use in RFCs to Indicate Requirement Levels
 


</body>
</day>
<day date="2010-11-09" title="">
<body>
*1289265674*[Caty]無限FizzBuzzをCatyスクリプトで書いてみる

CatyScript 2.0 では、メモリ資源（スタック）を消費しない再帰呼び出しを使って、意図的に無限ループを書ける。長時間セルフテスト（マゾテスト）のために無限ループは必要なのだ。

で、無限に続くFizzBuzzを書いてみる。実際には整数がラップアラウンドしてしまうが、エラーが起きないかぎり無限に続く。

事前定義されているコマンド：

&lt;pre class=&quot;code&quot;&gt;
/** 入力を1増やして出力する */
command inc :: integer -&gt; integer;

/** 入力第1項目を第2項目で割り算して、商と余りを出力 */
command div :: [integer, integer] -&gt; [integer, integer];

/** passと同じだが、引数で指定された秒数だけ何もしないで待つ */
command wait&lt;T&gt; [number] :: T -&gt; T;
&lt;/pre&gt;

無限FizzBuzz：真偽値はTrue, Falseを使うことにしてみる。eqはTrue, False対応と仮定。代入式は '&gt;' で書く。

&lt;pre class=&quot;code&quot;&gt;
/** 入力が、引数で指定された数で割り切れるかどうかを判定する */
command dividable [integer] :: integer -&gt; @(True|False) integer {
 [pass &gt; n, %1] | div | [nth 2, 0] | eq | 
 when {
  True =&gt; @True %n,
  False =&gt; @False %n
 }
};

/** 入力値を開始の数として、FizzBuzzを永遠に続ける。
 * 出力を生成することはないので、出力の型はneverである。
 */
command fizzbuzz-forever :: integer -&gt; never {
 dividable 15 |
 when {
   True =&gt; [pass, (&quot;Fizz Buzz&quot; | cout)] | nth 1,         // 15の倍数
   False =&gt; dividable 3 |
        when {
          True =&gt; [pass, (&quot;Fizz&quot; | cout)] | nth 1,       // 3の倍数
          False =&gt; dividable 5 |
               when {
                 True =&gt; [pass, (&quot;Buzz&quot; | cout)] | nth 1,// 5の倍数
                 False =&gt; [pass, (cout)]| nth 1 // その他
               }
        }
 } | wait 1 | inc | repeat
};
&lt;/pre&gt;

副作用を記述する構文マクロsideがあると少し短くスッキリ書ける。

&lt;pre class=&quot;code&quot;&gt;
command fizzbuzz-forever :: integer -&gt; never {
 dividable 15 |
 when {
   True =&gt; side {&quot;Fizz Buzz&quot; | cout},         // 15の倍数
   False =&gt; dividable 3 |
        when {
          True =&gt; side {&quot;Fizz&quot; | cout},       // 3の倍数
          False =&gt; dividable 5 |
               when {
                 True =&gt; side {&quot;Buzz&quot; | cout},// 5の倍数
                 False =&gt; side {cout}         // その他
               }
        }
 } | wait 1 | inc | repeat
};
&lt;/pre&gt;

1回分なら、今のCatyでも書ける。

&lt;pre class=&quot;out&quot;&gt;
caty:misc&gt; 10 | fizzbuzz-once.caty
Buzz
11
caty:misc&gt; 10 | fizzbuzz-once.caty | fizzbuzz-once.caty
Buzz
11
12
caty:misc&gt; 10 | fizzbuzz-once.caty | fizzbuzz-once.caty | fizzbuzz-once.caty
Buzz
11
Fizz
13
caty:misc&gt; 14 | fizzbuzz-once.caty | fizzbuzz-once.caty | 
&gt; fizzbuzz-once.caty | fizzbuzz-once.caty | fizzbuzz-once.caty | void
14
Fizz Buzz
16
17
Fizz
caty:misc&gt;
&lt;/pre&gt;

今、coutに不具合（仕様ともいえる）があって、一箇所sayに置き換えた。

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
// tihs is fizzbuzz-once.caty

 dividable 15 |
 when {
   True =&gt; [pass, (&quot;Fizz Buzz&quot; | cout)] | nth 1,         // 15の倍数
   False =&gt; dividable 3 |
        when {
          True =&gt; [pass, (&quot;Fizz&quot; | cout)] | nth 1,       // 3の倍数
          False =&gt; dividable 5 |
               when {
                 True =&gt; [pass, (&quot;Buzz&quot; | cout)] | nth 1,// 5の倍数
                 False =&gt; [pass, say] | nth 1 // その他
               }
        }
 } | inc 

&lt;/pre&gt;

dividableとinc、それとsayは、Pythonで書いておく。

&lt;pre class=&quot;code&quot;&gt;
# -*- coding: utf-8 -*- 
# 
#
from caty.command import Command
from caty.jsontools import tagged

class Inc(Command):
    def execute(self, input):
        return input + 1

class Dividable(Command):
    def setup(self, n):
        self.n = n
    def execute(self, input):
        r = input % self.n
        if r == 0:
            return tagged('True', input)
        else:
            return tagged('False', input)

# coutの代替
class Say(Command):
    def execute(self, input):
        t = type(input)
        if (t is int) or (t is float):
            print &quot;%d&quot; % input
        else: # t is unicode
            print &quot;%s&quot; % input
        return None
&lt;/pre&gt;

スキーマ：

&lt;pre class=&quot;code&quot;&gt;
module public; // -*- coding: utf-8 -*-

/** 入力を1増やして出力する */
command inc :: integer -&gt; integer
refers python:cmd.Inc;

/** 入力が、引数で指定された数で割り切れるかどうかを判定する */
command dividable [integer] :: integer -&gt; (@True integer | @False integer)
refers python:cmd.Dividable;

/** coutの代替 */
command say :: number | string -&gt; void
refers python:cmd.Say;

// End of Module
&lt;/pre&gt;

*1289266055*[Caty]ディレクトリツリー生成をCatyスクリプトで書いてみる

repeatではなくて、普通の再帰を使ってみる。これはスタックフレームを消費する。名前付きコマンドを許してしまうと、repeatがあっても結局コールスタックベースの再帰は必要になる。

&lt;pre class=&quot;code&quot;&gt;
type path = string(format=path);

type Item = {&quot;name&quot; : string, &quot;isDir&quot; : boolean, *:any?};

type Tree = {
 &quot;name&quot; : string,
 &quot;child&quot; : [Tree*]?
};

command tree [path] :: void -&gt; Tree {
 do {
   %1 | path:basename            &gt;: &quot;name&quot;,
   lsdir %1 | 
   each{ [%1, pass] | make-tree }&gt;: &quot;child&quot;
 }
};

command make-tree :: [path, Item] -&gt; Tree {
 set { nth 1 &gt;parent, nth 2 &gt;- }|
 when isDir {
    false  ==&gt; // ファイル、終端
           do {
             pv name &gt;: &quot;name&quot;
           }, 
    true   ==&gt; // ディレクトリ、再帰
           [%parent, pv name &gt; name] | path:join &gt; new_path; 
           do {
             %name &gt;: &quot;name&quot;,
             lsdir %new_path | 
             each { [%new_path, pass] | make-tree } &gt;: &quot;child&quot;
           }
 }
};
&lt;/pre&gt;

make-tree呼び出しを単純にrepeatに置き換えることはできない。eachが暗黙のbeginを含むので、eachスコープを超えて制御を戻せない。begin { [%new_path, pass] | repeat }は無限ループになるので、each { [%new_path, pass] | repeat } も無限ループ。
             
make-treeを全面的に書き換えれば、repeatに（つまり末尾再帰に）できるが、そうやってもメモリの節約にはならない。スタックは使わないが、入力がスタックの代わりに膨らむので同じことだ。再帰が時間方向だけじゃなくてデータ方向にも膨らむ過程なら、末尾再帰に直して最適化してもメモリを食いつぶす。

末尾再帰で無限に走れるのは、記憶が蓄積されないで時間だけを消費する繰り返し。なにかを忘れない限りは無限には繰り返せない。スタックベースの再帰とrepeatが決定的に違う状況は、空間有限、時間無限で走るとき。


</body>
</day>
<day date="2010-11-11" title="">
<body>
*1289446214*[Caty]何度も繰り返すことをCatyスクリプトで書いてみる

CatyScriptの基本はともかくパイプライン。CatyScriptの変数は、パイプライン・プログラミングの補助的なツールとなる。

すべてのデータをパイプラインだけで取り扱う場合、後で使う予定のデータを何もしないで単にパイプライン内を引き回すことになり、これは面倒だし可読性もすごく低下する。そこで、律儀にパイプラインを通さないでワープするような、&lt;em&gt;データ時空のワームホール&lt;/em&gt;のようなものがあると便利、それが変数。

/test/000.html から /test/999.html にリクエストするコマンドを書いてみる。（&lt;b&gt;[追記]&lt;/b&gt;gr-eq を gt-eq に変更&lt;b&gt;[/追記]&lt;/b&gt;）

&lt;pre class=&quot;code&quot;&gt;
/** greater-or-equal 述語 */
command gt-eq [number] :: number -&gt; @(True|False) number;

/** 入力を1増やす */
command inc :: integer -&gt; integer;

/** 文字列の整形 */
command format [string] :: any -&gt; string;
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;

command request-1000 :: void -&gt; void {
 0 | // 初期値の投入
 begin {
  gt-eq 1000 |
  when {
   True  =&gt; void, // オシマイ
   False =&gt; set { pass &gt; count, format &quot;/test/%03d.html&quot; &gt; path};
            request %path; // リクエストの実行
            %count | inc | repeat // beginの先頭に飛ぶ
  }
 }
};

&lt;/pre&gt;

この例だとカウンタ変数にあたるデータがパイプラインを流れるが、begin/repeatでぐるぐる回る。パイプラインの一部でループする。それがエルゴット繰り返し＝加法的トレース。


</body>
</day>
<day date="2010-11-12" title="">
<body>
*1289522839*[Caty][CatyScript]Catyスクリプトの書き方 ナニカと比較編

&lt;h5&gt;普通のプログラミング言語との比較&lt;/h5&gt;

逐次実行 A; B
&lt;pre class=&quot;code&quot;&gt;
// 流すデータがあるなら
A | B

// 流すデータがないなら
A ; B
&lt;/pre&gt;

条件分岐 if P then A else B 
&lt;pre class=&quot;code&quot;&gt;
P | when {True=&gt;A, False=&gt;B}
&lt;/pre&gt;

条件分岐 if P then A endif
&lt;pre class=&quot;code&quot;&gt;
// 次にデータを流すなら
P | when {True=&gt;A, False=&gt;pass}

// データを流さないなら
P | when {True=&gt;A, False=&gt;void}
&lt;/pre&gt;

リストのfor文 foreach x in list do A
&lt;pre class=&quot;code&quot;&gt;
list | each {A}
&lt;/pre&gt;

while文 while P do A
&lt;pre class=&quot;code&quot;&gt;
begin {P | when {False=&gt;void, True=&gt; A | repeat}}
&lt;/pre&gt;

短絡AND P andalso Q
&lt;pre class=&quot;code&quot;&gt;
P |&amp; Q
&lt;/pre&gt;

短絡OR P orelse Q
&lt;pre class=&quot;code&quot;&gt;
P || Q
&lt;/pre&gt;

代入文 x := A
&lt;pre class=&quot;code&quot;&gt;
A &gt; x
&lt;/pre&gt;

&lt;h5&gt;圏論との比較&lt;/h5&gt;

射の結合 f;g （ほんとは、inclusionをはさむ）
&lt;pre class=&quot;code&quot;&gt;
f | g
&lt;/pre&gt;

恒等射 id
&lt;pre class=&quot;code&quot;&gt;
pass
&lt;/pre&gt;

デカルトペアリング &amp;lt;f, g&gt;
&lt;pre class=&quot;code&quot;&gt;
[f, g]

{&quot;a&quot;:f, &quot;b&quot;:g}

do {f &gt;:&quot;a&quot;, g &gt;:&quot;b&quot;}
&lt;/pre&gt;

射影 π&lt;sub&gt;1&lt;/sub&gt;
&lt;pre class=&quot;code&quot;&gt;
nth 1
pv a
&lt;/pre&gt;

終射 !
&lt;pre class=&quot;code&quot;&gt;
void
&lt;/pre&gt;

デカルト余ペアリング [f, g]
&lt;pre class=&quot;code&quot;&gt;
when {1=&gt;f, 2=&gt;g]
&lt;/pre&gt;

入射 ι&lt;sub&gt;1&lt;/sub&gt;
&lt;pre class=&quot;code&quot;&gt;
@1 pass
&lt;/pre&gt;

クリーネスター f*
&lt;pre class=&quot;code&quot;&gt;
each {f}
&lt;/pre&gt;

エルゴットダガー f&lt;sup&gt;†&lt;/sup&gt;
&lt;pre class=&quot;code&quot;&gt;
begin {f | when {1=&gt;pass, 2=&gt;repeat}}
&lt;/pre&gt;

*1289524737*[Caty]unshaffleとクリーネスターの双対

直積と直和の双対性の意味でクリーネスターの双対を書こうとすると、対角Δの直和における対応物が必要になる。それをunshaffleとすると、begin {f | unshuffle | when {1=&gt;pass, 2=&gt; repeat}} がクリーネスターの双対になる。これは一体何に使えるのだろう？


</body>
</day>
<day date="2010-11-24" title="">
<body>
*1290558087*[Caty]CatyQL-N3 クエリ言語の新しい構文（かな？）

N3はNotation3、RDFの構文でN3ってあったような、それの真似。

[http://d.hatena.ne.jp/m-hiyama/20101122/1290405741:title]の目次に沿って定義する。最後のほうの結論(?)は結局、&lt;em&gt;N3なんて要らねんじゃね。&lt;/em&gt;

+ 二項関係による条件
++ 等号
++ 数値の大小比較
++ 文字列のマッチング
++ 所属（型の判定）
+ 論理結合子
+ 配列の条件
+ オブジェクトの条件
+ ANYとUNDEFINED
+ 配列に関する全称命題と存在命題

&lt;h5&gt;二項関係による条件&lt;/h5&gt;

N3では、普通のプログラマに馴染みの記号を使う。

|* 関係演算子 |* 英字綴り名 |* 記号|
| 等しい      |  EQ         | ==   |
| 大なり      |  GT         | &gt;    |
| 大なりイコール|  GE       | &gt;=   |
| 小なり      |  LT         | &amp;#60;    |
| 小なりイコール|  LE       | &amp;#60;=   |
| マッチ      |LIKE, MATCH  | ＝~   |

無名変数（アンダスコア）も省略して、条件は次の形に書く。

- '(' 関係演算子記号  JSON定数リテラル ')'

例：

+ (&gt;= 0)
+ (== &quot;M&quot;)
+ (== {&quot;x&quot;: 1, &quot;y&quot;: -3.5})
+ (=~ /^a.*x/i)
+ (=~ 'a%')

LIKEとMATCHの区別は、パターン側の構文で決定する。

所属（型の判定は型名）そのものを用いる。

例：
+ integer -- 整数である
+ boolean -- 真偽値である
+ any -- なんでもいい
+ undefined -- 未定義値である。

&lt;h5&gt;論理結合子&lt;/h5&gt;

&amp;#38;と||を用いる。&amp;#38;&amp;#38;ではなくて&amp;#38;が1個なところが問題になるかもしれない。「スキーマ言語とあわせたい」というのが意図。スキーマ言語側を&amp;#38;&amp;#38;に変える手もある。否定はとりあえず!とする。


|* 記号の候補案  |* AND  |* OR  |* NOT |* 問題点|
| C風            | &amp;#38;&amp;#38;    | &amp;#124;&amp;#124;   | !    |スキーマ言語と違う|
| 折衷案         | &amp;#38;    | &amp;#124;&amp;#124;   | !    |アンバランス|
| 別な案         | &amp;#38;    | &amp;#124;,        | !    |変な記号|
| さらに別な案   | &amp;#38;    | /        | !    |/は正規表現に使いたい|
| 綴りを使う     | and    | or        | not    |タイピングが面倒|
| 綴り別案       | &amp;amp;  | or        | not    |中途半端|

!(= X) は (!= X) と書いてよい。

&lt;h5&gt;配列の条件&lt;/h5&gt;

配列リテラルと同じ形。オプショナルの'?'、繰り返しの'*'を使ってよい。ただし、繰り返しは最後だけ。オプショナルも出現制限がある。

例：
- [integer, integer &amp;#38; (&gt;= 0), (=~ /[a-z]+/)?, (=~ /[a-z]+/)*]

&lt;h5&gt;オブジェクトの条件&lt;/h5&gt;

オブジェクトリテラルと同じ形。オプショナルの'?'、その他のプロパティに'*'を使ってよい。スキーマ言語と同じ。

&lt;h5&gt;宣言と名前付きクエリ&lt;/h5&gt;

query宣言で名前を付けて、他の場所で使ってよい。

&lt;pre class=&quot;code&quot;&gt;
query tokyo = (=~ /東京|Tokyo/i);

query tokyoGirl = {
  &quot;addr1&quot; : tokyo,
  &quot;gender&quot;:(= &quot;F&quot;),
  &quot;age&quot;:(=&lt; 24)
};
&lt;/pre&gt;

対応するスキーマ。

&lt;pre class=&quot;code&quot;&gt;
type tokyo = string(pattern =&quot;/東京|Tokyo/i&quot;);

type tokyoGirl = {
  &quot;addr1&quot; : tokyo,
  &quot;gender&quot;:&quot;F&quot;,
  &quot;age&quot;: number(maximum= 24),
  * : any?
};
&lt;/pre&gt;

&lt;h5&gt;所感&lt;/h5&gt;

ここまで似てると、別言語と考えるのがバカバカしくなる。@[query]とかのアノテーションで十分ではないか。

+ @[open]アノテーションは、配列またはオブジェクトの直前に付き、その型がopenになることを明示する。
+ @[query]アノテーションは、宣言（定義）の直前に付き、すべての配列とオブジェクトをopenに解釈する。

&lt;pre class=&quot;code&quot;&gt;

type tokyoGirl_1 = @[open] {
  &quot;addr1&quot; : tokyo,
  &quot;gender&quot;:&quot;F&quot;,
  &quot;age&quot;: number(maximum= 24)
};

@[query]
type tokyoGirl_2 = {
  &quot;addr1&quot; : tokyo,
  &quot;gender&quot;:&quot;F&quot;,
  &quot;age&quot;: number(maximum= 24)
};
&lt;/pre&gt;

あと問題になるのは、ORとNOTの取り扱いだけ。


</body>
</day>
<day date="2010-11-25" title="">
<body>
*1290660497*[Caty][論理]クエリ言語と論理式

MongoQLは、「それはナイダロ」的な意味で面白い。

で、だいたい分かったのは、どうも「ドット記法（dot notation）ありき」らしいこと。ドット記法じゃ分かりにくいからフィールドパスとでも呼んでおこう。「フィールパス＋値の条件」が原子論理式、しいて言えば。

で、原子論理式の集合をAとして、AがNOTとORで閉じているとき、boolean upper-closedと呼ぶことにする。NOTとANDで閉じていれば、boolean lower-closedね。で、

- Aがboolean upper-closedなら、Aから作った極性付きAND結合の全体がboolean-closedになる。
- Aがboolean lower-closedなら、Aから作った極性付きOR結合の全体がboolean-closedになる。

別に難しくはない。こんなことは今まで考えたこともなかったけど。&lt;b&gt;[追記 date=&quot;翌日&quot;]&lt;/b&gt;この定義はアホ。upper-closed = lower-closed = closed だから意味ない。&lt;b&gt;[/追記 date=&quot;翌日&quot;]&lt;/b&gt;

Mongoでは、ORがまともに使えないので、原子論理式のレベルではupper-closed、つまりORで閉じていたほうが都合がいい。だが、この条件も満たしてない。しょうがないので、JavaScriptの論理式の力を借りて、無理にupper-closedにする。すると、なんとかかんとかboolean-closedになる。

&lt;b&gt;追記：&lt;/b&gt;

「極性付きAND結合」ってのは、a, b, cなどが原子論理式だとして、+{a, b, c}, -{a, b, c} のような形で、集合に寄せ集めるのがAND結合で、プラマイが肯定と否定。それぞれ、a∧b∧c と ￢(a∧b∧c) の意味。

&lt;b&gt;さらに追記：&lt;/b&gt;

アトム（原子論理式）と論理式のあいだに、節（クローズ）って概念を入れるとよさそう。

- 節  ::= アトム | (極性 '∃' 論理式)
- 論理式 ::= 極性 '{' 節*  '}'

∀を入れてないので不恰好だが、これで十分。

</body>
</day>
<day date="2010-12-03" title="">
<body>
*1291360399*[Caty]make-requestコマンド

現状のrequestを定義するなら、http://d.hatena.ne.jp/m-hiyama/20101201/1291165175 に書いたコマンド以外に make-request というコマンドが必要。make-requestは単にXJSONデータを吐き出すだけのコマンドだが、process-requestの入力データを作る。

&lt;pre class=&quot;code&quot;&gt;
/** 入力とパラメータからリクエストデータを作る */
command make-request 
{
 /** 入力のメディアタイプ */
 @[without(&quot;ext&quot;)]
 @[default(&quot;application/octet-stream&quot;)]
 &quot;content-type&quot; : mediaType?,

 /** 拡張子によりメディアタイプを指定 */
 @[without(&quot;content-type&quot;)]
 &quot;ext&quot; : string?,

 /** HTTPメソッド */
 @[default(&quot;GET&quot;)]
 &quot;method&quot; : (&quot;GET&quot;|&quot;POST&quot;|&quot;PUT&quot;|&quot;DELETE&quot;|&quot;HEAD&quot;)?,

 /** 動詞 */
 @[default(&quot;&quot;)]
 &quot;verb&quot; : string?,
}
[
 /** リクエストパス*/ path
] :: 
( /** ボディなし */
  null | 
  /** テキストまたはバイナリ */
  (string|binary) |
  /** フォーム */
  object |
  /** 明示的なフォーム指定 */
  @form object |
  /** JSON */
  @json any
) -&gt; WebRequest 
throws @ConfilictSettings ;
&lt;/pre&gt;

+ content-typeもextも指定されなかったら入力からメディアタイプを判断する。
+ メディアタイプが判断できなければ、octet-stream。
+ オプションと入力が矛盾するようなときは、@ConflictSettings例外。
+ 例外の型は型名じゃなくてタグを書いてもよいとする。


</body>
</day>
<day date="2010-12-07" title="">
<body>
*1291700989*[プログラム意味論]モノイドの自由積は重要だ、なのに、、、

モノイドの直積は普通に出てくるが、自由積はあまり話題にされない。圏論的には、自由積は余積（直和）となる。ストレージの並列操作を定式化しようとすると、モノイドの自由積が必要になる。

SがM加群かつN加群のとき、SにM*N加群構造が自然に定義できる。この加群構造が並列操作を議論する枠組みになる。ゼロ（吸収元）があるとき、自由積を潰して作った積（平坦積？）が排他性とかの記述に使えると思う。


</body>
</day>
<day date="2010-12-09" title="">
<body>
*1291857497*[雑記]アマゾンのおすすめ

おすすめ商品の1ページに出てきたのがコレ。ウーム、けっこう正確だなー。

&gt;&gt;

これらのおすすめ商品は、既にお持ちの商品などに基づいています。

+ Conceptual Mathematics: A First Introduction to Categories &lt;br /&gt;F. William Lawvere (2009/7/30) 
+ Purely Functional Data Structures &lt;br /&gt;Chris Okasaki (1999/7/1) 
+ Category Theory (Oxford Logic Guides) &lt;br /&gt;Steve Awodey (2010/8/13) 
+ 層・圏・トポス―現代的集合像を求めて &lt;br /&gt;竹内 外史 (1978/01) 
+ Basic Algebra I: Second Edition &lt;br /&gt;Nathan Jacobson (2009/6/22) 
+ Basic Algebra II: Second Edition &lt;br /&gt;Nathan Jacobson (2009/7/22) 
+ Types and Programming Languages &lt;br /&gt;Benjamin C. Pierce (2002/2/1) 
+ 最新コンパイラ構成技法 &lt;br /&gt;Andrew W. Appel (2009/10/30) 
+ Lambda-Calculus and Combinators: An Introduction &lt;br /&gt;J. Roger Hindley (2008/7/24) 
+ 関数プログラミングの楽しみ &lt;br /&gt;Ｊｅｒｅｍｙ　Ｇｉｂｂｏｎｓ　ａｎｄ　Ｏｅｇｅ　ｄｅ　Ｍｏｏｒ (2010/6/23) 
+ jQueryクックブック &lt;br /&gt;jQuery Community Experts (2010/8/18) 
+ First-Order Logic &lt;br /&gt;Raymond M. Smullyan (1995/1/30) 
+ Webを支える技術 -HTTP、URI、HTML、そしてREST (WEB+DB PRESS plus) &lt;br /&gt;山本 陽平 (2010/4/8) 
+ Set Theory and the Continuum Hypothesis (Dover Books on Mathematics) &lt;br /&gt;Paul J. Cohen (2008/12/9) 
+ ハイパフォーマンスWebサイト ―高速サイトを実現する14のルール &lt;br /&gt;Steve Souders (2008/4/11) 

&lt;&lt;


</body>
</day>
<day date="2010-12-10" title="">
<body>
*1291939003*[プログラム意味論][Caty]型の有向系とその極限

Λが有向系（有向順序集合）だとして、Λの元で添字付けられた（indexed）型のファミリーを考える。

- T = (α∈Λ|T&lt;sub&gt;α&lt;/sub&gt;)

Lim T = Lim&lt;sub&gt;α∈Λ&lt;/sub&gt; T&lt;sub&gt;α&lt;/sub&gt; は（存在するなら）一意的に定まる。

T = (α∈Λ|T&lt;sub&gt;α&lt;/sub&gt;) と S = (β∈Γ|S&lt;sub&gt;β&lt;/sub&gt;) が同じ極限を持つ条件とかが必要だな。


</body>
</day>
<day date="2010-12-11" title="">
<body>
*1292042762*[トレース／コンパクト閉圏][論理]コンパクト論理の計算

テンソル計算は線形コンパクト閉圏でやればいい。コンパクト閉圏の計算は、コンパクト論理と同じはず。コンパクト論理のシーケント計算はテンソル計算と同じはず。

だから、テンソル計算のためのシーケント計算があるはず。で、それを書き下したいのだがなー。

*1292053250*[トレース／コンパクト閉圏][論理][雑感]コンパクト論理の計算を試してみた所感

次のものは、なんか入り口は同じようだ。

+ 古典テンソル計算
+ 複線形代数
+ 結び目理論
+ ラムダ計算
+ シーケント計算
+ プログラムの制御構造

どれも結局、コンパクト閉圏、コンパクト論理、0次元または1次元のTQFTになる。

*1292053251*[トレース／コンパクト閉圏][論理]コンパクト論理の計算、推論規則と公理

圏論的な観点からいうと、シーケント計算て、圏のスジのような部分だけを議論している -- 圏をプレ順序集合に潰してしまうからな。シーケント計算では、圏の性質をキチンと捉えることはできない。が、単純化するもんだから計算も簡単になるメリットはある。

さてそれで、推論規則。CPは Composition and Product の略。

&lt;pre&gt;
   Γ → Δ,Π  Π,Φ → Ψ
 ---------------------------[CP1]
     Γ,Φ → Δ,Ψ


  Φ,Π → Ψ   Γ → Π,Δ
 ---------------------------[CP2]
    Φ,Γ → Ψ,Δ
&lt;/pre&gt;

このCP1、CP2は強力。絵で描けば、多圏の結合の一種。

次が公理。

+ [id] A → A
+ [lunit] I,A → A と A → I,A
+ [runit] A,I → A と A → A,I

これで、モノイド圏の計算ができる。idはトートロジー、lunit, runitは、Iに関する増減になっている。

対称性を入れるには：

- [symm] A,B → B,A

これは換（Exchange）

双対（随伴）は次のようになる。

+ [unit-neg] I → ￢I と  ￢I → I
+ [ev] A,￢A → I
+ [coev] I → ￢A,A

それと、含意の定義

+ ￢A,B → A⊃B  と A⊃B → ￢A,B
+ A,￢B → A⊂B  と A⊂B → A,￢B

コンパクト閉圏にモデルを取れば、次は意味的に言える。

+ 二重否定
+ 対偶
+ 演繹定理（カリー化、反カリー化）

</body>
</day>
<day date="2010-12-17" title="">
<body>
*1292557083*[Caty]とにかく名前

http://d.hatena.ne.jp/m-hiyama-memo/20101026/1288062272 も参照。

名前を使う場面を列挙する。

+ アプリケーション名
+ アプリケーション・グループ名
+ サイト名＝プロジェクト名
+ タグ名
+ アノテーション名
+ 例外名
+ 型名
+ コマンド名
+ フィルター名
+ オプション名
+ 仮引数名（まだサポートしてない）
+ 変数名
+ フィイルパス名
+ スキーマ属性名
+ アノテーション・パラメータ名

追加：

+ モジュール名
+ パッケージ名
+ プレイス名
+ ハッシュ記法の名前
+ 名前とみなすプロパティ名（フィールド名）

他にシェルのワードって概念があるし、、


</body>
</day>
<day date="2010-12-20" title="">
<body>
*1292805378*[Caty][プログラム意味論]Webストーンの構成要素

+ アクションノード ≒ コマンド
+ ステート（クラアント状態）ノード ≒ 受け取ったレスポンスデータ
+ 埋め込みトリガー ≒ ハイパーリンク（アンカーとフォーム）
+ 自由トリガー ≒ リクエスト発行するクラアント側コード
+ モジュール （ヤヌスのコンポネント／モジュール概念）
+ ポート （ポートベースコンポネントのポート）
+ 内部ワイヤー（モジュール内のデータ＆メッセージフロー）
+ 外部ワイヤー
+ トークン ： トークンで実行状態を記述する。トークンはワイヤーに乗ってノード間を移動する。それ自体が状態（パラメータ値）を持ってもよい。マルチクライアント／マルチスレッドなら複数のトークンが同時に存在する。

ペトリネットとだいぶ似てきた。トークン概念がけっこう重要。

完全なコンパクト閉圏とみなすより、トレース付き圏とコンパクト閉圏の中間のような定式化がいいのかもしれない。

</body>
</day>
<day date="2010-12-21" title="">
<body>
*1292888529*[Caty]名前の掟

名前は次の構文定義を持つ。

&lt;pre&gt;

名前 ::= 名前開始文字 名前文字*

&lt;/pre&gt;

集合として、名前開始文字 ⊆ 名前文字 でなくてはならない。

+ 名前は、数値と混同されてはならない。
+ 名前に、区切り文字を含んではならない。
+ 名前は、アスキー文字列へのエンコードを持つべきである。


</body>
</day>
<day date="2010-12-24" title="">
<body>
*1293177052*[モナド][圏一般論][からみ系]ベックの法則にまたまた遭遇！

可換モノイドによるモノイダルスタンピングモナドから作ったクライスリ圏に対称モノイド積を入れようと試みて、次の等式（つうか同型）が必要になった。

&lt;img src=&quot;http://www.chimaira.org/img2/beck-string-eq-1.gif&quot; /&gt;

少し書き換えてみると：

&lt;img src=&quot;http://www.chimaira.org/img2/beck-string-eq-2.gif&quot; /&gt;

さらに一部と取り出して、整理したら次のようになる。

&lt;img src=&quot;http://www.chimaira.org/img2/beck-string-eq-3.gif&quot; /&gt;

これってベックの分配法則だろう！ また出てきたよ。

有向グラフの書き換えだと思うと、「3価（trivalent）のノード1個と4価のノード1個」が「3価のノード1個と4価のノード2個」に変形する。3価ノードは、二項演算または余二項演算（余二項余演算）を表す。4価ノードはベックのスワッパーだ。3価ノードが二項演算または余二項演算を表す状況は物理とかでもやたらに出てくる。フュージョンとか呼ばれているのがそうだと思う（詳しくは知らんが）。

一般的には、(n + 1)価のノードが演算／余演算、4価のノードがスワッパーだとして、結合性、交換性（ブレイドもあり）、分配性（ベックの法則）の議論が絵算的にできるのだと思う。スワッパーの定式化には、バンドル・アンバンドル（アンバンドリング）構造を使うのがよさそう。

*1293182486*[メモ][雑記][圏一般論]Freyd

えっ、ピーター・フレイド（Peter J. Freyd ）って、娘さんに性的虐待で訴えられた？ どうも、娘さんのジェニファー・フレイドの（Jennifer J. Freyd）ほうが有名人みたいだ。

</body>
</day>
<day date="2010-12-25" title="">
<body>
*1293267671*[その他代数][圏一般論][からみ系][モノイド圏]フュージョン変換とフロベニウス代数

物理のフュージョン変換（よく知らん）てのは、次の絵のように描かれることがある。

&lt;img src=&quot;http://www.chimaira.org/img2/diag-fusion.gif&quot; /&gt;

この辺に向きを付けて変形してみる。

&lt;img src=&quot;http://www.chimaira.org/img2/diag-fusion-frob.gif&quot; /&gt;

最後の変換はフロベニウス代数の等式（公理）だ。線をチューブにして描くと次のようになる。

&lt;img src=&quot;http://www.chimaira.org/img2/diag-frob3d.gif&quot; /&gt;



</body>
</day>
<day date="2010-12-29" title="">
<body>
*1293583002*[Caty][モノイド圏]デカルト半環圏の基本的な自然同型

デカルト半環圏の構造と法則を与える同型射達。

&lt;pre class=&quot;code&quot;&gt;

/** 直積の結合律 */
command prod-assoc&amp;lt;A,B,C&gt;
:: &amp;#91;[A, B], C] -&gt; [A, [B, C]&amp;#93; 
{
 [nth 1 | nth 1, [nth 1 | nth 2, nth 2]&amp;#93;
};

/** 直和の結合律 */
command sum-assoc&amp;lt;A,B,C&gt;
:: (@1 (@1 A | @2 B) | @2 C) -&gt; (@1 A | @2 (@1 B | @2 C))
{
 when {
  1 =&gt; when { 1 =&gt; @1 pass, 2 =&gt; @2 @1 pass },
  2 =&gt; @2 @2 pass
 }
};

/** 直積の単位律 */
command prod-unit&amp;lt;A&gt;
:: [null, A] -&gt; A
{
 nth 2
};

/** 直和の単位律 */
command sum-unit&amp;lt;A&gt;
:: (never | A) -&gt; A
{
 pass
};

/* ゼロ法則 */
/* これはさすがに定義できない *
command zero&amp;lt;A&gt;
:: [never, A] -&gt; never
{
};
&amp;#42;/

/** 直和の対称スワップ */
command sum-swap&amp;lt;A,B&gt;
:: (@1 A | @2 B) -&gt; (@1 B | @2 A)
{
 when {1 =&gt; @2 pass, 2 =&gt; @1 pass}
};

/** 直和に対する直積の分配法則 */
command dist&amp;lt;A,B,C&gt;
:: [A, (@1 B | @2 C)] -&gt; (@1 [A, B] | @2 [A, C])
{
 [nth 1 &gt; x,  nth 2 &gt; y];
 %y | when {1 =&gt; @1 [%x, pass], 2 =&gt; @2 [%x, pass]}
};

&lt;/pre&gt;

*1293601053*[プログラム意味論][モノイド圏][からみ系]足し算なしの余線形代数

線形代数の普通の概念と、それの双対を「足し算なし」で考えたときの対応表。

|* 普通の概念   |*足し算なし双対における意味      |
|スカラー       |イミュータブル＆コピーアブルな値 |
|ベクトル       |状態  |
|スカラー乗法 |観測、測定 |
|スカラーどうしの乗法 |繰り返し測定の結果予測 |
|結合法則       |正確な予測可能性 |
|双代数法則     |因果関係と予測可能性 |

絵算で考えると分かる。

予測可能性の保証は一般的には難しい。直接観測（実観測、Query)だけで予測に十分な情報が集まらない。仮想観測まで入れると予測可能性が成立するが、仮想観測を実観測にするにはトランザクション（アンドゥ）が必要。

あ、それとクエリーとセレクターは区別したほうがいいよね。クエリーはイミュータブルなコピーを返す。セレクターは、部分構造へのポインタを返す感じ。


</body>
</day>
<day date="2011-01-03" title="">
<body>
*1294024318*[プログラム意味論][モノイド圏][その他代数][Mx]時刻サーバーとローカル時計

時刻サーバーから時刻を1回とって、それからの経過時間を刻むローカル時計はコモノイドになっている。連続する観測を予測しているから。

- 観測、測定 : S→S×V
- 作用、遷移 : M×S→S
- 予測 : M×V→V
- キューイング : M×M→M

時刻は神様が刺激（時間進行アクション）を与えている（by 無神論者）。

*1294024640*[メモ][セミナー][Mx]簡単だけど面白い例、意外な例

- 左右の自明モノイドと変数定数双対性（左右対称、時間非対称）
- モノイドと加群
- コモノイドと余加群
- 状態と観測とCommand-Query分離
- アミダ、ブレイド、まんじ、スワップ
- 多重加群と多重余加群（例：回転と平行移動の働く平面）
- 観測セット（座標系）と観測の可換性（例：アクセスカウンター）
- 交替律とインターリーブ定理（マルチタスクとメモリ分離）
- バイノイド法則、順次可換性、交替法則、

順次可換性（sequential commutativity；檜山の造語）とは、f |× g  = f ×| g 。順次可換性と交替性が同値（ボブ・クック）というのは厳密にはウソ。&lt;em&gt;バイノイド法則（対象を掛ける積に関する分配性）がないと成立しない。&lt;/em&gt;

- バイノイド法則 -- 何もしない操作なら、いくらでも足していい。Arrows知らんが、arr f;g = arr f &gt;&gt;&gt; arr g に対応するらしい。

計算（computation, or model of computations）では交替法則は容易に破れるが、&lt;em&gt;バイノイド法則が破れる状況は極めて考えにくい。&lt;/em&gt; って、これは実はとても大事なことかもしれないな。


</body>
</day>
<day date="2011-01-04" title="">
<body>
*1294106515*[プログラム意味論][モノイド圏][からみ系][Caty]トランザクション関手

f : A → B :+ E に対して try(f) : A → B+E :+ 0 というtryの定式をもとに、モノイダルスタンピングモナドのトランザクション（transaction）を関手として定式化できた。

射のプロファイルが問題で、f:A → M×B :+ E という射を次のプロファイルに変換する：

- tranz(f):A+&lt;b&gt;1&lt;/b&gt; → M×B+&lt;b&gt;1&lt;/b&gt; :+ &lt;b&gt;0&lt;/b&gt;

failed: E→M×&lt;b&gt;1&lt;/b&gt; という射は、!&lt;sub&gt;E&lt;/sub&gt;;&lt;e, 1&gt; （eはモノイドの単位、1は&lt;b&gt;1&lt;/b&gt;の唯一元）として、failedによる例外ハンドリングを取り付けることがtranz関手になる。tranz関手の域は、基礎圏を例外とモノイドで拡張した圏。tranz関手の余域は、例外が起きない射の部分圏になる。

関手なので、tranz(f;g) = tranz(f);tranz(g)。ベキ等関手 tranz(tranz(f)) になっている。

この方法で、色々な例外処理を定義できそう。そんな例が処理を組み込みにするのはなんか変だ。やっぱり関手定義機能が必要なのか。

*1294128189*[プログラム意味論][リンク]ホモトピーラムダ計算はどうしたのかなあ

ヴｫエヴォドスキーのホモトピーラムダ計算の資料が極端に少ないなー。そろそろまとまったモノを出して欲しい。

有向位相、有向ホモトピーに関しては：

- http://academic.csuohio.edu/bubenik_p/talks/directedTopology.pdf

ヴォエヴォドスキー自身は次の計画をぶちあげている。これ、なんだかスゴイ。

- http://www.math.ias.edu/~vladimir/Site3/Univalent_Foundations_files/univalent_foundations_project.pdf



</body>
</day>
<day date="2011-01-05" title="">
<body>
*1294211570*[プログラム意味論][リンク]型とホモトピー

ホモトピーを使った型理論と言えば、これがあるか。

- Type theory and homotopy (Submitted on 9 Oct 2010)
- Steve Awodey
- http://arxiv.org/abs/1010.1810


</body>
</day>
<day date="2011-01-07" title="">
<body>
*1294389937*[プログラム意味論][Caty][モノイド圏]プレモノイド圏の直交系

バイノイド構造上の順次積を使って：

- 定義： f⊥g ⇔ (f |× g = f ×| g)

&lt;i&gt;C&lt;/i&gt;をプレモノイド圏として、A⊆&lt;i&gt;C&lt;/i&gt;が直交系とは：

- ∀f,g∈A.( f=g ∨ f⊥g )

*1294389938*[映画]ハリー・ポッター

先日、子供らと『ハリー・ポッターと死の秘宝 PART1』を見たのだった。

固有名詞がやたら出てきて、予備知識がない僕ら（子供も）にはちょっと分かりにくい。

一番の感想は「みんな大人になってしまったなー」。ハリーは無精ひげが生えるし、ロンはけっこうな筋肉マンだし。ハーマイオニーはきつい感じだが美しい女性になりましたね。


</body>
</day>
<day date="2011-01-12" title="">
<body>
*1294804377*[圏一般論][用語法]景 = site

http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%82%BF%E3%83%B3%E3%83%87%E3%82%A3%E3%83%BC%E3%82%AF%E4%BD%8D%E7%9B%B8 に「景」（site）という訳語が出てくる。

*1294825249*[メモ][セミナー][Mx]記号の乱用の仕方

- 乱用 or 濫用 : http://en.wikipedia.org/wiki/Abuse_of_notation

+ f;g = fg
+ id&lt;sub&gt;A&lt;/sub&gt; = A = 1
+ M = (M, ・, 1) , N = (N, ・, 1)
+ 無名（ラムダ）変数、ブランク記号 (-*-), -&lt;sup&gt;2&lt;/sup&gt;
+ Haskell風セクション記法


</body>
</day>
<day date="2011-01-14" title="">
<body>
*1294986095*[圏一般論][用語法]普遍対象

Uが普遍対象（universal object）とは、任意の対象XからUへの射が（とにかくも）存在することだと定義される。この定義はまったく面白くない。それで、普通は圏CのEPペアの圏EP(C)を作って、UがEP(C)で普遍であることを考える。正確に言えばEP普遍対象。

</body>
</day>
<day date="2011-01-18" title="">
<body>




</body>
</day>
<day date="2011-01-20" title="">
<body>
*1295487963*[Caty][圏一般論][プログラム意味論][気付いた]ハイパーリンクの正体を見つけたぞ！

&lt;b&gt;ダーーーッ、やっとわかった。&lt;/b&gt;

&lt;b&gt;やっとわかった。やっとわかったよぉ。&lt;/b&gt;

ハイパーリンクの&lt;em&gt;まともな&lt;/em&gt;定式化を探し始めたのはいつだ？ 1年はたってないかな？過去エントリーは本編の「[http://d.hatena.ne.jp/m-hiyama/20100921/1285035619:title]」にまとめてある。「Webサービスを設計するための単純明快な方法」は2010年の7月だが、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20100326/1269595801&quot;&gt;「CSSセレクタによるデータ抽出」&lt;/a&gt;とかは2010年3月； 今の言葉で言えばDOMの&lt;em&gt;パート&lt;/em&gt;を扱おうとしていたのだよな。去年の3月くらいからとしても、十ヶ月以上。ハァー。

分かってしまえば、分からなかった自分がバカとしか言いようがない。

&lt;h5&gt;圏論的なモデル&lt;/h5&gt;

まず、ベースとなる圏&lt;i&gt;C&lt;/i&gt;から出発する。&lt;i&gt;C&lt;/i&gt;は型を対象として、&lt;em&gt;不純かも知れない&lt;/em&gt;計算処理（computational processing）を射とする圏。対象類の2つの部分集合 Q, S⊆|&lt;i&gt;C&lt;/i&gt;| を固定する。QはreQuest、SはreSponseのつもり。Q∩R は空だとする（分離している）。このような3つ組 (&lt;i&gt;C&lt;/i&gt;, Q, S) が素材となる。

記述の都合により、圏の対象も射も小文字で表す。q∈Q, s∈S に対する&lt;i&gt;C&lt;/i&gt;の射 f:q→s を&lt;strong&gt;アクション&lt;/strong&gt;と呼ぶ。アクションの全体は&lt;i&gt;C&lt;/i&gt;の部分グラフにはなるけれど&lt;del datetime=&quot;2011-02-03T18:16:56+09:00&quot;&gt;部分圏にはならない（これ重要）&lt;/del&gt; いちおう部分圏になる、とても使いにくいけど。同様に、q∈Q, s∈S に対する&lt;i&gt;C&lt;/i&gt;の射 g:s→q を&lt;strong&gt;オパクション&lt;/strong&gt;（op-action）と呼ぶ。アクションの全体、オパクションの全体を Act(&lt;i&gt;C&lt;/i&gt;, Q, S), Opa(&lt;i&gt;C&lt;/i&gt;, Q, S) と書く。

アクションはサーバー側処理、オパクションはクライアント側処理を表現する。特に、トリガーデータ＋リクエスト生成器はオパクションを定義する。

オパクション g:r→q とアクション f:q→r' の組 (g, f) を&lt;strong&gt;リンク&lt;/strong&gt;と呼ぶ。gとfは&lt;i&gt;C&lt;/i&gt;で結合可能だが、結合した射 g;f in &lt;i&gt;C&lt;/i&gt; がリンク&lt;em&gt;なのではない&lt;/em&gt;。記号的に構成した射の組をリンクと呼ぶ。便宜的に (g, f):r→r' と書く（くどいが、こう書いても射を意味しない）。リンクの全体を Link(&lt;i&gt;C&lt;/i&gt;, Q, S) と書く。これは&lt;i&gt;C&lt;/i&gt;の部分グラフでさえなくて、頂点集合をSとして作ったグラフになる。下部構造に (&lt;i&gt;C&lt;/i&gt;, Q, S) を持つが、Linkが&lt;i&gt;C&lt;/i&gt;内にあるのではない。

&lt;h5&gt;状態遷移グラフ&lt;/h5&gt;

次のような状況証拠はあった。

+ レスポンスはクライアント側状態のように思える。
+ ハイパーリンクが状態遷移を記述しているように思える。
+ ハイパーオブジェクト、トリガー、リクエスター、アクションなどの概念はそれなりに有意義。

これらの現象の背景をはっきりさせたい。

Gを有向グラフとして、φ:G→Link(&lt;i&gt;C&lt;/i&gt;, Q, S) をグラフ写像とする。この表現は“はしょっている”から、もうちょい正確に言えば：

+ vがグラフGの頂点のとき、φ(v)∈S 。
+ eがグラフGの辺のとき、φ(e)∈Link(&lt;i&gt;C&lt;/i&gt;, Q, S) 。
+ 辺の接続関係などは自然に定義する。

この定式化で、ハイパーリンクによるナビゲーションの挙動は説明できる。より詳細な分析をするには、次のような圏を使う。

+ 今導入したグラフ写像 φ:G→Link(&lt;i&gt;C&lt;/i&gt;, Q, S) を対象とする。
+ φ, ψ:G→Link(&lt;i&gt;C&lt;/i&gt;, Q, S) の射は、自然変換のグラフ版で定義する。グラフに自然性の概念はないが、&lt;i&gt;C&lt;/i&gt;に落ちたときの自然性は要求すべきかもしれない（わからん）。
+ グラフGをインデックスとするindexed圏を作る。
+ グロタンディーク平坦化をする。

&lt;h5&gt;拡張状態遷移グラフ&lt;/h5&gt;

上の構成では、Link(&lt;i&gt;C&lt;/i&gt;, Q, S) を有向グラフと見るとき、頂点集合はSとしてきた。これでは不十分で、Qも頂点集合に加えた有向グラフが必要になる。さらに、φ:G→Link(&lt;i&gt;C&lt;/i&gt;, Q, S) の具体的な構成法や、グラフの接着の方法。多圏とGoI構成などの問題がある。

これらを定式化すれば、拡張された状態遷移も記述できるだろう。先は長いが、とりあえず出発点はわかった。


</body>
</day>
<day date="2011-02-03" title="">
<body>
*1296724469*[Caty][圏一般論][プログラム意味論]ハイパーリンクに関して補足

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110120/1295487963&quot;&gt;「ハイパーリンクの正体を見つけたぞ！」&lt;/a&gt;は、とりあえずの覚え書きとして書いたが、けっこう瑕疵がある。補足しておく。
&gt;&gt;
アクションの全体はCの部分グラフにはなるけれど部分圏にはならない（これ重要）。
&lt;&lt;

&lt;em style=&quot;font-size:large&quot;&gt;ウソ&lt;/em&gt;。アクション全体は部分圏になる。が、いいかげんツマラナイ、使いにくい部分圏。このままではちょっと使えない。Act(&lt;i&gt;C&lt;/i&gt;, Q, S)∪Opa(&lt;i&gt;C&lt;/i&gt;, Q, S) はこのままでは圏にならない。Act(&lt;i&gt;C&lt;/i&gt;, Q, S)∪Opa(&lt;i&gt;C&lt;/i&gt;, Q, S) を含む最小の圏を作ると、これは使える。ほぼWebのモデルと言っていいだろう。

&gt;&gt;
オパクション g:r→q とアクション f:q→r' の組 (g, f) をリンクと呼ぶ。
&lt;&lt;

これでいいとは思うが、オパクションがトリガーのときが典型的。別な言い方をすれば、実用的なオパクションはトリガー。

リンクはベースの圏&lt;i&gt;C&lt;/i&gt;の射ではないが、リンクのパスを射とする圏（自由圏）はすぐに作れる。ベースの圏とリンクパスの圏は混同されがちだ（混同してもいい状況も多い）。

Link(&lt;i&gt;C&lt;/i&gt;, Q, S) を辺、Sを頂点の集合とするグラフは LG(&lt;i&gt;C&lt;/i&gt;, Q, S)（Link Graphの意味）とでも表記するか。任意のグラフGから LG(&lt;i&gt;C&lt;/i&gt;, Q, S) へのグラフ写像が考察すべき対象。

*1296724778*[Caty][圏一般論][プログラム意味論]ホム関手に似たナニカ

&lt;i&gt;C&lt;/i&gt;がデカルト半環圏（むしろ、このケースでは双デカルト圏というべき）のとき、&lt;i&gt;C&lt;/i&gt;&lt;sup&gt;op&lt;/sup&gt;×&lt;i&gt;C&lt;/i&gt;→&lt;b&gt;Cat&lt;/b&gt; という双関手が作れる。これは双インデックス付き圏となる。どことなくホム関手とも似ている。


</body>
</day>
<day date="2011-02-05" title="">
<body>
*1296873156*[メモ]Emacsのtool-bar-modeとmenu-bar-mode

(tool-bar-mode 1) と (tool-bar-mode 0) で表示と非表示を切り替えられるが、非表示設定は-1でもよいようだ、(tool-bar-mode -1)。

(tool-bar-mode nil) がなかなか混乱しがちで、トグルする。(menu-bar-mode nil) も同じ。

*1296873345*[メモ]MeadowのUTF-8文字化けを緩和する

以下の設定は http://ai11.net/2007/11/20/ より、さらにオリジナルは http://web.archive.org/web/20060620002245/nijino.homelinux.net/emacs/utf-cjk.html らしいが、現在はアクセスできない。

&lt;pre class=&quot;code&quot;&gt;

;; U+0080 - U+2E7F の文字を CJKにデコード 
;; 
(utf-translate-cjk-set-unicode-range
   '((#x00a2 . #x00a3) ; ￠, ￡
     (#x00a7 . #x00a8) ; §, ¨
     (#x00ac . #x00ac) ; ￢
     (#x00b0 . #x00b1) ; °, ±
     (#x00b4 . #x00b4) ; ´
     (#x00b6 . #x00b6) ; ¶
     (#x00d7 . #x00d7) ; ×
     (#X00f7 . #x00f7) ; ÷
     (#x0370 . #x03ff) ; Greek and Coptic
     (#x0400 . #x04FF) ; Cyrillic
     (#x2000 . #x206F) ; General Punctuation
     (#x2100 . #x214F) ; Letterlike Symbols
     (#x2190 . #x21FF) ; Arrows
     (#x2200 . #x22FF) ; Mathematical Operators
     (#x2300 . #x23FF) ; Miscellaneous Technical
     (#x2500 . #x257F) ; Box Drawing
     (#x25A0 . #x25FF) ; Geometric Shapes
     (#x2600 . #x26FF) ; Miscellaneous Symbols
     (#x2e80 . #xd7a3)
     (#xff00 . #xffef)
))

&lt;/pre&gt;

</body>
</day>
<day date="2011-02-08" title="">
<body>
*1297156538*[リンク][高次圏論]ルーリエってばまったく

Jacob Lurie :

- http://www.math.harvard.edu/~lurie/papers/highertopoi.pdf 943ページ
- http://www.math.harvard.edu/~lurie/papers/higheralgebra.pdf 948ページ

コイツ、やっぱり人間じゃねーな。



</body>
</day>
<day date="2011-02-23" title="">
<body>
*1298431368*[用語法][プログラム意味論]状態のようなもの

- ストア
- 値割り当て
- 束縛
- スコープ（オブジェクト、チェーン、スタック）
- 環境
- 状態
- 文脈
- 状況
- コンフィギュレーション

*1298435373*[メモ][プログラム意味論]操作的意味論

ランディンのSECDが1964, 1965、VDLも1969とな。ふっるーーい。

</body>
</day>
<day date="2011-02-25" title="">
<body>
*1298595330*[メモ][プログラム意味論]プロセッサ例外

ハードウェアに近い例外処理を知りたいときは「プロセッサ例外」と検索すると良いようだ。

*1298618626*[メモ][Caty]入出力

ストリームポートからの入出力のことも書かないとな。

ベースはファシリティ入出力だけど。
</body>
</day>
<day date="2011-03-29" title="">
<body>
*1301364270*[メモ]Javaの起動時のデバッグメッセージ

環境変数_JAVA_LAUNCHER_DEBUGを定義すると起動時にデバッグメッセージが表示される。
知らなかった。これは便利。

*1301364271*[メモ]tar のいろいろ

- -O, --to-stdout  -- ファイルを標準出力に書き出す

tar cO は、tar cf - と同じ。xargsとの組み合わせで ls *.js | xargs tar cO とか使えるな。

- -C, --directory DIR  --  DIRにcdしてから動作を行なう

tar cf - . | (cd ../other; tar xvf -) の代わりに、tar cO . | tar -C ../other -xvf - 

- -u, --update  -- アーカイブ内の同名のファイルより新しいものだけを追加する
- --keep-old-files  -- ファイルが既存の場合は、アーカイブから抽出したファイルで上書きしない
- --keep-newer-files -- ファイルがより新しい場合は、アーカイブから抽出したファイルで上書きしない

$ tar cO . | tar -C ../test2 -xvf - --keep-newer-files とか。

あと次も使える。

- --exclude-vcs
- --exclude-tag-*
- --files-from

*1301364577*[メモ][goog]Closure Library関係

構成方式と必要なファイル

| -       |* archive |* base  |* deps |* lib |
|* raw    |          | ○     | ○    | ○   |
|* packed |○        |        | ○?   |      |
|* compiled|○       |        |       |      |
|* optimized|○      |        |       |      |

*1301386091*[メモ][goog]Closure Libraryを使うときのネーミング

フィーチャー名前空間に関して：

- パッケージ名は小文字のみ
- クラス名は大文字始まり
- 関数名は小文字始まりで、キャメルケースかアンダースコア区切り
- 必ずパッケージからはじめる

がいいと思う。

- chimaira.Foo -- Fooはクラス
- chimaira.bar -- barはおそらくサブパッケージ（関数の可能性あり）
- chimaira.do_that -- do_thatは関数名
- chimaira.registerpublic -- パッケージ

曖昧性は避けられないが、できるだけ法則的に。

ファイル名は、クラス名、クラス名の最初の語、パッケージ名のどれかに一致させるべき。ただし、base.js だけは特殊扱いでいいかも。


</body>
</day>
<day date="2011-03-31" title="">
<body>
*1301535338*[goog]Closure Libraryのメモはgoogタグ

トップレベルの名前空間がgoogだからな。

JSONのカラーリング表示ができる。&lt;code&gt;new goog.format.JsonPrettyPrinter(new goog.format.JsonPrettyPrinter.HtmlDelimiters());&lt;/code&gt;

- goog.format.JsonPrettyPrinter http://closure-library.googlecode.com/svn/trunk/closure/goog/demos/jsonprettyprinter.html

CSSプロパティは：

- .goog-jsonprettyprinter-propertyname
- .goog-jsonprettyprinter-propertyvalue-string
- .goog-jsonprettyprinter-propertyvalue-number
- .goog-jsonprettyprinter-propertyvalue-boolean
- .goog-jsonprettyprinter-propertyvalue-null

となるから、お好みの色やフォントで。

&lt;hr&gt;
無色のコンテナ（goog.ui.Container）とコントロール（goog.ui.Control）でもけっこうなことができる。

- goog.ui.Container http://closure-library.googlecode.com/svn/trunk/closure/goog/demos/container.html

コントロール（goog.ui.Control）からのACTIONイベント（goog.ui.Component.EventTypeにあるはず）を捕まえればいい。
イベントにコントロールのID（HTMLのIDとは無関係）が入っているので、それをコマンド名（トリガー文字列）と解釈して、対応するハンドラー関数を実行する。とか。
&lt;hr&gt;

簡単なダイアログなら：

- goog.ui.Prompt http://closure-library.googlecode.com/svn/trunk/closure/goog/demos/prompt.html

&lt;code&gt;var prompt = new goog.ui.Prompt('Information Required'/*title*/, 'What is your favorite color?'/*message*/, promptHandler/*callback*/);&lt;/code&gt;

もう少しダイアログらしいのは
- goog.ui.Dialog http://closure-library.googlecode.com/svn/trunk/closure/goog/demos/dialog.html

&gt;|html|
&lt;button onclick=&quot;showDialog(dialog2);&quot;&gt;
    Open Dialog (w/ Iframe mask)
&lt;/button&gt;
||&lt;

&gt;|javascript|
var dialog2 = new goog.ui.Dialog(null, true);
    dialog2.setContent('Some windowed elements leak through standard divs so ' +
        'we add an iframe to mask the nasties.');
    dialog2.setTitle('I have an Iframe mask :)');

    dialog2.setButtonSet(goog.ui.Dialog.ButtonSet.YES_NO_CANCEL);

    goog.events.listen(dialog2, goog.ui.Dialog.EventType.SELECT, 
                       function(e) {
                        alert('You chose: ' + e.key);
                      });


var currDialog;
function showDialog(dialog) {
     currDialog = dialog;
     dialog.setVisible(true);
}

||&lt;

*1301535587*[goog]ラベルインプット 簡単だ

最も簡単なUIコンポネントだろう。わかりやすい。

&gt;|html|

&lt;script&gt; 
    goog.require('goog.ui.LabelInput');
    goog.require('goog.dom');
&lt;/script&gt;


&lt;form&gt; 
    &lt;input id=i name=i label='Search, add, or invite 1'&gt; 
    &lt;div id=d&gt;&lt;/div&gt; 
    &lt;script&gt; 
      var $ = goog.dom.getElement;
 
      var li1 = new goog.ui.LabelInput;
      li1.decorate($('i'));
 
      var li2 = new goog.ui.LabelInput('Search, add, or invite 2');
      var el = li2.render($('d'));
      li2.getElement().name = 'dynamic';
    &lt;/script&gt; 
    &lt;button type=&quot;button&quot;&gt;Faux Submit&lt;/button&gt; 
&lt;/form&gt; 

||&lt;

input要素のlabel属性はHTMLで定義されてない。勝手に付けている。スクリプトが走るとこれは消費されて消えて、おそらくtype属性が付くのだろう。

*1301538253*[goog]DOMノードとコンポネントオブジェクト

コンポネントオブジェクトのgetElement()で対応するDOMノード（要素オブジェクト）が得られる。DOMノードからコンポネントオブジェクトへのバックポインタは、最後がアンダースコアのプロパティでアクセスできることがあるが、保証されるわけじゃない。

バックポインタプロパティもちゃんと仕様化されればいいのに。ゆるい原則として、enterDocumentでバックポインタを設定して、exitDocumentでバックポインタをnullに設定する。これを利用すると、DOMノードがコンポネントとして有効かどうかを判定できる。

また、イベントハンドラーの設定と解除もenter/exit Documentのタイミングで行われる。

*1301538559*[goog]Closureのイベントハンドラー：状況わろし

goog.events.EventHandler(component) がまたなんつーか、「イベントハンドラー」という言葉の多義性の新しい例で、イベント処理用のバインディングを行うlisten関数を所有するオブジェクト、ということになる。

いわゆるイベントハンドラー関数とは全然違う。いわゆるイベントハンドラー関数は、listen関数の第三引数に指定される。んで、listen関数は、eh.listen(target, eventType, handler) として使う。ehがClosureのEventHandlerオブジェクトなのだ。んじゃ、listenの第三引数は何と呼ぶか？ イベントリスナーだな。

つまり、Closureにおけるイベントハンドラーとイベントリスナーはまったくの別物。もちろん、DOMの用語ともXMLEventsの用語とも整合しない。XMLEventsのリスナーに近いのがlisten関数。イベントハンドラーのlistenは goog.events.litenの使いやすいラッパーになっている。

- 早わかり イベントモデル → http://d.hatena.ne.jp/m-hiyama/20071206/1196905196

Closureイベントハンドラーは、イベント処理のバインディングを管理する責任主体みいたもので、イベントターゲット（発生源）ともリスナーの所有者とも概念的には別。

さらにややこしいのは、EventHandlerオブジェクトに handler_ というプロパティがあって、これがハンドラーを指している。ええええー、ハンドラーからハンドラーを指すってナニソレ？

EventHandlerオブジェクトは、別なとあるオブジェクトに所有されることがあって、その所有者をhandler_が指している。この所有者もハンドラーと呼ぶのだ、、、、ムムムムム。handler_は、リスナー関数群の所有者であることが多い。

理解を促すスニペット：

&gt;|javascript|
/**
 * Stops listening to the events.
 * @private
 */
goog.ui.LabelInput.prototype.detachEvents_ = function() {
  if (this.eventHandler_) {
    this.eventHandler_.dispose();
    this.eventHandler_ = null;
  }
};
||&lt;

さらに悪いニュース：リスナー関数のネーミングは handleXxx （Xxxはイベント名）。ウギャ！

</body>
</day>
<day date="2011-04-01" title="">
<body>
*1301652822*[goog]vertical container example を見てみる

- http://closure-library.googlecode.com/svn/trunk/closure/goog/demos/container.html

&gt;|html|

&lt;td width=&quot;50%&quot; id=&quot;vc&quot;&gt; 
Vertical container example:
&lt;/td&gt; 

||&lt;

まず、EVNETSに、すべてのコンポネントイベントタイプの配列を入れておく。

&gt;|javascript|

var EVENTS = goog.object.getValues(goog.ui.Component.EventType);

||&lt;

Component.EventTypeは@enumと指定されている。ClosureJSでは、列挙型もオブジェクト。

&gt;|javascript|
/**
 * Common events fired by components so that event propagation is useful.  Not
 * all components are expected to dispatch or listen for all event types.
 * Events dispatched before a state transition should be cancelable to prevent
 * the corresponding state change.
 * @enum {string}
 */
goog.ui.Component.EventType = {
  /** Dispatched before the component becomes visible. */
  BEFORE_SHOW: 'beforeshow',

  /**
   * Dispatched after the component becomes visible.
   * NOTE(user): For goog.ui.Container, this actually fires before containers
   * are shown.  Use goog.ui.Container.EventType.AFTER_SHOW if you want an event
   * that fires after a goog.ui.Container is shown.
   */
  SHOW: 'show',

  /** Dispatched before the component becomes hidden. */
  HIDE: 'hide',

  /** Dispatched before the component becomes disabled. */
  DISABLE: 'disable',

  /** Dispatched before the component becomes enabled. */
  ENABLE: 'enable',

  /** Dispatched before the component becomes highlighted. */
  HIGHLIGHT: 'highlight',

  /** Dispatched before the component becomes un-highlighted. */
  UNHIGHLIGHT: 'unhighlight',

  /** Dispatched before the component becomes activated. */
  ACTIVATE: 'activate',

  /** Dispatched before the component becomes deactivated. */
  DEACTIVATE: 'deactivate',

  /** Dispatched before the component becomes selected. */
  SELECT: 'select',

  /** Dispatched before the component becomes un-selected. */
  UNSELECT: 'unselect',

  /** Dispatched before a component becomes checked. */
  CHECK: 'check',

  /** Dispatched before a component becomes un-checked. */
  UNCHECK: 'uncheck',

  /** Dispatched before a component becomes focused. */
  FOCUS: 'focus',

  /** Dispatched before a component becomes blurred. */
  BLUR: 'blur',

  /** Dispatched before a component is opened (expanded). */
  OPEN: 'open',

  /** Dispatched before a component is closed (collapsed). */
  CLOSE: 'close',

  /** Dispatched after a component is moused over. */
  ENTER: 'enter',

  /** Dispatched after a component is moused out of. */
  LEAVE: 'leave',

  /** Dispatched after the user activates the component. */
  ACTION: 'action',

  /** Dispatched after the external-facing state of a component is changed. */
  CHANGE: 'change'
};
||&lt;

次：

&gt;|javascript|
// Programmatically create a vertical container.
    var vc = new goog.ui.Container();
    vc.setId('Vertical Container');
||&lt;

vcというコンテナを作る。第一引数が方向（goog.ui.Container.Orientation）だが、Container orientation; defaults to VERTICAL. setIdはコンポネントIDというヤツだが、HTMLのIDとはまったく別。

次：
&gt;|javascript|
    goog.array.forEach(
        ['Athos', 'Porthos', 'Aramis', 'd\'Artagnan'],
        function(item) {
          var c = new goog.ui.Control(item);
          c.setId(item);
          // For demo purposes, have controls dispatch transition events.
          c.setDispatchTransitionEvents(goog.ui.Component.State.ALL, true);
          vc.addChild(c, true);
        });
||&lt;

コントロールを追加していく。setDispatchTransitionEvents()は、Enables or disables transition events for the given state(s). goog.ui.Component.Stateも列挙型で：

&gt;|javascript|
/**
 * Common component states.  Components may have distinct appearance depending
 * on what state(s) apply to them.  Not all components are expected to support
 * all states.
 * @enum {number}
 */
goog.ui.Component.State = {
  /**
   * Union of all supported component states.
   */
  ALL: 0xFF,

  /**
   * Component is disabled.
   * @see goog.ui.Component.EventType.DISABLE
   * @see goog.ui.Component.EventType.ENABLE
   */
  DISABLED: 0x01,

  /**
   * Component is highlighted.
   * @see goog.ui.Component.EventType.HIGHLIGHT
   * @see goog.ui.Component.EventType.UNHIGHLIGHT
   */
  HOVER: 0x02,

  /**
   * Component is active (or &quot;pressed&quot;).
   * @see goog.ui.Component.EventType.ACTIVATE
   * @see goog.ui.Component.EventType.DEACTIVATE
   */
  ACTIVE: 0x04,

  /**
   * Component is selected.
   * @see goog.ui.Component.EventType.SELECT
   * @see goog.ui.Component.EventType.UNSELECT
   */
  SELECTED: 0x08,

  /**
   * Component is checked.
   * @see goog.ui.Component.EventType.CHECK
   * @see goog.ui.Component.EventType.UNCHECK
   */
  CHECKED: 0x10,

  /**
   * Component has focus.
   * @see goog.ui.Component.EventType.FOCUS
   * @see goog.ui.Component.EventType.BLUR
   */
  FOCUSED: 0x20,

  /**
   * Component is opened (expanded).  Applies to tree nodes, menu buttons,
   * submenus, zippys (zippies?), etc.
   * @see goog.ui.Component.EventType.OPEN
   * @see goog.ui.Component.EventType.CLOSE
   */
  OPENED: 0x40
};

||&lt;

次：

&gt;|javascript|
    vc.addChildAt(new goog.ui.Separator(), 3, true);
    vc.getChild('Porthos').setEnabled(false);
||&lt;

これはいいとして、次：

&gt;|javascript|
    vc.render(goog.dom.getElement('vc'));
    goog.events.listen(vc, EVENTS, logEvent);

||&lt;

ここで、renderターゲットを'vc'としてレンダリング。イベントにリッスン関係を確立。あとは、イベントリスナー関数（ハンドラ関数と呼ぶこともある）logEventを書けばいい。

</body>
</day>
<day date="2011-04-02" title="">
<body>
*1301716448*[goog]スーパークラス情報

おそらくインターナル仕様だろうが、クラスコンストラクタ関数オブジェクトの superClass_ プロパティに、スーパークラスコンストラクタへの参照が入っている。

*1301716525*[メモ]CreateProcess

http://msdn.microsoft.com/ja-jp/library/cc429066.aspx より：
&lt;pre&gt;
BOOL CreateProcess(
  LPCTSTR lpApplicationName,                 // 実行可能モジュールの名前
  LPTSTR lpCommandLine,                      // コマンドラインの文字列
  LPSECURITY_ATTRIBUTES lpProcessAttributes, // セキュリティ記述子
  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // セキュリティ記述子
  BOOL bInheritHandles,                      // ハンドルの継承オプション
  DWORD dwCreationFlags,                     // 作成のフラグ
  LPVOID lpEnvironment,                      // 新しい環境ブロック
  LPCTSTR lpCurrentDirectory,                // カレントディレクトリの名前
  LPSTARTUPINFO lpStartupInfo,               // スタートアップ情報
  LPPROCESS_INFORMATION lpProcessInformation // プロセス情報
);
&lt;/pre&gt;



</body>
</day>
<day date="2011-04-05" title="">
<body>
*1301994968*[goog]goog.fx.Dragger

ドラッグ機能を追加する goog.fx.Dragger(target, opt_handle, opt_limits) では、ドラッガーのターゲット（ドラック移動が可能となるコンテント要素）とドラッグハンドルが包含関係のない要素でもいい。コンテナでまとめる必要がない。どうやっているかはよく知らないが。

*1301995329*[goog]xxxInternal

よく xxxInternal という名のメソッドが出てくるのだが、いまいち使用法がわからない。





</body>
</day>
<day date="2011-04-09" title="">
<body>
*1302341377*[映画]漫才ギャング

という映画を見た。一番の感想は、石原さとみが可愛い。「わたしが演じた由美子は、芸人さんの理想の彼女なんです」と、なるほど、そうだな。

それほど笑うところは多くないし、ストーリーもいまいちスッキリしない。


</body>
</day>
<day date="2011-04-12" title="">
<body>
*1302599595*[映画]ナルニア国物語／第3章：アスラン王と魔法の島

次男と一緒に、品川プリンスシネマで見た。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100323/1269329147&quot;&gt;次男は3Dにトラウマ&lt;/a&gt;なので、2D吹替版。

面白かった。十分に楽しめましたね。僕はこのシリーズ初めてなんだけど、次男は1章、2章知っていたんで色々と説明を受けた。主人公の4人兄弟は：

+ ピーター
+ スーザン
+ エド（エドマンド）
+ ルーシー

というよくありそうな名前。今回は、エドとルーシーだけで、上の二人は出てこない。大きくなりすぎたのかも。第2章で出てきたらしいカスピアン王子がカスピアン王となっていて、エドマンドとルーシーと共に主人公。

一番感心したのは敵役。ユースチスという憎たらしい男の子（エド、ルーシーの従兄弟）。最初は徹底的に憎まれ役なのだが、結局はヒーローになる、という作り。


</body>
</day>
<day date="2011-04-18" title="">
<body>
*1303083488*[映画]SP 革命編

長男と見に行ったが、、、、

僕はドラマ「SP 警視庁警備部警護課第四係」も前作「SP 野望編」もまったく知らない。そのせいでワケワカンナイということかも知れないが、それにしても一見＜イチゲン＞の客に不親切過ぎる。

いきなり緊迫した感じの映像から入るのだが、文脈・前後関係がわかってない僕には何が起きてるのかサッパリ？？ やたらにイッパイの登場人物、誰がなんなのか判別が付かない。背景も相互の関係も（僕には）不明のまま、ストーリーは進む（って、テンポはけっこう遅いけど）。最後はテロリストは射殺され、黒幕らしき官僚達もたぶん爆死。と、闇雲に死なせてオワリの安易な結末。

ようするに、連続ドラマの1回分だけ見たらダメよ、ってことか。それにしてもツマラナイ話だったなー。荒唐無稽なのは別にいいけど、だったらダイ・ハードのように岡田准一君を無敵のヒーローにしちゃうとか。リベリオンのようにガンカタ入れてみるとか（http://www.youtube.com/watch?v=e8gw_GMIuU8）。どうせ物語の整合性なんて破綻しているのに、変にリアルぶってもしょうがないでしょ。

それと、岡田君演じる井上は、ずっと体調悪いみたいだけどなんの持病なの？ それもわからんかった。予備知識無しでは、非常にイライラする映画でしたね。謎を残して終わる、というよりは単にオハナシの収集がつかないで放り投げた感じ。


</body>
</day>
<day date="2011-04-21" title="">
<body>
*1303357495*[Caty]各レベルの構成子、演算記号

Array, VarArrayは可変引数、Object, VarObject, Unionは名前付き引数になる。

|* レベル0   |* レベル1  |* レベル2 |
| Array      | Array     | Array    |
| Object     | Object    | Object   |
| Tagged     | Tagged    | Tagged   |
| -          | Opt       | Opt      |
| -          | VarArray  | VarArray |
| -          | VarObject | VarObject|
| -          | Union     | Union    |
| -          | Intersect | Intersect|
| -          | XMerge    | XMerge   |
| -          | -         | or  合并     |
| -          | -         | and  共通部分    |
| -          | -         | without 差集合 |

レベル1では他に制限（スキーマ属性、一種の内包記法）とバッグ型がある。バッグ型は扱いがかなり異なる。

リフト（レベルを上げて埋め込む）を行う関数は以下のとおり。

+ sing : D&lt;sub&gt;0&lt;/sub&gt; → D&lt;sub&gt;1&lt;/sub&gt; シングルトン型
+ just : D&lt;sub&gt;1&lt;/sub&gt; → D&lt;sub&gt;2&lt;/sub&gt; シングルトンカインド
+ lower : D&lt;sub&gt;1&lt;/sub&gt; → D&lt;sub&gt;2&lt;/sub&gt; 下方集合
+ upper : D&lt;sub&gt;1&lt;/sub&gt; → D&lt;sub&gt;2&lt;/sub&gt; 上方集合

記号的な表現は：

|* 名前     |* 演算記号 |
| Array     | [-, -, ...] |
| Object    | {&quot;a&quot;:-, &quot;b&quot;:-, ...} |
| Tagged    | @ - - |
| Opt       | - ? |
| VarArray  | [-, -, ..., -*] |
| VarObject | {&quot;a&quot;:-, &quot;b&quot;:-, ..., *:-} |
| Union     | (@a - &amp;#124; @b - &amp;#124; ...) |
| Intersect | - &amp;amp; - |
| XMerge    | - ++ - |

制限は -(-), バッグ型は {[ ... ]}。あっ、&lt;em&gt;VarUnionを実装しないとな。&lt;/em&gt;

例：

- Array(integer, boolean?) ≡ [integer, boolean?]
- Object(&quot;a&quot;:boolean, &quot;b&quot;:number?) ≡ {&quot;a&quot;:boolean, &quot;b&quot;:number?}
- Tagged(&quot;foo&quot;, integer) ≡ @foo integer
- Opt(null) ≡ null?
- VarArray(integer, boolean?, string) ≡ [integer, boolean?, string*]
- VarObject(&quot;a&quot;:boolean, &quot;b&quot;:number?, *:string?) ≡ {&quot;a&quot;:boolean, &quot;b&quot;:number?, *:string?}
- Union(&quot;a&quot;:boolean, &quot;b&quot;:number) ≡ (@a boolena | @b number)
- Intersect(integer, number) ≡ integer &amp;amp; number
- XMerge(foo, bar) ≡ foo ++ bar

*1303358595*[Caty][用語法]types-as-setsの型とカインドに関係して

次のような言葉は同義語だが、ニュアンスで使い分ける。

+ 集合 （外延）
+ 条件 （内包）
+ 述語 （1変数関係）
+ 制約
+ 制限
+ バリデータ

*1303361406*[メモ][リンク]フーン

- http://jp.layer8.sh/reference/entry/show/id/1049

内容もへーナルホドだけど、.sh ってドメイン名があるんだ。bashのリファレンスとかここしかない感じだが。


</body>
</day>
<day date="2011-04-23" title="">
<body>
*1303547574*[メモ][人物] de Bruijn

- http://ja.forvo.com/search/bruijn/

デュブランだな。あースッキリした。

サッカーの監督は Blanc でブラン。（ブラン監督辞めるみたいだけど、、、）
</body>
</day>
<day date="2011-05-06" title="">
<body>
*1304648109*[メモ][人物]Kozen

コォゼンとコゥゼンが混じっている。

- コォゼン一覧 http://d.hatena.ne.jp/m-hiyama-memo/archive?word=%A5%B3%A5%A9%A5%BC%A5%F3
- コォゼン内容 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%B3%A5%A9%A5%BC%A5%F3
- コゥゼン一覧 http://d.hatena.ne.jp/m-hiyama-memo/archive?word=%A5%B3%A5%A5%A5%BC%A5%F3
- コゥゼン内容 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%B3%A5%A5%A5%BC%A5%F3

コ&lt;b&gt;ゥ&lt;/b&gt;ゼンのほうが多い。

*1304650321*[Caty][論理][プログラム意味論][型検査]型に関するアルゴリズム

実行すべきプログラムを式と呼ぶ。Catyでは、式＝スクリプトコード。型を表す構文的対象を型項とする。型項を項として、包含関係 t⊆s を原子論理式とする論理系を考える。これはデクスター・コゥゼンのset constraintsと同じ。ただし、型変数が含まれて、全称記号も使う。

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=set%20constraints

式Fが与えられたとき、Consis(F)という論理式が作れる。Consis(F)は自由変数を含む式で、その全称閉包を∀[Consis(F)] とする。論理式Aが当該の論理系で証明可能なことを |- A と書く。|- ∀[Consis(F)] とは限らない。が、Consis(F)と同じ自由変数を含んだ論理式Wがあって、|- ∀[W⇒Consis(F)] とはできる。WをFの事前条件と呼ぶ。

UがFの事前条件ならば、U⇒W が成立するとき、Wを最弱事前条件（最汎妥当性制約）と呼ぶ。もし false が最弱事前条件なら、任意の事前条件Uは U ⇒ false （Uは矛盾する、￢U が成立する）となるから、Uの外延は空となる。Consis(F)が空の外延でしか成立しないとは、Consis(F)がまったく成立する見込みがないことだから、Fはまったくダメな式（実行してはいけないプログラム）となる。

最弱事前条件がtrueなら、任意のUに対して U⇒Consis(F) が成立し、任意の外延でConsis(F)が成立するから、Fは無条件で安全なプログラムとなる。

「まったくダメ」と「常に安全」の中間に、条件付きで安全なプログラムがある。そのようなプログラムの最弱条件、つまり最大の外延を計算で求める方法がある。ただし、式Fにある程度の制限を加えないと実効的ではないが、その制限は実用性を奪うほどではない。

&lt;hr&gt;

てなことは、1年以上前にだいたい書いているのか。フムフム。

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%2A%5B%B7%BF%B8%A1%BA%BA%5D

&lt;b&gt;[追記]&lt;/b&gt;「だいたい書いている」けど、カインドがなかったから、カインド計算を前提にしてなくて、その意味で曖昧つうか、暗黙の制約に頼っている。型の代数系、あるいはさらにカインドから構成される代数系の計算を背景にしないと、キチンとしたアルゴリズムは書き下せない。

最近の進歩は、すべての変数（型変数になる）をカインド付きにして、型制約を明示的にしたことだな。型の集合をTとして、Tの部分集合だけではなくて、T&lt;sup&gt;n&lt;/sup&gt; の部分集合（型関係、型制約）も使う。型関数は型関係の特殊なものとも言える。型集合を対象として、型関係を射とする圏で考えることになる。

デカルト半環圏は「値の計算」のモデルにはなるが、「型の計算」のモデルではない。型の計算のモデルは、1レベル上がった、別な圏が必要だった。&lt;b&gt;[/追記]&lt;/b&gt;

*1304662541*[Caty][メモ][Caty更新]Catyの変更や拡張

動くようになった：

+ 変数生成 '&gt;'
+ 変数参照 '%'
+ パイプラインの一時的終了 ';'
+ eachによる変数スコープ（つうかエクステント）
+ casmでスクリプトコマンド定義
+ kindのナンチャッテ第一段階。
+ バッグ型
+ actions/*.cara
+ 新しいスキーマ属性 maxProperties, minProperties, propNameFormat, tight。（remarkは以前から。）
+ XJSONパス、XJSON get/put、パートはまだだが。
+ ignore-tag-onceルール、pv, item, nth とXJSONパス
+ 疑似タグ構文 '@?' '(' (name|string) ':' スカラーリテラル ')'
+ 任意のタグ '@*'
+ 任意の明示的タグ '@*!'
+ 型名タグ '@&amp;' 
+ undefined型と#'undefined
+ @[register-public]
+ CatyBNFのナンチャッテ実装： ::=, :=, = が使える。
+ /*{{{, }}}*/ コメント
+ debug特殊コマンド
+ --no-ambient, --no-appオプション
+ select-action, select-script, trace-dispatchコマンド
+ スキーマ記述用のPythonファイルの分離
+ *.caraにfiletypeを書ける
+ 例外型の定義（exception宣言）
+ deferred型
+ お尻スラッシュ問題に対して、マニフェストに &quot;missingSlash&quot; 追加。
+ _global.xjsonに &quot;addrsAllowed&quot;, &quot;addrsDenied&quot;
+ スタックトレースのWebへの出力
+ throws only
+ 総称コマンドの実行時具体化
+ 国際化フレームワーク
+ フィルターのコマンド化
+ deprecatedアノテーションの処理
+ defaultアノテーションの処理
+ moduleにdocコメント
+ 配列型の項目名
+ HTTPメソッドトンネリング
+ CatyFITのjudge欄
+ ハッシュ記法
+ timeメタコマンド
+ CatyFITにignore-spaceオプション

予定：

+ __integerスキーマ属性
+ whenにotherwiseワイルドカード
+ 複数プロファイル
+ オブジェクトのeach
+ ユニオン型のワイルドカード
+ importと名前の本籍追跡
+ tag-onlyデータ
+ コマンドオーバーロード（優先度低し）
+ テンプレートの elseif

中途半端または未着手：

+ profileスキーマ属性（これはそもそも間違いだった）
+ パラメータ付きのファシリティ
+ inspect-dispatchコマンド
+ アクションサーチのfinishing
+ ファイルタイプの登録抹消
+ auto-print, gen-data 
+ 動的総称型、動的総称コマンド
+ アクションの内部プロファイル
+ インスタンスドキュメンテーション
+ 初期化の最後にコマンドラインを実行するオプション
+  疑似タグによる分岐
+ 例外マッパースクリプト
+ rootApplication 設定 
+ validate --closed 
+ untagged演算子 ^ 

*1304662890*[Caty][型検査]昔の記事を見なおしてコメント

[http://d.hatena.ne.jp/m-hiyama-memo/19100105:title]
- 「実行時型チェック条件」は、最弱事前条件から算出できるはず。最弱事前条件は、「可能な限り実行の邪魔をしない」条件。
- 制御不可変数、制御可能変数、伝搬変数って用語はよくない。独立変数と伝搬変数という言い方はあるかもしれない。
- 「プロファイルの右辺型には、消去不可能なインターセクションを書けない。」-- 消去不可能なインターセクションは全面禁止がいいかもしれない。
- 「シングルトン型」は特殊なスキーマ属性にするとよさそう、と今は考えている。
- 「ドットオンリーのJSONパス」-- ヘー、こんな昔から考えていたのだ。今は、シングルクォートを使うXJSONパスがある。
- 「通常のJSONパスはタグを無視してアクセスする。」-- 今はignore-tag-onceルール。'@'じゃなくて'^'を使うことにした。
- 条件付きワイルドカードは #(...), *(...) にするつもりだ。
- pvalidate（path-validate）は面白いアイディアだが不要だろう。
- 「型変数は、undefinedを含まない領域を表す。」-- なるほど、このころから意識はしていたのか。カインドがなかったけど。

[http://d.hatena.ne.jp/m-hiyama-memo/19100111/1262658439:title]
- Erlangで書いているけど、今度はCatyScriptで書くつもりだ。

[http://d.hatena.ne.jp/m-hiyama-memo/20091219/1261123136:title]
- 型定数、型変数、型関数、型演算子 って言葉をこのころから使っているな。
- 型ラムダ式「type&lt;型変数の並び&gt; 型表現」なんてのも使っていたのだ、このころ。

[http://d.hatena.ne.jp/m-hiyama-memo/20101102/1288667966:title]
- setoid -- より正確にはPERだ。PERがunderliyingで、その上に述語が乗っている構造。
- 「例外に関して4項ホムセット（二車線データフロー）を持つ。」-- これは indexed categoryを使うとヨロシ。
- 「ファントムタグ（#next, #except）」--ファントムって言い方はやめた。オパークにした。

[http://d.hatena.ne.jp/m-hiyama-memo/20101018/1287358225:title]
- 「疑似タグ分岐と値分岐」-- もっと拡張したい。分岐パターン。
- set, dosetはなんか要らないなー、僕は。
- ハイフン変数、あってもいいがなくてもいい。
- 「制御用パイプ記号 ';', '|&amp;', '||' の導入」-- |&amp;, || か？ あれば確かに便利そうではあるな。記号'|&amp;', '||' がどうなんだろう？ 他に候補もないけど。

&lt;hr &gt;

正規表現型がボツになって（延期のつもりだが）、その代わりにバッグ型が入った。型システムやスクリプトではないがアクション導入も大きな変化だ。

</body>
</day>
<day date="2011-05-07" title="">
<body>
*1304741520*[Caty][型検査]これでいいだろう：型検査と制約解決

静的型検査のアルゴリズムは、2009年末から2010年はじめに（2010-01-05, 2010-01-11）だいたいは考えた。その手順を述べると：

+ スクリプトコードからデータフローグラフを作る。（プログラムで実行するなら記号的な操作となる。）
+ データフローグラフのワイヤー（パイプ）ごとに型の単一化（ユニフィケーション）をする。単一化は基本的にロビンソンのアルゴリズムだが、等式ではなくて不等式を扱う点が異なる。
+ 単一化の結果として制約系＝連立不等式系が出力されるので、その連立不等式系の解を求める。

制約系＝連立不等式系を解く部分が問題だが、ホーン論理式の連言と含意を持つ論理系に関する問題として定式化できる。この論理系はSIL（Simple Inclusion Logic）と呼んでいた。

連立不等式系の解法は、論理系SILの充足可能性問題と充足例問題と解釈きる。ここまではいいのだが、実際にこの充足問題を解くのはかなりめんどくさい。完全に解けるものかどうか&lt;em&gt;わからない&lt;/em&gt;（可解性が不明）。そこで次を満たすアルゴリズムでよいとする。

- アルゴリズムが成功したときは、連立不等式系の解を出力する。
- アルゴリズムが失敗したときは、解の存在は不明となるが、実行時チェック条件を出力する。

ここで、「連立不等式系の解」と言っているのは、型変数の具体化である。実行時チェック条件は次の3つの要素で特定される。

+ パイプの位置（一意的にパイプを特定できる）
+ データの部分（パート）を抽出するパス式
+ 具体的な型（型変数なし）

実行時には：

- 特定されたパイプを通るデータはチェックする。
- パス式で抽出された部分が、指定された具体型であればOK。そうでなければ型エラーで致命的ランタイムエラー。

連立不等式系の解を求める部分を&lt;strong&gt;型制約の解決&lt;/strong&gt;（リゾリューション）と呼ぶとすると、解決アルゴリズムには幅がある。極端な例としては、常に失敗して実行時チェック条件だけを出力するアルゴリズムもありだ。上に述べたものは、静的型検査のフレームワークなので、解決アルゴリズムはプラッガブルとなっている。

さて、最近になって解決アルゴリズムの一例を具体的に構成した。あまり精度が高いアルゴリズムじゃないが、実用上は十分だと思う。論理操作によるものではなくて、有向グラフ上の値（型が値）の計算を行う。

不等式系の一部を&lt;em&gt;等式に置き換えて&lt;/em&gt;、ダイクストラのアルゴリズムで値の伝搬と集約を行う。こうして連立&lt;em&gt;等式&lt;/em&gt;系（不等式系じゃない！）の解を求める。この解が他の残った条件を満たすかどうかをチェックする。静的チェックがうまくいかなかったら実行時チェック条件を出力する。

実行時チェック条件をもとのスクリプトコードのパイプに貼り付けていく。パイプごとにチェック条件（0個から複数個）が付いたスクリプトができるが、型検査コマンドをその場所に展開すればよい。型検査の結果として出力されるスクリプトを&lt;strong&gt;CatyScript+e&lt;/strong&gt;と呼んでいて、次の点が普通のCatyScriptと違う。

+ スクリプトコードの冒頭に、__eval-options 内部コマンドを置ける。__eval-options --auto-type-check=false にセットする。
+ スクリプトコードの __eval-options の次の位置に、__schemataブロックを置ける。ローカルに型定義が書ける。
+ 型検査が必要な場所に、__validate-path 内部コマンドが配置される。

CatyScript+eをインタプリタ実行もできる（できたほうがよい）が、__schemataブロックの処理が重いので、かえって遅くなる可能性がある。__schemataブロックは、事前にコンパイルしてアンビエントに格納すれば効率が出るだろう。

*1304746576*[Caty][型検査]型検査と制約解決：全般的な注意

これから、型検査と制約解決の解説をするが、絵を使う。本質的にCatyScriptは絵図言語なので。

既に絵を描いてスキャンした。が、見直したら細部（でもないか？）では絵が間違っている。直すのはめんどくさいので、絵は&lt;em&gt;そのまま使う&lt;/em&gt;。いちおう修正は入れるが、あまり&lt;em&gt;アテにしない&lt;/em&gt;ように注意したほうがいい。

特に制約解決（連立不等式の解法）では、アルゴリズムそのものも不安定なところがある。とりあえず、忘れてしまわないウチに書いておく（つもり）。

*1304746823*[Caty][型検査]型検査と制約解決：全体の手順

次の5段階になるかな。

+ 式（スクリプトコード）からデータフローグラフを作る。
+ データフローグラフをもとに、不等式版の型単一化を行い制約系（連立不等式系）を作る。
+ 制約系（連立不等式系）は論理式なので、推論により論理式を簡約する（より短く単純な形にする）。
+ 制約系を解いて解を求める。解がうまく求まらないなら、実行時チェック条件を書き出す。
+ 制約系の解と実行時チェック条件の情報を埋め込んだ式（スクリプトコード）を作る。

このなかで、データフローグラフを作る部分は色々と応用があるから汎用的な操作。不等式ベースの単一化も他の用途に流用できるかもしれない。

論理簡約は、やらなくてもなんとかなる。やっておけば、次の制約解決フェーズが楽なる。

制約解決の部分はバリエーションがある。とりあえず使えるものを作って、だんだんに精度を上げていけばいいだろう。

*1304748980*[Caty][型検査][お絵描き]型検査と制約解決：ジャンクション

[http://d.hatena.ne.jp/m-hiyama/20110422/1303464264:title] とか [http://d.hatena.ne.jp/m-hiyama/20110426/1303802931:title] とかにデータフローグラフの例はある。ボックス＆ワイヤーの絵を描けばいいのだが、ワイヤリングのための特殊なノードとして&lt;strong&gt;ジャンクション&lt;/strong&gt;てのがあるから、これを説明しておく。

ジャンクション：
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/caty-junctions.gif&quot; /&gt;
&lt;a href=&quot;http://www.chimaira.org/img2/caty-junctions..gif&quot;&gt;原寸大&lt;/a&gt;

コピーとジョインはいいとして、そこから下は&lt;em&gt;説明のテキストが変&lt;/em&gt;だな。

- ペア、タプル、ラベル付きタプル： 射のデカルトペアやデカルトタプルを作るときの右半分の絵で、この絵自体は直積とラベル付き直積を作るジャンクション。要するに複数本のワイヤーを一本にまとめる絵。まとめ方が、直積とラベル付き直積がある。ラベル付き直積は、「×」じゃなくてテンソル積風の「(×)」にした。同様にラベル付き直和は「(+)」。
- ラベル付き直和（ユニオン）の分解は、ジョインにあわせて丸印を付ければ良かった。そうでないと、ラベル付き直和構成を左右逆にしただけで区別が付きにくい気がする。

次の双対性がある。

- 直積と直和
- コピーとジョイン
- ラベル付き直積の構成とラベル付き直和の分解
- ラベル付きデカルトタプリングとラベル付きデカルト余タプリング

ジャンクションの図の右側のほうには、等式的な型付け規則（typing rules）を書いている。データフローグラフ上での型付けとは、ワイヤーに対して「型で辺ラベルを付ける」こと。等式的な型付けでは、一本のワイヤーに&lt;em&gt;ひとつの型&lt;/em&gt;が付く。

一番単純なジャンクションを描き忘れた。それは単なるワイヤー。

ストレートジャンクション：
&lt;img src=&quot;http://www.chimaira.org/img2/caty-straight.gif&quot; /&gt;

それと、ジャンクションとは違うが、射のクリーネスターがある。List関手と言っても同じ。f:A→B に対してクリーネスターを作用させると、f&lt;sup&gt;*&lt;/sup&gt;:A&lt;sup&gt;*&lt;/sup&gt;→B&lt;sup&gt;*&lt;/sup&gt; となる。

クリーネスター関手：
&lt;img src=&quot;http://www.chimaira.org/img2/caty-star.gif&quot; /&gt;

&lt;hr&gt;

記号的な型付けのルールは次のようになる。

+ fが基本コマンドなら、Dom[f] = dom(f), Cod[f] = cod(f)
+ Dom[&amp;#60;F, G&gt;] = Dom[F]∩Dom[G] , Cod[&amp;#60;F, G&gt;] = Cod[F]×Cod[G]
+ Dom[{F &gt;:α, G &gt;:β}] = Dom[F]∩Dom[G] , Cod[{F &gt;:α, G &gt;:β}] = Cod[F]&lt;sub&gt;α&lt;/sub&gt;(×)Cod[G]&lt;sub&gt;β&lt;/sub&gt;
+ Dom[(α=&gt; F, β=&gt; G)] = α・Dom[F](+)β・Dom[G] , Cod[(α=&gt; F, β=&gt; G)] = Dom[F]∪Dom[G]

下付きの A&lt;sub&gt;α&lt;/sub&gt; は、プロパティ名がαのプロパティを表す。1つのプロパティは、そのプロパティだけを持つオブジェクトと同一視できるから、A&lt;sub&gt;α&lt;/sub&gt; は単一プロパティのオブジェクト型と思ってよい。すると、(×) は排他的マージ「++」となる。ナカグロで書いた α・A は、タグαを持つタグ付きデータ型。

等式的な型付けのルールなら次を使う。

- Dom[F|G] = Dom[F], Cod[F|G] = Cod[G]

だが、Catyは不等式的な型付けをするので、パイプラインの両端以外ではこのルールは適用しない。（暫定値を求めるのに使うことはある。）

*1304751227*[Caty][型検査][お絵描き]型検査と制約解決：不等式的な型付けと制約系（連立不等式系）

不等式的な型付けとは、ワイヤー（パイプ）が1本あると、その両端に型がラベルされる型付けの方法。普通の圏論だと、f:A→B, g:C→D が結合可能なのは B = C のときだけだが、Catyでは B = C は要求しない。B ⊆ C という集合の包含に関する不等式を要求する。したがって、fのボックスとgのボックスを繋ぐワイヤーには、「左にB、右にC」というラベルが貼られる。それで、B⊆C という不等式も添えることになる。

下の図は、ワイヤーに2つの型をラベルして制約の論理式（不等式）を書いたもの。

制約の論理式：
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/caty-constraints.gif&quot; /&gt;
&lt;a href=&quot;http://www.chimaira.org/img2/caty-constraints.gif&quot;&gt;原寸大&lt;/a&gt;

基本的な型構成子は：

+ 集合のミート（共通部分）
+ 直積
+ 直積ラベリング（Aとαから A&lt;sub&gt;α&lt;/sub&gt; を作る）
+ ラベル付き直積
+ 直和ラベリング（Aとαから α・A を作る）
+ ラベル付き直和

Catyでの記法は：

+ &amp;amp;
+ [-, -]
+ {-: -} または {- &gt;:-}
+ ++
+ @- - または - &gt;@ -
+ |

&amp;amp, ++, | は中置二項演算子で、結合的演算。++, | は全域的に定義されていない。&gt;@ も中置二項演算子なのだが、少し変わっているかな。

このような構成子（演算、関数）と包含の不等号を扱う論理系をSILと呼ぶ。以下にSILの解説。

&lt;hr /&gt;

SILは2つのソートを持つ。型（集合と言っても同じ）とラベルが2つのソート。基本記号は次のとおり。

+ 型定数
+ 型変数（x, yなど）
+ 型演算子、型関数
+ 型関係記号 ⊆
+ ラベル定数（たくさん）
+ ラベル変数（α、βなど）
+ ラベル関係記号 =、≠
+ 型とラベルの演算記号 ・と_（下付き添字の代わり）
+ 括弧

通常の方法で型項とラベル項が定義できる。ラベル項はラベル定数かラベル変数。原子論理式は：

- 型論理式 ::= 型 ⊆ 型
- ラベル論理式 ::= ラベル = ラベル | ラベル ≠ ラベル

一般の論理式は：

- 型論理式 ::= 原子論理式 | 型論理式 ∧ 型論理式 | 型論理式 if ラベル論理式 | ∀x,y.型論理式 など
- ラベル論理式 ::= 原子ラベル論理式 | ラベル論理式 ∧ ラベル論理式 | ∀α.ラベル論理式 など

論理式からシーケントを作って、シーケント計算の体系を作ればいい。公理系はデクスター・コゥゼンが揃えている。

SILのなかで論理計算を行えばそれなりの効果はあるだろうが、とりあえずはSIL使わなくてもいいかな、と。

*1304756310*[Caty][型検査]型検査と制約解決：制約解決＝連立不等式系の解を求める

制約解決の部分は今までいいかげんでしたね。そもそも、連立不等式系なので、解があっても一意的に決まるわけではない。なにか「最適性」の基準を決めて、「制約（不等式の集まり）を満たしてコレコレを最大にする」ような最適解の問題にできればいいのだけど、「なにが最適か？」もハッキリしない。

という事情で、解けるかもしれないが、見つかった解がいいか悪いかわからん、という状態だった。それはまー今でも変わらないのだけど、あまり複雑でなくて、「悪くない解」が見つかるアルゴリズムで妥協する。

下の図にだいたいのステップを書いている。単一化の結果から二部グラフ（無向、有向の混合グラフ）を作って、それを全部つないだグラフ内で計算を行う。そのグラフは、変数間の制約を記述したグラフ。このグラフの部分グラフを制約の伝搬フローとみなして、ダイクストラアルゴリズムで暫定解を求める。暫定解が残りの条件を満たすかを後からチェックする方針。

制約伝搬フローグラフを作るとき、片方向（one-way）だけを考えるので、&lt;strong&gt;片方向伝搬法&lt;/strong&gt;（one-way propagation method）とでも呼んでおこう。片方向伝搬法は、片方向（絵では右から左）しか考慮しないので、あまり精度が高くない。が、まーいい、妥協、妥協。

制約伝搬フローグラフにサイクルがあっても大丈夫だと思うが確認してない。たぶん、最大不動点（最小不動点ではない）を取ればいいだろう。

制約解決の方法：
&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/caty-resolution.gif&quot; /&gt;
&lt;a href=&quot;http://www.chimaira.org/img2/caty-resolution.gif&quot;&gt;原寸大&lt;/a&gt;

上の図に間違いがあったり、後から考えが変わった部分もある。が、順に説明していく。

&lt;h5&gt;単一化&lt;/h5&gt;

箱はコマンド、線がワイヤー＝パイプを表す。コマンドが総称プロファイルを持っているとき、その型変数を箱のなかに丸で描くとする（描き方はなんだっていいが）。本来、総称プロファイルに出現する型変数はラムダ束縛されているので、変数名はいくら変えてもいい（アルファ変換）。アルファ変換をして、全体として同じ変数名が現れないようにしてからラムダ束縛を解除する。つまり、自由変数のように扱う。まえもってアルファ変換をしておけば、本来違う変数が同じ名前になることはない。ぜーんぶ違う変数として扱う。

絵には描いてないが、ワイヤーの左右に総称型のラベルが貼ってある。例えば左がS(x,y)、右がT(z,w,u)のように。単一化は、S(x,y)とT(z,w,u)に関して行う。単一化が成功すれば、その結果は、変数 x, y, z, w, u のあいだの不等式の集合（空集合かもしれない）となる。

絵の例では：

+ x⊆z
+ y⊆f(z)
+ x⊆w
+ g(y)⊆w

を想定している（一例として）。

「変数⊆変数」の形の不等式だけ特別扱いして、無向辺で変数どうしを繋いでいる。が、この特別扱いは不要だった気がする。ステップ1もおそらく不要だろう。

y⊆f(z) の形のとき、「zの制約がfを通してyに伝搬する」という意味で zからy に矢印を描いている。これを&lt;strong&gt;伝搬辺&lt;/strong&gt;と呼ぼう。yからwの辺も同じなのだが、こっちの伝搬は無視する。片方向伝搬法と名付けた由来は片方しか見ないから。g(y)⊆w は無視してしまう。右から左 -- コドメインからドメインを制約する方向だけに注目する。

&lt;h5&gt;変数の値と関数&lt;/h5&gt;

説明の順序が前後するが、片方向伝搬法では、型とか集合とかはもう考えない。変数は値で具体化される、というだけ。値は最小限を持つミート半束の要素だとする。ミート半束のミートは∧で表すが、a∧b は単に a b とか ab とも書く。

ミート半束に値を持つ定数、変数、関数が登場する。関数は単調なものに限る。特に、関数は最大値を最大値に移す。

&lt;h5&gt;最大値による初期化&lt;/h5&gt;

各変数には、許される変域があり、その変域（定義域）は最大値を持つ。変数の変域の最大値を、その変数の最大値と呼ぶ。

最初は、すべての変数をその最大値で初期化する。絵の例では：

+ x := a
+ y := b
+ z := c
+ w := d
+ u := e

&lt;h5&gt;連結成分の変数達は同じ値にする&lt;/h5&gt;

x⊆z, x⊆w のような形で関連する変数は、無向辺で結んである。この無向辺による連結成分を求めて、同じ連結成分に属する変数はすべて同じ値にする。その値は、連結成分内のすべての変数のミートを取った値である。

+ x = acd
+ z = acd
+ w = acd

&lt;h5&gt;伝搬の影響を計算する&lt;/h5&gt;

右から左に向かう辺だけを取り出して、その部分グラフ上で伝搬の影響を累積する。

上の絵では、2つの箱と1本のワイヤーしか出てこないが、すべての箱とワイヤーからグラフを作るのでグラフは大きくなるかもしれない。そのグラフ上で、伝搬関数を成分とする正方行列を作って、クリーネ・ファインマン型の累積値を計算する。

この状況では、… &lt;em&gt;またも出ましたダイクストラ・アルゴリズム&lt;/em&gt;。ダイクストラ波動を発進させる境界（有向グラフのルート領域）を求めて、そこから累積値を計算する。普通は積和を計算するが、半束なのでミートしか演算がない。しいていえば、辺上の関数による計算が積で、ミートを和とする総積和となる。

&lt;h5&gt;残っていた条件のチェック&lt;/h5&gt;

左から右への矢印は無視していたので、ダイクストラ波動を走らせた後でチェックする。このチェックのときは、変数はすべて具体化されているので、具体値の不等式チェックとなり、真偽が決定する。

チェックで不等式偽となっても、それで完全にダメということではない。暫定解と整合しないだけで、暫定解を少し変えれば不等式を満たす可能性がある。が、暫定解を変えることはしないで、事後チェックが失敗した部分だけ実行時チェックにする。

&lt;h5&gt;注意&lt;/h5&gt;

ステップ3のチェックに入る前に、暫定解において値が0（最小値）になる変数がないかのチェックを入れるのが普通。0は、普通は空集合を意味し、たいていは具合が悪い。その他、チェックすることはあるかもしれない。

型変数はもとの総称形における出現位置から、パス式を持つ。このパス式を使えば、実行時チェックを軽くできる可能性がある。CatyScript+eのパス毎のバリデータはそのような用途を想定している。

制約伝搬グラフにサイクルがあるとき、μオペレータの逆であるνオペレータを使えばいいと思う。νオペレータは最大不動点演算子だが、最大不動点の存在を示す必要はあるな。

&lt;h5&gt;最後に&lt;/h5&gt;

片方向伝搬法は、制約条件の半分(? 方向から言えば半分)を捨ててしまうので、ちょっとヒドイとも言えるが、実際的にはこれでたいていは間に合ってしまうのではないかなー。メインになるのはロビンソン・アルゴリズムとダイクストラ・アルゴリズムだけど、記号処理やグラフ変形を多用するので、それほど簡単とも言えない。ここらへんがいい落とし所だと思っている。

</body>
</day>
<day date="2011-05-09" title="">
<body>
*1304896664*[Caty][型検査]スキーマ属性

- ※ 内部的に別な形式を採用
- △ 曖昧（明瞭でない）
- × 実装しない

|* スキーマ属性名 |* 適用対象となる型 |* 意味 |* 値の型 |* デフォルト値|
|minimum ※        | number            |最小値 |number   | なし|
|maximum ※        | number            |最大値 |number   | なし |
|exclusiveMinimum ※| number            |最小値はイコールを含まない|boolean|false|
|exclusiveMaximum ※| number            |最大値はイコールを含まない|boolean|false|
|divisibleBy      | number            |特定の数で割り切れる|number|なし |
|minLength        | string            |文字列の最小長|非負integer |なし |
|maxLength        | string            |文字列の最大長|非負integer |なし |
|format △※      | string, &lt;del datetime=&quot;2011-05-09T08:17:44+09:00&quot;&gt;number&lt;/del&gt;    |文字列と数値のフォーマット|string|なし|
|pattern ×       | string            |正規表現パターン|string|なし|
|minItems         | array             |配列の最小長|非負integer|なし|
|maxItems         | array             |配列の最大長|非負integer|なし|
|uniqueItems ×   | array             |配列項目が全部異なる|boolean|false|

Catyで追加

|* スキーマ属性名 |* 適用対象となる型 |* 意味 |* 値の型 |* デフォルト値|
| remark △       | すべて            |自然言語による制限 | string | なし |
| format △※     | binary      |バイナリのフォーマット|string|なし|
| profile △※    | string, binary    | フォーマットの補助情報 | string | なし|
| minProperties   | object            |プロパティの最小個数|非負integer|なし|
| maxProperties   | object            |プロパティの最大個数|非負integer|なし|
| tight           | array             |  タイト配列かどうか|boolean|false|
| propNameFormat △| object           |プロパティ名のフォーマット|string|なし|
| __integer       | number            | 整数である | boolean  | false|

*1304897033*[Caty][型検査]もっと精度を上げたほうがいいかも、だが難しい

「片方向伝搬法は精度が悪い」と書いたが、簡単な例でも実際に精度が悪い(苦笑)。

精度を上げるには、いくつかの方法がある。

+ 論理系SILのなかで論理簡約をがんばる。
+ 充足可能性問題の精度を上げる。
+ 充足例問題の精度を上げる。

このなかで、充足可能性問題の精度を上げても、全体としてはあまり効果がないかも。充足不可能な制約を検出するとは、実行してはいけないプログラムの検出なので、まー意義はあるのだが、実行してよいプログラムの情報が増えるわけではない（ことが多い）。

論理系SILを働かせるのはそれなりの効果が期待できるが、SILが完全に定式化できてない。決定可能な論理システムかどうかも分からない。

最弱事前条件＝最汎制約の充足例を求めるのが一番いいのだけど、最適な充足例の定義がいまのところマッタク出来ない。原理的に出来ないような気もする。具体化しないで実行時の安全性を定義できるのだろうか？

*1304898865*[Caty][型検査]集合論的半環宇宙、モデル代数、エルブランモデル

集合圏の部分圏で、isoの族Eが指定されていて、Eに関して亜群になっているようなものUを考える。そして：

+ 空集合と単元集合（少なくとも1つ）を含む
+ A, B∈|U| ならば、A×B∈|U|
+ A, B∈|U| ならば、A+B∈|U|
+ 半環圏としての構造同型がEに入っている。

このような部分圏を集合論的な半環宇宙と呼ぶ。

同値関係～を持つ集合Aで、次の部分演算を持つものを考える。

+ P:A×A⊃→A
+ S:A×A⊃→A

半環宇宙UからAへの写像fがあって、任意の対象A,Bに対して

+ AとBがEにより同型なら、f(A)～f(B)
+ f(A)～a, f(B)～b となるa, bがあって P(a, b) が定義され、A×Bを表現する。
+ f(A)～a, f(B)～b となるa, bがあって S(a, b) が定義され、A+Bを表現する。

その他適当な条件を満たすとき、AはUのモデル代数と呼ぶことにする。特に、Aが適当な項のエルブラン宇宙になっているとき、エルブランモデル代数、あるいは単にエルブランモデル。

型理論の意味論は、集合論的半環宇宙を外的なモデル（概念的なモデル）と考えるのだが、実際の作業はエルブランモデル（＝内的モデル＝実装モデル）を構成することだろう。

</body>
</day>
<day date="2011-05-10" title="">
<body>
*1305003789*[Caty][その他代数][形式言語理論][型検査]型演算子のまとめ

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110421/1303357495&quot;&gt;「各レベルの構成子、演算記号」&lt;/a&gt;にだいたいまとめたが、別な観点からまとめておく。

型の全体を代数系と考える。これは2ソート代数で、「ラベル型」ソートと「データ型」ソートを持つが、単に「ラベル」と「データ」と言ってしまうこともある。Lをラベル型の全体、Dをデータ型の全体として、色々な演算を持つ。説明欄に×が付いているのは実装がないもの。

|* 演算の説明       |* 演算のプロファイル |* 演算記号 |* Catyスキーマ |
| ラベルの連接×    | L×L → L           | ・        | &gt;&gt;  |
| ラベル連接の単位×| 1 → L              |  ε       | [] |
| ラベルのミート×  | L×L → L           | ∧        | &amp;amp;  |
| ラベルミートの単位×| 1 → L            | L         | * (string) |
| タギング       | L×D → D           | ・        | @, &gt;@ |
| タギングの右単位×| 1 → L             | ε        | [] |
| タギングの左擬単位| 1 → D           | υ        | undefined |
| タグのデータへの埋め込み | L → D              | -・υ     | 単項の @ |
| 直積           | D×D → D           | ×        | [-, -], &gt;&gt; |
| 公平有限直積   | D&lt;sup&gt;2+&lt;/sup&gt; → D | 複数の×  | [-, ..., -], 複数の&gt;&gt; |
| 直積の単位     | 1 → D              | 1&lt;sub&gt;×&lt;/sub&gt; | null |
| 無限直積×     | D&lt;sup&gt;*∞&lt;/sup&gt; → D| Π        | なし |
| 有限台無限直積 | D&lt;sup&gt;*∞&lt;/sup&gt; → D| Π ×      | [-, ..., -*] |
| ラベル付き直積           | D×D → D           | (×)        | ++ |
| ラベル付き公平有限直積   | D&lt;sup&gt;2+&lt;/sup&gt; → D | 複数の(×)  | 複数の++ |
| ラベル付き直積の単位     | 1 → D              | 1&lt;sub&gt;(×)&lt;/sub&gt; | {} |
| 無限ラベル付き直積×     | D&lt;sup&gt;*∞&lt;/sup&gt; → D| Π        | なし |
| 有限台無限ラベル付き直積 | D&lt;sup&gt;*∞&lt;/sup&gt; → D| Π ×      | {-:-, ..., *:-} |
| 直和×         | D×D ⊃→ D           | +        | なし |
| 公平有限直和× | D&lt;sup&gt;2+&lt;/sup&gt; ⊃→ D | 複数の+  | なし |
| 直和の単位     | 1 → D              | 0        | never|
| 無限直和×     | D&lt;sup&gt;*∞&lt;/sup&gt; ⊃→ D| Σ        | なし |
| 有限台無限直和×| D&lt;sup&gt;*∞&lt;/sup&gt; ⊃→ D| Σ +      | なし |
| ラベル付き直和           | D×D ⊃→ D           | (+)        | &amp;#124; |
| ラベル付き公平有限直和   | D&lt;sup&gt;2+&lt;/sup&gt; ⊃→ D | 複数の(+)  | 複数の&amp;#124; |
| ラベル付き直和の単位     | 1 → D                | 0          | never |
| 無限ラベル付き直和×     | D&lt;sup&gt;*∞&lt;/sup&gt; ⊃→ D| Π        | なし |
| 有限台無限ラベル付き直和 | D&lt;sup&gt;*∞&lt;/sup&gt; ⊃→ D| Π +      | (@- -&amp;#124; ..., &amp;#124;@* -) |
| ミート（集合の共通部分） | D×D → D | ∧  | &amp;amp; |
| ミートの単位             | 1 → D    | U   | any?  |
| ジョイン（集合の合併）× | D×D → D | ∨  | &amp;#124;&amp;#124; |
| ジョインの単位           | 1 → D    | 0   | never |
| クリーネスター | D → D              | -&lt;sup&gt;*&lt;/sup&gt; | [-*] |
| 0のクリーネスター | 1 → D           | 0&lt;sup&gt;*&lt;/sup&gt; = 1 | [] |

単位だけ取り出してみる。

| ラベル連接の単位×| 1 → L       |  ε       | [] |
| ラベルミートの単位×| 1 → L     | L         | * (string) |
| タギングの右単位×| 1 → L       | ε        | [] |
| タギングの左擬単位| 1 → D       | υ        | undefined |
| 直積の単位        | 1 → D       | 1&lt;sub&gt;×&lt;/sub&gt; | null |
| ラベル付き直積の単位| 1 → D     | 1&lt;sub&gt;(×)&lt;/sub&gt; | {} |
| ラベル付き直和の単位| 1 → D     | 0          | never |
| ミートの単位        | 1 → D     | U   | any?  |
| ジョインの単位      | 1 → D     | 0   | never |
| 0のクリーネスター | 1 → D           | 0&lt;sup&gt;*&lt;/sup&gt; = 1 | [] |

随分とたくさんの演算があるもんんだ。

以上に出てこないが他にも重要な演算がある。

|* Catyの型演算子 |* 説明 |
| ?               | オプショナル |
| !               | 必須（required） |
| (, )            | スキーマ属性付与 |
| {, }            | バッグ型の出現回数 |

オプショナル'?'は、代数的には x? = x∨υ と書ける。同様に、x! = x - υ （- は集合差として）

他に、Catyスキーマで出てくる記号は：

- &gt;:, &gt;@ 図式順の演算、ただし、&gt;@ は中置二項演算子。
- クリーネスターの'*', プロパティ名ワイルドカードの'*'
- タグ名ワイルドカードの'*' , '*!'
- 疑似タグの '@?'
- 型名タグの '@&amp;'

演算子の構文上の形式から整理すると以下。

|* Catyの型演算子 |* 説明  |* 形式          |* 備考 |
| &gt;&gt;              | 連接   | 中置二項演算子 | 実装はない |
| &amp;#124;&amp;#124;    | 合併   | 中置二項演算子 | 実装はない |
| &amp;amp;           | ミート | 中置二項演算子 |  |
| ++              | マージ | 中置二項演算子 |  |
| &amp;#124;          | ユニオン（排他的）| 中置二項演算子 |  |
| [ ]            | 配列    | 特殊形式多項演算子 | |
| [ ,-*]         | 可変配列 | 特殊形式多項演算子 | |
| { }            | オブジェクト | 特殊形式多項演算子 | |
| { ,*:-}         | 可変オブジェクト| 特殊形式多項演算子 | |
| do { }         | DOオブジェクト| 特殊形式多項演算子 | |
| do {,:&gt;*}       | DO可変オブジェクト| 特殊形式多項演算子 | |
| @               |タグング|前置二項演算子  |  |
| &gt;@              |タグング|中置二項演算子  | タグが右 |
| ?               |オプショナル |後置単項演算子| |
| !               |必須（required） |後置単項演算子 |未実装 |
| (, )            |スキーマ属性付与 |後置単項演算子 | |


</body>
</day>
<day date="2011-05-11" title="">
<body>
*1305082574*[映画]名探偵コナン

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110418/1303085726&quot;&gt;ココ&lt;/a&gt; で話題になっていた「名探偵コナン」の最新作（15作目)『名探偵コナン 沈黙の15分（クォーター）』を次男と見てきた。

以前も次男とコナンみたけど、いつだったか？ 2009年の『漆黒の追跡者＜しっこくのチェイサー＞』か。あのときのようなムチャクチャなスーパー推理はなかったな。けっこうマトモな感じだった。その分、印象も薄いが。

</body>
</day>
<day date="2011-05-12" title="">
<body>
*1305180910*[goog]実験ディレクトリー

どこで実験していたか忘れる。

- ~/ProjectCaty/latest-*/main/ui/pub/js/ 

ここにある。Webからは /ui/js/ として見える。

*1305189432*[Caty][プログラム意味論][圏一般論][型検査]Catyの型システムの背景とアルゴリズム

http://twitter.com/#!/hiyama_on_caty/status/67728585816948736 とか http://twitter.com/#!/hiyama_on_caty/status/68582156598910976 とかつぶやいてるだけだと後で分からなくなる。

&lt;h5&gt;型の代数はブール半環層を係数とする多元環圏&lt;/h5&gt;

型の表現を台集合Aとその上の述語pの組で表す。(A, p)でもいいが、{x∈A|p(s)} だから {A|p} と略記するといい。さらにはpを係数として p・A、pA と書いてもいいだろう。

台集合の全体、正確には台集合を表現する記号の全体は帰納的な可算集合で：

- neverを含むスカラー型（の記号）が基本記号
- 直積×と∩、∪から作られる式

×、∩、∪に関する代数法則から同値関係が入る。+ を導入すると、×と＋で半環になる（と思ってよい）。型変数を考えない具体型（の表現）なら順序が判定可能で、順序を射と思って圏となる。各台集合（の表現）にスキーマ属性を付けると、スキーマ属性の全体がブール半環（否定のないブール代数）となるから、台集合の包含の圏からブール半環の圏への関手ができる。この関手は貼りあわせ条件を満たすから層になる。

もともと半環だったのだが、ブール半環の層を係数にしたスカラー乗法を入れると、この可換半環（の層）係数の多元環となる。包含順序を射とみなせば多元環圏。

総称型は関手だが、掛け算と足し算から構成されるから多項式関手。複線形関手と定数との足し算で構成されるアフィン複線形関手に対角を組み合わせた形が多項式関手。

&lt;h5&gt;型グラフをプログラムと解釈する&lt;/h5&gt;

型定義モジュール（の一部）を有向グラフとして描いて型グラフと呼ぶことにする。そのノードは：

+ define {name, body}
+ never 末端
+ any 末端
+ null,  boolean, number, string, binary, tagName 末端
+ array {items}
+ object {properties}
+ tagged {name, val}
+ union {choices}
+ option {base}
+ reference 末端

グラフ構造にとって特に重要なのは、unionによる場合分けとdefine/refereceによる接続。

次の解釈で、型グラフをプログラム（の表現）と考える。

- union → 非決定性の選択だが、タグと値がガード
- option → if-exists-then
- referece → goto
- any → ある種の暴走（乱数選択でもいい）

以上を制御ノードと呼ぶ。それ以外はデータノードでコンストラクタとなる。

型グラフで表現できるプログラムの関して、プログラムAが生成可能なデータ集合をD(A)と書く。プログラムAの任意の挙動をプログラムBが模倣できるなら、Aが生成するデータは必ずBでも生成できる。したがって、D(A)⊆D(B) 。これは受理オートマトンとみなすのとは逆（双対）で、生成装置とみなしている。が、どっちでも同じだろう。

データ集合の包含関係を、プログラムの生成能力の順序に置き換える。生成能力を模倣関係に還元し、最大の模倣関係を「単一化＋ダイクストラ法」で具体的に構成する。というストーリー。


</body>
</day>
<day date="2011-05-13" title="">
<body>
*1305275791*[Caty][プログラム意味論][形式言語理論][型検査]再帰的データ型の包含性の判定、わかった

結局、分かった後から眺めれば、正規表現型のときと事情は同じだ。あからさまに（陽に）正規表現を使ってなくても、再帰的な定義を入れれば、結局は正規言語になる。「再帰的データ型（の領域）＝正規言語」と言ってよいから、正規表現型の導入と再帰的なデータ型の導入は同じこと。だから、やることも同じ。

次の3つの問題が同じなのだ。

+ 集合の包含性の判定
+ オーマトンの模倣の存在を示す
+ 無限正規木の埋め込み可能性の判定

包含性の判定をそのままやるのは難しい。論理計算に持ち込む方法として、ホヴランド（Hovland）のアルゴリズムとかコゥゼン（Kozen）の集合制約（set constraints）の解法とかあるが、難しいし効率も芳しくない。

制限（明瞭性）を付けてオーマトン（あるいは余代数）の模倣構成問題にしたほうがやさしいし高速な解法がある。それが1年弱前に考えていた拡張ダイクストラ法。

今回も状況は同じだから拡張ダイクストラ法が使える。一般的な明瞭オートマトンに比べると、サイクル付きの林の形をしているので少し扱いやすい。有限な状態空間のあいだの関係をビット行列として作っていく方法。林のリーフノード全体の集合が終状態となる。

すべてのノードをくまなくチェックしたことの確認が難しい。全体として木の形をしているから、普通の深さ優先探索順序でスキャンしていけば良いと思われるが、ループのところでもうまく処理できるかを確認しないと。

工夫の余地はあるが、大筋は大丈夫そうだ。


</body>
</day>
<day date="2011-05-14" title="">
<body>
*1305348974*[Caty][形式言語理論][型検査][リンク]正規表現、オートマトン、包含、型推論

SGMLに関連して割と有名な論文。&quot;deterministic&quot;を使っているが、決定性オートマトンの「決定性」とは違う。

- Title: Deterministic Regular Languages (1992) （実際にはたぶん1991）
- Authors: Bruggemann-Klein, Wood
- URL: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.6882

同じ著者（Bruggemann-Klein ＆ Wood）による、内容も同じような論文。&quot;deterministic&quot;じゃなくて&quot;One-Unambiguous&quot;という用語を使っている。

- Title: One-Unambiguous Regular Languages (1997)
- Authors: Bruggemann-Klein, Wood
- URL: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.3277

Hovlandの、正規表現で定義した型の包含関係を扱っているもの。型推論のアルゴリズムも載っている。One-Unambiguousの場合は、高速に処理できる。

- Title: The Inclusion Problem for Regular Expressions
- Author: Dag Hovland
- URL: http://www.ii.uib.no/~dagh/reinclusionBORA.pdf
- URL: https://bora.uib.no/handle/1956/3956

Antimirov, Mosses がintersectin付きの正規表現を扱っている。

- Title: Rewriting Extended Regular Expressions
- Authors: Antimirov, Mosses
- http://www.daimi.au.dk/PB/461/PB-461.pdf

以下は型理論ぽい。ちょっと面白そう。

- Title: Simple, Decidable Type Inference with Subtyping
- Author: Eli Gottlieb
- URL: http://arxiv.org/abs/1104.3116


</body>
</day>
<day date="2011-05-16" title="">
<body>
*1305502507*[Caty][モノイド圏][トレース／コンパクト閉圏][気付いた]モジュールの圏

&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;category of modules って言葉は使えないわ。加群圏だもんな。&lt;/em&gt; &lt;b&gt;[/追記]&lt;/b&gt;

ゴグエンの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%C2%E7%B6%C9%C5%AA%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0&quot;&gt;大局的プログラミング&lt;/a&gt;（&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=programming%20in%20the%20large&quot;&gt;programming in the large&lt;/a&gt;）の発想でモジュール計算をしていたら、GoI構成とコンパクト閉圏が出てきてビックリ。

モジュールMとNが提供（provide）している名前をお互いに吸収しあう方法で結合すると、これがGoI構成の8の字結合になる。8の字結合と対角、余対角を組み合わせると、提示する名前を減らさない（privateにしない）結合になる。

再帰的な定義（定義の再帰化）がトレースに対応しているから、モジュール集約をモノイド積、モジュールの直列結合を結合とするレース付きモノイド圏で、名前により自然にGoI構成がなされているらしい。リネームや隠蔽（hiding）なども圏論的な定式化ができる。

それと、モジュール名やパッケージ名による修飾（qualify, prefix）を、直和を作るタギングとして捉えることができる。これを考慮すると、importの構文は：

- import type foo as bar from other.mod prefix m;

リネーミングとプレフィックシングはどちらから一方があれば足りる。リネームはやめてプレフィックシングだけにするほうが単純かも。

*1305503157*[Caty][形式言語理論][型検査]サイクルがあるとき、確実な列挙方法

[http://d.hatena.ne.jp/m-hiyama-memo/20110513/1305275791:title] の「すべてのノードをくまなくチェックしたことの確認が難しい。」というハナシ。これも大丈夫だろう。

とりあえず、練習問題としてサイクルがあるツリー（言葉は変だが）のノード列挙問題を考えるとよい。一番アホだが一番確実なのは、訪れたノードを全部記録しておくこと。「一度訪れたノードは二度行かない」という制限付きで、深さ優先再帰的トラバースはできる。

「過去は全部記録方式」のトラバースを、参照（部分構造の共有）がある場合に拡張する。参照先への“ハイパージャンプ”があるが、ハイパージャンプの履歴も記録して“戻るボタン”を有効にする。要するに、なんでもかんでも記録する。

「一度訪れたノードは二度行かない」の代わりに、2つのツリーのノード対に関して、「一度確認したノード対は二度確認はしない」とすれば、模倣の構成ができる。記録されたノード対は、模倣関係の要素となる。具体的に構成された模倣にも使いどころがあるかもしれない。

だんだん模倣の構成が当たり前にできる感じがしてきたぞ。模倣の圏がとてもリアルに見えてきた。包含性判定が主たる応用だが、他にも使える感じがするな。クリーネ／ファインマン総和と拡張ダイクストラ法をガシガシ使って型解析やってみるべ。アルゴリズムをもう少し速くしないとなー。

*1305538936*[Caty][モノイド圏][トレース／コンパクト閉圏]モジュール演算

大局的プログラミング（programming in the large）：

手でモジュールの計算をするときの演算記号を決めておこう。キーボードでも書けるようにアスキーベース。

|* 演算記号   |* 意味 |
| +           |モノイド積、モジュールの集約／マージ |
| &amp;#124;&gt;   | 圏の結合、普通の結合 |
| :&gt;          | 閉じた吸収結合 |
| *&gt;          | 開いた吸収結合 |
| &amp;lt;:&gt;       | 対称な閉じた吸収結合 |
| &amp;lt;*&gt;       | 対称な開いた吸収結合 |


吸収結合（absorbing composition; 檜山造語）は絵を描かないとうまく説明できない。ので、いずれまた。

</body>
</day>
<day date="2011-05-21" title="">
<body>
*1305935158*[メモ][雑感]行き詰まったときには

http://twitter.com/#!/hiyama_on_caty/status/71717718457450497 あたり：

&gt;&gt;
なんか行き詰まり感があるなー。今日は、この行き詰まりを解消するために、、、何をすりゃいいんだかね？
&lt;hr&gt;
こういうときは、アイディアが足りないというよりは；見落としや勘違いをしていることが多いんだよな。あるいは、方向性が間違っているとか。
&lt;&lt;

なにが原因か：

- 目的と手段の混同、または不適切な設定： 目的を忘れて手段を追求している。適切な手段を選んでいない。
- 異なる状況を区別できてない： 似ている、しかし本質的に違う状況を峻別できてないので、矛盾があるように感じる。
- 前例にとらわれている： 前例や既存の手法を使うのは当然だが、適切でない手法を無理に適用しようとしている。
- 解けない問題： 解けない問題を解こうとしている。問題設定に無理がある。
- 解けている問題： 既に解けている問題を解けてないと思い込んでいる。「解けた」かどうかの判断基準が誤っている。

なにをするか：

- 既に分かっていことの細部を詰める。その作業で見落としや勘違いに気付くことがある。
- 実験環境を作ったり、実験をしてみる。やってみないと分からないこと／気付かないことがある。
- 基本に戻る。根拠となる理論や手法をもう一度確認する。
- 関係ないことをする。気分転換も必要。

*1305936203*[プログラム意味論][圏一般論]スパンとオートマトン

[http://d.hatena.ne.jp/m-hiyama/20110520/1305871425:title]の話は当座の応用があって、オートマトン（有限とは限らない）の圏をベースにしてSpan(C)を作ると面白い。

スパンの左右の足を射影と考えると、ボディのオートマトンの2つの影を見ているように思える。逆に、ボディは両足のオートマトンから合成されているとも見られる。いずれにしても、足の部分では並列処理が行われる。

スパンの足に適当な条件を付ければ、スパンは模倣だと思える。A→B という模倣可能性（BはAを模倣できる）が、AとBの並列処理で合成オートマトンを作れるかどうか？ という問題とみなせる。

「スパンの足に適当な条件を付ける」ってのが、どうもベクトル空間やヒルベルト空間の圏にも適用できて、線形アイソメトリーによるシステムの記述になっている気がする。

オートマトンもヒルベルト空間も、コンパクト閉圏（の類似物）であることが背景か？

*1305941862*[Caty][型検査]考えなおそう

カインドを肥大させないように禁欲的に考えてたが、どうもこれがよくないかも。ブール半環の構造を持たせてもいいかもしれない。

カインドKに対して、最大値 max(K) の存在を要請するのは無理がある。極大元の集合をtops(K)として、tops(K)が有限集合ならいいことにしよう。これは、カインドをブール半環にすることと矛盾しない。

静的型解析と実行時チェックはかなり違う。カインドKの情報で、実行時に使えるのは型 sup(K) だけ。max(K)が存在しなくてもsup(K)は常に存在するし、tops(K)が有限だから計算可能だ。&lt;em&gt;max(K)の存在にこだわるのが間違い&lt;/em&gt;だったようだ。

実行時に何が必要か？ と冷静に考える必要があるな。型情報のほとんどは実行時には意味が無い、高階の情報があっても使いがようがない。実行時には、型概念のレベルにおいて、レベル0の判断しかできないので、レベル1（型）、レベル2（カインド）の情報が役に立たない。

それと、「総称は具体化しなくてはならない」という原則（ドグマ）も疑ったほうがいいかも。具体化は手段だから、もし具体化せずにうまくいくなら無理に具体化する必要はない。絶対に具体化が必要なところがあるかどうか？ 具体化しても、実行時情報としては無意味だとしたら？

もうひとつのドグマは、「いわゆる型推論」で、推論していいことあるのか？ と考える必要がある。推論することが目的ではない。&lt;em&gt;実行時の安全性を保証することが目的&lt;/em&gt;で、確定した型宣言を求めることが目的ではない。「実行時安全性を保証する」ことと「静的に型宣言を確定する」ことがほんとに因果関係を持つのか？ 持つと信じてきたが、具体的な因果の糸をたどってない。

インスタンスとカインドのあいだには1レベル分のギャップがある。我々の型制約（type constraints）は等式的ではない。ギャプがなく等式的な状況における議論をそのまま適用するのは的外れの可能性がある。

*1305963205*[Caty][型検査]考えなおした結果

型解析系がやること：

+ プロファイルのないスクリプトを解析して、プロファイル（宣言）を作る。
+ 人間がプロファイルを書いているとき、そのプロファイルが正しいかどうかをチェック。
+ 実行時の安全性を保証する。

1,2番はそれほど重要じゃなくて、重要なのは3番目。

次のように記号を約束する。

+ E, F はスクリプト式
+ x, y などは型変数
+ S, T などは型変数を含むかもしれない型項
+ A, B などは閉じた（型変数を含まない）型項

式Eが与えられれば、パイプの位置をチェックして番号をつけることができる。nをパイプ番号とする。

式Eが整合的である条件をConsis(E)とすると、Consis(E)は次の形の制約（不等式）の集まりとなる。

- [n] S⊆T

これがパイプの数（入り口、出口を含めるかもしれない）だけの連立となる。

Cosis(E)の制約（連立不等式）を、型項の単一化で解くと、次の形のパス付き制約が出てくる。

+ [n] p : x⊆y
+ [n] p : x⊆B
+ [n] p : A⊆y

nはパイプ番号、pはパス。xのカインドをK、yのカインドをLとすると、これらの制約は次の実行時チェック条件になる。

+ [n] p : sup(K)∧sup(L)
+ [n] p : sup(K)∧B
+ [n] p : A∧sup(L)

これで「実行時の安全性は保証」できているハズ。総称プロファイルを持つコマンドの解釈を厳密化して、安全であることを証明すればいい。それが出来るなら、他の問題は気にするほどのことではないだろう。

</body>
</day>
<day date="2011-05-23" title="">
<body>
*1306109304*[メモ][雑感]続・行き詰まったときには

せっかくアルゴリズムが出来たのに、どう使うかがハッキリしない。&lt;em&gt;モヤモヤ&lt;/em&gt;している。

モヤモヤの原因は、混同・混乱、誤解・思い込み（間違ったこだわり）、曖昧さなどだ。一歩下がって見直さないとならない。

言葉の使い方も気を付けないと、混同や曖昧さを助長することになる。例えば、「代入」（substitution）って言葉、これは名詞と動詞を同じ言葉で表す、代入する行為、代入オペレータ、代入オペレータを表現するデータ、みんな「代入」だ。そそもそ、代入の意味が「変数を項で置き換える構文的操作」「変数を値で置き換え（さらに計算する）意味論的操作」のどちらかも曖昧。

「代入」「束縛」「環境」なども同義で使うか、別な意味か？ 微妙な違いが本質的な違いだったりしないか、十分注意する必要がある。

*1306109387*[Caty][型検査][用語法]型関係の用語の(再)定義

新しい用語を導入しないと辛い。

- 型項 -- 型の構文的な表現、概念的には無限かもしれないGornツリー。
- 型制約 -- 型の等号、不等号、論理AND、論理OR、全称を含む論理式（formula）
- 連言的型制約 -- 論理ORを含まない型制約
- 原子型制約 -- 等号または不等号をひとつだけ含む論理式
- 非対称単一化 -- 等号ではなくて不等号（⊆）に関する単一化
- 最汎事前制約 -- 非対称単一化の結果、most generic preconstraints
- 型具体化 -- 型変数と型定数の対応、またはそれによる型代入行為
- 型項のp成分 -- pをパスとして、型項をGornツリーと見てのp-サブツリーで与えられる型。T[p] と書く。

</body>
</day>
<day date="2011-05-24" title="">
<body>
*1306220035*[Caty][型検査][用語法]Caty用語の整理

従来からのCaty用語も整理。

TYPEを型（の意味）全体の集合、Mを計算モデル圏とする。

- コマンド -- プロファイルと実行ボディの組。名前を持つか持たないかは理論上は重要ではない。
- プロファイル -- 同一の型変数スコープ内に置かれた2つの型項のタプル
- ネイティブコマンド -- 実行ボディがネイティブ言語で書かれたコマンド
- スクリプト -- CatyScript言語の式
- スクリプトコマンド -- 実行ボディがスクリプトであるコマンド
- 総称型 -- 型パラメータを持つ型。nパラメータの総称型の意味は、TYPE&lt;sup&gt;n&lt;/sup&gt;⊃→|M| という写像。
- 総称プロファイル -- 型パラメータを持つプロファイル。nパラメータの総称プロファイルの意味は、TYPE&lt;sup&gt;n&lt;/sup&gt;⊃→|M|×|M| という写像。
- 総称コマンド -- 型パラメータを持つコマンド。nパラメータの総称コマンドの意味は、TYPE&lt;sup&gt;n&lt;/sup&gt;⊃→M という写像。
- 総称スクリプト -- 型パラメータを持つスクリプト。式内に総称コマンドを含む。プロファイルが指定されないと意味が定義できない。
- 型制約 -- TYPE&lt;sup&gt;n&lt;/sup&gt;の部分集合を定義する論理式
- カインド制約 -- 型制約の一種で、ある構文的制限を持った論理式で定義される1パラメータの型述語
- カインド -- カインド制約、またはカインド制約が定義するTYPEの部分集合
- （Catyの）型具体化 -- 総称型、総称プロファイル、総称コマンド、総称スクリプトの型パラメータへの具体型の割り当て
- 総称整合性条件 -- 総称型、総称プロファイル、総称コマンド、総称スクリプトの型パラメータ領域TYPE&lt;sup&gt;n&lt;/sup&gt;に関する条件で、n型パラメータの型関数（広義）の定義域を特徴付ける型制約。
- 整合的な型具体化 -- 総称型、総称プロファイル、総称コマンド、総称スクリプトの型具体化で、総称整合性条件を満たすもの。

&lt;em&gt;ついでに&lt;/em&gt;(?)、総称コマンドの例

+ pass&amp;lt;X&gt; :: X-&gt; X
+ pr-1&amp;lt;X, Y&gt; :: [X, Y] -&gt; X
+ pr-2&amp;lt;X, Y&gt; :: [X, Y] -&gt; Y
+ in-1&amp;lt;X, Y&gt; :: X -&gt; (@1 X | @2 Y)
+ in-2&amp;lt;X, Y&gt; :: Y -&gt; (@1 X | @2 Y)
+ diag&amp;lt;X&gt; :: X -&gt; [X, X]
+ cons&amp;lt;X&gt; :: [list&amp;lt;X&gt;, X] -&gt; list&amp;lt;X&gt;
+ car&amp;lt;X&gt; :: list&amp;lt;X&gt; -&gt; X throws EmptyList
+ cdr&amp;lt;X&gt; :: list&amp;lt;X&gt; -&gt; list&amp;lt;X&gt; throws EmptyList

2型パラメータ、1型パラメータのpassは次のように定義される。

- pass/&amp;lt;2&gt; = Λ&amp;lt;X, Y: X⊆Y&gt;(X-&gt;Y).λx:X.x
- pass/&amp;lt;1&gt; = Λ&amp;lt;X&gt;(X-&gt;X).λx:X.x



</body>
</day>
<day date="2011-05-25" title="">
<body>
*1306313729*[Caty][型検査][用語法]さらに用語の整理

言葉と記号法の問題が色々とある。

&lt;strong&gt;型代入&lt;/strong&gt;（type substitution, 行為とオペレータの意味がある）は構文的操作、&lt;strong&gt;型環境&lt;/strong&gt;は意味論的な概念としよう。そう定義する。型環境は型評価に使う。&lt;strong&gt;型評価&lt;/strong&gt;は型計算と言ってもいいが、型項を具体化して結果として具体型を求めること。

型項と名前を関係付けることは&lt;strong&gt;割り当て&lt;/strong&gt;（assignment）、&lt;strong&gt;型のlet束縛&lt;/strong&gt;といってもいい。代入（置換）とは違う。が、代入（置換）、割り当て、束縛はテキトーに使っているな、僕も皆んなも。区別しがたいこともあるし。

型具体化って言葉もあいまいで、具体型による型代入なのか、型環境における型評価かわからない。同値なら同値という証明が必要だ。

「いわゆる型推論」、あるいは僕が「型推論」から連想するような行為は実は不要だったような気がする -- これは前例や既存の知識にこだわり過ぎだった。従来の型推論とかはスッパリ忘れて、非対称単一化の結果を中心にすべきかも。

それと、記号法も不十分； ラムダ式で言えば λ(x∈A, y∈B).E のような形を考えているのだが、これはどうもダメで、λ(x, y:C).E のような形だろう。ここで、Cはx, yを含む（かも知れない）論理式。

「・」をアプライ演算子として、(λ(x, y:C).E)・(a, b) が許されるのは、|- C(a, b) のときに限るとする。こうすると、λ(x∈A, y∈B).E は、λ(x, y : x∈A ∧ y∈B).E の略記となる。|= (a∈A ∧ b∈B) のときに、(a, b)による代入（具体化）ができる。

型ラムダ式にも同じ記法を採用すると、λ&lt;x, y:C&gt;.E となる。Eにプロファイルαを添えると、λ&lt;x, y:C&gt;α.E と書けばいいかな。(λ&lt;x, y:C&gt;α.E)・&lt;a, b&gt; ==&gt; α[a/x, b/y].E[a/x, b/y] という代入による具体化（&lt;strong&gt;型ベータ変換&lt;/strong&gt;）ができる。このベータ変換のとき、|- C(a, b) の&lt;strong&gt;証明&lt;/strong&gt;が必要となる。

</body>
</day>
<day date="2011-05-27" title="">
<body>
*1306457119*[Caty][型検査][プログラム意味論][その他代数]型の代数の公理化

コゥゼンのtermset algebraの公理を参考にして、型の代数を公理化しないとダメだと思うな。今のように実例ドリブンでは計算の根拠がハッキリしない。


</body>
</day>
<day date="2011-05-30" title="">
<body>
*1306711194*[Caty][型検査][論理][用語法]型理論と論理との対応

Catyの型システムだと、1階述語論理と完全な対応が付く。

|* 論理  |* 英語    |*  型 |
| 変数   | variable | 型変数 |
| 定数   | constant symbol| 具体型|
| 関数   | function symbol| 総称型|
| 述語   | predicate symbol| カインド|
| 結合子 | logical connective|結合子 |
| 限量子 | quantifier | 限量子  |
| 原子論理式| atomic formula| - |
| 論理式 | formula | 型制約 |


</body>
</day>
<day date="2011-06-03" title="">
<body>
*1307080710*[リンク][圏一般論]圏の分類空間

- Title: CLASSIFYING SPACES FOR MONOIDAL CATEGORIES THROUGH GEOMETRIC NERVES
- Authors: M. BULLEJOS AND A.M. CEGARRA
- URL: http://www.ugr.es/~acegarra/Paperspdfs/CSMCTGN.pdf
- Pages: 11

- Title: CLASSIFYING SPACES OF MONOIDS - APPLICATIONS IN GEOMETRIC COMBINATORICS
- Authors: Maja D. Rabrenovic
- URL: http://www.emis.de/journals/PIMB/091/n091p021.pdf
- Pages: 7

- Title: THE CLASSIFYING TOPOS OF A TOPOLOGICAL BICATEGORY
- Authors: IGOR BAKOVIC and BRANISLAV JURCO
- URL: http://www.intlpress.com/HHA/v12/n1/a14/v12n1a14.pdf
- Pages: 22

それと、doi=10.1.1.24.2898 の論文（15ページ）

*1307084711*[用語法][高次圏論][気付いた]書き換え（rewrite）って言葉を使えばいいのか

英語が substitute, assign, permutate, replace で日本語が「代入」、「置換」； ウエーー！ 困った。と思っていたが、replaceはやめて、rewriteって言葉を使えばいいか。項書換え系って言葉もあるし。

とりあえず：

- グラフ書き換え：グラフの一部を別なグラフで入れ換える。
- チャンバー：グラフ書き換えで入れ換える部分。
- チャンバー境界：そのまんま。
- 書き換えルール：そのまんま。
- 書き換えルールセット：そのまんま。
- ルールの発火：与えられたチャンバーにマッチするルールを検索して適用すること

ボックス＆ワイヤーのグラフを射とみると、グラフ書き換えは2セルになる。チャンバー境界の仕様は要するにプロファイルだ。書き換えルールのインスタンスが2セルの生成元となる。

変数シンボルって概念は、書き換えポイントを指定する仮想チャンバーってことだろう。

</body>
</day>
<day date="2011-06-08" title="">
<body>
*1307542383*[Caty][形式言語理論][お絵描き][型検査]後で書く：モノドロミーグラフとか

&lt;del datetime=&quot;2011-06-09T10:16:38+09:00&quot;&gt;絵だけ。説明は後で書く。&lt;/del&gt;

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110610/1307688106&quot;&gt;別な場所&lt;/a&gt;に引越した。

</body>
</day>
<day date="2011-06-10" title="">
<body>
*1307678301*[Caty][形式言語理論][お絵描き][型検査]ツリーの参照グラフと、変換コピー接ぎ木の手順

ツリーをいちいちリアルに描くとめんどくさいから、&lt;em&gt;三角形で略記&lt;/em&gt;。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/treefig-1.gif&quot; &gt;

◎の「ツリー全体を表すノード」は、DOMの文書ノード（ルート要素ノードとは別）のようなもの。ルートノードとは別にあったほうが便利。参照ノードはリーフの位置にあるが、意味的には他の場所まで伸びる辺（グラフのedge）。参照先（ターゲット）は、ツリーの番号とか名前で示す。メモリ内ならほんとの参照（メモリアドレス）でもいい。

1つ以上のツリーがあると、それらのあいだの参照関係は有向グラフになる。

&lt;img src=&quot;http://www.chimaira.org/img2/treefig-2.gif&quot; &gt;

上のほうは割とリアル（つっても三角形で略記）に描いたヤツ。1つのツリーを◎で表現してしまい、参照を辺として描くと、サイクルや多重辺を持つ有向グラフとなる。参照辺には、パラメータリストが&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110603/1307062942&quot;&gt;記号的代入として&lt;/a&gt;付着しているが、それは絵に描いてない（でも使う！）。

さー、次は色付きで説明。

&lt;img src=&quot;http://www.chimaira.org/img2/treefig-3.gif&quot; &gt;

2つのツリーが相互参照している状況。1番のツリーに注目して、自分（1番）から参照されているツリーたちをコピーして接ぎ木する。コピーとは言っても、完全に同じならコピーする必要はない。パラメータリストが代入を定義し、代入は一種のツリー変換となる。このツリー変換で変更を受ける場合に、&lt;em&gt;もととちょっと違ったツリー&lt;/em&gt;をコピーする。単なるクローンじゃなくて、変換を施したコピー。

2番の変換コピーが2'、それを1に接ぎ木する。2'から1への参照は残るから、1の変換コピー1'を作って接ぎ木。1'から2'への参照をさらに&lt;strong&gt;変換コピー接ぎ木&lt;/strong&gt;をする、と続く。その状況と手順を簡略に示したのが&lt;em&gt;上の図の下側&lt;/em&gt;の螺旋階段風の絵。

下の写真はほんとの螺旋階段。

&lt;img src=&quot;http://www.chimaira.org/img2/rasen.jpg&quot; &gt;

ほんとの螺旋階段&lt;em&gt;じゃない&lt;/em&gt;絵で、赤と青の矢印は変換コピー操作、黒の矢印は接ぎ木操作を表す。例えば、1→2' の矢印は、ツリー1の下にツリー2'を接ぎ木することを意味する。

変換コピーがどんどん出来ると、螺旋階段は無限に上に昇ることになる。これは、接ぎ木も無限に行うことを意味して、永久に終わらない。それじゃ困る。そこで、いずれは新しい変換コピーが不要となる状況を考える。言い換えると、変換コピーをどんどん作ると、オリジナルと同じものができるような場合； オリジナルと同じならコピーする必要はないので、コピーの無限連鎖は避けられる。

変換コピー（赤）と接ぎ木（黒）が有限回で終わる例：

&lt;img  width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/schema-monodromy-2.gif&quot; &gt;

この絵のような話を整理するために、僕はモノドロミー（monodromy）という言葉を使ったのだった。モノドロミーの説明は別エントリーで中途半端になっているから、後で書き足す。&lt;b&gt;[追記]&lt;/b&gt;&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110610/1307688106&quot;&gt;書いたよ&lt;/a&gt;&lt;b&gt;[/追記]&lt;/b&gt;

*1307688106*[Caty][形式言語理論][お絵描き][型検査]モノドロミーグラフとか

えーと、最初に言っておくが； 複素解析ともリーマン面とも微分方程式とも特異点とも接続とも曲率とも、&lt;em&gt;何の関係もない&lt;/em&gt;。被覆とは少し似ているし、（正錐により順序が付いた可換群としての）整係数ホモロジー群ともなんとなく関係ありそう。&lt;em&gt;だが、&lt;/em&gt;、再帰的定義と引数渡しとオートマトンの問題。実装予定あり。

螺旋階段の話に近いかな。螺旋階段の写真は&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110610/1307678301&quot;&gt;先のエントリー&lt;/a&gt;で出したからもういいや。本編の関連エントリーは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070313/1173755754&quot;&gt;コレ&lt;/a&gt;とか&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20080206/1202270985&quot;&gt;コレ&lt;/a&gt;とか。

&lt;hr&gt;
有向グラフGがあって、Gから圏Vへのグラフ準同型（関手から圏演算に関する事を除いた対応）Fがあるとする。Gから作られた自由圏（道の圏）を D = Path(G) とすると、Fは自然に圏Dから圏Vへの関手に拡張できる。よって、Fは関手と考えても別に差し支えない。

tがグラフGの頂点、Cはtを通るGの素サイクルだとする。Cに含まれる辺を c&lt;sub&gt;1&lt;/sub&gt;, c&lt;sub&gt;2&lt;/sub&gt;, ..., c&lt;sub&gt;n&lt;/sub&gt; とする。ただし、c&lt;sub&gt;1&lt;/sub&gt;の始点はt、c&lt;sub&gt;n&lt;/sub&gt;の終点もt。F(C) を、F(c&lt;sub&gt;1&lt;/sub&gt;);F(c&lt;sub&gt;2&lt;/sub&gt;); ...;F(c&lt;sub&gt;n&lt;/sub&gt;) in V の意味だとする。Cはサイクルだから、F(C):F(t)→F(t) in V、つまり、F(C)は End(F(t)) in V に入る。

書くのが楽になるように、m = F(C)、M = End(F(t)) と置く。Mはモノイドで、m∈M となる。Fの存在を前提にすれば、mはCから決まる。mをサイクルCの（Fに関する）&lt;strong&gt;モノドロミー元&lt;/strong&gt;とか&lt;strong&gt;モノドロミー射&lt;/strong&gt;と呼ぶことにする。mはモノイドM（＝End(F(t)) in V）の元（要素）だし、圏Vの射になっている。

モノドロミー（monodromy）の語源は、&lt;em&gt;run round&lt;/em&gt; なので、グルッと一周したときの量に形容詞として「モノドロミー」を付けるのは許されるでしょ。似た(?)用語でホロノミー（holonomy）もあるけど、モノドロミーが先に思いついたのでモノドロミーを使う。

まーともかく、グラフGのノードtと、tを基点と考えたサイクルCからモノドロミー元mが決まる。モノイドMにおけるmのベキ（累乗）を普通のとおり、m&lt;sup&gt;0&lt;/sup&gt;, m&lt;sup&gt;1&lt;/sup&gt;, m&lt;sup&gt;2&lt;/sup&gt; のように書く。集合 {m&lt;sup&gt;k&lt;/sup&gt; | k = 0, 1, 2, ...} を、tとCから決まる&lt;strong&gt;モノドロミーモノイド&lt;/strong&gt;と呼ぶことにする。モノドロミーモノイドは、モノイドM（= F(C) in V）の部分モノイドで、モノドロミー元mから単元生成されたモノイドとなる。

モノドロミーモノイドが無限集合になると、無限の螺旋階段になるので困る。有限の場合を扱う。モノドロミーモノイドが有限とは、生成元であるモノドロミー元mに、m&lt;sup&gt;n+1&lt;/sup&gt; = m&lt;sup&gt;p&lt;/sup&gt;（0≦p≦n）という関係が成立すること。

有限なモノドロミーモノイドの例をいくつか示す。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/schema-monodromy-1.gif&quot; &gt;

この絵は、モノドロミーモノイドのケイリーグラフとなっている。ケイリーグラフ（Cayley graph）は群と生成団に対して定義されるが、モノイドと生成団に対しても同様に定義できる。モノドロミーモノイドのケイリーグラフだから、&lt;strong&gt;モノドロミーグラフ&lt;/strong&gt;としよう。

- http://en.wikipedia.org/wiki/Cayley_graph

モノドロミーモノイドが有限なら、基点tとサイクルCから作られる螺旋階段は無限には昇らずに適当な所で循環する。循環の様子は、モノドロミーモノイドの循環と同様となり、それは、モノドロミー元mのベキ（累乗）の性質から決まる。絵に描くと次のよう。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/schema-monodromy-2.gif&quot; &gt;

上の絵のような有限循環する螺旋階段で記述される参照グラフや接ぎ木手順は次のようだ。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/schema-monodromy-3.gif&quot; &gt;

参照グラフと接ぎ木に関しては&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110610/1307678301&quot;&gt;先のエントリー&lt;/a&gt;で述べた。


</body>
</day>
<day date="2011-06-16" title="">
<body>
*1308187709*[Caty][形式言語理論][型検査]オートマトングラフの比較アルゴリズム

似たことは何度も書いているような気がするが、&lt;em&gt;2011年春夏シーズン向け&lt;/em&gt;のアルゴリズム（新作じゃないけど）。

&lt;h5&gt;準備&lt;/h5&gt;

いろいろと記号の約束をする。

- G, Hなどは有向グラフ
- 圏論の記法を借りて、グラフの頂点集合を|G|、辺集合を&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110204/1296794257&quot;&gt;記号の乱用&lt;/a&gt;でGとも書く。
- 辺eに対して src(e)（ソース＝根本）、trg(e)（ターゲット＝行き先）は、圏のdom, codに相当。
- 有向グラフには基点が指定されている。g∈|G|, h∈|H| のように、グラフを表す文字を小文字にして表す（と約束）。
- 有向グラフには頂点ラベル、辺ラベルが付いている、それを、関数 V:|G|→Σ、E:G→Γ で表す。頂点ラベル（&lt;em&gt;色、ノード値とか、呼び名はいろいろ&lt;/em&gt;）の集合Σは順序集合、辺ラベルの集合Γ（ガンマ）はなんでもよい。ΣとΓは前もって固定されているとする。記号の乱用で、すべてのグラフに対して同じ記号V, Eを使い回す。
- グラフは&lt;em&gt;決定性の&lt;/em&gt;オートマトンを表すので、頂点から出る辺にはすべて異なるラベルが付いている。選択（choice, union）ノードは、辺ラベルというよりは、候補の頂点を調べて遷移を決定するんだが、辺ラベルだと考えてもまーいいだろう。
- 「パラメータ、変数、プレースホルダー、穴（hole）」などと呼ばれる頂点がある。ここでは、グラフGの変数（頂点の一種だよ）の全体をVar(G)と書く。Var(G)が空でもよい。x∈Var(G)ならば、out(x) = 0。outは頂点の出次数（out degree）。

我々が扱う決定性オートマトンを表現するグラフGは：

+ 基点gを持つ。（起点は開始状態）
+ 頂点にラベル（値、属性）が付いている。V:|G|→Σ
+ 辺にラベルが付いている。E:G→Γ
+ 頂点ラベルの集合Σには順序（記号は≦を使う）が入っている。全順序とは限らない。
+ 辺ラベルは決定性である。
+ 変数と呼ばれる頂点がある（かもしれない）。変数頂点は、頂点ラベルによって識別されてもいいし、その他の方法で識別されてもよい。

x∈|G| に対して、頂点xの近傍（正確には、距離1のout近傍だけど）N(x) を次のように定義する。

- N(x) = {y∈|G| | xからyに向かう辺がある}

ほんとは、N&lt;sub&gt;G&lt;/sub&gt;(x) とか書くべきだろうが、またしても記号の乱用。

&lt;h5&gt;アルゴリズム&lt;/h5&gt;

GとHを与えられた2つのグラフとして、比較の作業は&lt;strong&gt;トライアル&lt;/strong&gt;の繰り返しとなる。トライアルが進むと、Next, Done, Resultという集合が更新される。トライアルが失敗すると全体も失敗し、トライアルが成功すると次のトライアルに進む。次にすべきことがなくなると（Nextが空集合）全体が成功。

- Next⊆(|G|×|H|) 次に調べるべき頂点ペアの集合
- Done⊆(|G|×|H|) 既に調べ終わった頂点ペアの集合
- Result⊆(|G|×|H|) 最汎事前制約。単なる頂点ペアではなくて、どっちかは変数。もう少し正確に書くと、Result⊆(Var(G)×|H| ∪ |G|×Var(H) ∪ Var(G)×Var(H)) ←たいして正確じゃねーな、コレ。

&lt;h6&gt;トライアルの手順&lt;/h6&gt;

+ Nextが空なら全体が終了。そのときのResultが全体の結果。
+ Nextが空でないなら、そこから任意の元（頂点のペア） (x, y) を取り出す。
+ (x, y)に関して頂点の比較（後述）をする。
+ 頂点の比較が失敗すればトライアルは失敗。
+ 頂点の比較が成功すれば、次に辺の比較（後述）を行う。
+ 辺の比較が失敗すればトライアルは失敗。
+ 辺の比較が成功すれば、N(x)とN(y)からペアを作って、N(x, y)を構成する（後述）
+ Nextから (x, y) を取り除きDoneに加える。
+ N(x, y)＼Done をNextに加える。（「＼」は集合の差を表す）

Next, Doneの動きは：

- 失敗の時は何もしない（どうせ全体が失敗する）。
- 成功なら、Next := Next＼{(x, y)}; Done := Done∪{(x, y)}; Next := Next∪(N(x, y)＼Done)

Resultの作り方は後述。

&lt;h6&gt;頂点の比較&lt;/h6&gt;

頂点ペア(x, y)に対して、

+ xが変数のとき（つまり、x∈Var(G)）、(x, y) をResultに入れて成功。Result := Result∪{(x, y)}
+ yが変数のとき（つまり、y∈Var(H)）、(x, y) をResultに入れて成功。Result := Result∪{(x, y)}
+ xもyも変数ではないとき、V(x)≦V(y) なら成功、そうでないなら失敗。

&lt;h6&gt;辺の比較&lt;/h6&gt;

辺の比較も、頂点ペア(x, y)に対して行う。x∈|G|から出る辺を e1, e2, ..., eN とする（Nは頂点xの出次数）。&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;ウギャ、Nが近傍の記号とかぶった。ここでは非負整数。&lt;/em&gt; &lt;b&gt;[/追記]&lt;/b&gt;

+ N = 0 のときは、成功。
+ E(e1) = a1 として、yから出るHの辺でa1をラベルとする辺を探す。なければ失敗。
+ yから出る辺でa1をラベルとする辺（決定性から一意に決まる）があったら、それをf1として、ペア (trg(e1), trg(f1)) を作っておく。
+ e2, ..., eN まで同じことを繰り返す。

以上の過程で出来た集合 {(trg(e1), trg(f1)), (trg(e2), trg(f2)), ..., (trg(eN), trg(fN))} を N(x, y) とする。N(x, y) は、次のトライアルのNextを決めるために使う。

Next := Next＼{(x, y)}; Done := Done∪{(x, y)}; Next := Next∪(N(x, y)＼Done) なので、Next∪N(x, y) 作ってから、{(x, y)}∪Done を取り除いても同じ。

&lt;b&gt;[追記]&lt;/b&gt;なるほど、引数なしのN（非負整数）と1 or 2引数のN（近傍 or 近傍の対応）は、アリティでオーバーロードされていて、まったく別な意味で使っているわけね。アドホックつうか&lt;em&gt;無関係なオーバーロード&lt;/em&gt;だ。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h6&gt;全体のセットアップ&lt;/h6&gt;

初期状態は：

- Next := {(g, h)} （基点の対）
- Done := {} （空集合）
- Result := {} （空集合）

Doneはトライアルが成功するたびに1個ずつ要素が増える。Nextは増えたり減ったりしながら最終的には空になる（成功の時）。Resultは単調に増えるが、空のままかもしれない。

成功すればResultが得られる。失敗のときは、どこ（どの頂点対）で何が原因で失敗したかを報告する。

*1308212517*[Caty][形式言語理論][型検査]有向グラフの深さ優先再帰的トラバース

有向グラフGのchildren関数 |G|→Pow(|G|) を、children(x) = {y∈|G| | xからyに向かう辺がある} で定義する。すべてのchildren(x)が全順序集合になっているようなグラフを考える。局所順序グラフと呼びたいが、誤解されそうだから、semifatグラフと呼ぶ。無向グラフに対してfatという概念があり、それに似ているからsemifat。

基点付きのsemifatグラフに関して、ツリーの深さ優先再帰的トラバースと似た方法で頂点をたどれる。ツリーのパスに相当する [x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;] という頂点のリストに関して、&lt;strong&gt;次の頂点&lt;/strong&gt;を計算する。ただし、x&lt;sub&gt;0&lt;/sub&gt;は常に基点（ルートや開始状態）だとする。

次のような約束／記号／概念を使う。

- children(x)はリストだとする。children(x)が空リストのときもある。リストの順番がsemifat構造を定義する。
- Aが頂点のリスト、Xが頂点の集合のとき、A＼X は「AにXの要素が出現すれば、それを取り除いたリスト」の意味。
- x∈children(p) のとき、younger(p, x)は、children(p)のなかでxより若い（順序でより後）の頂点からなるリスト。xが親pの最後の子（末子）のとき younger(p, x)は空リスト。

既にたどった（訪れた）頂点の集合をVisited、[x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;1&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;] というリストをパスリストと呼ぶことにする。Visitedの初期値は空集合、パスリストの初期値は [基点] 。

手順：

+ パスリストが空のときは、次の頂点は定義されない。終了。
+ 空でないパスリストの最後の頂点x&lt;sub&gt;n&lt;/sub&gt;をxとする。
+ children(x)＼Visited が空リストでないなら、その最初の頂点が次の頂点。Visitedに現在の頂点を入れ、パスリストに次の頂点をpushして、現在の頂点 := 次の頂点 と更新する。
+ children(x)＼Visited が空リストで、パスリストにx以外の頂点がないなら次の頂点は定義されない。終了。
+ x&lt;sub&gt;n-1&lt;/sub&gt;があればそれを pとする。
+ children(x)＼Visited が空リストで、younger(p, x)＼Visited が空でないなら、その最初の頂点が次の頂点。Visitedに現在の頂点を入れ、パスリストのpop後に次の頂点をpushして、現在の頂点 := 次の頂点 と更新する。
+ children(x)＼Visited も younger(p, x)＼Visited も空のときは、パスリストをpopして、最初（手順1）からやり直す。



</body>
</day>
<day date="2011-06-23" title="">
<body>
*1308805212*[Caty][型検査]スキーマ属性

&lt;b&gt;[追記]&lt;/b&gt; ンギャ、http://d.hatena.ne.jp/m-hiyama-memo/20110509/1304896664 にも書いていた。アッチのほうが詳しいわ。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h5&gt;JSONスキーマのスキーマ属性&lt;/h5&gt;

|* スキーマ属性名 |* 適用対象となる型 |* 意味 |* 値の型 |* Catyのサポート状況 |
| minimum         | number      |最小値	      | number  | ○ |
| maximum         | number      |最大値       | number  | ○ |
| minimumCanEqual | number      |最小値はイコールを許す| boolean |サポート予定 |
| maximumCanEqual | number      |最大値はイコールを許す| boolean |サポート予定 |
| maxDecimal      | number      |小数点以下の桁数|integer | 未定 |
| divisibleBy     | number      |特定の数で割り切れる|number | サポート予定 |
| minLength       | string      |文字列の最小長| integer | ○ |
| maxLength       | string      |文字列の最大長| integer | ○ |
| format          | string, number|文字列と数値のフォーマット|string| △ |
| pattern         | string      |正規表現パターン | string  | サポートしない |
| minItems        | array       |配列の最小長| integer | ○ |
| maxItems        | array       |配列の最大長| integer | ○ |
| uniqueItems     | array       |配列項目が全部異なる| boolean | 未定 |

- formatは、formatプラグインで対応しているが、プラグインが揃っていない。

&lt;h5&gt;Catyスキーマ独自のスキーマ属性&lt;/h5&gt;

|* スキーマ属性名 |* 適用対象となる型 |* 意味 |* 値の型 |* Catyのサポート状況 |
| minProperties   | object            | プロパティの最小個数 |integer | ○ |
| maxProperties   | object            | プロパティの最大個数 |integer | ○ |
| tight           | array             | タイト配列に限るか   |boolean | ○ |
| propNameFormat  | object            | プロパティ名のフォーマット指定 |string|△ |

- propNameFormatは、formatプラグインで対応しているが、プラグインが揃っていない。

*1308807276*[Caty][メモ][Caty更新]Catyの変更や拡張

http://d.hatena.ne.jp/m-hiyama-memo/20110506/1304662541 以降、今まで。

+ when-otherwiseのワイルドカード
+ PATH_INFO環境変数
+ 環境変数が直接参照可能に。
+ app.logとloggingモジュールを追加。
+ osモジュール os:exec-scriptコマンドを追加。
+ rc-once/*.caty による一回実行起動時スクリプト
+ 複数候補から選択した値の解決 json:fix-on-selectionコマンド、$selection, $embed。
+ モジュール循環依存性の検出
+ 型コンパイル方式を少しずつ改善
+ make-exception, throw-if-can。throw-if-canは今バグっている。
+ pathモジュール
+ when, eachにオプションが（構文上は）可能となる。
+ gen-dataの改善、@[typical]アノテーション
+ デーモンモードでのシグナル（SIGTERM, SIGHUPなど）に対応
+ SIGHUPではリスタートする。
+ PIDファイルをちゃんと消す。
+ システム情報の公開性を少し高めた。
+ 疑似タグのプロパティ名に文字列が使える。
+ 疑似タグでundefinedが使える。

予定：

- 型の包含性判定
- データセットのサポート

http://d.hatena.ne.jp/m-hiyama-memo/20110506/1304662541 再掲。

+ 変数生成 '&gt;'
+ 変数参照 '%'
+ パイプラインの一時的終了 ';'
+ eachによる変数スコープ（つうかエクステント）
+ casmでスクリプトコマンド定義
+ kindのナンチャッテ第一段階。
+ バッグ型
+ actions/*.cara
+ 新しいスキーマ属性 maxProperties, minProperties, propNameFormat, tight。（remarkは以前から。）
+ XJSONパス、XJSON get/put、パートはまだだが。
+ ignore-tag-onceルール、pv, item, nth とXJSONパス
+ 疑似タグ構文 '@?' '(' (name|string) ':' スカラーリテラル ')'
+ 任意のタグ '@*'
+ 任意の明示的タグ '@*!'
+ 型名タグ '@&amp;' 
+ undefined型と#'undefined
+ @[register-public]
+ CatyBNFのナンチャッテ実装： ::=, :=, = が使える。
+ /*{{{, }}}*/ コメント
+ debug特殊コマンド
+ --no-ambient, --no-appオプション
+ select-action, select-script, trace-dispatchコマンド
+ スキーマ記述用のPythonファイルの分離
+ *.caraにfiletypeを書ける
+ 例外型の定義（exception宣言）
+ deferred型
+ お尻スラッシュ問題に対して、マニフェストに &quot;missingSlash&quot; 追加。
+ _global.xjsonに &quot;addrsAllowed&quot;, &quot;addrsDenied&quot;
+ スタックトレースのWebへの出力
+ throws only
+ 総称コマンドの実行時具体化
+ 国際化フレームワーク
+ フィルターのコマンド化
+ deprecatedアノテーションの処理
+ defaultアノテーションの処理
+ moduleにdocコメント
+ 配列型の項目名
+ HTTPメソッドトンネリング
+ CatyFITのjudge欄
+ ハッシュ記法
+ timeメタコマンド
+ CatyFITにignore-spaceオプション

予定：

+ __integerスキーマ属性
+ whenにotherwiseワイルドカード
+ 複数プロファイル
+ オブジェクトのeach
+ ユニオン型のワイルドカード
+ importと名前の本籍追跡
+ tag-onlyデータ
+ コマンドオーバーロード（優先度低し）
+ テンプレートの elseif

中途半端または未着手：

+ profileスキーマ属性（これはそもそも間違いだった）
+ パラメータ付きのファシリティ
+ inspect-dispatchコマンド
+ アクションサーチのfinishing
+ ファイルタイプの登録抹消
+ auto-print, gen-data 
+ 動的総称型、動的総称コマンド
+ アクションの内部プロファイル
+ インスタンスドキュメンテーション
+ 初期化の最後にコマンドラインを実行するオプション
+  疑似タグによる分岐
+ 例外マッパースクリプト
+ rootApplication 設定 
+ validate --closed 
+ untagged演算子 ^ 

</body>
</day>
<day date="2011-06-24" title="">
<body>
*1308897992*[雑感][圏一般論][その他代数][課題][山勘]どっちが先か？

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110624/1308891741&quot;&gt;本編にあんなこと&lt;/a&gt;書いたけど、タングル・ベースの算術があってもいいんじゃないだろうか？ 「数＝タングル（の同値類）」として、それ以上の抽象化はしない。目の前の図形と、それに対する手でできる操作だけを基本とする。

モノイド、群、半環、これらは抽象化／進化した概念であって、より原初的にはモノイド圏、亜群、半環圏だろう。抽象化／進化したとは脱圏化であり、原初に戻す操作が圏化。

モノイドかモノイド圏か、群か亜群か、半環か半環圏か、いったいどっちが先か？ には「どっちでもいい」と答えることができる。しかし、対応する小さな代数系がないとき（例えば置換の圏）は、脱圏化は難しいし無理にやってもいいことがない。進化＝脱圏化した概念を副次的と考えて、できるだけ原初の姿を壊さずそのままの形で扱うことが望ましいと思う。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070110/1168390324&quot;&gt;子供たちが小さかった頃のこと&lt;/a&gt;を思い起こしても、序数や基数が自然かどうかはアヤシイ。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20070411/1176255532&quot;&gt;「1 + 1 ができない」&lt;/a&gt;的な素朴な感覚をそのまま生かす方法が欲しい。


</body>
</day>
<day date="2011-06-28" title="">
<body>
*1309237518*[雑感][気付いた][まとめ]計算構造

「式を計算（評価）して値を求める」-- という構造を一般化するハナシ。とりとめもない。

&lt;hr&gt;
計算とは（ここでは）、計算関手:図式の圏→値の圏。値の圏は、事実上「行列の圏」。図式とは、図 and/or 式、つまり、graph, diagram, term, expression, formulaなど。

値の圏⊆図式の圏 とみなせる。この包含関手を使うと、計算関手:図式の圏→図式の圏 という自己関手とみなせる。計算自己関手を備えた図式の圏＝計算の圏＝計算構造。

計算自己関手のアルゴリズム部分＝計算手順＝正規化＝簡約＝還元＝変形＝書き換え。

計算構造を持つ圏は、図式書き換え系とみなせるから、書き換えを2-射とする2-圏。計算自己関手は2-圏の構造から得られる。2-圏の構造＝計算手順が、計算自己関手を定義する手段となる。

計算手順＝2-射＝書き換えは、2-射の生成系である計算ステップから生成される。計算ステップ＝移動＝基本変形＝書き換えルール。

&lt;hr&gt;
図式＝形状＋係数。形状＝複体。係数域＝古典的な代数系。係数は、付置、ラベル、カラー、重さ、荷電、パリティ、ポテンシャル、流量、k-形式、など。

&lt;hr&gt;
レルム＝圏の圏、形式的には2-圏がレルム。Cが圏として、Cのモノイド対象（内部モノイド）の圏をMod(C)とする。Modはレルムからレルムへの関手。Mod(C) = C&lt;sup&gt;Δ&lt;/sup&gt; = Func(Δ, C) なので、Δは関手Modを表現する表現対象（表現圏）。

これは、Δが形状の圏で、Cが係数域で、Modは自由生成された関手と考えることができる。

*1309252055*[Caty][モノイド圏][トレース／コンパクト閉圏][お絵描き]モジュールの演算 絵算

http://d.hatena.ne.jp/m-hiyama-memo/20110516 あたりの続き。大局的プログラミング（programming in the large）関係。

とある圏がありまする。

- この圏の射（対象じゃない）はモジュールである。
- この圏の対象は名前の有限集合である。
- 名前を型名だけに限定しても圏となる。とりあえず、型名だけで考えてもいい。 
- Lispのフィーチャーシステムと同じようなもの。

モジュール圏と呼びたいがそれはダメ。

- この圏の対象は指標（signature）と呼んでよい。（インスティチューションの用語法では。）
- この圏の射は指標射（signature morphism）と呼んでよい。
- だが、この圏の射はモジュールであることは事実。
- モジュールの英語&quot;module&quot;は加群の意味があるので、category of modules は使えない。
- 指標圏（category of signatures または signature category）なら使える。
- だが、「指標圏」で分かる人はいない。 

とりあえず、signatures and modules を縮めて sigmod圏とでもしておく。

http://d.hatena.ne.jp/m-hiyama-memo/20110516/1305538936 の表を再掲。

|* 演算記号   |* 意味 |
| +           |モノイド積、モジュールの集約／マージ |
| &amp;#124;&gt;   | 圏の結合、普通の結合 |
| :&gt;          | 閉じた吸収結合 |
| *&gt;          | 開いた吸収結合 |
| &amp;lt;:&gt;       | 対称な閉じた吸収結合 |
| &amp;lt;*&gt;       | 対称な開いた吸収結合 |

んで、絵はこうなる。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img2/module-connections.gif&quot; &gt;


</body>
</day>
<day date="2011-06-30" title="">
<body>
*1309390496*[モノイド圏][トレース／コンパクト閉圏][お絵描き]1次元お絵描き、これだけあればいいんじゃないのかな。

ジャンクション記号：

+ I
+ X
+ X&lt;sub&gt;+&lt;/sub&gt;, X&lt;sub&gt;-&lt;/sub&gt;
+ !
+ Δ
+ i
+ ∇
+ ∪
+ ∩

X なら対称（symmetric）で、X&lt;sub&gt;+&lt;/sub&gt;, X&lt;sub&gt;-&lt;/sub&gt; ならブレイド付き（braided）だが、仮想結び目があるから、X, X&lt;sub&gt;+&lt;/sub&gt;, X&lt;sub&gt;-&lt;/sub&gt; を混ぜて使うこともあるだろう。virtual braided となるのか？ 僕は mixed braided のほうがいいと思うけど。

モノイド積が2つあると、これらのジャンクションも2倍になる。


</body>
</day>
<day date="2011-07-04" title="">
<body>
操作を間違えて、朝の記事2本を上書きで潰してしまったよ。まー、ローカルコピーがあったからよかったが。http://d.hatena.ne.jp/m-hiyama/20100120/1263975148 でもやっているな。

びびったから、三番目の記事は明日にしよう、っと。

*1309771024*[からみ系][トレース／コンパクト閉圏][お絵描き]マルコフ移動

マルコフ移動については&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090501/1241156518&quot;&gt;ココ&lt;/a&gt;とかに書いているが、絵がなかった。絵はこうなる。

&lt;img src=&quot;http://www.chimaira.org/img2/markov-move-1.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/markov-move-2.gif&quot; &gt;

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%DE%A5%EB%A5%B3%A5%D5&quot;&gt;「マルコフ」で検索&lt;/a&gt;

*1309771025*[からみ系][トレース／コンパクト閉圏][お絵描き][メモ][気付いた]ライデマイスター移動の番号の覚え方

ライデマイスター移動の番号イチ、ニ、サンが覚えられなくてずっと困っている。ヤン・バクスター関係式とか名前が付いていればわかるのだが、番号は一番苦手だ。ところがだ、

&lt;img src=&quot;http://www.chimaira.org/img/singulars-and-moves.gif&quot; &gt;

この図を見ていて気がついた。射影図の交差点が上から順に1個、2個、3個なのだ。そうか、「番号＝交差点の個数」と覚えればいいのか。

三角、ジグザグ、スネーク、剛性などと呼ばれるアノ等式はライデマイスター移動0と呼ばれることがあるが、交差点はたしかにない（0個だ）。フムフム。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080704/1215140284&quot;&gt;ライデマイスター移動IIとIIIによる移動は regular isotopy。移動Iも入れると ambient isotopy 。&lt;/a&gt;


</body>
</day>
<day date="2011-07-05" title="">
<body>
*1309823512*[雑感][プログラム意味論][TQFT][お絵描き][セミナー]なぜにアミダはそれほどに重要か

僕がプログラム意味論とTQFTが関係すると思い出したのは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050614/1118708091&quot;&gt;マーク・ホプキンスの観測と示唆&lt;/a&gt;がキッカケだ。マークの観測は完全に正しかった。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20091019/1255913310&quot;&gt;ステファネスクがやっていたこと&lt;/a&gt;はそれを裏付けるし、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100722/1279762256&quot;&gt;最近のシャイ・ハランのF1の研究（Non-Additive geometry）&lt;/a&gt; はさらに状況証拠を与える。

図式プログラミング言語を考えると、ソースコード＝図 となるので、プログラム（のソースコード）の圏は「図の圏」と考えてよい。プログラム意味論とは、ソースコードの意味を定義するものだから、意味写像は &lt;em&gt;図の圏→適当な圏&lt;/em&gt; という関手となる。

意味領域である「適当な圏」は振る舞いの圏と言ってもよい。「振る舞い」という言葉だと誤解をまねくかもしれないから「振る舞いの記述」といったほうがいいかもしれん。

- 振る舞いの圏の対象はプログラムの入出力を表すナニカ
- 振る舞いの圏の射はプログラムの振る舞いの記述

意味関手＝振る舞い関手 となる。これはまた、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110628/1309237518&quot;&gt;計算構造&lt;/a&gt;で計算関手と呼んだものと同じ。

- 意味関手＝振る舞い関手＝計算関手＝TQFT関手

プログラム意味論では、実行によらずにプログラムの同値性やプログラムの模倣関係を知りたい。よく使われる手段はプログラムの書き換え／変形である。プログラムは図だったから、これは図の変形操作となる。

プログラムの同値性、プログラムの書き換えの簡単で分かりやすい例は、ブレイド図の圏の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100723/1279873974&quot;&gt;アルチン変形&lt;/a&gt;と&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110704/1309771024&quot;&gt;マルコフ移動&lt;/a&gt;だ。ブレイド図とブレイド群を完全に区別して、ブレイド図をプログラム、ブレイド群を振る舞いと考える。すると、アルチン変形で移りあえる同値関係が振る舞い同値になる。さらに、ブレイイド閉包を考えると、アルチン関係とマルコフ移動で移れる同値関係（マルコフ同値）が振る舞い同値になる。

状態遷移系の模倣、長谷川やセリンガーの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061110/1163147851&quot;&gt;一様性&lt;/a&gt;、ステファネスクの酵素規則などもマルコフ同値に近いと思える。行列にアダマール順序（成分比較するだけのバカ順序）を入れた2-圏とかが振る舞い記述の圏になるように思う。ここで不等式が出てくる。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?of=15&amp;word=%B0%EC%CD%CD%C0%AD&quot;&gt;一様性で検索&lt;/a&gt;

「図」を多様体や複体と解釈すると、コボルディズム圏が出てくる。TQFTとは、多様体を図とするプログラムの振る舞いの理論だと言ってもよいだろう。このとき、振る舞い記述の圏はヒルベルト空間の圏となり、振る舞いはユニタリ線形写像や&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20080704/1215129404&quot;&gt;ユニタリ対応&lt;/a&gt;となる。

といった諸々のこと、&lt;em&gt;これらの源泉はアミダの圏にある。&lt;/em&gt;

&lt;hr&gt;
それはそうと、円筒にアミダを描いたら、周期的な振る舞いをするプログラムになるよな。これの同値性ってどう判断するんだろう。全部同値になってしまう気がするが。


</body>
</day>
<day date="2011-07-07" title="">
<body>
*1310013087*[人物]ステファネスク師匠のURL

http://funinf.cs.unibuc.ro/~gheorghe/ がリンク切れになっている。
今生きているURLは：

- http://www.cs.uiuc.edu/homes/stefanes/mirrorNus/
- http://picasaweb.google.com/elETcris/CMR2007

*1310013385*[用語法][からみ系][お絵描き][メモ]ヤコビ図

ええーっ、ヤコビ図（Jacobi diagram）って、ファインマン図（Feynman diagram）と同じなの。web diagramなんて（もう使われることはなさそうな）名前もあるんだ。

</body>
</day>
<day date="2011-07-08" title="">
<body>
*1310099592*[用語法][からみ系][圏一般論]初歩的圏 再定義

初歩的圏という言葉が例えば次に出てくる。

- [http://d.hatena.ne.jp/m-hiyama-memo/20080709/1215582978:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080702/1214966458:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080627/1214524872:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080507/1210155603:title]

「&lt;i&gt;C&lt;/i&gt;が初歩的 ⇔ |&lt;i&gt;C&lt;/i&gt;| = &lt;b&gt;N&lt;/b&gt;」だが、少し拡張する。

&lt;i&gt;C&lt;/i&gt;が初歩的の条件は：

- |&lt;i&gt;C&lt;/i&gt;| ⊆ |&lt;b&gt;Fin&lt;/b&gt;| （&lt;b&gt;Fin&lt;/b&gt;は有限集合の圏）
- &lt;i&gt;C&lt;/i&gt;は可算集合、したがって、|&lt;i&gt;C&lt;/i&gt;|も可算集合。

&lt;i&gt;C&lt;/i&gt;(A, B) もたかだか可算だが、特に有限のときは局所有限な初歩的圏と呼ぶ。

初歩的なモノイド圏や半環圏が面白い。シャイハランの&lt;b&gt;F&lt;/b&gt;も局所有限初歩的な半環圏。


</body>
</day>
<day date="2011-07-09" title="">
<body>
*1310176608*[セミナー][気付いた][説明]L加群豊饒化と行列計算による説明

文字「L」自体には特に意味が無い。プレースホルダーつうか変数つうか。適当な有限個の代数（広い意味の「代数」！）の集合上を走る変数がL。代数系の集合は {I, F1, F2, N, Z} あたりか。

+ &lt;b&gt;I&lt;/b&gt; または I -- 自明なモノイド
+ &lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt; または F1 -- 自明な零付きモノイド、通称一元体
+ &lt;b&gt;F&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt; または F2 -- 二元体
+ &lt;b&gt;B&lt;/b&gt; または B -- ブール半環
+ &lt;b&gt;N&lt;/b&gt; または N -- 自然数半環
+ &lt;b&gt;Z&lt;/b&gt; または Z -- 整数環

これらの代数を便宜的にL代数と呼ぶ。L代数上の加群、特に自由生成加群により既存の圏（主に集合圏の部分圏）を豊饒化するシナリオ。そのために事前にいくつかの概念と練習が必要。

&lt;h5&gt;自由構成&lt;/h5&gt;

自由群が典型だろうが、自由モノイドのほうがわかりやすい。自由モノイドの要素は「語、文字列、列（シーケンス）、文、リスト」などと呼ばれる。自由モノイド構成は関手になる。モナドにもなる。

自由ベクトル空間、いい例はなにかな？ 電圧ポテンシャルを持った0チェイン、電流を持った1チェインをグラフ上で考えるとか。抵抗が一定の回路グラフの有向辺の上に電流を割り当てる、か。キルヒホッフの法則？ それだけで時間がかかる。

一次式の集合がいいか。もともと形式的だし。自由ベクトル空間構成も関手となって、忘却関手の随伴となる。もちろんモナドになる。

&lt;h5&gt;コレクション・データ型&lt;/h5&gt;

集合A（有限が考えやすい）があるとき：

+ A&lt;sub&gt;⊥&lt;/sub&gt; ボトム添加
+ A&lt;sup&gt;*&lt;/sup&gt; = List&amp;lt;A&gt; クリーネスター、リスト関手
+ FSet&amp;lt;A&gt; = Enum&amp;lt;A&gt; 有限集合関手
+ Bag&amp;lt;A&gt; バッグ＝マルチセット関手
+ A上の自由&lt;b&gt;Z&lt;/b&gt;加群

これらはL加群豊饒化と関係する。

+ I豊饒化 なにもしないA
+ F1豊饒化 A&lt;sub&gt;⊥&lt;/sub&gt;
+ F2豊饒化 Fset&amp;lt;A&gt; 対消滅付き合併
+ B豊饒化 Fset&amp;lt;A&gt;
+ N豊饒化 Bag&amp;lt;A&gt;
+ Z豊饒化 荷電集合

零付き代数に関しては、豊饒化＝局所加群化 だけでなく、全加群化もできる。

局所加群化の例としてのND（非決定性）関手。

&lt;h5&gt;行列計算&lt;/h5&gt;

上で定義したL代数以外の代数系も入るが：

+ 可達問題 Bの計算
+ 最短経路問題 [0, ∞] 上のmin-plus代数
+ 氷の運搬問題 [0, 1] 上のmax-times代数
+ 構文図 アルファベットA上のクリーネ代数

&lt;h5&gt;一般化された行列計算&lt;/h5&gt;

+ ダイクストラのアルゴリズム
+ ウィルスの感染／バイオハザードのシミュレーション
+ 離散波＝ステップ進行波、波頭集合と掃過域
+ 設定ファイルの合理的なマージ
+ ファインマン／クリーネ総和の公式

他に、フロイド／ウォーシャル法とかベルマンの原理とか。

*1310205242*[セミナー][説明][DFD]フロイド／ウォーシャル法と行列計算

&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt; http://d.hatena.ne.jp/m-hiyama-memo/20110713/1310515189 とだぶっていた。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

もともとの（かなり狭義の）フロイド／ウォーシャル法では、無向グラフ上の最短距離行列や最短経路を求める。

有向グラフにして、距離を非負値コストにしてもたいして事情はかわらない。[0, ∞] に min-plusをいれた加法的ベキ等半環が係数域とする行列計算になる。

Aのクリーネスター級数の打ち切り多項式を A&lt;sup&gt;[n]&lt;/sup&gt; と書くことにする。A&lt;sup&gt;*&lt;/sup&gt; = A&lt;sup&gt;[∞]&lt;/sup&gt; 。フロイド／ウォーシャルのアルゴリズムとしてのキモは、累乗の計算を 2, 4, 8, 16 と2のベキで行うので速いことだろう。2のベキで済む根拠は次のこと。

+ A&lt;sup&gt;n+1&lt;/sup&gt; = A&lt;sup&gt;n&lt;/sup&gt; となるようなnがあるとき、Aはベキ安定とでも呼ぶ（なんか用語があるのか？）。グラフの直達距離行列（あるいはコスト行列）Aはベキ安定である。
+ 加法的ベキ等半環を係数とする行列では、A&lt;sup&gt;[n]&lt;/sup&gt;×A&lt;sup&gt;[n]&lt;/sup&gt; = A&lt;sup&gt;[2n]&lt;/sup&gt; という公式が成立する。

最短経路（または最小コスト経路）に関しては、長さが (頂点数 - 1) で抑えられることから、ベキ安定が出てくる。min-plusの性質から、A = A&lt;sup&gt;[1]&lt;/sup&gt; = I + A となり、A×A = A&lt;sup&gt;[1]&lt;/sup&gt;×A&lt;sup&gt;[1]&lt;/sup&gt; = A&lt;sup&gt;[2]&lt;/sup&gt; が成立。A&lt;sup&gt;[2]&lt;/sup&gt;×A&lt;sup&gt;[2]&lt;/sup&gt; = A&lt;sup&gt;[4]&lt;/sup&gt; 、… を繰り返すと割とすぐに安定する。

実際の経路はどうでもよくて、最短距離行列が欲しいなら、2点を固定して、中継点を動かして検索した最小値ともとの値の比較を繰り返す。計算が楽なわけじゃないが、もともとがたくさんの組み合わせを試す問題だからな。

いい忘れたが、推移的閉包ってクリーネスター。文法で生成される言語もクリーネスター。離散半方向時間の半S行列もクリーネスター。行列Aのkステップ後の波頭がA&lt;sup&gt;n&lt;/sup&gt;で、掃過域がA&lt;sup&gt;[n]&lt;/sup&gt;。無限時間後だと波頭は意味がないが、履歴を全部累積した掃過域は意味を持つ。初期状態から、効果を無限に累積した後の姿がクリーネスターってことだな。これを作用素と考えると、現在から無限の未来（安定状態）を計算する作用。

</body>
</day>
<day date="2011-07-13" title="">
<body>
*1310514854*[その他代数][雑感]アーベル圏を使わないで何ができるか

計算関係だとホモロジーが使えない。アーベル圏が出てこない。アーベル圏では次が定義できる。

- f : A → B
- ker f : Ker(f) → A
- coim f : A → Coim(f) = A/Ker(f)
- im f : Im(f) → B
- coker f : B → Coker(f) = B/Im(f)

しかし、普通の計算（computation）の状況では、核と余核は意味が無い。CoimとImは定義できる。Imはそのまんま、Coimは逆像により同値関係を作って割り算をする。

(A → Coim(f) → Im(f) → B) という列は作れるが、これは完全列でも何でもない。完全列を定義する方法がみつからない。完全列が定義できないと、ホモロジーは定義できない。

仮にやりくりしてホモロジーを定義しても有用な情報が含まれない。

(コ)ホモロジーっぽい情報を一切あきらめるか、ホモロジーっぽいのだが、アーベル圏や完全列に頼らない定義を見つけるか？ ホモロジーをとらないで単に入射的分解、射影的分解だけを考えるのはありかもしれない。もっとも、計算に関係する対象の入射性や射影性が僕はわかってないけど。

*1310515189*[セミナー][説明][DFD]フロイド／ウォーシャル法と行列計算

もともとの（かなり狭義の）フロイド／ウォーシャル法では、無向グラフ上の最短距離行列や最短経路を求める。

有向グラフにして、距離を非負値コストにしてもたいして事情はかわらない。[0, ∞] に min-plusをいれた加法的ベキ等半環を係数域とする行列計算になる。

Aのクリーネスター級数の打ち切り多項式を A&lt;sup&gt;[n]&lt;/sup&gt; と書くことにする。A&lt;sup&gt;*&lt;/sup&gt; = A&lt;sup&gt;[∞]&lt;/sup&gt; 。フロイド／ウォーシャルのアルゴリズムとしてのキモは、累乗の計算を 2, 4, 8, 16 と2のベキで行うので速いことだろう。2のベキで済む根拠は次のこと。

+ A&lt;sup&gt;n+1&lt;/sup&gt; = A&lt;sup&gt;n&lt;/sup&gt; となるようなnがあるとき、Aはベキ安定とでも呼ぶ（なんか用語があるのか？）。グラフの直達距離行列（あるいはコスト行列）Aはベキ安定である。
+ 加法的ベキ等半環を係数とする行列では、A&lt;sup&gt;[n]&lt;/sup&gt;×A&lt;sup&gt;[n]&lt;/sup&gt; = A&lt;sup&gt;[2n]&lt;/sup&gt; という公式が成立する。

最短経路（または最小コスト経路）に関しては、長さが (頂点数 - 1) で抑えられることから、ベキ安定が出てくる。min-plusの性質から、A = A&lt;sup&gt;[1]&lt;/sup&gt; = I + A となり、A×A = A&lt;sup&gt;[1]&lt;/sup&gt;×A&lt;sup&gt;[1]&lt;/sup&gt; = A&lt;sup&gt;[2]&lt;/sup&gt; が成立。A&lt;sup&gt;[2]&lt;/sup&gt;×A&lt;sup&gt;[2]&lt;/sup&gt; = A&lt;sup&gt;[4]&lt;/sup&gt; 、… を繰り返すと割とすぐに安定する。

実際の経路はどうでもよくて、最短距離行列が欲しいなら、2点を固定して、中継点を動かして検索した最小値ともとの値の比較を繰り返す。計算が楽なわけじゃないが、もともとがたくさんの組み合わせを試す問題だからな。

いい忘れたが、推移的閉包ってクリーネスター。文法で生成される言語もクリーネスター。離散半方向時間の半S行列（片側S行列）もクリーネスター。行列Aのnステップ後の波頭がA&lt;sup&gt;n&lt;/sup&gt;で、掃過域がA&lt;sup&gt;[n]&lt;/sup&gt;。無限時間後だと波頭は意味がないが、履歴を全部累積した掃過域は意味を持つ。初期状態から、効果を無限に累積した後の姿がクリーネスターってことだな。これを作用素と考えると、現在から無限の未来（安定状態）を計算する作用。



</body>
</day>
<day date="2011-07-15" title="">
<body>
*1310702609*[リンク][トレース／コンパクト閉圏][DFD][プログラム意味論]アダメク達のエルゴット理論

- title: Elgot Theories: a new Perspective of Iteration Theories (Extended Abstract)
- authors: Jiri Adamek, Stefan Milius, Jiri Velebil
- URL: http://www.iti.cs.tu-bs.de/~adamek/Elgot(abstract),AMV.pdf

*1310702822*[メモ]hg st -X tmp .

hg st の -X or --exclude オプションが意外と便利。.hgignoreを書き換えないでその場で対処できる。


</body>
</day>
<day date="2011-07-16" title="">
<body>
*1310793742*[メモ][プログラム意味論][本]Alloy本いただいた

Alloy本を献本でいただいた。けど、「はじめに」しか読んでない。

昨日、他もチラチラ眺めたが、チラチラではどうも分からないな。疑問を感じたところをメモしておこう。ちゃんと読めばたぶん分かるだろうから、後で読むときに「気をつける」ポイントだな。

+ 仕様と述語はどう違うの？
+ 仕様とアサーションはどう違うの？
+ アトムのリテラルは説明専用？
+ タプルと一元（sigleton）関係はほんとに同じ？
+ 部分集合と単項（unary）関係はほんとに同じ？
+ フィールドってなに？
+ sigってなに？（インスティチューションのsigと関係するのか）
+ インスタンスってなに？（アトムとは全然違うが、語感がアトムっぽい）
+ なんで、集合の直積に '-&gt;' を使う？ そのココロは？
+ なんで型システムがあるんだ？ 関係計算だけじゃダメ？
+ 整数ってなに？ なんで整数だけ付け足しっぽい？
+ 入れ子タプルは認めてないようだが、強調してないな。直積もフラットな直積になるよな。
+ 一階の対象（タプルの集合）までしか認めてないのに高階論理風の論理式が出てくるけど、あれはなに？
+ 「+」は和集合か、直和はないの？ 直和である条件を制約として書く？ メンドイ。
+ univとnoneの扱いが不明。
+ サイズと基数って同じじゃないの？
+ アリティだけで、関係のプロファイルのようなものはないのか。
+ 関係の定義がこれはどうなのかな。単純すぎない？
+ 転置や推移的閉包が2項関係にしか定義できない。入れ子タプルを認めないと、一般の関係を2項に落とすこともできないし。フラットタプル型をペアにしたプロファイルが認められるなら、たいていのことは出来そうだが。
+ “実行”で検索する検索空間がイマイチはっきりしない。
+ 代数や余代数で定式化できないの？
+ loneをなんて発音する？ エルワン、ローン？
+ 一階の論理式でも、対象物が関係なら、アトムから数えて二階にいると思うが。

*1310810684*[メモ][プログラム意味論][本]Alloy本いただいた 2

さらにチラチラ：

+ （本じゃなくてAlloyが）全体に、オブジェクト指向言語、特にJavaと類似の構文にしようとしている印象。abstractとかextendsとか。それが良いか悪いかはともかく、やるんなら、sigじゃなくてinterfaceにすればよかったのでは。
+ sig（interface）の実装が、アトム集合になる。アトム集合がクラス相当ってのはけっこう辛いアナロジーかな。もっと辛いのは、「インスタンス」って言葉が使えないことだ。他で別な意味で使っている。
+ アトムが状態点でアトム集合を状態空間とすれば、まーギリギリだが、クラスとのアナロジーが取れるか。「インスタンス」は使えないとなると、thisの指すものは個体（individual）とでもするか。
+ sig = interfaceの実装領域（アトム集合）の個体（アトム）ごとに、値が変わるのがフィールド。いちおう辻褄はあう。
+ フィールドの値はスカラーとは限らず、シングルトンとも限らず、集合かもしれない。
+ なんでも関係とみなすのはまーいいんだけど、メンタルモデルとしては、演算の項（オペランド）にほんとのアトムやほんとのタプルが入ったとき、演算が可能になるような自動型変換がされる、とするほうが余程分かりやすいだろう。
+ 概念的には、アトム、アトムのタプル、タプルの集合は区別しなくてはならない。それらの型変換を純粋に思考と概念の世界に押し込めるのは、実は負担が大きい。むしろ、異なる型に属するが、同等なモノへの変換は処理系がすべき。
+ 例えば、限量子で束縛された変数は要素を走るとするのがどう考えても自然。ベキ集合内のシングルトンセットの領域を走る、と考えるのは辛い。さらに、単項関係（長さ1のタブルの集合）の集合内で、特にサイズ（基数）が1のモノの領域上を走る、なんて考えるのはマゾ！
+ 「タプル」をサイズ1の関係（一元関係）、「集合」をアリティ1の関係（単項関係）とする用語法は、どうやっても徹底できないだろう。破綻することは眼に見えている。
+ 「タプル」や「集合」は極めてポピュラーな用語だから、ジャーゴンとオーバーロードして使うべきじゃないだろう。
+ '-&gt;' が直積、というのも少し違うような。長さnのタプルの集合と長さmのタプルの集合を、二項直積して出来るタプルの長さは2であって、n+mじゃない。'-&gt;'でタプルの繋ぎ目が完全に消えるかというとそうでもない。(a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;; b&lt;sub&gt;1&lt;/sub&gt;, ..., b&lt;sub&gt;m&lt;/sub&gt;) のようなモノが出来るのだろう。あくまで気持ちとしては、だが。
+ 関係演算 '-&gt;' の結合律はon-the-noseで成立するが、関係圏のカリー化／反カリー化が背後にあるのを忘れないほうがいい。データセットのレベルでは on-the-noseだが、射のプロファイルの変化が伴う。
+ プロファイル概念（単にタプルの切れ目を「;」とかでマークするだけ）があれば、転置も推移的閉包もずっと一般化出来る。
+ タプルの切れ目を移動するだけでカリー化／反カリー化も出来る。左に移動でカリー化、右に移動で反カリー化（だいたいだけど）。
+ graded pointed setの圏に直積を入れて、その圏内のモノイドを考えると '-&gt;' の代数的なモデルになる。だいたいだけど。
+ 関係の圏では、∪をベキ等な可換演算と考えて、それで順序が導入される。なので、可換ベキ等モノイドの圏で豊饒化できる。（なんか関係ない話に行ってしまったか。）
+ ドットは、記法としては良いが、定義がショボイだろう。プロファイルがないので、なんか恣意的にプロファイルを割り当てている。
+ 関係の域は、sigがあるので割と明確だが、余域がわからない。余域と像（image）を値域（range）という名で混同している気配がある。全域かどうかは判断できるが、全射的（surjective）の判断は曖昧。
+ 「値域」は「余域」と「像」にオーバーロードしているのか？ それだと困るな。
+ sigを使う限り、関係の域はアトムの集合に限られる。（普通の意味で）タプルの集合を域に指定することができない。結局、アトムの集合を域として、タプルの集合を余域とする範囲？
+ しかし、アリティにおいて、1→n だけを取り出すと、ドットの定義がまったく整合性がない。n = 1 以外ではうまくいかない。n = 1 だとすると、関係圏のendmorphismモノイドしか使ってないことになる。so-called「集合」は、subidentityになる。
+ プロファイルがないのが、全体に暗い影。

</body>
</day>
<day date="2011-07-19" title="">
<body>
*1311035844*[メモ][プログラム意味論][その他プログラミング]Alloy本いただいた 3

本じゃなくて言語と処理系のことだけど。

書き方：

+ 区切り記号はあんまりないようだけど、カンマで区切る（分離）ことがある。改行で区切りを認識するわけじゃない。
+ アトムは修飾子付きの自然数だと思えば十分のようだ。
+ 本の説明では、アトムは大文字。
+ タプルは (A, B, C) とも A-&gt;B-&gt;C とも書く。
+ 集合は普通の {...}。

モデル：

+ 関係は見出しなしのテーブルと思えばいい。RDBのテーブルは実はタプルの集合じゃなくて、バッグ（マルチセット）。
+ アリティはテーブルの幅、サイズはテーブルの高さ
+ テーブルは、関係行列のスパース表現だ。

処理系UI：

+ GUIが出てくるのは僕にはイヤだ。
+ 編集ウィンドウはジャマなだけだが、ヴィジュアライザーは意味がある。これはいい。
+ けど、2項関係しか絵に描けないのがドウモね。線に色々書いてあるのは好きじゃない。が、描き方の代替案があるわけでもない。
+ Evaluator ってのがある。便利だ。式の書き方の練習もできる。
+ メッセージペイン（右ペイン）とかEvaluatorのクリアの仕方がわからない。
+ 具体的なモデル（インスタンス）を人間が作って、それが妥当かどうかを検査したいけど、どうする。インスタンスの記述言語がないとダメだな。
+ 全般に、もっとキーボードショートカットが欲しい。

気付いたこと：

+ 条件が強すぎて、モデルがないとき、それは公理を余計に書きすぎたとは限らない。命題の前提条件（含意の左）が足りないこともある。
+ 暗黙のスコープ（基数リミット）からモデルインスタンスが探せないことがあるので注意。

*1311036826*[メモ][プログラム意味論][その他プログラミング]Alloy本いただいた 4

わかりにくかったところ／困ったところ：

+ '.' は記法としては巧妙で素晴らしい。が、その定義はサイテー。あれはないだろうよ。現状では、僕が一番&lt;em&gt;気に入らない&lt;/em&gt;ところだ。
+ Aが基本集合（アトムの集合）として、x:A と x:A-&gt;A の意味がわかりにくい。x:A では、xはAの要素、x:A-&gt;A では、xは二項関係。あまりにも違いすぎる。
+ 記号や概念を節約して、単純性、一様性、柔軟性を増す戦略はわかるが、やり過ぎだろう。部分集合を単項要素に統合するのはまーいいとして（厳密には双対性を考慮しないとダメだが）、要素変数と関係変数を使ってもよかった。少なくとも、説明とメンタルモデルでは、要素と関係を区別すべき。
+ x :: A を x∈A、x:A をx⊆A とすれば、全体にツジツマがあう。限量子で束縛される変数は要素変数だから all x::A と書くことになる。

</body>
</day>
<day date="2011-07-23" title="">
<body>
*1311409585*[映画]SUPER8/スーパーエイト

ちょっと時間が余ったはずみに映画『SUPER8/スーパーエイト』を一人で見た。

製作にスティーブン・スピルバーグが入っているし、監督のＪ・Ｊ・エイブラムスは大のスピルバーグファンだったらしい。この映画の舞台は1979年の新興住宅街。少年たち、親子、家族、地域、それで宇宙からの未知の生物。「未知との遭遇」、「Ｅ.Ｔ.」とおんなじ設定やん。

「未知との遭遇」のリアルな公開は1977年、「サタデー・ナイト・フィーバー」も同じ年だ。僕が六本木やらヨロン島やらにいたころだ。そりゃなつかしくもなるわな。

アリス（アリー； 配役：エル・ファニング）とそのろくでなしの父親がとてもよかった。主人公の少年たちは8ミリ映画に熱中している。スピルバーグも（たぶんエイブラムスも）8ミリ少年だったはず。僕も高校時代に8ミリ映画撮ったしな。山のようにノスタルジーのネタがある。気がつけばジイサマ。

</body>
</day>
<day date="2011-07-25" title="">
<body>
*1311551098*[DFD][形式言語理論][課題][まとめ]波頭関数、指数関数、片側S行列

時間も空間も何もかも離散的な状況で考える。可算無限は認めたいが、面倒なら全部有限でいい、という前提。

時間発展の生成子（time evolution generator）は、正方行列Aで与えられているとする。境界（入出力）とかあるけど、とりあえずはAだけに注目。

+ F&lt;sub&gt;A&lt;/sub&gt;(k) := A&lt;sup&gt;n&lt;/sup&gt;
+ E&lt;sub&gt;A&lt;/sub&gt;(k) := A&lt;sup&gt;[n]&lt;/sup&gt; = I + A + ... + A&lt;sup&gt;n&lt;/sup&gt;
+ S&lt;sub&gt;A&lt;/sub&gt; := A&lt;sup&gt;[∞]&lt;/sup&gt; = I + A + ... 

Fは波頭の動きを表現する。Eは掃過域の動きを表現する。Sは無限の未来の全掃過域。

粒子の運動に限定すれば：

+ 粒子の運動（時刻ごとの位置）
+ 粒子の運動のある時刻までの軌跡
+ 粒子の運動の全軌跡

問題は：

+ 時間発展生成子Aをうまく定義する。
+ F&lt;sub&gt;A&lt;/sub&gt;, E&lt;sub&gt;A&lt;/sub&gt;, S&lt;sub&gt;A&lt;/sub&gt; を実際に計算する。


</body>
</day>
<day date="2011-07-26" title="">
<body>
*1311647504*[DFD][プログラム意味論][形式言語理論][課題][マンダラ]運算的振る舞い関手

僕の作業仮説である&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/archive?word=%A5%DE%A5%F3%A5%C0%A5%E9&quot;&gt;マンダラ&lt;/a&gt;仮説だと、計算の世界は複雑だ。単純化しすぎた定式化はうまくいかないだろうと思っている。だが、扱いにくい複雑性ではどうにもならない。扱いやすい「単純な複雑さ」を探さなくてはならない。

今知っている具体例から抽象して、次のような枠組みを考えている。

+ 二重圏Diag：図の圏。コボルディズム圏がお手本になっている。
+ 二重圏Mat：行列の圏。順序半環係数の行列の圏がお手本になっている。
+ 二重関手CB:Diag→Mat：ファインマン／クリーネ総和による計算がお手本になっている。

二重圏の各次元のセルは次のように解釈する。

+ 0セル：境界、入出力ポート／ピン
+ 1セル：グラフ、オートマトン、ラベル付き遷移系、カテグラフ、圏ラベル付きタングルなど
+ 2セル：模倣関係、書き換え、変形、移動（move）など

二重圏の水平方向（ってどっちだ？）の1-骨格(1-切り落とし）には半環構造が入っていて、半環圏になっている。2セルは半環構造と協調している。

幾つかの問題がある。

+ ペトリネットをどうやって取り入れるか。拡張が必要かもしれない。
+ ペトリネットと関係しそうだが、時間概念をどうするか。
+ マイヒル／ネロードの定理の定式化
+ 正規形の定義や合流性の証明
+ ステファネスクの基本定理の証明

「ステファネスクの基本定理」は僕が命名したものだが、だいたいは次の主張。

- トレース付き対称モノイド圏MとVがあるととき、M→V というトーレス付きモノイド関手の全体は再びレース付き対称モノイド圏となる。

もともとの記述は、「networksに圏係数を付けて拡張してもnetworksになる」といった話でちょっと曖昧なところがある。必要に応じて係数を拡張できる、という意味では非常に重要なことだと思う。

TrSySMonをトレース付き対称厳密モノイド圏の圏（レルム）として、TrSySMon(A×B, C) ≒ TrSySMon(A, [B,C]) という閉構造として定式化できるとうれしいが、×の定義が素朴じゃない気もする。仮に閉構造の形になっても、2セルとどう関係するかが問題だし。

それと、加法的なトレースはエルゴット繰り返しなのはわかるが、乗法的トレースがよくわからない。インターフェースの隠蔽がそれにあたる気もするが。

*1311647710*[DFD][形式言語理論][用語法][お絵描き]圏を係数とする行列やテンソル

同じ概念を次のような言い方をしている。

+ 複行列&lt;br&gt; http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%CA%A3%B9%D4%CE%F3
+ 形式テンソル&lt;br&gt; http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%B7%C1%BC%B0%A5%C6%A5%F3%A5%BD%A5%EB
+ テンソルグラフ&lt;br&gt; http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%C6%A5%F3%A5%BD%A5%EB%A5%B0%A5%E9%A5%D5
+ 圏係数 行列&lt;br&gt; http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%B7%F7%B7%B8%BF%F4%20%B9%D4%CE%F3

カテグラフってのが一番一般的な概念で、イエッター（Yetter）も&lt;i&gt;C&lt;/i&gt;ラベル付きタングルという概念を提示しているから、良い概念だと思う。特殊ケースにリグラフがある。

カテグラフのなかで古典テンソル計算に対応するのが形式テンソル。形式テンソルの特殊なものが形式行列＝圏係数行列でいいと思う。テンソル計算では積和の計算が必要だから、係数圏は半環圏ということになるだろう。行列計算だけなら、加法的モノイド圏で十分。

形式テンソルの圏を作るには、和と積を持つ添字集合の圏が必要。対象の和と積は集合論的直和と直積で良さそうだが、射の定義が問題。射の定義によって形式テンソル圏の構造も変わる。有限集合と関係の圏とするのが一般的かもしれない。

一般のカテグラフの圏は、添字の圏（テンソルの添字と同じ）と係数圏から決まる。添字の圏は、係数圏を自明圏&lt;b&gt;1&lt;/b&gt;とした場合のカテグラフ圏と同一視できる。一方、係数圏Cは、添字の圏を自明圏としたカテグラフ全体の自然変換の圏と同一視できる。

&lt;hr&gt;

ここで絵の描き方の話。次の図は裏写りしているし、分割するのがメンドイので一枚絵だが：

&lt;img src=&quot;http://www.chimaira.org/img2/tensor-diagram.gif&quot; &gt;

i∈{1, 2, ..., n} を i:n とも書く。iは単なる目印で、適当にリネームしても影響ない。nは添字の範囲。iをフラットケーブルの識別子だと考えると、nがケーブルの幅になる。幅nのケーブルには、1からnとマークされた単純ワイヤーが含まれる。iはその単純ワイヤーのどれかを示す変数でもある。

フラットケーブルも単なる線で示すと、n→m の行列は、普通のオダンゴ図で表現できる。添字がマルチになったテンソルは、入力も出力も複数のフラットケーブルを持つ。この絵は&lt;strong&gt;スパイダー&lt;/strong&gt;と呼ぶこともある。

スパイダーは、コンパクト閉多圏の射（多射）を意味する。論理では、コンパクトシーケントになる。コンパクト閉多圏は、コンパクトシーケント計算の意味を与え、コンパクト閉多圏をコンパクト閉圏に落とすこともできる。

スパイダーの複数の足を一本のワイヤーで略記すると、基本的にコンパクト閉圏の絵と変わらない。コンパクト閉多圏の演算は次がある。

+ 結合： 圏の結合と同じ。
+ テンソル積： 併置
+ 直和： ワイヤーはOR結合される。どちらかにしか入力は入らない。
+ 和：Δ;(f(+)g);∇ のこと。

*1311659542*[DFD][形式言語理論][プログラム意味論][マンダラ]Hoare algebra ＝ プログラムの両側半加群構造

&quot;Hoare algebra&quot;って言葉は使われてないようだ。僕が使ってしまうぞ。

プログラムの計算がテンソル計算と似ているのは、・→・ に対して、2つのブール半環と、それらを係数とする両側半加群が対応するからだろう。A, Bなどがプログラムで、p, qなどが条件だとして：

+ 順次実行 A; B
+ 選択的実行 choice A or B end
+ 並列実行 cobegin A and B end
+ プレガード pre p A
+ ポストガード A post q

(pre p A) post q ≡ pre p (A post q) はホーアトリプルで p{A}q と同じ意味。ホーアトリプルを、宣言や主張とみるのではなくて、これもプログラムと見る。p{A}q = A のとき、プログラムAは事前条件pと事後条件qを満たす。

Kを2元のブール半環とすると、これは半体となる。R, SをK上の可換半環として、Mは左R右S半加群だとする。これらをまとめた (K, R, S, M)をホーアトリプル代数またはホーア代数と呼ぶことにする。

基礎半体Kで 1+1 = 1 が成立することからRやSも加法的ベキ等になる。したがって順序が入り、可換半環も半加群も順序構造を持つ。Kは固定するが、RもSも固定しないとホーア代数の全体は二重圏になる。ホーア代数をトリプルの形で R{M}S と書くと、R{M}S, S{N}T は、Sに関するテンソル積で R{M(×)N}T となるから、これが横結合（スター積）を与える。

順序を2セルと考えると、半環準同型は3セルになるうようだ。もっとも、この議論では、半加群と半加群の元を混同しているきらいがあるが、混同してもいい、あるいは混同を合理化する定式化がありそうなもんだ。

</body>
</day>
<day date="2011-07-27" title="">
<body>
*1311732299*[DFD][セミナー]半環係数行列とその応用

グラフの頂点数と同じサイズの正方行列を計算する。頂点付値、辺付値がある。

+ {0, 1}半環 可達性
+ min-plus代数 コストの最小化（例：距離、運送費用）
+ max-plus代数 ゲインの最大化（例：金貨拾い問題）
+ max-times代数 乗法係数の最大化 （例：氷運搬問題）
+ 言語半環 オートマトン

頂点付値はある種のポテンシャルで、頂点付値の全体はアフィン空間かベクトル空間（のようなもの）になる。辺付値が時間発展の生成子行列で、頂点付値の空間にendomorphismとして働く作用素になる。

辺付値の空間がアフィンまたはベクトル空間で、付随するベクトル空間になにか内積のようなものがあれば、初期状態がxで観測子がyであるような時間発展における観測量の推移は

- φ(t) = &amp;#60;E(A, t)x|y&gt;

と表現できる。Eがクリーネ指数関数（I + A + AA + ...）なら、φは単調増加する。

*1311748262*[メモ][用語法]接合行列（結合行列）と隣接行列

隣接行列をインシデンス行列と言うのは違うだろう。

+ http://en.wikipedia.org/wiki/Incidence_matrix
+ http://en.wikipedia.org/wiki/Adjacency_matrix

*1311748263*[気付いた][具体例][課題]単調シリアライゼーションと三角行列

Aが有限プレ順序集合として、f:A→&lt;b&gt;N&lt;/b&gt; が：

+ fは全単射である。
+ fの像は、{1, ..., n} の形で、nはAの基数。
+ 順序に関して単調。

このとき、fを単調シリアライゼーションと呼ぶ。

次の問題を考える：

+ 与えられたAに対して、単調シリアライゼーションはあるか？
+ あるなら全部で何個あるか？

状況証拠から次がいえそうだ。プレ順序集合Aを有向グラフと見て、その隣接行列を同じくAで表す。

+ 可逆行列Pを使って P&lt;sup&gt;-1&lt;/sup&gt;AP を上三角行列にできる ⇔ グラフAにサイクルがない
+ グラフAにサイクルがない ⇔ Aが単調シリアライゼーションを持つ

これを使って、単調シリアライゼーションの数え上げができないか？

*1311760603*[メモ][気付いた]行列の記法

上下の添字を使うのはアスキーで書けない。A[i, j] とかがいいが、これだと向きがいまいちわからない。そこで、A[i-&gt;j]とかA[j&lt;-i]とか括弧の代わりに矢印を使う。

Σ(B[k&lt;-j]A[j&lt;-i]) で、jが2回出てきてるから、これで和を取るのはテンソル計算と同じ。アインシュタイン規約でΣを省略可能。

Aの転置をAlloyに倣って ~A とすると、~A[i&lt;-j] = A[j-&gt;i] のように書ける。A[i,j-&gt;k], A[k,j&lt;-i] なども同じ、こっちはモロにテンソル計算。

</body>
<comments>
<comment>
<username>salmonsnare</username>
<body>グラフ理論で出てくる、「incidence matrix」の訳語は「接続行列」だと思います。</body>
<timestamp>1311785754</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>salmonsnareさん、&lt;br&gt;標準的訳語は「接続」ですか。&lt;br&gt;どう考えても隣接行列をインシデンス行列と呼んでいる例があったんで、それは違うだろう、と。</body>
<timestamp>1311825710</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>＞どう考えても隣接行列をインシデンス行列と&lt;br&gt;＞呼んでいる例があったんで、それは違う&lt;br&gt;&lt;br&gt;そうですね。&lt;br&gt;グラフ理論の訳語においては違います。&lt;br&gt;&lt;br&gt;グラフ G = (V, E) が与えられたとき、 &lt;br&gt;辺 {x, y}∈E が存在するならば、&lt;br&gt;G の 「2個の頂点 x, y は隣接する」といいます。&lt;br&gt;隣接行列は頂点対が隣接するかしないかを&lt;br&gt;1, 0 で表現したものです。&lt;br&gt;&lt;br&gt;また、辺 e ∈ E に対して e の端点の一つが v のとき、&lt;br&gt;「v は e に接続する。」といいます。&lt;br&gt;接続行列は接続するかしないかを&lt;br&gt;1, 0 で表現したものです。&lt;br&gt;&lt;br&gt;グラフ理論の和書 (翻訳書を含む) の大体の文献が、&lt;br&gt;この訳語で書かれていると思うので、&lt;br&gt;その例を書かれた著者が、&lt;br&gt;隣接行列と接続行列を混同されているか、&lt;br&gt;その分野でその用語がそういう使われ方をしているか、&lt;br&gt;どちらかだと思います。</body>
<timestamp>1311856134</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&gt; その分野でその用語がそういう使われ方をしているか、&lt;br&gt;この可能性もなくはないですね。</body>
<timestamp>1311902869</timestamp>
</comment>
</comments>
</day>
<day date="2011-07-28" title="">
<body>
*1311843013*[雑感][その他代数]ガウスの消去法

ガウスの消去法ってすごいなー。中学生でも知っている連立一次方程式の解き方なんだけど。

連立一次方程式の空間は、たとえば適当なサイズの行列で表現できる。同じ解をもつ方程式を同値とするなら、定義より当然に、同値類と解が1：1に対応する。この同値関係を尊重するような書き換えができて、この書き換えの一意的な正規形として解が得られる。

書き換え規則がエロ三つ組（Elementary Row Operations）で、EROは可逆だから、EROで生成された群が働く空間になっているわけだ。連立一次方程式の空間を状態空間とみての遷移系とも見られる。すごいのは、遷移に方向性があって、正規形に向かって遷移できるところ。

方向性があるってことは、遷移に（あるいは空間に）ある種の計量的判断基準が備わっているってこと。この基準に沿った遷移＝離散的な運動が解に向かって行く、と。最適制御とかともどことなく似ている。


</body>
</day>
<day date="2011-07-29" title="">
<body>
*1311905990*[高次圏論][DFD][プログラム意味論][山勘]並列計算、ABCD構造、スパイダー、インターリーブ複体

&lt;em&gt;とりとめない。&lt;/em&gt;

並列計算を理解したい！ 高次遷移系を使いたい。higher-dimensional transition systems とか higher-dimensional automata とかで検索してそれなりに引っかかる。が、なんかピンと来ない。

組み合わせ幾何学の観点からは、単体的複体や方体的複体を扱うことになる。図形に対称性は期待できない。むしろ、非対称性、方向のような概念が重要になる。

組み合わせ複体を作るときは、モノイドや圏の脈体を作る方法がすごく重要になると思う。圏C内のモノイドの圏 Mon(C) が、C&lt;sup&gt;Δ&lt;/sup&gt; で作れることは良いヒントになる。乗法と単位から生成される単体構造があって、コサイクル条件が単位律と結合律に対応している。

モノイド圏におけるモノイド積（テンソル積）と交替律も、並列計算の基本概念を提供する。対象のテンソル積は、独立・無干渉な2つのシステムを一緒に考えて複合システムの構成になる。独立・無干渉であることの主張が交替律になる。交替律を仮定する限り、干渉する複合システムは扱えない。

干渉する複合システムはどう作るか、というと、ファイバー積を作ればよいだろうが、ファイバー積の計算を系統的にしたい。それでスパイダー； 多圏の射の図をスパイダーと呼ぼうと考えていたが、形式テンソル（または抽象テンソル）と言えばいいので、スパンの拡張概念をスパイダーと呼ぼう。

有限完備な圏C上に、対象の部分類A, Bを考える。Aはattributeの類、Bはboundaryの類、ここまででABCとなる。実際は、Cはcodomain、Dはdomainを含めてABCD構造。さて、(C, A, B)内の錐を考える。錐の頂点をボディと呼ぶ。側線が3つのグループにわかれていて、それぞれのグループをD-脚、A-脚、C-脚と呼ぶ。脚のグループが空であってもよい。A-脚の端点（余域）はA類に入っている必要がある。D-脚とC-脚の端点はB類。

以上で定義した錐がスパイダー。スパンの制限と拡張であることは明らかだろう。2つのスパイダーf, gの結合は、fのC-脚とgのD-脚の端点群が一致するとき、そこに出来るマルチ・コスパンを使ってファイバー積を作ればいい。とはいっても、詳細はめんどくさい。

Cをまるまるスパイダーの圏に埋め込めるわけではないが、Cのなかの“興味ある射”はスパイダー圏に埋め込める。Cの結合も直積もスパイダー圏の結合で書けるので、スパイダー圏構成は、“興味ある射”だけを抜き出して計算を拡張したことになる。

&lt;hr&gt;

ほんとにとりとめもないが、これらの話題はなんか相互に関係するような気がしている。並列計算と直列計算の関係は、同時並行実行がインターリーブでエミュレートできるかどうかに尽きるような気もする。任意のインターリーブで置き換え可能なら、複合システムは独立・非干渉だ。インターリーブで置き換え可能とは可換性を要求する。可換性もまた独立・非干渉の表明となる。

複合システム内で、2つのサブシステムがどの程度干渉しているか、どの程度絡んでいるか？ を判定するときにホモトピー的情報が必要になる。このホモトピー的情報を組み合わせ的に計算するためには複体が前提になる。だからなにはともあれ複体を構成しなくちゃ。この複体の0次元部分は状態空間だ。セルは同時実行される複数のアクションの組だろう。インターリーブ可能性とかインターリーブの可換性が組み合わせトポロジー的な構造を決めるはずだ、たぶん。

並列計算の表現となる図形がインターリーブ複体。通常のモノイド圏（の脈体）は、インターリーブ複体の特殊ケースになるはず。なぜなら、モノイド圏は独立・無干渉な複合システムだけを扱う枠組みだから。依存・干渉が入ると、結合とテンソル積を分離して考えるのは困難になる。結合とテンソル積をファイバー積として混ぜて計算する体系がスパイダー計算系。

&lt;b&gt;[追記]&lt;/b&gt;単体構造は辺作用素（単位）と退化作用素（乗法）で定義できる。

- δ&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt; : [n]→[n+1]  （k = 0, ..., n）
- σ&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt; : [n+2]→[n+1]  （k = 0, ..., n）

これに加えて、チェインの隣り合う成分の交換に意味があるときに交換する作用素 τ&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;k&lt;/sub&gt;:[n+2]→[n+2] （k = 0, ..., n） が必要になるのだろう。チェインが、自己射の列として与えられるなら交換作用素は常に意味を持つ。

単体構造＋交換作用素（対称、スワップ）による構造を図形として捉える問題。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2011-07-30" title="">
<body>
*1312000379*[プログラム意味論][モナド]コモナドの余代数

大域変数の参照をコモナドと考えると、大域変数への書き込みがこのコモナドのアイレンベルク／ムーアの意味での余代数となる。ということは、大域変数を読むだけのプログラムは余クライスリ圏に住んでいるので、余アイレンベルク／ムーア圏に埋め込めるから、書き込みをするプログラムの圏に入る？ 一見なんか奇妙だ。どうやって説明するんだ？

奇妙に感じるのは、クライスリ圏がアイレンベルク／ムーア圏に入っているという状況をちゃんと理解してないせいだろう。

*1311991519*[高次圏論][モナド][用語法]moritable

Yoneda（米田）は超有名だが、Morita（森田）も有名。moritableなんて概念を定義する人がいる。

http://homepages.vub.ac.be/~jvercruy/EM.pdf :

&gt;&gt;
Defnition 3.5.1. 

Let T = (T ; (L&lt;sub&gt;A&lt;/sub&gt;, R&lt;sub&gt;A&lt;/sub&gt;); (L&lt;sub&gt;B&lt;/sub&gt;, R&lt;sub&gt;B&lt;/sub&gt;)) be an object in Adj(A, B). The pair (R&lt;sub&gt;A&lt;/sub&gt;, R&lt;sub&gt;B&lt;/sub&gt;) is said to be &lt;i&gt;moritable&lt;/i&gt; if and only if the comparison functor K is an equivalence of categories.
&lt;&lt;

*1311989645*[高次圏論][DFD][プログラム意味論]高次遷移系がイマイチ、別な定式化を探そう

higher-dimensional transition systemの関係論文を&lt;em&gt;少し見ただけ&lt;/em&gt;で、こう言うのはナンだが； 定義や定理がなんかイマイチで、役に立つ感じがしない。抽象論は大好きだが、CPU、メモリ、マシン（またはプロセス）などとの対応が鮮明じゃないと現実に適用しにくい。僕は現実の並列計算を説明したい。

同時実行をインターリーブして展開すると効果（effect）が変わる。そこが問題なのに、同時実行とインターリーブ展開を区別しない（同値にしてしまう）ような定式化してもショウモナイ。それは複数の計算が独立・無干渉なときに限られる話だ。

遷移だけ見ててもダメで、遷移の変形（deformation）が問題。変形は書き換え（並列プログラムのリファクタリングや最適化）と言ってもいい。状態点＝0セル、遷移＝1セル、変形＝2セルとしての高次圏が必要だ。1セルにマルチアクションのラベルを付けても、実際には高次になってない。アクションラベルの集合がタプルになっただけで、状態空間の幾何構造が変わってない（1次元のまま）。

豊饒圏を作るとき、対象の集合の完全グラフを作って、辺に値の圏V（enriching category）のホム対象を割り当てる。この作り方は正方行列の定義と同じで、グラフで言えば隣接行列がホム対象の割り当ての記述になる。1次元グラフ＝普通のグラフでは、すべての頂点は潜在的には辺で繋げる可能性を持っている。この事実を、頂点（のペア）は&lt;strong&gt;1-connectable&lt;/strong&gt;と言うことにする。XとYが1-connectableのとき、hom(X, Y) が意味を持つ。

基礎となる1次元グラフの辺のあいだに2-connectableの関係を入れる。このときアクションのタプルを使う。同時実行遷移と、それをインターリーブ展開（分解）したパスは2-pre-connectableとして、2-pre-connectableを反射的対称な関係として拡張して2-connectableを定義する。2-connectable関係を～とすると； p～p、p～q ⇒ q～p となる。

2-ラベルの集合というものを考えて、2-ラベル係数の行列 A[p, q] （ただし p～q）を与える。これが2-隣接行列。問題は、2-隣接行列の計算と、2-隣接行列／1-隣接行列のあいだの関係。1-隣接行列の推移的閉包は簡単に定義できて、これで計算的振る舞いを定義できた。類推すると、2-隣接行列の推移的閉包が2-振る舞いを定義しそう。2-ラベルの集合が真偽値なら、2-振る舞いはホモトピーになると思われる。

キーとなる概念は：

- インターリーブ展開
- 非交替（non-interchangeable）圏
- 実行（run）のホモトピー

同時実行をインターリーブ展開すると、たくさんのパスが出てくるが、これらが交替律を満たすとは限らない。非交替の度合いがサブシステムの相互干渉を測る目安となる。その非交替性はホモトピーで記述されると思う。

ところで、実行（run）て概念も問題で、それほど素朴なもんじゃない。線形パスを実行として捉えていいのは単純直列プログラムの話であって、並行処理プログラムではそうはいかない。並行実行を、そのなかに含まれる直列実行の集合で特徴づけるアプローチは確かに有効だが、それがプライマリーな定義になるのはおかしい。もっと直接的な実行（run）の定義があってしかるべき。

以前、「時間の空間」という変な言葉を使っていたが、並列実行の定義はまさに「時間の空間」の問題だと思う。いくらなんでも「時間の空間」って言葉はひどいから、時間形状とか時間図式とか言えばいいのかも。時間図式にアクションでラベル付けしたものが並列フローチャート（これはプログラムそのもの）で、並列フローチャートからモデル圏への関手が実行（の記述）ってことだろう。


</body>
<comments>
<comment>
<username>salmonsnare</username>
<body>並列計算を説明するモデルの&lt;br&gt;良く用いられるものの一つとして、&lt;br&gt;並列ランダムアクセス機械 (以下、 PRAM と略記。) &lt;br&gt;と呼ばれるモデルがございます。&lt;br&gt;既存の基本的なグラフアルゴリズム &lt;br&gt;(最小スパニング木問題や&lt;br&gt;最大フロー問題に対する解法等)も、&lt;br&gt;PRAM モデルにおいて拡張した既存結果が&lt;br&gt;数多くあり、理論的な整備もかなり進んでおります。&lt;br&gt;&lt;br&gt;PRAMは、逐次計算 (直列計算のことです。) に&lt;br&gt;おける ランダムアクセス機械 (RAM) の&lt;br&gt;並列計算のための自然な拡張です。&lt;br&gt;複数の RAM が単一の共有メモリに&lt;br&gt;アクセスするようなモデルで、&lt;br&gt;全ての RAM が共有するクロックの元で&lt;br&gt;同期して動作するものです。&lt;br&gt;&lt;br&gt;もし、「CPU、メモリ、マシン（またはプロセス）などとの対応」&lt;br&gt;を意識される並列計算のモデルを探されているのでしたら、&lt;br&gt;おそらく既存のものではこれが最も近いものかと思われます。&lt;br&gt;&lt;br&gt;また、圏論からのアプローチは、&lt;br&gt;私は存じ上げないので、大変興味深く、&lt;br&gt;こちらの日記で勉強させていただいております。&lt;br&gt;&lt;br&gt;この分野の導入のための教科書として、&lt;br&gt;下記 2 点がございます。&lt;br&gt;ご参考になれば幸いです。&lt;br&gt;&lt;br&gt;[1] J. J〓J〓, An Introduction to Parallel Algorithms, &lt;br&gt;Addison Wesley Longman Publishing Co., Inc., &lt;br&gt;Redwood City, CA, USA, 1992.&lt;br&gt;&lt;br&gt;amazon.co.jp への URL: &lt;br&gt;http://www.amazon.co.jp/dp/0201548569&lt;br&gt;&lt;br&gt;[2] A. Gibbons and W. Rytter, &lt;br&gt;Efficient Parallel Algorithms, &lt;br&gt;Cambridge University Press, New York, NY, &lt;br&gt;USA, 1990.&lt;br&gt;&lt;br&gt;amazon.co.jp への URL: &lt;br&gt;http://www.amazon.co.jp/dp/0521388414</body>
<timestamp>1312276536</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>salmonsnareさん、&lt;br&gt;&gt; RAM が単一の共有メモリに&lt;br&gt;共有メモリはプログラミングが難しいので、メッセージング・ベースで考えています。&lt;br&gt;計算モデル自体は、ホーア、ミルナー、アブラムスキーあたり（その他たくさんの人）が提案しているので素材はありますが、&lt;br&gt;現実と自分の好みにあわせてチューニングするのがソレナリに面倒、という状況ですね。</body>
<timestamp>1312327911</timestamp>
</comment>
<comment>
<username>salmonsnare</username>
<body>状況について了解しました。&lt;br&gt;こちらの日記を手がかりに、引き続き勉強させていただきます。</body>
<timestamp>1312330840</timestamp>
</comment>
</comments>
</day>
<day date="2011-08-01" title="">
<body>
*1312158838*[形式言語理論][マンダラ][高次圏論]「半」の世界と、両側(半)加群

相変わらず&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20100708/1278550332&quot;&gt;マンダラ圏Mand&lt;/a&gt;を考えている。Mandの候補として、あるいはMandのひとつの見方として、非可換多元環上の両側加群の圏がよさそうだ。

実際は、非可換&lt;em&gt;半&lt;/em&gt;多元環上の両側&lt;em&gt;半&lt;/em&gt;加群の圏、全部「&lt;em&gt;半&lt;/em&gt;」が付く。

- 半体
- 半ベクトル空間
- 半可換環（可換半環）
- 半加群
- 半多元環（半代数）

引き算ができないことが「半」の意味。「半」の世界に、加法的ベキ等の世界が含まれている。「ベキ等」の世界が「半」の世界のなかでもなにか特別な地位を占めている感じだ。実際、ブール半体 {0, 1} はベキ等なので、ブール半体上で展開されるすべての議論は「ベキ等」である。

以下はすべて「半」、しかも「ベキ等」な世界での話なので、形容詞「半」「ベキ等」は省略する。

加群とは、適当な（非可換でもよい）多元環を係数とするアーベル群（実はアーベルモノイドだよ！）だとする。スカラー積は左か右に固定するが、右にしたほうが記号のツジツマはあいそうだ。基礎体は常にブール体&lt;b&gt;B&lt;/b&gt;（ほんとは半体だよ！）とする。

両側加群（bimodule, 2-sided module）は2つの多元環が作用している加群で、左スカラー乗法を*、右スカラー乗法を・とする。極めて重要なのは：

- (a*x)・b = a*(x・b)

A, Bが多元環のとき、左右のA-片側加群の全体を RMod[A], LMod[A] で示す。左右が問題にならないときは、Mod[A] と書く。(A, B)-両側加群の圏を BMod[A, B] とする。RMod[A], LMod[A], BMod[A, B] は圏であり、A, Bを動かすと、インデックス付き圏、2-圏（圏で豊饒化された圏）となる。ベースとなるのは、&lt;b&gt;B&lt;/b&gt;-多元環の圏である。RMod[A], LMod[A], BMod[A, B]に出てくる&lt;em&gt;A,Bを固定しないで全体として考えるのがミソ。&lt;/em&gt;

順番に書いているとめんどくさいから、ランダムにいく。

&lt;hr&gt;

マンダラの圏Mandでは、次の演算が必要だろう。

+ プログラム図の順次結合 「;」
+ プログラム図の排他的ユニオン 「(+)」 直和または双積
+ プログラム図の独立並列結合 「(×)」 テンソル積
+ プログラム図の同期IO結合／同期メッセージング結合 「*」 スター積
+ 模倣の結合 |

このなかで、テンソル積（独立並列結合）をモノイド積、スター積（同期IO結合）を結合としてコンパクト閉圏が作れると思っている。このとき、対象をアクションアルファベットだと思う。対象を境界集合と思うのは別な“方向”から見た場合の構造。今回は境界とかポートの問題はいったん保留。

アクションアルファベットは、点付き集合（pointed set）だと思って、直和と直積は点付き集合のなかで考える。アルファベットを&lt;b&gt;B&lt;/b&gt;係数でクリーネスター拡張するとベクトル空間であり、かつ非可換多元環となる。なお、the pointはε記号。アルファベットとアルファベットを生成元としてできた多元環を（強引に）同一視する。すると、アルファベットの圏は、体&lt;b&gt;B&lt;/b&gt;上の非可換多元環の圏と同一視できる。この圏をALとする。

AL内では&lt;b&gt;B&lt;/b&gt;係数のテンソル積が自由で作れる。テンソル積は集合の直積に対応する。有限的な操作なら代数的テンソル積で十分。ω極限を考えて完備化テンソル積を作れば、正規言語なども扱える。

適当な多元環A上の加群Sは、オートマトンと解釈できる。加群の台集合Sは状態空間Xの&lt;b&gt;B&lt;/b&gt;係数の拡張なので、S = Powf(X) となる。'f'はfiniteを意味する。'f' = finite はブランチングの濃度なので、ωブランチングなどを考えることもできる。

多元環Aの掛け算を逆順に定義した多元環をAの転置（反対、逆転、双対、共役）と呼びA&lt;sup&gt;t&lt;/sup&gt;と書く。(A, B)-両側加群は、A&lt;sup&gt;t&lt;/sup&gt;(×)B 右加群となる（A(×)B&lt;sup&gt;t&lt;/sup&gt; 左加群）。Sが(A, B)-両側加群であるとき、Sを A→B という射だと考える。形式言語理論から見ると、射Sは、トランスデューサーとも言えるし、言語関係ともいえる。関数的／動作的に見ればトランスデューサー、関係的に見れば（線形な）言語関係。

問題は圏の結合。これは、加群の非可換多元環上のテンソル積で与える。このテンソル積は、体&lt;b&gt;B&lt;/b&gt;上のテンソル積とはまったく異なる。A右加群SとA&lt;sup&gt;t&lt;/sup&gt;左加群Tに関して、S(×)&lt;sub&gt;A&lt;/sub&gt;T が定義できるが、記号はS *&lt;sub&gt;A&lt;/sub&gt; T とする。単なる（&lt;b&gt;B&lt;/b&gt;上の）テンソル積と区別してA-スター積と呼ぶ。Aが了解されていれば、単に S*T と書く。多元環Aは、右からの掛け算により、A&lt;sup&gt;t&lt;/sup&gt;左加群ともA右加群ともみなせる。Aが圏の恒等となる。

+ (S*T)*U = S*(T*U)
+ A*S = S*B = S

このスター積と普通のテンソル積がモノイド圏の公理を満たすことを確認すればよい。さらに、転置を双対としてコンパクト閉圏になるだろう。この部分はコンポネントの同期メッセージングに関する定式化だ。トレースは単位と余単位を使って構成できる。行列のトレース、テンソルの縮約と同じだ。やっぱり、トレースは隠蔽のような概念かな。

境界の問題は、アルファベットにも境界概念を入れる必要があって、アルファベットをモノイドの生成系と考えていてはダメで、圏の生成系として定式化する必要があるだろう。つまり、“「境界」を持つランクの集合”に値を取るダブルランク付きアルファベット。{0, *, 1}がランクで、0が始境界、1が終境界でとりあえずは十分だと思う。0→* が開始記号、*→1が終了記号、*→*が内部アクション。

境界の問題をちゃんとやるには、「言語＝自由モノイドの&lt;b&gt;B&lt;/b&gt;係数モノイド環」という認識ではダメで、「言語＝自由圏の&lt;b&gt;B&lt;/b&gt;係数圏環」とする。圏環（圏多元環）はあまり使わないなー、と思っていたが、ここでは使う。バキバキに使う。言語を特にプログラミング言語と解釈すると、圏環の要素はプログラムの集まりと解釈される。個々のプログラムではなくて集まりを考えるのは、足し算を可能とするため。&lt;b&gt;B&lt;/b&gt;以外の係数としては、&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;b&gt;F&lt;/b&gt;&lt;sub&gt;1&lt;/sub&gt;、あるいは確率分布を考えてもいいかもしれない。

プログラムの実行は、意味空間での経路（1次元とは限らない）を与える。ものすごくたくさんの経路に対して、なんらかの量を総和（積分）すると、振る舞いを記述する量が得られるはずだ。つまり、プログラムに関するクリーネ／ファインマン総和。ホイゲンス／フェルマー双対によると、クリーネ／ファインマン総和に対応するダイクストラ波動があるはずだ。つまり、プログラムの意味空間＝状態空間で、初期状態から広がっていく図形（波頭と掃過域）だ。

&lt;hr&gt;

とか書いているうちに、bimoduleではダメでtrimoduleとかn-moduleが必要な気がしてきた。やっぱりスパイダー計算か。スパイダーのボディに加群を書いて、脚に多元環を書けばよさそうだ。転置多元環は脚の方向を逆に描くとよい。

まだスッキリしないところが色々あるが、非可換多元(半)環の加群（非可換モノイドの&lt;b&gt;B&lt;/b&gt;係数表現）を中心にするのはいいと思う。この見方では、非可換多元環が主役で、加群は脇役になる。このコンパクト閉圏（になるとして）で、色々な計算を実行してみよう。自由多元環として圏環が出てくるのも面白い。「アルファベットもまた圏なり」というのも統一性があっていいと思う。



</body>
</day>
<day date="2011-08-02" title="">
<body>
*1312248588*[その他代数][雑感]引き算ができないと

半環係数の世界でコホモロジーはやっぱりうまくいかないな。射の核が定義はできるが意味を持たない。うまくいくためには、&lt;em&gt;まともな&lt;/em&gt;核と余核の存在が非常に重要。

そもそも、(コ)サイクルZと(余)境界Bとの「差」をとらないといけないが、引き算ができないから差のとりようがない。演算的な差じゃなくて集合論的な差という話もなくはないが。モノイドのナントカ核という概念があったような気もする（パース核？）。

足し算さえないF1上でコホモロジーが定義できれば、それは応用できるかもしれない。

*1312248931*[プログラム意味論][マンダラ]プログラムのあいだの通信とは何か？

またマンダラ圏Mandに関係するのだが、マンダラ圏では、直列結合と並列結合がある。並列結合にはテンソル積とスター積がある。並列結合＝(テンソル積+スター積) だけでコンパクト閉圏となる。

これらの演算のなかで、テンソル積は直列結合にも並列結合にも絡んでいる。対局的な性質を持つ2つの演算は、「直列結合 v.s. スター積」だろう。どちらも2つのプログラムを通信させて、全体として複合プログラムを作る演算だ。&lt;em&gt;が、&lt;/em&gt;通信の解釈が違う。時間方向での通信（逐次）、空間方向での通信（同時並行）の違い。

- 時間方向の通信＝処理の引継ぎ＝直列結合：「繋ぎ目は空間の代数＝ブール可換環」
- 空間方向の通信＝同期協調動作＝並列メッセージング結合：「繋ぎ目は時間の代数＝「アクション非可換多元環」

面白くもあり、混乱の原因ともなるのが、これらの通信方式＝「順次結合と並列メッセージング結合」は、互いにエミュレーション可能であること。2つのサブシステム（コンポネント）をブラックボックに入れて、振る舞いから時間成分を抜いてしまう（例えばS行列を取る）と、制御とデータを一気に受け渡す順次結合と、少しずつデータを渡しながら協調動作する並列メッセージング結合の差はなくなる。

直接結合の境界点に、時間的な歴史をエンコードできる。境界点はデータで境界は受け渡しデータ型だと思える。一方で、メッセージの時系列は、同時走行システムの境界要素を定義する。メッセージ時系列は時間を時間として扱っている。

*1312255853*[プログラム意味論][気付いた][トレース／コンパクト閉圏][マンダラ]アルファベットも圏であることと、ステージ付き遷移系

アルファベットも圏（の生成系）と言ったが、実例を出す。

以前から僕は、状態遷移におけるステージ（フェーズとかモードと言ってもよい）という概念を使ってきた。次の例では、4つのステージを持つ。（ネーミングは、created/disposed とか born/dead のほうがよかった。

+ beBorn
+ ready
+ working
+ disposed

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/staged-transition.gif&quot; &gt;

アクション記号は

+ init : beBorn→ready
+ begin : ready→working
+ end, cancel : working→ready
+ put(0), put(1), ..., unput : working→working
+ dispose : working→disposed

実は&lt;em&gt;間違っている。&lt;/em&gt; disposeは、ready→disposedのはずだ。これは、書き込みバッファを持ったストリームを表すオブジェクトのライフサイクルを表す。図を見れば明らかなように、ラベル付き有向グラフで、辺ラベルがアクション記号になっている。そして、頂点ラベルがステージの名前。

この有向グラフから自由圏（道の圏）を作れば圏になるから、ラベル付き有向グラフと圏はほぼ同一視してもよい。それで、ラベル付き有向グラフがアルファベットだから、アルファベットも圏となる。

アルファベット＝ラベル付き有向グラフをAとする。A→&lt;b&gt;Set&lt;/b&gt;という関手が決定性オートマトン（遷移系とオートマトンは今は区別しない）。A→&lt;b&gt;Rel&lt;/b&gt;という関手が非決定性オートマトン。値を取る圏を&lt;i&gt;C&lt;/i&gt;とすると、&lt;i&gt;C&lt;/i&gt;&lt;sup&gt;A&lt;/sup&gt; がアルファベットAのオートマトンの圏。オートマトンの圏の射は関手のあいだの自然変換になる。

アルファベット達の圏（有向グラフの圏）をDiagとすると（図式だからDiag）、A∈|Diag|に対して圏&lt;i&gt;C&lt;/i&gt;&lt;sup&gt;A&lt;/sup&gt;が対応しているからインデックス付き圏となる。

Diagの対象であるグラフは構文的な存在物とみなされる。よって、Diag内の射は構文的な変換とみなされる。Diagにいろいろな結合を入れるとマンダラ圏の構造を持つようになるだろう。つまり、Diagはプログラム図式の圏とも考えられる。

上の図で注意すべきは、ステージは単なるラベル付き頂点だが、ステージに対応するのは&lt;b&gt;Set&lt;/b&gt;または&lt;b&gt;Rel&lt;/b&gt;の対象なので、要素（点）を持つ状態空間である。beBornやreadyなどの状態空間は単元集合となる。ステージ（の記号）、単元の状態空間、状態点をシッカリ区別せよ。

アルファベットを圏（の生成系であるグラフ）と捉えただけでかなり自由度が上がるし、現実の表現にも便利、そしてマンダラ圏の構成にも近づく。

*1312256095*[プログラム意味論][気付いた][トレース／コンパクト閉圏][お絵描き]入れ子のオートマトンはトレースで実現

もう1個、絵を見ればわかる知見。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/nested-transition.gif&quot; &gt;

外側のオートマトンの遷移辺や状態点が、小さなオートマトンになっている状況、まー「入れ子のオートマトン」みたいなことだが、それはトレースで表現できる。つまり、オートマトンの圏がトレース付きなら入れ子オートマトンも自由に作れる、ってこと。


</body>
</day>
<day date="2011-08-03" title="">
<body>
*1312345780*[気付いた][マンダラ][形式言語理論]アルファベット、文、言語

ラベルの集合がアルファベットなんじゃない。&lt;em&gt;ラベル付きグラフそのものが、圏の生成系としてアルファベットなのだ。&lt;/em&gt;と、&lt;em&gt;たったそれだけのこと&lt;/em&gt;だが、これでモノの見方は変わった。

「アルファベット→圏の生成系→圏→圏多元環」という一本道により、アルファベットと圏多元環が同じものに見えてきた。圏多元環が境界としてのブール半環を持ったり、クリーネスターを持ったりもする（してもいい）。そして分解を通じて余代数にもなっているようだ（非可換性のために、双代数にはなってないかもしれない）。

次のような対応がある。

|* 形式言語理論 |* 代数 |
|アルファベット | 圏多元環の生成系 |
| 文            | 圏の射 |
| 文の連接      | 射の結合 |
| 言語          | 圏多元環の元 |
| 言語の連接    | 圏多元環の乗法（畳み込み） |
| 言語の微分(?) | 圏多元環の余乗法(?) |

適当な基礎代数系上の圏多元環の表現は加群と同じだから、加群の圏は表現の圏になる。&lt;b&gt;Set&lt;/b&gt;への表現が決定性全域オートマトン、&lt;b&gt;Partial&lt;/b&gt;への表現が決定性オートマトン、&lt;b&gt;Rel&lt;/b&gt;への表現が非決定性オートマトン。係数を通常の体にすれば、通常の線形表現も考えることができる。&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;2&lt;/sub&gt;での議論はある程度は意味を持つかも知れない。

両側加群（ニ方加群 bimodule）や三方加群（trimodule）を考えると、メッセージング入出力を持つオートマトンとなる。オートマトンの圏は、多元環の上の加群の圏だったわけだ。加群の生成系を与えるのが状態空間。生成系が標準的に付いている加群には、a |→ a(×)a で標準的な余積（分解ではなくてコピー）が入る。これである程度は代数的な構造に見通しがついてきた（かな？）。


</body>
</day>
<day date="2011-08-04" title="">
<body>
*1312419213*[気付いた][高次圏論][モノイド圏]圏の単体複体と豊饒圏構成

時間がないので短いメモ。

集合Aに対して、Aを頂点とする完全有向グラフを圏とみなしたもの（自由圏じゃない）をK(A)とする。モノイド圏Vを次元を1持ち上げて2-圏とみなしたものを同じ記号Vで書く。A上のV豊饒圏は、Φ&lt;sup&gt;0&lt;/sup&gt; : |K(A)|→{*}, Φ&lt;sup&gt;1&lt;/sup&gt; : K(A)→|V|, Φ&lt;sup&gt;2&lt;/sup&gt; : Σ&lt;sup&gt;2&lt;/sup&gt;(K(A))→V で決まる。ここで、Σ&lt;sup&gt;2&lt;/sup&gt;(K(A)) は、圏K(A)の長さ2のチェーンの全体。

これを一般化すると、Φ&lt;sup&gt;i&lt;/sup&gt;:Σ&lt;sup&gt;i&lt;/sup&gt;(C)→Σ&lt;sup&gt;i&lt;/sup&gt;(V) によって、「圏CのΦによるV-豊饒化」が定義できるはず。記号としては、C↑&lt;sup&gt;Φ&lt;/sup&gt; とかどうだろう（まー、なんでもいいが）。


</body>
</day>
<day date="2011-08-10" title="">
<body>
*1312935635*[プログラム意味論][説明][その他代数]マグマ

Σが指標で、公理が一切ないとき、指標シグマのモデルは&lt;strong&gt;Σ-マグマ&lt;/strong&gt;だ。

指標Σと公理（法則）が意外と強く（心理的に）結びついていることがあるので、マグマって概念は重要。

*1312935636*[プログラム意味論][マンダラ][その他代数]代数的プログラム意味論

TQFTとの類似を考えたプログラム意味論は幾何的プログラム意味論とでも言えるだろう。最近、代数的な定式化にも傾いている。本質は同じだけど。

|* プログラム |* 代数   |
| 状態空間    | 加群    |
| プログラム  | 多元環  |
| 状態点      | 加群の生成系  |
| インストラクション | 多元環の生成系  |
| 遷移系      | 多元環上の加群 |

境界付き遷移系を考えると、空間的境界（順次実行の両端のデータ型）がブール代数、時間的境界（メッセージングプロトコル）が非可換多元環になっている。遷移系が空間的境界（開始状態と終了状態）を持ち、時間的境界も持つなら、2つのブール代数といくつかの非可換多元環を係数域（作用団）とする加群になる。

加群の射が模倣となるのは、各種の係数域の作用と射が交換することで表現されるのだと思う。

このような観点から言うと、Kleene Algebra with Test とか Kleene Algebra with Domains とかも、ブール代数を係数域にしている加群、多元環として説明できると思う。

*1312968510*[雑記]Dotsterでドメイン更新

「DotsterのUIは相変わらずヒドイ」（http://d.hatena.ne.jp/m-hiyama-memo/20100706/1278381395）にも書いたが、今もひどい。もうアソコはやめようなか。

とりあえず記録に貼っておこう。

&lt;pre&gt;
Domain
Message
 
CHIMAIRA.ORG
Item processed successfully.
 
DAPHNIA.ORG
Item processed successfully.
 
MICROAPPLICATIONS.NET
Item processed successfully.
 
MICROAPPLICATIONS.ORG
Item processed successfully.
 
If you have any questions about this order, please contact our customer support. Please mention the following order code: order ID: 13357510
&lt;/pre&gt;

</body>
</day>
<day date="2011-08-11" title="">
<body>
*1313023166*[マンダラ][その他代数]三方加群

やっぱり、trimoduleが必要だ。R, S, T が多元環として、多元環の転置（逆、共役）を (-)&lt;sup&gt;t&lt;/sup&gt; で表すとして、R(×)S&lt;sup&gt;t&lt;/sup&gt;左加群は、R左、S右の両側加群。同様に、R(×)S&lt;sup&gt;t&lt;/sup&gt;(×)T&lt;sup&gt;t&lt;/sup&gt; とかを考えることができる。3つの多元環が作用している加群が三方加群。

三方を左R、右S、中Tと呼ぶことにする。メッセージ通信をしない遷移系は、中T加群になっている。左係数域、右係数域は自明な多元環に退化している。中係数域である、内部遷移の多元環は、空間的境界（開始状態と終了状態）でブール半環の両側係数を持つ。この状況の特殊ケースが、Kleene Algebra with Test, Kleene Algebra with Domains となる。



</body>
</day>
<day date="2011-08-12" title="">
<body>
*1313118104*[リンク][メモ] Categorical Quantum Circuits

http://arxiv.org/abs/1010.4840 Categorical Quantum Circuits が面白そう。

*1313134976*[マンダラ][雑感][プログラム意味論][インスティチューション]そういえばinterfaceを拡張しようとしていた

Command-Queryが分離した指標をメイヤー指標と呼ぶことにしよう。メイヤー指標のモデル（理論的な実装）をメイヤーオートマトンと呼ぶ。もちろん、インスティチューションになる。

いつだか忘れたが、昔、IDLの構文に、when accept xxx とか issues Event, results NewState とか、そんなキーワードを入れてinterface構文を拡張しようとしていた。今にして思えば：

+ ステージ遷移とステージ内の状態遷移を記述したかった。
+ 外部からのメッセージ（刺激、イベント）を受け取って、それをきっかけにする動作（イベントハンドリング）を記述したかった。
+ 状態遷移に伴って、外部にメッセージ（イベント）を発行することも記述したかった。
+ メッセージ／イベントの受け口や出口をポートという名前で定式化しようとしていた。

コンポネントの挙動をどっちかというと並列動作とメッセージベースで考えていたわけだ。

その後、クリーネ代数とかでしばらく直列計算を考えていたが、結局、直列計算も並列計算も両方できないとダメ。現実には、直列と並列が混じり合っているのだから。

現実には、空間的境界（データ型経由）と時間的境界（プロトコル経由）の通信を区別するのは難しい。バッファやデータ転送により、相互に変換できるから。だが、区別しないと、いつまでも曖昧なママなのだ。

やっぱり、n-セルとn-重圏が必要そうだ。



</body>
</day>
<day date="2011-08-13" title="">
<body>
*1313213963*[Caty][メモ][気付いた]hg -Iオプション

hg st や hg locate で -I . とか -I * がすごく便利。知らなかった。


</body>
</day>
<day date="2011-08-19" title="">
<body>
*1313723550*[Caty][メモ][msched]issueトラッカー

issueトラッカーを使い出すと、バグ報告以外に：

+ 掲示板
+ Q and A
+ ミニ仕様書
+ FYI（情報共有）
+ メッセージコミニュケーション
+ ToDoの備忘

などに使ってしまう。これはいい点でもあり悪い点でもある。

*1313725731*[Caty]フレームワークの比較：PerlのAmon2

http://d.hatena.ne.jp/tokuhirom/20110715/1310600765 にあったコードをCatyと比較してみる。

なんでもPerlのコードで書けてしまう、のがCatyとは対極的。アプリケーションが1ファイルで済むのは魅力的だな。

&gt;|perl|

# 設定
sub config {
    +{
        DBI =&gt; [
            &quot;dbi:SQLite:dbname=$ENV{PLACK_ENV}.db&quot;,
            '',
            ''
        ],
    }
}
||&lt;

↑は、_manifest.xjsonに相当するのだろう。

&gt;|perl|
get '/' =&gt; sub {  # / にたいする GET リクエストをフックする
    my $c = shift;
    return $c-&gt;render('index.tt'); # index.tt を描画してかえす
};

post '/create' =&gt; sub { # /create にたいする POST リクエストをフックする
    my $c = shift;
    my $src = $c-&gt;req-&gt;param('url') || return $c-&gt;redirect('/');

    my $key = sub {
        # dup check
        {
            my $key = $c-&gt;dbh-&gt;selectrow_array(q{
                SELECT key FROM tinyurl WHERE url=? LIMIT 1
            }, {}, $src);
            return $key if $key;
        };
        # create new one.
        {
            my @chars = ( 'A'..'Z', 'a'..'z', '0'..'9' );
            my $key;
            for (1..6) {
                $key .= $chars[int rand @chars];
            }
            $c-&gt;dbh-&gt;do(q{INSERT INTO tinyurl (key,url) VALUES (?, ?)}, {}, $key, $src);
            return $key;
        }
    }-&gt;();
    return $c-&gt;render('result.tt', {tinyurl =&gt; $c-&gt;req-&gt;base . 'g/' . $key});
};

get '/g/{key}' =&gt; sub {
    my ($c, $args) = @_;
    my $key = $args-&gt;{key} || die &quot;oops&quot;;
    my $url = $c-&gt;dbh-&gt;selectrow_array(q{
        SELECT url FROM tinyurl WHERE key=? LIMIT 1
    }, {}, $key);
    if ($url) {
        warn $url;
        return $c-&gt;redirect($url);
    } else {
        return $c-&gt;res_404();
    }
};

||&lt;

↑は、actions/ の下のファイルに相当。

&gt;|perl|
builder {
    enable 'Plack::Middleware::Static',
        path =&gt; qr{^(?:/static/|/robot\.txt$|/favicon.ico$)},
        root =&gt; File::Spec-&gt;catdir(dirname(__FILE__));
    enable 'Plack::Middleware::ReverseProxy';

    __PACKAGE__-&gt;to_app();
};

||&lt;

builderウンヌンはオマジナイですね。

&gt;|perl|
__DATA__

@@ index.tt
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;met charst=&quot;utf-8&quot;&gt;
    &lt;title&gt;TinyURL&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;tinyurl&lt;/h1&gt;
    &lt;form method=&quot;post&quot; action=&quot;/create&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;tiny!&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

@@ result.tt
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;met charst=&quot;utf-8&quot;&gt;
    &lt;title&gt;TinyURL&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;tinyurl&lt;/h1&gt;
    &lt;div&gt;[% tinyurl %]&lt;/div&gt;
    &lt;a href=&quot;/&quot;&gt;back to top&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
||&lt;

↑がいいなー。ソース内にリソースを書いてしまう。ファイルシステムに書く必要がない！ 素晴らしい。

&lt;b&gt;[追記]&lt;/b&gt; 
Catyの場合、

- コマンドはアリモノを使うとしても、アクションファイルが必要。アクションファイルの書き方がCatyScriptだから、ここでCatyScriptを学ぶ必要がある。
- アクション内にテキストも書けるが、長いテキストは辛い。が、アクションファイル内にデータを書く手段がないので、includeの下にファイルが必要。

しょうがないことだとも言えるが、ナニカ考えたほうがいいかもしれない。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2011-08-20" title="">
<body>
*1313808218*[映画]モンスターズ/地球外生命体

次のような概要：

&gt;&gt;
- 94分
- 分野: パニック
- 監督: ギャレス・エドワーズ 
- 出演者: スクート・マクネイリー, ホイットニー・エイブル 

製作費130万円で作られ、その品質の高さとセンスのよさが海外で評判になったSF映画。NASAの探査機が地球外で採取した生命体がメキシコで繁殖。その危険地帯を縦断するはめになった男女の運命を描き出す。監督のギャレス・エドワーズは、本作の成功で新たなハリウッド版『GODZILLA』の監督に抜擢された。
&lt;&lt;

「シアターN渋谷」で見た。

低予算だという予備知識があったのでフラストレーションはなかったが、モンスターは&lt;em&gt;ショボい&lt;/em&gt;。タコに似た巨大生物だが、夜の闇でしか出現しない。あとは死体の一部が出るだけ。

パニックとかアクションの映画ではなくて、むしろロードムービー。メキシコを男女が旅をする。それが、危険地帯からの脱出という体裁をとっている。この二人のラブストーリーにもなっている。冴えないカメラマンと彼の新聞社の社長令嬢という組み合わせ。

パニック映画って、だいたいは大予算のスペクタクルだから、そういうのを期待するとヒドイ映画って評価になってしまうが、ちょっと変わったラブストーリーとしては悪くない。けっこう良かった。

*1313808773*[Caty][メモ][msched]issueトラッカーの終了状態

終了状態はいろいろあって：

- バグがなおった
- バグがなおらないであきらめた
- 議論が集結して結論が出た
- 議論が発散してなんだかわかんなくなった
- 仕様がまとまった
- 仕様が却下された
- 情報が周知した
- 情報が無視された
- 情報が古くなって無意味化した

issueトラッカーは、こういう終了状態をちゃんと区別して、それぞれにふさわし終了処理をしないとダメだと思う。

</body>
</day>
<day date="2011-08-23" title="">
<body>
*1314081074*[Caty][メモ]PyGraphviz

事実上、AGraphってクラスだけ。http://networkx.lanl.gov/pygraphviz/reference/agraph.html

メモしておくが、&lt;em&gt;まだメチャクチャ&lt;/em&gt;。後で整理する。
&lt;b&gt;[追記 date=&quot;2011-09-02&quot;]&lt;/b&gt; &lt;em&gt;後で整理とか言っているあいだに、鍬田くんはPyGraphvizが使えるようになり、僕は使い方がよくわからないまま。もういいや。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;
- 表現データ

&lt;pre class=&quot;code&quot;&gt;
  {始点1 : {終点1-1 : None, 終点1-2 : None, ...}, 始点2 : ...}
&lt;/pre&gt;
または、
&lt;pre class=&quot;code&quot;&gt;
  {始点1 : [終点1-1, 終点1-2, ...], 始点2 : ...}
&lt;/pre&gt;
- クエリー

+ G.nodes()
+ directed
+ edges(nbunch=None, keys=False)
+ get_edge(u, v, key=None)
+ get_name()
+ get_node(n)
+ has_edge(u, v=None, key=None)
+ has_neighbor(u, v, key=None)
+ has_node(n)
+ is_directed()
+ is_strict()
+ is_undirected()
+ number_of_edges()
+ number_of_nodes()

- グラフの生成

+ filename=
+ string= DOT形式の記述
+ data= 表現データ
+ handle= Swig pointer to an agraph_t data structure
+ copy() Return a copy of the graph.

- グラフの種類設定

+ name 名前やID
+ directed
+ strict -- 多重辺を許さない

+  B=A.acyclic(copy=True) 

Graphviz属性がメチャクチャいっぱいある。http://www.graphviz.org/doc/info/attrs.html

- 表示（文字列化）

+ string()
+ to_string()

- 追加

+ 頂点 add_node(u)
+ 辺 add_edge(u, v) G.add_edge('a','b','first') G.add_edge(u'a',u'b',color='green')
+ 道 add_path(nlist)
+ 辺の集まり add_edges_from(elist) G.add_edges_from(elist, color='green')
+ サイクル add_cycle(nlist)

- 変更

+ graph_attr.update(landscape='true',ranksep='0.1')
+ node_attr.update(color='red')
+ edge_attr.update(len='2.0',color='blue')

- 削除

deleteとremoveの違いがわからん。

+ clear()
+ delete_edge(u, v=None, key=None)
+ delete_edges_from(elist)
+ delete_node(n)
+ delete_nodes_from(nbunch)
+ remove_edge(u, v=None, key=None)
+ remove_edges_from(ebunch)
+ remove_node(n)
+ remove_nodes_from(nbunch)

- ファイルIO

+ read(path) Read graph from dot format file on path. path can be a file name or file handle
+ write(path=None)

- レンダリング 

+ layout(prog='neato', args='') Assign positions to nodes in graph.  
+ A.layout(prog='dot')
+ draw(path=None, format=None, prog=None, args='')

- その他の操作

+ tred(args='', copy=False)
+ reverse() Return copy of directed graph with edge directions reversed.



</body>
</day>
<day date="2011-09-02" title="">
<body>
*1314950644*[映画]トランスフォーマー／ダークサイドムーン 

ちょっと前、夏休みのあいだ：

シリーズ3作目、たぶんこれで最後らしい。もはや当たり前の感じもする3D。長男と見に行った。次男は3Dが嫌いなのと、以前テレビ東京でやっていたアニメの印象が強いらしく「別に見たくない」ということだった。サッカーの練習もあったし。

スピルバーグファン（監督はマイケル・ベイだが）の僕は、最初のトランスフォーマー（2007年）のときも子供たちを誘ったが、二人とも乗ってこなくて、一人で見に行った。このとき、シャイア・ラブーフを知った。彼、後で「インディ・ジョーンズ/クリスタル・スカルの王国」にも出ていた、ハリソン・フォードの子供の役で。

主人公サムの恋人カーリー役のロージー・ハンティントン＝ホワイトリーさんは美人でエロい。（第1作の恋人のミーガン・フォックスのイメージがあんまり残ってないなー。) 女性軍人のシャーロット・メアリング役のフランシス・マクドーマンドさんもいい味出していました。

悪役のメガトロンは今回さえなかった。活躍したヒールはショックウェーブ。

映画のなかに、軍のムササビ飛行隊みたいなのが出てくる。編隊を組んで、ビルのあいだを何の道具もなしに飛んでいく（落ちて行く）。映像はなかなかのものだったが、どうせCGなんだろうと思って見ていたら、なんとこれは実写だった、スゲー。えらい手間隙かけて撮ったらしい。

CGでなんでも出来るようになってくると、すごい映像を見ても「どうせCGでしょ」と思ってしまう。悲しい事だ。

</body>
</day>
<day date="2011-09-07" title="">
<body>
*1315352787*[用語法][圏一般論][Mx]アーベル圏がらみの概念

とある論文での用語法：

- プレ加法的 -- Ab豊饒 と同じ
- 加法的 -- 有限直和と任意の直積が存在する。始対象と終対象も含まれる。
- プレアーベル -- 加法的で、ゼロ対象があり、すべての射が核と余核を持つ。
- アーベル -- すべてのモノが核、すべてのエピが余核になる。

「プレ加法的」なんて言葉はいらんでしょう。加法的の任意の直積が存在するはかなり強いなー、ほんとに必要なのか？ そこまでは要らんと思うが。



</body>
<comments>
<comment>
<username>msakai</username>
<body>s/集対象/終対象</body>
<timestamp>1315435635</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>ありがとうございます。</body>
<timestamp>1315437608</timestamp>
</comment>
</comments>
</day>
<day date="2011-09-13" title="">
<body>
*1315881554*[モノイド圏][論理]シーケントとスパイダー計算

スパイダー計算 ＝ シーケント計算の絵算版 ですな。

スパイダーは多圏または複圏の射だけど、一般の多圏／複圏を考えるのではなくて、ベースとなるモノイド圏&lt;i&gt;C&lt;/i&gt;の上でスパイダーを考える。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20100722/1279761492&quot;&gt;マニンのファインマン図の用語法&lt;/a&gt;を使うなら、スパイダーはカローラになる。1個の頂点とフラグの集合だ。が、有向グラフなので、フラグは有向半辺となる。入力ワイヤー群と出力ワイヤー群に完全に分かれる。&lt;strong&gt;有向カローラ&lt;/strong&gt;と呼ぶべきか？

&lt;i&gt;C&lt;/i&gt;が2つのモノイド積を持つ圏とする。ただし、2つの積が一致していてもよい（コンパクトなケース）。有向カローラがあるとき、頂点に&lt;i&gt;C&lt;/i&gt;の射、有向フラグに&lt;i&gt;C&lt;/i&gt;の対象を割り当てた図形がスパイダー。次の条件（意味論条件）を満たす。

- 入力フラグのラベルすべてに渡る第一モノイド積は、射の域になっている。
- 出力フラグのラベルすべてに渡る第ニモノイド積は、射の余域になっている。

コンパクトなケースでは、タングルの計算に近いが、非コンパクト（2つの積が異なるとき）は古典論理のシーケント計算に近くなる。スパイダーの全体が、スパイダー計算によりどんな圏（多圏、複圏）になるか？が最初の問題。ステファネスクの基本定理（ネットワークの圏に値を取るネットワークの全体は再びネットワークの圏になる）と同じスタイルの基本定理が成り立つとうれしい。

*1315882153*[モノイド圏][論理][プログラム意味論]フェンス付きシーケント／スパイダー計算

スパイダー計算をマジメにやったほうがいいなと思うのは、「例外＆環境付き計算」の計算の道具にフェンス付きシーケント計算というのを思いついたが、これはフェンス付きスパイダー計算のほうが分かりやすそうだからだ。

入力ワイヤー群と出力ワイヤー群は1次元に並んでいて、その並びにフェンスと呼ぶ仕切りがある。この仕切の位置が重要な意味をもつ。フェンスの移動によるワイヤー配置換えが、インデックス付き圏では、ファイバー圏を（水平方向に）移動することになる。



</body>
</day>
<day date="2011-09-14" title="">
<body>
*1315960430*[モノイド圏][論理][プログラム意味論]スパイダー計算の守備範囲

次は対象にしたい。

+ ペンローズ／カウフマンの図式テンソル計算
+ イエッターの圏ラベル付きタングルの計算
+ 何種類かのシーケント計算
+ 非可換多元環上のn方加群の計算

最後の加群の計算はスパンになるので、テンソル計算とはまったく別物かもしれない。統合できればうれしいけど。

*1315961812*[その他代数][圏一般論][プログラム意味論]森田同値

森田の定理（Morita theorem）がどんな主張かはじめて知った。

可換とは限らない環A、Bがあるとき、左加群の圏 A-Mod, B-Mod が圏同値であるとき、AとBは森田同値という（定義）。森田同値が、多元環の同型から導かれるとは限らない。森田同値の具体的な姿を明らかにしたのが森田の定理。

(B,A)-双加群（両側加群）Mで次の条件を満たすものを考える。

+ B左加群として有限生成
+ B左加群として射影的

このような双加群と森田同値の集合は1:1に対応する。ここで、森田同値は「加群圏の関手対と自然変換の組」と考える。加群の射影性は、完全列とかHomとか使わなくても「自由加群の直和成分」として定義できる。

B-Modのなかで、有限生成射影加群はけっこうあるだろう。問題は、それがAの左加群構造を許容するかどうか。A左加群になるなら、それが森田同値を与える。

具体的な、関手の形は、N |→ M(×)&lt;sub&gt;A&lt;/sub&gt;N  というAテンソル積を使う。

これはプログラム意味論に使えそうだ。A-Modとは、CPUアーキテクチャ（インストラクションセット）がAであるコンピュータの全体と思ってよい。つまり、加群の圏は、コンピュータの圏／計算処理の圏となる。AとBが森田同値なら、2つのCPUアーキテクチャのよる計算には実質的な差がないことになる。森田同値でCPUを分類すれば、本質的な計算能力／計算の可能性による分類になるだろう。


</body>
</day>
<day date="2011-09-15" title="">
<body>
*1316046120*[その他代数][圏一般論][プログラム意味論]続・森田同値

森田の定理って1958年に発表されていたのか。古いんだなー。

森田同値や、それを実現する森田双加群（morita bimodule）の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110810/1312935636&quot;&gt;代数的プログラム意味論&lt;/a&gt;での対応物があるはずだと思う。

ほんとのところ、環と加群ではなくて（非可換）半環と半加群だから、アーベル圏的な議論はほとんど通用しない。証明もそのまま使えないだろう。だが、現象の類似性はあるように思える。双模倣やトランスデューサーを使って定式化できると予想される。

アーベル圏なしで森田同値が定義できれば、アーベル圏が使えない状況に対する処方とヒントが得られるかも知れない。森田同値をある種のホモトピー同値として捉えられたりすると「とても良い」のだが、それは妄想だろうな。

*1316052133*[caty-depl]サーバ設定、デーモンの起動など

またもサーバ環境を作らねばならない。ううううう、やだーー。

iptablesに関しては次に悪口が書いてあるが、悪口言っても役に立たないな。

- http://d.hatena.ne.jp/m-hiyama-memo/20100202/1265070159
- http://d.hatena.ne.jp/m-hiyama-memo/20100205/1265356917

vsftpの設定は日記内検索で出てくるが、起動が書いてない。意外と起動でとまどう。

&lt;pre class=&quot;out&quot;&gt;
# /etc/rc.d/init.d/vsftpd start
&lt;/pre&gt;

でもいいが、serviceを使うこともできる。

&lt;pre class=&quot;out&quot;&gt;
# service vsftpd start
Starting vsftpd for vsftpd:                                [  OK  ]

# service vsftpd status
vsftpd (pid 12165) is running...

&lt;/pre&gt;

chkconfigで自動起動の設定もできる。

&lt;pre class=&quot;out&quot;&gt;
# chkconfig --list vsftpd
vsftpd          0:off   1:off   2:off   3:off   4:off   5:off   6:off
&lt;/pre&gt;

これは設定されてない。# chkconfig vsftpd on で、

&lt;pre class=&quot;out&quot;&gt;
# chkconfig --list vsftpd
vsftpd          0:off   1:off   2:on    3:on    4:on    5:on    6:off

&lt;/pre&gt;

番号はランレベルなので、ランレベル2, 3, 4, 5 でon。

*1316075308*[caty-depl]サーバ設定の準備メモ

いいかげんサーバー設定しないと。イヤなことはいくらでも先延ばしにしてしまうな。

+ dotsterでドメインの状態を確認
+ さくら管理画面でドメインの一部を張り替える、ドメインの利用料金はDNSサーバーの料金だろうからたぶん変更なし。
+ 新サーバのドメインが行き渡るまでは生のIPアドレスでアクセスして設定
+ https://secure.sakura.ad.jp/vpscontrol/ にIPアドレスとルートパスワードを入れるとコンパネ操作ができる。
+ SSHは	sshd（22/tcp）
+ www4054uc.sakura.ne.jp という名前が前もってあたえられていて、nslookup で引けることは引ける。
+ pingは跳ねられるようだ。


</body>
</day>
<day date="2011-09-16" title="">
<body>
*1316128040*[その他代数][圏一般論][プログラム意味論][マンダラ]続々・森田同値

「森田同値は役に立ちそうだ」は僕の勘と思い込みだから、まったくの間違いである可能性がある。が、とりあえずはいい目標が出来た。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110810/1312935636&quot;&gt;代数的プログラム意味論&lt;/a&gt;のなかで森田の定理を再現したい。つまり、森田同値と森田双加群の1：1対応を作りたい。

森田同値は、CPUの計算能力が同じことだと思えばよい。森田双加群は、トランスデューサーとかエミュレーターだろう。だから、森田の定理は双模倣の特徴づけのようなものだと思う。

森田同値は双圏で考えるのが自然だが、二重圏でもたぶんいけるだろう。となると、マンダラとも関係する。

*1316155861*[雑感][リンク]マニン

マニン（Yuri I. Manin）つうジイサマは、ほんとに凄い！

- http://arxiv.org/find/math/1/au:+Manin_Y/0/1/0/all/0/1

</body>
</day>
<day date="2011-09-17" title="">
<body>
*1316248421*[形式言語理論][圏一般論][プログラム意味論]森田同値：対応関係

|* 森田理論  |*  プログラム理論 |
|体          | 二値ブール代数   |
|（可換）環  | ブール代数 |
|多元環      | 言語の代数 |
|加群        | オートマトン |
|双加群      |トランスデューサー|
|双積        | OR結合 |
|テンソル積  |並列入出力結合 |
|加群射      | オートマトン射 |
|双加群射    | トランスデューサー射|

*1316248662*[形式言語理論][圏一般論][プログラム意味論]森田同値：射影生成子

森田理論では、射影生成子（progenerator）という概念が極めて重要。&lt;i&gt;C&lt;/i&gt;が&lt;i&gt;V&lt;/i&gt;豊饒圏だとして、&lt;i&gt;C&lt;/i&gt;の対象Pが射影生成子とは、

+ Pは&lt;i&gt;C&lt;/i&gt;の生成子（generator）である。
+ Pは&lt;i&gt;C&lt;/i&gt;の射影的対象（projective object）である。
+ Pは有限生成である。

これらは圏論（豊饒圏論だけど）の概念で次のように定義できる。

+ generatorって用語がダメだって話が出る割には結局使われている。&lt;br&gt;対象Xが生成子とは、f, g:A→B、f≠g ならば a:X→A、a;f ≠ a;g となるaがあること。Xからの射の全体 &lt;i&gt;C&lt;/i&gt;(X, -) によって、射の等値性が判断可能であることを意味する。僕の感覚だと、Xは点の役割を演じる、あるいは部分的（partical）ではない対象。non-partical objectってのがピッタリかと。
+ Pが射影的とは、Pから決まる共変ホム関手 &lt;i&gt;C&lt;/i&gt;(X, -) = Hom(X, -) : &lt;i&gt;C&lt;/i&gt;→&lt;i&gt;V&lt;/i&gt; がエピをエピに移すとき。エピ性を保つといってもいい。
+ Pが有限生成とは、コンパクトの定義と同じ。(f&lt;sub&gt;i&lt;/sub&gt;:X&lt;sub&gt;i&lt;/sub&gt;→P | i∈I) がモノ射（部分対象と思ってよい）の族で、jointly epic ならば、有限集合 J⊆I が取れて、やっぱり jointly epicにできる。圏に位相を入れてのコンパクトだと思えばいいだろう、たぶん。

生成子は分離子ということもある。射影生成子は、コンパクト分離的射影対象ということになる。特筆すべきは、アーベル圏でなくても定義できることだろう。任意の圏は&lt;b&gt;Set&lt;/b&gt;豊饒圏だから、&lt;i&gt;V&lt;/i&gt;豊饒の条件は一般性を損なわない。任意の圏において、射影生成子を考えることができる。

圏&lt;i&gt;C&lt;/i&gt;が半加法的であれば、&lt;i&gt;C&lt;/i&gt;は可換モノイドの圏&lt;b&gt;AbMon&lt;/b&gt;で豊饒圏となる。射影生成子Pの自己ホムセットは、&lt;b&gt;AbMon&lt;/b&gt;上でモノイドとなるから、半環となる。End(P) = &lt;i&gt;C&lt;/i&gt;(P, P) も森田理論で使われる。

森田理論は強くアーベル圏に依存しているわけではなく、双圏の2-同値を使ったりするので、プログラム意味論に翻訳しやすいと思う。


</body>
</day>
<day date="2011-09-20" title="">
<body>
*1316476634*[メモ][雑感]米田と森田

米田の補題は次の論文らしい：

- Yoneda, N. &quot;On the Homology Theory of Modules&quot; J. Fac. Sci. Univ. Tokyo, Sect.I.7 (&lt;b&gt;1954&lt;/b&gt;), 193-227

それで、森田同値、森田の定理は：

- Kiiti Morita. &quot;Duality for modules and its applications to the theory of rings with minimum condition&quot; Sci. Rep. Tokyo Kyoiku Daigaku Sect. A, 6:83-142, &lt;b&gt;1958&lt;/b&gt;.

ようするに、もう半世紀以上が経過している、と。

*1316483265*[形式言語理論][その他代数]FLT（formal-language-theoretic）代数

AがFLT代数だとは：

+ 加法的ベキ等な（可換とは限らない）環である
+ 加法から決まる順序に対してω完備である。これをω-ISRと呼ぶ。
+ 順序に関して原子的、乗法に関して素な元の全体（atomic primes）が、ω-ISRとしての生成系になっている。

零因子を持たないことは、順序の議論から出る。

ω-ISRの圏と、自由生成と忘却関手の随伴性は最初に定義しておかないといけないな。


</body>
</day>
<day date="2011-09-21" title="">
<body>
*1316565635*[形式言語理論][プログラム意味論][気付いた]オートマトン、余オートマトン、文法

オートマトンを形式言語（列言語）の代数の上の左加群とみなす。言語の代数をAとして、a∈Aによる左作用 a・s を次のように解釈する。

- s'∈(a・s) ⇔ input a may-cause transiton s--&gt;s'

通常のオートマトンを受動的オートマトンと呼ぶ。つまり、オートマトンは受理器という解釈。

Aの右加群に対して、a∈Aによる右作用 s・a を次のように解釈する。

- s'∈(s・a) ⇔ transiton s--&gt;s' may-emit output a 

右加群を余オートマトン、または能動的オートマトンと呼ぶ。余オートマトンは生成器という解釈。余オートマトンはまた、文法と解釈してもよい。文法は生成器を与えるから。

受理機と文法の同等性は、左加群と右加群の同等性により解釈できる。さらに、トランスデューサーは双加群と解釈し、入出力の同期結合は右加群と左加群のテンソル積と解釈できる。

代数（多元環）Aを固定して、左加群射＝オートマトン射、右加群射＝余オートマトン射、双加群射＝トランスデューサー射などを考えると、これはラベル付き遷移系の双模倣と同じ定義になるはずだ。

多元環の定義で、「生成系＋関係」による定義があるが、生成系＝指標、関係＝制約、となる。指標＋制約＝仕様＝セオリーだから、仕様（セオリー）の圏は多元環の圏であり、それに対するモデルの圏は、多元環上の加群の圏となっていると思ってよい。インスティチューションがインデックス付き圏の形をしているのは、多元環上の加群の圏とも解釈できるからだろう。

*1316569424*[形式言語理論][プログラム意味論][雑感]双圏で解釈する森田の定理

レイチェル・ブラウワー（Rachel Brouwer）の流儀（彼女がオリジナルとは違うかもしれないが）で森田の定理を解釈すると、一部（ごく一部だが）は定義からほぼ自明になる。一般化しても森田定理（Morita Theorem）のキモの部分は再現できないが、地勢を見るには一般化もある程度有効だろう。

&lt;i&gt;B&lt;/i&gt;が双圏だとして、&lt;i&gt;B&lt;/i&gt;の対象（0セル）をA, Bなど、&lt;i&gt;B&lt;/i&gt;の水平射（1セル）をf, gなど、&lt;i&gt;B&lt;/i&gt;の垂直変換（2セル）をα、βなどで表す。

双圏&lt;i&gt;B&lt;/i&gt;の対象A, Bが同値（同型ではなくて、2-同値）だとすると、f:A→B, g:B→A があって、互いにip-to-isoで逆となる。このとき、ホム圏 &lt;i&gt;B&lt;/i&gt;(X, A) と &lt;i&gt;B&lt;/i&gt;(X, B) が圏同値となる。もすこし一般的には、ホム圏 &lt;i&gt;B&lt;/i&gt;(A, B) と、外から見た関手圏 Func(&lt;i&gt;B&lt;/i&gt;(X, A), &lt;i&gt;B&lt;/i&gt;(X, B)) に関手が定義できる。森田の定理では、&lt;i&gt;B&lt;/i&gt;(A, B) → Func(&lt;i&gt;B&lt;/i&gt;(X, A), &lt;i&gt;B&lt;/i&gt;(X, B)) の（外から見ての）圏同値を構成することになる。

&lt;i&gt;B&lt;/i&gt;(A, B) → Func(&lt;i&gt;B&lt;/i&gt;(X, A), &lt;i&gt;B&lt;/i&gt;(X, B)) の向きは簡単だが、Func(&lt;i&gt;B&lt;/i&gt;(X, A), &lt;i&gt;B&lt;/i&gt;(X, B)) → &lt;i&gt;B&lt;/i&gt;(A, B) は難しい。単に一般的な議論をしてもうまくいかない。

森田定理はやはり、多元環と加群の文脈でないと構成できない。ただし、「多元環」と「加群」をめいっぱい一般化することはできそう。必要な概念は、Mが加群であるとき、End(M) が多元環とみなせること。つまり、End(-)が加群と同型の亜群から多元環の圏への関手として定義できるような状況があればいい。

係数多元環Rとプロジェネレータ（有限生成で射影的な分離的対象）Pに対して、RとEnd(P)の同型の存在を仮定するので、プロジェネレータとEnd多元環を共通に比較できる場所が必要。

これらのことを考えると、多元環を作るためのベースの圏と、同じベースによる豊饒圏の枠組みは必要だろう。また基礎環の取り換えのような操作も必要なので、インデックス付き圏（ファイバー圏）も必要だと思われる。

ベースの圏を、ベキ等可換モノイドにとれば、ISR上の加群の話になるだろう。そうすると、いちいち「半」とか付けるのをやめて、ベースを固定して、その上での「環」「多元環」「加群」という言葉を使える。それで、それぞれのベースの圏ごとに「森田定理」が示せる可能性がある。まっ、実際はそう話が簡単じゃないだろうが。

&lt;b&gt;[追記]&lt;/b&gt;なんか、集合圏ベースの森田の定理は出来そうな気がするな。勘違いでなければ。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2011-09-24" title="">
<body>
*1316833253*[形式言語理論][プログラム意味論]集合圏で森田の定理

&gt;&gt;
なんか、集合圏ベースの森田の定理は出来そうな気がするな。勘違いでなければ。
&lt;&lt;

集合圏が一番簡単なのではなかろうか、と思ったがそうでもない。

森田理論は、どうやら本質的に多元環と加群の理論らしい。「多元環（代数）と加群」という概念がないとうまく進まない。とはいえ、集合圏に近い圏でもなんとかなるようは気はしている。ようするに、「多元環（代数）と加群」をメイッパイ拡張するやり方。

いずれにしても、「集合圏なら簡単」とはならない。

森田定理が成り立つ条件というか状況としては、テンソル積の概念があって、テンソル積を横結合（水平結合）とする双圏が作れること。それと、非可換な乗法を持つ代数系としてのモノイド概念は必須のようだ。どんな圏であってもEnd(A)がモノイドになることを本質的に利用している。

ここでの（広義の）多元環とは、いろいろな圏におけるモノイド対象のこと。同じベース圏への多元環（代数、モノイド）の表現が加群。森田理論は抽象的モノイドとEnd(A)を比較するような理論じゃないかと思う。森田同値という同値関係のベースに森田順序とでも呼ぶべき順序関係があるような気がする。森田同値は圏同値に対応するが、森田順序はおそらく圏の埋込みに対応するのだろう。

&lt;b&gt;[追記]&lt;/b&gt;森田同値ってすごく荒っぽい分類かと思っていたが、そうでもないような気がしてきた。森田コンテキストを作って、αペアリングとβペアリングを作って、isoになるか？ とか見ると、なかなかisoにならない感じがする。具体的に森田双加群＝森田水平射を作るのは難しそうだ。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;b&gt;[追記]&lt;/b&gt; 集合Xに対する有限ベキ集合Powfin(X)をブール可換半環上のベクトル空間だと思って、この線形代数を基本とした多元環と加群を考えるのが楽のようだ。形式言語理論で言えば、正規表現以前で有限言語だけを考えるレベル。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2011-09-26" title="">
<body>
*1316992601*[形式言語理論][プログラム意味論][雑感]オートマトンの森田の定理

いやー、&lt;em&gt;むずかしい&lt;/em&gt;、難しい。

オートマトンを加群と考えるのは、ポリシー／指導原理としてはいいと思うが、具体的な定義では対応がつかない。双加群（両側加群）の (ax)b = a(xb) という結合律が、双オートマトン＝トランスデューサと考えると&lt;em&gt;まったく成立しない&lt;/em&gt;。この等式は結合律の形をしているが、実質は交替律だ。時間順序がある計算では成立しようがない。極めて空間的な対称性なのだ。

入出力ではなく、ペア（タプル）インストラクションが作用するオートマトンを考えれば作用の結合律を温存できる。しかし、直交して相互作用しない複数のインストラクションセットが働くオートマトンつうのはそれほど考えやすくない。入出力結合の二重圏モデルも捨てがたいものがある。

&lt;em&gt;タプルインストラクションが働く状態空間と、入出力を持つオートマトンはまったくの別物&lt;/em&gt;として扱い、なんらかの条件を付けて同一視するのかもしれない。

ともかくも、枠組みとして使えるのは次のことだろう。

+ 全体として双圏または二重圏がある。
+ 構文的なモノイドまたは圏がインストラクションの代数としてあり、それは0セルとなる。
+ インストラクションが作用する状態空間としてのオートマトンがある。
+ オートマトンAは、双圏&lt;i&gt;B&lt;/i&gt;内の自明な0セル&lt;b&gt;1&lt;/b&gt;に対するホム圏 &lt;i&gt;B&lt;/i&gt;(A, &lt;b&gt;1&lt;/b&gt;) の射である。自明な0セル（対象）の定義は自明じゃない。
+ 一般的なホム圏 &lt;i&gt;B&lt;/i&gt;(A, B) の射は、双オートマトンである。が、双オートマトンの定義が不明。
+ 双加群のテンソル積に類似したスター積があり、これが双圏（または二重圏）の横結合を与える。双オートマトンはスター積で結合できる。
+ 双オートマトン射が縦変換＝2セルを与える。これは模倣や双模倣だと思われる。
+ オートマトン射は双オートマトン射の特殊なものである。
+ &lt;i&gt;B&lt;/i&gt;(A, A) にはスター積に関して単位となる I&lt;sub&gt;A&lt;/sub&gt; という双オートマトンがある。
+ 双オートマトンの縦同型＝2同値＝自然同値 が定義できる。
+ 双オートマトンのスター結合とI&lt;sub&gt;A&lt;/sub&gt;と自然同値を使って、0セル＝インストラクションセットのアイレンベルグ／ワッツ（Eileburg-Watts）同値を定義できる。これは、圏の圏同値と同じ概念。
+ オートマトンの圏の圏同値を使って森田同値を定義できる。

森田理論は、森田コンテキストとHom, End関手を使いまくることにより、アイレンベルグ／ワッツ（Eilenberg-Watts）同値と森田同値の1:1対応を示す。また、アイレンベルグ／ワッツ同値を与える双オートマトンを具体的に構成する。関手からprogeneratorオートマトンを作る手順が必要。

Rがインストラクションモノイドとして、Pがprogeneratorオートマトンのとき、P&lt;sup&gt;*&lt;/sup&gt;(×)&lt;sub&gt;R&lt;/sub&gt;P = &lt;i&gt;B&lt;/i&gt;(P, P) のような同型が成立するはずだが、、、？？


</body>
</day>
<day date="2011-09-27" title="">
<body>
*1317082637*[リンク][高次圏論]森田と米田をあわせると

ニルス・ジョンソン（Niles Johnson）が、森田と米田（森田定理と米田補題）の統合を試みている。→ http://arxiv.org/abs/0805.3673

ニルス・ジョンソンの個人サイト：http://www.nilesjohnson.net/
</body>
</day>
<day date="2011-09-29" title="">
<body>
*1317283380*[caty-depl][メモ][リンク]サーバー設定で苦しんだ記録のリスト

ドメインとWebサーバー（nginx）関係

- http://d.hatena.ne.jp/m-hiyama-memo/20110915/1316075308
- http://d.hatena.ne.jp/m-hiyama-memo/20110810/1312968510
- http://d.hatena.ne.jp/m-hiyama-memo/20100426/1272238234
- http://d.hatena.ne.jp/m-hiyama-memo/20100413/1271148592
- http://d.hatena.ne.jp/m-hiyama-memo/20100220/1266642253
- http://d.hatena.ne.jp/m-hiyama-memo/20100219/1266539224
- http://d.hatena.ne.jp/m-hiyama-memo/20100218/1266465636
- http://d.hatena.ne.jp/m-hiyama-memo/20100218/1266486037
- http://d.hatena.ne.jp/m-hiyama-memo/20100212/1265944168
- http://d.hatena.ne.jp/m-hiyama-memo/20100212/1265939469
- http://d.hatena.ne.jp/m-hiyama-memo/20100201/1264982756
- http://d.hatena.ne.jp/m-hiyama-memo/20100201/1264982931
- http://d.hatena.ne.jp/m-hiyama-memo/20100123/1264232430
- http://d.hatena.ne.jp/m-hiyama-memo/20100122/1264147649

FTP（vsftpd）関係

- http://d.hatena.ne.jp/m-hiyama-memo/20110915/1316052133
- http://d.hatena.ne.jp/m-hiyama-memo/20100210/1265757939
- http://d.hatena.ne.jp/m-hiyama-memo/20100210/1265769680
- http://d.hatena.ne.jp/m-hiyama-memo/20100208/1265588392
- http://d.hatena.ne.jp/m-hiyama-memo/20100129/1264735884

*1317285826*[caty-depl][メモ]今日のサーバー設定

まず、さくらインターネットの会員（顧客）IDと、VPSサーバーコントロールパネルの管理者IDと、サーバー自体のroot IDが全部別物で、パスワードも3つあるってことに&lt;b&gt;注意&lt;/b&gt;。年のため、3つ全部別にしているが、覚え切れない。セキュリティ上いいんだか悪いんだか。

- 会員のID/Passwordで  https://secure.sakura.ad.jp/menu/
- コントロールパネルのID/Passwordで https://secure.sakura.ad.jp/vpscontrol/
- rootのID/Passwordで www4054uc.sakura.ne.jp へのSSH接続

現時点では、コントロールパネルからのリモートコンソールはシリアルもVNCも動作しない。このあいだまでVNCは動いたんだが、、、 TeraTermにIPアドレスか標準ホスト名を入れればSSH2接続はできる。けど、VNCもあれば安心なんだが、さくらは何やっているんだ？

コントロールパネルから、会員メニューのトップ／ネームサーバー登録へのリンクは用意されている。ともかく使いにくい。

dotsterはと言うと、http://www.dotster.com/login/ からログインできるが、ログインすると相変わらずサイテーのメニューが出る。

|* ドメイン		|* 登録日    |* 失効日 |
| CATY-SITES.NET	|11/14/2009 | 11/15/2012 |
| CHIMAIRA.ORG	|08/22/2003 | 08/22/2013 |
| DAPHNIA.ORG	|08/08/2003 | 08/09/2013 |
| MICROAPPLICATIONS.NET	| 08/17/2005 | 08/17/2013 |
| MICROAPPLICATIONS.ORG	| 08/17/2005 | 08/17/2013 |

さくらもdotsterも、なんでこうも酷いWebUIなのか？

それはともかく、さくらのネームサーバー登録画面を使って、microapplications.net と daphnia.org を旧IPアドレスから新IPアドレスに変更。DNS情報がどのくらいで行き渡るかはワカランが、以前やったときは驚く程速かった（1時間後にnslookupで引けた）と思った。

&lt;b&gt;[追記]&lt;/b&gt;よし、http://chimaira.daphnia.org が動いた。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2011-09-30" title="">
<body>
*1317359290*[caty-depl][メモ]続・サーバー設定

&lt;h5&gt;ゾーン設定&lt;/h5&gt;

ドメインの基本情報は次のような形：

|*エントリ名|* タイプ	|*データ|
| @	    | NS	| ns1.dns.ne.jp. |
|  	    | NS	| ns2.dns.ne.jp. |
|	    | MX	| 10 @ |
|	    | A	 	| 49.212.35.78 |
| www	    | CNAME	| @ |
| mail	    | CNAME	| @ |
| ftp	    | CNAME	| @ |

必要に応じてCNAMEにホスト名を追加する。commuworld.org は失効したらしい。まーいいや。daphniaとmicroapplicationsを使おう。

&lt;h5&gt;nginx&lt;/h5&gt;

- インストール先は /usr/local/nginx/ 
- nginx -h でヘルプが出る。
- 基本は、nginx &amp;amp; として起動しておけばOK。
- Apacheが起動しているときは、service httpd status で止めてから、nginx &amp;amp; すればよい。

&lt;pre class=&quot;out&quot;&gt;
# service httpd status
httpd (pid 9368 9367 9366 9365 9364 9363 9362 9361 2204) is running...

# service httpd stop
&lt;/pre&gt;

&lt;h5&gt;postfix&lt;/h5&gt;

postfixメールサーバーのことが http://d.hatena.ne.jp/m-hiyama-memo/20100426/1272274832 くらいしか書いてない。マズイな。

インストールは済んでいるとして、次のようにして調べることができる。

&lt;pre class=&quot;out&quot;&gt;
# which postconf
/usr/sbin/postconf

# ls -l /usr/sbin/post*
&amp;#45;rwxr-xr-x  1 root root     165108 Aug 15  2008 /usr/sbin/postalias
&amp;#45;rwxr-xr-x  1 root root      86900 Aug 15  2008 /usr/sbin/postcat
&amp;#45;rwxr-xr-x  1 root root     181428 Aug 15  2008 /usr/sbin/postconf
&amp;#45;rwxr-sr-x  1 root postdrop 132200 Aug 15  2008 /usr/sbin/postdrop
&amp;#45;rwxr-xr-x  1 root root      78644 Aug 15  2008 /usr/sbin/postfix
&amp;#45;rwxr-xr-x  1 root root      86676 Aug 15  2008 /usr/sbin/postkick
&amp;#45;rwxr-xr-x  1 root root      82612 Aug 15  2008 /usr/sbin/postlock
&amp;#45;rwxr-xr-x  1 root root      78548 Aug 15  2008 /usr/sbin/postlog
&amp;#45;rwxr-xr-x  1 root root     156884 Aug 15  2008 /usr/sbin/postmap
&amp;#45;rwxr-sr-x  1 root postdrop 161012 Aug 15  2008 /usr/sbin/postqueue
&amp;#45;rwxr-xr-x  1 root root      95124 Aug 15  2008 /usr/sbin/postsuper

# ls -l /etc/postfix/
total 272
&amp;#45;rw-r--r--  1 root root 11942 Aug 15  2008 LICENSE
&amp;#45;rw-r--r--  1 root root  1629 Aug 15  2008 TLS_LICENSE
&amp;#45;rw-r--r--  1 root root 15647 Aug 15  2008 access
&amp;#45;rw-r--r--  1 root root 10947 Aug 15  2008 canonical
&amp;#45;rw-r--r--  1 root root  9622 Aug 15  2008 generic
&amp;#45;rw-r--r--  1 root root 16393 Aug 15  2008 header_checks
&amp;#45;rw-r--r--  1 root root 26778 Apr 25  2010 main.cf
&amp;#45;rw-r--r--  1 root root 14332 Aug 15  2008 main.cf.default
&amp;#45;rw-r--r--  1 root root 26719 Apr 25  2010 main.cf.saved
&amp;#45;rw-r--r--  1 root root 26732 Apr 25  2010 main.cf~
&amp;#45;rw-r--r--  1 root root  1244 Aug 15  2008 makedefs.out
&amp;#45;rw-r--r--  1 root root  4185 Apr  1  2009 master.cf
&amp;#45;rwxr-xr-x  1 root root 22478 Aug 15  2008 post-install
&amp;#45;rw-r--r--  1 root root 17298 Aug 15  2008 postfix-files
&amp;#45;rwxr-xr-x  1 root root  6366 Aug 15  2008 postfix-script
&amp;#45;rw-r--r--  1 root root  6523 Aug 15  2008 relocated
&amp;#45;rw-r--r--  1 root root 11033 Aug 15  2008 transport
&amp;#45;rw-r--r--  1 root root 11732 Aug 15  2008 virtual

# service postfix status
master (pid 2329) is running...

# postconf -n
alias_database = hash:/etc/aliases
alias_maps = hash:/etc/aliases
command_directory = /usr/sbin
config_directory = /etc/postfix
daemon_directory = /usr/libexec/postfix
debug_peer_level = 2
html_directory = no
inet_interfaces = all
mail_owner = postfix
mail_spool_directory = /var/mail
mailq_path = /usr/bin/mailq.postfix
manpage_directory = /usr/share/man
mydestination = $myhostname, localhost.$mydomain, localhost, daphnia.org, commuworld.org, caty-sites.net, chimaira.org
mydomain = microapplications.net
myhostname = microapplications.net
mynetworks = 127.0.0.1
myorigin = $myhostname
newaliases_path = /usr/bin/newaliases.postfix
queue_directory = /var/spool/postfix
readme_directory = /usr/share/doc/postfix-2.2.10/README_FILES
sample_directory = /usr/share/doc/postfix-2.2.10/samples
sendmail_path = /usr/sbin/sendmail.postfix
setgid_group = postdrop
unknown_local_recipient_reject_code = 550

#
&lt;/pre&gt;

postfixのインストールと運用はいずれメモしておかないとな。

vsftpdはうまく動かない。起動はするが繋がらない。&lt;b&gt;[追記]&lt;/b&gt;iptablesの設定のせいだった。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;b&gt;[追記]&lt;/b&gt;chimaira.orgのDNS情報がだいたい行き渡ったようだ。が、Webが死んでいた。nginxが落ちて、Apacheが起動していた。ってことは再起動があったらしい。とりあえず、chkconfig httpd off したが、起動でnginxが上がるように設定しないといけないな。&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2011-10-04" title="">
<body>
*1317692905*[マンダラ][TQFT][からみ系]圏のサークル

サイクルじゃなくて&lt;em&gt;サークル&lt;/em&gt;。

イエッターの本で、圏Cに対して E(C) = Σ(A∈Obj(C) | End(A)) として、E(C)にトレース同値 f;g = g;f を入れた集合を定義していた。同じ概念に別な定義をしている例もある。そしてこれは、圏のサイクルとかループとか呼ばれることがある。

サイクルやループはグラフ理論で既に使っている用語だし、グラフと圏を同時に扱うときに混乱しがち。グラフにハーフエッジを認める場合、頂点をまったく持たない閉じた辺としてサークルが出てくる。トレース同値で得られた同値類はサークルと呼ぶのがいいと思う。

∪と∩は境界付きヘミサークルだから、これをグルーイングするとサークル○が出てくるわけだ。サークルはディレクリ条件から解放されるので、自由に動くことができる。


*1317692906*[気付いた][具体例][圏一般論][モナド]もう少しでモノイドな代数系

結合律と左単位律を満たし、右単位律を満たさない例を見つけた。基点付き集合の直和の圏で考えるのだけど、他の圏でも出来るかもしれない。

(A, ⊥&lt;sub&gt;A&lt;/sub&gt;), (B, ⊥&lt;sub&gt;B&lt;/sub&gt;) などを基点付き集合圏の対象として、直和は、AとBの集合直和を作って基点⊥&lt;sub&gt;A&lt;/sub&gt;と⊥&lt;sub&gt;B&lt;/sub&gt;を同一視した新しい基点とする。

&lt;b&gt;1&lt;/b&gt;を基点付き集合とみなした単元集合とすると、これは直和のモノイド単位となる。唯一の射 i&lt;sub&gt;A&lt;/sub&gt;:&lt;b&gt;1&lt;/b&gt;→(A, ⊥&lt;sub&gt;A&lt;/sub&gt;)を単位として、乗法 m: (A, ⊥&lt;sub&gt;A&lt;/sub&gt;) + (A, ⊥&lt;sub&gt;A&lt;/sub&gt;) → (A, ⊥&lt;sub&gt;A&lt;/sub&gt;) を、余タプル [0&lt;sub&gt;A&lt;/sub&gt;, id&lt;sub&gt;A&lt;/sub&gt;] で定義する。

- 0&lt;sub&gt;A&lt;/sub&gt; = !&lt;sub&gt;A&lt;/sub&gt;;i&lt;sub&gt;A&lt;/sub&gt; : A→A
- id&lt;sub&gt;A&lt;/sub&gt; : A→A

(A, i&lt;sub&gt;A&lt;/sub&gt;:&lt;b&gt;1&lt;/b&gt;→A, m:A+A→A) は左単位律と結合律を満たすが右結合律を満たさない。left almost-monoid という感じ。


</body>
</day>
<day date="2011-10-06" title="">
<body>
*1317855706*[圏一般論][気付いた]f.α という記法とホモトピー

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20111004/1317711060&quot;&gt;本編でも書いたDOTN&lt;/a&gt;の話。

&lt;img src=&quot;http://www.chimaira.org/img/horiz-composition.gif&quot; &gt;

F, G:C→D で f:a→b in C だとする。α::F⇒ G:C→D があるとして、f.F, f.G, a.α, b.α を4辺とする可換四角形ができる。この四角形を f.α と書くことにする。f.αは、D&lt;sup&gt;→&lt;/sup&gt;という関手圏の射として意味を持つ。f.α:f.F→f.G in D&lt;sup&gt;→&lt;/sup&gt; となる。

さて、H:D→E があると、Hは、D&lt;sup&gt;→&lt;/sup&gt;→E&lt;sup&gt;→&lt;/sup&gt; まで持ち上げることができる。可換四角形のすべての辺にHを適用して写せばいい。これは H&lt;sup&gt;→&lt;/sup&gt; と書けるが、HとH&lt;sup&gt;→&lt;/sup&gt; をオーバーロードする。

可換四角形 f.α のH（ほんとはH&lt;sup&gt;→&lt;/sup&gt;）による像を (f.α).H = f.α.H と書く。β::H⇒K:D→E に対する (f.K).β も可換四角形だが、(f.α).H と (f.K).β は縦結合可能なので、(f.α.H);(f.K.β) in E&lt;sup&gt;→&lt;/sup&gt; が作れる。これが、f.(α*β) を与える。つまり、自然変換は、射に可換四角形を対応付けるルールとみなせる。四角形を2セルとみたときの始辺と終辺が関手F, Gで与えられる。C→D の関手に働く自然変換は、C→D&lt;sup&gt;→&lt;/sup&gt; の関手のように思える。

これは、&lt;b&gt;Cat&lt;/b&gt;のデカルト閉性から次を意味する。

- &lt;b&gt;Cat&lt;/b&gt;(C, D&lt;sup&gt;→&lt;/sup&gt;) = &lt;b&gt;Cat&lt;/b&gt;(C×→, D)

C×→ は柱体なので、自然変換は、空間Cと空間Dの間の写像（関手）の離散的ホモトピーを与える。

ウーム、&lt;em&gt;やっぱりホモトピーか。&lt;/em&gt;

</body>
</day>
<day date="2011-10-07" title="">
<body>
*1317967632*[高次圏論][その他代数]ニルス・ジョンソンの米田／森田理論

ニルス・ジョンソン（http://www.nilesjohnson.net/）の米田／森田理論をチラ見したが、全然わからない。リカード（Rickard）の定理が森田定理の一般化らしいが、それを理解するには、さまざまな予備知識がいる。

+ The dual basis lemma -- 知らん。半加群のdual basis lemmaが http://www.anubih.ba/Journals/vol-1,no-2,y05/03revdeore.pdf にある。http://arxiv.org/abs/math/0002014 にもナンカ書いてある。加群や半加群が射影的であることの特徴づけが、双対基底を持つことだ、という内容らしい。
+ canonical coevaluation map -- P&lt;sup&gt;*&lt;/sup&gt; = Hom&lt;sub&gt;S&lt;/sub&gt;(P, S) と置いたときの、P(×)&lt;sub&gt;S&lt;/sub&gt;P&lt;sup&gt;*&lt;/sup&gt; → Hom&lt;sub&gt;S&lt;/sub&gt;(P, P) のことらしい。が、これはevaluation mapなんじゃないかと思うが。coev だったら、T→P&lt;sup&gt;*&lt;/sup&gt;(×)P の形だろう。
+ dual pair over S and R -- 森田コンテキストのような気がする。canonical evとかcoevとかも、dual pair に関して出てくる概念だろう。
+ PとP&lt;sup&gt;*&lt;/sup&gt;が、R、S上のdual pair とは、-(×)&lt;sub&gt;R&lt;/sub&gt;P と -(×)&lt;sub&gt;S&lt;/sub&gt;P&lt;sup&gt;*&lt;/sup&gt; （P&lt;sup&gt;*&lt;/sup&gt; = Home&lt;sub&gt;S&lt;/sub&gt;(P, S)）が随伴対になること。
+ 随伴対のevaluation map ε:Hom&lt;sub&gt;S&lt;/sub&gt;(P, S)(×)&lt;sub&gt;R&lt;/sub&gt;P → S が同型になるの／ならないのとか言っている。んん？ P&lt;sup&gt;*&lt;/sup&gt;(×)P → S がevで順序を逆にして、値を取る先も変えた P(×)&lt;sub&gt;S&lt;/sub&gt;P&lt;sup&gt;*&lt;/sup&gt; → Hom&lt;sub&gt;S&lt;/sub&gt;(P, P) がcoeveってか？ 習慣と違うと思うが。
+ dual pair が可逆（invertible）ということの定義。これって、アイレンベルグ／ワッツ同値のことか。

それから、ホモロジー代数の概念がバシバシと出てくる。

+ quasi-isomorphic -- ホモロジーのレベルで同型を誘導することだっか？
+ 次数0に集中している -- 0以外の添字のところは零加群てことかと。
+ DG代数 -- 名前からいって微分と階数が付いているんだろうが、実感はまったくない。
+ 三角圏 -- ウーム、名前は聞いたことがあるが、内容は知らん。

ンガー、わからん。ホモロジー代数は、僕の目的にはサッパリ役に立たないので興味を失った。が、ホモロジーの先にあるものが役立つかもしれないから、乗り越えないといけない壁なのかもしれないなー。


</body>
</day>
<day date="2011-10-08" title="">
<body>
*1318037314*[用語法][雑感]基本的な用語がわからない

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110822/1313973286&quot;&gt;本編に書いたことがある&lt;/a&gt;が、「単純」とか「既約」とか、割と基本的な用語がかえって難しい、という話。

+ 環が非自明なイデアルを持たないとき「単純」（simple）と呼ぶ。
+ 加群が非自明な部分加群を持たないときも「単純」でいいだろう。
+ しかし、既約加群という言葉も使われる。
+ 表現に対しては「単純」じゃなくて「既約」（irreducible）と呼ぶ。既約表現＝単純加群

単純の双対の余単純は「非自明な商対象を持たない」として定義できる。単純加群（＝既約加群）とは別に、直既約加群（indecomposable module）という概念がある。

- 直既約加群とは、{0} でないふたつの部分加群の直和に書くことができない加群のことをいう。任意の既約加群は直既約加群だが逆は必ずしも成立しない。

直既約とは、分解可能（decomposable）じゃないことだが、ここの分解は直和分解。モノイド積による分解まで拡張は当たり前にできる。

それはそうと、Rがスカラーの条件として、R = End(R) （同型）という条件をたまに見る。これは、内部ホムがある状況じゃないと正しく程式化できない。内部ホムを [-, -] と書くことにして、R = [R, R] が条件。

計算科学で出てくる概念と一緒にまとめる。0, 1は始対象と終対象、□, I がモノイド構造、[ , ] が内部ホムとする。

+ 0 と id 以外に部分対象を持たない対象は単純または既約
+ 単純対象の積（□の意味で）に書けるなら半単純
+ x = x□I 以外にモノイド積分解を持たないなら直既約
+ [x, x]がxの部分対象（[x, x]→x というモノを持つ）ならxは反射的対象
+ 任意の対象からのモノを持つなら、xは包摂的（subsumpting）対象

リー環の半単純性は「根基が消えている（0 でない可換なイデアルを持たない）ようなリー環は半単純 (semi-simple) であるという。」となっているな。

その他、いろいろな「半単純」の例：

- A semisimple module is one in which each submodule is a direct summand.
- A semisimple algebra (or ring) is one that is semisimple as a module over itself.
- A semisimple operator (or matrix) is one for which every invariant subspace has an invariant complement. This is equivalent to the minimal polynomial being square-free. Over an algebraically closed field it is equivalent to diagonalizable.
- A semisimple Lie algebra is a Lie algebra that is a direct sum of simple Lie algebras.
- A semisimple algebraic group is a linear algebraic group whose radical of the identity component is trivial.

包摂的は今僕が考えた。普遍的という言葉を使う例もあるが、良くないと思う。反射的かつ包摂的であり、外の圏の構造を移す機構が備わっているときに、普遍的（むしろ万能）対象と呼ぶべきだろう。外の圏がデカルト閉などでないとあまり意味を持たないかもしれない。

*1318050474*[圏一般論][Mx]アーベル圏／半アーベル圏の定義

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110907/1315352787&quot;&gt;以前書いた&lt;/a&gt;、アーベル圏の定義の話。ゴタゴタと書く。

&lt;h5&gt;半加法圏と加法圏&lt;/h5&gt;

加法圏と半加法圏は意味がある。半加法圏のほうが自然な概念だと思う。以下が条件である。

- 任意の有限離散図式に同時に極限かつ余極限であるものが存在する。

これは当然に次を含む。

+ 任意の有限離散図式に極限が存在する。
+ 任意の有限離散図式に余極限が存在する。

空図式を考えると：

- 同時に始対象かつ終対象である対象が存在する。

2頂点の離散図式を考えると：

- 同時に直積かつ直和ある対象が存在する。

この２つは、零対象と双積の存在になる。零対象と双積から足し算を作っていくのは純圏論的な構成で出来て、豊饒圏の議論はいらない。

半加法圏を加法圏にするのは、加法的対蹠（additive antipode）が必要。加法的堆積をネゲーション（negation）と呼びνで書くことにする。対象Aごとにν&lt;sub&gt;A&lt;/sub&gt;:A→A があって、ホップ代数の公理を満たすことになる。加法圏では、すべての対象に可換（対称）ホップ代数（むしろ、ホップモノイド）の構造が入ることになる。

まとめると：

- 半加法圏 = 零対象（pointed）と双積の存在
- 加法圏 = 半加法圏＋ネゲーション

&lt;h5&gt;プレアーベル圏&lt;/h5&gt;

半加法圏を拡張して、次の性質を考える。

- 任意の有限図式に同時に極限かつ余極限であるものが存在する。

今度は離散とは限らない有限図式である。これは、次のことを意味する。

- 任意の共端射対に、等値射と余等値射が存在する。

核と余核の存在は自動的に従う。核は特殊な等値射、余核は特殊な余等値射だから。

以上の定義だと、極限と余極限が一致する&lt;em&gt;双極限&lt;/em&gt;とでも呼ぶべき構成物の存在が問題になる。双極限は懸垂（suspension、錐と余錐の底面貼りあわせ）の両端をつなげた約懸垂（reduced suspension、ただし基点空間ではない）を考えた極限操作となる。双極限の存在を&lt;em&gt;双完備&lt;/em&gt;とすると、有限離散双完備が半加法性、有限双完備が半プレアーベルとなる。もっとも、半プレアーベルという性質に意味があるかどうかは疑問。有限双完備＋ネゲーションでプレアーベル性となる。

- プレアーベル＝有限双完備＋ネゲーション＝加法性＋ker/coker

半加法圏では、ker/cokerからeq/coeqを再現できない。ネゲーションがないときは、ker/cokerに威力はないらしい。

&lt;h5&gt;アーベル圏&lt;/h5&gt;

最後にアーベル性の決め手となるのは、準同型定理の成立。つまり、ker(f), coker(f), im(f), coim(f) が定義できて、Ker(f) := dom(ker(f)) のように定義するとき：

- Coim(f) と Im(f) が同型

プレアーベルからアーベルは割と素直だが、プレ半アーベルから半アーベルはゴタツク。いわゆる半アーベルの定義はめんどくさい。

ker, cokerは双極限からストレートに出るが、im, coimの定義が問題。次の定義が一般的に意味があるかどうかが疑問。

- im(f) := coker(ker(f))
- coim(f) := ker(coker(f))

この定義は、全単分解と何の関係もない。全単分解の意味での像（image）の定義には、一意分解性とか、強エピ、正則エピなどの概念が必要。半アーベル圏では、正則圏の概念に近い形で定式化しているようだ。

&lt;h5&gt;擬アーベル圏&lt;/h5&gt;

擬アーベル圏（Quasi-Abelian category）という概念もある。

-  Quasi-Abelian Categories and Sheaves http://archive.numdam.org/ARCHIVE/MSMF/MSMF_1999_2_76_/MSMF_1999_2_76__R3_0/MSMF_1999_2_76__R3_0.pdf

これは、準同型定理の成立を要求しない。その代わりに、準同型定理が成立するような射を厳密射（strict morphism）と呼ぶ。厳密射に関する公理と設ける。だが、厳密射がある程度は豊富にないとうまく使えないのではないかと思う。次のような事実はプレアーベル圏で一般的に成り立つ。

+ fがなんでも、ker(f) は厳密モノである。
+ fがなんでも、coker(f) は厳密エピである。
+ fが厳密モノなら、fはcoker(f)の核となっている。
+ fが厳密エピなら、fはker(f)の余核となっている。
+ fが厳密モノmと厳密エピeで f=e;m と書けることと、fが厳密なことは同値。

&lt;h5&gt;有限双完備圏のホモロジー&lt;/h5&gt;

計算モデルとして使うモノイド、半環、半加群などは半アーベル圏にも擬アーベル圏にもならないようだ。

計算モデルの圏が有限双完備になっていることは多い。が、たいていはネゲーションが存在しない、引き算ができない。完全列ベースでホモロジーを定義するのは難しいのかの知れない。が、完全列なしのホモロジーは意味不明だし。

*1318057527*[圏一般論][Mx]約懸垂と双極限

幾何の約懸垂（被約懸垂 reduced suspension）は、For a pointed space (X, x0), ΣX = (I×X)/({0,1}×X ∪ I×{x0}) となっているが、I×{x0} を潰すのはやめる、つうか基点x0が最初からない。記号は同じΣを拝借する。

Dを圏&lt;i&gt;C&lt;/i&gt;の図式として、ΣD からのグラフ射の圏を &lt;i&gt;C&lt;/i&gt;/ΣD&lt;/sup&gt; とする。Dは固定されている。約懸垂の頂点（つうか基点つうか）が動く。この圏での始対象かつ集対象があれば、それが双極限だろう。もっとよく考えないといかんが。

もし、この方法がうまく動くなら、直感的でいい方法だと思う。

*1318064643*[圏一般論][Mx]半加法圏の再論

&lt;b&gt;Ab&lt;/b&gt;豊饒から始まる加法圏の定義は嫌いだ：

+ 半加法性、加法性が圏論的な概念であることが見えなくなる。
+ 半加法構造、加法構造が本質的にひとつしか入らないという事実が見えなくなる。
+ 加法を入れる楽しい議論がすべてすっ飛ばされる。

圏の有限極限／余極限を使うのがいいのだが、これはこれでup-to-isoの議論が鬱陶しい。

結局、スタートは等式的な定義だろう。等式的な定義は極限を使う定義とは異なる。

- 前もって、終対象や直積対象／射影などが一意的に選ばれている。

これにより、up-to-isoな議論はいらない。極限で定義される同型対象類のなかに1つだけ特定対象が入っていて、それを記号で指示・表現できる。極限で定義される&lt;em&gt;性質&lt;/em&gt;のセクションとなるような&lt;em&gt;演算&lt;/em&gt;が定義されている。

等式的な定義と極限による要請・制約の関係がわかったら、それが圏のモノイド構造と、「すべての対象上への本質的に一意なコモノイド構造」を許容（極限）または定義（等式的）することを見る。

つまり、デカルト圏、余デカルト圏、双デカルト圏＝半加法圏の定義は次の3つのどれでも良い。

+ 等式的な定義
+ 極限による定義
+ コモノイド構造を持つモノイド圏

半加法圏にネゲーションを入れると加法圏だが、このときは、すべての対象がホップモノイド構造を持つ対象モノイド圏と考えるのが一番良さそう。


</body>
</day>
<day date="2011-10-10" title="">
<body>
*1318220493*[圏一般論][リンク][気付いた]非対称モノイド圏のモノイド対象のコホモロジー

&quot;Cohomology of Monoids in Monoidal Categories&quot; という論文を見つけた。1997年なのでそれほど新しいわけではない。著者の一人は、Mamuka Jibladzeだが、http://ncatlab.org/nlab/show/Mamuka+Jibladze によるとグルジア共和国の人らしい。目を引く論文は：

- Cohomology of Algebraic Theories (1991) [13 citations - 8 self] &lt;br&gt;http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9028
- Cohomology of Monoids in Monoidal Categories (1997) [2 citations - 1 self] &lt;br&gt;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.3891
- Scattered Toposes [1 citations - 0 self] &lt;br&gt;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.2579

citationsが少ない。あまり知られてない。あまり注目も評価もされてない。

&lt;em&gt;だが僕にとっては&lt;/em&gt;、&quot;Cohomology of Monoids in Monoidal Categories&quot;は驚くべき事実が色々と書かれていて、面白いしとても役に立つ。

まず、僕のほうの状況として次があった。

+ 森田理論では、双加群とか森田コンテキストが重要らしい。
+ 双圏と双圏版の米田補題が気になる。
+ オートマトン圏で双加群を考えたら予想とは違って、IOは説明できない（ガックリ）。
+ だが、オートマトン圏での双加群は2次元オートマトンにはなるらしい。
+ オートマトンの(コ)ホモロジーが取れないか？
+ 前例を見てもぱっとしない。アーベル圏にならないのがマズイのでは？
+ 非アーベル圏でのコホモロジーとしては、擬アーベル圏や半アーベル圏がある。
+ 擬アーベル圏や半アーベル圏でもなんかうまくいかない（ガックリ）。
+ それはそうと、オペラッドも面白そうだな。

と、こんなことを考えていた。

&quot;Cohomology of Monoids in Monoidal Categories&quot;では、かなり一般的なコホモロジーを具体的に構成する方法が書いてある。アーベル圏を使うし、原形は1969年のバー／ベック（Barr-Beck）のコトリプルコホモロジーというやり方。その意味ではあまり新しいことはないとも言えるが、オペラッドや小圏のコホモロジーなども統一的に説明できることと、係数圏という概念が素晴らしい。

目的の対象達の圏がアーベルでなくても、係数圏を使ってアーベル圏を作り、そのアーベル圏内で具体的にコホモロジーを作る方針。一般的な枠組みは対称とは限らない圏&lt;i&gt;C&lt;/i&gt;の内部モノイドの圏 Mon(&lt;i&gt;C&lt;/i&gt;) を考えて、Mon(&lt;i&gt;C&lt;/i&gt;) の対象Gごとに、Coef(&lt;i&gt;C&lt;/i&gt;, G) という圏を考えて、係数圏の対称Aと取ってきて、組 (G, A) ごとに(余)鎖複体を作る。(余)鎖複体から先の扱いは古典的／計算的である。

例によって、僕の予備知識が足りない。次を理解する必要がある。

+ 極限関係で、reflects, createsなど
+ filtered (co)limit と finitary functor
+ profunctor
+ natural system （全然知らなかった）
+ tow-sided bar construction
+ cosimplicial abelian group
+ torsor （胴体だけのトルソーは torso)

*1318231723*[圏一般論][リンク][人物]続・モノイド圏のモノイド対象のコホモロジー

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111010/1318220493&quot;&gt;前の記事&lt;/a&gt;の続き。&quot;Cohomology of Monoids in Monoidal Categories&quot; を、CMMCと略記することにする。著者の一人はジブと表記（http://www.rmi.ge/~jib/）。

CMMCが注目されないのはなぜだ？ 本質的に新しい結果がないからか？ そうだとしても解説として優れている。独自の視点とか方法論が感じられる。ジブのホームページ http://www.rmi.ge/~jib/ に他の論文もあるが、一般代数を現代的に展開している感じ。非常にメタな話と、具体的で泥臭い計算が混じっているのが面白い。

CMMCのコホモロジーはある程度は（かなり面倒だが）実際に計算できるはずだ。余鎖複体の定義は具体的だ。次の例で計算したい。

+ 普通の集合圏のモノイドのコホモロジー
+ 小圏のコホモロジー
+ 「ベクトル空間の圏のモノイド＝体上の多元環」のコホモロジー
+ モナドのコホモロジー

オペラッドはよくわからんから無理だ。

&lt;i&gt;C&lt;/i&gt;がアンビエントとなる（非対称）モノイド圏、Gが&lt;i&gt;C&lt;/i&gt;内のモノイド対象のとき、最初に係数圏Coef(&lt;i&gt;C&lt;/i&gt;, G)を求めなくてはならない。これだけでも一作業。次に係数圏から係数対象を選んで余鎖複体を作る。余鎖複体のコホモロジーを求める。低次の部分は、定義とは別な方法でも計算できる。

モナドのコホモロジーとして、モノイダルスタンピングモナドのコホモロジーを計算すると、元のモノイドのコホモロジーとどう関係するのだろう？ 圏のコホモロジーを圏環（圏代数）のコホモロジーで計算する例があったが、あれとはどう関係する？

そもそもの動機がオートマトンのコホモロジーだから、最終的にはオートマトンに対して意味のあるコホモロジーが定義できるどうかが問題だ。そういえば、力学系のコホモロジーの計算もあったが、あれは力学系を小圏とみてのコホモロジーのようだった。力学系はオートマトンの特殊例だから、オートマトンのコホモロジーは力学系のコホモロジーを包含しなくてはならない。

*1318233627*[圏一般論][メモ][説明][Mx]逆向きにたどるアーベル圏

+ ホモロジー代数をやりたい
+ 完全列とその操作が必要
+ 準同型定理
+ Coim と Im が必要
+ kerとcokerから定義される
+ ker/cokerには、引き算、零射が必要
+ 引き算と零は足し算がないと意味持たない
+ 零はもちろん、足し算と符号反転も必要

となると、やっぱり軸となるのは「準同型定理」と「足し算、零、反転」。


</body>
</day>
<day date="2011-10-18" title="">
<body>
*1318914373*[圏一般論][メモ][プログラム意味論]ABCシステム

+ ABC = Action of Bimonoid on Comonoid
+ ABC = Algebra for Buffers and Caches

B = (B, ∇, i, Δ, !) が双モノイド、C = (C, Δ, !) が余モノイドとする。(B, C, a:B×C→C) が&lt;strong&gt;ABCシステム&lt;/strong&gt;とは：

+ Bをモノイドとみなして、aはCへのBモノイド作用＝加群＝表現となっている。
+ 作用aは、余モノイドの余乗法、余単位と強調している（双代数律との類似が成立する）。

Bのモノイド構造を忘れて余モノイドとみなしたものをB&lt;sup&gt;Δ&lt;/sup&gt;として、C := B&lt;sup&gt;Δ&lt;/sup&gt;, a := (モノイド積) と置くと、(B, B&lt;sup&gt;Δ&lt;/sup&gt;, ∇:B×B&lt;sup&gt;Δ&lt;/sup&gt;→B&lt;sup&gt;Δ&lt;/sup&gt;) はABC構造になる。

X = (B, C, a) がABCシステムのとき、X上の加群 (S, o, m) は次のように定義する。

+ o : S→S×C がC上の余加群（oは観測余乗法）
+ m : B×S→S がモノイドとみなしたB上の加群（mはモノイド作用の乗法）
+ o, m に関して双代数律との類似が成立する。

適当なベース圏の上で、ABCシステムの全体と準同型は圏となる。ABCシステムXを固定しての加群の圏X-Modも定義できる。左右の概念を明確にして双加群を定義すると何かわかるかも。

*1318932666*[リンク][メモ][人物]カテゴリカル・フラーレンの達人・クランス

クランス（Sjoerd Crans http://home.tiscali.nl/secrans/）という人がいる。

On braidings, syllepses, and symmetries  (1998) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.3774 なんて論文を書いている（73ページもある）。このなかで、可換図式が出てくるが、それがもうフラーレン化している。よくもこんな計算をするものだ、と。高次圏に対して、なんか独特の感性を持っているようだ。

クランス／グレイ（Crans-Gray）テンソル積なんて概念も作っている。tas（複数形はteisi）もクランスが編み出したもの。ちなみに、tas, teisiはウェールズ語（Welsh）だそうで、意味はスタック。



</body>
</day>
<day date="2011-10-20" title="">
<body>
*1319095674*[用語法][気付いた][圏一般論][説明]点／余点じゃなくて粒子／余粒子

&lt;i&gt;C&lt;/i&gt;が圏のとき、対象Xを固定して、Hom&lt;sub&gt;&lt;i&gt;C&lt;/i&gt;&lt;/sub&gt;(X, -) = &lt;i&gt;C&lt;/i&gt;(X, -) は集合圏への関手となる。この関手をX&lt;sub&gt;∧&lt;/sub&gt;とする。同様に、Hom&lt;sub&gt;&lt;i&gt;C&lt;/i&gt;&lt;/sub&gt;(-, Y) = &lt;i&gt;C&lt;/i&gt;(-, Y) は集合圏への反変関手となる。こっちはY&lt;sup&gt;∨&lt;/sup&gt;。

対象Aに対して、X&lt;sub&gt;∧&lt;/sub&gt;(A) は集合で、Xをベースとする点の集合、あるいはX-点（X-point）の集合と呼ぶことがある。同様に、Y&lt;sup&gt;∨&lt;/sup&gt;(A) は、Xを余ベースとする余点の集合、あるいはX-余点（X-copoint）の集合。

だが、どうも「点」という言葉をこのように使うのは違和感があるような気がする。次のように呼んではどうか。

- X&lt;sub&gt;∧&lt;/sub&gt;(A) は、XをシェープとするA内の粒子の集合；X-粒子（X-particle）の集合
- Y&lt;sup&gt;∨&lt;/sup&gt;(A) は、Yを余シェープとする余粒子の集合、あるいはX-余粒子（X-coparticle）の集合

例えば、X = S&lt;sup&gt;1&lt;/sup&gt; として、S&lt;sup&gt;1&lt;/sup&gt;-粒子の集合。なんか物理っぽいし、違和感が少ないと思う。点というとなにか絶対的なアトムな感じがするが、粒子なら色々あってもいいと思える。

*1319097236*[圏一般論][説明]スクリーンとしての集合圏と粒子／余粒子による空間描像

http://d.hatena.ne.jp/m-hiyama-memo/20111020/1319095674 の続き：

&lt;i&gt;C&lt;/i&gt;がなんかの世界（小宇宙）だとして、世界内の対象Xがあると、対象（空間）A内にXの形（シェープ）をした粒子がどのくらいあるか？ という観点から世界&lt;i&gt;C&lt;/i&gt;を集合圏という普遍的な世界に映し出せる。集合圏は、世界の姿をそこに投影する標準的（無個性）なスクリーンみたいなもの。そして、映しだす方法がX&lt;sub&gt;∧&lt;/sub&gt;。

X&lt;sub&gt;∧&lt;/sub&gt;は関手＝標準スクリーンへの投影法だが、モノはつまり「投影法というハタラキ＝社会的関連」により規定されると考えると、米田埋め込みとなる。

反変的に余シェープYをとると、Yは測定器とか尺度と言える。Y&lt;sup&gt;∨&lt;/sup&gt;は、尺度Yでどの程度識別できるか、識別の度合いにより世界を投影する投影法だと言える。粒子的描像が運動の自由度、余粒子的描像は位置の識別の可能性で空間を探ろうとする。


</body>
</day>
<day date="2011-10-22" title="">
<body>
*1319277316*[圏一般論] アーベル圏のほうから来ました

*** アーベル圏とは

+ 足し算ができる圏。ゼロと引き算もあって、それらしい計算は普通にできる。
+ 完全列が定義できる圏。完全列として期待される性質をみたして、ホモロジー代数が展開できる。

だから当然に話題は：

+ 足し算の話
+ 完全列の話

*** 足し算の話

当初は足し算の話を中心にしようと思っていた。

その理由は：

+ 完全列はよく知らない。ホモロジー代数なんて使ったことないし。
+ 圏に足し算を導入する普通の方法がヒドイ。もっといい方法を紹介したい！
+ 足し算を作る話は面白いし、役に立つ。ホモロジー代数より身近だ。

*** 足し算の話はやめました

- だが、足し算を作ってみるだけだと、「どこがアーベル圏なの？」となる。

*** 足し算の話はやめましたけど

圏に足し算を導入する普通の方法がヒドイ。
とは言っておく。

+ 強い対称性（自己双対性）が見えない。
+ デカルト圏との関係が見えない。アーベル圏とデカルト圏が無関係に見えてしまう。
+ 加法構造（実は半加法構造）の一意性が見えない。直感的には一意性が分からず、別に証明を要する。
+ 内在している対角コモノイドの存在が隠れてしまう。
+ 内在している加法的対蹠（additive antipode）の存在が隠れてしまう。
+ 一般的に有用な「モノイド、余モノイド、双モノイド、ホップモノイド」の枠組みが隠れてしまう。

*** つまり

- 足し算をいきなり入れてしまうのは不自然だし、あまりにも&lt;strong&gt;もったいない&lt;/strong&gt; 。

&lt;img src=&quot;http://www.chimaira.org/img2/hopf-antipode.gif&quot; &gt;

- だが、足し算を作ってみるだけだと、「どこがアーベル圏なの？」となるので …

*** 足し算の話はやめたので

+ アーベル圏では、共端な射（parallel pair）は足し算できると天下りに言う。f + g が和。
+ アーベル圏では、ホムセットごとにゼロが決まっていると天下りに言う。0&lt;sub&gt;A,B&lt;/sub&gt; がゼロ。面倒だからたいていは単に 0 。
+ アーベル圏では、結合（composition; 合成）に関して左右の分配法則が成り立つと天下りに言う。
+ アーベル圏では、引き算もできる、あるいは射のマイナスがあると天下りに言う。

天下りはよくない。が、背に腹は代えられない (どこが背? 腹?)。

*** 完全列の基本は

+ 完全列の基本は加群の準同型定理
+ アーベル圏における準同型定理を目指そう。
+ って、準同型定理（の形をした公理）って、アーベル圏の定義の一部なんですけど。
+ つまり、アーベル圏の定義を目指そう。
+ 目指す場所が定義なのか!?
+ 入門にさえなってない。

*** だから

アーベル圏のほうから来ました。

アーベル圏のほうに一緒に行きましょう。

*1319277719*[圏一般論]あらためてアーベル圏について

*** 参考文献

なんぞ流用できる素材がないかと、googleで &quot;Abelian category (introduction|introductory|short|brief)&quot; と検索してみた。

意外にない。

- Aaron Lauda の10ページ： http://www.math.columbia.edu/~lauda/teaching/rankeya.pdf &lt;br&gt;これは非常に入門的。これを（一部）参考にした。
- Geillan Aly の15ページ： http://math.arizona.edu/~galy/research/ab_categories.pdf &lt;br&gt; Freyd-Mitchellの埋め込み定理が解説されてる。
- Wikipediaの解説: http://en.wikipedia.org/wiki/Abelian_category
- nLabの解説: http://ncatlab.org/nlab/show/abelian+category

*** なんで「アーベル」なの？

+ マックレーンが命名者
+ アーベル群（＝可換群）の圏が典型的な例だから。
+ アーベル群の圏で成立することは、だいたいアーベル圏でも成立する。
+ アーベル群の圏＝Z加群の圏なので、一般にR加群で成立することは、だいたいアーベル圏でも成立する。
+ つうか、アーベル圏ってR加群の圏なんじゃねーの？（ミッチェルの埋め込み）
+ アーベル群の圏、R加群の圏をお手本に公理化したもの。
  アーベル群の圏、R加群の圏がほぼ再現（recover, reconstruction）できる。

*** 誰が考えたの？

+ マックレーンが創始者
+ 概念を整備して活用したのはグロタンディーク
+ 記念碑的論文は &lt;br&gt;  Grothendieck, Alexander: Sur quelques points d'algebre homologique, Tohuku Math J. (2) 9 (1957) だそうで。
+ フレイド（Peter Freyd）が本にまとめた。 &quot;Abelian categories&quot; Harper and Row, New York, 1964 &lt;br&gt; http://www.tac.mta.ca/tac/reprints/articles/3/tr3abs.html

*** 圏論とホモロジー代数とアーベル圏

 絵描く

*1319278240*[圏一般論] 圏論からの準備

*** いろんいろな圏

+ Set 集合圏 -- しばしば使う
+ PtSet 付点集合の圏
+ Rel 関係の圏
+ Grp 群の圏
+ Ab 群の圏 -- 今回の主人公
+ Mon モノイドの圏 -- 今回はあまり触れないが重要
+ CRing -- 可換環の圏（環といえば可換と仮定することもある）
+ R-Mod -- 可換環R上の加群の圏、可換なら左右は区別しなくも大丈夫
+ Vect[k] -- kベクトル空間の圏、とりあえず k = R だけにする。

*** 小さい可愛い圏

+ N 自然数 足し算モノイドとして圏
+ N 自然数 掛け算モノイドとして圏
+ N 自然数 順序集合として圏
+ N 自然数 順序に、足し算をモノイド積としてモノイド圏
+ 任意の順序集合 ハッセ図で図示
+ 任意のモノイド 対象は１個
+ 任意の有向グラフ 自由圏にする
+ 任意のラベル付き遷移系 状態空間が対象集合

*** 終対象

これはものすごく重要。

+ 普遍性と極限の最初で最重要な例
+ 普遍性と極限は、結局は終対象
+ 終対象が分かれば、普遍性と極限も分かる。
+ 双対は始対象。余極限。

*** 練習問題

終対象の定義をちゃんと述べて、終対象が up-to-iso で一意的であることを示せ。

*** 直積

+ 2点離散図式の極限
+ Λ型の図の圏の終対象
+ C(X, A)×C(X, B) と C(X, A×B) の1:1対応を与える。（'×'のオーバーロードに注意）
+ n点離散図式の極限は、終対象と極限で作れる。

*** 始対象と直和（余積）

双対です。

*** ゼロ対象と双積

- ゼロ対象 -- 1つの対象（単一頂点の図式）であり、同時に終対象でもあり始対象でもある。
- 双積 -- 1つの図式（約懸垂）であり、同時に積でもあり余積でもある。特にその頂点を双積と呼ぶことが多い。

*** 等値化と等値核

+ e が、共端な対 f, g を等値化するとは、e;f = e;g 
+ f, gを等値化する射のなかで普遍的（ある意味最大）なものが等値核（差核）。僕は、単に等値射とも言うことが多い。
+ 方程式の解全体（の埋め込み）
+ 等値核は、共端対を底面とする錐の圏の終対象

*** 練習問題 2

等値核は必ずモノ射となることを示せ。

（けっこう難しい。かも？）

*** 一意存在の使い方

∃!u.P(u) は次のように分けて考える。

+ ∃u.P(u), then a := εu.P(u)
+ ∀x, y.(P(x)∧P(y) ⊃ x = y)
+ そんなんで、P(x) を示せば x = a

*** 普遍性（極限／余極限）の使い方

普遍性は一意存在を主張するから：

+ 既知のaが P(a) であることを確認
+ 未知のxが P(x) であることを確認
+ a = x だと言える。

これがなかなか使いこなせない（少なくとも檜山は）。

*1319288190*[圏一般論]準同型定理

*** ベクトル空間の準同型定理

写実的な絵

*** ベクトル空間の準同型定理 2

象徴的な絵

*** ベクトル空間の準同型定理 3

ベクトル空間の準同型定理では、核部分空間を「要素0の逆像」、像空間を「写像の像集合」として定義する。

この定義はまったく圏論的ではないので、後で修正する。特に、像の直接的定義は圏論では難しい（正則圏論や因子分解系の議論が必要）。アーベル圏の像の定義は別な簡単な方法を使う。

*** いろいろな射

準同型定理による系列を作ろう。

+ 6n + 9m : Z&lt;sup&gt;2&lt;/sup&gt; → Z
+ n + (√-1)m : Z&lt;sup&gt;2&lt;/sup&gt; → C
+ 包含 : Q → R
+ 3n : Z → Z
+ exp : R → C&lt;sup&gt;×&lt;/sup&gt;
+ これもexp : R&lt;sup&gt;2&lt;/sup&gt; → S&lt;sup&gt;1&lt;/sup&gt;×R → S&lt;sup&gt;1&lt;/sup&gt;×P ＝ C&lt;sup&gt;×&lt;/sup&gt;
+ トーラスへの紐巻き付け : R → S&lt;sup&gt;1&lt;/sup&gt;×S&lt;sup&gt;1&lt;/sup&gt; ＝ T&lt;sup&gt;2&lt;/sup&gt;

*1319288191*[圏一般論]アーベル圏手前

*** 加法圏とプレアーベル圏

+ 加法圏 -- ゼロと引き算も含めて、射の足し算が自由にできる圏。対象の双積も要求する。
+ ほんとは、半加法圏＝双デカルト圏 を定義して、それに加法的対蹠（マイナス、ネゲーション）を入れて、ホップデカルト圏（Hopf cartesian cat.）とすると、それが加法圏。
+ 加法圏に核と余核の存在を要求するとプレアーベル圏
+ プレアーベル圏に準同型定理（の形の公理）を入れるとアーベル圏

*** 核

注意：記号の雰囲気を合わせるため、domをDomと表記する。

+ 核の定義：ker(f) = (f と 0 の等値核)、Ker(f) = Dom(ker(f))
+ 核の定義の言い換え：fをゼロ化する射のなかで普遍的なヤツ
+ 核はモノである。
+ 別な核の定義：fをゼロ化するモノ（ヤツじゃなくてmono）のなかで弱普遍的なヤツ。「弱」は存在の一意性を除いた主張。
+ fがモノなら、ker(f)はゼロである。
+ ker(f)がゼロなら、fはモノである。
+ ゼロの核は同型である（意外と難しい）。

*** 余核

双対です。

*** 像と余像

+ 線形代数では、KerとImが先。Coim := Cod/Im が後。
+ アーベル圏では、kerとcokeが先。im := ker(coker)、coim := coker(ker) が後。
+ Ker = Dom(ker), Coker = Cod(coker)
+ Im = Dom(im), Coim = Cod(coim)

*** 射に平行に誘導された射

+ f:A→B に対して6頂点の系列を作る。
+ 「核の余核」と「余核の核」を付け加える。
+ Coker(ker) から B への対角線が一意に決まる。
+ Coker(ker) から Ker(coker) へのfと平行な射が一意に決まる。

一般に、この誘導された射が同型である保証はない。

*1319288253*[圏一般論]これがアーベル圏 

*** アーベル圏の定義

圏Cがアーベル圏とは：

+ Cは加法圏である。
+ Cには核と余核がある（プレアーベル圏）
+ Cでは、準同型定理が常に成り立つ。

*** アーベル圏の性質をひとつだけ

アーベル圏では、

- fがモノなら、f は ker(coker(f)) と射として同型である。

+ fがモノのとき、Coim と Dom が同型であることを示す。
+ 準同型定理を使って、Dom と Ker(coker(f)) の同型を示す。
+ DomとCoimを同一視すれば、f = ker(coker(f)) 。

*** これで

アーベル圏の定義に到達しました。

おめでとうございます。

*** おめでとうございます

hirataraさん、ご結婚おめでとうございます。


</body>
</day>
<day date="2011-10-25" title="">
<body>
*1319517580*[プログラム意味論][モナド][気付いた]モノイドの圏Monの直和に注目すべき

計算の副作用（主作用かも）の定式化はモノイドの圏となるが、モノイドの圏のなかの直和が重要だと気が付いた。つうか、前から細々とは使っていたが、これは大々的に使わないといかん、と思った。

例外（exception）があると、あるストレージ（加群の台）に作用するモノイドは、M + &lt;b&gt;1&lt;/b&gt; の形になる。Mは正常処理から、&lt;b&gt;1&lt;/b&gt; は例外からやってくる。モノイドの圏の直和は、群と同様に自由積で与えられる。集合直和としての M + &lt;b&gt;1&lt;/b&gt; はいったん自由積 M*&lt;b&gt;1&lt;/b&gt; に埋め込まれる。ところが、M*&lt;b&gt;1&lt;/b&gt; は M と同型なので、例外に起因する &lt;b&gt;1&lt;/b&gt; の作用は消えることになる。

例外とは限らない、直和（場合分け）があると、それぞれの直和成分（ケース、選択肢、choice）ごとに作用モノイドが出てくる。これらの作用モノイドの直和＝自由積がストレージに作用する。

ん、モノイドの圏も半環圏になるのか？ と思ったがまったくダメだ。それに、モノイドの圏の直積と割とショーモナイ感じがする -- ほんとに実行が分離しているプログラムのモデルにしかならない。

*1319517878*[プログラム意味論][モナド][マンダラ]インストラクションモノイドの合成法が4つもある

インストラクションセットから作られた自由モノイドが、メモリの状態空間に作用している、というのがノイマン型コンピュータの素直な定式化だろう。

自由モノイドを A&lt;sup&gt;*&lt;/sup&gt; のようなクリーネスターで書くとする。A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt; が自由モノイドの直積、A&lt;sup&gt;*&lt;/sup&gt;#B&lt;sup&gt;*&lt;/sup&gt; が自由積＝直和だとする。自由積に星印を使うとクリーネスターと紛らわしいのでシャープにした。この2つはモノイドの圏&lt;b&gt;Mon&lt;/b&gt;のなかの積と余積だから自然なものだが、実は他にも“積”がある。

- (A×B)&lt;sup&gt;*&lt;/sup&gt;
- (A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt;。

(A×B)&lt;sup&gt;*&lt;/sup&gt;は完全にクロック同期したマシンによる実行。(A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; は最も一般的な並列プログラムで、非同期実行と同期&lt;em&gt;待ち合わせ&lt;/em&gt;が混じっている。

+ A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt; -- 完全に独立（分離）したプログラム実行
+ A&lt;sup&gt;*&lt;/sup&gt;#B&lt;sup&gt;*&lt;/sup&gt; -- インターリービング。タイムシェアリング、コルーチン制御など。
+ (A×B)&lt;sup&gt;*&lt;/sup&gt; -- 単一クロックで完全同期した実行
+ (A&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt;)&lt;sup&gt;*&lt;/sup&gt; -- 一般並列実行協調制御

以前から数珠暖簾や梯子形の紐とかを考えてきたが、モノイドのなかで考えると以上のようになる。梯子のシェープを考えるとタイルの定式化がいいのかもしれない。梯子の横線の射が二重圏の水平射（か垂直射）となるのだろうが、水平圏は単なる完全グラフのような気がする。

しかしなー、一番簡単な例でも積が4種類（もっとかも）あるってのは、ちょっと&lt;em&gt;愕然&lt;/em&gt;としますわ。ABCシステムと例外を入れて混ぜなくてはならない。うううう、複雑だー。生きている間にどこまでわかるのか -- ほんとに微々たる部分しか理解出来ないだろう。うううう。


</body>
</day>
<day date="2011-10-28" title="">
<body>
*1319784373*[圏一般論][雑感]インデックス付き圏

インデックス付き圏て、単にグラフ（ハッセ図）上の関数くらいのノリで扱えばいいんじゃないか。

F[x]がインデックス付き圏のとき、グロタンディーク平坦化は、 ∫F[x]δx とか Σ&lt;sub&gt;x∈X&lt;/sub&gt;F[x] と書けばいいくらい。


</body>
</day>
<day date="2011-10-31" title="">
<body>
*1320021072*[圏一般論][雑感][プログラム意味論][論理]プロ関手の圏

圏の圏&lt;b&gt;Cat&lt;/b&gt;の一般化として、プロ関手の圏&lt;b&gt;Prof&lt;/b&gt;が大事なようだ。

この圏の射＝プロ関手の結合にエンドと余エンドを使うが、エンドと余エンドの双対性を表すには、Σ、Πという記号を使うといいと思う。特に、反転補題（reversing lemma）は自然な形になる。作用積分をeの型に乗せたやつを積積分に展開するのと似ている。

論理の∀、∃、⊃ でも成立しそうだが、よくわからない。

*1320021410*[プログラム意味論][モナド][マンダラ][Caty]トランザクションとか

Catyのトランザクション処理くらい定式化できないと、マンダラのご利益がないよなー。

ローカルリクエスターはABCシステム。トランザクションがあるから、モノイダルスタンピングモナドじゃ不十分で、モノイドの圏の上のある種のツリーモナドで拡張した代数（アイレンベルグ／ムーア圏の対象）をスタンピングする。その代数（拡張されたモノイド）のスタンピングとABCシステムを強調させて、さらに例外モナドとも強調させる。テンソル強度が必要だろう。

モナディックな代数系（非対象モノイド圏としてのEnd(C)内の種々の代数構造のつもり）と、台関手のあいだのベックスワッパー（特にテンソル強度）を何度も使わなくてはならない。ベックスワッパーは分配則だが、どれとどれがどういう具合に分配するか把握できてない。まだまだ整理と調査が必要。


</body>
</day>
<day date="2011-11-01" title="">
<body>
*1320113796*[モナド][気付いた][課題]プロ関手圏のモノイドと多重インデックス付き圏

&lt;b&gt;Cat&lt;/b&gt;またはその部分圏への関手をインデックス付き圏と呼び、多変数関手のときは多重インデックス付き圏と呼ぶことにする。アリティが (&lt;i&gt;D&lt;/i&gt;-, &lt;i&gt;C&lt;/i&gt;+) の関手とは、&lt;i&gt;D&lt;/i&gt;に関して反変、&lt;i&gt;C&lt;/i&gt;に関して共変な多変数関手のこと。

&lt;b&gt;Prof&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;C&lt;/i&gt;)内にモノイドがあれば、アリティが (&lt;i&gt;C&lt;/i&gt;-, &lt;i&gt;C&lt;/i&gt;+) であるインデックス付き圏を定義するだろう。しかし、必ずしもアリティが (&lt;i&gt;C&lt;/i&gt;-, &lt;i&gt;C&lt;/i&gt;+) ではない二重インデックス付き圏はどうなる？

二重インデックス付き圏、あるいはより一般の多重インデックス付き圏とは、&lt;b&gt;Prof&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;C&lt;/i&gt;)モノイドの拡張と言えるのだろうか？ それとも、&lt;b&gt;Prof&lt;/b&gt;をベースに多重インデックス付き圏を説明できるのだろうか。


</body>
</day>
<day date="2011-11-08" title="">
<body>
*1320717398*[msched][課題][雑感]issueトラッカー

bitbucketのissueトラッカーのグチとかは次に書いている。

- https://bitbucket.org/project_caty/dev/issue/43/misc-bitbucke &lt;br&gt;misc: Bitbuckeの困ったところ

以前からメッセージング＋スケジューラみたいなものが欲しくて、そのことは mschedというタグで書いている。

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%2A%5Bmsched%5D

最近また、もう少しマシなイシュートラッカーが欲しいと思っている。イシュートラッカーの構成要素は：

+ イシューの集合
+ イシュータイプの集合。個々のイシューはイシュータイプを持ち、同じタイプのイシューは同じ振る舞いをする。
+ 状態の集合。イシューはどれかの状態にある。
+ イシューの状態遷移。どんな状態遷移が可能かはイシュータイプで規定される。
+ 時間軸の集合。人とか組織とかにそれぞれ１本の時間軸を与える。実際には、なんらかのキャパシティを持った2次元の空間なので、スケジュール空間とか呼ぶほうがいいかもしれない。
+ エージェントの集合。イシューに記載されたタスクの実行主体。エージェントごとに時間軸（スケジュール空間）を持つ。
+ 割り当て：イシューとエージェントの持つスケジュール空間との対応。
+ ログ：時間方向のあらゆる変化の記録。これがないとトラックできない。

各構成要素のネーミングとか、関連性とかメッセージングとかも必要。

</body>
<comments>
<comment>
<username>soda</username>
<body>1～4はRedmineでできそうですね( http://redmine.jp/guide/RedmineIssueTrackingSetup/ )。8.もRedmineページで良さそうな気がします。5～7は、チケットに着手日や期限を記録しておいてガントチャートで表示する程度ならありますが…</body>
<timestamp>1320924631</timestamp>
</comment>
<comment>
<username>soda</username>
<body>書き誤りがありました。_o_ &lt;br&gt;s/8.もRedmineページ/8.もRedmineの「活動(Activity)」ページ/</body>
<timestamp>1320924715</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>sodaさん、ありがとうございます。&lt;br&gt;こんな所に書いたグチを読んで応答してくださる方がいるだけで感激ものです。&lt;br&gt;&lt;br&gt;Redmineというものが存在することは知ってました。本屋でRedmine本の背表紙を見た記憶があります。&lt;br&gt;が、存在以上は何も知らないのでちょっと調べてみます。&lt;br&gt;&lt;br&gt;ともかくも、もう少しマシなissuetトラッカーを備えたリポジトリホスティングがあればいいのだけど、、、</body>
<timestamp>1320973609</timestamp>
</comment>
</comments>
</day>
<day date="2011-11-12" title="">
<body>
*1321073864*[モノイド圏][モナド][説明]モノイド圏内のモノイド対象の圏とパラメータ付きモナド

&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;これは、 本編のコメント http://d.hatena.ne.jp/m-hiyama/20111107#c に対して書いたもの。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt; などは単なる圏、&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;N&lt;/i&gt; などはモノイド圏を表すと約束する。モノイド圏のモノイド積と単位対象は、□, I を主に使う。以下の議論では、大きな圏を扱うと破綻するだろうから、適当なsmallnessは仮定する。

圏 &lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt; に対する関手圏は、通常 &lt;i&gt;D&lt;/i&gt;&lt;sup&gt;&lt;i&gt;C&lt;/i&gt;&lt;/sup&gt; と書かれるが、上付き指数が嫌なので [&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;] を使う。念のために定義を述べると：

+ 対象の集合： Obj([&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;]) = |[&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;]| = Func(&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;) = (&lt;i&gt;C&lt;/i&gt;から&lt;i&gt;D&lt;/i&gt;へのすべての関手)
+ ホムセット： [&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;](F, G) = Nat(F, G :&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt;) = (FからGへのすべての自然変換)

&lt;h5&gt;&lt;i&gt;M&lt;/i&gt; がモノイド圏なら [&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;] もモノイド圏&lt;/h5&gt;

&lt;i&gt;M&lt;/i&gt;がモノイド圏のとき、関手圏 [&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;] には、&lt;i&gt;M&lt;/i&gt;のモノイド構造から誘導された標準的なモノイド構造を入れることができる。

記号を乱用して、&lt;i&gt;M&lt;/i&gt; = (&lt;i&gt;M&lt;/i&gt;, □, I) として、[&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;]上に定義される積と単位も □, I とすると、おおざっぱな書き方で：

+ (F□G)(x) := F(x)□G(x) （xは、&lt;i&gt;C&lt;/i&gt;の対象または射）
+ I(x) := (I in &lt;i&gt;M&lt;/i&gt;) （定数関手）

&lt;h5&gt;モノイド対象の圏は、関手圏とみなせる&lt;/h5&gt;

&lt;i&gt;M&lt;/i&gt;がモノイド圏のとき、&lt;i&gt;M&lt;/i&gt;内のモノイド対象とモノイド準同型射が定義できて、その全体は圏となる。モノイド圏&lt;i&gt;M&lt;/i&gt;のモノイド対象（とモノイド準同型射）からなる圏を Mon(&lt;i&gt;M&lt;/i&gt;) と書く。

モノイド圏とモノイド関手の全体からなる圏を &lt;b&gt;MonCat&lt;/b&gt; とすると、Monは &lt;b&gt;MonCat&lt;/b&gt;→&lt;b&gt;MonCat&lt;/b&gt; という関手とみなせる。関手Monは表現可能で、その（共変の）表現対象は単体圏（the simplex category）&lt;b&gt;Δ&lt;/b&gt; である。つまり：

- Mon(&lt;i&gt;M&lt;/i&gt;) = &lt;b&gt;MonCat&lt;/b&gt;(&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;) （= は圏同値）

関手圏（圏の指数）を&lt;b&gt;MonCat&lt;/b&gt;内で考えるなら：

- Mon(&lt;i&gt;M&lt;/i&gt;) = [&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;] （= は圏同値）

つまり、Mon = Mon(-) は、[&lt;b&gt;Δ&lt;/b&gt;, -] = (-)&lt;sup&gt;&lt;b&gt;Δ&lt;/b&gt;&lt;/sup&gt; in &lt;b&gt;MonCat&lt;/b&gt; 。

&lt;h5&gt;圏の圏はデカルト閉&lt;/h5&gt;

圏の圏&lt;b&gt;Cat&lt;/b&gt;は、圏の直積をモノイド積、1つの対象だけからなる圏を単位対象、圏同値をイコールのように扱って、デカルト閉になる。したがって、カリー化、反カリー化を行なってよい。

&lt;h5&gt;発見的な等式変形&lt;/h5&gt;

&lt;i&gt;C&lt;/i&gt;は単なる圏、&lt;i&gt;M&lt;/i&gt;はモノイド圏として、以下の変形は不正確だがソレラシイ感じがする。「//」の後はコメント。

+ Mon([&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;]) // Monを&lt;b&gt;Δ&lt;/b&gt;で表現
+ [&lt;b&gt;Δ&lt;/b&gt;, [&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;]&amp;#93; // 反カリー化
+ [&lt;b&gt;Δ&lt;/b&gt;×&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;] // 直積の対称性
+ [&lt;i&gt;C&lt;/i&gt;×&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;] // カリー化
+ [&lt;i&gt;C&lt;/i&gt;, [&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;]&amp;#93; // Monの定義
+ [&lt;i&gt;C&lt;/i&gt;, Mon(&lt;i&gt;M&lt;/i&gt;)]

実際には、ブラケット [-, -] をオーバーロードしているので：

+ Mon(&lt;b&gt;Cat&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;) in &lt;b&gt;MonCat&lt;/b&gt;)
+ &lt;b&gt;MonCat&lt;/b&gt;(&lt;b&gt;Δ&lt;/b&gt;, &lt;b&gt;Cat&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;) in &lt;b&gt;MonCat&lt;/b&gt;)
+ &lt;b&gt;Cat&lt;/b&gt;(&lt;b&gt;Δ&lt;/b&gt;×&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;) in &lt;b&gt;MonCat&lt;/b&gt;
+ &lt;b&gt;Cat&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;×&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;) in &lt;b&gt;MonCat&lt;/b&gt;
+ &lt;b&gt;Cat&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;MonCat&lt;/b&gt;(&lt;b&gt;Δ&lt;/b&gt;, &lt;i&gt;M&lt;/i&gt;)&amp;#41; in &lt;b&gt;MonCat&lt;/b&gt;
+ &lt;b&gt;Cat&lt;/b&gt;(&lt;i&gt;C&lt;/i&gt;, Mon(&lt;i&gt;M&lt;/i&gt;)&amp;#41; in &lt;b&gt;MonCat&lt;/b&gt;

2から3への変形どうなってんの？ &lt;b&gt;Δ&lt;/b&gt;×&lt;i&gt;C&lt;/i&gt; は単なる直積か？ これらのあいだに、ほんとに自然な対応が作れるのか？ -- たぶん、なとかなるでしょ。

2つの圏、&lt;b&gt;Cat&lt;/b&gt;と&lt;b&gt;MonCat&lt;/b&gt;を行ったり来たりして、外部ホムセットと内部ホム（指数）も行ったり来たりでヤヤコシイが、こういう等式（圏同値）変形ができるとウレシイかも。

&lt;h5&gt;たぶん、導かれること&lt;/h5&gt;

発見的な等式変形でやったことは&lt;em&gt;アヤシイ&lt;/em&gt;けど、これに近い事実は期待していいだろう、つうことで：

- &lt;i&gt;C&lt;/i&gt;が圏、&lt;i&gt;M&lt;/i&gt;がモノイド圏のとき、Mon([&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;M&lt;/i&gt;]) = [&lt;i&gt;C&lt;/i&gt;, Mon(&lt;i&gt;M&lt;/i&gt;)]

圏&lt;i&gt;D&lt;/i&gt;上のモナドの圏を Monad(&lt;i&gt;D&lt;/i&gt;) とすると、Monad(&lt;i&gt;D&lt;/i&gt;) = Mon([&lt;i&gt;D&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;])。上記の&lt;i&gt;M&lt;/i&gt;のところに、[&lt;i&gt;D&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;] を“代入”すると

- Mon([&lt;i&gt;C&lt;/i&gt;, [&lt;i&gt;D&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;]&amp;#93;) = [&lt;i&gt;C&lt;/i&gt;, Mon([&lt;i&gt;D&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;])] = [&lt;i&gt;C&lt;/i&gt;, Monad(&lt;i&gt;D&lt;/i&gt;)]


</body>
<comments>
<comment>
<username>###</username>
<body>お返事をどうもありがとうございました．ほんの短い時間に大幅な一般化を示唆していただいて，嬉しく思うと同時に驚いております．パラメータ圏Cを固定して考えるとき，与えられたモノイド圏Mに対し，Cによるパラメトライズの作用とMon(.)の作用が(広い意味で)双対的な関係となる，というのが本質だということですね．&lt;br&gt;一つ気になったのはMon(M) = MonCat(Δ, M) (圏同値)についてで，わたしはMがストリクトモノイド圏のときに限って証明したのと，一般のモノイド圏でのコヒーレンスについてはまだ勉強不足なこともあって，一般に成り立つか自信がないです．&lt;br&gt;&lt;br&gt;ともかく大筋には納得できました．記事本文の2.から3.への変形については，わたしもまだ厳密には証明していないのですが，以下ではMをストリクトモノイド圏として…&lt;br&gt;&lt;br&gt;・Cから生成される自由(ストリクト)モノイド圏を@Cと書く．この@は射にも拡張し関手とでき，(自由対象の構成として)いつも通りにMonCatからCatへの忘却関手Uを右随伴とする．&lt;br&gt;&lt;br&gt;つまり，Uを明示すれば&lt;br&gt;・Cat(C, UM) = MonCat(@C, M) (同型)　----------(*)&lt;br&gt;&lt;br&gt;故に，所望の変形(記事本文の2.-6.)は&lt;br&gt;[1] MonCat(Δ, Cat(C, M) in MonCat)&lt;br&gt;[2] MonCat(Δ, Cat(C, UM) in MonCat)　//(*)を適用&lt;br&gt;[3] MonCat(Δ,MonCat(@C, M))　//反カリー化&lt;br&gt;[4] MonCat(Δ×@C, M)&lt;br&gt;[5] MonCat(@C×Δ, M)　//カリー化&lt;br&gt;[6] MonCat(@C, MonCat(Δ, M))&lt;br&gt;[7] MonCat(@C, Mon(Δ, M))　//(*)を適用&lt;br&gt;[8] Cat(C, UMon(Δ, M)) in MonCat&lt;br&gt;[9] Cat(C, Mon(Δ, M)) in MonCat&lt;br&gt;として得られると思います．つまり，カリー化，反カリー化をMonCatの方に押し付けた形です．&lt;br&gt;&lt;br&gt;だいぶよい見通しが得られたと思っています．本当にありがとうございました．</body>
<timestamp>1321086550</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>&gt; 一般に成り立つか自信がないです．&lt;br&gt;たぶん、なとかなるでしょ。&lt;br&gt;&lt;br&gt;&gt; つまり，カリー化，反カリー化をMonCatの方に押し付けた形です．&lt;br&gt;いけそうですね、たぶん。&lt;br&gt;&lt;br&gt;本編のほうにも、さっき少しコメントを追加しておいたのですが、computationsへの応用だと、もっとたくさんのモナド類似物の取り扱いが必要で、テンソル強度やベックの分配法則で、たくさんのモナド類似物を組み合わせます。&lt;br&gt;だいたいの雰囲気は実例から分かるのですが、計算がけっこうシンドクテ、ちっとも確認してません。なにか確かな結果が分かったら教えて下さい。</body>
<timestamp>1321087264</timestamp>
</comment>
</comments>
</day>
<day date="2011-11-16" title="">
<body>
*1321410555*[caty][雑感]ユースケース図もどき

まーまー、ソレラシイかな。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/shop-system_ucase.gif&quot; &gt;

&lt;a href=&quot;http://www.chimaira.org/img2/shop-system_ucase.gif&quot;&gt;原寸大画像&lt;/a&gt;

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
/* 
 * http://www.atmarkit.co.jp/im/carc/serial/renew_uml08/renew_uml08.html
 * の図1をベースに修正したもの
 */

module shop-system in cara;


userrole 管理者;
userrole 店員;
userrole オンライン顧客;
userrole オフライン顧客;


state 商品購入     for オンライン顧客  :: deferred links {
  + 購入 --&gt; 購入処理.実行;
  + キャンセル --&gt; ホーム.取得;
};

state 購入商品確認 for オンライン顧客  :: deferred links {
  // まだ定義してない
};

state 商品登録     for [店員, 管理者]  :: deferred;
state 売り上げ集計 for 管理者          :: deferred;
&lt;/pre&gt;



</body>
</day>
<day date="2011-11-19" title="">
<body>
*1321691471*[メモ][人物]Pachner

- http://ja.forvo.com/search/pachner/

によると、Pachnerはパフナーがよさげ。

- http://d.hatena.ne.jp/m-hiyama-memo/archive?word=Pachner

*1321691881*[caty][雑感]ユースケース間の関係性

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20111116/1321430548&quot;&gt;ユースケース図&lt;/a&gt;の extends, includeとかって、「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110802/1312256095&quot;&gt;入れ子のオートマトンはトレースで実現&lt;/a&gt;」のような話ではないのかな？ どうにも曖昧な記述しかないからなんとも言えないが。

*1321691982*[課題][雑感]確認すべきこと

+ メイヤーオートマトンのマイヒル／ネロードの定理 -- これはほとんどOK。どう発展させるかを考える。
+ フビニ／グロタンディーク同値 -- だいたい大丈夫な気がするが、ちゃんと計算してない。
+ フレイド圏のJが随伴を持つときにモナドを構成する -- クライスリ圏からのモナド再現を一般化するのだろう。
+ ホーアトリプルのインスティチューションによる一般化 -- あんまりわかってない。
+ ペトリネットのマーキングの一般化と双対の定式化 -- 単なる山勘、アヤシイ。
+ オートマトンの森田同値 -- 当初の目論見はダメだった。で、ほったらかしだが、なんかありそう。
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%B7%C1%BC%B0%B8%C0%B8%EC%B7%CF&quot;&gt;形式言語系&lt;/a&gt;を相対モナドを使って定式化できないか？
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060502/1146561239&quot;&gt;モナドの作用乗法&lt;/a&gt;って何だったのか？
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110120/1295487963&quot;&gt;ハイパーリンク&lt;/a&gt;をちゃんと書いておいたほうがいい。
+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20090317/1237285079&quot;&gt;境界付きアルファベット&lt;/a&gt;って、結局よく分からないまま。なんとかしたい。

&lt;b&gt;[追記]&lt;/b&gt;それと、ユースケース図とかシナリオとかナニヤラの曖昧な定義を、状態遷移ベースでまともにしたい。けっこう深刻な事情があるし。&lt;b&gt;[/追記]&lt;/b&gt;

*1321694073*[課題][雑感][用語法][プログラム意味論]また、時間の空間

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/archive?word=%BB%FE%B4%D6%A4%CE%B6%F5%B4%D6&quot;&gt;時間の空間&lt;/a&gt;というワケワカラナイ言葉を何度か使っている。国語的にあまりにも変だから止めようと思いながらも使っている。意外と本質を突いた言葉かもしれないし。

並列性とか対話性とかの制御＆データフローを考えと、どうしても時間の空間に行き着いてしまう。時間の空間は避けられない気がする。とりあえず、時間シェープと呼ぶことにする。時間シェープは、時間パラメータが走る変域。

時間シェープの圏TShpを考える。これは (0, 1)-コボルディズム圏だと思う。時間シェープのあいだの変換なり模倣なりを考えるともう１次元上がって、2セルが存在する。2セルをタイルと考えて、二重圏とするのが一番良さそうだ。それでさらに、モノイド積があるから、モノイド二重圏、いや半環二重圏だろうな。

TShpで考えられる演算を列挙すると：

+ 直列結合（順次結合、逐次結合）：時間シェープの終端境界（これは0次元空間）と開始境界を糊付けする。
+ 並列結合＝直和 ： 単に直和、可換（対称）なモノイド積となる。
+ テンソル積＝直積 ： 0×0 = 0, 1×1 = 1 なので次元が上がらないで well-defined。
+ 2セルの結合＝写像や関係の結合

圏&lt;i&gt;C&lt;/i&gt;を持ってきて、&lt;i&gt;C&lt;/i&gt;を値（ラベル）とするカテグラフの圏を作る。これは、&lt;i&gt;C&lt;/i&gt;ラベル付きタングルと同じように作る。

+ 0セル＝一点に&lt;i&gt;C&lt;/i&gt;の対象を対応付ける。
+ 1セルに&lt;i&gt;C&lt;/i&gt;の射を対応付ける。
+ &lt;i&gt;C&lt;/i&gt;が高次構造を持つなら、2セルにも対応を付ける。

&lt;i&gt;C&lt;/i&gt;カテグラフに対して、直列結合と並列結合は自然に定義できる。&lt;i&gt;C&lt;/i&gt;がテンソル積（モノイド積）を持っているなら、カテグラフのテンソル積も定義できる。２次元（以上）の構造はよくわからない。

&lt;i&gt;C&lt;/i&gt;カテグラフの圏は、&lt;i&gt;C&lt;/i&gt;にTShpで時間概念を入れた圏となるだろう。TShpの部分圏を取ったり、TShpを別な圏に取り替えれば時間概念が変わるから振る舞いの定義も変わる。

TShpとは別に、しかし類似の構造を持った構文的対象のコボルディズム類似の圏を作る。時間シェープの圏、構文的対象（プログラムの記述）の圏、意味論を提供する&lt;i&gt;C&lt;/i&gt;の3つの圏のあいだの関係を議論することになるだろう。時間を含んだ意味論には、時間の圏が必要だってことだ。たぶん。


</body>
</day>
<day date="2011-11-22" title="">
<body>
*1321930125*[圏一般論][雑感][マンダラ][プログラム意味論]もっともっとカテゴリカルに

自分はけっこう圏論を使うほうだと思っていが、どうも甘いな、ダメだな。圏論使いになり切れてない。

なんというか、ある種の遠慮、躊躇＜ためら＞い、照れ、とかがあるような気がする。「ここはまー、圏論持ちださなくてもいいだろう」「なにもそこまでやんなくても」みたいな感覚。これがイカンのだと思う。自主規制する必要はない。もっと徹底的にガッツンガッツンに使うべきだろう、と最近思った。

圏論だと点と空間の区別がつかなくなる。集合も空間も別に点を持つとは限らないし、一方で、集合も空間も図式の上では一点（対象）で描かれる。高次圏を考えることはできるが、次元の概念も揺らぐ。

とりあえずは、状態遷移を定式化するとき、状態遷移そのものを射と考えてもいいし、ひょっとすると状態遷移は関手かもしれない、と。状態遷移において、状態点と状態空間の区別が付かないのは、ある意味当然なことになる。状態点が実は状態空間でもあるかもしれない。空間はなんらかの圏だと解釈できるから、点と圏の区別さえつかないような世界になる。これはスノーグローブの世界、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20071212/1197437412&quot;&gt;手塚治虫が描いていた無限階層性&lt;/a&gt;のようなものだろう。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110624/1308891741&quot;&gt;ネアンデルタールのレベル&lt;/a&gt;から圏論で考えたほうがいいのだ、たぶん。そこまでしないと、モノの見え方が変わらない。

*1321944496*[メモ] 予約

- 木曜日の 12:30 


</body>
</day>
<day date="2011-11-24" title="">
<body>
*1322092923*[雑感][マンダラ][高次圏論][TQFT][課題]マンダラと時間

僕の作業仮説「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%DE%A5%F3%A5%C0%A5%E9&quot;&gt;マンダラ仮説&lt;/a&gt;」は、「&lt;b&gt;計算現象のモデルは複雑だろう&lt;/b&gt;」という予測。単に複雑だ、というだけじゃなくて、どんな複雑さかのラフな描像を含む。キッカケは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20050614/1118708091&quot;&gt;マーク・ホプキンス&lt;/a&gt;の指摘。それと、その後の僕の経験に由来する。

TQFT、まー、Q=Quantum はあんまり関係無いのでTFT（Toplogical Field Theory）と呼ぶべきだろうけど -- その枠組でプログラム意味論／計算モデルを作れないか、という話だ。（いきがかり上、Qも付けて引き続き「TQFT」と呼ぶ。）

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111119/1321694073&quot;&gt;時間の空間&lt;/a&gt;という概念を認めた上で、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100818/1282117192&quot;&gt;フローチャート&lt;/a&gt;を計算モデルの中核に据えれば、TQFTの枠組みは自然だと思える。

TQFTは、ある種の関手 Z:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;V&lt;/i&gt; だ。この関手を構成したり性質を調べるのが課題だが、別な Z':&lt;i&gt;C'&lt;/i&gt;→&lt;i&gt;V'&lt;/i&gt; があるとき、ZとZ'の関係も議論したい。TQFTの圏&lt;b&gt;TQFT&lt;/b&gt;が必要だろう。

とはいえ、任意のTQFTが必要なわけじゃないし、とてもじゃないが扱えない。関手Zが、プログラムの記述（ソースコード）にプログラムの振る舞いを対応させるような関手になっているものだ。ここで、ソースコードとはテキストで書かれたコードではなくて、グラフィカルなソースコード、つまりフローチャートだ。

フローチャートはシェープ（姿形）とラベリング（値や記号の割り当て）から出来ている。シェープは図形的なものだから、(0, 1)次元のコボルディズム圏で記述できるだろう。ラベリングの値はプログラム素子となる。プログラム素子をフローチャートのシェープ（線の図形）上に配置していけば回路図ができあがる。この回路図がプログラム記述＝フローチャート。プログラム素子は別な圏の射となっている。

圏でラベリングしたシェープは、圏ラベル付きグラフだから、 &lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%AB%A5%C6%A5%B0%A5%E9%A5%D5&quot;&gt;カテグラフ&lt;/a&gt;と呼んでいた。シェープがタングルの場合は、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111004/1317692905&quot;&gt;サークル&lt;/a&gt;の扱いに注意する必要がある。カテグラフの特殊ケースにリグラフがある。ラベルが半環に値を取るグラフだ。非可換半環を対象が1つの対称モノイド圏とみなせばいい。rigは半環の別名。

リグラフの全体が、行列の圏の一般化になっているのはすぐ分かる。となると、カテグラフの圏も行列の圏の一般化のはずだ。行列計算で出来ることをカテグラフでも行いたい。行列のトレースや行列式は、カテグラフの文脈でどんな意味があるのだろう？

行列計算は、およそ経路（軌道）の計算と見なせる。軌道とは位置の履歴である。履歴 -- 時間だ、時間が出てくる。時間をどう取り扱えばいいのだ？ それが分かれば、マンダラの正体が少しは明らかになる気がする。

*1322098669*[Caty]ポート束縛

次の4種がある。直接接続（ノードの重ね合わせ）は2種。

+ port to action （直接接続、接続後にポートは消失）
+ port to port （直接接続、接続後にポートは分岐点）
+ port to url （redirect間接接続）
+ url  to port （redirect間接接続）

その他の接続は通常のモジュール記述で行える。

</body>
</day>
<day date="2011-11-25" title="">
<body>
*1322204253*[Caty]自動描画とインスタントモックアップ

2010年8月20日に書いた「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100820/1282270208&quot;&gt; Webサービスの設計：Webの状態遷移図の描き方&lt;/a&gt;」に次の手描きの絵を載せた。

&lt;img src=&quot;http://www.chimaira.org/img2/webstone-login-module.gif&quot; &gt;

それから1年3ヶ月、次はCatyに描かせた。1秒もかからないで描く。

&lt;img src=&quot;http://www.chimaira.org/img2/login2a-state.gif&quot; &gt;

レイアウトの左右が逆だったりするが、内容的にはまったく同じ。もう少し詳しく描けば次のよう。

&lt;img src=&quot;http://www.chimaira.org/img2/login2a.gif&quot; &gt;

これが単なる説明や文書用の絵じゃなくて、動いてしまうってのがミソ。いや、今はインスタントモックアップが出来てないから、即座に動くわけじゃないが、スクリプトとテンプレートを手で書き足せば動く。&lt;em&gt;書き足すのがメンドクサイ&lt;/em&gt;ので&lt;b&gt;インスタントモックアップ&lt;/b&gt;ってことなのだけどね。

次はソースコード。

&lt;pre class=&quot;code&quot;&gt;
module login2a in cara;

type LoginUI     = deferred object;
type AccountInfo = deferred object;

/** ユーザー登録画面の生成 */
port ユーザー登録;

/** ログイン成功時のリダイレクト先 */
port 成功時の処理;

/** 開始状態 */
@[abstract]
state 開始 :: void links {
  - enter --&gt; ログイン.get;
}; 

/** ログイン画面 */
state ログイン画面 :: LoginUI links {
  /* IDとパスワードを入れてサブミット */
  - submit      --&gt; ログイン処理.do;
  - new-account --&gt; ユーザー登録;
};

/** ログイン再試行画面 */
state 再ログイン画面 :: LoginUI links {
  /* IDとパスワードを入れてサブミット */
  - resubmit    --&gt; ログイン処理.do;
  - new-account --&gt; ユーザー登録;
};


/** ログイン画面の生成 */
resource ログイン(&quot;/login.html&quot;) {
  action get(&quot;/GET&quot;)
  :: @[in, out] #io void -&gt; LoginUI produces ログイン画面 ;
  
};

/** ログイン処理 */
resource ログイン処理(&quot;/do-login.cgi&quot;) {
  action do(&quot;/POST&quot;)
  :: @[in]  #in AccountInfo -&gt; _       relays [ok, ng],
     @[out] #ok _           -&gt; void    redirects 成功時の処理,
     @[out] #ng _           -&gt; LoginUI produces  再ログイン画面 // retry
   ;

};
&lt;/pre&gt;

*1322215177*[Caty][モノイド圏][トレース／コンパクト閉圏]Webのモデルとエルゴット圏

エルゴット流の計算モデルを作るベースをエルゴット圏と呼ぶことにする。具体的には、トレース付き余デカルト圏。直和（余デカルト積）をモノイド積とするモノイド圏にトレースを入れたもの。直積もあったほうが便利なことが多いので、加法的トレースを持つデカルト半環圏と定義したほうがいいかもしれない。

エルゴット圏は、Webのモデルにも使えると思う。ハイパーリンクグラフはエルゴット圏に落として考えることができる。エルゴット圏の軌道が計算過程を表す状況は多いが、Web上での行動が軌道を描く。

今日はもう時間がないから、ここまで。


</body>
</day>
<day date="2011-11-26" title="">
<body>
*1322289906*[caty][プログラム意味論]ユースケースをなんとかする -- 手始め

ユースケース＝サブシステムなんだと思うが、これといってサブシステムの厳密な定義もないしね。

とりあえず、システムはなんらかの状態遷移系だとする。状態遷移系はその遷移グラフで決まるから、ラベル付き有向グラフでシステムを表現することにする。ラベルは頂点ラベル、辺ラベルの両方を認める。ラベリングが要らないなら、単元集合をラベル値の集合にしておけばいい。

システムを表すグラフGは次のものから構成される。

+ 頂点集合 N
+ 辺集合 E
+ 辺の始点と終点 src, trg: E→N
+ 頂点ラベル値の集合 L&lt;sub&gt;N&lt;/sub&gt;
+ 辺ラベル値の集合 L&lt;sub&gt;E&lt;/sub&gt;
+ 頂点ラベリング ν : N→L&lt;sub&gt;N&lt;/sub&gt;
+ 辺ラベリング ε: E→L&lt;sub&gt;E&lt;/sub&gt;

多重辺もループも認める。有限性の条件は課さない。もう何でもあり。

圏論風に、Gの頂点の集合を |G|、頂点A, Bに対する辺の集合を G(A, B) とする。a∈E が、src(a) = A, trg(a) = B のとき、a:A→B in G と書く。

G = (N, E, ν, ε)、G' = (N', E', ν', ε') のとき、写像 f&lt;sub&gt;N&lt;/sub&gt;:N→N', f&lt;sub&gt;E&lt;/sub&gt;:E→E' が次の条件を満たすとき、ラベル厳密保存のグラフ準同型写像と呼ぶ。

- src(f&lt;sub&gt;E&lt;/sub&gt;(a)) = f&lt;sub&gt;N&lt;/sub&gt;(src(a))
- trg(f&lt;sub&gt;E&lt;/sub&gt;(a)) = f&lt;sub&gt;N&lt;/sub&gt;(trg(a))
- ν'(f&lt;sub&gt;N&lt;/sub&gt;(A)) = ν(A) forall A∈N
- ε'(f&lt;sub&gt;E&lt;/sub&gt;(a)) = ε(a) forall a∈E

ラベル値の集合が順序集合のとき、ラベル保存の条件をゆるめて、laxグラフ準同型写像とoplaxグラフ準同型写像を定義する。

lax条件：

- ν(A) ≦ ν'(f&lt;sub&gt;N&lt;/sub&gt;(A))  forall A∈N
- ε(a) ≦ ε'(f&lt;sub&gt;E&lt;/sub&gt;(a))  forall a∈E

oplax条件：

- ν'(f&lt;sub&gt;N&lt;/sub&gt;(A)) ≦ ν(A) forall A∈N
- ε'(f&lt;sub&gt;E&lt;/sub&gt;(a)) ≦ ε(a) forall a∈E

辺に型をラベリングして、型の包含関係（階層関係）を順序構造にすることは多い。サブシステムの記述と少し違うが、Catyのリソースをノードにするとマッチング階層で順序構造を入れたりもできる。

&lt;hr &gt;

自然数の区間[0, n]をラベリングなし有向グラフ（竹グラフ）とみて、ラベリングを考えないグラフ準同型を長さnの軌道（trajectory）と呼ぶ。グラフGに対して、軌道の全体を Traj(G) とする。始点と終点を決めて、Traj(G)(A, B) のような記法も使う。長さがちょうどn、n以下の軌道は、Traj&lt;sup&gt;n&lt;/sup&gt;(G), Traj&lt;sup&gt;≦n&lt;/sup&gt;(G) と書く。

ラベリングを忘れて、圏と同様に、広い準同型、充満準同型、忠実準同型、埋め込みなどを定義する。直和と直積も圏と同じに定義する。

中途半端だが、今日はこのへんで。

*1322293780*[圏一般論][プログラム意味論][気付いた]Cob-Para自由構成

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111125/1322215177&quot;&gt;Webのモデルとエルゴット圏&lt;/a&gt;」とかとも関係するのだが、もっと一般的な話。たいへんに曖昧だが、それでもたぶん使える、役に立つ。

まず、コボルディズム圏とは何か？というとよく分からない。多様体とか（幾何的）複体の概念を使って(n, n+1)-コボルディズム圏を定義するのはまーできるでしょう。角付きになると難しいし、二重圏の構造を持つ。次元が混じってしまった普遍的なコボルディズム圏があって、それは高次圏のなかでも特別なものなんだろうと思うが、ワカランわ。

ワカランのだけど、次元が低い場合、0, 1, 2くらいなら見当はつく。特に、(0, 1)-コボルディズム圏は時間の圏だと捉える。普遍的で大きなコボルディズム圏とかコボルディズム圏の総体は分からないが、個々の小さな特定のコボルディズム圏なら分かる。

次にパラ圏（paracategory, http://ncatlab.org/nlab/show/paracategory）、これはプレ圏（プリ圏、前圏、precategory）と同じ概念だが、パラのほうが語感がいいのでパラ圏にする。単なる有向グラフもパラ圏だし、普通の圏もパラ圏になる。擬パラ圏とかも面白いと思うが、まー、とりあえずパラ圏で。

&lt;b&gt;Bam&lt;/b&gt;を竹グラフ（bamboo）の全体に端点接合を入れたコボルディズム圏とする。Gはグラフとする。&lt;b&gt;Bam&lt;/b&gt;からGへのグラフ準同型の全体に、&lt;b&gt;Bam&lt;/b&gt;のコボルディズム構造を使って結合と恒等（一点グラフからの準同型）を定義して圏を作れる。これはGから作った自由圏と同じもの。

今の自由構成を一般化したものが&lt;strong&gt;Cob-Para自由構成&lt;/strong&gt;。短く&lt;strong&gt;CP自由構成&lt;/strong&gt;ともいう。Cを（よくワカランが）なんらかのコボルディズム圏、Pをパラ圏とする。CからPへのグラフ射の全体に圏構造やその他の構造（直和モノイド積とか）を入れる。これで自由ナントカ圏ができる。さらに、Pが持っていた部分的な構造を使って同値関係を入れる。同値関係で割り算して出来たモノがCP自由構成。自由とは言いながら割り算をしていることに注意。

以上の直感的かつイイカゲンなことを、厳密に定義するのはなかなかに大変な作業だと思う。しかし、個々の具体例を作ることはできなくも無い。Cが竹グラフの場合、竹グラフの直和（数珠暖簾と呼んでいた）の場合、梯子形の場合、とかだ。また、Cに単体や方体として2セルを入れて、1次元高い状況で考えることもできる。

CP自由構成で出来上がった圏の射は何かというと、軌道、世界線、世界膜とでも呼ぶべきもので、ある種の運動学的実体となる。Pが、とあるパラ圏の&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%EC%A5%EB%A5%E0&quot;&gt;レルム&lt;/a&gt;に属するとき、適当なCに対するCP自由構成が再び同じレルムに属することは、&lt;em&gt;基本定理として扱われる&lt;/em&gt;ことがある。ステファネスクのネットワーク代数に関する基本定理はこの形をしている。この形の主張を、&lt;strong&gt;基本閉性&lt;/strong&gt;（fundamental closure property）と呼んでいいだろう。

基本閉性があると、軌道の次元を上げていくことができるし、ホモトピーを考える途もある。もっとも、次元が0, 1だとそれ以上に次元が上がらないが、それはそれで次元的に閉じた世界になっていてケッコウなことだと思う。



</body>
</day>
<day date="2011-11-29" title="">
<body>
*1322535561*[圏一般論][雑感]オペラッド

オペラッドを何に使うか、少しだけ分かってきた。少しだけ。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20111128/1322438761&quot;&gt;本編で触れたトム・レンスター&lt;/a&gt;は、Homotopy Algebras for Operads でオペラッド概念をキチンと分類定義している。

まず、基本となる素のオペラッドがある。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110916/1316155861&quot;&gt;マニン&lt;/a&gt;なんかが言っているオペラッドは、線形対称オペレッドで、素のオペラッドではない。

素のオペラッドはほんとに素朴な概念だ。これに色々と付加構造を入れていく。

+ 型（または色）を入れると、複圏＝色付きオペラッドとなる。
+ 対称群の作用を考えると、対称オペラッドとなる。ブレイド群やローテートシフト群などを考えてもいいだろう。
+ 演算（記号）の集合を、対称モノイド圏の対象に代えると豊饒オペラッドとなる。

これ以外の一般化としては、複圏じゃなくて多圏との対応を考えて多オペラッドを定義できそう。僕の目的だと多オペラッドが必要だ。多オペラッドの計算は、ほとんどスパイダー計算だと思う。


</body>
</day>
<day date="2011-12-06" title="">
<body>
*1323130598*[圏一般論][Caty]データセットが難しい理由

「データセット」はテストに使うための集合を意味するが、前もって生成して保存しておくか、その場で作る。データセットの議論は以外に難しい。

ちと考えてみたら、データセットの圏というのがけっこう変な圏なので。それで直観が効きにくく、難しさに繋がっている。データセットは整列順序 (well-order) を持つので、高々加算の整列集合の圏だと思ってよい。が、列挙（enumeration）とかノルムとかも考える。列挙やノルムの構造をうまく作ろうとすると、直積／直和のデカルト構造は壊れてしまう。

データセットの圏は、デカルト圏からすごく離れてしまう。しかし、直積・直和の痕跡みたいな演算が残っていて、これは対称でも結合的でもない双関手（または多項関手）となる。バイノイド積程度の構造しか持たない。だが、忘却関手でもとのデカルト圏に写すと直積・直和が再現する。

アルゴリズム的には、整列集合を添字とする集合族（ファイバー構造）が重要で、ツリーのように扱って深さ優先／幅優先のトラバースを行う。二種類のトラバースをうまく組み合わせるのがコツ。


</body>
</day>
<day date="2011-12-08" title="">
<body>
*1323326444*[圏一般論][Caty]データセットの圏

結局、データセットの圏を考える必要がある。この圏の対象とは：

+ 高々加算の集合Aが台集合で、XJSON型の圏への忘却関手を持つ。
+ 適当な n∈(&lt;b&gt;N&lt;/b&gt;∪{∞}) に対する [n] からの双射を持つ。e:[n]→A を列挙と呼ぶ。
+ ノルムと呼ばれる ν:A→&lt;b&gt;N&lt;/b&gt; がある。ノルムの条件は後述。

e(0)∈A を 0&lt;sub&gt;A&lt;/sub&gt; と書く。混乱がなければ単に 0 とも書く。

+ ν(x) = 0 ⇔ x = 0&lt;sub&gt;A&lt;/sub&gt;
+ e;ν は [n]→&lt;b&gt;N&lt;/b&gt; の単調写像となる。
+ すべての k∈&lt;b&gt;N&lt;/b&gt; に対して、ν&lt;sup&gt;-1&lt;/sup&gt;(k) は有限集合（空でもよい）である。

A = (A, e&lt;sub&gt;A&lt;/sub&gt;, ν&lt;sub&gt;A&lt;/sub&gt;) = (A, e, ν) のような記号の乱用を使うとして、f:A→B がこの圏の射だとは：

+ e;f;e&lt;sup&gt;-1&lt;/sup&gt;:[n]→[m] が単調写像である。e;f;e&lt;sup&gt;-1&lt;/sup&gt; はfの表現関数と呼ぶ。
+ 定数Mがあって、ν(f(x)) ≦ M*ν(x) とできる。

二番目は、一様有界性みたいなもので、fが非常におとなしいことを表す。この条件はきつすぎるかもしれない。

この圏には直和と直積のモドキがあるが、対称でもないし結合的でもない変な演算となる。むしろ、櫛（comb; 縦方向に有限な特殊なツリー）、暖簾（noren; 横方向に有限な特殊なツリー）などが操作の中心となる。


</body>
</day>
<day date="2011-12-10" title="">
<body>
*1323506669*[子供][後で消す]17日 土曜

土曜の昼間に予約入れる。

*1323507650*[映画]いろいろ

明日、「タンタンの冒険/ユニコーン号の秘密」の予定。

しかし、僕は実際はかなり映画みてる。毎週じゃないが、二週に一回くらいだろう。

「リアル・スティール」、たぶん見るだろう。「ハッピーフィート2 踊るペンギンレスキュー隊」も見るかも知れない。「カイジ2 ～人生奪回ゲーム～」 -- これは時間的にどうかな？ だが「カイジ」の1は見たのだった。このあいだ「三銃士/王妃の首飾りとダ・ヴィンチの飛行船」も見たな。「猿の惑星/創世記〈ジェネシス〉」も見た。「カンフー・パンダ2」は見逃したが「カンフー・パンダ」は見た。ちょっと前「世界侵略：ロサンゼルス決戦」てのも見た（駄作だと思うが）。

あっ、新宿武蔵野館で「いちご白書〈デジタルリマスター版〉」をやっている。ウーム、ウーム。



</body>
</day>
<day date="2011-12-12" title="">
<body>
*1323649814*[課題][気付いた]プロファイルのコンフォーマンス計算

単一のプロファイルではなくて、プロファイルセットを考えて、コンフォーマントという順序関係で（上か下に）閉じたものを考えて、そのなかで計算をする。

型とカインドの計算はこうしないとうまくいかないと思う。

*1323650919*[課題][気付いた]程度問題

型宣言、ホーアトリプル、関数定義に質的な違いはない。量的な違いがあるのみで同じ。つまり、程度問題に過ぎない。プロファイルのコンフォーマンス計算（すぐ上のエントリー）で扱いたい。


</body>
</day>
<day date="2011-12-13" title="">
<body>
*1323741530*[多圏][Caty][トレース／コンパクト閉圏]スパイダーグラフ (1)

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111220/1324367266&quot;&gt;スパイダーグラフ (2) &lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111222/1324512515&quot;&gt;スパイダーグラフ 補足&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111226/1324857675&quot;&gt;スパイダーグラフ：チャンネルと描画&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111226/1324860625&quot;&gt;スパイダーグラフ：絵は大ざっぱに描くべし&lt;/a&gt;

&lt;h5&gt;スパイダーグラフの起原と用途&lt;/h5&gt;

いつ頃からか、直観主義論理の“ある種の双対”となる論理のシーケント計算を&lt;strong&gt;スパイダー計算&lt;/strong&gt;と呼ぶことにした。そのシーケント計算の絵図的表現が&lt;strong&gt;スパイダーグラフ&lt;/strong&gt;、または&lt;strong&gt;スパイダー図&lt;/strong&gt;である。スパイダーグラフを使うことにより、スパイダー計算は絵算として遂行できるようになる。

ふと気付けば、スパイダーグラフはCatyScriptの可視化にも使える、つうか&lt;em&gt;ピッタリじゃん&lt;/em&gt;。CatyScriptプログラムをスパイダーグラフで描けるが、むしろ、スパイダーグラフを&lt;em&gt;プライマリーな存在物&lt;/em&gt;と考えて、CatyScriptソースコードはスパイダーグラフの&lt;em&gt;テキストシリアライゼーションに過ぎない&lt;/em&gt;と考えたほうがいい。

スパイダーグラフは、テキストコードより意味論（圏論）に近く、抽象度が高く、テキストコードでは表現しにくい制御構造も容易に可視化できる。通常のスクリプトの可視化にも、ハイパーリンク・グラフから作ったWebエミュレーション・グラフの可視化にも汎用的に使える。

参照：

- [多圏]タグ http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%2A%5B%C2%BF%B7%F7%5D
- 「スパイダー」で検索 http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%B9%A5%D1%A5%A4%A5%C0%A1%BC

&lt;h5&gt;スパイダーグラフの描き方に関する注意&lt;/h5&gt;

スパイダーグラフは、手描きする場合とソフトウェアによる自動描画（プログラム描き）をする場合がある。手描きとプログラム描き＜ぷろぐらむがき＞では、適切な描き方の基準が異なる。ここでは、基本的に手描き向けの描画法を述べる。が、これは容易にプログラム描きにも適用できることを考慮している。

グラフのノード／辺の個数は、適切な省略により減らすことができる。これは、グラフ書き換え（「描き変え」か？）によるある種の最適化だと言える。このテの最適化にはあまり触れない。描画の原則に注目し、レイアウトや簡略化は別な議論として切り離す。

&lt;h5&gt;背景となる圏&lt;/h5&gt;

意味論の舞台となる圏は、型を対象として計算処理を射とする圏である。Sets-as-Types（Types-as-Sets）の立場なので、「型＝集合」と考えてよい。が、計算は写像ではない。写像では解釈できない作用や効果（モナド類似物; monad-like entities）を持つが、それらはスパイダーグラフにはほとんど現れない（ロバストネス図類似の図で、一部のファシリティを描くことがあるかもしれないが）。

スパイダーグラフには、通常の圏では解釈しにくい概念が出てくるが、それは複圏、余複圏、多圏などで解釈できる。スパイダーグラフは、多圏（polycategory）における計算の可視化である。が、多圏には触れない -- 逆に、多圏とはスパイダーグラフで表現できるような category-like entities と思えばいい。

&lt;h5&gt;Caty特有の事情&lt;/h5&gt;

スパイダーグラフは、Catyへの応用を念頭に置く。Catyの計算モデルは、原則的にデカルト半環圏だが、いくつかCaty特有の事情がある。

+ void型がある。void型は、デカルト圏の終対象の型だが、それだけでなくて、処理系が自動void結合（後述）を行う。
+ 射の結合は包含結合である。圏には包含（inclusion）と呼ばれる順序構造（とてもやせた部分圏）⊆があり、cod(f) ⊆ dom(g) なら、射の結合を許す。この結合は通常の圏の結合とは異なる。
+ 直積の構成法が二種類ある。A×B をJSON配列とJSONオブジェクトの二種類で表現できる。JSONオブジェクトの場合は、プロパティ名（成分ラベル）の選び方に任意性／恣意性がある。

&lt;h5&gt;射の描き方&lt;/h5&gt;

基本的な射は、名前を持つコマンドである。コマンドは、f P :: A -&gt; B の形の宣言を持つ。fが名前、Pは&lt;strong&gt;パラメータ型&lt;/strong&gt;、Aは&lt;strong&gt;入力型&lt;/strong&gt;、Bは&lt;strong&gt;出力型&lt;/strong&gt;である。これを次のように図示する。

&lt;img src=&quot;http://www.chimaira.org/img3/sg01-basic.gif&quot; &gt;

パラメータがないときは描かない。パラメータがあっても、それに注目しないときは描かないことが多い。以下の例では、パラメータを省略している。

射の本体を表すグラフノードを&lt;strong&gt;計算ノード&lt;/strong&gt;（computation node）と呼ぶ。グラフの有向辺は&lt;strong&gt;ワイヤー&lt;/strong&gt;と呼ぶこともある。計算ノードにはコマンド名でラベル付けし、ワイヤーには型でラベル付けする。&lt;span style=&quot;font-size:x-large&quot;&gt;&lt;em&gt;計算ノードの形状はなんでもよい。&lt;/em&gt;&lt;/span&gt;こだわると身動き取れなくなる。矩形（box）が多く使われるが、手描きでは楕円が描きやすい。データ＆制御の方向を明示するために&lt;em&gt;矢印は付ける&lt;/em&gt;。Graphvizならnormal arrow（入出力）、inv arrow（パラメータ）を使う。

&lt;h5&gt;void型とnever型&lt;/h5&gt;

void型とnever型は、それぞれデカルト半環圏の直積単位＝終対象と直和単位＝始対象に対応する。void型、never型を入出力とする射は組み合わせとして4種あるが、neverからの射は描画対象にならない（ソフトウェアでの実現もできない）ので、次の3種となる。

+ f :: A -&gt; never
+ f :: void -&gt; B
+ f :: A -&gt; void

never型は何も描かず、void型は&quot;void&quot;という型ラベルをワイヤーに付ける代わりに&lt;em&gt;点線のワイヤー&lt;/em&gt;を使う。

&lt;em&gt;voidとneverの混同と、それによる誤解・混乱が多い&lt;/em&gt;ので、voidは点線で明示的に描くことにする。

&lt;img src=&quot;http://www.chimaira.org/img3/sg02-void-type.gif&quot; &gt;

&lt;h5&gt;ポイントとスポット&lt;/h5&gt;

名前を持つ計算ノードは矩形や楕円などの図形として描くが、組み込みの制御構造などの特殊なノードは別な形状を使うことがある。例えば、分岐に関しては次のような図示法があり得る。

&lt;img src=&quot;http://www.chimaira.org/img3/sg03-branch.gif&quot; &gt;

形状を持つ図形の代わりに、点（point）を使って描くノードを&lt;strong&gt;ポイント&lt;/strong&gt;、何も描かない（none）ときは&lt;strong&gt;スポット&lt;/strong&gt;と呼ぶ。ポイントもスポットもその意味は射であるし、グラフのノードに代わりはないが、&lt;em&gt;特殊なノードを示すとき&lt;/em&gt;に使われる。

&lt;h5&gt;型と型制約&lt;/h5&gt;

ワイヤー（グラフの有向辺）は、型でラベルする。ラベルの描画法には次の2つがある。

&lt;img src=&quot;http://www.chimaira.org/img3/sg04-type-label.gif&quot; &gt;

右側の描き方は、辺ラベルが他の意味で使われているときや、型を強調したいときに用いる。

Catyの包含結合（パイプ結合）では、ワイヤーの両端の型が違うケースも許す。しかし、包含関係は要求するので、そのことを次のように表す。

&lt;img src=&quot;http://www.chimaira.org/img3/sg05-type-inclusion.gif&quot; &gt;

「A⊆B」の形の式を&lt;strong&gt;型制約&lt;/strong&gt;と呼ぶ。単一の型Aも「A⊆A」とみなせるので、スパイダーグラフのワイヤーは&lt;em&gt;型制約でラベルされている&lt;/em&gt;と言える。

&lt;h5&gt;恒等射とvoid射&lt;/h5&gt;

圏論では、対象Aの恒等射は id&lt;sub&gt;A&lt;/sub&gt;、対象Aから終対象への唯一の射を !&lt;sub&gt;A&lt;/sub&gt; と書く。Catyでは、pass&amp;lt;A&gt;, void&amp;lt;A&gt; である。

恒等射は特別な事情がない限りは計算ノードとしては描かない。型が不明な pass はラベルがないワイヤー、pass&amp;lt;A&gt; は型Aをラベルしたワイヤーとして描く。

void射も、&lt;em&gt;実線と点線を繋いだワイヤー&lt;/em&gt;（混合ワイヤー）として描く。型が不明な void はラベルがない混合ワイヤー、void&amp;lt;A&gt; は型Aをラベルした混合ワイヤーとして描く。

&lt;img src=&quot;http://www.chimaira.org/img3/sg06-void-morph.gif&quot; &gt;

不明な型、未定な型、型に注目してないことを明示的に表すには、dont-care型マーカー '_' （アンダースコア）を型ラベルに使う。'_'は、出現ごとに違う型で具体化可能な型変数である。

&lt;h5&gt;結合の描き方&lt;/h5&gt;

Catyのスパイダーグラフでは、3種類の射の結合方法がある。

+ 厳密結合 -- 圏論の結合である。cod(f) = dom(g) のときだけ結合が許される。
+ 包含結合 -- cod(f) ⊆ dom(g) のとき結合が許される。
+ void結合 -- 任意のfと dom(g) = void であるgの結合が許される。

それぞれ次のように図示される。下向きの⇒は、結合操作の実行を示す。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/sg07-compositions.gif&quot; &gt;

Catyの結合は&lt;em&gt;常に包含結合&lt;/em&gt;で、厳密結合を指定する方法はない。fとgのvoid結合は f;g と書く。明示的なvoid結合記号「;」を書かなくても、gのdomを見て処理系がvoid結合に切り替えることがある。これが&lt;strong&gt;自動void結合&lt;/strong&gt;である。自動void結合は、便利なソフトウェア的な機能であるが、意味論としては、void射を挿入するだけである。

スパイダーグラフ上では、明示的なvoid結合と自動void結合を区別することはできない。どちらも同じように混合ワイヤーで図示される。

&lt;h5&gt;ジャンクションの描き方&lt;/h5&gt;

組み込みの制御構造を表す特殊ノード（特殊射の図式表示）を&lt;strong&gt;ジャンクション&lt;/strong&gt;と呼ぶ。恒等射を表すワイヤー、void射を表す混合ワイヤーもジャンクションである。その他に次のジャンクションを使う。

+ コピージャンクション -- デカルト圏の対角Δに対応する多圏の射。
+ タプリングジャンクション -- タプルを構成するコンストラクタに対応する。配列構成とオブジェクト構成がある。タギングも一種のタプリングである。
+ 排他的分岐ジャンクション -- CatyScriptの排他的ユニオン型とwhen分岐に対応する。
+ 合流ジャンクション -- 制御＆データの合流（待ち合わせはしない）に対応する。

これらのジャンクションは、一例として次のように描く。

&lt;img src=&quot;http://www.chimaira.org/img3/sg08-junctions.gif&quot; &gt;

とりあえず、コピーとタプリングはポイント、排他的分岐と合流はスポットを使ったが、他の描画法を採用するかもしれない。

&lt;h5&gt;スパイダー射&lt;/h5&gt;

A, B&lt;sub&gt;1&lt;/sub&gt;, B&lt;sub&gt;2&lt;/sub&gt;, ..., B&lt;sub&gt;n&lt;/sub&gt; を型として、&lt;strong&gt;スパイダー射&lt;/strong&gt;は次のようなプロファイルを持つ（多圏の）射である。

- f :: A -&gt; B&lt;sub&gt;1&lt;/sub&gt;, B&lt;sub&gt;2&lt;/sub&gt;, ..., B&lt;sub&gt;n&lt;/sub&gt;

これは、直観主義論理のシーケントの左右を逆にした形をしている。排他的とは限らないユニオン型を∪で表すとして、上記のスパイダー射は、f :: A -&gt; (B&lt;sub&gt;1&lt;/sub&gt;∪B&lt;sub&gt;2&lt;/sub&gt;∪ ... ∪B&lt;sub&gt;n&lt;/sub&gt;) と似てるが&lt;em&gt;異なる&lt;/em&gt;。グラフノードとして、「出る辺の数が違うので違う」と思っておけば当面は十分である。

スパイダー射に対応するノードを&lt;strong&gt;スパイダーノード&lt;/strong&gt;と呼ぶ。スパイダーノードは、多圏（polycategory）の射を表す。

&lt;img src=&quot;http://www.chimaira.org/img3/sg09-spider1.gif&quot; &gt;

スパイダーノードから出る辺（出力ワイヤー）の本数は任意だ（0本でもよい）が、入力ワイヤーは1本（voidワイヤーでもよい）である。このため、&lt;strong&gt;片側スパイダーノード&lt;/strong&gt;とも呼ぶ。

入力ワイヤーを複数持つ射（計算ノード）を認めるが、&lt;em&gt;略記（省略形）として導入する&lt;/em&gt;。合流ジャンクションとスパイダー射の結合（包含結合）を簡略に描いた図形が&lt;strong&gt;両側スパイダーノード&lt;/strong&gt;である。

&lt;img src=&quot;http://www.chimaira.org/img3/sg10-spider2.gif&quot; &gt;

スパイダーグラフ内では両側スパイダーノードを使うが、厳密な議論のときは、合流ジャンクションと片側スパイダーノード（本来のスパイダー射）の結合に戻して考える必要がある。両側スパイダーノードは&lt;em&gt;便宜上の図示法である&lt;/em&gt;。が、図をすっきりさせる効果は大きい。

&lt;h5&gt;リテラル射の描き方&lt;/h5&gt;

データインスタンスの集合Xが定まっているとして、Xを基本データ領域と呼ぶ。Xの要素はリテラル表現を持つとする。Catyの場合は、基本データ領域Xは、リテラル表現を持つスカラー全体の集合である。Xに属するデータインスタンスxとそのリテラル表現はしばしば同一視される。

x∈X に対して、Singleton(x) = {x} とする。Singleton:X→Pow(X) である。Types-as-Sets なので、Pow(X)の要素（＝Xの部分集合）は型である。一方、x∈X に対して、literal(x) :: void -&gt; Singleton(x) というコマンド（射）を定義できる。

- literal(x)(null) = x

literal(x) を、データインスタンスxの&lt;strong&gt;リテラル射&lt;/strong&gt;と呼ぶ。リテラル射は、xのリテラル表現をラベルとする計算ノードとして描かれる。ただし、出力型は Singleton(x) に決まっているのでラベルしなくてもよい。（以下の図の出力形は、{&quot;hello&quot;} というシングルトン型。）

&lt;img src=&quot;http://www.chimaira.org/img3/sg11-literal.gif&quot; &gt;

&lt;h5&gt;変数の描き方&lt;/h5&gt;

Catyでは、変数の生成と参照が次のようにして行える。

- 変数の生成  &gt; foo
- 変数の参照  %foo

「&gt;」が変数生成の演算子、「%」が変数参照の演算子となっている。変数生成はワイヤー上に乗った変数ポイントで表す。型Aの変数参照は、void -&gt; A の計算ノードとして表すが、変数ポイントからの&lt;strong&gt;変数参照ワイヤー&lt;/strong&gt;を描く。変数参照ワイヤーは、通常のワイヤーとは区別される。プログラム描きのときはワイヤー（有向辺）の色を変える。モノクロ手描きのときは、適当な間隔で短い斜め棒を添えて変数参照ワイヤーを識別する。斜め棒は、「制御はこのワイヤーを通らない」という意味合いである。

&lt;img src=&quot;http://www.chimaira.org/img3/sg12-variable.gif&quot; &gt;

スパイダーグラフの書き換え操作により、変数ポイントをコピージャンクションに置き換え、変数参照ワイヤーを通常ワイヤーに置き換え、変数参照ノードをすべて消し去ることができる。変数を消し去っても挙動は変わらないようにできるが、テキストコードでは変数の必要性が高い（経験上、変数なしでは&lt;em&gt;とても書きにくい&lt;/em&gt;）。

&lt;h5&gt;続きは&lt;/h5&gt;

「スパイダーグラフ (2)」では、スパイダー射の意味論、エリアやポートについて述べる。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111220/1324367266&quot;&gt;スパイダーグラフ (2) &lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111222/1324512515&quot;&gt;スパイダーグラフ 補足&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111226/1324857675&quot;&gt;スパイダーグラフ：チャンネルと描画&lt;/a&gt;
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111226/1324860625&quot;&gt;スパイダーグラフ：絵は大ざっぱに描くべし&lt;/a&gt;

</body>
</day>
<day date="2011-12-20" title="">
<body>
*1324348786*[caty-depl]ペリーロのWSGIコンテナ

イタリアのペリーロ（Perillo）さんて人が、nginx上のWSGIコンテナを作っているらしい。今度試してみよう。

- Perillo の発音： http://ja.forvo.com/search/perillo/
- ペリーロさんの発表： http://www.viddler.com/explore/python-italia/videos/10/ （イタリア語）
- ペリーロさんのリポジトリ群： http://hg.mperillo.ath.cx/nginx/
- mod wsgi ： http://wiki.nginx.org/NgxWSGIModule

*1324367266*[多圏][Caty][トレース／コンパクト閉圏]スパイダーグラフ (2)

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111213/1323741530&quot;&gt;スパイダーグラフ (1) &lt;/a&gt;の続き。

&lt;h5&gt;スパイダー射の意味論&lt;/h5&gt;

&lt;strong&gt;スパイダー射&lt;/strong&gt;は、f: A → B&lt;sub&gt;1&lt;/sub&gt;, B&lt;sub&gt;2&lt;/sub&gt;, ... B&lt;sub&gt;n&lt;/sub&gt; という、余域側に複数の型を並べていいプロファイルを持つ。複数の出力チャンネルを持つわけだ。複数の出力の一番お馴染みの例は、標準出力（stdout）と例外（exception）である。Catyの記法で、f :: A -&gt; B throws E ならば、f:A → B, E というスパイダー射となる。f :: A -&gt; B throws [E, E'] ならば、f:A → B, E, E' である。

標準出力と例外は違った出力チャネルだが、スパイダー射ではそれを特に区別しない。Catyでは、例外と類似のシグナルという機構がある。例外とシグナルは通常同じメカニズムで実装されるが、シグナルはエラーではなくて正常な大域脱出となる。f :: A -&gt; B throws [E, E'] signals S は、f:A → B, E, E', S というスパイダー射となる。

CatyScript 2.0では、標準入出力のパイプライン結合以外に、forward制御やbegin/repeat制御が導入されている。これらのgoto-like制御によるフローも、スパイダー射では通常の出力と同様に扱う。

つまり、言語仕様や実装のレベルでは異なる扱いとなる出力チャネルを&lt;em&gt;同等に扱ったフローグラフ&lt;/em&gt;が&lt;strong&gt;スパイダーグラフ&lt;/strong&gt;である。スパイダーグラフの「ノード（蜘蛛の胴体）とノード近傍（蜘蛛の脚）」を&lt;strong&gt;スパイダーノード&lt;/strong&gt;（蜘蛛の胴体と脚＝スパイダー射の図式表現）と呼んでいる。

ソフトウェア的には正常処理とエラーは違うと思われているが、その違いは微妙なことも多い。ときに恣意的でさえある。また、標準入力かパラメータかの区別も偶発的／恣意的と言える。これらの恣意性は忘れて、&lt;em&gt;単に複数の入出力チャンネルがある&lt;/em&gt;と捉えたのがスパイダーグラフだ。

CatyScriptの直列実行エンジンは、時系列に沿ってスパイダーグラフ上の1本の経路をたどる。並列実行エンジンなら、同時に複数の経路をたどることになる。スパイダーグラフの計算ノードに制御が移り、そこで計算が実行されることを、そのノードが&lt;strong&gt;発火する&lt;/strong&gt;と言うことがある。直列実行エンジンでは、同時に発火する点は高々1個。並列実行エンジンでは、同時に複数の箇所が発火可能である。

発火点の時間的な変動では、直列実行エンジンでは&lt;em&gt;粒子の運動の軌道&lt;/em&gt;、並列実行エンジンでは&lt;em&gt;波の進行&lt;/em&gt;のように記述される。スパイダーグラフは並列実行を仮定しているので、それを直列実行エンジンで実行するときにはバックトラック経路を付け加える必要がある。バックトラック経路を付け加えれば、スパイダーグラフを一筆書きできる。その一筆書きの跡が直列（逐次、順次）実行の運動軌道となる。

火が燃え移る、燃え広がる感じをほんのちょっと味わえるページ↓

- http://www.chimaira.org/misc/fire2.html

&lt;h5&gt;エリア&lt;/h5&gt;

&lt;strong&gt;エリア&lt;/strong&gt;とは、グラフを描く平面内の境界線で区切られた領域である。手描きのときは、任意の不定形の領域を使ってよい。プログラム書きだと、矩形や楕円に限定されるだろう。

グラフを描く全体領域もまたエリアと考えて、これを&lt;strong&gt;ルートエリア&lt;/strong&gt;と呼ぶ。概念上は空エリアを考えることができるが、実質的には無意味であるので、描画では考えない（無視する）。

データ構造としてのエリアは、ノードの集合である。グラフのノード全体の集合をNとして、「Aがエリアである」とは「A⊆N」という意味になる。ノードの集合（グループ）を視覚的に識別するために、境界付きの領域内にまとめて配置する。

Aがエリアで、eがグラフの辺（edge）のとき； source(e), target(e)∈A ならば、eはエリアの&lt;strong&gt;内部辺&lt;/strong&gt;（domestic edge）と呼ぶ。 描画のときも辺は領域から出ることはない（レイアウトによっては、チョットはみ出すかも）。複数のエリアをまたがる（エリア境界を超える）辺は&lt;strong&gt;インターエリア辺&lt;/strong&gt;（inter-area edge）と呼ぶ。

&lt;h5&gt;エリアの入れ子構造&lt;/h5&gt;

お約束： A⊂B は、「A⊆B であり、A≠B」を意味する。つまり、A⊂B は、AがBの真部分集合であることを意味する。

ノード全体の集合をNとして、Nの部分集合の族を&lt;b&gt;S&lt;/b&gt;とする。A∈&lt;b&gt;S&lt;/b&gt; と A⊆N は同じ意味。&lt;b&gt;S&lt;/b&gt;が&lt;strong&gt;適性にネストしている&lt;/strong&gt;（properly nested）とは次のこと：

+ A∈&lt;b&gt;S&lt;/b&gt; ならば S≠空集合。つまり、空集合は&lt;b&gt;S&lt;/b&gt;に含まれない。
+ N∈&lt;b&gt;S&lt;/b&gt;
+ A, B∈&lt;b&gt;S&lt;/b&gt; ならば、A = B、A⊂B、B⊂A、 A∩B = 空 のいずれかが成り立つ。

&lt;b&gt;S&lt;/b&gt;が適正にネストしているなら、&lt;b&gt;S&lt;/b&gt;の要素をノードとした&lt;em&gt;ツリー構造&lt;/em&gt;を持つ。「&lt;b&gt;S&lt;/b&gt;の要素＝Nの部分集合＝エリア」なので、ツリー構造はエリアのツリー構造となる。

グラフに指定されたエリアの集合が適正にネストしているときは、エリアを平面領域にする以外に、エリアをノードとしたツリーも描ける。元のノードを末端ノード（リーフ）、エリアを中間ノード（分岐ノード）、もとのノード全体を表すNをルートとするツリーを描くこともある。

多くの応用では、エリアの集合は適正にネストしている。具体例は、モジュールをノード、エリアをパッケージとするグラフ構造である。

&lt;h5&gt;エリアの事例&lt;/h5&gt;

エリアを持つようなグラフの例には次がある。

|* ノード      |* エリア     |* 全体        |* 該当する図 |
| フラグメント | アクション |アクション近傍|アクションの図|
| アクション   | リソース   |モジュール    | モジュールの図|
| コマンド     | ブロック／フラグメント   | スクリプトコード | スクリプトコードの図 |
| モジュール   | パッケージ | アプリケーション| アプリケーションの図 |
| コントロール | サブシステム | システム  | ロバストネス図 |

&lt;h5&gt;ポート&lt;/h5&gt;

&lt;strong&gt;ポート&lt;/strong&gt;とは、仮のノード／ノードの代理のようなものだ。ポートはエリアとの関係で論じられる。とりあず描画法だが、次のように描くことにする。&lt;strong&gt;アウトバウンドポート&lt;/strong&gt;（または&lt;strong&gt;アウトレット&lt;/strong&gt;）は、エリアから出ていく出口。&lt;strong&gt;インバウンドポート&lt;/strong&gt;（または&lt;strong&gt;インレット&lt;/strong&gt;）は、外部からエリアに入る入口。

&lt;img src=&quot;http://www.chimaira.org/img3/sg13-ports.gif&quot; &gt;

ポートはエリアに所属する。アウトバウンドポートは、根元をエリア内に、矢先をエリアの外に出す。結果としてポートの線はエリア境界を横切ることになる。インバウンドポートは逆向きに配置する。（&lt;em&gt;次の図、インバウンドポートが形状がちと間違っている、まーいいや。適当に修復してちょ。&lt;/em&gt;）

&lt;img src=&quot;http://www.chimaira.org/img3/sg14-area-ports.gif&quot; &gt;

&lt;h5&gt;ポートの結合（束縛）&lt;/h5&gt;

ポートは結合される。ポートどうしの結合、ポートとノードの結合が2種で、合計三種類の結合がある。下向きの「⇒」は結合操作を表す。

&lt;img src=&quot;http://www.chimaira.org/img3/sg15-binding.gif&quot; &gt;

&lt;h5&gt;リレー&lt;/h5&gt;

いくつかの辺とノードを経由して2つのノードのあいだを結ぶことができる可能性（&lt;strong&gt;可達性&lt;/strong&gt;）を示す辺を&lt;strong&gt;リレー辺&lt;/strong&gt;と呼ぶ。リレー辺は、現状は茶色の点線になっている。まー、適当な描画法で示せばいい。


</body>
</day>
<day date="2011-12-22" title="">
<body>
*1324512515*[多圏][Caty][トレース／コンパクト閉圏]スパイダーグラフ 補足

いくつか補足しておく。

ハブエントリー：
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111213/1323741530&quot;&gt;スパイダーグラフ (1)&lt;/a&gt;

&lt;hr&gt;

以下の図のインバウンドポートの形状が&lt;em&gt;間違っている&lt;/em&gt;。

&lt;img src=&quot;http://www.chimaira.org/img3/sg14-area-ports.gif&quot; &gt;

矢印の方向はこれでいいが、白丸が内部に入る。では、白丸はなぜ内部に描くのか？ エリアがルートエリアのときは外部を描きようが無いので：

+ 白丸とそこから出る矢印でアウトバウンドポート
+ 白丸とそこに入る矢印でインバウンドポート

としようと思う。現在、ハイパーリンク・グラフ（caraモジュールの図示）では、点線輪郭の楕円でアウトバウンドポートを表している。特に出る矢印は添えてない。

インバウンドポートは使わないのじゃないか、と思っている。インバウンドポートがないなら、ポートの結合法は、アウトバウンドポートをアクションに繋ぐ一種類だけとなる。

ノードに入る辺には、標準入力以外にパラメータがある。ノードから出る辺には、標準出力以外に例外、シグナル、フォーワードがある。変数参照を表す辺（変数伝搬ワイヤー）もある。また、ファシリティも入出力と言えなくもない。これらをすべて描くと、余りにも煩雑。

+ パラメータは原則として描くが、オプションで省略可能とする。省略すると、コマンドにパラメータがないかのように描く。
+ 例外、シグナルは描かない。リダイレクトはシグナルで実装されるだろうが、アクションのリダイレクトだけはWebでの重要性を鑑み描く。つまり、リダイレクトは特別扱いする。
+ フォーワードは描く。
+ 変数伝搬ワイヤーは原則として描くが、オプションで省略可能とする。省略するときは、変数ポイント（生成点）に変数名を添える。名前で対応を取ることができる。
+ ファシリティは描かないが、コマンドとファシリティの関係だけを描く図を別に用意する。

コマンドとファシリティの関係を描く図は：

+ コマンドの集合を固定して、そこから（再帰的に）使用されているファシリティ群を列挙する。
+ 資源利用宣言をもとに二部グラフを描く。
+ 二部グラフのノードはコマンド（アクションも含む）とファシリティ。
+ reads/updates/usesを辺として描く。
+ reads, updates, usesの3種の辺、 read-only, update-only, read-update の3種のファシリティは、色か形状で区別したほうがよい。

*1324516316*[映画]いちご白書

新宿武蔵野館でやっていたので行ってしまった。先日。

武蔵野館て、めちゃくちゃ目立つ場所／建物だと思い込んでいたが、そうでもなかった。そのことに、ちょっと驚いた。大人になって小学校を訪れたら、階段の段差が小さいのに驚くような感触か。

映画「&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%81%84%E3%81%A1%E3%81%94%E7%99%BD%E6%9B%B8&quot;&gt;いちご白書&lt;/a&gt;」より、「&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%80%8E%E3%81%84%E3%81%A1%E3%81%94%E7%99%BD%E6%9B%B8%E3%80%8F%E3%82%92%E3%82%82%E3%81%86%E4%B8%80%E5%BA%A6&quot;&gt;いちご白書をもう一度&lt;/a&gt;」のほうを知っている人が多いだろうな。あの歌はノスタルジックだが、映画はそれほどにロマンチックなわけじゃない。

映画として素晴らしいかどうかは分からない。が、60年代（映画公開は1970年）、あの時代が強烈に刻印されている。僕の少年時代、主人公たちは8歳上の姉とだいたい同年代ってことになる。冒頭でラジオ（テレビ？）から流れるニュースはシャロン・テート殺害事件、ケネディやニクソンの写真が何度も出てくる。ベトナム戦争が進行している、それより前の朝鮮戦争もチラリと出てくる。今では古くさい歌詞とビブラートのきいた音楽。学生の服装はなんか今と変わらないな。当時の学生ファッションが、今ではオッサンでも着てるけど。

学生運動の連中が警察に捕まって護送されるとき、車中でダンスを踊るシーンがあるが、マット・ハーディングのマットダンスの原形みたいだった。

リンダ役をやっていたのはキム・ダービーっていう女優さんなんか。可愛い、けど、やっぱりあの時代っぽい可愛さなのかな。自分が高校生くらいのときの基準だとあの感じが可愛いのだと思う。今？ 今の見方だとどうかな？ もっと典型的（ステレオタイプな）美人のほうがいいかもしれない。主役のサイモンをやっていた俳優さんは、学生っぽくていいのだけど、ボート部員の割には華奢な感じがした。

別にたいして面白くもない映画って感想だが、もう一度見たいか？ と聞かれれば、「見たい！」


</body>
</day>
<day date="2011-12-24" title="">
<body>
*1324708007*[子供][後で消す]荷物の受取

26日の午後8時から9時で配送。

あんれ、27日にダブルブッキングしたか？

*1324708008*[映画]ワイルド7

封切り日に渋谷で見た。後で感想書くかも。


</body>
</day>
<day date="2011-12-26" title="">
<body>
*1324857675*[多圏][Caty][トレース／コンパクト閉圏]スパイダーグラフ：チャンネルと描画

ハブエントリー：
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111213/1323741530&quot;&gt;スパイダーグラフ (1)&lt;/a&gt;

チャンネル（ワイヤーのロール）と図示法。「描画するか」の△は、「設定によっては描画する」こと。

|* チャンネル  |* in/out |* 描画するか |* 色(暫定)  |* 矢印(暫定)  |* 備考 |
| param        | in      | △          | -    | inv    |  |
| env          | in      | ×          | -    |  -     |  |
| stdin        | in      | ○          | -    | normal |  |
| varin        | in      | △          | -    | diamond|変数参照ノードのみ|
| stdout       | out     | ○          |black | -      |  |
| except       | out     | ×          | -    | -      |  |
| signal       | out     | △          |hotpink| -     |  |
| forward      | out     | ○          |green  | -     |  |
| varout       | out     | △          |darkblue| -    |変数生成ポイントのみ  |
| redirect     | out     | ○          |blue   | -     |Webのみ  |


redirectチャンネルは、Webでのみ使われる“signalチャンネルの特別なもの”だが、Webでは重要なので通常のシグナルとは別に扱う。RedirectResponseを、「リダイレクトをクライアントに伝えるレスポンスの型」だとして、シグナルの宣言は signals RedirectResponse のようになる。だが、この一般的宣言に代えて、リダイレクト先まで明示した redirects Res.act の形の宣言を使う。redirects宣言はアクションでのみ有効で、一般コマンドでは使えない。

redirectチャンネル（アクション専用）とforwardチャンネル（一般的）は、制御の行き先が最初から明示されているという点で、他の出力チャンネルとは異なる。他のチャンネルの行き先は、局所的な宣言では判断できず、スクリプト全体のフロー文脈のなかで決定される。

現状、envとexceptは描かないが、try-catch風構文とその双対が導入されれば、env/exceptもある程度は描く必要がある。

ワイヤーに色や形状を付けることによってチャンネルを識別する。が、色や形状を取り去ってもグラフのトポロジーは変わらない。データと制御のフローに関して本質的なのはグラフのトポロジーであって色・形状はオマケ。オマケに拘ってはいけない、トポロジーとその変形（最適化やリファクタリング）に注目すべき。

*1324860625*[多圏][Caty][トレース／コンパクト閉圏]スパイダーグラフ：絵は大ざっぱに描くべし

ハブエントリー：
- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111213/1323741530&quot;&gt;スパイダーグラフ (1)&lt;/a&gt;

絵がテキストより分かりやすいのは、ノード／ワイヤー数が少ない場合で、ノード／ワイヤーが増えると結局はナンダカワカラナイ。

ノード／ワイヤー数を減らすには、絵で表現する情報を絞り込んで余分なことは描かない。細かい分類をしないで、類似のものは同じ形状で描いてしまう。大ざっぱに描くことは抽象度が上がることでもあるので、同じ絵にいろいろな解釈ができる。例えば：

&lt;img src=&quot;http://www.chimaira.org/img3/sg08-junctions.gif&quot; &gt;

黒丸のポイントジャンクションがAND分岐とAND合流、スポットのほうがOR分岐とOR合流。

ANDのほうを考えてみると、分岐はデータとしてはコピー（copy, dup, clone）、制御としてはcobegin、フォークポイントとなる。合流はデータとしてはタプルコンストラクタ、制御としてはcoend, ジョインポイントとなる。タプルコンストラクタは、XJSONの配列コンストラクタ、オブジェクトコンストラクタ、タギングコンストラクタのどれも同じ絵で表すことが出来る。ワイヤーに型以外のラベル（タグラベル）を目印に付けるとして：

+ 配列：番号タグでラベル
+ オブジェクト：名前タグでラベル
+ タギング：$$tag, $$val という特殊タグでラベル

ジャンクションは証明図の推論とも解釈できて、分岐と合流が次に対応する。

&lt;pre&gt;

    A
  ------[増]
  A   A


  A    B
 ---------[∧導入]
   A∧B

&lt;/pre&gt;

大ざっぱな絵では、同一の絵を、データ操作、プログラム制御、論理計算の観点から解釈できる。要するに、カリー／ハワード対応が目視で確認できるようになるわけ。

</body>
</day>
<day date="2011-12-28" title="">
<body>
*1325059599*[圏一般論][高次圏論][リンク]operad, properad

76ページもある、ちょっとコレは読めん。

- title: A unified framework for generalized multicategories
- authors: G.S.H. Cruttwell, Michael A. Shulman
- URL: http://arxiv.org/abs/0907.2460

こっちは36ページだが、なんだか僕が知りたいことじゃないような。

- title: Curved Koszul duality theory
- authors: Joseph Hirsh, Joan Milles
- URL: http://arxiv.org/abs/1008.5368

&quot;A unified framework for generalized multicategories&quot;のダイジェスト版がないかなー。

*1325060166*[雑記][雑感][気付いた][課題][メモ][インスティチューション]インスティチューションだのプロ関手だのなんだの

クリスマスで連休で、その後は正月で、ってなわけで、こういうときは、普通どおりに仕事するのもナンだし、最近は子供と遊ぶことも少ないしで、なんだかボーッとしている。すると、ボーッとしたことを思いつく。はたして意味があることかどうかわからないが、メモしておこう。

&lt;h5&gt;インスティチューションの定式化と例&lt;/h5&gt;

ボーッと考えていたのは、インスティチューション。

+ インスティチューションを、もっと使いやすいように変形や拡張ができないか？
+ インスティチューションの実例で、わかりやすいものはないか？
+ インスティチューションをバキバキに使いたいなー。

とか。

&lt;h5&gt;階層付き圏&lt;/h5&gt;

まず、category with inclusions / inclusive category って言葉がどうもイヤだ。category with hierarchy / hierarchical category で、&lt;strong&gt;階層付き圏&lt;/strong&gt;と呼びたい。階層が実際にモノな包含（inclusion）のときもあるが、階層を表現する射がエピのこともある。

階層付き圏の例は、オブジェクト指向のクラスをモデル化するような圏で、B extends A のとき、B ≧ A （または、B ≦ A、向きは&lt;em&gt;どっちでもいい&lt;/em&gt;）の順序があるような圏。B extends A かどうかは、なんらかの方法で決定できるとする（ダックタイピングでも良い）。B extends A かつ A extends B は A = B だとするなら、extendsで生成される圏は“とてもやせた圏＝順序集合”となる。

インスティチューションのモデル圏 Mod[Σ] に、とてもやせた部分圏（単にやせた部分圏でもいいだろう）が指定された構造を持たせて階層付き圏としたい。Mod[Σ] 自体は模倣を射とする遷移系（広義のオートマトン）の圏とするのが現実的／実務的だろう。

&lt;h5&gt;メイヤー指標とメイヤー・オートマトン&lt;/h5&gt;

インスティチューションの具体例として、メイヤー指標の圏の上に、メイヤー・オートマトンのモデル圏を考えるのがいいと思う。形容詞「メイヤー」は、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20101216/1292469108&quot;&gt;メイヤー先生の「Command-Query分離の原則」&lt;/a&gt;を守ったモノという意味。

メイヤー指標Σは、オペレーション記号の集合Σで：

+ Σ = Σ&lt;sub&gt;command&lt;/sub&gt; + Σ&lt;sub&gt;query&lt;/sub&gt; と直和分解される。
+ Σ&lt;sub&gt;command&lt;/sub&gt; は単なる記号の集合。
+ Σ&lt;sub&gt;query&lt;/sub&gt; は、記号と基本ソート（集合と思ってよい）のペアの集合。
+ Σ&lt;sub&gt;command&lt;/sub&gt; も Σ&lt;sub&gt;query&lt;/sub&gt; も無限集合でよい。

q∈Σ&lt;sub&gt;query&lt;/sub&gt; だと、q = (op&lt;sub&gt;q&lt;/sub&gt;, V&lt;sub&gt;q&lt;/sub&gt;) と書けるが、q = (q, V&lt;sub&gt;q&lt;/sub&gt;) と略記する。さらに、十分大きな集合Vを用意して、V&lt;sub&gt;q&lt;/sub&gt;⊆V と考える。

A = (State&lt;sub&gt;A&lt;/sub&gt;, tran&lt;sub&gt;A&lt;/sub&gt;, obs&lt;sub&gt;A&lt;/sub&gt;) が指標Σ上の決定性メイヤー・オートマトンだとは：

+ tran&lt;sub&gt;A&lt;/sub&gt;: Σ&lt;sub&gt;command&lt;/sub&gt;×State&lt;sub&gt;A&lt;/sub&gt;→State&lt;sub&gt;A&lt;/sub&gt; は写像
+ obs&lt;sub&gt;A&lt;/sub&gt;: Σ&lt;sub&gt;query&lt;/sub&gt;×State&lt;sub&gt;A&lt;/sub&gt;→V は写像

A = (A, tran obs) のように略記する。集合としてのAが状態空間、tranが遷移、obsが観測。非決定性メイヤー・オートマトンは、圏&lt;b&gt;Set&lt;/b&gt;の代わりに圏&lt;b&gt;Rel&lt;/b&gt;で考える。メイヤー・オートマトン射は、模倣か双模倣で定義する。

メイヤー・オートマトンの圏は、インスティチューションの例だけでなくて、&lt;em&gt;マイヒル／ネロードの定理&lt;/em&gt;の説明にも使える。

&lt;h5&gt;Senを圏と考える&lt;/h5&gt;

インスティチューションのSen[Σ]を集合ではなくて圏と考える。その圏は、やせたデカルト閉圏。

+ 圏の対象は論理文（閉じた論理式）p, q など。
+ pからqへの射は、証明可能性 p |- q 。
+ pとqのデカルト積はp∧q。
+ pとqの指数は含意 p⊃q。
+ pとqの同型は、論理的同値 p≡q。
+ 指数に関する随伴は演繹定理 p∧q |- r ⇔ p |- q⊃r
+ 終対象でもあり、かつ積∧の単位対象は、論理定数true。

&lt;h5&gt;充足関係はブール値のプロ関手&lt;/h5&gt;

プロ関手（副関手）は、profunctor、distributor、module、bimoduleとか色々な呼び方があるが、最近 correspondence と呼んでいる例を見た（http://dl.dropbox.com/u/8165870/Unicity.pdf）。ウヒャー。さらに用語を増やしてコノヤローとも思ったが、correspondenceが&lt;em&gt;一番適切&lt;/em&gt;な気がする。

それはそーと、&lt;b&gt;B&lt;/b&gt;を{0, 1}からなるブール代数に 0 ＜ 1 という順序を入れて、順序からできる圏に論理ANDでモノイド積を入れた対称モノイド圏とする。&lt;b&gt;B&lt;/b&gt;には含意演算があるから、実は&lt;b&gt;B&lt;/b&gt;は対称モノイド閉圏である。

それで、&lt;b&gt;B&lt;/b&gt;に関して豊饒化（enriching）した豊饒圏（enriched categories）の枠内で考える。&lt;b&gt;B&lt;/b&gt;-圏のなかでプロ関手を考えると、それは&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20111212/1323649258&quot;&gt;順序付き関係&lt;/a&gt;となる。順序付き関係はプロ関手なので、プロ関手の結合で圏になるが、そうじゃなくて別な圏構造を入れる。

AからBへの順序付き関係を A+→B のように表す。順序付き関係を1セルと考えて、2セルを考える。2セルをTRペアと呼ぶ。TRはtranslation-reductのこと。インスティチューションを意識している。α::(R:A+→B)⇒(S:C+→D) がTRペアとする。TRペアとは：

+ f:C→A という単調写像（関手）
+ g:B→D という単調写像（関手）
+ 可換性

可換性の基本は、充足関係の公理：

- R(f(c), b) = S(c, g(b))

随伴ペア(f, g)の随伴性と同じ形をしている。R:A+→A のとき、RはA上のhomset関手だと思ってよい。ホントのhomset関手（標準homset）がプロ関手圏の恒等を与える。

&lt;h5&gt;充足関係がプロ関手である状況証拠&lt;/h5&gt;

細かい計算を全然してない。雰囲気だけ。

B extends A のことを B≧A あるいは A≦B と書くことにする。pが論理文だとして、メタ命題 A |= p の（メタの立場の）ブール論理値を [A |= p] と書くことにする。（&amp;lt;A |= p&gt; のほうが感じが出てるが、はてなダイアリーで書くのがメンドイ。）

次の事実がある。

- B≧A ならば、任意のpに対して [B |=p]≧[A |= p]。
- p |- q ならば、任意のAに対して [A |=p]≦[A |= q ]。

Mod[Σ]の階層構造の圏と、やせたデカルト閉圏とみなした Sen[Σ] に対して、R(A, p) := [A |= p] として定義された写像が、プロ関手になっていることは示せると思う。

Mod[Σ]の階層構造の圏をHier[Σ]とすると、[- |=&lt;sub&gt;Σ&lt;/sub&gt; -] :Hier[Σ]+→Sen[Σ] となっている。つまり、3つ組 (Hier, Sen, [- |= -]) は、指標圏からプロ関手を対象として（1セルではなくて）2セルを射とする圏への関手となっている。

&lt;h5&gt;多段インスティチューション&lt;/h5&gt;

実は、一連のことをボーッと考えたきっかけは、多段インスティチューションなのだ。Hier[-], Sen[-] のような意味が固定された関手ではなくて、指標の圏Sigから&lt;b&gt;B&lt;/b&gt;-豊饒圏への関手 F[-], G[-] があったとして、R[-]:F[-]+→G[-] がプロ関手となっている状況を考える（TRペアも一緒に考えている）。これは普通のインスティチューションを少し抽象化しただけ。

別に、S[-]:G[-]+→H[-] というプロ関手を値とする関手があるとする。これもインスティチューションと考えてよい。R[-]とS[-]は、プロ関手の普通の結合で結合できる。RとSを結合すると、(R*S)[-] : F[-]+→H[-] というインスティチューションができる。

もちろん、プロ関手圏の1セル（水平セル）と2セルの計算をちゃんと定義しないといけない。

多段インスティチューションを使うと、「要件、仕様、論理モデル、実装モデル」のように順に詳細化／具体化する設計プロセスを定式化できると思われる。「実装が要件を満たす」といった言明に正確な定義を与えられる可能性がある。

&lt;h5&gt;何が必要か&lt;/h5&gt;

豊饒圏をベースにしたプロ関手の理論が必要なんだが、通常のプロ関手結合以外に、2セルを入れて2次元化することも必須。インスティチューションでは、指標射に対して2セルのほうを対応させる。1セル（プロ関手）の水平結合は、多段インスティチューションを縮退させるときに使う。

豊饒化の基礎圏（enrichedじゃなくてenriching cat. のほう）も取り替えるような定式化が必要な気もする。

多段インスティチューションは、充足関係（2つの圏とプロ関手）の横チェーンのことだ。それとは別に縦方向の2セル（面）もある、という構造。2セルが、translation-reduct pairだ。通常のインスティチューションでは、2セルの部分の定式化が弱い。ここを強化しないとな。

&lt;h5&gt;ローヴェルの距離空間&lt;/h5&gt;

非負実数を対象として、順序（ただし逆向き）を射とする圏は、maxを直積、minを直和とするデカルト半環圏となる。この圏の同型は等しいこと。積は厳密に対称となる。他に足し算もモノイド積となり、制限引き算が指数となりモノイド閉圏。

非負実数の圏には、モノイド積が3つもある。有限次元ベクトル空間の圏のように直積直和が退化していることもない。なかなかに面白い圏だ。

非負実数の圏を豊饒基礎圏（enriching cat.）として豊饒圏が（多少拡張した）距離空間であることはローヴェルが指摘している。直積距離空間は和距離で定義すると、距離空間の圏は積を持つことになる。また非負実数自体も差の絶対値で距離空間になる。

距離空間の圏をある種の圏の圏（レルム）と考えると、関手は縮小写像（正確には非拡大写像）となる。プロ関手は、積距離空間からの縮小写像で与えられる。プロ関手の結合は、不等号評価を色々使えば出る。

この距離空間の圏においても、プロ関手とTRペアのようなものを考えることが出来ると思うが、どうだろう。

&lt;h5&gt;用語&lt;/h5&gt;

プロ関手は、まー「プロ関手」でもいいと思う。「対応」のほうが望ましい気はするが少数派だからな。

プロ関手のあいだの２セルは「随伴対」でもいいのかな。プロ関手を一般化されたホムセットと考えれば、ホムセットを使った随伴の定義と同じ形をしている。随伴とのアナロジーを追うのも悪くない気がする。

&lt;h5&gt;記号とキーワード&lt;/h5&gt;

|* 記号     |* キーワード |
| p⊃q      | p implies q |
| &amp;#124;- A | Provable[A] |
| A &amp;#124;- B | A derives B |
| A &amp;#124;= p    | A satisfies p |
| B≧A      | B extends A |
| A∈Mod[Σ] | A implements Σ |
| α⊆β    | β contains α |


</body>
</day>
<day date="2011-12-29" title="">
<body>
*1325129976*[気付いた][課題][メモ][高次圏論][プログラム意味論][インスティチューション]多段インスティチューションに使うための、ある種の2次元の圏

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111228/1325060166&quot;&gt;インスティチューションだのプロ関手だのなんだの&lt;/a&gt;」の「何が必要か」に書いたこと、だいたいの見当は付いたと思う。厳密性がないハナシで、その意味ではマダマダだけど。

目的は多段階の設計実装プロセスをきちんと定式化すること。インスティチューション（指標圏からの関手）が値を取る圏が複雑になる。インスティチューションの値となる圏（関手の余域圏）は水平射と垂直射と2セルを持つ二重圏と考えられる。水平射は、豊饒化プロ関手。垂直射は関手のペアで、豊饒化プロ関手と協調するもの。

豊饒化プロ関手（圏論的対応＝一般化関係）として次のような例を考えたい。Vは豊饒化基礎圏を表す。

+ 単なる集合のあいだの関係 V=ブール代数
+ プレ順序集合のあいだの順序付き関係 V=ブール代数
+ ローヴェルの一般化距離空間の積からの縮小写像 V=非負実数
+ 順序ベクトル空間と順序保存双線形形式 V=非負実数
+ 普通のプロ関手 V=&lt;b&gt;Set&lt;/b&gt;

これらの圏の対象（0-セル）はそれ自体圏となるので、&lt;em&gt;圏の圏＝レルム&lt;/em&gt;を考えることになる。ただし、生の関手はほとんど登場しない。垂直（鉛直）射が関手ではあるが。

この圏、いや二重圏で、問題となるのは2-セル＝タイルと、その4つの1-境界の定義である。以下2セルを&lt;strong&gt;タイル&lt;/strong&gt;と呼び、水平方向は&lt;em&gt;左から右&lt;/em&gt;、垂直方向は&lt;em&gt;上から下&lt;/em&gt;として、タイルの左辺、右辺、上辺、下辺を使う。

- 左辺＝水平方向のdom
- 右辺＝水平方向のcod
- 上辺＝垂直方向のdom
- 下辺＝垂直方向のcod

タイルは、原則的に垂直方向（上から下）への射と考える。水平方向では横結合＝スター積を考える。

タイルの向き（orientation）が色々あるのが面倒になる原因。

&lt;pre&gt;

 ・→・
 ↓  ↓
 ・→・

 ・→・
 ↑  ↓
 ・→・

 ・←・
 ↓  ↓
 ・→・

 ・←・
 ↑  ↓
 ・→・

&lt;/pre&gt;

図形としては16通りの組み合わせがある。上辺と下辺の方向（direction）は揃ってるとして、左右が揃っているか食い違っているかの2種を考えれば間に合う気がする。いや、4種か？

- 左右の方向が揃っている ホモペア＝ホモタイル
- 左右の方向が食い違っている ヘテロペア＝ヘテロタイル

ホモかヘテロかってなんというのだろう？ 極性（polarity）じゃないし、変性（variance）でもないし。homogeneityか？

縦結合に関しては、ホモタイルとホモタイル、ヘテロタイルとヘテロタイルしかできない。ヘテロとホモ、ホモと上下反転のヘテロ、ホモとホモ、ヘテロと上下反転のヘテロの結合が可能だが、上下反転のヘテロの扱いがよく分からない。考慮すべきか無視すべきか？

双対のような対合関手（involution functor）がいくつか入っているのかもしれない。

</body>
</day>
<day date="2011-12-30" title="">
<body>
*1325208274*[気付いた][課題][メモ][山勘]プロセッサの個数とプランク定数

http://d.hatena.ne.jp/m-hiyama/20080121/1200892274、http://d.hatena.ne.jp/m-hiyama/20100713/1278997329 に書いた話で：

- h = 1 では、マスロフ和は +（普通の足し算）
- h = 0 では、マスロフ和は max

h(N) = 1 - 1/N とすると：

- h(∞) = 1
- h(1) = 0

Nはプログラム実行系が持つプロセッサ（CPU）の個数。つまり、1プロセッサの逐次処理だと粒子的、無限のプロセッサで並列処理すれば波動的。

N = 1, h = 0 のときの計算モデル圏は集合圏、N = ∞, h = 1 のときの計算モデル圏は関係圏。

現状、妄想のレベル。だが、状況証拠がないわけじゃない。スパイダーグラフ上の計算エミュレータができれば実験的な状況証拠が増えると思う。ナニカがある、なんだろう？



</body>
</day>
<day date="2012-01-04" title="">
<body>
*1325660872*[気付いた][からみ系][多圏] 1/2-近傍

あ、そうか。

グラフのある点から、n本以下の辺をたどっていける頂点＋辺のスター状近傍をn-近傍と呼ぶことにする。0-近傍、1-近傍、2-近傍、と定義できる。半整数に関しても近傍を考えればいいんだな。

特に、1/2-近傍＝半近傍が大事だ。1/2の意味は、辺を真ん中へんでちょんぎって、切り口は開端（open-end）ノードとすること。つまり、辺が開いた辺、半辺、フラグとか呼ばれているアレになる。

近傍＝1-近傍、半近傍＝1/2-近傍という言葉でうまいこと説明がつくな。開端ノードを考えるのは重要なんだ。

*1325658594*[Caty][圏一般論]スパイダーグラフのジャンクション 暫定案

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/junctions.gif&quot; &gt;

+ id&lt;sub&gt;A&lt;/sub&gt; : A→A
+ literal&lt;sub&gt;x&lt;/sub&gt; : void→sngleton(x)
+ literal&lt;sub&gt;void&lt;/sub&gt; = id&lt;sub&gt;void&lt;/sub&gt; : void→void
+ disc&lt;sub&gt;A&lt;/sub&gt; : A→void
+ copy&lt;sub&gt;A&lt;/sub&gt; : A→A×A
+ tuple&lt;sub&gt;A,B&lt;/sub&gt; : A, B→A×B
+ detuple&lt;sub&gt;A,B&lt;/sub&gt; : A×B→A, B
+ choose&lt;sub&gt;A&lt;/sub&gt; : A→A, A
+ merge&lt;sub&gt;A,B&lt;/sub&gt; : A, B→A∪B
+ branch&lt;sub&gt;A,B&lt;/sub&gt; : A+B→A, B

以下に描画用のソース。
====

&gt;||
// -*- coding: utf-8 -*-
// This is junctions.caty

[

// id

 gv:node --shape=point --style=invis idin,
 gv:node --shape=point --style=invis idout,

 gv:edge --label=A idin idout,


// literal l

 gv:node --shape=point --style=invis lin,
 gv:node --shape=point --style=invis lout,

 gv:edge --label=x --dir=both --arrowtail=dot lin lout,

// void v

 gv:node --shape=point --style=invis vin,
 gv:node --shape=point --style=invis vout,

 gv:edge --label=&quot;&quot; --dir=both --arrowtail=dot --arrowhead=dot --style=dotted vin vout,

// discharger d

 gv:node --shape=point --style=invis din,
 gv:node --shape=point --style=invis dout,

 gv:edge --label=&quot;A&quot; --dir=both --arrowhead=dot --arrowtail=inv --style=dotted din dout,

// copy  c
 gv:node --shape=point --style=invis cin,
 gv:node --shape=point --style=invis cout1,
 gv:node --shape=point --style=invis cout2,

 gv:node --shape=point --width=0.3 --style=filled --fillcolor=brown copy,

 gv:edge --label=A cin copy,
 gv:edge --label=A copy cout1,
 gv:edge --label=A copy cout2,


// tuple t

 gv:node --shape=point --style=invis tin1,
 gv:node --shape=point --style=invis tin2,
 gv:node --shape=point --style=invis tout,

 gv:node --label=&quot;*&quot; --shape=diamond --style=filled --fillcolor=brown tuple,

 gv:edge --label=A tin1 tuple,
 gv:edge --label=B tin2 tuple,

 gv:edge --label=&quot;[A, B]&quot; tuple tout,

// detuple dt

 gv:node --shape=point --style=invis dtin,
 gv:node --shape=point --style=invis dtout1,
 gv:node --shape=point --style=invis dtout2,

 gv:node --label=&quot; &quot; --shape=diamond --style=filled --fillcolor=brown dt, 

 gv:edge --label=&quot;[A, B]&quot; dtin dt,
 gv:edge --label=A dt dtout1,
 gv:edge --label=B dt dtout2,

// nd branch nd

 gv:node --shape=point --style=invis ndin,
 gv:node --shape=point --style=invis ndout1,
 gv:node --shape=point --style=invis ndout2,

 gv:node --label=&quot;&quot; --shape=point --width=0.3 --style=filled --fillcolor=white nd, 

 gv:edge --label=A nd ndout1,
 gv:edge --label=A nd ndout2, 
 gv:edge --label=A ndin nd,

// merge m

 gv:node --shape=point --style=invis min1,
 gv:node --shape=point --style=invis min2,
 gv:node --shape=point --style=invis mout,

 gv:node --label=&quot;&quot; --shape=point --width=0 --style=invis merge, 
 gv:edge --label=A min1 merge,
 gv:edge --label=B min2 merge,
 gv:edge --label=&quot;A, B&quot; merge mout,

// cond branch cb

 gv:node --shape=point --style=invis cbin,
 gv:node --shape=point --style=invis cbout1,
 gv:node --shape=point --style=invis cbout2,

 gv:node --label=&quot; &quot; --shape=diamond --style=filled --fillcolor=white cb, 

 gv:edge --label=&quot;A|B&quot; cbin cb,
 gv:edge --label=A cb cbout1,
 gv:edge --label=B cb cbout2, 

] | gv:graph --label=junctions --rankdir=TB --bgcolor=gainsboro

||&lt;

*1325638766*[課題][雑感][圏一般論]データを捨てるのは難しい、など

集合圏で考えると、!&lt;sub&gt;A&lt;/sub&gt; : A → &lt;b&gt;1&lt;/b&gt; があるから、これでデータを捨てることになる。しかし、&lt;b&gt;1&lt;/b&gt;は「無」ではないから存在がなくなったわけではない。単に縮めただけ、あるいは要素の区別をなくしただけで、捨てたことになってないような気がする。

だが、集合圏では、非空なAに対して A → &lt;b&gt;0&lt;/b&gt; という射はないから、「有」を「無」にできない。一方、&lt;b&gt;0&lt;/b&gt;→A は存在するから、「無」から「有」は許されている。とはいえ、ソフトウェアで「無」状態を表現できないから、&lt;b&gt;0&lt;/b&gt;→Aがあってもそのままでは扱いようがない。可能なのは &lt;b&gt;1&lt;/b&gt;→A という射でプログラムを始めることだが、この&lt;b&gt;1&lt;/b&gt;が&lt;em&gt;どっから来たのか&lt;/em&gt;がどうもわからない。

集合ベースで考えると、データを無にすることはできない。できる事は、データを見えなくすることだけだ。見えないとは言っても「在る」のだから、見えない場所に存在している。つまり、データを捨てるとか消すとか言っても、存在の様式を変化させているだけだ。例えば、例外を出せば戻り値はなくてもいいが、戻り値を例外という様式（チャンネル）に変えて出力しただけ。

&lt;b&gt;1&lt;/b&gt;→A がデータの生成か？ これも&lt;em&gt;アヤシイ&lt;/em&gt;。&lt;b&gt;1&lt;/b&gt;はもともと在ったモノだし、Aも最初から在ったモノだし。単に在るモノを特定したに過ぎない。

関係圏なら、A→&lt;b&gt;0&lt;/b&gt; という射が1つだけだが“在るには在る”。これがデータの消去なのか？ うーん、&lt;em&gt;わからん&lt;/em&gt;。

集合圏と関係圏はまったく違う。&lt;em&gt;似てない&lt;/em&gt;。にもかかわらず、集合圏（や部分写像の圏）は関係圏に埋め込める。単なる圏としては確かに埋め込めるのだが、直積・直和の構造は極端に変形してしまう。集合圏の直和は関係圏の双積になり、集合圏の直積はテンソル積になる。我々は、暗黙に「関係圏に埋め込まれた集合圏」を考えていることが多く、直積・直和の解釈でしばしば混乱する。

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20111230/1325208274&quot;&gt;プランク定数&lt;/a&gt;が異なる世界を同時に考えて、ワケワカンナクなっている状況だと思う。実際ワケワカンナイ。なんとかしたい。

*1325638861*[Caty][説明][雑記]コマンドでお絵描き

例えば、

&lt;img src=&quot;http://www.chimaira.org/img3/seq4.gif&quot; &gt;

この図のソースは次。

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
// sequent

[
 gv:node --shapa=point --style=invis sin1,
 gv:node --shape=point --style=invis sin2,
 gv:node --shape=point --style=invis sin3,
 gv:node --label=&quot;&gt; *&quot; --shape=diamond --style=filled --fillcolor=brown sin4,

 gv:edge --label=A     sin1 seq,
 gv:edge --label=B     sin2 sin4,
 gv:edge --label=C     sin3 sin4,
 gv:edge --label=&quot;B*C&quot; sin4 seq,

 gv:node --label=&quot;==&gt;&quot; --style=filled --fillcolor=darkseagreen seq,

 gv:node --shapa=point --style=invis sout1,
 gv:node --label=&quot;+ &amp;lt;&quot; --shape=diamond --style=filled --fillcolor=white sout2, 
 gv:node --shape=point --style=invis sout3,
 gv:node --shape=point --style=invis sout4,


 gv:edge --label=X     seq   sout1,
 gv:edge --label=&quot;Y+Z&quot; seq   sout2,
 gv:edge --label=Y     sout2 sout3,
 gv:edge --label=Z     sout2 sout4,

] | gv:graph --label=sequent --rankdir=LR --bgcolor=gainsboro
&lt;/pre&gt;

これはスクリプトファイル。実行すると次を出力する（けっこう長いな）。

&lt;pre class=&quot;code&quot;&gt;
@digraph {
    &quot;graph&quot;: {
        &quot;rankdir&quot;: &quot;LR&quot;,
        &quot;bgcolor&quot;: &quot;gainsboro&quot;,
        &quot;label&quot;: &quot;sequent&quot;
    },
    &quot;elements&quot;: [
        @node {
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sin1&quot;,
            &quot;shapa&quot;: &quot;point&quot;
        },
        @node {
            &quot;shape&quot;: &quot;point&quot;,
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sin2&quot;
        },
        @node {
            &quot;shape&quot;: &quot;point&quot;,
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sin3&quot;
        },
        @node {
            &quot;shape&quot;: &quot;diamond&quot;,
            &quot;style&quot;: &quot;filled&quot;,
            &quot;id&quot;: &quot;sin4&quot;,
            &quot;fillcolor&quot;: &quot;brown&quot;,
            &quot;label&quot;: &quot;&gt; *&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sin1&quot;,
                &quot;seq&quot;
            ],
            &quot;label&quot;: &quot;A&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sin2&quot;,
                &quot;sin4&quot;
            ],
            &quot;label&quot;: &quot;B&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sin3&quot;,
                &quot;sin4&quot;
            ],
            &quot;label&quot;: &quot;C&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sin4&quot;,
                &quot;seq&quot;
            ],
            &quot;label&quot;: &quot;B*C&quot;
        },
        @node {
            &quot;style&quot;: &quot;filled&quot;,
            &quot;label&quot;: &quot;==&gt;&quot;,
            &quot;id&quot;: &quot;seq&quot;,
            &quot;fillcolor&quot;: &quot;darkseagreen&quot;
        },
        @node {
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sout1&quot;,
            &quot;shapa&quot;: &quot;point&quot;
        },
        @node {
            &quot;shape&quot;: &quot;diamond&quot;,
            &quot;style&quot;: &quot;filled&quot;,
            &quot;id&quot;: &quot;sout2&quot;,
            &quot;fillcolor&quot;: &quot;white&quot;,
            &quot;label&quot;: &quot;+ &amp;lt;&quot;
        },
        @node {
            &quot;shape&quot;: &quot;point&quot;,
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sout3&quot;
        },
        @node {
            &quot;shape&quot;: &quot;point&quot;,
            &quot;style&quot;: &quot;invis&quot;,
            &quot;id&quot;: &quot;sout4&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;seq&quot;,
                &quot;sout1&quot;
            ],
            &quot;label&quot;: &quot;X&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;seq&quot;,
                &quot;sout2&quot;
            ],
            &quot;label&quot;: &quot;Y+Z&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sout2&quot;,
                &quot;sout3&quot;
            ],
            &quot;label&quot;: &quot;Y&quot;
        },
        @edge {
            &quot;nodes&quot;: [
                &quot;sout2&quot;,
                &quot;sout4&quot;
            ],
            &quot;label&quot;: &quot;Z&quot;
        }
    ],
    &quot;id&quot;: &quot;graph&quot;
}
&lt;/pre&gt;

GraphvizのDOT形式なら：

&lt;pre class=&quot;code&quot;&gt;
strict digraph &quot;graph&quot; {
        graph [bgcolor=gainsboro,
                label=sequent,
                rankdir=LR
        ];
        node [label=&quot;\N&quot;];
        sin1     [shapa=point,
                style=invis];
        seq      [fillcolor=darkseagreen,
                label=&quot;==&gt;&quot;,
                style=filled];
        sin1 -&gt; seq      [label=A];
        sout1    [shapa=point,
                style=invis];
        seq -&gt; sout1     [label=X];
        sout2    [fillcolor=white,
                label=&quot;+ &amp;lt;&quot;,
                shape=diamond,
                style=filled];
        seq -&gt; sout2     [label=&quot;Y+Z&quot;];
        sin2     [shape=point,
                style=invis];
        sin4     [fillcolor=brown,
                label=&quot;&gt; *&quot;,
                shape=diamond,
                style=filled];
        sin2 -&gt; sin4     [label=B];
        sin4 -&gt; seq      [label=&quot;B*C&quot;];
        sin3     [shape=point,
                style=invis];
        sin3 -&gt; sin4     [label=C];
        sout3    [shape=point,
                style=invis];
        sout2 -&gt; sout3   [label=Y];
        sout4    [shape=point,
                style=invis];
        sout2 -&gt; sout4   [label=Z];
}
&lt;/pre&gt;

XJSONやDOTのデータとして書いてもいいだろう？ って思うかもしんないが、そりゃ違う。最終的にgv:Digraph型のXJSONデータが出来れば途中で何したっていいのが凄く便利。例えば次は、バグ（もう直った）の再現用のスクリプト。なんでもいいから引数（%1）を渡すとバグを再現する。

&lt;pre class=&quot;code&quot;&gt;
%1? |
when {
  undefined =&gt; [],
  *         =&gt; [gv:edge n3 n1, gv:edge n3 n2], // これがバグを引き起こす
} &gt; bug;

[
  [
    [ 
      gv:node --shape=doublecircle --style=filled --fillcolor=red n1,
      gv:node --shape=diamond --style=filled --fillcolor=skyblue  n2,
      gv:edge --style=&quot;dashed, bold&quot; n1 n2,
    ] | gv:cluster --style=rounded,
    gv:node n3,
  ], 
  %bug 
] | list:concat | gv:graph
&lt;/pre&gt;

ちなみに、gvモジュールでPythonで書かれたコマンドは1個だけ（Graphvizとインターフェースする主要コマンドdraw）。他のユーティリティはCatyScriptで書いている。

あと、本編には貼らないだろう“より現実的な”コマンドの絵。いずれ説明する。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/cmd2.gif&quot; &gt;
&lt;a href=&quot;http://www.chimaira.org/img3/cmd2.gif&quot; &gt;原寸大&lt;/a&gt;

*1325644069*[Caty][プログラム意味論][多圏]Catyのコマンドと変数

http://d.hatena.ne.jp/m-hiyama-memo/20120104/1325638861 :
&gt;&gt;
いずれ説明する。
&lt;&lt;

今日説明する。絵に基づいて説明する。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/cmd2.gif&quot; &gt;
&lt;a href=&quot;http://www.chimaira.org/img3/cmd2.gif&quot; &gt;原寸大&lt;/a&gt;

これが&lt;strong&gt;コマンド&lt;/strong&gt;なわけだが：

+ &lt;strong&gt;command body&lt;/strong&gt; とはPythonコード、またはCatyScriptコードで、コマンドの本体となる定義体（definition body）のこと。
+ パラメータの一部のArg0はシステムが準備する。今はWebリクエストのURLくらいで、大した用途はないが、いずれ&lt;em&gt;ヘビーに使う&lt;/em&gt;予定だ。
+ オプションパラメータOptsはコマンドライン（コマンド起動構文）、またはクエリー文字列から渡される。
+ 引数パラメータArgsはコマンドラインから渡される。アクションのときは、自動的に%0と%1が同じ値にセットされる（これはアクション特有の仕様）。
+ Arg0 + Args は、Argvとしてアクセスできる。（実際の変数名は _ARGV）
+ パラメータの情報は、すべて変数としてアクセスできる（&lt;em&gt;書き換えはできない&lt;/em&gt;）。command bodyの実行が始まるときには、パラメータ変数の値はすべて確定している。
+ パラメータ変数以外に、（大域）環境変数がcommand bodyから見える。環境変数とパラメータ変数は、実行前にセットアップされるので、&lt;strong&gt;準備済み変数&lt;/strong&gt;（prepared variables）と呼ぶ。
+ 準備済み変数のセットアップ手順やスコーピングはけっこう複雑だが今は触れない。
+ command bodyに制御が渡るときは、準備済み変数と共に標準入力も必ず存在している。標準入出力のデータが制御を運ぶ役割もしている。
+ 準備済み変数と標準入力以外のデータが欲しいときは、readableファシリティを使う。ファシリティを経由しないIOはほぼ犯罪行為である。多くの場合、犯罪には天罰が下る。
+ command bodyが正常に終了すれば標準出力にデータを書く。
+ 例外とシグナルは標準出力以外の出力チャンネルとなる。どちらも「投げて」「キャッチされる」もの。実装は規定しないが、たぶん両者は同じ実装方式だろう。例外はエラーメッセージを出したりロギングしたりする都合から投げるデータ形式が&lt;em&gt;決まっている&lt;/em&gt;。シグナルは特に制限がない（勝手にやってくれ）。
+ フォーワード制御は大域ジャンプで、例外／シグナルとは違い行き先が決まっている。&lt;strong&gt;ポート&lt;/strong&gt;を使うと、行き先の決定を遅らせることができるが、実行時には特定のコマンドに飛ぶことになる。
+ 出力チャンネルの選択は排他的で、どれか1つのチャンネルだけが選ばれる。他のチャンネルには何も出力されない。特定のチャンネルを使用禁止にするには、その型をneverと宣言すればよい。例外なら、throws only [] で例外チャンネルを使用しないこと、つまり絶対に例外を出さないことを宣言できる。
+ Webの場合は特殊事情で、リダイレクトチャンネルを設ける。これは、シグナルで実装されることが多いだろうが、単に便宜上の都合から独立な出力チャンネルとして扱う。
+ リダイレクトチャンネルのように、応用で必要ならチャンネルを増やしてもよい。ただし、コマンドの宣言構文が変わるので、ユーザー拡張はできない。

&lt;hr&gt;
&lt;img src=&quot;http://www.chimaira.org/img3/var.gif&quot; &gt;

これは&lt;strong&gt;局所変数&lt;/strong&gt;の説明の絵。局所変数（local variable）は、スクリプトコードの実行時に生成され利用（参照）される。Catyでは、変数参照（%foo）も一種のコマンド（射）のように扱う。変数参照（%foo）に制御が渡るときには、変数はセットされてなくてはならない。制御フローを解析すれば、未定義変数の参照は検出できる。

変数参照が点線で描かれたvoid標準入力を持つのは、コマンド扱いだからである。破線で描かれた変数伝搬ワイヤーは、readableファシリティからの入力と同じようなものだ。つまり、%foo は、local-variableファシリティを使う var-ref foo のようなコマンドだと思えばよい。'&gt;' が、local-variableファシリティへの単一書き込みをする演算子となる。

変数参照は、値を変数ポイント（黒丸）から変数伝搬辺（破線）を通してもらうが、自分で値を作り出せばリテラル射となる。変数参照とリテラルはけっこう近い存在だ。

&lt;hr&gt;
&lt;img src=&quot;http://www.chimaira.org/img3/varset.gif&quot; &gt;

&lt;strong&gt;変数セット&lt;/strong&gt;（variable set）の絵。変数セットとは、文字通り変数の集合体。大域環境変数やパラメータ変数達が変数セットをなす。実装上はシンボルテーブルにするかな。局所変数もスコープを作る（eachブロックとbeginブロック）ので、スコープ内の束縛＝変数セットとみなすことができる。

図の変数bazのように、存在しても参照されない変数は描かなくてもよい。あってもなくても同じだから。変数の特徴は、一度値がセットされれば、それより後に何度でも参照できること。図の変数fooは二箇所で参照されている。

&lt;hr&gt;
&lt;h5&gt;絵のソース&lt;/h5&gt;

念のため、絵のソースを貼っておく。gvモジュールを使っている。万が一、画像ファイルをなくしても、これを実行すればすぐに作れる。手直してもすぐだ。SVGやプレーンDOT形式にも出せるよ。

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
// command

[
 gv:node --shapa=point --style=invis cin,
 gv:node --shapa=point --style=invis ain,
 gv:node --shape=point --style=invis pin1,
 gv:node --shape=point --style=invis pin2,
 gv:node --label=&quot;* &quot; --shape=diamond --style=filled --fillcolor=brown param,

 gv:edge --label=StdIn cin  cmd,
 gv:edge --label=Opts  pin1 param,
 gv:edge --label=Arg0  ain  param,
 gv:edge --label=Args  pin2 param,
 gv:edge --label=&quot;ParamVars&quot;  --arrowhead=diamond param cmd,

 gv:node --label=&quot;command\nbody&quot; --style=filled --fillcolor=darkseagreen cmd,

 gv:node --shapa=point --style=invis cout,
 gv:node --label=&quot;  &quot; --shape=diamond --style=filled --fillcolor=white th, 
 gv:node --shapa=point --style=invis cerr,
 gv:node --shape=point --style=invis sout, 
 gv:node --label=target --style=&quot;dotted, filled&quot; --fillcolor=yellowgreen port_h, 

 gv:edge --label=StdOut    cmd cout,
 gv:edge --label=Throwable cmd th,
 gv:edge --label=Exception --color=red --fontcolor=red  th cerr,
 gv:edge --label=&quot;Signal&quot; --color=blue --fontcolor=blue th sout,
 gv:edge --color=seagreen  --fontcolor=seagreen --label=&quot;Forward&quot; cmd port_h,

] | gv:graph --label=&quot;command&quot; --rankdir=LR --bgcolor=gainsboro
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
// variables

[
  gv:node --shapa=point --style=invis  vin,
  gv:node --shapa=point --style=invis  vout,
  gv:node --shape=point --width=0.1 --style=filled --fillcolor=black var,

  gv:edge --label=A --arrowhead=none --headlabel=foo vin var,
  gv:edge var vout,

// ref  

  gv:node --shapa=point --style=invis  rin,
  gv:node --shapa=point --style=invis  rout,
  gv:node --label=&quot;%foo&quot; --style=filled --fillcolor=moccasin ref,

  gv:edge --arrowhead=none --style=dotted rin ref,
  gv:edge --label=A ref rout,
  gv:edge --style=dashed --arrowhead=diamond var ref,
  

] | gv:graph --label=&quot;local variable&quot; --rankdir=LR --bgcolor=gainsboro
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-
// variable set

[
  [
  gv:node --shape=point --style=invis  v1in,
  gv:node --shape=point --width=0.1 --style=filled --fillcolor=black var1,
  gv:edge --label=&quot;foo::A&quot; --style=dashed --arrowhead=none /*--headlabel=foo*/ v1in var1,

  gv:node --shape=point --style=invis  v2in,
  gv:node --shape=point --width=0.1 --style=filled --fillcolor=black var2,
  gv:edge --label=&quot;bar::B&quot; --style=dashed --arrowhead=none /*--headlabel=bar*/ v2in var2,

  gv:node --shape=point --style=invis  v3in,
  gv:node --shape=point --width=0.1 --style=filled --fillcolor=black var3,
  gv:edge --label=&quot;baz::C&quot; --style=dashed --arrowhead=none v3in var3,


  ] | gv:cluster --style=&quot;filled, rounded&quot; --fillcolor=moccasin varset,

// ref1

  gv:node --shape=point --style=invis  r1in,
  gv:node --shape=point --style=invis  r1out,
  gv:node --label=&quot;%foo&quot; --style=filled --fillcolor=moccasin ref1,

  gv:edge --arrowhead=none --style=dotted r1in ref1,
  gv:edge --label=A ref1 r1out,
  gv:edge --style=dashed --arrowhead=diamond var1 ref1,
  

// ref2

  gv:node --shape=point --style=invis  r2in,
  gv:node --shape=point --style=invis  r2out,
  gv:node --label=&quot;%foo&quot; --style=filled --fillcolor=moccasin ref2,

  gv:edge --arrowhead=none --style=dotted r2in ref2,
  gv:edge --label=A ref2 r2out,
  gv:edge --style=dashed --arrowhead=diamond var1 ref2,
  
// ref3

  gv:node --shape=point --style=invis  r3in,
  gv:node --shape=point --style=invis  r3out,
  gv:node --label=&quot;%bar&quot; --style=filled --fillcolor=moccasin ref3,

  gv:edge --arrowhead=none --style=dotted r3in ref3,
  gv:edge --label=B ref3 r3out,
  gv:edge --style=dashed --arrowhead=diamond var2 ref3,
  
] | gv:graph --label=&quot;variable set&quot; --rankdir=LR --bgcolor=gainsboro
&lt;/pre&gt;

</body>
</day>
<day date="2012-01-06" title="">
<body>
*1325831420*[メモ][雑感]インターネットって便利

突如、「キム・ノバック」って人名が思い浮かんだ。が、誰だかわからん。

「&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%82%81%E3%81%BE%E3%81%84_%281958%E5%B9%B4%E3%81%AE%E6%98%A0%E7%94%BB%29&quot;&gt;めまい&lt;/a&gt;」に出ていた女優さんか、&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A0%E3%83%BB%E3%83%8E%E3%83%B4%E3%82%A1%E3%82%AF&quot;&gt;キム・ノヴァク&lt;/a&gt;。

「めまい」は見たと思うが、なーんも覚えてない。

あ、キム・ノバックは「ピクニック」にも出てた、ウイリアム・ホールデンと一緒に。なーんも覚えてない。

*1325820410*[Caty][論理][多圏]カリー／ハワード／ジラール対応とスパイダーエンジン

カリー／ハワード対応は、「論理⇔プログラム」の対応。典型例は、「連言と含意のNK」と「型付きタプル付きラムダ計算」の対応。型の計算（型推論）がNKの証明に対応している。

ジラールとその周辺による対応はもうちょっと範囲が広いし、少し観点が違うように思うので、カリー／ハワード／ジラール対応と呼ぼう。本編 http://d.hatena.ne.jp/m-hiyama/20090406/1238979506 でちょっと触れたことがある。

以下に出てくる証明は、人間の証明行為ではなくて、対象化されたデータとしての証明だから&lt;em&gt;証明図&lt;/em&gt;ということにする。カリー／ハワード／ジラール対応では、証明図＝プログラム（証明図⇔プログラムという対応だが、イコールで書く）で、カット消去のような証明図の正規化がプログラムの実行＝式の評価に対応する。そして、正規化された証明図をジラールはdatumと呼ぶ。

すると、計算行為は、与えられた証明図を正規化することで、証明図の変形操作になる。「証明をすること」とはちょっと違う。計算行為の実行エンジンがコンピュータとかマシンなのだが、ここではエンジンと呼ぶ。

僕の感覚では、2つの世界が対応するというより、重なって同じものにみえる。つまりは文字通りに「証明図＝プログラム」。こうなると、「証明図を正規化するエンジン＝プログラムを実行するエンジン」となる。証明図もプログラムも絵図としてはスパイダーグラフで表現できる。つまり、「証明図を正規化するエンジン＝プログラムを実行するエンジン＝スパイダーグラフを正規化するエンジン」となる。

というわけで、証明図＝プログラム＝スパイダーグラフを評価or実行するエンジンを&lt;strong&gt;スパイダーエンジン&lt;/strong&gt;と呼ぶ。スパイダーエンジンは概念的なマシンなので、VMと呼ぶのは語弊がある。Logical Machine = LM だろうか？ LM仕様をVM仕様に落としてソフトウェアで実装できる。

ソフトウェアで実装したスパイダーエンジンがCatyのエンジンとなる。ただし、いわゆるランタイムとは限らない。ジラールの言う計算（computation）は、どちらかというとコンパイルなので、スパイダーエンジン＝コンパイラに近い。もっとも、コンパイラとインタプリタ（ランタイム）の区別はどうでもよくて、境界線を自由に設定できるような定式化にしておかないとマズイだろうが。



</body>
</day>
<day date="2012-01-10" title="">
<body>
*1326154487*[メモ][リンク]本・データベース設計

トビー・J.ティオリー・著、原田勝・訳『データベースの設計』（勁草書房）という本を買った。

[asin:4326000252:detail]

帯は捨ててしまうので写しておくと：

- データベースの設計のプロセスを、相互に結びついた一連のステップとして解説。理論面にかたよらない総合的な本格テキスト。

だそうで。

</body>
</day>
<day date="2012-01-11" title="">
<body>
*1326253174*[メモ]リンクの生成方法

- 順序集合の型：discrete, partial-order, linear-order, upTree, downTree, orderedUpTree, ...
- 複合的順序の構成法：product A, B、 dictionary A, B、sum A, B
- リンクの貼り方： completeFamily（完全グラフ）, directed, bidirected, tree, orderedTree, ...
- ノードのリンキング制約： sourceOnly, targetOnly, noLink, ...
- コレクションの概念：コレクションとは、有向グラフのベースになる順序集合
- ランク2コレクションの概念（コレクションのコレクション）
- コレクションのあいだのリンクフラックス（リンク矢印の束）
- ランク0オブジェクト＝エントリー、ランク0リンク＝リンク
- ランク1オブジェクト＝コレクション、ランク1リンク＝リンクフラックス

*1326274209*[メモ][Caty]忘れていた、アイコンデザインが途中

データと型の構成を表すアイコンを放置していた。

複合データ構成（直積）

+ 配列構成
+ オブジェクト構成
+ タギング

その他の圏論的な構成

+ 直和（排他的ユニオン）
+ undefモナドによる構成 

論理／集合論的な構成

+ 共通部分
+ 合併

だいたいの方針として、直積系は茶色、直和系は白。形状は丸か菱形。共通部分と合併は二重丸にしようかな（共通部分は茶色、合併は白）。

スクリプトの図示との整合性も必要だ。

- 複合データ構成はインスタンスにも定義できる演算。
- 複合データ構成と、直和／undefモナドはコマンド（射）に対しても適用できる。


</body>
</day>
<day date="2012-01-14" title="">
<body>
*1326527612*[メモ][msched]issueトラッカーの状態

次のようなことでクローズすることがある。

- 別な方法で解決した。
- 別な方法に方針を変えたので、もはや問題ではなくなった。

*1326527660*[Caty][メモ][多圏]スパイダー射の一種の掛け算

f:A→ B&lt;sub&gt;1&lt;/sub&gt;, ..., B&lt;sub&gt;n&lt;/sub&gt; と g:A→ C&lt;sub&gt;1&lt;/sub&gt;, ..., C&lt;sub&gt;n&lt;/sub&gt; がスパイダー射（cooperation）のとき、f▲g という射が定義できる。

- f▲g : A → B&lt;sub&gt;1&lt;/sub&gt;×C&lt;sub&gt;1&lt;/sub&gt;, ..., B&lt;sub&gt;n&lt;/sub&gt;×C&lt;sub&gt;n&lt;/sub&gt;

fとgは形状が同じだから、重ねあわせて、域の側はそのまま、余域側はワイヤー（成分）ごとに積を作る。多圏には積があるとする。

スパイダー射のk番目の出力ワイヤーだけを取り出し、他は捨てる操作を f&lt;sub&gt;+k&lt;/sub&gt; と表すと：

- (f▲g)&lt;sub&gt;+k&lt;/sub&gt;  = f&lt;sub&gt;+k&lt;/sub&gt;▲g&lt;sub&gt;+k&lt;/sub&gt;

*1326527803*[リンク][雑感]Torsors, herds and flocks

- Title: Torsors, herds and flocks
- Authors: Thomas Booker, Ross Street
- URL: http://arxiv.org/abs/0912.4551

なんなのこれ？ torsorなんて辞書にもない言葉だし。ロス・ストリートは還暦だいぶ過ぎていると思うが、、、このジイサンも凄いよな。

*1326530844*[メモ]MingwGIT

http://d.hatena.ne.jp/m-hiyama/20110302/1299029346 依頼、しばらく使ってなかった。使えなくなっていた。

/c/Installed/msysgit/ 以下に入っているが、パスがいってない。/c/Installed/msysgit/bin/git を直接呼んだら、libiconv-2.dll がないと言う。/c/Installed/msysgit/mingw/bin/ に libiconv-2.dll があるので、これを通常使っているMSYSの/bin/にコピーする。

&lt;pre class=&quot;out&quot;&gt;
[/c/Installed/msysgit]$ cp mingw/bin/libiconv-2.dll /bin/
&lt;/pre&gt;

これで動くようだ。

&lt;b&gt;[追記]&lt;/b&gt; 次も必要だった。

- msysgit/mingw/bin/libcurl-4.dll
- msysgit/mingw/bin/libcrypto.dll
- msysgit/mingw/bin/libssl.dll

YUI3がダウロードできた。

&lt;pre class=&quot;out&quot;&gt;
$ ./msysgit/bin/git clone https://github.com/yui/yui3.git
Cloning into yui3...
remote: Counting objects: 184744, done.
remote: Compressing objects: 100% (34633/34633), done.
remote: Total 184744 (delta 147219), reused 183050 (delta 145728)
Receiving objects: 100% (184744/184744), 61.95 MiB | 673 KiB/s, done.
Resolving deltas: 100% (147219/147219), done.

&lt;/pre&gt;

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2012-01-18" title="">
<body>
*1326881273*[Caty]CatyScriptの構成要素

お絵描きするにも操作的意味論するにも列挙しないと。

+ 基本コマンド呼び出し
+ スカラーリテラル（基本コマンド扱い）
+ 変数参照（ほぼ基本コマンド扱い）
+ 定義されたコマンドの呼び出し
+ 配列構成（直積 その1）
+ オブジェクト構成（直積 その2）、doもある
+ タギング（直積 その2）、&gt;@ もある

データ構成のレベルでは以上、タギング以外はJSONデータの構成。

次に圏論的なもの。

+ パイプ結合、';'もある。
+ when分岐（直和）、otherwiseワイルドカード'*'もある
+ each、リスト関手[T*]の射部分

メタコマンドによる制御。

+ call
+ forward
+ start

予定している機能、http://d.hatena.ne.jp/m-hiyama-memo/20101018/1287358225 参照。ただし、「set, doset構文の導入」はもうやる気なし。http://d.hatena.ne.jp/m-hiyama-memo/20101018/1287358319 にはrepeatの記述。

+ begin
+ repeat
+ 例外処理
+ throw
+ 論理パイプ

分類しにくい。

+ 代入演算子 '&gt;'
+ take
+ time

まだよくわからない。

+ undefsafe機能
+ フォーリンデータ型の扱い

SEVC機械という抽象機械を考えている。

- Stack (Call Stack)
- Environment (Context)
- Value
- Code

&lt;b&gt;[追記]&lt;/b&gt; uncloseもあった。→ http://d.hatena.ne.jp/m-hiyama/20110920/1316512670 。
あと、=[ , ] で書く予定の並行タプル＝射の直積。

関係するURLを並べておく。

+ http://d.hatena.ne.jp/m-hiyama/20090902/1251869950
+ http://d.hatena.ne.jp/m-hiyama/20101221/1292895388
+ http://d.hatena.ne.jp/m-hiyama/20091117/1258449015
+ http://d.hatena.ne.jp/m-hiyama/20091110/1257819178
+ http://d.hatena.ne.jp/m-hiyama/20091107/1257584135
+ http://d.hatena.ne.jp/m-hiyama/20091104/1257296704
+ http://d.hatena.ne.jp/m-hiyama/20091104/1257327232

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2012-01-20" title="">
<body>
*1327051537*[メモ]予定

火曜の10時に歯医者さん。

*1327051141*[Caty] 2010年10月の予定を2012年1月に振り返ると

1年3ヶ月ほど前の http://d.hatena.ne.jp/m-hiyama-memo/20101018/1287358225 からコピーすると：

&gt;&gt;
+ ワード概念とワードの解釈の明確化（文字列解釈、名前解釈、値解釈）
+ when分岐の拡張（疑似タグ分岐と値分岐）
+ 変数参照の明確化（構文、メカニズム、意味論）
+ スコープの明確化（環境変数、パラメータも含めて）
+ set, doset構文の導入
+ ハイフン変数の導入（名前が'-'である特殊変数）
+ 制御用パイプ記号 ';', '|&amp;', '||' の導入
+ コマンド宣言からコマンド定義に
+ begin/repeat制御構造（エルゴット・イテレーション）
&lt;&lt;

&lt;h5&gt;ワード概念とワードの解釈の明確化（文字列解釈、名前解釈、値解釈）&lt;/h5&gt;

最近、かなり明確になった。https://bitbucket.org/project_caty/dev/issue/342/ に書いてある。

&lt;h5&gt; when分岐の拡張（疑似タグ分岐と値分岐）&lt;/h5&gt;

やってない。when の直後にXJSONパスを書けばよい。問題はむしろ、ケースの値の表記のほうだ。タグ構文と一緒に変更するかもしれない。

パラメータ構文がハッキリしたから、これをベースにタグ名構文とケース分岐定数構文は考えなおしても良さそうだ。

&lt;h5&gt; 変数参照の明確化（構文、メカニズム、意味論）&lt;/h5&gt;

これは明確になった。

&lt;h5&gt; スコープの明確化（環境変数、パラメータも含めて）&lt;/h5&gt;

だいたい明確。スコープを作るブロックは begin, each。

&lt;h5&gt; set, doset構文の導入&lt;/h5&gt;

要らない、入れない。

&lt;h5&gt; ハイフン変数の導入（名前が'-'である特殊変数）&lt;/h5&gt;

入れてもいい。

&lt;h5&gt; 制御用パイプ記号 ';', '|&amp;', '||' の導入&lt;/h5&gt;

セミコロンは入れた、便利だ。論理パイプも入れようかな、記号は結局 |&amp;, || だろう。

&lt;h5&gt; コマンド宣言からコマンド定義に&lt;/h5&gt;

できた。使いまくっている。

&lt;h5&gt; begin/repeat制御構造（エルゴット・イテレーション）&lt;/h5&gt;

まだ。だが、forwardでほぼ同じことができる（http://d.hatena.ne.jp/m-hiyama/20111215/1323930122）。ただし、forwardで代替はできないのでrepeatは必要だ。



</body>
</day>
<day date="2012-01-21" title="">
<body>
*1327131453*[Caty] CatyScript1+α

昨日、「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120120/1327051141&quot;&gt;2010年10月の予定を2012年1月に振り返ると&lt;/a&gt;」なんてのを書いて、久々にCatyScript言語仕様について考えたりしている。

1.0とか2.0とか言っても、結局なし崩しに言語仕様が変わっていて、あんまり切れ目はない。今のところ、後方互換性を壊すような変更はしてない。

今後の予定で、慎重に考えたほうがいいのは：

+ 例外処理： 例外型、throw、try-catch的な構文 http://d.hatena.ne.jp/m-hiyama/20091117/1258449015
+ undefsafe機能、単なるモナドではない。クライスリ圏のEmbedding-Projection関手ペアを考えるのだと思う。
+ フォーリンデータ型：よくよく注意しないと、型システムを滅茶苦茶に壊す。

なるべく早く欲しいのは：

+ beginブロックとrepeat制御
+ ポートに対するcall, forward

問題はないと思うが別に慌てなくてもいいのは：

+ 論理パイプ、|&amp;、||
+ 並行タプル =[,]、={,} http://d.hatena.ne.jp/m-hiyama/20101223/1293077872
+ unclose構文 http://d.hatena.ne.jp/m-hiyama/20110920/1316512670
+ 変数参照にパス式、 %foo.a.2.tag() とか。

やらないほうがいいと思うのは、パラメータ構文の拡張。変数参照が使えるので、もはや不足はない。これ以上やるとなんかヤバそうだ。フォーリンデータも相当にヤバいのだが、メタオブジェクトの表現にはないと困るので、入れざるをえない。必要なメタオブジェクト型は：

+ Type
+ Code
+ Command
+ Module
+ Ambient

Type（型）とCode（スクリプトのコード）があれば、他はXJSONでも表現できるとも言える。

&lt;hr&gt;

型システムは言語仕様の一部とも言えるが、いちおう別に考えると：

型の排他性判定は結局はintersectionの計算になる。N個の型が排他であることを保証するのは、(N*(N-1))/2 回のintersection計算をすればいい。今まで簡略でより速い方法を使ってきたが、正面からintersection計算してもいいかもしれない。

intersection計算でネックになるのはスキーマ属性なのだが、これは「できなきゃできないでいい」と割り切るべきだろう。排他性が不明なときは、安全性から「排他じゃない」とみなす。

あとは型推論だが、トランザクション処理をちゃんとすれば、実行時型チェックでもそれほどマズイわけじゃない。コンパイル時にチェックできたほうがいいが、実行時チェックを排除することはどうせできない。

&lt;b&gt;[追記]&lt;/b&gt;

今現在の心境では、whenの拡張はやりたくなくなった。どう拡張しても不自然な感じがするからだ。もともとwhenは拡張することを想定して設計したわけじゃなくて、一番簡単な分岐を実現しただけ。実際、概念も実装も簡単で、なかなかに使いやすい。こじんまり良くまとまっているものに手を加えるのはいかがなものか。

汎用的で強力な分岐構文caseを考えてみた。分岐条件は型であり、whenと同様に分岐条件は排他的でないといけない。つまり、互いに排他的なN個の型を並べる。分岐条件を適用する部分をパス式で指定できて、分岐後処理に渡す直前のフィルタリング処理も書ける。

同様な機能を提供する構文が2つあるのはドーヨ？という気はする。caseはwhenの機能を完全に含んでいるので、whenを廃止しても困ることはない。だが、whenは残したい。かなりのところwhenで間に合うし、タグ分岐なら明らかにwhenのほうが書きやすい。

もともと、CatyScriptの制御構造は排他的多方向分岐だけで、それをwhenが担ってきた。が、whenがいささか非力な点が気になってきた。whenの拡張・増強はしないで、別な排他的多方向分岐を入れたほうが良かろう、と、そう思っている。

&lt;b&gt;[/追記]&lt;/b&gt;

&lt;b&gt;[追記2]&lt;/b&gt; 

フォーリンデータ型のなかで、単なるメタオブジェクトというよりはむしろインターフェースと言うべきものがある。eachへの入力となるデータだ。現在、eachの入力はJSON配列／オブジェクトに限っているが、なんつーかIterableともでいうインターフェースを持っていればいい。each{f} の処理を手続き的に書けば：

&lt;pre class=&quot;code&quot;&gt;
var output = [];
while (input.hasNext()) {
  var item = input.next();
  output.push(f(item));
}
return output;
&lt;/pre&gt;

だから、hasNext(), next() を持っているナニカならeachに入れていい。データベースのカーソルとか、ファイルのストリームとか。型Tの配列と見なせるモノを Iterable&lt;T&gt; とすると、Tが既知の型なら eachは Iterable&amp;#60;T&gt; -&gt; list&amp;#60;T&gt; となる。list&amp;#60;T&gt; -&gt; Iterable&amp;#60;T&gt; は暗黙に変換されるから、黙っていても list&amp;#60;T&gt; -&gt; list&amp;#60;T&gt; が実現される仕掛け。

&lt;b&gt;[/追記2]&lt;/b&gt;

</body>
</day>
<day date="2012-01-30" title="">
<body>
*1327880124*[Caty]再度「XJSON - JSON」差分

データ構造としての「XJSON - JSON」差分は：

+ タグ付きデータ（型システムにも追加）
+ ルーズ配列の許容

型システムとしては、

+ binary型の追加
+ undefined型の追加

表層構文（パーズしたらなくなる）としては、

+ コメント
+ 三重引用符
+ 余分なカンマ

JSONエンコードに関しては：

+ タグ付きデータ→エンコード可能
+ ルーズ配列→&lt;em&gt;エンコード不可能&lt;/em&gt;
+ binary型→&lt;em&gt;エンコード方法未定&lt;/em&gt;
+ undefined型→エンコード不要（陽に出現しない）
+ コメント→&lt;em&gt;削除&lt;/em&gt;
+ 三重引用符→二重引用符＋エスケープ
+ 余分なカンマ→削除

</body>
</day>
<day date="2012-02-01" title="">
<body>
*1328091254*[Caty]いくつかの総称コマンドの例


- pass&amp;lt;T&gt; :: T -&gt; T;
- length&amp;lt;T&gt; :: list&amp;lt;T&gt; -&gt; number(minimum=0);
- dup&amp;lt;T&gt; [integer(minimum=0) n] :: T -&gt; list&amp;lt;T&gt;; //同じデータをn個並べたリスト
- first&amp;lt;T&gt; :: [T, _*] -&gt; T; //リストの先頭
- rest&amp;lt;_T*&gt; :: [_, _T*] -&gt; [_T*]
- leaves&amp;lt;T&gt; :: tree&amp;lt;T&gt; -&gt; [T*]; //ツリーの末端を集めてリストにする
- pair-fst&amp;lt;S, T&gt; :: Pair&amp;lt;S, T&gt; -&gt; S;
- pair-snd&amp;lt;S, T&gt; :: Pair&amp;lt;S, T&gt; -&gt; T;


</body>
</day>
<day date="2012-02-03" title="">
<body>
*1328228791*[雑感][Caty][プログラム意味論] まずい用語と記法は弊害を撒き散らす

Aを型項、αを型変数として、多相型を ∀α.A と表すのは定着した習慣になっている。∀をfor allなりfor anyと読み下すとそれなりに意味が通るので、まーいいかと思っていたが、論理の全称記号（全称限量子）が一緒に出てくる文脈だと混乱する。

それと、論理の全称束縛とは無関係なのに∀を使ったので、悪乗りしたヤツが∃をこれまた論理とは関係ない意味で使ったりする。∀、∃のような変わった記号は、論理における意味が強く染み付いているので、それをまったく無関係なところでオーバーロードするのは良くないだろう。しかも、ご本家の論理的命題（述語論理の限量された論理式）が出てくるのに一緒に使うって最悪じゃねーの。

*1328230842*[Caty][プログラム意味論]集合の不等式系と等式系

ここ何ヶ月か（ひょっとして何年？）悩んでいる問題がある。うまくいけば解決するかもしれない。

細部の定式化はいくらでもバリエーションがあるのだけど、次のような事実がある。

- プログラムの型安全性と集合の連立不等式系の可解性が同値となる。

集合の包含関係「⊆」を不等号とみなして、「⊆」と集合演算（∪、∩、＼）を含む論理式を「不等式」と呼んでいる。コゥゼン（Kozen）は集合制約系（set contsraints）という言葉を使っている。

束縛されてない（開いた）型変数を含むプログラムがある時、次の問を考える。

+ そのプログラムは型安全か？
+ そのプログラムの型変数にどのような具体型を割り当てれば型安全か？

これは、実際は1つの問とも言えて：

- そのプログラムを型安全とする型変数への型割り当てを求めよ。

集合の連立不等式系に持って行くと：

+ その不等式系は可解か？
+ その不等式系の未知変数にどのような値を割り当てれば不等式系は満たされるか？

非可解のときはそれでオシマイだが、可解のとき、不等式系の解は一意に決まらない。どの解を選ぶべきかが&lt;em&gt;わからない&lt;/em&gt;、これが問題。いわゆる最適解が欲しいのだが、最適性の条件が特にないのだ。テキトーに解を選べばいいのだが、テキトーに選ぶアルゴリズムが難しい。

ふと気づくと、不等式系Eが与えられると、これから閉じた（変数を含まない）不等式命題Cと等式系E'を作れる。そして、次の関係がある。

- 命題Cが真である ⇔ 等式系E'が可解である

さらに、

- 不等式系Eが可解である ⇔ 等式系E'が可解である

つまり、もとの不等式系Eの可解性も閉じた命題Cの真偽で決定できる。命題Cの作り方は知っていたし、それが可解性条件を与えることも知っていたが、等式系E'のほうは全然意識してなかった。

等式系E'は、もとの不等式系Eに比べてはるかに自由度が少ない。E'の解が（あるとして）一意かどうかわからないが、ずっと絞り込めることは確かだ。実例では、変数の数も劇的に減る。仮に変数が未定で生き残るにしても、それは少数だろう。

不等式系EからCとE'を作って、その後はCの真偽判定と等式系Eの解を求めることに集中すればいいのではないか、と（今は）思っている。

&lt;b&gt;[追記]&lt;/b&gt; このテの問題は、http://d.hatena.ne.jp/m-hiyama-memo/20110507 にだいたいまとまっている。「型検査と制約解決：制約解決＝連立不等式系の解を求める」（http://d.hatena.ne.jp/m-hiyama-memo/20110507/1304756310）では等式を併用しているのだが、このときは制約の伝搬という考え方をしている。不等式の一部を等式に置き換えているけど、「可解性が変わらない」という意識はなかったと思う。&lt;b&gt;[/追記]&lt;/b&gt;

&lt;b&gt;[さらに追記]&lt;/b&gt;

集合の連立不等式系Eから、閉じた命題Cと連立等式系E'が得られると言ったが、実際のアルゴリズムを考えると、命題Cの真偽は不等式系Eを作る段階で分かってしまう。つまり、次が成立する。

- 不等式系Eが作れる ⇔ 命題Cが真である。

等式系の構成もほぼ同じ手順なので、

- 等式系E'が作れる ⇔ 命題Cが真である。

最終的な型具体化を、等式系E'のほうから作るのだとしたら、不等式系Eは不要となる。ただし、ほんとに等式を考えるのかと言うとそうではなくて、命題Cは不等式命題。不等式命題Cの真偽を確認しつつ、ついでに等式系E'を作っていくようにすればいい。

処理が失敗したときは、

- 不等式命題Cが偽だった。
- したがって、等式系E'（不等式系Eでも）を作ることはできなかった。

処理が成功すると：

- 不等式命題Cが真だった。
- 等式系E'が作れた。

となる。「不等式命題Cが真 ⇔ 等式系E'が可解」なので、得られたE'には解がある。一意解とは限らないが、不等式系Eに比べてずっと扱いやすいはずだ。

&lt;b&gt;[/さらに追記]&lt;/b&gt;

</body>
</day>
<day date="2012-02-06" title="">
<body>
*1328489134*[Caty][プログラム意味論][形式言語理論]なーんだ！

非対称グラフ単一化って、オートマトンの模倣構成問題だったのだ。

メモリを気にしなければ、ノード間の対応（模倣辺）を全部覚えておいて、ダイクストラ法を使えばいい。メモリを使わないように、覚えておかなくていい（後で使わない）記録を削除しようとすると難しくなる。

中間結果は（使わなくても）全部覚えておくようにするなら、非対称グラフ単一化も簡単だ。


</body>
</day>
<day date="2012-02-07" title="">
<body>
*1328570820*[Caty][プログラム意味論][形式言語理論]Catyの型解析

最近考えている手順：

+ スクリプトから有向グラフを作る。あるいは最初から有向グラフが与えられる。
+ すべてのワイヤー（有向辺＝パイプ）に型注釈を付ける。このとき型付け規則（typing rules）を使う。
+ 限量子で束縛されていた型変数を名前を変えて自由変数にする。このとき、名前の捕捉が起きないようにする。
+ ワイヤーごとに不等式を作り、連立不等式系を構成する。この段階で不等式の個数はワイヤー＝パイプの数と同じ。
+ 非対称単一化を行い、不等式を既約な形にする。変数を含まない不等式か、xを変数として、A⊆x、x⊆B が規約な形。
+ 変数を含まない不等式を分離して、可解性条件とする。非可解ならオシマイ。
+ 残った不等式（変数を含む規約形）から付随等式系を構成する（詳細はいずれ）。
+ 付随等式系を代入法で解く（詳細はいずれ）。
+ 付随等式系の解を使って型注釈の変数を具体化する。

*1328591386*[Caty][プログラム意味論][形式言語理論]多相化ラムダ

http://ttic.uchicago.edu/~pl/classes/CMSC336-Winter08/lectures/lec10.pdf に、次の推論規則が載っていた。
「Xは型です」を X type と書くことにして、

&lt;pre&gt;
 Δ, α type |- τ type
 ----------------------
      Δ |- ∀α.τ


 Δ, α type; Γ |- e : τ
 --------------------------
 Δ; Γ |- Λα.e : ∀α.τ
&lt;/pre&gt;

セミコロンの左が型コンテキストで、右が評価環境なのだと思う。型コンテキストだけの∀導入はわかりやすい。Λα.e : ∀α.τ は、型項と項の両方を同時に型変数で束縛する。∀α.τ はいわゆる多相型。Λα.e は多相項か？ 項eを型変数で多相化する操作がΛなのだろう。

この例では、値に関する関数抽象がλ、型に関する全称束縛がΛとなっている。型に関する全称束縛を、型項も値項も同じ∀を使っている例がある。

∀α.(e : τ) = (Λα.e : ∀α.τ) と考えればいいのかな？ それなら、∀α.(e : τ) = (∀α.e : ∀α.τ) が分かりやすいかも。


</body>
</day>
<day date="2012-02-08" title="">
<body>
*1328676370*[TQFT][マンダラ][雑感][課題]行列の高次化

行列を高次元化するといっても、添字を増やしてテンソル計算するような話ではない。それは次元を増やしてない。いや、まー増やしていると言えなくもないが、0次元図形である点を配置する格子の空間の次元を増やしているだけ。

行列をうまく定義しようとすると、やはりカテグラフになる。カテグラフは、圏を係数域とする行列のことだ。カテグラフの圏を構成するには、次の2つの圏を必要とする。

+ &lt;i&gt;S&lt;/i&gt; ： シェープの圏。この圏の対象が境界シェープで、射がグラフのシェープとなる。
+ &lt;i&gt;V&lt;/i&gt; ： 係数の圏。

&lt;i&gt;S&lt;/i&gt;としては、2部グラフの圏、一般的な境界付き有向グラフの圏、タングルの圏、コボルディズムの圏などを選ぶ。有限な有向2部グラフの圏を選んだときが普通の行列になる。カテグラフは、&lt;i&gt;C&lt;/i&gt;の射であるグラフに、Vを使ってラベリングしたもの。

オートマトン（ラベル付き状態遷移系）と模倣の圏が、模倣を行列（カテグラフ）とみなして行列の圏になるはずだ。プロ関手も行列のような気がする。

*1328687128*[雑記]なごり雪

まずは元祖。

- イルカ http://www.youtube.com/watch?v=4IT_ZHGsQXw
- 伊勢正三 http://www.youtube.com/watch?v=CLuQdc7KyNE
- かぐや姫 http://www.youtube.com/watch?v=JBWYk6hYHws
- 伊勢正三＆イルカ http://www.youtube.com/watch?v=gPsc4ItkLRE

実力派。

- 鬼束ちひろ http://www.youtube.com/watch?v=bgkOYU-yhaE
- 元ちとせ http://www.youtube.com/watch?v=onfSZSTT59I
- 平原綾香 http://www.youtube.com/watch?v=kdi-MqgQvpY
- 坂本冬美　http://www.youtube.com/watch?v=rIPwxWxxKqU

昔のアイドル。

- 麻丘めぐみ http://www.youtube.com/watch?v=w_A1QatdJ5Y
- 天地真理 http://www.youtube.com/watch?v=hpXhKxIth4E
- 石川ひとみ http://www.youtube.com/watch?v=s9Y3hxj-1Ao

最近のアイドル。

- 松浦亜弥 http://www.youtube.com/watch?v=unLQEwphsno
- 初音ミク http://www.youtube.com/watch?v=2mvFaAAJxEo

アンカテゴライズ。

- X JAPAN TOSHI http://www.youtube.com/watch?v=8WzH1umRdxY
- 山崎まさよし&amp;スガシカオ http://www.youtube.com/watch?v=NAo77Ri7bsM
- 秦基博 http://www.youtube.com/watch?v=iey2se5ggOo
- 秦基博+元ちとせ http://www.youtube.com/watch?v=0NsHV4YKCfk

&lt;hr&gt;

松浦亜弥がけっこういい。

- 渡良瀬橋 http://www.youtube.com/watch?v=ZvETehSbEHg


</body>
</day>
<day date="2012-02-09" title="">
<body>
*1328753048*[説明]積集合と和集合

集合の共通部分（intersection）、記号は∩（キャップ）。

- A∩B = {x | (x∈A)∧(x∈B)}

ミート（meet）と呼ぶこともある。積集合と呼ぶこともある。共通部分の定義に使う連言（論理AND)を論理積と呼ぶことがあるので、それにあわせて「積」と言いたいこともあるし、ブール代数の演算を積（掛け算）と和（足し算）と呼ぶときも、「積」となるかもしれない。が、「積集合」って、最近はあまり聞かないな。

集合の合併（union）、記号は∪（カップ）。

- A∪B = {x | (x∈A)∨(x∈B)}

ジョイン（join）と呼ぶこともある。和集合と呼ぶこともある -- これは今でも割と使うかも。

「積集合、和集合」のペアはバランスがいいと思うが、意外に使われない。そのひとつの理由は、積には直積（direct product）の意味もあるからだろう。直積の記号は×（クロス）。

- A×B = {(x, y) | (x∈A)∧(x∈B)}

要するにペアの集合。一般化すると、長さnのタプルの集合。

集合の直和（direct sum）は、AとBの共通部分がないときの合併として定義される。記号は+（プラス）が多いが、他の記号が使われることもある。

- A+B = (A∪B ただし、A∩B = 空)

この定義は、条件付きでなんか中途半端な感じがする。「A∩B = 空」じゃなくても使える定義は：

- A+B = ({1}×A)∪({2}×B)

{1}×A と {2}×B の共通部分がないことは保証される。この定義だと A+B ⊆ {1, 2}×(A∪B) となる。

{1, 2}×(A∪B) に埋め込む定義もなんか人工的な感じがする。スッキリしたいなら、集合圏の圏論的直和の定義を採用する。（直積もそうだが）圏論的直和は具体的な作り方を捨象している。作り方を固定すると、その固定の仕方は恣意的になるので違和感がある（かもしれない）。

集合圏&lt;b&gt;Set&lt;/b&gt;の対象Uを1つ選んで固定して、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100909/1284018392&quot;&gt;オーバー圏&lt;/a&gt; &lt;b&gt;Set&lt;/b&gt;/U を考える。&lt;b&gt;Set&lt;/b&gt;/U のなかでの始対象、終対象、直積、直和を考えるのは良い練習問題。

さらに、&lt;b&gt;Set&lt;/b&gt;/U のなかのモノ射だけを選んだ部分圏 Mono(&lt;b&gt;Set&lt;/b&gt;/U) を考える。ここにも始対象、終対象、直積、直和がある。トポスの定義で出てくるサブオブジェクト Sub(U) は Mono(&lt;b&gt;Set&lt;/b&gt;/U) から構成される。f:X→U mono、g:Y→U mono に対して、同型 u:X→Y があれば f～g という同値関係を考えて：

- Sub(U) := (Mono(&lt;b&gt;Set&lt;/b&gt;/U)/～)

外側のスラッシュは商集合を作る記号。もっと正確に書けば、圏&lt;i&gt;C&lt;/i&gt;の射の集合をMor(&lt;i&gt;C&lt;/i&gt;)として、Mor(Mono(&lt;b&gt;Set&lt;/b&gt;/U))/～ 。

*1328753049*[説明]リテラル

リテラルとは、具体的なデータを直接的に表現する構文の意味だろう。Prologの「リテラル」（原子論理式またはその否定）のような全然別な意味もあるが。

普通の感覚だと、数値12や文字列&quot;hello&quot;はリテラル。最近のプログラミング言語では、タプル、リスト、マップなどのリテラルも持つ。古めの言語だと、コンストラクタや専用の関数を呼び出さないと複合データは作れないことがる -- これは不便。

JavaScriptのリテラル構文をベースにしたデータ記述言語がJSON。多くのプログラミング言語では、JSONリテラルを当該言語のリテラルに翻訳できるが、複合データ構造ではコンストラクタ／関数などに頼るケースもあるだろう。

変数参照や関数呼び出しに頼らないで書けるのがリテラルのメリットなので、変数参照や関数呼び出しを含む式（expression, term）はリテラルとは呼ばない。


</body>
</day>
<day date="2012-02-10" title="">
<body>
*1328851216*[用語法]欠けてない型

制限型（restricted type）とか部分集合型（subset type）に対して、何の制限も受けてない（絞り込み条件となる論理式がtrue）型を何と呼ぶべきか。

バルク型（bulk type）ってのはどうだろう？ ワインのバルク買いとかのイメージ。

*1328853295*[その他代数][プログラム意味論]コゥゼン代数再び

http://d.hatena.ne.jp/m-hiyama-memo/20100109/1263025526 で「Σコゥゼン σ-順序代数」てのを導入したが、あれは大事だ。すごく役に立つ。

公理が：

+ [ジョイン演算の保存]f(..., x∪y, ...) = f(..., x, ...)∪f(..., y, ...)
+ [全射性（生成性）] ∪f(1, ...,1) = 1、ただしすべてのf∈Σに関して合併をとる。fには定数記号も含まれる。
+ [分離性（排他性）] f≠g ならば、f(1, ..., 1)∩g(1, ..., 1) = 0。f, gには定数記号も含まれる。
+ [非退化性] 有限個のx&lt;sub&gt;i&lt;/sub&gt;に関して ∧(x&lt;sub&gt;i&lt;/sub&gt; ≠ 0) ならば、f(x&lt;sub&gt;&lt;/sub&gt;, ..., x&lt;sub&gt;&lt;/sub&gt;) ≠ 0

となっているが、∪や1という定数をやめて、別な定式化をしたほうが良さそうだ。

+ [単調性]すべてのfに対して、x≦y ならば f(..., x, ...) ≦ f(..., y, ...)
+ [全射性（生成性）] これは生成系の定義とする。最初からは仮定しない。
+ [分離性] f(x1, ..., xn) = g(y1, ..., ym) ならば、f=g （したがって、n = m）。かつ、xi = yi。
+ [非退化性] f(x&lt;sub&gt;&lt;/sub&gt;, ..., x&lt;sub&gt;&lt;/sub&gt;) = 0 ならば、どれかのiでx&lt;sub&gt;i&lt;/sub&gt; = 0。

≦ は台となる順序集合の順序で、0は最小元。つまり、台は最小元を持つことは仮定する。fの全体は集合Σだが、これは擬積指標と呼ぶことにする。擬積（pseudo product）とは、積に似た演算だが、ほんとに積である必要はないような演算記号。上の公理は、擬積が単調非退化な演算であり、分離性を満たすことを言っている。分離性はエルブラン性と言ってもいいだろう。

Σが無限集合、つまり無限個の擬積を持つ場合が重要だ。

&lt;b&gt;[追記]&lt;/b&gt; 

Σはユーザーが指定可能（プラッガブル）な指標だが、小文字のσのほうは構文フレームワークに作り付け。σには普遍的に使う定数と演算が含まれる。

σとΣが決まると指標が固定されるので、これで代数（指標のモデル）を考えることができるようになる。固定されたσ-Σに対するモデルの圏 Mod[σ-Σ] が出来る。Mod[σ-Σ] の対象であるσ-Σ代数Aに対して、その生成系を定義できる。Bが生成系のとき、σ-Σ, B, Var（変数集合）を使って、項（あるいは多項式）の集合 Term(σ, Σ, B, Var) を定義できる。Termにイッパイ引数があるから、これを色々と変えたり固定したりすると、面白いことができる、ってわけだ。

ここらへんはまさに、エルブランやコゥゼンがやったことだよね。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
<comments>
<comment>
<username>msakai</username>
<body>&gt; 欠けてない型&lt;br&gt;&lt;br&gt;ちょっと意味が広すぎるかもですが、base type というのは時々見ます。&lt;br&gt;例:&lt;br&gt;&lt;br&gt;Liquid Types&lt;br&gt;http://goto.ucsd.edu/~pmr/papers/liquid-types-pldi08.pdf&lt;br&gt;&lt;br&gt;CVC3のAPIのgetBaseType&lt;br&gt;http://cs.nyu.edu/acsys/cvc3/doc/classCVC3_1_1ValidityChecker.html#a5719a951194add8706db1ae0668f91ab</body>
<timestamp>1329867246</timestamp>
</comment>
<comment>
<username>m-hiyama</username>
<body>msakaiさん、&lt;br&gt;&gt; ちょっと意味が広すぎるかもですが、base type というのは時々見ます。&lt;br&gt;僕も最初 base type を考えたのですが、他で使いそう、つうか使っている事情で断念。&lt;br&gt;カットしてないケーキをホールケーキというから whole type でもいいのか？ とも思ったのですが、語感に自身がないですね。</body>
<timestamp>1329879404</timestamp>
</comment>
</comments>
</day>
<day date="2012-02-14" title="">
<body>
*1329200506*[リンク][メモ]JavaScriptの型推論

- Title: Type Inference for JavaScript
- Author: Christopher Lyon Anderson
- URL: http://pubs.doc.ic.ac.uk/chrisandersonphd/chrisandersonphd.pdf
- pages: 186ページ

これは学位論文らしい。長くて読む気がしない。

- Fast and Precise Hybrid Type Inference for JavaScript
- http://people.mozilla.org/~lmesa/ti-draft.pdf
- mozilla.org の lmesaさん（詳細不明）
- pages: 10ページ

firefoxの推論エンジンについて書かれている。Hybrid Type Inference てのは静的と動的を組み合わせること。静的な推論がけっこうイイカゲンだけど、そのほうが実用的だ、みたいな話かな？ 

- JavaScript type inference
- http://www.ccs.neu.edu/home/dimvar/jstypes.html

オンラインで試せるJavaScriptの自動型付け。精度がイマイチな気がする。



</body>
</day>
<day date="2012-02-17" title="">
<body>
*1329450940*[Caty][プログラム意味論]Catyのtyping rulesの基本

式の構成に従って型付けするが、その構成法は：

+ パイプ |と;
+ 配列構成 [,]
+ オブジェクト構成 {,}
+ タギング @
+ 変数生成 &gt;
+ 変数参照 %
+ each 
+ each --obj 単なるeachと挙動が違う
+ take
+ when分岐
+ case分岐（難しい）
+ cond分岐はやらない
+ beginブロック
+ repeat
+ call
+ forward
+ start
+ time これは単なる便利構文

型命題の原子論理式は、次。fはコマンド、A, Bは型。xは変数。Kはカインド。

+ f:: A-&gt;B
+ A⊆B
+ A≠&lt;b&gt;0&lt;/b&gt;
+ x∈A
+ A in K

アスキーで書きたいなら、A⊆B は A &amp;lt;= B、A≠&lt;b&gt;0&lt;/b&gt; は A notnever、x∈A は x &amp;lt;:  A とする。

本質的なの命題はIOプロファイルの宣言と型不等式だけ。後はテクニカルな理由で導入している。実際のtyping rulesを書き下すのは後で。

*1329463597*[Caty][プログラム意味論]Catyのtyping rulesと制約の可解性を少し

次のようなtyping rulesを設けたとする。

&lt;pre&gt;

  Γ ⇒ f:: A-&gt;B
  Γ ⇒ g:: C-&gt;D
  Γ ⇒ B⊆C
  ------------------------[パイプ]
  Γ ⇒ (f | g):: A -&gt; D


  Γ ⇒ x∈B
  Γ ⇒ f:: A-&gt; B
  ------------------------[変数生成]
  Γ ⇒ (f &gt; x) :: A-&gt; B


  Γ ⇒ x∈B
  ------------------------[変数参照]
  Γ ⇒ %x :: null -&gt; B
&lt;/pre&gt;

次の証明があるはず。イコール並べたのは証明がそこにあることを意味する。

&lt;pre&gt;
  Γ ⇒ f:: A-&gt;B
  Γ ⇒ x∈B
  Γ ⇒ g:: C-&gt;D
  Γ ⇒ B⊆C
  ===========================
  Γ ⇒ (f &gt; x | g) :: A -&gt; D
&lt;/pre&gt;

A, B, C, Dの代わりに X, Y, Z, W を未知変数とする（これは単に気分の問題）。Y⊆Z, Y≠&lt;b&gt;0&lt;/b&gt; が可解なら、型命題 (f &gt; x | g) :: X -&gt; W も可解となる。つまり、式 (f &gt; x | g) のtypabilityは、4変数 X, Y, Z, Wの制約系の可解性に翻訳され、可解性条件は Y, Z だけの制約にまで落とせる（X, W は自由に決めてよい変数）。

解集合は、集合の空間を4個直積した空間のなかの図形（領域）だが、X, W方向への射影は全射になる。Yでは&lt;b&gt;0&lt;/b&gt;だけは例外、Y, Zでは半空間みたいな感じ。

*1329464747*[その他代数][プログラム意味論]コゥゼン代数もっと

- http://d.hatena.ne.jp/m-hiyama-memo/20100109/1263025526
- http://d.hatena.ne.jp/m-hiyama-memo/20120210/1328853295

これらの続き。

いやいやいや、コゥゼン代数やっぱり非常に便利だわ。コゥゼン代数（Kozen algebra）は僕の命名で、コゥゼン自身は termset algebraと呼んでいる。実は、termset algebra を少し変形している。

まず、(0, 1; ∪, ∩, +, -; ⊆) という指標を考える。指標だけではなくて、集合束でモデル化できる順序代数の公理を入れる。記号「-」は差集合で、足し算 x + y は x∩y = 0 のときだけ x∪y を意味する部分演算。その他は標準的な解釈。この指標と計算法則（公理）は、すべての集合束からなるモデル圏で特徴付けられるとする。今、計算法則を具体的には書き下さないけど。

σは、(0, 1; ∪, ∩, +, -; ⊆) の部分指標で、公理も必要なだけ選んだものだとする。実際に使うのは、(0; ∩, +; ⊆) とか。定数、演算は減らすがモデルは変えない。また、定数0と順序関係⊆を外すことはできないとする。よって、最小のσは (0; ⊆) となる。最小のσの場合は、最小元を持つ順序集合の公理しか残らないが、それでもモデルは集合束。等号は明示してないが、常に入っていて、(x⊆y ∧ y⊆x) ⇔ x = y だとする。

今までΣと書いてきたものをΠ（パイの大文字）にする。同じシグマでは紛らわしいのと、productのpからの連想。Πはランク付きアルファベットで、Π&lt;sub&gt;0&lt;/sub&gt;, Π&lt;sub&gt;1&lt;/sub&gt;, Π&lt;sub&gt;2&lt;/sub&gt;, ... のように直和分解される。直感的には、Π&lt;sub&gt;k&lt;/sub&gt;はk引数の関数記号の集合。特にΠ&lt;sub&gt;0&lt;/sub&gt;は定数記号の集合と解釈できる。

k≧1 に対しては、Π&lt;sub&gt;k&lt;/sub&gt;に属する記号は&lt;strong&gt;k項の擬積&lt;/strong&gt;記号と呼ぶ。なぜに擬積かというと、積に似てるがちょっと違う演算だから。単調性（順序との協調性／一貫性）、分配法則、非退化性（零が吸収元）などは積と似ている。しかし、結合律、可換律、単位律（単位の存在）などはまったく成立しない（少なくともon-the-noseでは成立しない）。

法則に関して言うと：

- [単調性]すべてのfに対して、x≦y ならば f(..., x, ...) ≦ f(..., y, ...)

これは、∪や+の分配法則に替えてもよい。

-  [分離性] f(x1, ..., xn) = g(y1, ..., ym) ならば、f=g （したがって、n = m）。かつ、すべてのiで xi = yi。

これは大事。&lt;strong&gt;エルブラン性&lt;/strong&gt;と呼ぶのがよいと思う。

- [非退化性] f(x, ..., x) = 0 ⇔ どれかのiでxi = 0。

これは0が、どんな擬積に対しても吸収元となっていること。

さらに強い条件を課すこともある、つうか、現実にはずっと強い条件が必要だが、代数系としてはこのくらいの定義でいいと思う。

</body>
</day>
<day date="2012-02-18" title="">
<body>
*1329555836*[メモ]werkzeug

uWSGIの説明中に、Werkzeugってがの出てきて、何だろうと思ったので。

-  http://werkzeug.pocoo.org/

よくわからんがインストール。

&lt;pre class=&quot;out&quot;&gt;
PS C:\Users\hiyama\Work\ProjectCaty&gt; easy_install werkzeug
Searching for werkzeug
Reading http://pypi.python.org/simple/werkzeug/
Reading http://werkzeug.pocoo.org/
Reading http://trac.pocoo.org/repos/werkzeug/trunk
Best match: Werkzeug 0.8.3
Downloading http://pypi.python.org/packages/source/W/Werkzeug/Werkzeug-0.8.3.tar.gz#md5=12aa03e302ce49da98703938f257347a

Processing Werkzeug-0.8.3.tar.gz
Running Werkzeug-0.8.3\setup.py -q bdist_egg --dist-dir c:\users\hiyama\appdata\local\temp\easy_install-lucl3r\Werkzeug-
0.8.3\egg-dist-tmp-e_rvqt
warning: no files found matching '*' under directory 'werkzeug\debug\templates'
warning: no files found matching '*' under directory 'tests'
warning: no previously-included files matching '*.pyc' found under directory 'docs'
warning: no previously-included files matching '*.pyo' found under directory 'docs'
warning: no previously-included files matching '*.pyc' found under directory 'tests'
warning: no previously-included files matching '*.pyo' found under directory 'tests'
warning: no previously-included files matching '*.pyc' found under directory 'examples'
warning: no previously-included files matching '*.pyo' found under directory 'examples'
no previously-included directories found matching 'docs\_build'
Adding werkzeug 0.8.3 to easy-install.pth file

Installed c:\installed\python26\lib\site-packages\werkzeug-0.8.3-py2.6.egg
Processing dependencies for werkzeug
Finished processing dependencies for werkzeug
PS C:\Users\hiyama\Work\ProjectCaty&gt;
&lt;/pre&gt;

どこの何がインストールされたんじゃろ？ /Installed/Python26/Lib/site-packages/werkzeug-0.8.3-py2.6.egg らしい。

http://python.matrix.jp/web/werkzeug/ を見て：

&gt;|python|
# simple.py
def application(env, start_response):
  start_response('200 OK', [('ContentType', 'text/plain')])
  return 'Hello WSGI world!'

from werkzeug import run_simple
run_simple('0.0.0.0', 8000, application)
||&lt;

&lt;pre class=&quot;out&quot;&gt;
PS C:\Users\hiyama\Work\ProjectCaty&gt; python .\simple.py
 * Running on http://0.0.0.0:8080/
127.0.0.1 - - [18/Feb/2012 17:59:21] &quot;GET / HTTP/1.1&quot; 200 -
127.0.0.1 - - [18/Feb/2012 17:59:21] &quot;GET /favicon.ico HTTP/1.1&quot; 200 -
127.0.0.1 - - [18/Feb/2012 17:59:23] &quot;GET /favicon.ico HTTP/1.1&quot; 200 -
&lt;/pre&gt;

フーン。Catyのwsgirefの代わりに使えたりするかな？

</body>
</day>
<day date="2012-02-20" title="">
<body>
*1329693643*[メモ]続・werkzeug

次のコマンドラインでgithubから落とせる。

&lt;pre class=&quot;out&quot;&gt;
./msysgit/bin/git clone https://github.com/mitsuhiko/werkzeug.git
&lt;/pre&gt;

uWSGI用のCatyを少し変更したら、とりあえずwerkzeug上でCatyを動かすことはできた。

それはそうと、'werkzeug'って何語で何て読むんだ？ http://ja.forvo.com/search/werkzeug/ で聞くと「ヴェァクツォイ」に聞こえる。http://d.hatena.ne.jp/perezvon/20080404/1207335270 には「ヴェルクツォィグ」と書いてある。「ヴェルクツォイ」くらいが妥当か。

http://werkzeug.pocoo.org/docs/debug/ に
&gt;&gt;
Werkzeug provides a WSGI middleware that renders nice debugging tracebacks, optionally with an AJAX based debugger (which allows to execute code in the context of the traceback’s frames).
&lt;&lt;

と書いてある。WSGIに渡すappを次のようにラップして作ればいいらしい。

&gt;|python|
from werkzeug.debug import DebuggedApplication
from myapp import app # the WSGI application to run debugged.

app = DebuggedApplication(app, evalex=True)
||&lt;

&gt;&gt;
The evalex keyword argument allows evaluating expressions in a traceback’s frame context.
&lt;&lt;

</body>
</day>
<day date="2012-02-22" title="">
<body>
*1329882689*[プログラム意味論][形式言語理論]項と項集合

項と項集合はもちろん違うのだが、コゥゼン（Kozen）の項オートマトンと項集合オートマトンとなると、区別がちょっとわかりにくくなる。

項集合の全体はコゥゼン代数（termset algebla）となるが、項の全体はそれほどハッキリした代数構造は持たない。まー、いちおう項構成子とか項の観測子は定義できるけど。項集合代数は、項の演算の持ち上げ以外に集合演算と順序を持ち、ずっと豊かな構造となる。

項集合集合とか変な用語になるのを避けて「空間」を使うことにすると、項空間も代数構造を持つには持つが、項集合空間に入る代数構造のほうがリッチで、しかも項空間から項集合空間への（代数構造を保つ）埋め込みが存在する。

この埋め込みを系統的にやると、項オートマトンの圏は項集合オートマトンの圏に埋め込める。オートマトンに関する概念は、圏論的に定式化出来る。等式系や不等式系（制約系）との関係も圏論的に出てくると思うが、ここは具体的に計算してない。


</body>
</day>
<day date="2012-02-23" title="">
<body>
*1329952382*[プログラム意味論][形式言語理論]term, termset, termset term

+ termグラフの圏ありき。
+ termツリーはtermグラフの特別なもの。
+ termツリーはテキスト表現を持つ。
+ 「term=termツリー」か「term=termグラフ」かは文脈次第
+ termsetはtermの集合、ただしtermの普遍集合があり、その部分集合
+ term空間 = termset
+ termset空間 = termsetの集合 = (Pow(Term) の部分集合)
+ termset代数 = termset空間に代数構造を入れたもの
+ term言語 = term空間 = termset
+ termset term = termsetを表現するterm
+ termsetグラフ = termset termの図形的表現
+ termsetツリー = termsetグラフの特別なもの

さらに：

+ term = インスタンス
+ termset = 型
+ termset term = 型表現 ＝ 型のテキスト構文表現
+ termsetグラフ = 型グラフ
+ termset代数 = コゥゼン代数 = 型代数

*1329953570*[プログラム意味論][形式言語理論]コゥゼン流

デクスター・コゥゼン（Dexter Kozen）は、なんか独特の（あるいはクセのある）手法を使う。それで論文が読みにくい感じもするのだが、問題意識は今の僕にとってはピッタリだ。set constraintsとかtermset algebraとか再帰的な型を含むsubtypingとか。

コゥゼンのどことなく古めかしい語りをもうちょっと現代風に書き直せたらいいな。現代風がイイとも限らんけど、僕にとっては圏論ベースのほうがわかりやすい。

*1329986286*[Caty]IPythonからCatyを見る

なんだかんだあったば、IPython（http://ipython.org/）のなかでCatyをロードできるようになった。IPythonのインターフェースでCatyを操作できるといいんだが、とりあえず次のようなことはできる。

&lt;pre class=&quot;out&quot;&gt;
In [69]: caty.front.console.help()
Catyコンソール
Usage: python stdcaty.py console [opts]

起動オプション:
  -a, --app APP_NAME      起動時にAPP_NAMEに移動
  -s, --system-encoding   コンソール出力時の文字エンコーディング
                          デフォルト値は環境変数から取得する
                          取得出来なかった場合はutf-8が使われる
  -e, --eval SCRIPT       起動時にSCRIPTをCatyスクリプトだとして実行する
  -f, --file SCRIPT_FILE  起動時にSCRIPT_FILEを読み込み実行する
  -q, --quiet             起動メッセージを省略

In [70]: caty.front.web.help()
Catyサーバ
Usage: python stdcaty.py server [opts]

起動オプション:
  -s, --system-encoding  コンソール出力時の文字エンコーディング
                         デフォルト値は環境変数から取得する
                         取得出来なかった場合はutf-8が使われる
  -p, --port             ポート番号を指定する（デフォルト:8000）
  --hcon-port            サーバ起動と同時に指定されたポートでHTTPコンソールを起
動する(スタンドアローンでのみ有効)。オプション未指定時はHTTPコンソールなし
  --hcon-name            サーバ起動と同時に指定された名前のHTTPコンソールアプリ
ケーションを起動する(uWSGIでのみ有効)。オプション未指定時はHTTPコンソールなし


In [71]:
&lt;/pre&gt;

IPythonプロンプトから、Catyが持っている関数やメソッドを直に呼んでいる。まずは、CatyScriptの式をどうやって入力するか、だな。
</body>
</day>
<day date="2012-02-24" title="">
<body>
*1330066848*[プログラム意味論][形式言語理論]項と項集合、もっと

項空間に代数構造が入るは入るので、これを項代数と呼んでおく。項代数の演算は、項構成子（コンストラクタ）となる。項空間は余代数構造も持っていて（たいていそういうもんだ）、項の分解とか項の特性とかが余代数構造を定義する。

項集合空間はもっと代数らしい。項＝インスタンス、項集合＝型だから、項集合代数（termset algebra）は型代数と言ってもよい。型代数の演算は、「項代数演算の持ち上げ＋集合演算」だが、集合演算には次がある。

+ ∪
+ ∩
+ + （排他的なときの合併）
+ - （集合の差）
+ ~ （補集合）

もちろん、これらは独立ではない。

最近気がついたのだが、型表現という構文構造の操作（加工）から導かれる演算というのもあるみたい。Catyの型で言えば、パスにより型表現の部分表現を抜き出すとか、部分表現を置換するとかの構文的操作に対応する型演算。

オブジェクトのmergeとか配列のconcatは、項代数の演算（インスタンスの演算）の持ち上げと考えることができる。

Catyの場合、項演算じゃなくて型演算（集合演算）というのは、最終的には+（排他的合併）しかないような気がする。∩は出てくるのだが、割と早い段階で消してしまう。一般的な∪は難しいので扱わない。「型代数＝項代数に'+'演算」という事実は、物事を簡略化するのにすごく役だっている。


</body>
</day>
<day date="2012-02-27" title="">
<body>
*1330299117*[Caty][メモ][Caty更新]Catyの変更や拡張

http://d.hatena.ne.jp/m-hiyama-memo/20110623/1308807276 以降で、以前のリポジトリの最後の時期； 2011年6月から8月くらい。上のほうが古くて、下がより新しい。

+ osモジュール
+ json:fix-on-selection （下に記述）
+ json:fix-on-selection に、インライン・インクルード機能としての $embed
+ pidファイル機能
+ server status を server だけで参照可能。
+ OSシグナル SIGTERM, SIGQUITに対応。Windowsでは不十分。
+ キーボード割り込みをシグナルハンドラで対応するよう変更。Windowsでは不十分。
+ isarray, isobjectフィルターを追加
+ smarty3のfunctionを実装。
+ その他 SmartyMinEx（smarty-mx）
+ モジュールにアノテーションを付けられる。
+ chcker.casm と checker:check-files、 まだ不十分。

&lt;hr &gt;
json:fix-on-selection は次の形のセレクションを処理する。

&lt;pre class=&quot;code&quot;&gt;
type selection = {
 /** 選択の方式、必須とする */
 &quot;$selection&quot; : (&quot;array&quot;|&quot;object&quot;),

 /** 現在の値の番号または名前 */
 &quot;$current&quot; : (integer(minimum=0) | string),

 /** 値の候補 */
 &quot;$values&quot; : [any*] | {*:any?}
}
&lt;/pre&gt;

古いmainline issue #600 に、checkerに関してタグオンリーの記述がある。

&lt;pre class=&quot;code&quot;&gt;
type WebResource = {

  // meta.jsonファイルは必須
  &quot;meta.json&quot; : true,  

  // *.txtファイルはあってのなくてもよい
  &quot;*.txt&quot; : true?,

  // html/ サブディレクトリは必須
  &quot;html&quot; : {
   /* index.htmlは必須、他にHTMLファイルを好きなだけ */

    &quot;index.html&quot; : true,
    &quot;*.html&quot; : true?
  },

  // imagesサブディレクトリはあってもなくてもよい
  &quot;images&quot; : {
   /* このディレクトリ内に存在していいファイルは *.jpg, *.png, *.gif */

   &quot;*.jpg&quot; : true?,
   &quot;*.png&quot; : true?,
   &quot;*.gif&quot; : true?,

  }?,
};
&lt;/pre&gt;

上のスキーマは次のインスタンスで表現可能だ。

&lt;pre class=&quot;code&quot;&gt;
{
  // meta.jsonファイルは必須
  &quot;meta.json&quot; : @required 1,  

  // *.txtファイルはあってのなくてもよい
  &quot;*.txt&quot; : @optional 1,

  // html/ サブディレクトリは必須
  &quot;html&quot; : @required {
   /* index.htmlは必須、他にHTMLファイルを好きなだけ */

    &quot;index.html&quot; : @required 1,
    &quot;*.html&quot; : @optional 1,
  },

  // imagesサブディレクトリはあってもなくてもよい
  &quot;images&quot; : @optional {
   /* このディレクトリ内に存在していいファイルは *.jpg, *.png, *.gif */

   &quot;*.jpg&quot; : @optional 1,
   &quot;*.png&quot; : @optional 1,
   &quot;*.gif&quot; : @optional 1,

  },
}
&lt;/pre&gt;

ダミーの 1 がうるさい。タグオンリーデータならすっきり。

&lt;pre class=&quot;code&quot;&gt;
{
  // meta.jsonファイルは必須
  &quot;meta.json&quot; : @required,  

  // *.txtファイルはあってのなくてもよい
  &quot;*.txt&quot; : @optional,

  // html/ サブディレクトリは必須
  &quot;html&quot; : @required {
   /* index.htmlは必須、他にHTMLファイルを好きなだけ */

    &quot;index.html&quot; : @required,
    &quot;*.html&quot; : @optional
  },

  // imagesサブディレクトリはあってもなくてもよい
  &quot;images&quot; : @optional {
   /* このディレクトリ内に存在していいファイルは *.jpg, *.png, *.gif */

   &quot;*.jpg&quot; : @optional,
   &quot;*.png&quot; : @optional,
   &quot;*.gif&quot; : @optional,

  },
}
&lt;/pre&gt;

https://bitbucket.org/project_caty/dev/issue/373/ にも関連する記述がある。

</body>
</day>
<day date="2012-02-29" title="">
<body>
*1330491076*[Caty][メモ][Caty更新]Catyの変更や拡張

http://d.hatena.ne.jp/m-hiyama-memo/20120227/1330299117 から後の2011年の変更拡張：

+ text:verify-chars追加
+ start.logにロギング
+ _OPTS, _ARGV変数
+ dribbleファイル機能
+ smarty-mxの実装 https://bitbucket.org/project_caty/dev/issue/17/smarty-mx
+ list:tightenを実装
+ object-to-array, array-to-objectを実装
+ テンプレートで仮想プロパティをサポート
+ list:range コマンド追加
+ smarty=smarty-mx とした
+ ハイフン1個オプションを廃止
+ path:matchesコマンド、テスト不十分
+ パス式アクセスに$記法を導入（実装方式はけっこうヒドイ）
+ ハイパーリンク記述を開始 https://bitbucket.org/project_caty/dev/issue/63/
+ httpコンソール
+ viva:draw
+ gen-data -&gt; gen:sampleに変更
+ リソースのヘルプを追加
+ viva:draw-action
+ 環境変数LANGUAGEを追加。主にi18nメッセージの言語選択に使われる。
+ viva:draw-actionに --loneオプション
+ caraとcasmの統合
+ call, forwardを追加。コマンド宣言にsignals節追加
+ start{...}を追加、参考：https://bitbucket.org/project_caty/dev/issue/114/
+ sleepを追加。
+ キーボード割り込みでREPの中断、Windowsではまともに動かない。
+ gen:urlを実装
+ &amp;lt;?caty-* の出現位置の制限を先頭200文字→先頭10行に変更
+ viva:draw/draw-action に --if-modified オプション
+ vivaの描画フォーマットにsvgeを追加
+ Literate形式のモジュール
+ Wikiにignoreプラグイン
+ caraにもlit形式
+ h, hc, ht, hrをコンソールに出力するよう修正(helpはこれまで通り)
+ schemata@this, actions@this を readonly で公開する。
+ patternスキーマ属性
+ userrole宣言、ユースケースのアクター概念を入れた（最小限）
+ 不明なuserroleに疑問符
+ --node=userrole の描画
+ Catyの名前文字の日本語対応
+ file:listでschemataやactionsを見られるように
+ globalをアプリケーションとして扱えるように
+ -マークで、別にどっちでもいいよトリガー
+ globalのWebアクセス禁止(Webからは存在しない扱い)
+ lexicalキーワードをsyntax宣言で使用可能に
+ portのナンチャッテ実装
+ ポートが束縛される機構／タイミングによりポートノードの色を変える
+ 不明なノードのSVG出力時、classにunknownを追加
+ 新CSSセレクターライブラリ
+ filter:json フィルターコマンド
+ filter:javascript フィルターコマンド
+ with, withoutアノテーションを実装
+ gv:drawを実装
+ コマンドがエラーになったときに、スクリプトでの位置を同時に出力
+ setモジュールを暫定的に追加

2011年までは以上。2012年に入ってからは次の機会に。

http://d.hatena.ne.jp/m-hiyama-memo/20120227/1330299117 再掲

+ osモジュールにコマンド追加
+ json:fix-on-selection
+ json:fix-on-selection に、インライン・インクルード機能としての $embed
+ pidファイル機能
+ server status を server だけで参照可能。
+ OSシグナル SIGTERM, SIGQUITに対応。Windowsでは不十分。
+ キーボード割り込みをシグナルハンドラで対応するよう変更。Windowsでは不十分。
+ isarray, isobjectフィルターを追加
+ smarty3のfunctionを実装。
+ その他 SmartyMinEx（smarty-mx）
+ モジュールにアノテーションを付けられる。
+ chcker.casm と checker:check-files、 まだ不十分。

http://d.hatena.ne.jp/m-hiyama-memo/20110623/1308807276 再掲

+ when-otherwiseのワイルドカード
+ PATH_INFO環境変数
+ 環境変数が直接参照可能に。
+ app.logとloggingモジュールを追加。
+ osモジュール os:exec-scriptコマンドを追加。
+ rc-once/*.caty による一回実行起動時スクリプト
+ 複数候補から選択した値の解決 json:fix-on-selectionコマンド、$selection, $embed。
+ モジュール循環依存性の検出
+ 型コンパイル方式を少しずつ改善
+ make-exception, throw-if-can。throw-if-canは今バグっている。
+ pathモジュール
+ when, eachにオプションが（構文上は）可能となる。
+ gen-dataの改善、@[typical]アノテーション
+ デーモンモードでのシグナル（SIGTERM, SIGHUPなど）に対応
+ SIGHUPではリスタートする。
+ PIDファイルをちゃんと消す。
+ システム情報の公開性を少し高めた。
+ 疑似タグのプロパティ名に文字列が使える。
+ 疑似タグでundefinedが使える。

予定：

- 型の包含性判定
- データセットのサポート

http://d.hatena.ne.jp/m-hiyama-memo/20110506/1304662541 再掲。

+ 変数生成 '&gt;'
+ 変数参照 '%'
+ パイプラインの一時的終了 ';'
+ eachによる変数スコープ（つうかエクステント）
+ casmでスクリプトコマンド定義
+ kindのナンチャッテ第一段階。
+ バッグ型
+ actions/*.cara
+ 新しいスキーマ属性 maxProperties, minProperties, propNameFormat, tight。（remarkは以前から。）
+ XJSONパス、XJSON get/put、パートはまだだが。
+ ignore-tag-onceルール、pv, item, nth とXJSONパス
+ 疑似タグ構文 '@?' '(' (name|string) ':' スカラーリテラル ')'
+ 任意のタグ '@*'
+ 任意の明示的タグ '@*!'
+ 型名タグ '@&amp;' 
+ undefined型と#'undefined
+ @[register-public]
+ CatyBNFのナンチャッテ実装： ::=, :=, = が使える。
+ /*{{{, }}}*/ コメント
+ debug特殊コマンド
+ --no-ambient, --no-appオプション
+ select-action, select-script, trace-dispatchコマンド
+ スキーマ記述用のPythonファイルの分離
+ *.caraにfiletypeを書ける
+ 例外型の定義（exception宣言）
+ deferred型
+ お尻スラッシュ問題に対して、マニフェストに &quot;missingSlash&quot; 追加。
+ _global.xjsonに &quot;addrsAllowed&quot;, &quot;addrsDenied&quot;
+ スタックトレースのWebへの出力
+ throws only
+ 総称コマンドの実行時具体化
+ 国際化フレームワーク
+ フィルターのコマンド化
+ deprecatedアノテーションの処理
+ defaultアノテーションの処理
+ moduleにdocコメント
+ 配列型の項目名
+ HTTPメソッドトンネリング
+ CatyFITのjudge欄
+ ハッシュ記法
+ timeメタコマンド
+ CatyFITにignore-spaceオプション

予定：

+ __integerスキーマ属性
+ whenにotherwiseワイルドカード
+ 複数プロファイル
+ オブジェクトのeach
+ ユニオン型のワイルドカード
+ importと名前の本籍追跡
+ tag-onlyデータ
+ コマンドオーバーロード（優先度低し）
+ テンプレートの elseif

中途半端または未着手：

+ profileスキーマ属性（これはそもそも間違いだった）
+ パラメータ付きのファシリティ
+ inspect-dispatchコマンド
+ アクションサーチのfinishing
+ ファイルタイプの登録抹消
+ auto-print, gen-data 
+ 動的総称型、動的総称コマンド
+ アクションの内部プロファイル
+ インスタンスドキュメンテーション
+ 初期化の最後にコマンドラインを実行するオプション
+  疑似タグによる分岐
+ 例外マッパースクリプト
+ rootApplication 設定 
+ validate --closed 
+ untagged演算子 ^ 

</body>
</day>
<day date="2012-03-03" title="">
<body>
*1330754228*[Caty][メモ][caty-depl]配布パッケージに関する概念

OSファイルシステム、プログラミング言語のモジュールシステムを含めて、名前空間の管理が問題だな、結局。

+ リポジトリとパッケージが1:1対応すると簡単だし望ましい。が、たぶん将来的には1リポジトリで複数パッケージのサポートが必要かもしれない。（しばらくは考えないが。）
+ パッケージはプロジェクトにインストール（導入）される。
+ パッケージのインストールでプロジェクトに導入された機能性をフィーチャと呼ぶことにする。
+ パッケージとフィーチャは&lt;em&gt;1:1対応しない&lt;/em&gt;。なぜなら、Catyでは、1つのパッケージを複数のアプリケーションに導入することがあるから。
+ プロジェクト（＝サイト、サーバーインスタンス）に対する何らかの変更はモディフィケーションと呼ぶことにする。
+ インストールはモディフィケーションだが、より一般的には、フィーチャのcreate, update, deleteがある。
+ モディフィケーションIDは、「パッケージ名＋パージョン＋日時（秒まで）」とする。モディフィケーションIDのスコープはプロジェクトである。
+ ひとつのモディフィケーションで、1つのフィーチャが導入、または更新、または削除される。
+ モディフィケーションでは、パッケージの依存関係を調べる必要がある。
+ フィーチャは、もとのパッケージとモディフィケーションパラメータにより決定される。
+ モディフィケーションパラメータでもっとも重要なものはターゲットアプリケーションで、これは特別扱いしたほうがよい。
+ すべての管理されたファイルの操作（create, update, delete）は、そのモディフィケーションを追跡できなくてはならない。
+ すべてのモディフィケーションは記録されべき（完全なログ）。
+ 現在のファイル状態は維持されるべき。例： status/currentFiles.json
+ 現在のフィーチャ状態は維持されるべき。例： status/currentFeatures.json

*1330760601*[Caty][メモ][caty-depl]配布パッケージに関する概念 2

/META-INF/index.json を基点にして各種ファイルを配置すればいいだろう。

インストール先は抽象化して、プレースとして指定する。プレースの構造は：

&lt;pre class=&quot;code&quot;&gt;
type Place = {
 &quot;container&quot; : string(minlength=1),
 &quot;role&quot;      : string(minlength=1),
 @[default(&quot;tree&quot;)]
 &quot;layout&quot;    : (&quot;flat&quot; | &quot;tree&quot;),
 @[default(&quot;**&quot;)]
 &quot;allowedName&quot;: string(remark=&quot;globパターン&quot;)?,
 @[default(null)]
 &quot;forbiddenName&quot;: (null | string(remark=&quot;globパターン&quot;))?,
};
&lt;/pre&gt;

placeDef.jsonは [Place*] か、またはそれをハッシュにしたオブジェクト。キーは role@container にする。

placeDef.jsonは固定的だが、placeAssign.jsonはあるプロジェクトごとに変わる。placeAssign.jsonでは、アプリケーションプレース（特定のアプリケーション配下のプレース）以外のプレースの物理パスを決める。アプリケーション以外のコンテナは、_project と _system （増えるかもしれない）。アプリケーションごとのassignは_manifest.xjsonに書いてあるはず。

プレースの下はmafsのファイルツリーがぶら下がる。ファイルは何らかのフィーチャ（一意的）に所属し、フィーチャには一意的にモディフィケーション（オペレーションはcreate, update）が紐付く。フィーチャには元のパッケージが対応し、フィーチャの変更履歴（ログ）はパッケージごとに管理される。

&lt;b&gt;[追記]&lt;/b&gt; 
パッケージ管理系のディレクトリ構造は：

+ tools/
+ tools/caplib.py
+ tools/capman.py
+ log/{package}/
+ log/{package}/{modification}.log
+ status/
+ status/currentFiles.json
+ status/currentFeatures.json
+ meta/{package}_{ver}/
+ docs/{package}_{ver}/
+ archive/{package}_{ver}.cap.zip

&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2012-03-06" title="">
<body>
*1330996691*[Caty][メモ][caty-depl]配布パッケージに関する概念 3

パッケージ管理系に管理されたファイルの情報ってこんなもんか。

&lt;pre class=&quot;code&quot;&gt;
type FileInfo = {
 /** そのファイルが存在するプレース */
 &quot;place&quot; : string,
 /** プレース内のパス */
 &quot;path&quot; : path,
 /** ファイルサイズ */
 &quot;size&quot; : integer(minimum=0),
 /** ダイジェスト値 */
 &quot;digest&quot; : {&quot;algorithm&quot;: string, &quot;value&quot;:string},
 /** 導入された日時 */
 &quot;installedDateTime&quot; : dateTime,
};
&lt;/pre&gt;

それと、フィーチャに対するオペレーションは、create, update, delete以外に replace, patchがあるな。

</body>
</day>
<day date="2012-03-08" title="">
<body>
*1331175865*[メモ][caty-depl]DoIt

インストール記録。

- http://python-doit.sourceforge.net/index.html

$ pip install doit でよかったみたいだが、doit-0.15.0.tar.gz をダウンロードしてしまったから、これを展開して、setup.pyを実行した。

&lt;pre class=&quot;out&quot;&gt;
$ python setup.py install
c:\Installed\Python26\lib\distutils\dist.py:266: UserWarning: Unknown distribution option: 'install_requires'
  warnings.warn(msg)
running install
running build
running build_py
creating build
creating build\lib
creating build\lib\doit
copying doit\action.py -&gt; build\lib\doit
copying doit\cmdparse.py -&gt; build\lib\doit
copying doit\cmds.py -&gt; build\lib\doit
copying doit\control.py -&gt; build\lib\doit
copying doit\dependency.py -&gt; build\lib\doit
copying doit\doit_cmd.py -&gt; build\lib\doit
copying doit\exceptions.py -&gt; build\lib\doit
copying doit\filewatch.py -&gt; build\lib\doit
copying doit\loader.py -&gt; build\lib\doit
copying doit\reporter.py -&gt; build\lib\doit
copying doit\runner.py -&gt; build\lib\doit
copying doit\task.py -&gt; build\lib\doit
copying doit\tools.py -&gt; build\lib\doit
copying doit\__init__.py -&gt; build\lib\doit
running build_scripts
creating build\scripts-2.6
copying and adjusting bin\doit -&gt; build\scripts-2.6
copying bin\doit.bat -&gt; build\scripts-2.6
running install_lib
creating c:\Installed\Python26\Lib\site-packages\doit
copying build\lib\doit\action.py -&gt; c:\Installed\Python26\Lib\site-packages\doit

copying build\lib\doit\cmdparse.py -&gt; c:\Installed\Python26\Lib\site-packages\do
it
copying build\lib\doit\cmds.py -&gt; c:\Installed\Python26\Lib\site-packages\doit
copying build\lib\doit\control.py -&gt; c:\Installed\Python26\Lib\site-packages\doi
t
copying build\lib\doit\dependency.py -&gt; c:\Installed\Python26\Lib\site-packages\
doit
copying build\lib\doit\doit_cmd.py -&gt; c:\Installed\Python26\Lib\site-packages\do
it
copying build\lib\doit\exceptions.py -&gt; c:\Installed\Python26\Lib\site-packages\
doit
copying build\lib\doit\filewatch.py -&gt; c:\Installed\Python26\Lib\site-packages\d
oit
copying build\lib\doit\loader.py -&gt; c:\Installed\Python26\Lib\site-packages\doit

copying build\lib\doit\reporter.py -&gt; c:\Installed\Python26\Lib\site-packages\do
it
copying build\lib\doit\runner.py -&gt; c:\Installed\Python26\Lib\site-packages\doit

copying build\lib\doit\task.py -&gt; c:\Installed\Python26\Lib\site-packages\doit
copying build\lib\doit\tools.py -&gt; c:\Installed\Python26\Lib\site-packages\doit
copying build\lib\doit\__init__.py -&gt; c:\Installed\Python26\Lib\site-packages\do
it
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\action.py to action.
pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\cmdparse.py to cmdpa
rse.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\cmds.py to cmds.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\control.py to contro
l.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\dependency.py to dep
endency.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\doit_cmd.py to doit_
cmd.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\exceptions.py to exc
eptions.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\filewatch.py to file
watch.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\loader.py to loader.
pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\reporter.py to repor
ter.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\runner.py to runner.
pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\task.py to task.pyc
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\tools.py to tools.py
c
byte-compiling c:\Installed\Python26\Lib\site-packages\doit\__init__.py to __ini
t__.pyc
running install_scripts
copying build\scripts-2.6\doit -&gt; c:\Installed\Python26\Scripts
copying build\scripts-2.6\doit.bat -&gt; c:\Installed\Python26\Scripts
running install_egg_info
Writing c:\Installed\Python26\Lib\site-packages\doit-0.15.0-py2.6.egg-info

$
&lt;/pre&gt;

試す。

&lt;pre class=&quot;out&quot;&gt;
$ which doit
/c/Installed/Python26/Scripts/doit

$ cat dodo.py
def task_hello():
    &quot;&quot;&quot;hello from shell &amp; python! &quot;&quot;&quot;

    def python_hello(targets):
        with open(targets[0], &quot;a&quot;) as output:
            output.write(&quot;Python says Hello World!!!\n&quot;)

    return {'actions': ['echo Hello World!!! &gt; %(targets)s',
                        python_hello],
            'targets': [&quot;hello.txt&quot;]
            }

$ doit
.  hello

$
&lt;/pre&gt;

*1331177305*[Caty][メモ][caty-depl]配布パッケージに関する概念 4

やっぱりある程度は抽象化しないとダメだ。

+ 実ディレクトリツリーはファイルシステムのツリー
+ 仮想ディレクトリフォーレストは名前付きフォーレストで、成分のツリーに名前が付いている。
+ 仮想ディレクトリフォーレストのツリーを識別する名前がプレース。
+ 実ディレクトリツリーと仮想ディレクトリフォーレストの対応関係を記述するメタ情報が、assign.jsonまたはfiles.json。
+ assign.jsonは条件を記述する、files.jsonは全部列挙する。どちらか一方があれば十分。
+ 2つの仮想ディレクトリフォーレストのあいだでオペレーションができる。
+ オペレーションは、ソースとターゲットを定めた上で、create, update, delete, patch 。
+ フィーチャとは、仮想ディレクトリフォーレストの上で定義された属性を値とする部分関数といえる。
+ フィーチャを操作することができる。create, update, delete, patch は、フォーレストの形状操作と共にフィーチャも操作する。
+ フィーチャは、実ディレクトリツリーとpackage.jsonの組み合わで生成される。
+ ただ1つのフィーチャを持つ仮想ディレクトリフォーレストをパッケージと呼ぶ。
+ いくつかのフィーチャを持つ仮想ディレクトリフォーレストをプロジェクトと呼ぶ。
+ パッケージとプロジェクトの差は曖昧で、厳密に定める必要もない。
+ パッケージはリリースヒストリーを持ち、プロジェクトはインストールヒストリーを持つ。ヒストリーは何らかの事象と時刻の対のリストである。
+ プロジェクトを、パッケージをもとに操作することがモディフィケーション。

プロジェクトとパッケージをあまり区別しないことがミソかな。

フィーチャは、グラフ上のノードラベリングとも言える。ノードIDはラベル（属性）と別だとして、2つのグラフのIDを比較して形状操作をして、さらにフィーチャ＝ノードラベリングも書き換えるのがインストールとアンイストール。これに時間概念を入れて、必ず逆操作ができるようにする。時間的な記録がヒストリーまたはログ。

パッケージやプロジェクトを時間も含めた空間内に配置されたノードと考えて、時間方向の辺も考慮するのは、バージョン管理システムと同じ。

仮想ディレクトリフォーレストとかフィーチャを定義するメタデータ、アーカイブやヒストリーは、パケージ／プロジェクトとは別物と考えたほうがわかりやすい。もちろん、物理的にはメタデータもデータだが、概念的にはメタデータは天上にあると思っておく。

*1331184138*[メモ][caty-depl]nose と unittest-xml-reporting

インストールした。

&lt;pre class=&quot;out&quot;&gt;
$ easy_install -ZU nose
Searching for nose
Reading http://pypi.python.org/simple/nose/
Reading http://somethingaboutorange.com/mrl/projects/nose/
Reading http://readthedocs.org/docs/nose/
Best match: nose 1.1.2
Downloading http://pypi.python.org/packages/source/n/nose/nose-1.1.2.tar.gz#md5=
144f237b615e23f21f6a50b2183aa817
Processing nose-1.1.2.tar.gz
Running nose-1.1.2\setup.py -q bdist_egg --dist-dir c:\users\hiyama\appdata\loca
l\temp\easy_install-7doyvw\nose-1.1.2\egg-dist-tmp-hjgw1o
Adding nose 1.1.2 to easy-install.pth file
Installing nosetests-2.6-script.py script to c:\Installed\Python26\Scripts
Installing nosetests-2.6.exe script to c:\Installed\Python26\Scripts
Installing nosetests-2.6.exe.manifest script to c:\Installed\Python26\Scripts
Installing nosetests-script.py script to c:\Installed\Python26\Scripts
Installing nosetests.exe script to c:\Installed\Python26\Scripts
Installing nosetests.exe.manifest script to c:\Installed\Python26\Scripts

Installed c:\installed\python26\lib\site-packages\nose-1.1.2-py2.6.egg
Processing dependencies for nose
Finished processing dependencies for nose

$ easy_install -ZU unittest-xml-reporting
Searching for unittest-xml-reporting
Reading http://pypi.python.org/simple/unittest-xml-reporting/
Reading http://github.com/danielfm/unittest-xml-reporting/tree/master/
Best match: unittest-xml-reporting 1.3.1
Downloading http://pypi.python.org/packages/source/u/unittest-xml-reporting/unit
test-xml-reporting-1.3.1.tar.gz#md5=ddd72668d2fc4707e566b11b31b5b7a2
Processing unittest-xml-reporting-1.3.1.tar.gz
Running unittest-xml-reporting-1.3.1\setup.py -q bdist_egg --dist-dir c:\users\h
iyama\appdata\local\temp\easy_install-crmrwy\unittest-xml-reporting-1.3.1\egg-di
st-tmp-m56n0h
Adding unittest-xml-reporting 1.3.1 to easy-install.pth file

Installed c:\installed\python26\lib\site-packages\unittest_xml_reporting-1.3.1-p
y2.6.egg
Processing dependencies for unittest-xml-reporting
Finished processing dependencies for unittest-xml-reporting

$
&lt;/pre&gt;

&lt;pre class=&quot;out&quot;&gt;
$ which nosetests
/c/Installed/Python26/Scripts/nosetests.exe

$ nosetests --help
Usage: nosetests-script.py [options]

Options:
  -h, --help            show this help message and exit
  -V, --version         Output nose version and exit
  -p, --plugins         Output list of available plugins and exit. Combine
                        with higher verbosity for greater detail
  -v, --verbose         Be more verbose. [NOSE_VERBOSE]
  --verbosity=VERBOSITY
                        Set verbosity; --verbosity=2 is the same as -v
  -q, --quiet           Be less verbose
  -c FILES, --config=FILES
                        Load configuration from config file(s). May be
                        specified multiple times; in that case, all config
                        files will be loaded and combined
  -w WHERE, --where=WHERE
                        Look for tests in this directory. May be specified
                        multiple times. The first directory passed will be
                        used as the working directory, in place of the current
                        working directory, which is the default. Others will
                        be added to the list of tests to execute. [NOSE_WHERE]
  --py3where=PY3WHERE   Look for tests in this directory under Python 3.x.
                        Functions the same as 'where', but only applies if
                        running under Python 3.x or above.  Note that, if
                        present under 3.x, this option completely replaces any
                        directories specified with 'where', so the 'where'
                        option becomes ineffective. [NOSE_PY3WHERE]
  -m REGEX, --match=REGEX, --testmatch=REGEX
                        Files, directories, function names, and class names
                        that match this regular expression are considered
                        tests.  Default: (?:^|[\b_\.\-])[Tt]est
                        [NOSE_TESTMATCH]
  --tests=NAMES         Run these tests (comma-separated list). This argument
                        is useful mainly from configuration files; on the
                        command line, just pass the tests to run as additional
                        arguments with no switch.
  -l DEBUG, --debug=DEBUG
                        Activate debug logging for one or more systems.
                        Available debug loggers: nose, nose.importer,
                        nose.inspector, nose.plugins, nose.result and
                        nose.selector. Separate multiple names with a comma.
  --debug-log=FILE      Log debug messages to this file (default: sys.stderr)
  --logging-config=FILE, --log-config=FILE
                        Load logging config from this file -- bypasses all
                        other logging config settings.
  -I REGEX, --ignore-files=REGEX
                        Completely ignore any file that matches this regular
                        expression. Takes precedence over any other settings
                        or plugins. Specifying this option will replace the
                        default setting. Specify this option multiple times to
                        add more regular expressions [NOSE_IGNORE_FILES]
  -e REGEX, --exclude=REGEX
                        Don't run tests that match regular expression
                        [NOSE_EXCLUDE]
  -i REGEX, --include=REGEX
                        This regular expression will be applied to files,
                        directories, function names, and class names for a
                        chance to include additional tests that do not match
                        TESTMATCH.  Specify this option multiple times to add
                        more regular expressions [NOSE_INCLUDE]
  -x, --stop            Stop running tests after the first error or failure
  -P, --no-path-adjustment
                        Don't make any changes to sys.path when loading tests
                        [NOSE_NOPATH]
  --exe                 Look for tests in python modules that are executable.
                        Normal behavior is to exclude executable modules,
                        since they may not be import-safe [NOSE_INCLUDE_EXE]
  --noexe               DO NOT look for tests in python modules that are
                        executable. (The default on the windows platform is to
                        do so.)
  --traverse-namespace  Traverse through all path entries of a namespace
                        package
  --first-package-wins, --first-pkg-wins, --1st-pkg-wins
                        nose's importer will normally evict a package from
                        sys.modules if it sees a package with the same name in
                        a different location. Set this option to disable that
                        behavior.
  -a ATTR, --attr=ATTR  Run only tests that have attributes specified by ATTR
                        [NOSE_ATTR]
  -A EXPR, --eval-attr=EXPR
                        Run only tests for whose attributes the Python
                        expression EXPR evaluates to True [NOSE_EVAL_ATTR]
  -s, --nocapture       Don't capture stdout (any stdout output will be
                        printed immediately) [NOSE_NOCAPTURE]
  --nologcapture        Disable logging capture plugin. Logging configurtion
                        will be left intact. [NOSE_NOLOGCAPTURE]
  --logging-format=FORMAT
                        Specify custom format to print statements. Uses the
                        same format as used by standard logging handlers.
                        [NOSE_LOGFORMAT]
  --logging-datefmt=FORMAT
                        Specify custom date/time format to print statements.
                        Uses the same format as used by standard logging
                        handlers. [NOSE_LOGDATEFMT]
  --logging-filter=FILTER
                        Specify which statements to filter in/out. By default,
                        everything is captured. If the output is too verbose,
                        use this option to filter out needless output.
                        Example: filter=foo will capture statements issued
                        ONLY to  foo or foo.what.ever.sub but not foobar or
                        other logger. Specify multiple loggers with comma:
                        filter=foo,bar,baz. If any logger name is prefixed
                        with a minus, eg filter=-foo, it will be excluded
                        rather than included. Default: exclude logging
                        messages from nose itself (-nose). [NOSE_LOGFILTER]
  --logging-clear-handlers
                        Clear all other logging handlers
  --with-coverage       Enable plugin Coverage:  Activate a coverage report
                        using Ned Batchelder's coverage module.
                        [NOSE_WITH_COVERAGE]
  --cover-package=PACKAGE
                        Restrict coverage output to selected packages
                        [NOSE_COVER_PACKAGE]
  --cover-erase         Erase previously collected coverage statistics before
                        run
  --cover-tests         Include test modules in coverage report
                        [NOSE_COVER_TESTS]
  --cover-inclusive     Include all python files under working directory in
                        coverage report.  Useful for discovering holes in test
                        coverage if not all files are imported by the test
                        suite. [NOSE_COVER_INCLUSIVE]
  --cover-html          Produce HTML coverage information
  --cover-html-dir=DIR  Produce HTML coverage information in dir
  --pdb                 Drop into debugger on errors
  --pdb-failures        Drop into debugger on failures
  --no-deprecated       Disable special handling of DeprecatedTest exceptions.
  --with-doctest        Enable plugin Doctest:  Activate doctest plugin to
                        find and run doctests in non-test modules.
                        [NOSE_WITH_DOCTEST]
  --doctest-tests       Also look for doctests in test modules. Note that
                        classes, methods and functions should have either
                        doctests or non-doctest tests, not both.
                        [NOSE_DOCTEST_TESTS]
  --doctest-extension=EXT
                        Also look for doctests in files with this extension
                        [NOSE_DOCTEST_EXTENSION]
  --doctest-result-variable=VAR
                        Change the variable name set to the result of the last
                        interpreter command from the default '_'. Can be used
                        to avoid conflicts with the _() function used for text
                        translation. [NOSE_DOCTEST_RESULT_VAR]
  --doctest-fixtures=SUFFIX
                        Find fixtures for a doctest file in module with this
                        name appended to the base name of the doctest file
  --with-isolation      Enable plugin IsolationPlugin:  Activate the isolation
                        plugin to isolate changes to external modules to a
                        single test module or package. The isolation plugin
                        resets the contents of sys.modules after each test
                        module or package runs to its state before the test.
                        PLEASE NOTE that this plugin should not be used with
                        the coverage plugin, or in any other case where module
                        reloading may produce undesirable side-effects.
                        [NOSE_WITH_ISOLATION]
  -d, --detailed-errors, --failure-detail
                        Add detail to error output by attempting to evaluate
                        failed asserts [NOSE_DETAILED_ERRORS]
  --with-profile        Enable plugin Profile:  Use this plugin to run tests
                        using the hotshot profiler.   [NOSE_WITH_PROFILE]
  --profile-sort=SORT   Set sort order for profiler output
  --profile-stats-file=FILE
                        Profiler stats file; default is a new temp file on
                        each run
  --profile-restrict=RESTRICT
                        Restrict profiler output. See help for pstats.Stats
                        for details
  --no-skip             Disable special handling of SkipTest exceptions.
  --with-id             Enable plugin TestId:  Activate to add a test id (like
                        #1) to each test name output. Activate with --failed
                        to rerun failing tests only.  [NOSE_WITH_ID]
  --id-file=FILE        Store test ids found in test runs in this file.
                        Default is the file .noseids in the working directory.
  --failed              Run the tests that failed in the last test run.
  --processes=NUM       Spread test run among this many processes. Set a
                        number equal to the number of processors or cores in
                        your machine for best results. [NOSE_PROCESSES]
  --process-timeout=SECONDS
                        Set timeout for return of results from each test
                        runner process. [NOSE_PROCESS_TIMEOUT]
  --process-restartworker
                        If set, will restart each worker process once their
                        tests are done, this helps control memory leaks from
                        killing the system. [NOSE_PROCESS_RESTARTWORKER]
  --with-xunit          Enable plugin Xunit: This plugin provides test results
                        in the standard XUnit XML format. [NOSE_WITH_XUNIT]
  --xunit-file=FILE     Path to xml file to store the xunit report in. Default
                        is nosetests.xml in the working directory
                        [NOSE_XUNIT_FILE]
  --all-modules         Enable plugin AllModules: Collect tests from all
                        python modules.  [NOSE_ALL_MODULES]
  --collect-only        Enable collect-only:  Collect and output test names
                        only, don't run any tests.  [COLLECT_ONLY]

$
&lt;/pre&gt;


</body>
</day>
<day date="2012-03-09" title="">
<body>
*1331253125*[メモ][説明]100万倍

http://hozumi.github.com/2012/03/datomic-ja.html を読んで、まー「ヘーッ」って程度の感想だけど：

- RAMへのアクセスが250サイクル、ネットワークを介したアクセスが2億4千万サイクル

と書いてあった。こういう値は時代と環境で変わるけど、「100万倍のコスト」って言い方は象徴としてはいいかも。

*1331276051*[メモ][リンク]Nginxの入れ替えスクリプト

本編 http://d.hatena.ne.jp/m-hiyama/20120309/1331263930 で参照した http://webdevrefinery.com/forums/topic/8348-nginx-update-script/ にるシェルスクリプトを写しておく。

&gt;|sh|
#!/bin/sh
VERSION=0.0.1

echo &quot;&quot;
echo &quot;########################################################&quot;
echo &quot;#             nginx updater  (c) NSPwn.com             #&quot;
echo &quot;########################################################&quot;
echo &quot;# Author: GreySyntax                                   #&quot;
echo &quot;# Version: $VERSION                                    #&quot;
echo &quot;########################################################&quot;
echo &quot;&quot;

PID=`cat /var/run/nginx.pid`

echo &quot;Ensure you have ran 'make install clean' before continuing&quot;
echo &quot;Are you sure you wish to update nginx? [y/n] ($PID)&quot;
read update_ok

if [ $update_ok == &quot;y&quot; ]
then
        kill -USR2 $PID
        echo &quot;Disable old workers? [y/n]&quot;
        read disable_workers

        if [ $disable_workers == &quot;y&quot; ]
        then
                kill -WINCH $PID
                echo &quot;Kill old master [1] or restart old workers [2]?&quot;
                read master_workers

                if [ $master_workers == &quot;1&quot; ]
                then
                        echo &quot;Killing old master (this may take some time)&quot;
                        kill -QUIT $PID
                        exit 0
                else
                        echo &quot;Restarting old workers&quot;
                        PID_NEW=`cat /var/run/nginx.pid`
                        kill -HUP $PID
                        echo &quot;Shutting down new master process ($PID_NEW)&quot;
                        kill -QUIT $PID_NEW
                        kill -TERM $PID_NEW
                fi      
        else
                echo &quot;Restarting old workers&quot;
                PID_NEW=`cat /var/run/nginx.pid`
                kill -HUP $PID
                echo &quot;Shutting down new master process ($PID_NEW)&quot;
                kill -QUIT $PID_NEW
                kill -TERM $PID_NEW
        fi
else
        exit -1
fi
||&lt;

&lt;b&gt;[追記]&lt;/b&gt;

これも本編に書いたけど、最近のMakefileで次のターゲットがある。簡単。

&lt;pre class=&quot;code&quot;&gt;
upgrade:
        /usr/local/nginx/sbin/nginx -t

        kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
        sleep 1
        test -f /usr/local/nginx/logs/nginx.pid.oldbin

        kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
&lt;/pre&gt;

&lt;b&gt;[/追記]&lt;/b&gt;

*1331279598*[caty-depl]現在のサーバー環境とか

- ドメイン → http://www.dotster.com/login/ 
- 契約関係 → 会員のID/Passwordで https://secure.sakura.ad.jp/menu/
- VPSの管理 → コントロールパネルのID/Passwordで https://secure.sakura.ad.jp/vpscontrol/

ドメインは：

+ CATY-SITES.NET 11/14/2009 - 11/15/2012
+ CHIMAIRA.ORG 08/22/2003 - 08/22/2013
+ DAPHNIA.ORG 08/08/2003 - 08/09/2013
+ MICROAPPLICATIONS.NET	08/17/2005 - 08/17/2013
+ MICROAPPLICATIONS.ORG	08/17/2005 - 08/17/2013

メインのnginxは、/usr/local/nginx/ に入っていて、conf/ に設定在り。

&lt;pre class=&quot;out&quot;&gt;
[hiyama@microapplications conf]$ grep server_name nginx.conf
        server_name  www.microapplications.net;
        server_name  www.caty-sites.net;
        server_name  caty.caty-sites.net;
        server_name  chimaira.daphnia.org;
        server_name  www.commuworld.org;
        server_name www.chimaira.org;
        server_name  www.daphnia.org;
[hiyama@microapplications conf]$
&lt;/pre&gt;

commuworld.org は今は無効。ゴミだ。

www.chimaira.org と chimaira.daphnia.org は同じ場所を指していて、/home/chimaira/web_pub/ の静的リソースとなる。

catyに繋がる口が2つあって、caty.caty-sies.net が http://localhost:8000 に、www.daphnia.org:7999 が  http://localhost:8080 にリバースプロキシーしている。が、アップストリーム（バックエンド）が動いてないことが多い。

その他（http://www.daphnia.org/ とか）はnginxのダミーページ。今調べると、○はダミーページ、◎はコンテンツあり。

+ www.microapplications.net ○
+ www.caty-sites.net ○
+ caty.caty-sites.net 502 Bad Gateway
+ chimaira.daphnia.org ◎
+ www.commuworld.org ×
+ www.chimaira.org ◎
+ www.daphnia.org ○
+ http://www.daphnia.org:7999 × タイムアウト

*1331280001*[caty-depl]実験的な環境

キマイラサイトは、/usr/local/nginx/ と /home/chimaira/web_pub/ でサポートすることにして、ユーザーcatyのホーム /home/caty/ の下に別なnginxとcatyサーバーを立てて、実験に使うことにする。caty.caty-sites.net の 80, 8000, 8080 は、Catyが使うことにする。

&lt;b&gt;[追記]&lt;/b&gt;

というわけで、/home/caty/nginx/ に nginx-1.0.13 をインストールした。configureは次のようにした。

&gt;|sh|
./configure --prefix=/home/caty/nginx --user=caty --group=member \
 --with-http_realip_module \
 --with-http_ssl_module \
 --with-debug \
 --without-http_ssi_module \
 --without-http_fastcgi_module | tee myconf.log
||&lt;

&lt;pre class=&quot;out&quot;&gt;
$ ~/nginx/sbin/nginx -V
nginx version: nginx/1.0.13
TLS SNI support disabled
configure arguments: --prefix=/home/caty/nginx --user=caty --group=member --with-http_realip_module --with-http_ssl_module --with-debug --without-http_ssi_module --without-http_fastcgi_module
[caty@microapplications ~]
$
&lt;/pre&gt;

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2012-03-10" title="">
<body>
*1331348465*[caty-depl][Caty]配布パッケージに関する概念 5

プロジェクトとパッケージを区別しないほうがいいと言ったが、メタデータを持つプロジェクト＝パッケージ ということだろう。そして、再帰的な構成も可能としないといけない。

- 依存性と包含性（containment）という2つの関係を考えて、これをパッケージ間の辺と考えたグラフを想定する。このグラフは大域的なもの。
- 個々のパッケージ／プロジェクトもグラフで、色付きフォーレストになる。ノードはファイルで色はフィーチャのこと。
- 互換性、交換可能性、あるいは同値性という関係も考える。
- パッケージの同一性（アイデンティティ）として、おそらくプロダクトという概念がいる。プロダクトは、同一とみなせるパッケージの集合を意味する。パッケージ名がプロダクト名だと考えるしかないだろう。
- バージョン番号は互換性を識別すべきだが、それだけでは不十分。

色付きフォーレストをデータとするデータ操作のセットや色付きフォーレストのあいだの関係を構造として認識する。次に（同時に）、パッケージを点とする空間の構造を考える。構造は、依存性、包含性、互換性などを辺とするグラフで与えられる。

色付きフォーレストに関する操作：

+ インストール＝マージ
+ アンインストール＝一部削除
+ 抽出（部分パッケージの識別）
+ 集約（これもマージかも）
+ 色の付与、色の変更

*1331352105*[caty-depl]実験的な環境 続

iptables の設定で、tcpポートで外から使えるのは 80, 8888 だけ。実験用途は8888を使おう。今、実験用のnginxが7999をlistenしているが、外からはアクセスできない。ので、もう少しポートを開けたほうがよさそうだが、iptablesの使い方が毎度忘れる、あれはヒドイよね。もうちょっと使い勝手がどうにかならなかったかと思う＞iptables。

80番はキマイラサイトに使うので、今のところ8888しかないが、外から見える名前／ポートとアップストリームとの関係にルールがないと混乱しそう。それと、fuser -vn tcp 7999 とかでポートを使用しているプロセスはわかるが、複数のnginxがいるので、どのnginxだかワカラナイ。PIDファイルと比べればいいのだが、ファイルに書かれているのはマスタープロセスIDだけ。psの出力から親子関係をたどって、とかしないと全体のプロセス構成が読めない。

さらに、3031ポートをuWSGIが使っているが、これはnginxとの通信用。どのuWSGIプロセスがどのnginxと通信しているかも把握しないとならない。あーめんどくさいなー。たぶん、人の記憶とか注意力ではどうにもならなくなる。なんかツールが必要。

それはそうと、専用のユーザーからnginxやuwsgiを起動すると、ユーザー名がラベルとして多少は機能する。

&lt;pre class=&quot;out&quot;&gt;
$ sudo /sbin/fuser -vn tcp 3031
here: 3031

                     USER        PID ACCESS COMMAND
3031/tcp             caty      12236 f....  uwsgi
                     caty      12251 f....  uwsgi
                     caty      12252 f....  uwsgi
&lt;/pre&gt;

ユーザー名で目的用途が識別できるなら、nmap と /sbin/fuser でだいたいの事情は把握できる（今のところ、だけど）。

*1331353955*[caty-depl]pipのインストール

Pythonのインストーラーとかパッケージマネージャとか、なんだか歴史的経緯なんだろうか？ 複雑。easy_installというインストーラーをインストールしないと使えないし、pipはeasy_installでインストールしないと使えない。基本的なツールなんだから言語処理系に入れておいてくれればいいのに。

&lt;pre class=&quot;out&quot;&gt;
$ easy_install pip
Searching for pip
Reading http://pypi.python.org/simple/pip/
Reading http://pip.openplans.org
Reading http://www.pip-installer.org
Best match: pip 1.1
Downloading http://pypi.python.org/packages/source/p/pip/pip-1.1.tar.gz#md5=62a9f08dd5dc69d76734568a6c040508
Processing pip-1.1.tar.gz
Running pip-1.1/setup.py -q bdist_egg --dist-dir /tmp/easy_install-j0A9qC/pip-1.1/egg-dist-tmp-MvDQ5Y
warning: no files found matching '*.html' under directory 'docs'
warning: no previously-included files matching '*.txt' found under directory 'docs/_build'
no previously-included directories found matching 'docs/_build/_sources'
Adding pip 1.1 to easy-install.pth file
Installing pip script to /home/caty2/python2.6.4/bin
Installing pip-2.6 script to /home/caty2/python2.6.4/bin

Installed /home/caty2/python2.6.4/lib/python2.6/site-packages/pip-1.1-py2.6.egg
Processing dependencies for pip
Finished processing dependencies for pip
$
&lt;/pre&gt;

easy_installの入っているのはsetuptoolsで、最近ではdistributeで、こういうもののインストールがまた色々（apt-get, yum, ...）あって、ってあんまり幸せじゃない。

*1331368840*[caty-depl]openssl-0.9.8* のインストールとpypy

&lt;pre class=&quot;out&quot;&gt;
$ wget http://www.openssl.org/source/openssl-0.9.8t.tar.gz
$ cd ~/Work
$ tar xvzf ../DOWNLOAD/openssl-0.9.8t.tar.gz
&lt;/pre&gt;

あとは基本的に、./config shared; make; make install 。ただし、sudo make; make install ってやって失敗した。sudo make; sudo make install だな。

/usr/local/ssl/lib/libssl.so.0.9.8 がインストールされた。これはpypyで必要だとか。

&lt;pre class=&quot;out&quot;&gt;
$ pypy-1.8/bin/pypy
pypy-1.8/bin/pypy: error while loading shared libraries: libssl.so.0.9.8: cannot open shared object file: No such file or directory
$
&lt;/pre&gt;

あれ、LD_LIBRARY_PATHを指定するのか。

&lt;pre class=&quot;out&quot;&gt;
$ LD_LIBRARY_PATH=/usr/local/ssl/lib pypy-1.8/bin/pypy
pypy-1.8/bin/pypy: error while loading shared libraries: libexpat.so.1: cannot open shared object file: No such file or directory
$
&lt;/pre&gt;

今度は expatかよ。expatは普通のPythonで使ってるはずだが、、、めんどくさくなった。後にする。

&lt;pre class=&quot;out&quot;&gt;
$ ldd pypy-1.8/bin/pypy | grep not
pypy-1.8/bin/pypy: /lib/tls/libc.so.6: version `GLIBC_2.4' not found (required by pypy-1.8/bin/pypy)
        libssl.so.0.9.8 =&gt; not found
        libcrypto.so.0.9.8 =&gt; not found
        libexpat.so.1 =&gt; not found
        libbz2.so.1.0 =&gt; not found
$
&lt;/pre&gt;

つまり

+ /lib/tls/libc.so.6 がバージョン違い
+ libssl.so.0.9.8 がない（あるけど）
+ libcrypto.so.0.9.8 がない（あるけど）
+ libexpat.so.1 がない。
+ libbz2.so.1.0 がない。

&lt;pre class=&quot;out&quot;&gt;
$ sudo find /usr/lib -name 'libexpat*'
/usr/lib/libexpat.so
/usr/lib/libexpat.a
/usr/lib/libexpat.la
/usr/lib/libexpat.so.0
/usr/lib/libexpat.so.0.5.0
$ sudo find /usr/lib -name 'libbz2*'
/usr/lib/libbz2.so.1.0.2
/usr/lib/libbz2.a
/usr/lib/libbz2.so.1
/usr/lib/libbz2.so
$
&lt;/pre&gt;

確かに同じ名前のものはないな。libbz2.so.1.0 とlibbz2.so.1 は違うものなんか？


</body>
</day>
<day date="2012-03-12" title="">
<body>
*1331510099*[caty-depl]nginxのtry-filesとif, rewrite

静的ファイルをnginxに配信させるには、try-files, if, rewrite あたりが鍵だ。


</body>
</day>
<day date="2012-03-13" title="">
<body>
*1331623803*[メモ法]そのときに書け！

「あっ、わかった」と思うことがある。「なーんだ簡単じゃん、こんな事も分からなかった俺ってバカ」と感じるわけだ。「簡単なことだったのだから、一度分かってしまえば、もう自明だな」と思い込む。

これが大間違いなんだな。分かった直後は、長らく考えた末だから、そのことに関しての認識とか習熟度は上がった状態になっている。その状態だから分かって、しかも自明に見える。問題や理論が簡単なのではなくて、簡単に見える状態に&lt;em&gt;たまたま&lt;/em&gt;運良くなっている。

この状態が長く続けばいいのだけど、そうはいかない。しばらくすると、「アンレーーー、アレ？アレ？アレーー？？ 分かっていたはずなのに、自明だったはずなのに、ダメだ、全然わからん」となる。

だから、自明に見えているうちに書き留めておくべき。それが自明に見えない人のために。人といっても他人じゃなくて自分のためだが。しばらくすると、自分もそれがチットモ自明ではない人になる。


</body>
</day>
<day date="2012-03-20" title="">
<body>

</body>
</day>
<day date="2012-03-21" title="">
<body>
*1332318582*[Caty][プログラム意味論]Catyの型システムとサイト自動生成 (1)

サイトの自動生成とは何であるかを説明する前に、それを表す記号をaと決めておく。autoからa。

aは写像（関数）であり、

- a: サイトの仕様 → 実際のサイト

となる。サイトの仕様はスキーマ（Catyのcasmとcara、いずれcambも）で与えられ、実際のサイトはアクションと状態（画面、ページ）の集まりとなる。サイトのグラフ構造はハイパーリンクグラフで視覚化される。アクションのアルゴリズム部分は忘れて表示だけを考える。すると、「状態＝画面＝ページ」だけを考えることになる。画面／ページは、テンプレートで生成されるから、「実際のサイト＝テンプレートの集まり」と&lt;em&gt;単純化&lt;/em&gt;する。

サイトの仕様とは、スキーマのことだが、スキーマは型の集まりを定義する。結局、

- a: 型の集まり → テンプレートの集まり

型全体の集合をType、テンプレート全体の集合をTemplとすると（後で記号法を少し変えるが）、

- a: Type → Templ

となる。ただし、aはType全域で定義される必要はないので、&lt;em&gt;部分写像&lt;/em&gt;である。計算科学で出てくる写像（関数）はほとんどの場合は部分写像なので、いちいち&lt;em&gt;その旨を断らない&lt;/em&gt;こともあるので注意。

以下では、a: Type → Templ （部分写像）をどう定義するかを述べる。この機会に、背景もテキトーにまとめておく。

&lt;h5&gt;後から書いた注意&lt;/h5&gt;

大文字エックス（X）、小文字エックス（x）、掛け算記号（×）が区別しにくいな。文字を変えれば良かったが、直す気力が無いのでソノママ。よく注意して識別してくださいな。

指数型と配列型を同じ記号にしたのも悔やまれる。これも注意してね。

&lt;h5&gt;Catyの大域モデル圏と局所モデル構造&lt;/h5&gt;

本編の http://d.hatena.ne.jp/m-hiyama/20120302/1330676182 が事前知識。以下、一般的な背景を述べる。

大域計算モデルは圏&lt;i&gt;C&lt;/i&gt;で：

+ 圏&lt;i&gt;C&lt;/i&gt;は、掛け算「×」と足し算「+」を持つ半環圏である。
+ 圏&lt;i&gt;C&lt;/i&gt;の掛け算「×」の部分はデカルト圏となる。
+ 圏&lt;i&gt;C&lt;/i&gt;の足し算「+」の部分は余デカルト圏となる。
+ 圏&lt;i&gt;C&lt;/i&gt;はデカルト閉構造を持たない。
+ しかし、いくつかの部分閉構造を許容する。http://d.hatena.ne.jp/m-hiyama/20110115/1295075311 参照。

局所計算モデルは、特定の対象U∈|&lt;i&gt;C&lt;/i&gt;| の上に作られる。Uは普遍領域（univ）と呼ばれる。

+ &lt;i&gt;C&lt;/i&gt;の任意の対象は、U上のPER（Partial Equivalnece Relation, settoid）で表現可能である。
+ &lt;i&gt;C&lt;/i&gt;の対象Xに対して、U上のPER（の商集合）との同型が1つずつ割り当てられている。
+ 対象XのPERの同値関係がU上のイコールのとき、X（に割り当てられている同型）は&lt;strong&gt;非退化&lt;/strong&gt;と呼ぶ。
+ 非退化なXは、Uの部分集合と考えてよい。
+ 退化するX（非退化でないX）も、U→X という部分全射を持つ。この全射のセクションを&lt;strong&gt;正規形&lt;/strong&gt;と呼ぶ。正規形が定まっているのが望ましいが必須ではない。

&lt;i&gt;C&lt;/i&gt;の対象に対応するU上のPERを、&lt;strong&gt;型&lt;/strong&gt;と呼ぶ。型の全体をTypeと書く。定義より、|&lt;i&gt;C&lt;/i&gt;| はTypeに埋め込まれる。また、非退化な型だけを考えれば、Type ⊆ Pow(U) となる。圏&lt;i&gt;C&lt;/i&gt;では、対象Uに関してスノーグローブ現象が起きていることに注意。

Catyの型には、バッグ型のような退化する型もあるが、話を&lt;em&gt;単純化&lt;/em&gt;するために非退化な型だけを考えることにする。したがって、T∈Type ⇒ T⊆U 。

&lt;h5&gt;局所モデルもっと&lt;/h5&gt;

+ Uを&lt;strong&gt;普遍データ領域&lt;/strong&gt;と呼ぶ。
+ Uの要素を&lt;strong&gt;インスタンスデータ&lt;/strong&gt;と呼ぶ。単にインスタンス、単にデータとも呼ぶ。
+ Uの部分集合で型表現（type expression）で定義可能なものを&lt;strong&gt;型&lt;/strong&gt;（の集合）と呼ぶ。
+ Tが型である ⇔ T∈Type であり、Type⊆Pow(U) 。
+ &lt;strong&gt;型定数&lt;/strong&gt;は、Typeの要素、または &lt;b&gt;1&lt;/b&gt;→Type の写像のことである（どっちでも同じ）。
+ &lt;strong&gt;型関数&lt;/strong&gt;は、Type→Type、Type×Type→Type、… などの部分写像である。
+ スキーマ（の型定義部分）は、名前が付いた型の集合を定義する。つまり、Nを名前の集合として、N→Type という写像を定義する。同じ型を異なる名前で指せるので、単射とは限らない。
+ アンビエント（の型定義部分）は、いくつかのスキーマが定義する写像を寄せ集めた構造を持つ。アンビエント（の型定義部分）もまた、名前から型への写像である。

型関数（型演算）として、タプリングや排他的ユニオンなど（その他いっぱい http://d.hatena.ne.jp/m-hiyama-memo/20110510/1305003789）があるが、指数型（ベキ型、関数型）を作ることはできない。XとYの指数 X-&gt;Y は型ではなくて&lt;strong&gt;IOプロファイル&lt;/strong&gt;と呼ばれる。IOプロファイル X-&gt;Y の意味は、モデル圏&lt;i&gt;C&lt;/i&gt;のホムセット &lt;i&gt;C&lt;/i&gt;(X, Y) で、宣言 f::X-&gt;Y は、f∈&lt;i&gt;C&lt;/i&gt;(X, Y) を意味する。

&lt;h5&gt;コマンド&lt;/h5&gt;

大域モデル圏&lt;i&gt;C&lt;/i&gt;の射が&lt;strong&gt;コマンド&lt;/strong&gt;だが、コマンドはパタメータを持つので、正確に定義したかったら多圏モデルとなる。

- 多圏 本編： http://d.hatena.ne.jp/m-hiyama/searchdiary?word=%C2%BF%B7%F7
- 多圏 メモ編： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%C2%BF%B7%F7

ストレージアクセスなどの副作用を扱うには、基本モデル圏&lt;i&gt;C&lt;/i&gt;をモナド類似物で拡張しなくてはならない。多圏モデル（あるいはシーケント計算）とモナド類似拡張をどう折り合いを付けるかは、まだ完全には解決してないが、インデックス圏に対するクライスリ類似構成をすれば良さそう。

曖昧な話だから、この話題はオシマイ。

&lt;h5&gt;デカルト閉構造&lt;/h5&gt;

モデル圏&lt;i&gt;C&lt;/i&gt;はデカルト閉圏ではない。が、完全なデカルト閉圏&lt;i&gt;D&lt;/i&gt;があって、&lt;i&gt;C&lt;/i&gt;は&lt;em&gt;デカルト閉な&lt;i&gt;D&lt;/i&gt;の部分圏&lt;/em&gt;と考えることができる。ではなぜ最初から&lt;i&gt;D&lt;/i&gt;で考えないのか？ CatyScriptを高階と多相を扱える立派な言語にする気がまったくないから。

とはいえ、言語処理系の実装では、&lt;i&gt;D&lt;/i&gt;に属する概念が出てくる。デカルト閉圏&lt;i&gt;D&lt;/i&gt;を持ちださないで実装を語るのは難しい。&lt;i&gt;D&lt;/i&gt;における指数演算を [X, Y] と書く。この記法は、Catyの配列型と同じなので混乱に注意。[X-&gt;Y] とか Y&lt;sup&gt;X&lt;/sup&gt; を使うといいが、メンドクサイ。|&lt;i&gt;C&lt;/i&gt;|に関数型はないので、X, Y∈|&lt;i&gt;C&lt;/i&gt;| でも、[X, Y] は|&lt;i&gt;C&lt;/i&gt;|に入らないので、|&lt;i&gt;D&lt;/i&gt;|内でしか意味がない。

デカルト閉圏&lt;i&gt;D&lt;/i&gt;の評価射をevとする。ev&lt;sub&gt;X,Y&lt;/sub&gt;:X×[X, Y]→Y in &lt;i&gt;D&lt;/i&gt; となる。evは&lt;em&gt;ホンモノのインタプリタ&lt;/em&gt;（実行エンジン）を意味し、実装上の概念となる。指数型 [X, Y] の要素は、CatyScriptコードのコンパイル済みデータとなる。入力としてXのインスタンスを与えれば評価可能で、出力（評価結果）は型Yのインスタンスとなる。

例外や無限走行などの異常事態を表す値を⊥とする。テキスト（文字列と言っても同じ）データの型をTextとする。Catyのコマンドevalは、U×Text -&gt; U というプロファイルを持つ。evalは、Textをスクリプトコードとみなして評価するコマンド。失敗する可能性を明示的に書けば、eval : U×Text -&gt; (U | ⊥) となる。Catyの宣言構文なら（ここでは、[, ]は配列型！）、eval :: [univ, string] -&gt; univ throws Exception; （Exceptionはもっと特殊化したほうがいいけど）。

スクリプトコード（テキスト）をコンパイルする関数は（今度の[, ]は指数）、compile&lt;sub&gt;X,Y&lt;/sub&gt;: Text → ([X, Y] | ⊥) となる。コンパイルの失敗（⊥）が起きないようにするなら、ScriptText&lt;sub&gt;X,Y&lt;/sub&gt;を正しいスクリプトコードの集合として、compile&lt;sub&gt;X,Y&lt;/sub&gt;: ScriptText&lt;sub&gt;X,Y&lt;/sub&gt; → [X, Y] とすればよい。

コマンドevalを型総称化（多相化）すると（次の[, ]は配列だーー）、eval&amp;lt;X, Y&gt; :: [X, ScriptText&amp;lt;X, Y&gt;] -&gt; Y となる。この eval&amp;lt;X, Y&gt;（eval&lt;sub&gt;X,Y&lt;/sub&gt;とも書く）は、コンパイラとインタプリタを使って次のように書ける。

- eval&lt;sub&gt;X,Y&lt;/sub&gt;(x, s) := ev&lt;sub&gt;X,Y&lt;/sub&gt;(x, compile&lt;sub&gt;X,Y&lt;/sub&gt;(s))  &lt;b&gt;Compile and Go!&lt;/b&gt;

s∈ScriptText&lt;sub&gt;X,Y&lt;/sub&gt; であるかどうかの判定は、パーザー（構文解析系）と型解析系で行える。なので、compile&lt;sub&gt;X,Y&lt;/sub&gt; は、パージングと型解析が済んだ後の純粋なコード生成系とみなせる。実際の言語処理系では、s∈ScriptText&lt;sub&gt;X,Y&lt;/sub&gt; の判定とコード生成はそれほどスッキリ分離しない。

&lt;h5&gt;テンプレート言語のデカルト閉構造&lt;/h5&gt;

コンテキストの型がXであるテンプレートコードのテキストの集合を TemplText&lt;sub&gt;X&lt;/sub&gt; とする。TemplText&lt;sub&gt;X&lt;/sub&gt; もテキストの集合なので、TemplText&lt;sub&gt;X&lt;/sub&gt;⊆Text 。

テンプレート展開を行うコマンドを expand として、型総称化して expand&amp;lt;X&gt; または expand&lt;sub&gt;X&lt;/sub&gt; と書くことにする。

- expand&lt;sub&gt;X&lt;/sub&gt; : X×TemplText&lt;sub&gt;X&lt;/sub&gt; → Text

expandコマンドのエンジンとして、evalのエンジンであるevを使うことにする。compile&lt;sub&gt;X,Y&lt;/sub&gt;: ScriptText&lt;sub&gt;X,Y&lt;/sub&gt; → [X, Y] と同様に考えて、

- templcompile&lt;sub&gt;X&lt;/sub&gt;: TemplText&lt;sub&gt;X&lt;/sub&gt; → [X, Text] 

となる。よって、expandの定義は、

- expand&lt;sub&gt;X&lt;/sub&gt;(x, t) := ev&lt;sub&gt;X,Text&lt;/sub&gt;(x, templcompile&lt;sub&gt;X&lt;/sub&gt;(t))

t∈TemplText&lt;sub&gt;X&lt;/sub&gt; の判定は、テンプレートパーザーと型解析系が行う。

templcompile&lt;sub&gt;X&lt;/sub&gt;は、[X, Text] を直接吐くが、TemplText&lt;sub&gt;X&lt;/sub&gt; → ScriptText&lt;sub&gt;X,Text&lt;/sub&gt; のテキストレベル・トランスレータを準備してもよい。このときは、

- templcompile&lt;sub&gt;X&lt;/sub&gt;(t) := compile&lt;sub&gt;X,Text&lt;/sub&gt;(translate&lt;sub&gt;X&lt;/sub&gt;(t))

となる。

いずれの方法でも、構文処理だけを準備すれば、型解析と実行はスクリプトとテンプレートで共通のモノを使える。


続きは (2)。

*1332318647*[Caty][プログラム意味論]Catyの型システムとサイト自動生成 (2)

いよいよサイト自動生成の話。

サイトを構成するページの作成をデザイナに依頼することを想定する。静的ページはコンテキストがvoidのテンプレートと考えられるので、すべてのページをテンプレートと考えてよい。

デザイナは、作成するテンプレート（静的ページ含む）の仕様を渡されて作業をする。仕様にはコンテキスト型の記述が含まれるが、コンテキスト型とテンプレートが1:1対応しているわけではない。ハイパーリンクグラフのabstractではない状態ノードとテンプレートが1:1対応する。

- 具体状態ノード ←→ テンプレート （1：1対応）

具体状態ノードは、型とリンク記述からなる。

- 具体状態ノード ＝ (型 + リンク記述)

リンク記述まで含めた型概念を&lt;strong&gt;ハイパー型&lt;/strong&gt;と呼び、それに対する&lt;strong&gt;ハイパースキーマ&lt;/strong&gt;と&lt;strong&gt;ハイパーバリデーション&lt;/strong&gt;の概念があるのだが、完全な定式化ができてないので、具体的状態ノードの型（ハイパーリンクは省略）を中心に話をする。（たぶん、ハイパー型とはハイパーリンクグラフの仕様となるだろう。）

&lt;h5&gt;状態ノードと型とテンプレート&lt;/h5&gt;

S, Tなどは型として、状態ノードを α::S、β::T などと書く。α、βなどはノードの名前（ラベル）である。α≠β（名前が違う）とき、α::T と β::T は別なノードとなる。状態ノードの型は、その状態（画面、ページ）を生成するテンプレートのコンテキスト型と考えてよい（正確に言えばちょっと違うが）。

同じ型Tを持つ2つの状態 α::T と β::T に異なるテンプレートが必要となるのは、αとβのサイト内での役割／用途／文脈などが違うためである（それゆえに違うラベルを与えている）。その違いを示すために異なるデザインにするかも知れない。しかし、これは知的な話なので、非知的な自動生成では、型とテンプレートを対応付けてしまう。α::T と β::T のテンプレートは、内容は同じで名前だけが違うモノとなる。

以上の&lt;em&gt;単純化&lt;/em&gt;により、テンプレート作成作業とは：

- 与えられた型（状態の型＝コンテキスト型）1つに対して、1つのテンプレート（静的ページを含む）を作る。
- 一般にN個の型（N≧1）が与えられるので、テンプレートもN個となる。
- サブテンプレートやテンプレート関数も含めると、N個とは限らないが、これは単に数え方の違いに過ぎない。アクションから直接呼ばれるトップレベルテンプレートはN個である。

&lt;h5&gt;型からのテンプレート生成&lt;/h5&gt;

Ψ、Φなどのギリシャ大文字は&lt;em&gt;型の有限集合&lt;/em&gt;を表すことにする。ギリシャ大文字を使った理由は、型やインスタンスと区別するためである。型の有限集合が「スキーマ＝仕様」に対応する。T∈Ψ に対して、Tに対応するテンプレートを a(T) とする。aがデザイナによる作業を表す。作業aを人間ではなくて、プログラムにautoでやらせるのが目標。

コンテキスト型がTであるテンプレートテキストの全体を TemplText&lt;sub&gt;T&lt;/sub&gt;、または TemplText&amp;lt;T&gt; と書くことにする、T=void ならば静的ページを意味する。。多相型 ∀X.TemplText&amp;lt;X&gt; = forall&amp;lt;X&gt;TemplText&amp;lt;X&gt; を、ワイルドカードを使って TemplText&lt;sub&gt;*&lt;/sub&gt;、または TemplText&amp;lt;*&gt; とも書く。

テンプレートを生成する作業は、a:Type→TemplText&amp;lt;*&gt; という写像となる。次の条件を満たす必要がある。

- a(T)∈TemplText&amp;lt;T&gt;

これは、「型Tに対するテンプレートのコンテキスト型はTであるべき」という当たり前の条件。この条件を&lt;strong&gt;コンテキスト条件&lt;/strong&gt;と呼ぶことにする。

テンプレート展開のevalであるexpandを使うと、f(t) := expand(t, a(T)) として、写像 T→Text を定義できるので、a(T) は指数型 [T, Text]に入ると思ってもよい。つまり、aは、(Type → [*, Text]) という写像とも解釈できる。ただし、aがType全域で定義されいるとは限らないので、部分写像と考える。

一般に、コンテキスト条件を満たす Type→TemplText&lt;sub&gt;*&lt;/sub&gt; という写像は「型からテンプレートを生成する操作」なので、サイト自動生成に使える。ただし、与えられた仕様（型の有限集合）とマッチしなくてはならない。

- 部分写像 a:Type→TemplText&lt;sub&gt;*&lt;/sub&gt; がΨ（Ψ⊆Type)と&lt;strong&gt;適合する&lt;/strong&gt;とは、Ψ⊆(aの定義域) のこと。

&lt;h5&gt;レイフィケーション&lt;/h5&gt;

Typeは普遍データ領域Uの外側にある。Type→U という埋め込みを&lt;strong&gt;型レイフィケーション&lt;/strong&gt;と呼ぶ。型レイフィケーションも全域でなくて（部分レイフィケーションで）もよいし、いくつかのレイフィケーションがあってもよい。なにか標準的なレイフィケーションを1つ選んで、それをReiとする。Rei:Type→U （埋め込み写像）。

a:Type→TemplText&lt;sub&gt;*&lt;/sub&gt; に対して、次の性質を満たすa'を考える。

- T∈Type に対して、a'(Rei(T)) = a(T) が（両辺が定義されるなら）成立する

a'は、Uの外に存在するaをU内に落としたもの。a' は U→TemplText&lt;sub&gt;*&lt;/sub&gt; だが、TemplText&lt;sub&gt;*&lt;/sub&gt;⊆Text なので、a':U→Text という部分写像と考えてよい。a'は次の性質を持つ。

+ Uの適当な部分集合上で定義されている。
+ 値はテキストである。

つまり、&lt;em&gt;なんてことないコマンド&lt;/em&gt;である。a'をメタレベルで解釈しなおすと、a:Type→TemplText&lt;sub&gt;*&lt;/sub&gt; という高階写像となる。

&lt;h5&gt;高階テンプレートとレイフィケーション&lt;/h5&gt;

型からテンプレートを生成する機能であるaを定義する際に、再びテンプレート技術を使うことができる。このとき使うテンプレートは、次の意味で高階である。

- コンテキスト（入力）がTypeの要素なので、高階の対象を入力とする。
- 結果（出力）が、指数型 [T, Text]とみなせるので、出力も高階の対象である。

「高階の対象」という言葉を使ったが、入力は「集合（型）の集合」、出力は関数型（指数型）である。レイフィケーションを使うことにより、aをa'に落とせる。a'を定義するテンプレートでは：

- コンテキスト（入力）はUの要素なので、単なるデータである。（意味は高階の対象だが。）
- 結果（出力）はTextなので、単なるテキストデータである。（テンプレートテキストである必要があるが。）

「集合の集合」に「関数」を対応させる、という高階の写像aも、レイフィケーションを通じて、単なるテンプレートa'で実現できる。実際のサイト自動生成では、静的ページやフォームの自動生成が難しい。情報表示用のテンプレート（サーバーサイドJSONView）は&lt;em&gt;実は簡単&lt;/em&gt;。特に、(型→フォーム) という生成写像は&lt;strong&gt;auto-form&lt;/strong&gt;と呼ぶ。高階テンプレートの一番の用途はauto-formの実現である。

&lt;h5&gt;クォーティングによる高階テンプレートの実現&lt;/h5&gt;

テンプレートテキストが単なるテキスト以上のものとなる根拠は、区切り記号とそれによるブロック構造である（http://d.hatena.ne.jp/m-hiyama/20070125/1169702291）。異なる区切り記号を持つ2つのテンプレート言語は、互いに他のメタテンプレート言語として使用できる。

もっと簡単な方法は、区切り記号のクォーティングまたはエスケープである。クォートされた区切り記号は、その評価が1回遅れる（何回でも遅らせることができるが）。この機能（クォーティングだけ）で高階テンプレート機能を実現できる。

例を示す。

次が実行時のテンプレート変数（コンテキスト）。

+ title
+ date
+ content

生成時のテンプレート変数（メタコンテキスト）。

+ siteTitle
+ encoding

&gt;|html|
&lt;?caty-meta template=&quot;smarty-mx&quot; ?&gt;&lt;&lt;?caty-meta template=&quot;smarty-mx&quot; ?&gt;&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv='Content-Type' content='text/html; charset={$encoding}' /&gt;
    &lt;title&gt;{$siteTitle} - {{$title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;{$siteTitle}&lt;/h1&gt;
     &lt;h2&gt;{{$title}} : {{$date}}&lt;/h2&gt;
     {{$content|noescape}}
  &lt;/body&gt;
&lt;/html&gt;
||&lt;

展開を1回した後。

&gt;|html|
&lt;?caty-meta template=&quot;smarty-mx&quot; ?&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8' /&gt;
    &lt;title&gt;キマイラ飼育記 - {$title}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;キマイラ飼育記&lt;/h1&gt;
     &lt;h2&gt;{$title} : {$date}&lt;/h2&gt;
     {$content|noescape}
  &lt;/body&gt;
&lt;/html&gt;
||&lt;

さらに展開。

&gt;|html|
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8' /&gt;
    &lt;title&gt;キマイラ飼育記 - 最近思うこと&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;キマイラ飼育記&lt;/h1&gt;
     &lt;h2&gt;最近思うこと : 2012-04-01&lt;/h2&gt;
     &lt;p&gt;最近思うのだが ...&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
||&lt;

</body>
</day>
<day date="2012-03-23" title="">
<body>
*1332480680*[Caty][モナド][課題]undef-safeが難しい

undef-safeなブロックというのを考えていた。Undef例外とundef値を統合して透過的かつ安全に使える構文。だが難しかった。

考えてみたら、クライスリ圏のあいだの関手を構成する問題。実際に問題の関手を構成すると、適当なdomain（領域理論のdomain）のstrictな射の圏が関手の域圏になる。この域圏の判断は難しい、つうか現状できない。ようするにできないからできない、という結論だった。

あるコマンドがstrictな射かどうかは、まず自己申告してもらって、念のためチェックするか。純射ならチェックできない話ではない。不純射ではどうにもならないので、自己申告を信じるしかない。


</body>
</day>
<day date="2012-03-27" title="">
<body>
*1332830239*[caty-depl][メモ]なんかいろいろインストールした

SLOCCountを苦労してインストールしたが（http://d.hatena.ne.jp/m-hiyama/20120326/1332722359）、他にもいくつか。

Pythonのコーディングルールをチェックするpep8。

&lt;pre class=&quot;out&quot;&gt;
$ pip install pep8
Downloading/unpacking pep8
  Downloading pep8-0.6.1.tar.gz
  Running setup.py egg_info for package pep8
Requirement already satisfied (use --upgrade to upgrade): setuptools in c:\insta
lled\python26\lib\site-packages (from pep8)
Installing collected packages: pep8
  Running setup.py install for pep8
    Installing pep8-script.py script to c:\Installed\Python26\Scripts
    Installing pep8.exe script to c:\Installed\Python26\Scripts
    Installing pep8.exe.manifest script to c:\Installed\Python26\Scripts
Successfully installed pep8
Cleaning up...

hiyama@TP-X200-HIYAMA ~
$
&lt;/pre&gt;

クローンディガー。

&lt;pre class=&quot;out&quot;&gt;
$ easy_install -UZ clonedigger
Searching for clonedigger
Reading http://pypi.python.org/simple/clonedigger/
Reading http://clonedigger.sourceforge.net
Best match: clonedigger 1.1.0
Downloading http://pypi.python.org/packages/source/c/clonedigger/clonedigger-1.1
.0.tar.gz#md5=0bf30b2de988f15d4dd57fd78e1e302f
Processing clonedigger-1.1.0.tar.gz
Running clonedigger-1.1.0\setup.py -q bdist_egg --dist-dir c:\users\hiyama\appda
ta\local\temp\easy_install-eyisql\clonedigger-1.1.0\egg-dist-tmp-qlp2vb
warning: no files found matching 'HISTORY.txt'
warning: no files found matching 'CONTRIBUTORS.txt'
warning: no files found matching 'LICENSE'
Adding clonedigger 1.1.0 to easy-install.pth file
Installing clonedigger-script.py script to c:\Installed\Python26\Scripts
Installing clonedigger.exe script to c:\Installed\Python26\Scripts
Installing clonedigger.exe.manifest script to c:\Installed\Python26\Scripts

Installed c:\installed\python26\lib\site-packages\clonedigger-1.1.0-py2.6.egg
Processing dependencies for clonedigger
Finished processing dependencies for clonedigger

$
&lt;/pre&gt;

noseのプラグインであるRednose。noseはだいぶ前に入れた。

&lt;pre class=&quot;out&quot;&gt;
$ easy_install rednose
Searching for rednose
Reading http://pypi.python.org/simple/rednose/
Reading http://github.com/gfxmonk/rednose/tree
Reading http://gfxmonk.net/dist/0install/rednose.xml
Best match: rednose 0.3
Downloading http://pypi.python.org/packages/source/r/rednose/rednose-0.3.tar.gz#
md5=1d85c2c02236b983805e25f0cabf5848
Processing rednose-0.3.tar.gz
Running rednose-0.3\setup.py -q bdist_egg --dist-dir c:\users\hiyama\appdata\loc
al\temp\easy_install-8udjom\rednose-0.3\egg-dist-tmp-xtnuv6
zip_safe flag not set; analyzing archive contents...
Adding rednose 0.3 to easy-install.pth file

Installed c:\installed\python26\lib\site-packages\rednose-0.3-py2.6.egg
Processing dependencies for rednose
Searching for python-termstyle&gt;=0.1.7
Reading http://pypi.python.org/simple/python-termstyle/
Reading http://gfxmonk.net/dist/0install/python-termstyle.xml
Best match: python-termstyle 0.1.9
Downloading http://pypi.python.org/packages/source/p/python-termstyle/python-ter
mstyle-0.1.9.tar.gz#md5=25a0015fe06a33579d53690edd22ab89
Processing python-termstyle-0.1.9.tar.gz
Running python-termstyle-0.1.9\setup.py -q bdist_egg --dist-dir c:\users\hiyama\
appdata\local\temp\easy_install-az36nz\python-termstyle-0.1.9\egg-dist-tmp-ybwlo
f
zip_safe flag not set; analyzing archive contents...
Adding python-termstyle 0.1.9 to easy-install.pth file

Installed c:\installed\python26\lib\site-packages\python_termstyle-0.1.9-py2.6.e
gg
Finished processing dependencies for rednose

hiyama@TP-X200-HIYAMA ~/ProjectCaty/dev/python
$
&lt;/pre&gt;


</body>
</day>
<day date="2012-03-28" title="">
<body>
*1332922218*[課題][メモ法] TO-THINK

[課題]ってカテゴリータグがある。

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%2A%5B%B2%DD%C2%EA%5D

これをもう少しキチンと管理したほうがいいな。

課題は折に触れて考えなおすべきこと。いくつかの課題はすぐに思い出せるようにしておこう。ちょっと空いた時間にも考えられるように。

</body>
</day>
<day date="2012-03-29" title="">
<body>
*1332991692*[メモ][msched] issueの終り方

resolvedで終わるとは限らない。

- もう情報が古くてもう意味がなくなっている。
- なんかの告知／周知のためだったが、十分に役割を果たした。
- より新しいもので置き換えられたが、リンクを残す。

とか。

*1333012983*[メモ]借りてるサーバー

いちおう仮想4コアだったのか。uWSGIの効果は出るはずだな。


</body>
</day>
<day date="2012-03-31" title="">
<body>
*1333187467*[課題][マンダラ]ORelは追求する価値がある

http://d.hatena.ne.jp/m-hiyama/20111212/1323649258 で書いたORelだが、あれは有望な気がする。面白い気がする。きっと役立つに違いない。

順序集合が V=真偽値 と置いたV豊饒圏なので、Vを別な順序集合（例えばダイヤモンド4値とか）に変えると別な構造が得られる。AとBが順序集合V上のV豊饒圏なら、V順序集合と言ってもいいだろう。2つのV順序集合A、Bの片一方を逆にしたペアリング A&lt;sup&gt;op&lt;/sup&gt;×B 上のV順序構造が、&lt;em&gt;少しだけ一般化したORel&lt;/em&gt;となる。Vで豊饒化したORelをV-ORelとして、V-ORelの計算を行列計算だとみなすこと、合理的にみなすことが当面の課題。

行列は、完全二部グラフ上に、自明な半環圏とみなした半環の係数をくっつけたものになる。足し算のほうは総和（summation）に一般化出来る。同様に、高次完全ニ部グラフ上に、自明な2-圏係数をくっつけたものがV-ORelの射となると思われる。

高次完全ニ部グラフを高次（つっても2次元）複体に拡張して、域と余域は境界と考えたコボルディズム圏と考えたい。マンダラと関係しそうな気がする。

*1333188033*[課題][マンダラ][Caty]リスコフ順序とORel

ORelやV-ORelには、当面少なくとも1つは実務的な応用がある。Catyのモジュールやクラス（OOPのクラスとは若干違う）のあいだには、リスコフ置換可能性からリスコフ順序と呼ぶべき順序が入る。そのもとになるのは、コマンド＝射のプロファイルあいだのリスコフ順序というかconformance順序。

この順序に関しては、ORelの構造があるように思える。つうか、もともとの動機はココだった。が、プロファイルの世界がORelだとしても、それだけではうれしくない。どうしたらうれしくなるか？ それも課題。


</body>
</day>
<day date="2012-04-02" title="">
<body>
*1333323906*[プログラム意味論][Caty]トランザクション

トランザクションはモナドではないな。まー、モナド関係するけど。

操作命令の発行過程がフラグ付きツリー状データのモナドになる。それを入れ子リストにしてさらに単なるリストにするモナド準同型がトランザクション処理。リストモナドは非可換多元環に相当して、その上の加群がストレージ。


</body>
</day>
<day date="2012-04-07" title="">
<body>
*1333788290*[メモ]NetworkX（主にDiGraph）の使い方

+ import networkx as nx していることを仮定する。
+ import matplotlib.pylab as plt も仮定する。pylabなので、as pylab が良かったか？
+ pydotとPyYAMLは不要だから入れてない。
+ A node can be any hashable Python object except None. たいてい何でも使える。
+ nbunchはNetworkX特有の概念で、頂点集合の表現。とりあえず、リストと思ってもいい。&lt;br&gt;An nbunch is any iterable container of nodes
+ ebunchも同様。An iteratable container of edge tuples

&lt;hr&gt;

+ DiGraphが有向グラフで、ループを認める。が、多重辺は認めてないので、多重辺が必要ならMultiDiGraphを使う。辺に属性（例えば多重度）が付けられるので、たいていはDiGraphで間に合いそうだ。
+ 辺に付けられた数値を重さ（weight）と呼ぶ。辺重さ付きのグラフが「ネットワーク」の定義。最短経路問題などはネットワークに対して定式化される。
+ 初期化データはいろいろ使える。
++ edge list
++ NetworkX graph 
++ NumPy matrix
++ NumPy 2d ndarray
++ SciPy sparse matrix
++ PyGraphviz AGraph
+ edge listは、辺を表現するタプルのリスト。
+ やってみたら、DiGraph({1:[2,3], 2:[3, 4]}) もOKだった。
+ 属性付きの辺は、(u, v, dict) というタプルで、dictは辞書。
+ グラフ全体、頂点、辺のそれぞれに属性を付けられる。数値属性のどれかを（必要に応じて）weightと呼ぶ。
+ G.graph でグラフ属性にアクセスできる。
+ G.node[1] などで頂点属性にアクセスできる。
+ G[1][2]、G.edge[1] とかで辺属性にアクセスできる。
+ G[1]は辺属性の辞書。
+ グラフ描画は、nx.draw(G); plt.show()

&lt;hr&gt;

+ 有向グラフを逆転したいなら、reverse()
+ コピー（クローン）は copy()
+ 無向グラフとしてコピーなら、to_undirected()。to_undirected(reciprocal=True)とすると、両方向有向辺（辺の対）が無向辺になる。
+ コンストラクタ G=DiGraph(D) はシャローコピー。to_undirectedはディープコピー。
+ 頂点の入次数を知りたいなら、in_degree(nbunch) で取れる。nbunchが単一頂点なら数値、頂点集合なら辞書。
+ in_degreeは辞書を返すが、イテレータを返す in_degree_iterってのもある。
+ out_degreeも同じ。

&lt;hr&gt;

+ order() がノード数
+ number_of_nodes() でも同じ。
+ len(G) でもノード数
+ size() が辺数
+ number_of_edges() でも同じ。
+ self loopの情報が詳しく取れる。
++ nodes_with_selfloops()
++ selfloop_edges()
++ number_os_selfloops()
+ 頂点集合から誘導されるサブグラフは、subgraph(nbunch)で作れる。

*1333791703*[メモ]NetworkX（主にDiGraph）の使い方 (2)

+ 孤立頂点も表現できるので、初期化には辞書形式がいいみたい； nx.DiGraph({'a':['c', 'd'], 'b':[], 'c':['a'], 'e':[]})、bとeは孤立している。JSONで言うプロパティが、各頂点ごとのスターを表現している。孤立頂点以外は明示的に [] を書かなくてもいい。
+ 上記の形式は、dict_of_listsと呼ぶ。変換はメソッドじゃなくて、nx.to_dict_of_lists関数。nx.to_dict_of_lists関数に頂点集合を指定して誘導サブグラフを取ることもできる。
+ 辺の属性をエンコードしたいときは、dict_of_dicts関数。
+ nx.to_edgelist だと孤立頂点は取れない。辺属性は取れる。
+ G.graphで取れるグラフ属性、G.node[x] で取れる頂点属性がエンコードできない。
+ Catyのgvモジュールのデータ型を使えばOKだ。dict_of_lists形式。dict_of_dicts形式もなんとかなるか？
+ JSONとのIOは、from networkx.readwrite import json_graph as jg とかする。
+ jg.node_link_data(G) でJSONデータ。
+ jg.node_link_graph(d) でその逆。だが、なんか制約があるようだ。
+ jg.adjacency_data(G), jg.adjacency_graph(d) も同様。
+ ツリーなら、jg.tree_data(G, root)、jg.tree_graph(d)。
+ 行列への変換では、nx.adjacency_matrix、nx.incidence_matrix も使える。
+ グラフの形状をイミュータブルにするには、nx.freeze(G) を使う。


</body>
</day>
<day date="2012-04-11" title="">
<body>
*1334101519*[メモ]渋谷と恵比寿に行った

渋谷のフランフランという雑貨家具屋はなぜか小型掃除機が多い。小型掃除機を買いに行くならいいかも。

恵比寿の「さぼてん」の照り焼きチーズミルフィーユかつサンドがうまい。エビかつサンドもうまいが、チーズミルフィーユがオススメ。


</body>
</day>
<day date="2012-04-19" title="">
<body>
*1334790476*[課題]実験的観測、ネロード同値、ホーアトリプル、ソフトウェアテスティングの基礎理論

実験的観測による値を記録することと、それらの実験的観測値を比較することがソフトウェアテスティングで使える基本手段。

メイヤーオートマトンにおけるネロード同値を主張する命題はホーアトリプルで書けるだろう。

</body>
</day>
<day date="2012-04-21" title="">
<body>
*1334999175*[メモ]Perlのone liner

Perlはめったに使わないが、

&lt;pre class=&quot;out&quot;&gt;
perl -n -e 'if (/\.([^.\/]+)\/?$/) {print $1}'
&lt;/pre&gt;

'print $1 if (/\.([^.\/]+)\/?$/)' と書いたほうがソレらしいのか？

使う場面：

&lt;pre class=&quot;out&quot;&gt;
find . | perl -n -e 'if (/\.([^.\/]+)\/?$/) {print $1}' | sort | uniq -c
&lt;/pre&gt;


</body>
</day>
<day date="2012-04-25" title="">
<body>
*1335343743*[メモ]「東京」

BEGINがカバーしてリリー・フランキー原作の『東京タワー～オカンとボクと、時々、オトン～』の主題歌に。

- 「東京」 (昭和49年）
- 森 田 貢/作詞・作曲
- マイペース/歌

歌詞とオルゴールみたいなカラオケは、http://www.fukuchan.ac/music/j-folk3/tokyo.html 。

以前は、http://www.shinseido.co.jp/cgi-bin/WebObjects/Catalog.woa/wa/detail?r=VICL-18127 の 1-1 でボーカル付きで少し聞けたけど、今はないみたい。それにしても、これは悪いURLの典型みたいな。

- http://www.youtube.com/watch?v=VGShuXbcpHQ オジサンになったマイペースによる「東京」
- http://www.youtube.com/watch?v=BJLoWABmcE8 ジャケットと歌

あり、もう削除されている。

検索しなおし：

- http://www.youtube.com/watch?v=1P39OLmmpaE BEGIN版
- http://www.youtube.com/watch?v=grbKGjBvaRo マイペース版
- http://www.youtube.com/watch?v=xsrydjzGhes これはオジサン版？ なんか雰囲気が違う。
- http://www.youtube.com/watch?v=01QTqWYrQDc 紅白歌合戦のとき
- http://www.youtube.com/watch?v=-kotHbW3aqI 2010年、なんか音を気にしている？
- http://www.youtube.com/watch?v=kov30gCpgFU 大震災のとき


</body>
</day>
<day date="2012-04-27" title="">
<body>
*1335505498*[メモ]よい／悪い

http://tabesugi.net/memo/cur/cur.html#251845 より引用：

&gt;&gt;
- よいコードとは → 実行する前にそれを読んで、何をするものであるか (かなり) わかるもの。
- 悪いコードとは → 実行した後にそれを読んでも、何をするものであるかサッパリわからないもの。 
&lt;&lt;

素晴らしいお言葉。

*1335516608*[リンク][TQFT] Segalの講義録

以前もURLを貼ったが：

- http://www.cgtp.duke.edu/ITP99/segal/stanford/lect1.pdf
- http://www.cgtp.duke.edu/ITP99/segal/stanford/lect2.pdf
- http://www.cgtp.duke.edu/ITP99/segal/stanford/lect3.pdf
- http://www.cgtp.duke.edu/ITP99/segal/stanford/lect5.pdf

</body>
</day>
<day date="2012-05-05" title="">
<body>
*1336172779*[Caty][プログラム意味論]HTTP上のRPCの方法

連休のあいだもCatyの手直しをしている。Caty devのissueにも書いたのだが、&lt;strong&gt;ミッシングリング&lt;/strong&gt;が見つかってあまりにも&lt;em&gt;気分がスッキリした&lt;/em&gt;のでコッチにも書いておこう。以下、割とちゃんとした説明。

RPCってのは、1980年代／90年代からあって、HPの仕事をしていたときにアポロ（って会社、HPに買われた）が作ったNCS（Network Computing System）をベースにしたRPC（DCE/RPC）を使ったことがある。時代は変わった？ 進化した？ いや、むしろ退化したようだ。十数年も経過して、まともにRPCできる環境がない。

今RPCやるなら、HTTP上に載せるしかない。独自プロトコルはさすがに無理だろう。RPC over HTTPというと、多くの人がSOAPを思い出して「あんなもんは…」となるわけで、RPCを貶めた点でSOAPの罪は重い。

RPCはかなりのネガティブキャンペーンにさらされた。擁護するために書いた記事のひとつは次：

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20100819/1282179393&quot;&gt;今どき「RPC vs REST」なんてテーマ設定に意味があるかどうか？ 自分の頭で考えてみよう&lt;/a&gt; (2010年8月)

CatyはRPCにも向いた作りにしようと思っていたのだが、実際にRPCっぽいことやろうとするとナーンカ使いにくい。その原因は自動変換だろう、とは思っていた。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20101007/1286424775&quot;&gt;Catyとデータ型： だれががんばるの？&lt;/a&gt; (2010年10月)

最近になってやっと「自動変換をやめて、それからどうするか？」が分かった。ほとんどの問題は「基本に戻れば解決する」が、今回も伝統的・古典的な常識に基づいて考えればよかったのだ。ネットワークの教科書に必ず出てくる&lt;strong&gt;N層アーキテクチャ&lt;/strong&gt;。

次の3階層を使う。

+ 応用固有のデータ型と処理からなる Semantic層
+ 一般的で共通性が高いフォーマットからなる Generic層
+ 転送に使われるデータと転送方式からなる Raw/Transport層

各階層の間の変換処理と転送処理は次のように名付ける。

+ untranslate -- 送信側の、Semantic層データ→Generic層データ という変換
+ unparse -- 送信側の、Generic層データ→Raw/Transport層データ という変換
+ 転送処理 -- 後で出てくる。
+ parse -- 受信側の、Raw/Transport層データ→Generic層データ という変換
+ translate -- 受信側の、Generic層データ→Semantic層データ という変換

通信の両端にスタックがあるので、お馴染みの絵が描ける。ただし、boxes-and-wires記法を使う。箱が処理で、ワイヤーがデータ型とデータの流れを表す。

&lt;img src=&quot;http://www.chimaira.org/img3/webio-stack.gif&quot; /&gt;

Raw DataがHTTPトランスポート上を流れる、と考えればいい。この絵は、左上から下に降りて（downward）、右に写ってから上に登る（upward）。時間の順に直列に並べると、次の絵。時間は上から下に流れる。

&lt;img src=&quot;http://www.chimaira.org/img3/webio-sequence.gif&quot; /&gt;

「semanticな処理」と書いてある部分が実際には重要な処理で、その他の部分はデータ変換と転送である。one-way通信の場合はこの絵でよいが、同期呼び出しのように処理結果を戻す場合はさらに「戻し」の処理が入る。HTTP上での「戻し」を含めた全体は次の絵になる。使うHTTPメソッドはpostだとしている。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/webio-http-rpc.gif&quot; /&gt;

同期呼び出しなので、呼び側は戻るまでのあいだ「待ち」に入る。それが左の点線。呼ばれたサーバーは「semanticな処理」を済ませてからreturnするが、HTTPではreturnにresponseを使う。

一連の処理は、「マーシャリング、送信、アンマーシャリング、処理、リターン」となり、まさにRPC。HTTPは、リターン時のマーシャリング／アンマーシャリングをあまり意識しないで済む。しかし、レスポンスデータから「semanticな戻り値」を取り出す操作もあるから、これも絵に描くべきだったかもしれない。絵にはないが、戻り値を取り出す操作を&lt;em&gt;extract&lt;/em&gt;としよう。

すると、RPC over HTTPに必要な操作は、（時間順に）次のようになる。

+ untranslate
+ unparse
+ get, put, post, head, delete (HTTPメソッド）
+ parse
+ translate
+ process （実際の処理）
+ response
+ extract

いつもすべてが必要なわけではない。例えば、putでファイルを書く場合は：

+ put
+ process（ファイルを書く）
+ response

これでOK。ローレベルで完結することは、変換なしで簡潔に出来なくてはならない。余計な変換が入ると階層が&lt;em&gt;歪んで変なこと&lt;/em&gt;になる。

processは、それぞれの応用固有の処理だから個別に書くことになるが、あとはだいたい汎用コマンドでまかなえると思っている。特に、get/put/postなどのHTTPメソッドによるリクエストとレスポンスの戻しは決まり切った処理だ。階層間でのデータ変換を行う untranslate/unparse/parse/translateもだいたいは決まりものだろう -- 変換のカスタマイズのためにプラグイン方式にしたほうがいいけど。extractは個別に書くこともあるかもしれない。

以上の手順を、ものすごくおおざっぱにCatyScriptで書くと：

&lt;pre class=&quot;code&quot;&gt;
/** RPCを呼ぶ側 */
command call-web [uri target] :: A -&gt; B
{
  %1 &gt; target;

  untranslate |
  unparse |
  post %target | // ここで行って戻ってくる。
  extract
};

/** 呼ばれる側 */
command callee :: Raw -&gt; Response
{
  parse |
  translate |
  process |
  response
};
&lt;/pre&gt;

call-webは、ほんとにHTTP POSTリクエストを実行するのだが、ローカルでエミュレーションするなら、call-webを次のように書き換えればいい。

&lt;pre class=&quot;code&quot;&gt;
/** RPCを呼ぶ側 エミュレーション */
command call-web [uri target] :: A -&gt; B
{
  %1 | to-local-target &gt; target;

  untranslate |
  unparse |
  emu:post %target | // ローカルでエミュレーション
  extract
};
&lt;/pre&gt;

calleeは、Raw -&gt; Response というプロファイルなので、post %target をcalleeで置き換えてもいい。

&lt;pre class=&quot;code&quot;&gt;
/** RPCを呼ぶ側 caleeを呼んでしまう */
command call-web [uri target] :: A -&gt; B
{
  // %1 は使わない

  untranslate |
  unparse |
  callee | // callee呼び出し
  extract
};
&lt;/pre&gt;

processは A-&gt;B というプロファイルだから、&lt;em&gt;すべてをすっ飛ばして&lt;/em&gt;processを呼んでも同じ事だ。

&lt;pre class=&quot;code&quot;&gt;
/** RPCを呼ぶ側 processを呼んでしまう */
command call-web [uri target] :: A -&gt; B
{
  // %1 は使わない
  process
};
&lt;/pre&gt;

これら、色々な呼び出し方を、いちいち手で修正せずに、設定とか環境変数で入れ替えることも出来る。アプリケーションコードでは、call-webのようなラッパーを経由して処理本体（process）を呼び出しているなら、本物のネットワークから直接コールまで、どんな形態でも実験／テスト／本番運用ができる。

こんな&lt;em&gt;自由さ&lt;/em&gt;が欲しくてパイプライン方式を採用しているのに、ちょっとした歪み（不健全な階層化）がパイプを詰まらせてしまっていた。古典と基本に戻るのが遅きに失した感もあるが、ともかくも&lt;em&gt;パイプは繋がった&lt;/em&gt;。


</body>
</day>
<day date="2012-05-07" title="">
<body>
*1336346018*[プログラム意味論]零時間制約

「時間がまったく経過しないなら、何も起きない」という原則は当たり前で重要だが名前がない。&lt;strong&gt;零時間制約&lt;/strong&gt;と呼んでおこう。&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;ストップモーション制約&lt;/em&gt;がいいかも。&lt;b&gt;[/追記]&lt;/b&gt;

*1336383744*[プログラム意味論]ストップモーション制約とテンソル積

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120507/1336346018&quot;&gt;今日書いた&lt;/a&gt;ストップモーション制約（と呼ぶことにする）は、もともとはご都合主義的に入れた条件だった。勝手に手で入れた条件だから、ダメなものだと思っていた。が、これは実は正しい条件だった気がする。ストップモーション制約を入れると、モノイドのテンソル積と加群（オートマトン）のテンソル積が定義できる。

テンソル積の定義は、一見するとトリッキー／人工的な変な定義に思える。だが、テンソル積として期待する性質を持っている。見方を変えると、これは自然なものだと感じてきた。今までの常識的な見方が間違っていたのかもしれない。

*1336347594*[圏一般論][プログラム意味論]森田さんの勉強

「連休中にXXXを勉強しよう」は毎年失敗している。今年は「森田理論の勉強」と思ったが捗らず。

&lt;strong&gt;森田コンテキスト&lt;/strong&gt;が重要（つうか、これがないとはじまらない）ことはわかった。

- 可換とは限らない環A, Bがあるとする。
- 4つ組 (M, N, φ, ψ)が森田コンテキスト。
- Mは、(B, A)双加群
- Nは、(A, B)双加群
- φは、M(×)&lt;sub&gt;A&lt;/sub&gt;N → B という双線型写像
- ψは、N(×)&lt;sub&gt;B&lt;/sub&gt;M → A という双線型写像
- なんか条件を満たす。

森田コンテキストはAとBを繋ぐ（connecting）という意味で射だが、森田コンテキスト自体を対象と考えて、2つの森田コンテキストのあいだの射を考える。

基本的な結果は：

- φとψが全射（surjective）なら、実は可逆。

http://arxiv.org/pdf/math/0608601v2.pdf から引用すると、

&gt;&gt;
Part of the fundamental Morita theorem says that&lt;br&gt; there is a one-to-one correspondence between the isomorphism types of category equivalences between categories of modules; and the isomorphism types of Morita contexts with surjective maps.
&lt;&lt;

圏の同値が森田同値と呼ばれるから、森田同値類は、全射な森田コンテキストで尽くされる。

*1336347850*[Caty][プログラム意味論]ハイパー呼び出し

Webアプリケーションは、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120505/1336172779&quot;&gt;HTTP上のRPCアプリケーション&lt;/a&gt;とみなすことができる。ただし、単なるRPCではなくて、ハイパーRPCだと言える。ハイパーオブジェクトが介在する点が特徴的。

一般的なRPCは次の形をしている。SPは、&lt;strong&gt;セマンティック処理&lt;/strong&gt;（Semantic Processing）で、目的とする本来の処理。その他のマーシャリング／アンマーシャリングは、データを転送するときの手段であって、意味的に本質的ではない。

&lt;img src=&quot;http://www.chimaira.org/img3/hcall-rpc.gif&quot; /&gt;

マーシャリング／アンマーシャリングは本質的ではないし、決まりきった手順だから省略して、右の絵のように描くことにする。AとBは、セマンティック処理の入出力の型である。

&lt;strong&gt;ハイパーオブジェクト&lt;/strong&gt;（ハイパーメディアオブジェクト）はハイパーリンクを含むデータのことだが、次のように図示する。毛が生えたように見えるのは&lt;strong&gt;トリガー&lt;/strong&gt;で、ハイパーリンク（矢印）の根本となる。

&lt;img src=&quot;http://www.chimaira.org/img3/hcall-hobject.gif&quot; /&gt;

いくつかあるトリガーのなかで、特に選ばれたもの（chosen trigger）があるときはそれを黒マルで示す。

1本の&lt;strong&gt;ハイパーリンク&lt;/strong&gt;は、クライアント側にいる&lt;strong&gt;ユーザー&lt;/strong&gt;（アクター、人間かプログラム）とセマンティック処理を結び矢印で描く。このとき、ユーザーはハイパーオブジェクトの&lt;strong&gt;選ばれたトリガー&lt;/strong&gt;と向き合っていることに注意せよ。リンクは必ずトリガーを経由する。

&lt;img src=&quot;http://www.chimaira.org/img3/hcall-hlink.gif&quot; /&gt;

ハイパーリンクは、&lt;strong&gt;ハイパー呼び出し&lt;/strong&gt;（hypercall, hcall）の半分であり、残る半分を描きたすと次のようになる。

&lt;img src=&quot;http://www.chimaira.org/img3/hcall-hcall.gif&quot; /&gt;

SPはセマンティック処理、HOGは&lt;strong&gt;ハイパーオブジェクトの生成処理&lt;/strong&gt;（hyperobject generation）である。ハイパー呼び出しの結果（戻り値）はハイパーオブジェクトとなる。

ハイパー呼び出しは同期呼び出しなので、呼び出しは行ったユーザーは戻り（レスポンス）を待つことになる。結果のハイパーオブジェクトが戻ると、ユーザーが適当なトリガーを選び、さらにハイパー呼び出しを続ける（かもしれない）。1つのハイパーオブジェクトに複数のトリガーがあることから、選択の余地があり、ハイパーリンク／ハイパー呼び出しの全体は有向グラフ構造を持つ。この有向グラフを&lt;strong&gt;ハイパーリンクグラフ&lt;/strong&gt;と呼ぶ。

現在のCatyは、モジュールごとのハイパーリンクグラフを描くことができる。複数のモジュールを繋いだ（バインディングした）全体はまだ描けない。


</body>
</day>
<day date="2012-05-08" title="">
<body>
*1336436583*[雑記][メモ]DotsterのUI

さんざん悪口を言ってきたが：
	
&gt;&gt;
Dear Member, 

We're excited to let you know that Dotster will soon be upgrading to a new control panel, which we think you're really going to like. The domain management interface is more modern and intuitive -- ideal for customers who manage multiple domains.
Learn more about the new control panel: http://transition-dotster.com/domainmgt/
&lt;&lt;

やっと直すか。とにかく今までがヒドすぎだろうよ。

*1336457625*[プログラム意味論]どうやって双オートマトンを作るのか

X, Yなどがモノイドだとして、右加群と左加群を区別して、X-Mod, Mod-X と書く。双加群（両側加群）は、X-Mod-Y と書く。X自身をX上の加群とみなしたものを同じ記号Xで表す。X∈|X-Mod|、X∈|Mod-X| となる。

Φ: Mod-X→Mod-Y が関手だとして、Φ(X)∈|Mod-Y| は当然にY加群だが、これにX加群の構造も入れる。具体的な集合圏／関係圏で考える（一般論はよくわからない）。XのX加群構造は、X→Mod-X(X, X) として与えることができる。x∈X に対する Mod-X(X, X) の要素（Xの自己変換）を x~ と書くことにする。x~:X→X in Mod-X。

Φ: Mod-X→Mod-Y だったので、Φ(x~):Φ(X)→Φ(X) in Mod-Y。s∈Φ(X) に対して、x∈X の作用 x*s := Φ(x~)(s) として定義する。(Φ(X), X, *) が加群となることを確認する。また、γ(x, s, y) := Φ(x~)(s・y) として双加群構造を定義する。

*1336470036*[プログラム意味論]加群とオートマトン

だいぶ絞れてきた。

X, Yはモノイド、Mod-X, Mod-Y はそれぞれ右加群の圏。Φ:Mod-X→Mod-Y が任意の関手、ただし基礎可換モノイドは保存する。この状況で、示したいことは2つ。

(その1) P := Φ(X) と置く。ただし、X∈|Mod-X| と書いたときは、X-右加群としてのX。P∈|Mod-Y| だからPはY-加群。Φを経由してX作用をPまで前送りすると、PはX-左加群にできる。これにより、Pは(X, Y)-双加群。テンソル積を × で書くとして、X×P in Mod-Y となる。示すべきは、Y-右加群としての同型、X×P ＝ P in Mod-Y 。Mod-Y のなかで具体的に同型を構成する。

(その2) P, Q∈(X-Mod-Y) とする。(-)×P と (-)×Q は Mod-X → Mod-Y の関手となる。αが α::(-)×P ⇒ (-)×Q : Mod-X→Mod-Y という自然変換だとして、α&lt;sub&gt;A&lt;/sub&gt;:A×P→A×Q 。このα&lt;sub&gt;A&lt;/sub&gt;は、双加群の準同型f:P→Q を用いて、α&lt;sub&gt;A&lt;/sub&gt; := A×f と書ける。

(その1)のほうがなんか違うような気もする。勘違いがあるかもしれない。もとの形は、Aが自由加群のとき、Φ(A) = A×P と書ける、という主張。A = X とすると、Φ(X) = X×P だから、P = X×P かと思うのだが、、、？

</body>
</day>
<day date="2012-05-10" title="">
<body>
*1336639944*[形式言語理論][プログラム意味論][圏一般論][高次圏論][マンダラ]続・オートマトンの森田の定理

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20110926/1316992601&quot;&gt;オートマトンの森田の定理&lt;/a&gt;」で、「いやー、むずかしい、難しい。」と書いているが、そのあと挫折してやめた。

で、最近また再挑戦。「いやー、むずかしい、難しい。」少しだけ進展してるんだけどね。

</body>
</day>
<day date="2012-05-29" title="">
<body>
*1338283216*[セミナー][説明]双マグマ

二項マグマを単にマグマ、余二項余マグマを単に余マグマとする。マグマと余マグマの対があって、余演算がマグマ射、演算が余マグマ射となっているとき、双マグマと呼ぶ。

ただし、マグマ (A, m) に対して、A×Aをマグマにする方法が必要。このとき対称σが必要になる。σを使って、A×A→(A×A)×(A×A) を作れる。同様に、(A×A)×(A×A)→A も作る。

双代数法則は、マグマ／余マグマの組に対して定義できる。

例：

+ 集合圏と直積で、&lt;b&gt;N&lt;/b&gt;に掛け算と対角で双マグマとなる。
+ 集合圏と直積で、任意のマグマと対角で双マグマとなる。
+ K行列の圏 Mat&lt;sub&gt;K&lt;/sub&gt; のなかで、すべての対象を双マグマにできる。
+ 関係圏と直積で、&lt;b&gt;N&lt;/b&gt;に足し算と余足し算で双マグマとなる。
+ レコード単位でフェッチとアップデートできるデーターストア


</body>
</day>
<day date="2012-05-31" title="">
<body>
*1338444446*[気付いた][説明]直積を直和に移す射

関係圏での話だが、A×B→A+B という比較的自然な射がある。

A×B×(A + B) = A×B×A + A×B×B なので、R⊆(A×B×A + A×B×B) を R1 + R2 と分解して：

+ R1 = {(a, b, a) | a∈A, b∈B}
+ R2 = {(a, b, b) | a∈A, b∈B}

と定義する。π&lt;sub&gt;1&lt;/sub&gt; + π&lt;sub&gt;2&lt;/sub&gt; とも書ける。これが「どちらか早く終わったほうを選ぶ」になる。

</body>
</day>
<day date="2012-06-02" title="">
<body>
*1338606186*[プログラム意味論]計算処理に適切な圏

計算処理のモデルに集合圏はチトきびしい。部分写像の圏ならけっこういける。順序とか位相を入れるテもある。関係圏はより自由度が上がる。

が、どうも関係圏でも不足な感じがしている。部分写像の圏を点付き集合と点（基点）を保存する写像の圏に直して（圏同値）、さらに全域（total）関係だけを考えて関係圏を作る必要があるようだ。全域関係ということは、R:A→B、x∈A のとき R(x)⊆B が空であってはならない。だが、⊥∈B が決まっているから、⊥に移す定数写像が使える。

&lt;b&gt;[追記]&lt;/b&gt;これって、「何も値が得られない」って言い方を認めないことだな。「無限に待つ」ことを「⊥という値が得られた」とする。これで、いかなる場合も値が得られるので全域となる。有限時間で値が得られるケースと無限に待つケースが混在するなら、Pow&lt;sub&gt;+&lt;/sub&gt;(A+⊥) に値（の可能性）を持つことになる。 &lt;b&gt;[/追記]&lt;/b&gt;

*1338613581*[プログラム意味論][お絵描き][計算]ガード条件の連接と論理AND

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20120529/1338255357&quot;&gt;テスト付きクリーネ代数の圏論的な定式化&lt;/a&gt;」の簡単な例題の話。

&lt;img src=&quot;http://www.chimaira.org/img3/guard-calc.gif&quot; &gt;

罫線付きノートをスキャンするとこうなるなヤッパリ。無地ノートが意外と売ってない。

p, qがブール値のクエリー射 p, q:A→&lt;b&gt;B&lt;/b&gt;×A （ブール代数を左側にした）として、ブーリアンANDを演算とするモノイドの作用μ（絵では小さい黒三角）を使って、p~ := p;μ、q~ := q;μ のように定義する。p~, q~ は、ガードあるいはテストを意味する。p・f := p~;f  とすれば、クエリーが通常の射に（スカラー積として）作用しているように思える。

それで、示したいのは、p~;q~ = (p∧q)~ という等式；上の絵の上段で、双代数法則と作用の結合法則で変形している。残りは下段の変形だが、これは普通にブール代数の計算。絵算でやればより面白いが、単なる等式計算でも簡単。

p~;q~ = (p∧q)~ を示すのに、関連するほとんどすべての法則を使う所が面白い。論理OR ∨ のほうの法則は、そもそもどうやってテスト付きクリーネ代数の法則を再現するかも難しい（だいたいは分かるが）。分配性って、up-to-iso で成立してはいなくて、lax（またはoplax）でしか意味ないのかも知れない --  よくワカランけど。

*1338617467*[プログラム意味論][圏一般論]付点非空ベキ集合モナドのクライスリ圏を使う

(-)+⊥ を &lt;b&gt;Set&lt;/b&gt;→&lt;b&gt;Set&lt;/b&gt; の自己関手で付点するモナドだとする。このクライスリ圏は部分写像の圏と圏同値で、アイレンベルグ／ムーア圏は付点集合の圏&lt;b&gt;PtSet&lt;/b&gt;。この例では、クライスリ圏とアイレンベルグ／ムーア圏が同値。

付点集合の圏に非空ベキ集合関手を作用させてさらにクライスリ圏を作る。このとき、&lt;b&gt;Set&lt;/b&gt;上の複合モナドは Pow&lt;sub&gt;+&lt;/sub&gt;(- +⊥) と書ける。このモナドのクライスリ圏を&lt;b&gt;NTND&lt;/b&gt;とする。non-terminating non-deterministic から。

クライスリ圏を2回作っているだけなので、対象類は変わらないので、|&lt;b&gt;NTND&lt;/b&gt;| = |&lt;b&gt;Set&lt;/b&gt;|。この理由から、&lt;b&gt;NTND&lt;/b&gt;の対象も集合として書く。A, B∈|&lt;b&gt;NTND&lt;/b&gt;| = |&lt;b&gt;Set&lt;/b&gt;| に対して、f:A→B in &lt;b&gt;NTND&lt;/b&gt; とは、f:A+⊥→B+⊥ in &lt;b&gt;Rel&lt;/b&gt; （ただし全域） と解釈できる。A×B、A+B も意味は単純な直積、直和ではない。&lt;b&gt;Rel&lt;/b&gt;内で解釈するなら、(A+⊥)×(B+⊥） と A + B + ⊥ になる。

この圏&lt;b&gt;NTND&lt;/b&gt;が具合がいいのは、A×B→A+B in &lt;b&gt;NTND&lt;/b&gt; が「待たないで行け」を表現できること。(A+⊥)×(B+⊥）→ (A + B + ⊥)  は、(A×B + A×⊥ + B×⊥ + ⊥×⊥） → A + B + ⊥  となるが、⊥を待たないように定義すれば、直感に一致する。

*1338620674*[プログラム意味論][圏一般論][TQFT]有向グラフのラベリング、ガード付き文字列、境界付きアルファベット、

有向グラフのラベリングが関手だと書いたことがあるが：

- 関手の域は、グラフから作った自由圏（パスの圏）
- 関手の余域は、ラベルから作った圏

ラベルから作った圏Cとは、頂点ラベルがA、辺ラベルがBとして：

- |C| = A
- a, b∈A に対して、C(a, b) = B&lt;sup&gt;*&lt;/sup&gt; （ホムセットはすべて同じ）
- 結合 C(a, b)×C(b, c) は B&lt;sup&gt;*&lt;/sup&gt;×B&lt;sup&gt;*&lt;/sup&gt; のモノイドの積
- aに対する恒等id&lt;sub&gt;a&lt;/sub&gt; は、C(a, a) 内のモノイド単位元、つまり空列。

正確に言えば、C(a, b) = {a}×B&lt;sup&gt;*&lt;/sup&gt;×{b} のようにして、ホムセット達をdisjointにしておく。すると、f∈C(a, b)は、aαb（α∈B&lt;sup&gt;*&lt;/sup&gt;）とみなしてよい。aαb のような形、念の為に a{α}b か、これはガード付き文字列だから、ホムセットはガード付き文字列の集合。

以前から問題にしていた境界付きアルファベットとは、(Σ, Σ&lt;sub&gt;0&lt;/sub&gt;, Σ&lt;sub&gt;1&lt;/sub&gt;, Γ) の4つ組で：

+ Σはガード記号＝頂点ラベルの集合
+ Σ&lt;sub&gt;0&lt;/sub&gt;⊆Σ
+ Σ&lt;sub&gt;1&lt;/sub&gt;⊆Σ
+ Γは辺ラベルの集合

この(Σ, Σ&lt;sub&gt;0&lt;/sub&gt;, Σ&lt;sub&gt;1&lt;/sub&gt;, Γ) から、上記と同様な手段で圏Cを作れ。Cの対象類にはΣ&lt;sub&gt;0&lt;/sub&gt;、Σ&lt;sub&gt;1&lt;/sub&gt;という境界が付いている。これで、圏Cは境界付きの圏となる。

Gが境界付きグラフ（単なるシェープ）のとき、Gから圏Cへの境界を保つ関手が定義できる。この関手がラベリング。このラベリングは、境界付きグラフGを台とするカテグラフ（圏を値とする準同型）となる。境界があることから、境界を考慮したグルーイングができる。つまり、シェープのグルーイングと協調したカテグラフのグルーイングが定義できる。

より一般に&lt;em&gt;圏のコボルディズム圏&lt;/em&gt;（境界付き圏を射とする圏）に値を持つようなラベリングを考えることができるだろう。このラベリングがTQFT関手の対応物だろう。

次がほぼ同じもの：

- カテグラフ
- 境界付きラベリング
- TQFT関手

これらを繋ぐのは、やはり行列概念の一般化だろう。

*1338631965*[プログラム意味論][圏一般論]NTNDという圏

由来・経緯を省略していきなり天下りに定義すると：

+ |&lt;b&gt;NTND&lt;/b&gt;| = |&lt;b&gt;Rel&lt;/b&gt;| = |&lt;b&gt;Set&lt;/b&gt;| 
+ &lt;b&gt;NTND&lt;/b&gt;(A, B) := &lt;b&gt;Rel&lt;/b&gt;&lt;sub&gt;strict,total&lt;/sub&gt;(A+{⊥}, B+{⊥})

strictの条件は：

- R(⊥) = {⊥} あるいは、(⊥Ry ⇔ y = ⊥)

totalの条件は：

- ∀x∈A.∃y∈B.xRy

&lt;b&gt;T&lt;/b&gt;を三値 {true, false, indef} からなる半環（対合としての否定があってもよい）だとして、&lt;b&gt;NTND&lt;/b&gt;は：

+ 零対象を持つ。（空集合が零）
+ 双積を持つ。（直和）
+ テンソル積を持つ。（直積だが、⊥を考慮する）
+ たぶん&lt;b&gt;T&lt;/b&gt;線形圏だろう。End(&lt;b&gt;1&lt;/b&gt;)は&lt;b&gt;T&lt;/b&gt;のようだ。
+ つまり、&lt;b&gt;T&lt;/b&gt;線形なテンソル圏だろう。
+ &lt;b&gt;Rel&lt;/b&gt;は&lt;b&gt;B&lt;/b&gt;線形なテンソル圏だから、埋め込みがあるはず。
+ &lt;b&gt;Rel&lt;/b&gt;と&lt;b&gt;NTND&lt;/b&gt;はかなり似てるはず。
+ しかし、&lt;b&gt;Rel&lt;/b&gt;は、無限走行と正常終了が混じった非決定性を扱えない。

&lt;b&gt;T&lt;/b&gt;上の線形代数が、今まで馴染みがないという意味で難しそうだ。


</body>
</day>
<day date="2012-06-08" title="">
<body>
*1339118207*[メモ]リュバシェンコ

Forvoで調べたら、Lyubashenko はリュバシェンコ。

*1339118208*[用語法]モノイド関手

モノイド関手（monoidal functor）には、厳密（strict）、強（strong）、緩（lax）がある。形容詞がないと、どれを意味するかわからないから、形容詞を付けたほうがいい。

*1339119825*[気付いた][インスティチューション]多ソートメイヤー指標

多ソートメイヤー指標（many-sorted Meyer signature）とは：

+ 状態指標の集合Σ
+ 値指標の集合Φ
+ s∈Σ ごとに、通常のメイヤー指標 (C&lt;sub&gt;σ&lt;/sub&gt;, Q&lt;sub&gt;σ&lt;/sub&gt;)。クエリーの値はΦから取られる。
+ s, t∈Σ ごとに T(s, t) という記号の集合。状態のあいだの変換を表す記号。空でもよい。

状態指標の集合Σが単元のときが、通常のメイヤー指標。多ソートでは、T(s, t)を考えるのがミソ。指標の全体は、Σを対象とする記号の圏を構成する。この圏からモデルの圏への関手が意味論。意味論の全体は関手圏となる。

</body>
</day>
<day date="2012-06-11" title="">
<body>
*1339369566*[メモ][Caty]配布パッケージに関する概念 リンク

配布パッケージに関する概念 X

- http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%C7%DB%C9%DB%A5%D1%A5%C3%A5%B1%A1%BC%A5%B8%A4%CB%B4%D8%A4%B9%A4%EB%B3%B5%C7%B0

Caty dev のissuから引用：

+ パッケージの仕様とかお約束を決める。この仕様に従うパッケージングやインストールは、頑張ればツール無し手作業で出来る。
+ 必須ではないが、Caty内で使えるパッケージ管理コマンドを先に作って実験する。
+ Catyに依存しないスタンドアローンパッケージ管理コマンドを作る。
+ スタンドアローンパッケージ管理コマンド自体をパッケージ（ZIPアーカイブ）にする。
+ このパッケージを、空なプロジェクトにインストールする。
+ スタンドアローンパッケージ管理コマンドがインストールされた状態のプロジェクトをパッケージにする。
+ 出来上がったパッケージ（ZIPファイル）がブートストラップファイルで、パッケージではあるが、ZIP展開だけでインストールが終わるシロモノ。



</body>
</day>
<day date="2012-06-14" title="">
<body>
*1339654517*[メモ][Caty][お絵描き]ロバストネス図のアイコン

http://www.ogis-ri.co.jp/otc/swec/process/am-res/am/artifacts/robustnessDiagram.html にあった図。

&lt;img src=&quot;http://www.chimaira.org/img3/robustnessDiagramNotation.jpg&quot; &gt;

図のURL: http://www.ogis-ri.co.jp/otc/swec/process/am-res/am/images/models/robustnessDiagramNotation.jpg

*1339657474*[メモ][caty-depl]ポートを使っているプロセスの特定

コマンド： netstat -tan

- -t TCPプロトコル
- -a INETソケットも表示する（デフォルトではUNIXだけ）
- -n ホスト名・サービス名でなくて数値で表示

コマンド： fuser -n tcp 80

- -n 名前空間を指定する。tcpとか、あとなにかある？

fuserの表示

- c 指定ディレクトリを当該プロセスがカレントディレクトリにしている
- e 指定ファイルを当該プロセスが実行可能ファイルとしている
- f 指定ファイルを当該プロセスが読み込み用に開いている
- F 指定ファイルを当該プロセスが書き込み用に開いている
- r 指定ディレクトリを当該プロセスがルートにしている
- m 指定ファイルを当該プロセスがメモリマップしているか共有ライブラリとして読み込んでいる

nmapとlsofもある。

コマンド： lsof -i :http    

- -pオプションでプロセスID指定
- -cオプションでプロセス名指定
- -iオプションでアドレス・ポート指定 構文は、'@' {IPアドレス}? ':' {ポート番号} 名前でも番号でもOK
- -aオプションでAND


</body>
</day>
<day date="2012-06-15" title="">
<body>
*1339715840*[メモ][Caty]配布パッケージに関するに概念 6

files.json の例を幾つか挙げる。

&lt;pre class=&quot;code&quot;&gt;
{

  &quot;schemata@global&quot;: {
    &quot;baseDir&quot; : &quot;../../global/schemata/&quot;,
    &quot;files&quot; : [&quot;/webreq.py&quot;, &quot;webresp.py&quot;]
  },
 
  &quot;commands@global&quot;: {
     &quot;baseDir&quot;: &quot;../../glbal/commands/&quot;,
     &quot;files&quot;: [&quot;/webreq.casm&quot;, &quot;/webresp.casm&quot;]
  }
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
{
 &quot;lib@caty&quot;: {
    &quot;baseDir&quot; : &quot;../lib/&quot;,
    &quot;files&quot; : [&quot;/caplib.py&quot;]
  },
  &quot;tools@caty&quot;: {
     &quot;baseDir&quot;: &quot;../tools/&quot;,
     &quot;files&quot;: [&quot;/cap&quot;, &quot;/cap.bat&quot;, &quot;/cap.py&quot;, &quot;/catalog.json&quot;, &quot;/local-catalog.json&quot;]
  }
}
&lt;/pre&gt;

&lt;pre class=&quot;code&quot;&gt;
{
 &quot;home@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./&quot;,
   &quot;pattern&quot; : &quot;/**&quot;,
   &quot;excludePattern&quot; : [&quot;**.tmp&quot;, &quot;**.log&quot;, &quot;**.orig&quot;]
 },

 &quot;pub@wiki&quot; :  {
   &quot;baseDir&quot; : &quot;./pub/&quot;,
   &quot;pattern&quot; : &quot;**&quot;,
   &quot;excludePattern&quot; : [&quot;**.tmp&quot;, &quot;**.orig&quot;]
 },
 &quot;include@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./include/&quot;,
   &quot;pattern&quot; : &quot;**&quot;,
   &quot;excludePattern&quot; : [&quot;**.tmp&quot;, &quot;**.orig&quot;]
 },
 &quot;actions@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./actions/&quot;,
   &quot;pattern&quot; : &quot;**&quot;,
   &quot;excludePattern&quot; : [&quot;**.tmp&quot;, &quot;**.orig&quot;]
 },
 &quot;schemata@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./schemata/&quot;,
   &quot;pattern&quot; : &quot;**&quot;,
   &quot;excludePattern&quot; : [&quot;**.tmp&quot;, &quot;**.orig&quot;]
 },
 &quot;scripts@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./scripts/&quot;,
   &quot;pattern&quot; : &quot;*.caty&quot;
 },

 &quot;messages@wiki&quot; : {
   &quot;baseDir&quot; : &quot;./messages/&quot;,
   &quot;pattern&quot; : &quot;*.xjson&quot;
 }
}
&lt;/pre&gt;

ファイルセットを記述するための項目は：

+ baseDir
+ files
+ pattern
+ excludePattern
+ excludeFiles

計算は、files + (pattern - excludePattern) - excludeFiles

*1339719536*[メモ][Caty]型からフォームの生成

http://d.hatena.ne.jp/m-hiyama/20101213/1292201095 から再掲：

&lt;pre class=&quot;code&quot;&gt;
/** 
 * ランチの注文 
 */
type LunchOrder = {
  /** 会員識別情報 */
  &quot;ident&quot; : {
    &quot;name&quot; : string,
    &quot;memberNum&quot; : integer
  },
  /** 今日の注文 */
  &quot;order&quot; : {
    &quot;mainDish&quot; : (
                 &quot;special&quot;|
                 &quot;fish&quot;|
                 &quot;meat&quot;
                 ),
    &quot;drink&quot; : (
               &quot;teaHot&quot;|
               &quot;teaIce&quot;|
               &quot;coffeeHot&quot;|
               &quot;coffeeIce&quot;
               ),
    &quot;dessert&quot; : (
                &quot;pudding&quot;|
                &quot;strawberryShortcake&quot;|
                &quot;bavarianCream&quot;|
                &quot;gateauChocolat&quot;
                )
  }
};
&lt;/pre&gt;

&lt;b&gt;[追記]&lt;/b&gt;&lt;em&gt;以下のXMLはよくない、メンドクサイから直さないが、あとで別な形式を考える。&lt;/em&gt; &lt;b&gt;[/追記]&lt;/b&gt;

概念的には：

&gt;|xml|
&lt;form name=&quot;lunchOrder&quot;&gt;
  &lt;group name=&quot;ident&quot; lable=&quot;ident&quot; &gt;
    &lt;input ui=&quot;textField&quot; name=&quot;ident.name&quot; label=&quot;name&quot; /&gt;
    &lt;input ui=&quot;textField&quot; name=&quot;ident.memberId&quot; label=&quot;memberId&quot; /&gt;
  &lt;/group&gt;

  &lt;group name=&quot;order&quot; label=&quot;order&quot; &gt;
    &lt;select name=&quot;order.mainDish&quot; ui=&quot;checkboxGroup&quot; label=&quot;mainDish&quot;&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;special&quot; label=&quot;special&quot; /&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;fish&quot;    label=&quot;fish&quot;/&gt; 
      &lt;option ui=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;meat&quot;    label=&quot;meat&quot; /&gt;
      meat
    &lt;/select&gt;

    &lt;select name=&quot;order.drink&quot; ui=&quot;radioGroup&quot; label=&quot;drink&quot;&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;teaHot&quot;    label=&quot;teaHot&quot; /&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;teaIce&quot;    label=&quot;teaIce&quot; /&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;coffeeHot&quot; label=&quot;coffeeHot&quot; /&gt;
      &lt;option ui=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;coffeeIce&quot; label=&quot;coffeeIce&quot; /&gt;
    &lt;/select&gt;

    &lt;!-- 省略 --&gt;

  &lt;/group&gt;
&lt;/form&gt;

||&lt;

&gt;|html|
&lt;form method=&quot;post&quot; action=&quot;lunchOrder.cgi&quot;&gt;
  &lt;fieldset id=&quot;ident&quot;&gt;&lt;legend&gt;ident&lt;/legend&gt;
    &lt;div class=&quot;textField&quot; id=&quot;ident.name&quot;&gt;
      name：&lt;input type=&quot;text&quot; name=&quot;ident.name&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;textField&quot; id=&quot;ident.memberId&quot;&gt;
      memberId：&lt;input type=&quot;text&quot; name=&quot;ident.memberId&quot;&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;

  &lt;fieldset id=&quot;order&quot;&gt;&lt;legend&gt;order&lt;/legend&gt;
    &lt;div class=&quot;checkboxGroup&quot; id=&quot;order.mainDish&quot;&gt;
      mainDish：
      &lt;input type=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;special&quot; /&gt;
      special
      &lt;input type=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;fish&quot; /&gt; 
      fish
      &lt;input type=&quot;radio&quot; name=&quot;order.mainDish&quot; value=&quot;meat&quot; /&gt;
      meat
    &lt;/div&gt;

    &lt;div class=&quot;radioGroup&quot; id=&quot;order.drink&quot;&gt;
      drink：
      &lt;input type=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;teaHot&quot; /&gt;
      teaHot
      &lt;input type=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;teaIce&quot; /&gt;
      teaIce
      &lt;input type=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;coffeeHot&quot; /&gt;
      coffeeHot
      &lt;input type=&quot;radio&quot; name=&quot;order.drink&quot; value=&quot;coffeeIce&quot; /&gt;
      coffeeIce
    &lt;/div&gt;

    &lt;div class=&quot;checkboxGroup&quot; id=&quot;order.dessert&quot;&gt;
      dessert：
      &lt;input type=&quot;checkbox&quot; name=&quot;order.dessert&quot; value=&quot;pudding&quot; /&gt;
      pudding
      &lt;input type=&quot;checkbox&quot; name=&quot;order.dessert&quot; value=&quot;strawberryShortcake&quot; /&gt;
      strawberryShortcake
      &lt;input type=&quot;checkbox&quot; name=&quot;order.dessert&quot; value=&quot;bavarianCream&quot; /&gt;
      bavarianCream
      &lt;input type=&quot;checkbox&quot; name=&quot;order.dessert&quot; value=&quot;gateauChocolat&quot; /&gt;
      gateauChocolat
    &lt;/div&gt;
  &lt;/fieldset&gt;

  &lt;p&gt;&lt;input disabled type=&quot;submit&quot; value=&quot;送信する&quot;&gt;&lt;/p&gt;

&lt;/form&gt;
||&lt;

</body>
</day>
<day date="2012-06-20" title="">
<body>
*1340177690*[メモ][Caty]Graphvizの属性

gvモジュールを使うとき使っているオプション。

&gt;||
--arrowhead
--arrowtail
--bgcolor
--color
--dir
--fillcolor
--fontcolor
--fontname
--headlabel
--label
--peripheries
--rankdir
--shape
--style
--width
||&lt;

値付き。

&gt;||
--arrowhead=diamond
--arrowhead=dot
--arrowhead=none
--arrowhead=vee
--arrowtail=dot
--arrowtail=inv
--bgcolor=gainsboro
--color=blue
--color=brown
--color=forestgreen
--color=green
--color=hotpink
--color=red
--color=seagreen
--dir=both
--fillcolor=black
--fillcolor=brown
--fillcolor=darkseagreen
--fillcolor=khaki
--fillcolor=limegreen
--fillcolor=moccasin
--fillcolor=red
--fillcolor=skyblue
--fillcolor=wheat
--fillcolor=white
--fillcolor=yellowgreen
--fontcolor=blue
--fontcolor=forestgreen
--fontcolor=green
--fontcolor=hotpink
--fontcolor=red
--fontcolor=seagreen
--fontname=&quot;MS UI Gothic&quot;
--headlabel=bar
--headlabel=foo
--label=&quot;...&quot;
--peripheries=2
--rankdir=BT
--rankdir=LR
--rankdir=TB
--shape=box
--shape=diamond
--shape=doublecircle
--shape=note
--shape=plaintext
--shape=point
--style=filled
--style=rounded
--style=bold
--style=dashed
--style=dotted
--style=filled
--style=invis
--style=rounded
--width=0.1
||&lt;

*1340177859*[Caty]メタプログラミング in CatyScript

データ処理としてはカンタンでも、メタプログラミングはやっぱり難しいな。

「自分が何をしているか？」をずっと混乱しないで意識し続けるのが疲れる。

</body>
</day>
<day date="2012-06-21" title="">
<body>
*1340265612*[メモ][Caty]マスターまでの5段階

- A : インストール、起動、index.html、静的ファイルを置いてみる。コンソールコマンドを使う。
- B : テンプレートファイル、インラインスクリプト／アウトオブラインスクリプト。簡単なアクション。
- C : リソースとアクションを使いこなす。
- D : コマンドを作る。使う。
- E : ファシリティを作る。
- E'：メタプログラミング


</body>
</day>
<day date="2012-06-22" title="">
<body>
*1340321603*[Caty]メタプログラミング：メタスクリプトの雛形

&gt;||
&lt;?caty-meta template=&quot;smarty-mx&quot; ?&gt;{* -*- coding: utf-8 -*-

 ここにメタスクリプトのコメント
 主にコンテキストの意味とか使い方とか

*}
{* -------------------------------------------------- *}

/**
 ここに生成されたスクリプトに関するdocコメント
*/

// マクロコード
||&lt;

*1340346149*[Caty]メタプログラミング：用語とネーミング

レイファイドデータ（reified data）といえども、単なるXJSONデータだから、これを加工するのは普通の処理となんら変わらない。

が、難しい。

ほんとの普通のデータは、そのまま（文字通りに）解釈すればいい。文字列は文字列だし、配列は配列だ。が、レイファイドデータは、メタオブジェクトとしての解釈を持っていて、その解釈にしたがって加工していく。&lt;em&gt;この解釈をシッカリと把握し続ける&lt;/em&gt;のが難しいのだ。

用語とネーミングの整備は多少助けになるはず。まだ、試行錯誤で暫定的だが：

+ レイファイドデータを入力とするプログラムを&lt;strong&gt;メタプログラム&lt;/strong&gt;と呼ぶ。
+ メタプログラム内で、テンプレートシステムを使うとき、そのテンプレートを&lt;strong&gt;メタコード&lt;/strong&gt;と呼ぶ。&lt;strong&gt;メタスクリプト&lt;/strong&gt;と&lt;strong&gt;メタページ&lt;/strong&gt;が主たるメタコード。
+ メタコードに渡すコンテキストを&lt;strong&gt;メタコンテキスト&lt;/strong&gt;と呼び、略称は、&lt;b&gt;mctx&lt;/b&gt; とする。
+ レイファイドデータからメタコンテキストに変換するコマンドは、conv-to-*-mctx という名前にする。
+ レイファイドデータから目的とするコード（スクリプトコード、ページコード）を出力するトップレベルのコマンドは gen-* という名前にする。
+ メタコンテキストの変数（テンプレート変数名）はすべて大文字とする。ただし、プロパティまで大文字にはしない。これは、メタコード内の可読性のためである。
+ メタコードは、include:/meta/ に入れて、拡張子は *.meta.caty, *.meta.html としている。

</body>
</day>
<day date="2012-06-26" title="">
<body>
*1340672925*[メモ] emacsのdefine-generic-mode

&lt;pre class=&quot;code&quot;&gt;
(define-generic-mode MODE-NAME

  ;; 1. コメント文字列の指定
  
  ;; 2. ハイライトするキーワードの指定（シンプルにキーワード文字だけ登録したい場合はここだけでも良い）
  
  ;; 3. 個別にハイライトするキーワードとfaceを指定（不要ならnilでも良い）
  
  ;; 4. ファイル読み込み時に自動的にこのモードにするファイルのファイル名の指定
  
  ;; 5. モード起動時のhook関数（特に何もしない場合はnilで良い）
  
  ;; 6. モードの説明
  
)
&lt;/pre&gt;

不要なところはnilで埋める。

+ コメント文字列の指定 -- 文字列または文字列のドットペア（コンスセル）からなるリスト（リテラルならクォートを忘れないように）。
+ ハイライトするキーワードの指定 -- 文字列からなるリスト。
+ 個別にハイライトするキーワードとfaceを指定 -- 正規表現文字列とfaceの記号アトムのドットペアからなるリスト
+ ファイル読み込み時に自動的にこのモードにするファイルのファイル名の指定 -- 正規表現文字列からなるリスト
+ モード起動時のhook関数 -- 関数
+ モードの説明 -- 文字列

</body>
</day>
<day date="2012-06-27" title="">
<body>
*1340762851*[お絵描き][Caty][形式言語理論]名前の参照関係のグラフ構造：これは物凄く大事 

こういう絵になる。

&lt;img src=&quot;http://www.chimaira.org/img3/name-struct-graph.gif&quot; &gt;

NSは名前空間の略称。NSコンテナはいくつかの名前空間を保持する入れ物。NSソートは名前空間の種別。

- NSコンテナにNSソート指定＝名前空間＝束縛セット＝置換＝コンテキスト

色々な用語が使われているが同じこと。束縛セット（単に束縛ともいう）と置換は用途が違うので呼び方も変えている。

上の絵で：

+ 四角い枠が名前空間＝束縛セット＝置換（substitution）
+ 黒丸が名前
+ 枠内の黒丸は内部の名前
+ 枠の外の黒丸は外部の名前
+ 白い丸（楕円っぽい）は、名前の定義体（definition body）、値、式、項とか。
+ 黒丸→白丸 の矢印は、束縛、定義、宣言などを表す。
+ 白丸→黒丸 の矢印は、名前による参照。
+ 枠内は黒丸グループと白丸グループからなる&lt;em&gt;二部ブラフ&lt;/em&gt;と考えるとよい。
+ 下側に、名前ごとの可達性が書いてある。
+ 「名前 =&gt; 可達な内部名の集合 =&gt; 可達な外部名の集合

Catyの名前構造では、再帰（サイクル）のスコープは名前空間に限定されるので、外部に出た参照の矢印が戻ってくることはない。名前空間（四角い枠）内のサイクルだけを考えればよい。また、サイクルは必ず「1つ以上の黒丸と1つの以上の白丸」を通る。よって、最短でも長さ2以上となる。（白丸を無視すると自己ループもあるが、黒丸と白丸の両方を考える。黒丸→黒丸 はエイリアス。）

内部の黒丸の集合に、次の関係「～」を入れる。x～y とは：

- xからyに至るパス（長さ2以上）がある。
- yからxに至るパス（長さ2以上）がある。

つまり、「互いに行ったり来たり出来る」こと。この定義より：

+ x～y ならば、 y～x （対称律）
+ x～y かつ y～z ならば、x～z （推移律）

しかし、x～x （反射律）は成立しない。x～x のとき、その黒丸（名前）はサイクルに含まれるので再帰的となる。再帰的な名前だけを選んだ部分集合上では、関係「～」は、反射的／対称的／推移的 となるので同値関係。この同値関係のよる分割の成分を、再帰的連結成分と呼ぶことにする。

四角枠＝名前空間＝束縛セット＝置換 の黒丸の集合（名前の集合）に関して、再帰的連結成分を完全に求めることは非常に重要である。再帰的連結成分を単一のノード（例えば二重枠の白丸とか）にして、名前と定義体を結ぶ矢印を加工すると、再帰的定義の解釈ができる。

再帰的定義では、ツリーではなくて、サイクルを持つグラフそのものの不動点（の成分）を定義体と考えることになる。多変数の不動点演算子μと成分を取る（名前による射影）演算子π&lt;sub&gt;x&lt;/sub&gt;を組み合わせればよい。


</body>
</day>
<day date="2012-06-28" title="">
<body>
*1340870706*[お絵描き][Caty][形式言語理論]モグラ（MOGra）の基本

Catyのレイフィケーションを整備してメタプログラミング環境を作る。

そもそも&lt;em&gt;何を&lt;/em&gt;レイフィケーションするのか？ -- メタレベルにある構造をキチンと定義する必要がある。最近、「メタレベルにある構造」を&lt;strong&gt;モグラ（MOGra）&lt;/strong&gt;という名前で呼ぶことにした。Metaobject Graph の略（以前は別な名前で呼んでいた）。

モグラのノードがメタオブジェクトだが、3種に分類する。

+ 名前空間コンテナー
+ 名前空間
+ その他

モグラの一部分の典型的な絵：

&lt;img src=&quot;http://www.chimaira.org/img3/mogra-basic.gif&quot; &gt;

赤い辺は&lt;strong&gt;束縛&lt;/strong&gt;を表す。束縛は、名前（黒丸）と実体（値、大きめの白丸）の結び付きを意味する。名前は（黒丸より）赤い辺に乗る&lt;em&gt;辺ラベル&lt;/em&gt;と考えたほうがいいときもある。

左の束縛（赤矢印）で、名前mが名前空間コンテナーに束縛されている。名前空間コンテナーと名前空間を結ぶ辺は&lt;strong&gt;名前空間ソート&lt;/strong&gt;と呼ぶ。現在、modules, types, commands, classesなんてソートがある。

名前空間（四角の枠）の内部は束縛（赤矢印）の集まり。名前空間＝束縛セット。型やコマンドの場合、名前に束縛されている実体は式（expression）で、式の中から参照辺（黒矢印）が出る。参照辺には、内部参照と外部参照がある。図で、xやyは外部の名前。

黒丸と黒丸を結ぶ青い矢印はエイリアス辺。エイリアスは、名前を別な名前と結びつける。エイリアスも束縛っちゃ束縛だが、通常の束縛とは区別したほうがいい。通常の束縛は名前空間の中での結び付きだが、エイリアスは直接に外に飛び出す。dからyへの青矢印がその例だ。

典型的な名前空間コンテナーはモジュール。「モジュールは名前空間」という言い方もするが、厳密には間違い。モジュールは名前空間コンテナーで、「型の名前空間（types）」「コマンドの名前空間（commands）」「クラスの名前空間（classes）」などを持つ。

名前空間それ自体は名前を持たないので、親であるコンテナーの名前で代用する。m.types.a は m:a というコロンドットパスでアクセスされるので、モジュール名が型名前空間の名前（の代用）となる。このことから、同じコンテナに含まれる異なる名前空間をコロンドットパスでは区別できない、という問題が発生する。が、深刻ではない。

&lt;hr&gt;

まーともかく、モグラの定義を細部までハッキリさせればレイフィケーションは出来て、メタプログラミング環境も出来る。

</body>
</day>
<day date="2012-06-29" title="">
<body>
*1340943104*[圏一般論][モナド][リンク]DESCENT FOR MONADS

&quot;Descent for Monads&quot; Pieter Hofstra and Federico De Marchi て論文。33ページあったんで、2upで印刷したら字が小さくてヨメン、という不始末。

- http://www.tac.mta.ca/tac/volumes/16/24/16-24abs.html

pdfは、http://www.tac.mta.ca/tac/volumes/16/24/16-24.pdf 。


</body>
</day>
<day date="2012-07-02" title="">
<body>
*1341221525*[映画]『V』

ハッカー集団アノニマスのビデオを見ていて、『Vフォー・ヴェンデッタ』（V for Vendetta）って映画を思い出した。あの仮面はガイ・フォークスだそうだ。

- &lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/V%E3%83%95%E3%82%A9%E3%83%BC%E3%83%BB%E3%83%B4%E3%82%A7%E3%83%B3%E3%83%87%E3%83%83%E3%82%BF_(%E6%98%A0%E7%94%BB)&quot;&gt;Wikipedia Vフォー・ヴェンデッタ (映画)&lt;/a&gt;

「2005年に製作されたアメリカ・イギリス・ドイツ合作映画。」 -- そんな前だっけ？ たしか渋谷クロスタワー2Fの渋谷東急だった気がする。

渋谷東急って、マイナーではないが、ちょっとクセのある作品を選んでいる感じ。『マッハ』とか『ワイルド7』も渋谷東急だった。今は『ダーク・シャドウ』やっているし。

『V』はあんまり印象がないなー。映像は少し思い出せる（特にガイ・フォークスの仮面）が、ストーリーはまったく思い出せない。

</body>
</day>
<day date="2012-07-05" title="">
<body>
*1341477503*[映画]ヒューゴの不思議な発明 at 2012-04-22

4月だった。なんで日付が分かるかというと、ズボンのポケットから半券が出てきたから。

次男は3Dを嫌がるので（http://d.hatena.ne.jp/m-hiyama/20120622/1340349620）、最近は長男と行くかひとり。寂しい。

『ヒューゴの不思議な発明』は長男が見たい、と言い出した。そういえば、『TIME／タイム』とか『リアル・スティール』も長男が見たい、と。同時期に『アーティスト』という“映画の映画”をやっていたが、『ヒューゴの不思議な発明』も&quot;映画の映画”。ジョルジュ・メリエスという実在の人物が出てくる。月の目玉に弾丸が刺さった絵は僕も見たことがある。実話を少し混ぜたお伽話ってところだ。

映画館は「ヒューマントラストシネマ有楽町」、ヒューマントラストは渋谷にもあって、なんかゾンビ映画、あー『ゾンビランド』（ビル・マーレイが自分役で出演）とかデンゼル・ワシントンの『ザ・ウォーカー』とか『アイアンマン 2』とか見た。渋谷のヒューマントラストはけっこうよく行っているな。昔は、子供たちと渋谷児童会館にもしょっちゅう行ったし。

</body>
</day>
<day date="2012-07-06" title="">
<body>
*1341546988*[映画]MIB3

MIB3っていうと、SNMP（Simple Network Management Protocol）version 3のMIB（Management Information Base）だと思うだろうが（思わないか）、映画『メン・イン・ブラック3』だよ。

これも見た。缶コーヒーBOSSの「宇宙人ジョーンズの地球調査シリーズ」でお馴染みのトミー・リー・ジョーンズ、それとウィル・スミス。

最後がけっこう泣かせる話になっている。普通にいい話だわな。

なんか過去の映画を思い出そうとしてるんだが、『カウボーイ＆エイリアン』てわけわからん映画も見た、と思い出した。あと、『世界侵略：ロサンゼルス決戦』。はるか前に『G.I.ジョー』とか。それと、「恋人は殺し屋だった」ネタのアクションロマンス、これが&lt;em&gt;思い出せない&lt;/em&gt;。

*1341549257*[Caty][用語法]Webに関する概念と用語

いろいろと増えて、重複や曖昧さがある。○がついてるのは普通の言葉。△は普通の意味を変えている。

+ リソースクラス
+ リソースインスタンス
+ リソースインスタンス・ストレージ
+ クエリーパラメータ ○
+ セグメントパラメータ
+ リクエストボディ ○
+ アクション
+ アクション・エントリーポイント
+ アクション・エントリーポイントID
+ インボーカー
+ （遠隔）アクションコール
+ （遠隔）アクションインボケーション
+ トリガー
+ （リンクの）ターゲット
+ エンドポイント △
+ アンカー △
+ ウィジェット △

最近考えていいと思っている概念・用語は &lt;em&gt;&lt;b&gt;リソースマトリックス&lt;/b&gt;&lt;/em&gt;。


</body>
</day>
<day date="2012-07-07" title="">
<body>
*1341635897*[Caty][用語法]またしても概念と用語：主にハイパーリンク関係

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120706/1341549257&quot;&gt;Webに関する概念と用語&lt;/a&gt;」にいくつか書いたけど、もっとある。色々ある。

ハイパーリンクは難しい（http://d.hatena.ne.jp/m-hiyama/20100901/1283312114）と嘆いたことがあるけど、今まで、ほとんどマトモな定式化はなかったんじゃなかろうか。定式化に際して新しい概念が目白押しになるのも致し方ない。

ハイパーリンク、ハイパーメディアはまー普通の意味で使う。個別性／具体性を強調するときは、ハイパーメディア・オブジェクト、ハイパーメディア・データ、ハイパーメディア・インスタンスとか言うこともある。

+ ハイラップ（HyLapp）： ハイパーリンクアプリケーションの意味。ハイパースキーマが記述対象として、ハイパーバリデーションが検査対象とするのはハイラップ。ハイパースキーマのインスタンスがハイラップ。
+ ハイパー型＝ハイパーメディアクラス： ハイパーメディア・オブジェクトをインスタンスとするような型。具体的なハイパーメディア・オブジェクトの集合。ハイパー型でも、sets as types のポリシー。
+ 総称ハイパー型： パラメータを取るハイパー型だが、型パラメータだけとは限らない。サービス面が重要なパラメータとなる。具体的に定義された具体的なサービス面を与えると、総称ハイパー型が具体化されてハイパー型（集合）となる。
+ アクション： アクションaは、a:X→H というプロファイルを持つコマンド。ここで、Xは普通の型でHはハイパー型。Hがパラメータを持つときは総称アクションとなる。ほとんどの場合、アクションの定義には暗黙の総称パラメータが含まれる。
+ ハイパープロファイル：アクションが持つ X→H の形をしたプロファイル。Hはハイパー型、または総称ハイパー型。
+ アクション・エントリーポイント： 外部に公開されたエントリーポイント。通常は、URLと動詞／HTTPメソッドでエントリーポイントを識別する。エントリーポイントIDは他の命名方法もあるかもしれない。
+ CAEPS(カエプス）： Classified Action Entry Point Set。エントリーポイントの集合で、リソースクラスとリソースインスタンスによって、チャンクに直和分割されているもの。
+ サービス面（service surface）： CAEPSと同義語。外部からは一様な面で、“裏側”（サーバー側実装者の視点から）はクラスとリソースで分類されている感じ。
+ ハイパースキーマ： ハイパープロファイルが指定されたアクションの集合。アクション仕様から構成された指標。ハイパースキーマに、具体的なサービス面とアプリケーション状態空間を与えると、具体的なハイラップを生成可能となる。
+ ハイパーオートマトン： ハイラップのモデルとなるオートマトン。カエプス（サービス面）とアプリケーション状態空間と各種の遷移辺からなる。
+ ハイパーバリデーション： 与えられた具体的なハイラップが、ハイパースキーマと照合して整合的か妥当かを調べること。

*1341637721*[Caty][用語法]まだある概念と用語：主にハイパーリンク関係

+ &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120628/1340870706&quot;&gt;モグラ&lt;/a&gt;：アンビエントが持つメタオブジェクトの集合を構造化した有向グラフ。大分類して三種類のノード（名前空間コンテナ、名前空間、その他）を持つ。エイリアス辺によりツリーではないグラフとなる。エイリアス辺を除くとツリー、これはスパニングツリーを与える。
+ メタレベル作用（meta-level effect）： 式の評価が、アンビエントを変更する作用を伴うとき、その作用をメタレベル作用と呼ぶ。型やコマンドの定義が典型的。
+ リソースマトリックス： リソースクラスの情報と、リソースインスタンスセットを行列の形式で表したデータ構造。
+ リソースインスタンス・ストレージ： リソースインスタンスセットを格納する記憶媒体。今はファイルシステムを使っているが、専用のストレージが欲しいところ。
+ セグメントパラメータ： HTTPリクエストのパスの一部をパラメータと解釈したもの。
+ 状態チャンク： アプリケーション状態空間の部分集合。チャンク達は名前が付けられて、添字付き集合族となる。互いに排他的なチャンク達で状態空間は被覆される（領域分割）。チャンクをノードにしたグラフを作ると粗視化になる。
+ トラス（truss）： ハイパーリンクの束。ただし、有限個のハイパーリンク。1本のリンクは1個のトリガー（ハイパーメディア内に埋め込まれるリンク情報）と対応するので、トラスはトリガーセットだとも言える。ハイパーリンクの記述では、トラスに名前が与えられ。出現性（多重度）とターゲット（アクション・エントリーポイント）の範囲制限などが行わる。名前付きトラスセットがハイパーリンク記述となる。

藁のトラス（truss of straw）：

&lt;img src=&quot;http://www.chimaira.org/img3/Traditional_truss_of_straw.jpg&quot; &gt;

&lt;hr&gt;

&lt;span style=&quot;font-size:large&quot;&gt;新規の用語が多すぎるのは確か、後で整理して絞り込む。&lt;/span&gt;

*1341625246*[Caty]最近のCatyScriptコード

可読性に難ありだったCatyScriptもけっこう改善された。普通に読める。

最近書いたスクリプト。二百数十行、30行限界説を唱えていた頃に比べると……

&gt;||
// -*- coding: utf-8 -*-
/** 
 *
 * リソースマトリックス (Resource Matrices) の操作
 * 
 */
module resmat;

/** リソースインスタンスのパス */
type instancePath = string(remark=&quot;リソースインスタンスのパス&quot;);

/** コロンドットパス */
type cdpath = string(remark=&quot;コロンドットパス&quot;);

/** アクションのエントリーポイント
 * public:Trigger と類似している。
 *
 * inputDatatype --&gt; inputType これはTriggerも変更する。
 * paramsDatatype --&gt; paramsType これはTriggerも変更する。
 * 
 */
type EntryPoint = {
  /** エントリーポイントのURI */
  &quot;href&quot;: uri,

  /** HTTPメソッド */
  @[default(&quot;GET&quot;)]
  &quot;method&quot;: httpMethod?,
  /** 動詞 */
  @[default(&quot;&quot;)]
  &quot;verb&quot;: string?,

  /** 入力（リクエストボディ）の型 */
  @[default(&quot;void&quot;)]
  &quot;inputType&quot;: typeName?,
  /** パラメータの型 */
  @[default(&quot;EmptyObject&quot;)]
  &quot;paramsType&quot;: typeName?,

  *: any?
};

/** リソースマトリックス (Resource Matrix) */
type ResMat = {
  /** リソースのコロンドットパス 
   * アプリケーション名は除き、モジュールパス:ローカル名
   */
  &quot;resourceClassCdpath&quot; : cdpath,
  &quot;pathPattern&quot;: [string*],

  &quot;instances&quot;: [instancePath*],

  &quot;actions&quot; : {* /*アクションのローカル名*/: ActionSummary?},

};

/** アクション情報のサマリー */
type ActionSummary = {
 &quot;name&quot;: string,

  /** HTTPメソッド */
  @[default(&quot;GET&quot;)]
  &quot;method&quot;: httpMethod?,

  /** 動詞 */
  @[default(&quot;&quot;)]
  &quot;verb&quot;: string?,

  /** 入力（インレットの入力）の型 
   */
  @[default(&quot;void&quot;)]
  &quot;inputType&quot;: typeName?,
  /** パラメータ（オプション）の型 */
  @[default(&quot;EmptyObject&quot;)]
  &quot;paramsType&quot;: typeName?,
};

/** リソースマトリックス・データの置き場所 */
@[hidden]
const RES_MAT_DIR = &quot;data@this:/res-matrices/&quot;;

/**  サンプルのリソースマトリックス */
@[hidden]
const SAMPLE = {
  &quot;resourceClassCdpath&quot; : &quot;pkgFoo.modBar:CSVRes&quot;,
  &quot;pathPattern&quot;: [&quot;/csv/*.csv&quot;, &quot;/a/*.csv&quot;],

  &quot;instances&quot;: [&quot;/csv/file1.csv&quot;, &quot;/a/file2.csv&quot;],

  &quot;actions&quot; : {
    &quot;get&quot;: {
       &quot;name&quot;: &quot;get&quot;,
       &quot;method&quot;: &quot;GET&quot;,
       &quot;verb&quot;: &quot;&quot;,
       &quot;inputType&quot;: &quot;void&quot;,
       &quot;paramsType&quot;: &quot;EmptyObject&quot;,
     },
    &quot;getRaw&quot;: {
       &quot;name&quot;: &quot;getRaw&quot;,
       &quot;method&quot;: &quot;GET&quot;,
       &quot;verb&quot;: &quot;raw&quot;,
       &quot;inputType&quot;: &quot;void&quot;,
       &quot;paramsType&quot;: &quot;EmptyObject&quot;,
     },
  },

};

/** リソースマトリックスデータをセットアップする */
command setup :: void -&gt; void {
 SAMPLE &gt; sample | $.resourceClassCdpath &gt; cdpath;
 %cdpath | res-name-to-file-path &gt; path;
 %sample | json:pretty | file:write --mkdir %path
};

/** エラー時の処理（例外生成）をする */
@[hidden]
command error :: string -&gt; never {
 pass &gt; msg;
 @UnknownError {&quot;message&quot;:%msg} | throw-if-can
};

/** リソースのファイル名からCDパスに変換する */
@[hidden]
command file-name-to-res-name :: string -&gt; string {
 text:split &quot;.&quot; | [list:slice -2 -1 &gt; res-local, list:slice 0 -2 &gt; mod];
 [%mod | text:join &quot;.&quot; , %res-local | item 0] | text:join &quot;:&quot;
};

/** リソースのCDパスからファイルパスに変換する */
@[hidden]
command res-name-to-file-path :: string -&gt; string {
 text:split &quot;:&quot; | text:join &quot;.&quot; &gt; base;
 [RES_MAT_DIR, %base, &quot;.xjson&quot;] | text:concat
};

/** リソースマトリックスをロードする */
@[hidden]
command load-matrix [string res-name] :: void -&gt; ResMat {
  %1 | res-name-to-file-path &gt; path;
  xjson:read %path
};


/** 現在のリソースマトリックス名（＝リソース名）をリストする */
command list :: void -&gt; [string*] {
 RES_MAT_DIR &gt; dir;
 file:list %dir | each {pv name | file-name-to-res-name}
};

/** リソースマトリックスのインスタンスセット（配列）を取り出す */
command instances [string res-name] :: void -&gt; [instancePath*] {
 %1 &gt; res-name;
 load-matrix %res-name | $.instances
};

/** リソースマトリックスのアクションセット（オブジェクト）を取り出す */
command actions [string res-name] :: void -&gt; {*: ActionSummary?} {
 %1 &gt; res-name;
 load-matrix %res-name | $.actions
};

/** リソースマトリックスの成分（エントリーポイント）を取り出す */
command entry-point [string res-name, (string|null)? action-name, (instancePath|null)? instance] 
:: void -&gt; any/*EntryPoint | [EntryPoint*]*/
{
  %1  &gt; res-name;
  %2? &gt; action-name;
  %3? &gt; instance;

  [%action-name?, %instance?] |
  cond {
    [string, string]  =&gt; entry-point-one       %res-name %action-name %instance,
    [null,   string]  =&gt; entry-point-actions   %res-name              %instance,
    [string, null?]   =&gt; entry-point-instances %res-name %action-name,
    [null?,  null?]   =&gt; entry-point-all       %res-name,
    * =&gt; &quot;No Argument&quot; | error,
  }
};

/** エントリーポイントを作る */
@[hidden]
command make-entry-point :: [ActionSummary, string] -&gt; any/*EntryPoint*/
{
  [nth 1 &gt; action, nth 2 &gt; instance];
  [%HOST_URL, %APP_PATH] | text:concat &gt; url-base;

  {
    &quot;href&quot;: [%url-base, %instance] | text:concat,
    &quot;method&quot;: %action | $.method?,
    &quot;verb&quot;: %action | $.verb?,
    &quot;inputType&quot;: %action | $.inputType?,
    &quot;paramsType&quot;: %action | $.paramsType?,
  }
};

/** リソースマトリックスの1つの成分を取り出す */
command entry-point-one [string res-name, string action-name, instancePath instance] 
:: void -&gt; any/*EntryPoint*/
{
  %1  &gt; res-name;
  %2  &gt; action-name;
  %3  &gt; instance;

  load-matrix %res-name | [$.instances &gt; instances, $.actions &gt; actions];

  [%instances, %instance] | list:contains |
  when {
    False =&gt; [&quot;No Instance: &quot;, %instance] | text:concat | error ,
    True  =&gt;
      %actions | pv --safe %action-name |
      when {
        undefined =&gt; [&quot;No Action&quot;, %action-name] | text:concat | error ,
        * =&gt; [(%actions | pv %action-name), %instance] | make-entry-point
      }
    ,
  }
};

/** 指定されたインスタンスに対して、リソースマトリックスの列ベクトルを取り出す */
command entry-point-actions [string res-name, instancePath instance] 
:: void -&gt; any/*EntryPoint*/
{
  %1  &gt; res-name;
  %2  &gt; instance;

  load-matrix %res-name | [$.instances &gt; instances, $.actions &gt; actions];

  %actions | each {[pass, %instance] | make-entry-point}
};

/** 指定されたアクションに対して、リソースマトリックスの行ベクトルを取り出す */
command entry-point-instances [string res-name, string action-name] 
:: void -&gt; any/*EntryPoint*/
{
  %1  &gt; res-name;
  %2  &gt; action-name;

  load-matrix %res-name | [$.instances &gt; instances, $.actions &gt; actions];

  %actions | pv %action-name &gt; action;
  %instances | each {[%action, pass] | make-entry-point}

};

/** リソースマトリックスのすべての成分を取り出す */
command entry-point-all [string res-name] 
:: void -&gt; any
{
  %1 &gt; res-name;

  load-matrix %res-name | [$.instances &gt; instances, $.actions &gt; actions];

  %actions |
  each {
    pass &gt; action;
    %instances | 
    each {
      [%action, pass] | make-entry-point
    }
  }

};

// End of Module
||&lt;

</body>
</day>
<day date="2012-07-09" title="">
<body>
*1341790867*[Caty][用語法]ハイパートランジション？ トータルマトリックス、行列計算

クライアント側の状態遷移も「リンク」と呼ぶと誤解が生じる。まー、そりゃそうだ。普通、状態遷移はリンクとは言わないからね。

ハイパーリンクのトラバース（たどり）によって、その結果としてトランジションが生じるのだから、&lt;strong&gt;ハイパートランジション&lt;/strong&gt;。と、そう言えば誤解はないだろう。が、&lt;em&gt;またしても用語が増える&lt;/em&gt;。ムーー。

「ハイパーリンク」と「ハイパーメディア」って言葉はそのまま残したい。「リソース」の意義はどんどん下がってきているのだが、現状では、リソースクラスが、リソースインスタンスとアクションの編成（グルーピング）の道具。リソースインスタンス（ソースIDで識別される）は、アクションエントリーポイントをまとめる役割り。あと、いくつかのエントリーポイントに共通のデータを供給する役割りかな。

最近、リソースマトリックスという概念を考えて、これさえあれば何でも説明できると思っている。縦と横はどうでもいいのだが、今は横方向にリソースIDを並べて、縦方向にアクションを並べた方陣にしている。セルの値（行列成分）はエントリーポイント。エントリーポイントは一種の参照用ID値となる。

1つのリソースクラスから1枚（「枚」なのか？）のマトリックスができるので、アプリケーション全体としては複数のマトリックスを持つ。マトリックスの横軸のリソースインスタンスが重複することはない（互いに排他的）。よって、すべてのマトリックスの横軸＝リソースインスタンスセットを直和で並べることができる。直和で寄せ集めた全体のリソースセット（トータルセット）が、そのアプリケーションが持つリソースの全体。

マトリックスの縦軸がアクションだが、アクションも修飾名（QName、モジュール修飾＋クラス修飾）を使えば、マトリックス間の重複はない（だって、クラスが違うんだから）。よって、縦軸も直和で並べることができる。

すべてのマトリックスを、縦も横も直和で集めてデカイマトリックスを作れる。このデカイマトリックスの成分には未定義（⊥）も入れる。なんつーか、対角ブロックがあって、その対角ブロック以外は未定義。対角ブロック以外に有効値が出現するのは「なにかおかしい」。

アプリケーション全体のリソースセットとアクションセットを横軸／縦軸に配置して、成分を未定義も含めて埋めたマトリックスを、アプリケーションの&lt;strong&gt;トータルマトリックス&lt;/strong&gt;と呼ぶことにする。トータルマトリックスを見れば（解析すれば）、アプリケーションの挙動はほぼ完全にわかるはず。

アプリケーションのトータルマトリックスを単に&lt;strong&gt;アプリケーションマトリックス&lt;/strong&gt;と呼んでもいいかも。

- アプリケーションのトータルマトリックス → アプリケーションマトリックス
- リソースクラスのマトリックス → リソースマトリックス

アプリケーションマトリックスは、リソースマトリックス達を対角ブロックに並べたもの。そうなってないなら「なんかおかしい」と。行×列 と表記するなら、「アクション×インスタンス」の行列だ。アクション行の行数は有限。インスタンス列の列数も有限が望ましい。

マトリックスに対応するグラフは二部グラフなので、もとの行列と転置行列の積をとれる。これを往復行列（round-trip matrix）と呼ぶことにする。二種の往復行列が作れるが、どちらも正方行列になる。正方行列なのでクリーネ閉包が作れる。

あー、半環のε指標が使えそうだ。

+ ε(0) = 0
+ ε(x) = 1 if x≠0

なんかやっと、Webシステムの解析にグラフ理論と行列計算を適用する準備ができたような。ヨーシ、…。

*1341791206*[Caty][用語法][その他代数]さらに行列計算

トータルマトリックスは、リソースインスタンス（リソースID）セット（横軸）とアクションセット（縦軸）の上にエントリーポイントを配置したものだが、成分の値であるエントリーポイントを全部集めた集合を&lt;strong&gt;サービス空間&lt;/strong&gt;と呼ぶことにする。

通常、状態（state）と呼んでいるものは、正確には&lt;strong&gt;状態チャンク&lt;/strong&gt;。状態チャンクは状態空間の部分集合だが、直和分割を仮定して、その分割領域のひとつをチャンクと呼ぶ。

チャンクの集合（直和分割族）とサービス空間のあいだの二部グラフを、&lt;strong&gt;インタラクション・グラフ&lt;/strong&gt;と呼ぶ。これを行列と解釈すれば&lt;strong&gt;インタラクションマトリックス&lt;/strong&gt;だ。1つのチャンクから出る辺（ハイパーリンク）の集合を適切に分割した束を&lt;strong&gt;トラス&lt;/strong&gt;（truss）と呼ぶ。結局、トラス概念も必要だ。

トラス集合とサービス空間の行列を考えることもできる。また、サービス空間と状態チャンクの行列もある。行列の横軸または縦軸として配置する集合が直和分割構造を持つとき、直和成分ごとに足し算（総和）をとって、行列のサイズを縮退（reduce）、あるいは集約（aggregate）できる。

リソースのアクション分割、アクションのフラグメント分割、チャンクのトラス分割など、分割構造はよく出てくるので、分割構造に関する総和集約もまたよく出てくる。

行列に関してよく使う操作をまとめると：

+ 総和集約
+ 再インデキシング（添字の置き換え）
+ 転置
+ 和
+ 積
+ 対角ブロック和
+ クリーネ閉包（正方行列）
+ クロネッカー積

総和集約や再インデキシングも、特別な形状の二部グラフによる積で説明可能だが。

状態チャンクの集合とサービス空間（全エントリーポイントの集合）のあいだのインタラクションマトリックスを考え、その転置との積を取ると、状態チャンクの集合の正方行列とサービス空間の正方行列ができる。それぞれ、&lt;strong&gt;基本遷移行列&lt;/strong&gt;、&lt;strong&gt;基本余遷移行列&lt;/strong&gt;と呼ぼう。これらは、インタラクション行列から作られる2つのオートマトンを記述する。片一方がクライアント側オートマトン、もう一方がサーバー側オートマトンだ。

</body>
</day>
<day date="2012-07-10" title="">
<body>
*1341888272*[Caty][モナド]総称コマンドと関手とモナドとか、あとアイレンベルグ／ムーア構成とか、色々

記法としては、通常の集合論／圏論の記法よりは、CatyScriptの構文に近い書き方をする。が、最初は一般的かつ抽象的な状況設定、すぐ後で具体的なスクリプトで書く。

&lt;i&gt;C&lt;/i&gt;は、なんか具体的な対称モノイド圏だとする。&lt;i&gt;C&lt;/i&gt;は集合圏の部分圏と仮定してもいい（別になんだっていいけど）。Monoid(&lt;i&gt;C&lt;/i&gt;) は、&lt;i&gt;C&lt;/i&gt;内のモノイドを対象として、モノイド準同型を射とする圏。もとの圏&lt;i&gt;C&lt;/i&gt;が対称モノイダルなら、そのなかでモノイド概念は意味を持つ。

L:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;C&lt;/i&gt; をリスト関手とする。&lt;i&gt;C&lt;/i&gt;が抽象的な圏だと、リスト関手つっても意味がないので、リスト関手が意味を持つ程度には具体的セッティングだとする。Catyの計算モデル圏ではリスト関手は意味を持つ（list&amp;#60;T&gt; と each&amp;#60;T&gt; :: list&amp;#60;T&gt; -&gt; T）。

自己関手Lに、リスト平坦化μとシングルトンリストηを加えてモナドにする。Caty内では、flatten&amp;#60;T&gt; :: list&amp;#60;list&amp;#60;T&gt;&gt; -&gt; list&amp;#60;T&gt; と sing&amp;#60;T&gt; :: T -&gt; list&amp;#60;T&gt; で与えられる。記号の乱用で L = (L, μ, η) と書く。CatyScriptなら次のように書ける。

&gt;||
// Listモナド

type List&lt;T&gt; = [T*];

class List {
 command flatten&lt;T&gt; :: List&lt;List&lt;T&gt;&gt; -&gt; List&lt;T&gt;;
 command sing&lt;T&gt; :: T -&gt; List&lt;T&gt;;
};
||&lt;

classに型パラメータTを付けて、それがメソッド（クラス内コマンド）に行き渡るほうが使いやすいかもしれない。

&gt;||
// Listモナド

type List&lt;T&gt; = [T*];

class List&lt;T&gt; {
 command flatten :: List&lt;List&lt;T&gt;&gt; -&gt; List&lt;T&gt;;
 command sing :: T -&gt; List&lt;T&gt;;
};
||&lt;

型パラメータの具体化が、List.sing&amp;#60;integer&gt; か List&amp;#60;integer&gt;.sing かの違いが出てくる。-- これは横道だった。

Alg(&lt;i&gt;C&lt;/i&gt;, L) を、リストモナドLの代数の圏だとする。Alg(&lt;i&gt;C&lt;/i&gt;, L) はLの&lt;strong&gt;アイレンベルグ／ムーア圏&lt;/strong&gt;（http://d.hatena.ne.jp/m-hiyama/20110930/1317376793）だ。

&lt;h5&gt;モノイドの表現&lt;/h5&gt;

Monoid(&lt;i&gt;C&lt;/i&gt;) の対象は&lt;i&gt;C&lt;/i&gt;内のモノイドだが、これは次のものから構成される。（最初に注意したように、記法はCatyScript風。）

+ 台集合 T （Tは&lt;i&gt;C&lt;/i&gt;の対象）
+ 二項演算 op :: [T, T] -&gt; T ;
+ 単位元 unit :: void -&gt; T ;

演算が単位的かつ結合的なら、3つ組 (T, op, unit) がモノイドとなる。

例えば、num:add :: [number, number] -&gt; number はモノイドを定義するが、次のように書くとハッキリするかも。

&gt;||
// NumAddモノイド

class NumAdd {
 command op :: [number, number] -&gt; number {
   num:add
 };
 command unit :: void -&gt; number {
   0
 };
};
||&lt;

モノイド概念の抽象的定義である指標（インターフェイス）は次のよう。

&gt;||
// モノイドの指標

@[signature]
class Monoid {
 command op&lt;T&gt; ::  [T, T] -&gt; T;
 command unit&lt;T&gt; :: void -&gt; T;
};
||&lt;

型パラメータTがclassに付けられるなら：

&gt;||
// モノイドの指標

@[signature]
class Monoid&lt;T&gt; {
 command op ::  [T, T] -&gt; T;
 command unit :: void -&gt; T;
};
||&lt;

NumAddは、指標Monoid&amp;#60;T&gt; の型パラメータTを具体型numberで具体化しているから、

- NumAdd conforms Monoid&amp;#60;number&gt;

となる。conforms は適合性（conformance）を表しているが、&lt;strong&gt;リスコフ置換可能性&lt;/strong&gt;のこと。実装を持つクラスも指標クラス（実装なしのインターフェイス）も、振る舞い制約（CatyFITによる表明セット）とともにリスコフ置換可能性による順序構造を持つ。って、これも横道だった。

ともかくも、台集合がTであるモノイドは、二項演算 op :: [T, T] -&gt; T; と単位元 unit :: void -&gt; T; で表現される、ってこと。

&lt;h5&gt;アイレンベルグ／ムーア代数&lt;/h5&gt;

リストモナドLに限定して言うと、a:L(T)→T という&lt;i&gt;C&lt;/i&gt;の射がある条件を満たすとき、(T, a) を、Lの&lt;strong&gt;アイレンベルグ／ムーア代数&lt;/strong&gt;（あるいは単に&lt;strong&gt;代数&lt;/strong&gt;）と呼ぶ。CatyScriptで書けば：

&gt;||
// アイレンベルグ／ムーア代数

@[signature]
class EMAlg {
  command em-op&lt;T&gt; :: List&lt;T&gt; -&gt; T;
};
||&lt;

あるいは、

&gt;||
// アイレンベルグ／ムーア代数

@[signature]
class EMAlg&lt;T&gt; {
  command em-op :: List&lt;T&gt; -&gt; T;
};
||&lt;

&lt;h5&gt;モノイドとアイレンベルグ／ムーア代数の相互変換&lt;/h5&gt;

圏&lt;i&gt;C&lt;/i&gt;に対して、Monoid(&lt;i&gt;C&lt;/i&gt;) と Alg(&lt;i&gt;C&lt;/i&gt;, L) は圏同値であることが知られている。つまり、Monoid(&lt;i&gt;C&lt;/i&gt;) と Alg(&lt;i&gt;C&lt;/i&gt;, L) は事実上同じものだ。これは、up-to-isoで互いに逆になる関手 U:Monoid(&lt;i&gt;C&lt;/i&gt;)→Alg(&lt;i&gt;C&lt;/i&gt;, L)、B:Alg(&lt;i&gt;C&lt;/i&gt;, L)→Monoid(&lt;i&gt;C&lt;/i&gt;) がある。このUとBをCatyScriptで書き下してみる。

まず、B:Alg(&lt;i&gt;C&lt;/i&gt;, L)→Monoid(&lt;i&gt;C&lt;/i&gt;) のほうが簡単だから先にやる。アイレンベルグ／ムーア代数にモノイドを対応させる関手がBだが、関手Bの対象対応の部分 |Alg(&lt;i&gt;C&lt;/i&gt;, L)|→|Monoid(&lt;i&gt;C&lt;/i&gt;)| だけを考えると、二項演算opと単位元unitからアイレンベルグ／ムーア演算em-opを作ればよい。

CatyScriptは本物の高階引数は取れないから、代わりに演算の名前（文字列）を引数にする。

&gt;||
// アイレンベルグ／ムーア代数の演算から二項部分だけを取り出す
  
type operator = string(remark=&quot;高階引数の代わりに使う演算名の文字列&quot;);

command binary-part&lt;T&gt; [operator em-op /* em-op :: List&lt;T&gt; -&gt; T */] :: [T, T] -&gt; T {
  pass &gt; in;
  %1   &gt; em-op;
  
  %in | call %em-op
};
||&lt;

pass &gt; in; %1   &gt; em-op; が、CatySriptの鬱陶しい部分が出てしまっているが、まー定義は簡単だ。

逆向きの関手は、二項演算opと単位元unitから、em-op :: List&lt;T&gt; -&gt; T を作ればいいが、List&lt;T&gt; -&gt; T の形の演算を&lt;strong&gt;unbiased演算&lt;/strong&gt;と言うので、「二項演算 → unbiased演算」の高階コマンド（もどき）を定義する。

&gt;||
type operator = string(remark=&quot;高階引数の代わりに使う演算名の文字列&quot;);

command unbiased&lt;T&gt; [operator op /* op:: [T, T] -&gt; T*/, T unit] :: [T*] -&gt; T {
 pass &gt; in;
 %1   &gt; op;
 %2   &gt; unit;

 %in |
 cond {
   [] =&gt; %unit,
   [T] =&gt; nth 1, /* (A) */
   [T, T] =&gt; call %op, /* (B) */
   * =&gt;
     pass &gt; in2 | [nth 1, nth 2] | call %op &gt; bin-result;
     [[%bin-result],  (%in2 | list:slice 2)] | list:concat &gt; rest;
     %rest | unbiased&lt;T&gt; %op %unit /* (C) */
   ,
 }
};
||&lt;

実は、これは現状では&lt;em&gt;動かない&lt;/em&gt;。(A), (B), (C) と書いてあるところが動かない原因。動くように手直しすると：

&gt;||
kind LowerAny = lower any;

command unbiased&lt;T in LowerAny default any&gt; [operator op /* op:: [T, T] -&gt; T*/, any unit] :: [T*] -&gt; T {
 pass &gt; in;
 %1   &gt; op;
 %2   &gt; unit;

 %in |
 cond {
   [] =&gt; %unit,
   [any] =&gt; nth 1, /* (A) */
   [any, any] =&gt; call %op, /* (B) */
   * =&gt;
     pass &gt; in2 | [nth 1, nth 2] | call %op &gt; bin-result;
     [[%bin-result],  (%in2 | list:slice 2)] | list:concat &gt; rest;
     %rest | call u:unbiased %op %unit /* (C) */
   ,
 }
};
||&lt;

これはちゃんと動く（結果オーライだ）が、型パラメータの処理は不十分。コマンドの定義体であるスクリプトコード内に出現する型パラメータ参照が処理できてない。しょうがないので、定義体で型パラメータを使うのはやめて、anyで代用している。(C) が call u:unbiased %op %unit となっているのは現在の制限回避の書き方で、そのうち、unbased %opt %unit と書けるだろう。

&lt;h5&gt;型スキーム、コードスキームと総称コマンド&lt;/h5&gt;

List&amp;#60;List&lt;T&gt;&gt; とか List&amp;#60;T&gt; -&gt; T のように、型パラメータを含む型表現を&lt;strong&gt;型スキーム&lt;/strong&gt;と呼ぶことがある（http://d.hatena.ne.jp/m-hiyama/20120405/1333608868）。構文上、型パラメータと定義済み型名の区別はできないので、どれが型パラメータかを明示する必要がある。式のなかのパラメータを特定することはラムダ抽象と似ているので、大文字ラムダを使うことにすると：

- Λ&amp;#60;T&gt;.List&amp;#60;List&lt;T&gt;&gt; 
- Λ&amp;#60;T&gt;.(List&amp;#60;T&gt; -&gt; T)

(List&amp;#60;T&gt; -&gt; T) は指数型だが、Catyでは&lt;strong&gt;プロファイル&lt;/strong&gt;と呼んで通常の型とは別な扱いにしている（指数型を正式には認めてない）。よって、二番目はプロファイル・スキームとでも呼ぶべきだが、型スキームでもいいや。

型スキームは、型パラメータを持った型表現（またはプロファイル）だが、型パラメータを持ったスクリプトコードという概念がある。これは&lt;strong&gt;コードスキーム&lt;/strong&gt;と呼ぶことにしよう。コードスキームは、型名を変数（プレースホルダー）に持つテンプレートとかマクロとか言ってもいいが、いわゆる「テンプレート」以外の実現方法もある。

「プロファイルにも定義体のコードにも型パラメータを含んだコマンド」が、&lt;strong&gt;総称コマンド&lt;/strong&gt;。現在、プロファイルに出現する型スキームの具体化には対応してるが、定義体がコードスキームになる場合がサポートされてない。

総称コマンドでは、プロファイル（例外やシグナルの宣言も含む）が型スキームになっていて、定義体はコードスキームになっている。実行の前に、型スキームを具体化して具体型に、コードスキームを具体化して具体コードにする必要がある。コンパイル時に具体化するのが望ましいが、実行時型引数があると、実行時まで具体化できないこともある。

コードスキームに登場する型パラメータ参照を発見・特定しなくちゃならんが、cmd&amp;#60;Type&gt; の形以外に、case と cond の分岐条件部分に型パラメータが出現する可能性がある。とはいえ、出現位置は決まっているので、発見・特定が困難ということはない。

&lt;h5&gt;圏論とCatyScript&lt;/h5&gt;

&lt;i&gt;C&lt;/i&gt;をCatyの計算モデル圏とすると：

- CatyScriptの型 ＝ &lt;i&gt;C&lt;/i&gt;の対象
- CatyScriptのコマンド ＝ &lt;i&gt;C&lt;/i&gt;の射

となる。コマンドとスクリプトはあまり区別する必要はない（名前のあるなし程度）。

型パラメータTを含む型関数、例えば Λ&amp;#60;S, T&gt;.[S, T]、Λ&amp;#60;T&gt;.[T*] とかは、&lt;i&gt;C&lt;/i&gt;の対象に対象を対応させるので、通常は自己関手の対象部分として使う。

コマンドにコマンドを対応させる高階コマンドは、CatyScriptに正式にはないが、コマンド名文字列を引数にするコマンドで代用できる。これで、関手の射部分を書ける。例えば：

&gt;||
class List {
 // ...
 command map&lt;T&gt; [string cmd] :: List&lt;T&gt; -&gt; List&lt;T&gt; {
  each {call %1}
 };
};
||&lt;

このList.mapは、型パラメータTを持っているので、cmd :: A -&gt; A を (map&amp;#60;A&gt; cmd) :: List&amp;#60;A&gt; -&gt; List&amp;#60;A&gt; に移している。つまり、自然変換。通常、自然変換の下付き添字として書く対象が、総称コマンドの型パラメータとして現れる。

まとめると：

+ 型関数 ： 関手の対象部分
+ 高階コマンド ： 関手の射部分
+ 総称高階コマンド ： 自然変換

となる。もちろん、関手と自然変換以外の定義に総称や高階モドキを使ってもいい。

かなりのところ総称をサポートしているのに、指数型や高階コマンドを正式サポートしないのは中途半端だが、切実な必要性がないなら&lt;em&gt;やらない&lt;/em&gt;。

</body>
</day>
<day date="2012-07-11" title="">
<body>
*1341961047*[Caty]helpアプリケーションの作り方

Catyの内部構造を知っている人間はごく少数（約二名）だから、それについてここで書いてもしょうがない気もするが、いずれ知っている人が増えることを期待して …。

まず、mafsは、ストレージ・バックエンドがなんであっても同じインターフェイスを提供することを目的にしている。通常のファイルシステムはもちろん、KVSやRDB、ネットワーク越しの他のサーバー（S3みたいな）に対してもmafsは作れるはず。単一のJSONファイルをファイルシステムとみなすjsonfsなんて構想もある。インメモリストレージ（例えば単一のPython dict）をmafsにすることも考えられる。

モグラ（MOGra）はインメモリのグラフ構造だが、リードオンリーのストレージとみなすことができるから、リードオンリーmafsとしてアクセスできるはず。mafsパス名をモグラのグラフパス（CDパス＋ノード種別）にマップしなくてはならないが、今でも一応のマッピングルールはある。/foo.prj.apps/myapp.app.mods/bar.mod.typs/MyType.typ は、myapp::bar:MyType as type にマップされる（ちょっと鬱陶しいマップだ）。

ところで、アプリケーションマニフェスト（_manifest.xjson）に、assignて項目があり、現状なんだか無意味な設定になっている。

&lt;pre class=&quot;code&quot;&gt;
    &quot;assign&quot;: {
        &quot;behaviors&quot;: &quot;behaviors&quot;,
        &quot;commands&quot;: &quot;commands&quot;,
        &quot;messages&quot;: &quot;messages&quot;,
        &quot;actions&quot;: &quot;actions&quot;,
        &quot;schemata&quot;: &quot;schemata&quot;,
        &quot;pub&quot;: &quot;pub&quot;,
        &quot;scripts&quot;: &quot;scripts&quot;,
        &quot;include&quot;: &quot;include&quot;,
        &quot;data&quot;: &quot;data&quot;
    },
&lt;/pre&gt;

だが、廃止しないで残してきたのは、いつか使うと思ってだ。

pubにアサインされるファイルシステムがWebに公開される。だから、pubに標準以外のファイルシステムをアサインすれば、それがWebから見える。例えば、単一JSONファイルに対応するjsonfsがあって、そのjsonfsファイルシステムをpubにアサイン（マウント）すると、JSONファイルの中身がWebに公開される。

同様に、インメモリストレージとしてのモグラをバックエンドとするファイルシステムmografsがあったとして、このmografsをpubにアサインすると、ほとんど何もしなくてもhelpアプリケーションができるわけだ（表示用テンプレートは必要だけど）。

通常、Catyにアサイン（マウント）されているファイルシステム（プレース）は相当な数になるが、これらのバックエンドが通常ファイルシステムである必要はない。リモートストレージからインメモリストレージまで、なんでもいい。適切にmafsドライバーを作れば、Webアプリケーションを作る労力を減らせる。特に、読み込み専用ストレージの場合は、GETに対してファイル内容を返すだけなので、pubにマウントしただけで（表示テンプレートを書けば）Webアプリケーションになる。

直接XJSONをIOするには、mafsのread, writeを、今のxjson:read, xjson:writeのようにする必要があるが、そういう拡張をすれば、(X)JSONストレージとmafsを同じインターフェイスで扱えるかもしれない。


</body>
</day>
<day date="2012-07-12" title="">
<body>
*1342074861*[映画]ダーク・シャドウ

http://d.hatena.ne.jp/m-hiyama-memo/20120702/1341221525 ：

&gt;&gt;
渋谷東急って、マイナーではないが、ちょっとクセのある作品を選んでいる感じ。『マッハ』とか『ワイルド7』も渋谷東急だった。今は『ダーク・シャドウ』やっているし。
&lt;&lt;

渋谷東急では終わっていたので、渋谷シネパレスに行った。午後８時からの１回かぎり。

ジョニー・デップ×ティム・バートンの映画は、1990年『シザーハンズ』と1999年『スリーピー・ホロウ』を観たことがある。バットマンシリーズで、1989年『バットマン』、1992年 『バットマン・リターンズ』、1995年『バットマン・フォーエヴァー』のどれか1つは見てると思う。そういえば、一時、バットマンのTシャツ着てるヤツ多かったよなー。1990年の前後だったのか。

1993年『ナイトメアー・ビフォア・クリスマス』は、子供たちと行った映画の予告で見たような記憶があるが、それはオカシイ。1993じゃ、子供達は生まれてない。つい最近のことのように思えるのだが、記憶の錯覚だ。『ナイトメアー・ビフォア・クリスマス』はアニメだが、ティム・バートンて「ディズニーのアニメーターとして『トロン』（TRON）などに参加」だったんですか、フーン。

今思い出したが、2004年の『ポーラー・エクスプレス』は確実に子供と観たはず。これもアニメ、『バック・トゥ・ザ・フューチャー』のロバート・ゼメキスが監督。

『チャーリーとチョコレート工場』はテレビ放送されて、それをちらっと観た。これ、2005年か。JR渋谷と東急東横線を結ぶ通路のところに貼り紙があったのを覚えている。「これ、見ようか」と思ったのだった、あれから7年もたっている。ウーン。

『ダーク・シャドウ』に戻ると、魔女役のエヴァ・グリーンがめちゃくちゃに色っぽくて良かった。ヒロインとも言えるヴィクトリアとジョゼットの二役をやった女優さんベラ・ヒースコートは、なんかイマイチ印象が薄い。設定が1970年代で、カーペンターズの曲（「トップ・オブ・ザ・ワールド」とか）を使っていたのが懐かしい。

&lt;b&gt;[追記]&lt;/b&gt; 

&gt;&gt;
1993年『ナイトメアー・ビフォア・クリスマス』は、子供たちと行った映画の予告で見たような記憶があるが、それはオカシイ。1993じゃ、子供達は生まれてない。つい最近のことのように思えるのだが、記憶の錯覚だ。
&lt;&lt;

いや、そうじゃないかも。Wikipediaを見ると、

&gt;&gt;
2006年にはデジタル3D化されたバージョンが製作、シネマイクスピアリで劇場公開されている。
&lt;&lt;

これだったのかもしれない。

&lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2012-07-17" title="">
<body>
*1342480224*[Caty]CatyScrpiptが読みやすいと感じるとはコレ如何に

エソラングっぽいと思っていたCatyScriptだが、“慣れ”とは恐ろしいもので読みやすく感じる。余りにもバイアスがあるから、客観的にreadableなモノなのかどうか？ の判断は付かない。

まだ実装してない begin/repeat を使った例（自己forward版は実際に動かしている）。“慣れ”だけじゃなくて、以下のclientコマンドのコードは直前に書いた&lt;em&gt;日本語のコメントそのまま&lt;/em&gt;のように読めるが、やっぱりバイアス入ってる？

&gt;||
command stop :: void -&gt; never {
 forward void
};

/** クライアントの振る舞いをエミュレートする 

クライアント（とそのアクター）は次のことを行う。

# まず、受け取ったハイパーメディア・オブジェクトから、適当なトリガーを選ぶ。
# うまく選べなかったときはオシマイ。
# 選んだトリガー（例えばHTMLフォーム）に対する適切な値セットを生成する。
# トリガーが指し示すターゲットに対して、値セットを使ってリクエストを実行する。
# リクエストの結果であるハイパーメディア・オブジェクトを受け取り、また最初から繰り返す。

*/
command client :: GeneralHyperMedia -&gt; never {
 begin {
   select-trigger |
   when {
     undefined ==&gt; stop,
     *         ==&gt; pass,
   } &gt; selected-trigger |
   generate-request-values &gt; request-values;
   [%selected-trigger, %request-values] | exec-request | repeat
 }
};
||&lt;

*1342485762*[Caty]トリガーが難しいワケ、力学とのアナロジー

ずっと以前から、ハイパーメディアに関して「トリガー」という言葉と概念を使っている。「ハイパーリンク」とか「アンカー」と言わずに、あえて「トリガー」と呼んでいたのにはワケがあるのだが、どうもそのへんがうまく説明できないでいた。

ハイパーメディア・オブジェクトをレイフィケーションしてみて、事情がかなりハッキリした。トリガーは、ハイパーメディア・オブジェクトに埋め込まれた&lt;em&gt;データ&lt;/em&gt;なのだが、実は&lt;em&gt;スキーマ&lt;/em&gt;でもあった。より具体的に言うと、トリガーは「データ型定義＝値の集合」を表現するデータなのだった。HTMLフォームなどを考えれば、まー明らかといえば明らかだが。

対話の状態を表す状態空間をAとして、Xがサービス空間（エントリーポイント全体の集合）のとき、A×V→X という非決定性写像がリクエストを表現するが、トリガーは、(a, W, x) （a∈A、W⊆V、x∈X）の3つ組だったのだ。トリガーのインスタンスにはWという集合が入る。だから、トリガーの集合には「集合の集合」が含まれることになる。つまり、トリガー型はカインドのようなものになる。

意味的には、トリガーインスタンスは型で、トリガー型は高階型だったのだ。だから分かりにくい。メタオブジェクトやレイフィケーションを普通に使えるようにならないと、ここらへんの状況を正確に掴まえるのは難しいだろう。

逆に言えば、ハイパーメディアの機能と構造をちゃんと理解したいなら、メタオブジェクト、レイフィケーション、高階型などに慣れないとダメだ。ハイパーメディアを出力する関数（我々の言葉ではアクション）は、トリガー（の集合）を出力するのだから、型の集合を戻り値としていたわけだ。&lt;em&gt;高階データを戻り値にするような高階関数だった&lt;/em&gt;のだ。

アクションの出力は、高階データだが、それは実は、状態遷移系の半遷移を担うチャンクでもある。状態遷移系がファイバー束のような構造を持つので、一点の上のファイバー（の部分空間）を出力していたのだ。ファイバー方向の自由度の記述がトリガーだった。

力学とのアナロジーで言えば、トリガーは一点に付随する接空間（余接空間か？）の部分空間のようなものだ。運動にともなって、運動の可能性である局所空間が登場して、全体としてファイバー構造を定義する。http://en.wikipedia.org/wiki/Distribution_%28differential_geometry%29 と似た感じだ。

1個のトリガーは、基点と遷移ラベルの集合（全ラベルの集合の部分集合）、それとターゲットの組となる。遷移ラベルの集合＋ターゲットが、接空間の部分集合に相当する。トリガーが複数なら、複数の部分集合が登場するからそれらの合併を取る。

- トリガー  ⇔ 接空間の部分集合
- リクエスト ⇔ 接ベクトル
- リクエストの実行 ⇔ 接ベクトルに沿った移動
- レスポンス ⇔ 移動後の接空間の部分集合

この接バンドルとのアナロジーはかなり良い。力学的で分かりやすい。接ベクトル空間（の部分集合）は、可能な無限小移動の候補（これがトリガー）となる。実際の無限小移動（リクエスト）を行うと、“次の”接ベクトル空間（レスポンスのハイパーメディア）が登場する。

*1342501429*[Caty]コマンドの実行データと実行方式

コマンドのクロージャとよく似たデータだが、次のようなデータを考える。

&lt;pre class=&quot;code&quot;&gt;
{
  &quot;arg0&quot;: univ,
  &quot;args&quot;: [univ*],
  &quot;opts&quot;: {*:univ?}(propNameFormat=&quot;name&quot;),
  &quot;additionalEnv&quot;: {*:univ?}(propNameFormat=&quot;name&quot;),
  &quot;input&quot;: univ
}
&lt;/pre&gt;

注意：arg0とargsを一緒にしたのがargvだが、argv[0], argv[1:] と分解するのがメンドイので最初から別にしておく。ただし、%1がargs[0]となり番号がずれる。この点では、argv[1]と書いたほうが良い。

このJSONオブジェクトの各プロパティを同名の変数に代入した状況で考える。つまり、%arg0 とかでプロパティ値を参照できる。他に、%cmd にコマンドの名前（環境に依存しないようにフルネームが望ましい）が入っているとする。

このとき、与えられた実行データ（クロージャの変種）のもとでコマンドを実行するには次のようにする。

- &lt;b&gt; %input? | [%additionalEnv, pass] | unclose {call %cmd --0=%arg0? %--*opts %#args} &lt;/b&gt;

このパイプラインを説明する。動的なコマンド実行には、このパイプラインが絶対に必要となる。（このパイプラインに相当する単一コマンドを準備してもいいけど。）

&lt;h5&gt;unclose&lt;/h5&gt;

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20110920/1316512670&quot;&gt;try-catchの双対となる構造&lt;/a&gt;」で説明している。追加する環境変数を表すオブジェクトと標準入力を受け取って、ブロック内を新しい環境変数セットのもとで実行する。

&lt;h5&gt;--0=%arg0?&lt;/h5&gt;

コマンドにarg0を渡すにはこうする。arg0がundefinedだと例外を起こすので、'?'を付けておく。'?'があれば、&lt;em&gt;値としての#'undefined&lt;/em&gt;がarg0に入る。

&lt;h5&gt;%--*opts&lt;/h5&gt;

現在でも、%--foo のような構文が使える。これは、--foo=%foo? と同値だが短く書けて便利。

%obj がオブジェクトを値とする変数として、%--*obj は、%obj をコマンドラインオプションとしてコマンドに渡すことを指示する。%objが空（{}）なら、オプションが指定されなかったと同じだし、定義されてないオプションと同名のプロパティがあればエラーとなる。定義されている名前でも型エラーは起こりうる。

例えば、%obj が {&quot;safe&quot;: true, &quot;default&quot;: null} のとき %cmd %--*obj は次のように展開される。

- %cmd --safe=true --default=null

ただし、コマンドラインを文字列として操作するような（危険でまどろっこしい）方法は使わない。データ構造をそのままコマンド・クロージャにコピーする。

なお、%--* と変数名を省略した場合は、%_OPTS が使われる。

&lt;h5&gt;%#args&lt;/h5&gt;

%--*opts と同様だ。%arrが配列を値とする変数のとき、配列のすべての項目がコマンドライン引数として展開される。例えば、%arr が [&quot;hello&quot;, &quot;world&quot;] のと、%cmd %#arr は、

- %cmd hello world

%arrが歯抜け配列である場合もサポートする。

なお、%# と変数名を省略した場合は、%_ARGV の1以上のスライスが使われる。%_ARGV の1以上のスライスを %_ARGS とするなら、%#_ARGS と書けるが、%_ARGS は自動的に定義はされない（%_ARGVで間に合うので）。

*1342514430*[Caty][後で消す]絵、明日

絵を描いたが、説明を書くのが億劫。明日とかに。

&lt;img src=&quot;http://www.chimaira.org/img3/trigger-semitrans.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img3/trigger-truss.gif&quot; &gt;

</body>
</day>
<day date="2012-07-18" title="">
<body>
*1342577562*[Caty]絵、今日

絵を描いたので、今日中に説明を書く。

いやー、さらに先延ばしかな。でも、下に別な記事を書いた。

&lt;img src=&quot;http://www.chimaira.org/img3/trigger-semitrans.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img3/trigger-truss.gif&quot; &gt;


&lt;img src=&quot;http://www.chimaira.org/img3/Traditional_truss_of_straw.jpg&quot; &gt;

*1342601303*[Caty]ローカルトリガーとハイパーメディア・アプリケーション

Catyの型システム／コマンドシステムの機能を総動員すると、&lt;em&gt;Webを使わないハイパーメディア・アプリケーション&lt;/em&gt;のハイパースキーマが完全に書ける。つうか先週末に書いてみた。その解説をする。ここ2,3日で定義を変えたりしたところもあるが、オリジナル（つっても4日前）のモノをモトに説明。

まず、通常のトリガー＝Webトリガーの場合、本質的なデータ項目は：

+ &quot;href&quot;: uri,
+ &quot;verb&quot;: string?,
+ &quot;method&quot;: httpMethod?,

これによって、ターゲットのサービスエントリーポイント（アクションだと思ってよい）を特定できる。

サービスエントリーポイントへの入力データは次のようだった：

+ &quot;inputType&quot;: typeName?, （旧inputDatatypeからリネーム）
+ &quot;paramsType&quot;: typeName?,（旧paramsDatatypeからリネーム）

これは&lt;em&gt;いくらなんでも不十分&lt;/em&gt;。値に reif:TypeExpr を使えれば万全だが、現状いきなり reif:TypeExpr は使えない。そこで次の型を使う。

- (@typeName string(format=&quot;name&quot;) | @data any | reif:TypeExpr)

reif:TypeExprはタグ付き型のユニオンで、@typeName, @data というタグは含まれないので、上記の型は合法となる。将来的には reif:TypeExpr に移行する予定として、&lt;em&gt;当面は、@typeName と @data を使う。&lt;/em&gt;

+ @typeName string(format=&quot;name&quot;) ： 文字列による型の名前。例： @typeName &quot;mymod:MyType&quot;
+ @data any ： データリテラルによる固定値

reif:TypeExprが使えれば、@typeName は型の参照で、@data はシングルトン型で表現可能となる。

&lt;h5&gt;ローカルトリガーのスキーマ&lt;/h5&gt;

さて、ローカルトリガーの話だが、とりあえずスキーマを出して、その後で説明を追加する。

&gt;||
module u; // モジュール名は仮


/* ローカル呼び出し／フォーワードを実際に行うためのデータ
 */
type LocalRequest = @* {
  /** コマンドのコロンドットパス */
  &quot;target&quot;: string(format=&quot;cdpath&quot;),

  &quot;arg0&quot;: univ, // undefinedにもなることに注意
  &quot;args&quot;: [univ*],
  &quot;opts&quot;: {*: univ?}(propNameFormat=&quot;name&quot;),
  &quot;additionalEnv&quot;: {*: univ?}(propNameFormat=&quot;name&quot;),
  &quot;input&quot;: univ, // undefinedにもなることに注意
  
  *: any?
};

/** リクエストの実行 
 * ダミー
 */
command exec-request :: LocalRequest -&gt; univ {
 [
   $.target &gt; target,
   $.arg0?  &gt; arg0,
   $.args   &gt; args,
   $.opts   &gt; opts,
   $.additionalEnv  &gt; additionalEnv,
   $.input? &gt; input,
 ];
 // %input? | [%additionalEnv, pass] | unclose {call %target --0=%arg0? %--*opts %#args
 do {
   %input? | [%additionalEnv, pass]  &gt;: &quot;envInput&quot;,
   [%target, %arg0, %opts, %args]    &gt;: &quot;params&quot;,
 }
 
};

/* 値の制約 
 * 当面、reif:TypeExpr は使わない。
 */
type ValueConstraint = (@typeName string(format=&quot;name&quot;) | @data any /*| reif:TypeExpr */);

/* ローカル呼び出し／フォーワードのためのトリガー
 */
type LocalTrigger = @* {
  /** コマンドのコロンドットパス */
  &quot;target&quot;: string(format=&quot;cdpath&quot;),

  &quot;arg0&quot;: ValueConstraint,
  &quot;args&quot;: ValueConstraint | [ValueConstraint*],
  &quot;opts&quot;: ValueConstraint | {*: ValueConstraint?}(propNameFormat = &quot;name&quot;),
  &quot;additionalEnv&quot;: ValueConstraint | {*: ValueConstraint?}(propNameFormat = &quot;name&quot;),
  &quot;input&quot;: ValueConstraint,
  
  *: any?
};

||&lt;

&lt;h5&gt;リクエスター、リクエストデータ、トリガー&lt;/h5&gt;

クライアントはソフトウェアロボット（クライアント役の妖精さん）と考えると分かりやすい。実際、マゾ・テストでは、ロボット（妖精さん）を使う。

クライアントのなかに、&lt;strong&gt;リクエスター&lt;/strong&gt;という部分がある（と考えよう）。リクエスターはリクエストデータ（上記スキーマのLocalRequestのインスタンス）を受け取って、実際にリクエストを発行する。コマンド exec-request がリクエスターの実装だと思ってよい。ただし、ダミーで動かないが。

LocalRequest型のインスタンスがあれば、リクエストを発行できる。だが、ハイパーメディア・オブジェクトにリクエストデータが直接入っている&lt;em&gt;わけではない&lt;/em&gt;。&lt;strong&gt;トリガー&lt;/strong&gt;（LocalTrigger）がハイパーメディア・オブジェクトに埋め込まれている。トリガーとリクエストデータは&lt;em&gt;違うもの&lt;/em&gt;だ！（[http://d.hatena.ne.jp/m-hiyama/20120717/1342507743:title]も参照。トリガー＝form要素と考えてよい。）

トリガーというのは、「&lt;em&gt;データの形をしたスキーマ&lt;/em&gt;」なのだ。別な某プロジェクトで、「XJSONデータの形をしたスキーマのようなもの」を使っているが、アレと同じ（って、知っているのは二名）。例えば次がトリガーの例（4日前の例）。

&lt;pre class=&quot;code&quot;&gt;
{
  &quot;target&quot;: &quot;mymod:MyClz.foo&quot;,

  &quot;arg0&quot;: @typeName &quot;null&quot;,
  &quot;args&quot;: [@typeName &quot;string&quot;, @data 0],
  &quot;opts&quot;: {&quot;flag&quot;: @data true},
  &quot;additionalEnv&quot;: {},
  &quot;input&quot;: @typeName &quot;object&quot;
}
&lt;/pre&gt;

今は @typeName と @data を使っているが、プロパティ値に reif:TypeExpr を使うようになれば、ますます&lt;em&gt;トリガーがスキーマである&lt;/em&gt;ことが明らかになる。「リクエストデータ : トリガー ＝ インスタンス ： スキーマ」なのだ。

リクエスターとは別に、クライアント内に&lt;strong&gt;リクエストジェネレータ&lt;/strong&gt;なるモノもあるとしよう。リクエストジェネレータは、トリガー（一種のスキーマ）を見て、トリガーの条件を満たすリクエストデータ（インスタンス）を生成する。現状では、リクエストジェネレータに gen:sample を使っている。

+ @typeName t のとき、型の名前tを gen:sample の引数としてデータを生成する。
+ @data x のとき、xをそのままデータとして使う。

ハイパーメディア・オブジェクトに埋め込まれたトリガーを見て、リクエスト・インスタンスを生成するジェネレータが賢ければ、ソフトウェア・ロボット（妖精さん）としての精度が上がる。ジェネレータがやることは、「人間がHTMLフォームを埋めること」に相当する。ちゃんと埋められたら賢い。

&lt;h5&gt;クライアント・エミュレータ＝妖精さん&lt;/h5&gt;

クライアント役のソフトウェア・ロボットは、クライアント・エミュレータと言ってもいいだろう。何をエミュレートしているかと言うと、本物のアクター、つまり&lt;em&gt;人間のエミュレート&lt;/em&gt;である。「小人さん」「妖精さん」などと呼んでいるソフトウェア・ロボットは、だいたい人間の代理となるものだ。

クライアント・エミュレータは次のように作る。

&gt;||
/** クライアントのエミュレーション 
 */
command client [string? start-point] :: (null | HyperMedia) -&gt; never {

 // ここでトリガーを選ぶ

 // 選択したターゲットにジャンプ
 %selected-trigger | call-target-and-client-again
};

/** トリガーにより指定されたターゲットを呼び、その後、clientに再入する */
command call-target-and-client-again :: Trigger -&gt; never {

 // トリガーからリクエストデータをジェネレートして、
 // ターゲットを呼ぶ。
 // %respose に戻り値であるハイパーメディア・オブジェクト
 
 %response | forward mod:client
};
||&lt;

clientとcall-target-and-client-againをforwardで繋いでいるのは、begin/repeat構文がまだないから。begin/repeatがあれば、clientの内部で無限ループを回せばよい。そもそも、begin/repeatの主たる使い道は「妖精さん」の内部ループだ。

&lt;h5&gt;forwardの使い道&lt;/h5&gt;

begin/repeat構文があれば、forwardは要らないのだろうか？ そうではない、会員と非会員（ゲスト）の区別があるサイトで、それぞれのユーザーロールで振る舞う妖精さんを、client-as-member, client-as-guest とする。ログインしてユーザーロールが変わるとき client-as-guest の内部から client-as-member に大域ジャンプしてロールを変身することになる。

ログイン状態を保つには、クッキー送出のエミュレーションが必要になる。これは、additionalEnv で行う。環境変数の値を送ってやると、行った先の（起動された）コマンド内でその環境変数が見えることになる。コマンドは環境変数を見て挙動を変えることができる。

Web起動とローカル起動の対応関係は：

+ リクエストのエンティティボディ ⇔ 標準入力
+ クエリーパラメータ ⇔ オプション
+ リクエストURLのパス ⇔ arg0
+ リクエストヘッダ ⇔ 追加環境変数

例えば、{&quot;SECURE&quot;: true} という additionalEnv を送ると、https通信をエミュレートできる。USER_IDとかLANGUAGEなんて環境変数もよく使うだろう。

&lt;h5&gt;マルチクライアント&lt;/h5&gt;

マルチクライアントの状況をエミュレートするには、複数のエミュレータ（妖精さん）を同時に走らせる必要がある。通常のスレッド／プロセスでは重すぎて扱いにくい。軽量なグリーンスレッドが欲しい。Pythonにもグリーンスレッドの試みはあるようだし、数十個程度なら uWSGI でもグリーンスレッドをサポートしているようだ。

クライアント・エミュレータ1個に対してグリーンスレッドを1個割り当ててbegin/repeatループを回す。たくさんの妖精さん達がワサワサと動きまわる。楽しそうだ。

&lt;h5&gt;hconアプリケーション&lt;/h5&gt;

通常のWebアプリケーションとローカル（インターナル）で動くハイパーメディア・アプリケーションの中間に、hconアプリケーションがある。hconアプリケーションでは、コマンド呼び出しにhconプロトコルを使う。

hconプロトコルは、トランスポートにHTTPレイヤーを使うが直接呼び出しに極めて近い。「ローカル・アプリケーション ⇔ hconアプリケーション」の相互変換は容易だろう。
 

</body>
</day>
<day date="2012-07-20" title="">
<body>
*1342759765*[プログラム意味論][TQFT]模倣とコボルディズム

AとBが状態遷移系だとする。状態遷移系の定義にもよるが、状態点の全体が配位空間（底空間）、遷移辺の全体が接バンドル＝相空間となるような確率力学系だと思っていいだろう。

AとBの間に模倣関係があるということは、空間としてのAとBを結ぶコボルディズムMがあることじゃないのかな？ 次元が高い空間Mによって、境界であるAとBの力学が変形できる。この「力学がMに沿って変形できる」ってのがよくワカラナイのだけど、普通に考えると、M上の力学の境界値がAとB上の力学ってことだろう。それでまた「力学の境界値」がワカラナイのだけど(苦笑)。


</body>
</day>
<day date="2012-07-24" title="">
<body>
*1343101714*[論理][Caty]名前の推論

Caty名前に関する推論をCatyScriptで書くと面白いかもしれない。

*1343109186*[メモ]js2-mode のインデント

次の設定が僕好みかな。

+ (setq js2-basic-offset 2)
+ (setq indent-tabs-mode nil)

こうかな。

&gt;|lisp|
(add-hook 'js2-mode-hook
          #'(lambda ()
              (setq js2-basic-offset 2
                    indent-tabs-mode nil)
              ))
||&lt;

</body>
</day>
<day date="2012-08-02" title="">
<body>
*1343900124*[マンダラ][高次圏論][課題]なんかありそうなんだが

次のものは関係しそうだ。

+ 圏を係数とする行列
+ 豊饒圏
+ プロ関手
+ コボルディズムとTQFT
+ 単体的圏からの関手

Aが何でもいいから集合として、Δ(A) を、Aから作った（抽象的）単体的複体の圏だとする。この圏の射は退化写像と辺写像から作られたもの。次元は Δ&lt;sup&gt;0i&lt;/sup&gt;(A) = A となるように付ける。Δ(A) は次元による階数付けを持つが、高次圏も次元による階数付けを持つ。階数を保つか適当にシフトするような写像 Δ(A)→&lt;i&gt;C&lt;/i&gt; で、結合律と単位律に相当する一貫性条件を持つものは、豊饒圏や圏係数行列の概念を包含するようなものである気がする。

一般化TQFTってのを調べればいいのか？

*1343901137*[形式言語理論][XML][説明][用語法]基本的な概念

+ アルファベット
+ 列
+ 列言語
+ 列正規表現
+ 列オートマトン
+ 釣り合い列（balanced sequence）
+ ツリーアルファベット（分岐ノード記号とリーフノード記号）
+ ツリーシリアライズ
+ ツリーパターン
+ ツリー正規言語
+ 連接と包囲（enclosing）
+ 明瞭性（Bruggemann-Klein &amp; Wood）
+ トラバース双対グラフ
+ Glushkov-McNaughton-Yamada 構成
+ 縮約、集約、折りたたみ（contraction, aggregation, unfolding）
+ 模倣、双模倣

&lt;b&gt;[追記]&lt;/b&gt;

+ スタック（プッシュダウン）オートマトン
+ カウンターオートマトン
+ 明瞭性を保った縮約条件
+ 非可達ノードの除去

*1343901451*[モナド][メモ]ツリーレコードモナド

あ、そうだ。Nを名前の集合として、TreeRec&lt;sub&gt;N&lt;/sub&gt;(V) というモナドがあるんだった。

Nは固定するとして、TreeRec&lt;sub&gt;N&lt;/sub&gt;(-) が集合圏の上の自己関手で、モナドの台。単位も乗法も言われてみればあたりまえのもの。CatyScriptで書けるだろう。

</body>
</day>
<day date="2012-08-03" title="">
<body>
*1343952844*[後で消す][メモ]火曜日

火曜日は中止だ。

木曜 5:30pm→コレも変更になる？

火曜（今日）の予定はすべて中止。で、木曜が異常に忙しい。

明日（水曜）も皺寄せ。

木曜 PM5:30 = 17:30 恵比寿だが、15：10品川なら2時間以上あるか。ナントカ。

えーと、朝は10:30くらいで、待ち合わせが問題だ。
夕方は予定より早く終わるかも。あ、ダメか、歯医者があるし。






</body>
</day>
<day date="2012-08-06" title="">
<body>
*1344211094*[メモ][リンク][説明] オートマトンとかグラフとかの記事へのリンク

まったく未整理。

+ [http://d.hatena.ne.jp/m-hiyama-memo/20120802/1343901137:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110803/1312345780:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110802/1312256095:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110616/1308187709:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110521/1305936203:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110514/1305348974:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100617/1276745426:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100612/1276315149:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100612/1276316111:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100610/1276146815:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100610/1276151619:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20080925/1222320473:title]

+ [http://d.hatena.ne.jp/m-hiyama-memo/20120223/1329952382:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20110921/1316565635:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100621/1277075600:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20100610:title]
+ [http://d.hatena.ne.jp/m-hiyama-memo/20090618/1245295583:title]

+ [http://d.hatena.ne.jp/m-hiyama/20100916/1284600968:title]
+ [http://d.hatena.ne.jp/m-hiyama/20100422/1271902182:title]
+ [http://d.hatena.ne.jp/m-hiyama/20090525/1243210967:title]
+ [http://d.hatena.ne.jp/m-hiyama/20061215/1166148075:title]
+ [http://d.hatena.ne.jp/m-hiyama/20061214/1166055868:title]
+ [http://d.hatena.ne.jp/m-hiyama/20071012/1192180167:title]
+ [http://d.hatena.ne.jp/m-hiyama/20071011/1192093098:title]



</body>
</day>
<day date="2012-08-10" title="">
<body>
*1344562441*[リンク][プログラム意味論][メモ]CRSとその代数構造

- CRSとその代数構造:操作的意味論の統一的な解析へ向けて
- 浜名誠 Makoto Hamana
- http://www.nue.riec.tohoku.ac.jp/jssst2005/papers/05089.pdf



</body>
</day>
<day date="2012-08-11" title="">
<body>
*1344672749*[説明][形式言語理論]形式言語理論とは何であって、何がありがたいのか

ソフトウェア技術者の観点から言えば、「ソフトウェアのための集合論」だな。

+ 数学の集合は茫漠としていて掴みどころがない。
+ 全体集合U（universe）を決めて、その部分集合だけを考えるのが良い。
+ Uはデータの集合だが、アトムだけじゃなくて複合データも考えたい。
+ 一番簡単な複合データは列だから、Uは列の全体としよう。
+ A⊆U に対して、Aの列挙とか、Aに属するかどうかの判断をしたい。
+ 列挙プログラムも判断プログラムも、比較的簡単に実装できるものがいい。

複合データの全体Uを、列だけじゃなくてツリーとかレコードとかグラフとかにしてもいい。それだけ難しくなるけど。

Uの部分集合Aが十分に簡単なときは、三位一体が成立する。

+ Aの記述（description）／表現（expression）
+ Aの生成器
+ Aの受理（認識）器

これは、実務上は次に対応する。

+ 仕様
+ テストデータ（の生成）
+ バリデータ

</body>
</day>
<day date="2012-08-13" title="">
<body>
*1344816825*[メモ][caty-depl][caty]bitbucket Services

説明は：

- https://confluence.atlassian.com/display/BITBUCKET/Managing+bitbucket+Services
- https://confluence.atlassian.com/display/BITBUCKET/Setting+Up+the+bitbucket+POST+Service

http://brandonsummers.name/blog/2012/02/10/using-bitbucket-for-automated-deployments/ より：
&gt;&gt;
Work flow

+ Commit changes and push them up to your Bitbucket repository
+ Bitbucket sends a POST request to a deployment script on your server
+ The deployment script pulls changes into it’s local repository (which is in the web-root) which updates the website
+ Repeat
&lt;&lt;


</body>
</day>
<day date="2012-08-21" title="">
<body>
*1345527667*[メモ][モナド][課題] 一般化クライスリ構成の例

[http://d.hatena.ne.jp/m-hiyama/20120821/1345513552:title] に書いた件、次のような例を考えていた。

kは体として、集合Aに対してk(A)は、なんらかのk関数環にkベクトル空間構造を入れたもの。Mがモノイドのときは、k(M)はモノイド環構造を持つ、k(M)→k(M)(×)k(M) という余代数構造を持つはず。

モノイドMに対して、F(A) := k(M×A)、G(B) := k(B) とすると、k(M×A)→k(B) という射が一般化クライスリ射。もしうまく一般化クライスリ圏が構成できれば、これはオートマトンの線形代数版になるはず。形式言語理論の定理、例えばマイヒル／ネロードとかを定義できないだろうか？

*1345518207*[映画]『ダークナイト ライジング』と、連想した映画達

&lt;em&gt;ネタバレ。&lt;/em&gt;

『ダークナイト ライジング（The Dark Knight Rises）』（2012年）を一人で観に行った。子供たちは興味ない。実際、（うちの）子供たちが喜ぶような映画じゃないな。最近のバットマン（クリストファー・ノーラン監督の三部作）はシリアスで暗い。僕が子供の頃テレビで見ていたアッケラカンとしたヒーローじゃない。

特に今回は陰鬱な感じさえする。バットマン＝ブルース・ウェイン死んじゃうし。死ぬ前に個人破産してるし、ウェインの会社潰れるし。最後は葬式だし。

それと、ロビン（＝ジョン・ブレイク刑事）がやっと登場だが、バットマンが死んだ後にどうしよう、っての？ 次回作はバットマン亡き後のロビンが主人公ってテはあるが、僕はやっぱり二人一緒に悪と戦ってほしかった。ロビンの経歴も暗すぎだしなー。

『バットマン ビギンズ』（2005年、三部作の第一作）は見てないが、そのなかでラーズ・アル・グール（別名ヘンリー・デュカード）という格闘技(?)の師が登場するらしい。今回はその末裔（娘だけど）が登場する。これがまたサイテーな感じだ。いや、映画としてツマラナクはないが、ラーズも娘も不気味で理不尽すぎる。

Wikipediaより：
&gt;&gt;
ラーズの過去とその遺志を継ぐ者が登場し、ゴッサムを破滅へと追い込む事になる。またラーズ本人ではないが、奈落へ落とされたブルースの前に幻覚として現れ、その際自身を「不死身」と称していた。
&lt;&lt;

SFとしての設定は全般にイイカゲンだが、ゴッサム・シティ沖で中性子爆弾が爆発したのに「被害はなかった」とはどういうことだ？ あの程度の距離ではダメだろう、ダイナマイトじゃないんだから。バットマンの死も無駄だったはずだ。細部に目くじら立てる気はないが、ここはキモだろうに。

&lt;hr&gt;

もし続編を作るなら、ラーズの幻覚が「不死身」だと言っていたのがミソかな。ラーズもバットマンも不死身だった、と。安易すぎるが。それと、ラーズの娘とか弟子も不死身になっちゃうしな。

&lt;hr&gt;

キャットウーマン（別名セリーナ・カイル）は良かった。だいたいにおいて、セクシー美人は好きなんだけど。女優さんはアン・ハサウェイ。もうひとりのヒロイン・ミランダはマリオン・コティヤールというアカデミー賞の女優さん。フランス人らしい。

悪役ベインはちょっと小粒感がある。『ドゥームズデイ』（2008年）の悪役も小粒だった。『ダークナイト（The Dark Knight）』（2008年）のジョーカーが凄すぎた。

&lt;hr&gt;

Wikipediaの『ビギンズ』（2005年）項目から引用すると：

&gt;&gt;
執事アルフレッド（配役：マイケル・ケイン）の献身、ウェイン社応用科学部ルーシャス・フォックス（配役：モーガン・フリーマン）の技術的支援、街の唯一の良心ゴードン巡査部長（配役：ゲイリー・オールドマン）との結束、そしてブルースとしても幼馴染であり思い人でもあるレイチェル・ドーズ検事（配役：ケイティ・ホームズ、配役2：マギー・ギレンホール）の協力を受けながら、バットマンとしての闘いを開始する彼だったが、
&lt;&lt;

最愛の人・レイチェルは二作で死んでしまう。ウェインはこれを死ぬまで引きずっていた。二作でやはり死んだハービー・デント検事（配役：アーロン・エッカート）との関係も引きずってるし。

&lt;hr&gt;

監督のクリストファー・ノーランは『インセプション』（2010年）の監督。

ゴードン巡査部長やっていたゲイリー・オールドマンは、『ハリー・ポッターと死の秘宝 PART2』（2011年7月）にも出ていたいらしい。そんな気もするが、記憶がハッキリしない。『カンフー・パンダ2』（2011年）の声の出演、これは知らない。『カンフー・パンダ』（2008年）は長男と見たが、『カンフー・パンダ2』は見てないし … いや、見たか？ 記憶がハッキリしない。

主人公役のクリスチャン・ベール、彼はなんつっても『リベリオン（Equilibrium）』（2002年）のジョン・プレストンですよ。カート・ウィマー監督がGUN=KATAを開発したあれです。ミラ・ジョヴォヴィッチ主演の『ウルトラヴァイオレット（Ultraviolet）』（2006年）も見たかった。見逃した。当時の渋谷Book1stの壁ポスターで確認していたのに。

ベールは『ターミネーター4』（2009年、ジェームズ・キャメロン監督）のジョン・コナー役だった。『ターミネーター4 （Terminator Salvation）』（2009年）はお金かけたのはわかるがイマイチだった。低予算丸出しの第一作（1984年、ウーー、すげー昔だ！）のほうが良かったね。

シリーズ二作目『ダークナイト（The Dark Knight）』（2008年）のジョーカーをやっていたヒース・レジャーは28歳で死んでしまったらしい。

&gt;&gt;
睡眠薬等の薬物併用摂取による急性薬物中毒により急逝。死後、『ダークナイト』（2008年）の演技により、アカデミー助演男優賞を受賞した。28歳での同賞受賞は史上4番目の若さだった。
&lt;&lt;

ルーシャス・フォックス役のモーガン・フリーマンは、ジェームズ・マカヴォイ＋アンジェリーナ・ジョリー主演『ウォンテッド』（2008年）のスローンって役もやっていた。最後は悪役だと判明する。

ラーズ役でチラッと出たリーアム・ニーソン、『スター・ウォーズ エピソード1/ファントム・メナス』（1999年）のクワイ＝ガン・ジンだったんだな。『特攻野郎Aチーム THE MOVIE』（2010年）の主人公・ハンニバル大佐も彼だったのか。『ナルニア国物語/第2章:カスピアン王子の角笛』（2008年）と『ナルニア国物語/第3章:アスラン王と魔法の島』（2010年）では声の出演。

&lt;hr&gt;

&lt;h5&gt;言及した映画、言及したかったが気力がつきたもの&lt;/h5&gt;

+ 『ドゥームズデイ』（2008年）
+ 『インセプション』（2010年）[http://d.hatena.ne.jp/m-hiyama/20110105/1294187072:title]
+ 『ハリー・ポッターと死の秘宝 PART2』（2011年） [http://d.hatena.ne.jp/m-hiyama-memo/20110107/1294389938:title]
+ 『カンフー・パンダ2』（2011年）[http://d.hatena.ne.jp/m-hiyama-memo/20111210/1323507650:title]
+ 『カンフー・パンダ』（2008年）[http://d.hatena.ne.jp/m-hiyama-memo/20111210/1323507650:title]
+ 『リベリオン（Equilibrium）』（2002年） [http://d.hatena.ne.jp/m-hiyama-memo/20110418/1303083488:title] 
+ 『ウルトラヴァイオレット（Ultraviolet）』（2006年）[http://d.hatena.ne.jp/m-hiyama/20081002/1222904977:title] 
+ 『ターミネーター4』（2009年） [http://d.hatena.ne.jp/m-hiyama/20090218/1234915939:title]
+ 『ダークナイト（The Dark Knight）』（2008年）
+ 『ウォンテッド』（2008年） [http://d.hatena.ne.jp/m-hiyama/20081002/1222904977:title]
+ 『スター・ウォーズ エピソード1/ファントム・メナス』（1999年）
+ 『特攻野郎Aチーム THE MOVIE』（2010年）
+ 『ナルニア国物語/第2章:カスピアン王子の角笛』（2008年）
+ 『ナルニア国物語/第3章:アスラン王と魔法の島』（2010年） [http://d.hatena.ne.jp/m-hiyama-memo/20110412/1302599595:title]
+ 『Vフォー・ヴェンデッタ（V for Vendetta）』（2005年） [http://d.hatena.ne.jp/m-hiyama-memo/20120702/1341221525:title] 
+ 『ザ・ウォーカー（The Book of Eli）』（2010年） [http://d.hatena.ne.jp/m-hiyama-memo/20120706/1341546988:title]
+ 『キス＆キル』（2010年）
+ 『レスラー』（2008年） [http://d.hatena.ne.jp/m-hiyama-memo/20090715/1247630005:title]
+ 『アイアンマン2』（2010年）[http://d.hatena.ne.jp/m-hiyama-memo/20120706/1341546988:title]
+ 『エクスペンダブルズ』（2010年）
+ 『バイオハザード』シリーズ  [http://d.hatena.ne.jp/m-hiyama/20070802/1186037547:title]
+ 『ランボー 最後の戦場』（2008年） [http://d.hatena.ne.jp/m-hiyama/20080619/1213857131:title]
+ 『トランスフォーマー』シリーズ [http://d.hatena.ne.jp/m-hiyama-memo/20110902/1314950644:title]


</body>
</day>
<day date="2012-08-22" title="">
<body>
*1345622345*[メモ][モナド][課題]一般化クライスリ構成と無限待ち

6月4日からの週の「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20120609/1339213508&quot;&gt;今週見つけた圏&lt;/a&gt;」は、一般化クライスリ拡張となんか関係あるのか？

*1345622710*[映画]映画と本

次男はやたらに忙しい。先日だけど、つかのまの休日で『アメイジング・スパイダーマン』。2Dでやっている品川プリンスシネマ。長男は予定があわない。

早く着きすぎて、品川駅内の「BOOK EXPRESS エキュート品川サウス店」で時間つぶし。『ワンピース』の第一巻を買った。『アメイジング・スパイダーマン』の話はまた。



</body>
</day>
<day date="2012-08-25" title="">
<body>
*1345876719*[メモ][課題][トレース／コンパクト閉圏][プログラム意味論]不動点方程式と有向グラフと行列計算

本編に [http://d.hatena.ne.jp/m-hiyama/20120825/1345875871:title] って記事を書いたが、ほんとは「letrecと不動点方程式とトレース付き圏」みたいなタイトルでもっと具体的な計算を書きたかった。

letrec束縛の変数参照関係は有向グラフ（二部グラフから、頂点を同一視する）となる。これにサイクルがあるかないかで再帰を含むかどうかが決まる。このグラフのクリーネ閉包（無限級数）を求めれば不動点は計算できる。

このとき、正方行列のベキが出てくる。一般固有値問題で、「ベキ零＋半単純」分解をするが、あれと似たことができるような気がしている。半単純に対応する概念が、相互再帰する変数達でそれ以上は分解できない単位。有向グラフの強連結成分に対応する。ベキ零はDAGだろう。

ここまではわかるが、完全に線形代数とは対応してないのかもしれない（してるかもしれない）。よくわからん。いずれにしても、再帰変数と非再帰変数に分けて、強連結成分に分けるのが有効なのは確か。行列計算やトレースとどう関係づけるか？

</body>
</day>
<day date="2012-08-27" title="">
<body>
*1346026812*[課題][気付いた][モナド]入れ子の加群

安易に「入れ子の加群」とか言っていたが、少なくとも二種類ある。

MとNがモノイドでSが集合のとき：

+ SはM作用を持つ。
+ MはN作用を持つ。

このとき、入れ子の加群だが、「MへのN作用」が問題。

+ Mを単なる集合（忘却する）とみての作用
+ Mをモノイドとみての作用

この2つが違う。


</body>
</day>
<day date="2012-08-28" title="">
<body>
*1346113132*[Caty][圏一般論]tryは関手にはならない

言語仕様はtry/catchとしたが、やはり単独のtryを考えたほうが扱いやすい。が、注意すべきはtryが関手にはなってない点だ。関手ではないが圏論的オペレーター。

他の例：

- eachは、each(f;g) = each(f);each(g) の意味で関手性を持つ。クライスリ埋め込み関手。
- repeatは関手ではなくてトレース。repeat(f) := Tr(∇;f)
- takeは、述語射（述語コマンド）を引数にとって、take(p∧q) = take(p);take(q) は満たす。listクライスリ圏にテスト付きクリーネ圏の構造を導入するのだろう。listよりbagがふさわしそうだ。いまのところベース圏にテスト付きクリーネ構造がない。
- when, case, condは直和構成なので、関手つうよりはモノイド積。
- let（レイフィケーション）は直積の不動点構造。


*1346113133*[気付いた][圏一般論]圏の自由積

&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt;が圏だとして、全射 (|&lt;i&gt;C&lt;/i&gt;| + |&lt;i&gt;D&lt;/i&gt;|)→X がある状況で考える。この全射は融合和（amalgamation）だ。

融合和の連結部分があるので、&lt;i&gt;C&lt;/i&gt;の射と&lt;i&gt;D&lt;/i&gt;の射を繋ぐことができる。いったん、自由圏を作って縮約できるものは縮約して正規化すると一意な表現が得られる。こうして作った圏は、&lt;i&gt;C&lt;/i&gt;と&lt;i&gt;D&lt;/i&gt;の融合和に関する自由積になり、群やモノイドの自由積の拡張になる。

&lt;i&gt;C&lt;/i&gt;, &lt;i&gt;D&lt;/i&gt; が境界を持つ圏で、融合和が境界の貼り合わせ（gluing）のとき、これらの自由積は圏の貼り合わせとなるだろう。「境界」を1次元低い圏だと考えると、2圏を1圏の境界を糊代にして貼り合わせるような操作も考えることができる。

*1346113872*[Caty][圏一般論][モナド]更新モナドの指数法則

M, Nなどはモノイドとして、モノイダルスタンピングモナドを更新モナドとも呼ぶことにする。Catyの更新ファシリティ（updates, usesで宣言される）はすべて更新モナド。

Mによる更新モナドの&lt;i&gt;C&lt;/i&gt;ベースのクライスリ圏を &lt;i&gt;C&lt;/i&gt;[M] と書くことにすると：

- &lt;i&gt;C&lt;/i&gt;[&lt;b&gt;1&lt;/b&gt;] = &lt;i&gt;C&lt;/i&gt;
- &lt;i&gt;C&lt;/i&gt;[M×N] = (&lt;i&gt;C&lt;/i&gt;[M])[N]

と指数法則が成立する。

では、

- &lt;i&gt;C&lt;/i&gt;[M+N] = &lt;i&gt;C&lt;/i&gt;[M]×&lt;i&gt;C&lt;/i&gt;[N]

はどうか。「+」を普通に解釈していては成立しない。モノイドの足し算は自由積、圏の足し算も、対象類を同一視しての自由積とすると、ある程度は成立しそう。「ある程度」が謎だが。

モノイドも圏も直積と自由積に関する代数法則があって、それによってインターリーブが記述されるのだと思う。いずれにしてもモノイドの自由積がきちんと扱えないと、並列・直接の問題は解けないだろう。

並列・直接の問題が解けないなら、たくさんの更新モナドを扱うことも困難だ。

</body>
</day>
<day date="2012-08-29" title="">
<body>
*1346200541*[Caty][プログラム意味論]CatyScriptとデカルト半環圏

デカルト半環圏

+ dom -- 入力型
+ cod -- 出力型
+ id  -- pass&lt;T&gt;
+ 結合 -- パイプ、セミコロン
+ 直積 -- 配列、オブジェクト、タグ付きデータ
+ 直積単位 -- null、undefined、その他シングルトン
+ 直和 -- when, case, cond
+ 直和単位 -- never

リスト構造

+ リスト型 -- [T*]
+ マップ関数 -- each
+ テスト付きクリーネ構造 -- take

圏論的オペレーター

+ トレース -- begin/repeat
+ try -- 例外モナドを潰す
+ forward -- 米田埋め込み？

制御構造（重複して列挙）

+ when, case, cond
+ call, forward, start, emit

変数

+ 環境変数（参照コモナド）
+ オプション、引数（多圏とシーケント、スパイダー計算）
+ ローカル変数（ワイヤリング）

一般化クライスリ拡張

+ readonlyファシリティ -- 参照コモナド
+ updateonlyファシリティ -- 更新モナド
+ 両ファシリティ -- メイヤー代数

ワイルドな機能（重複して列挙）

+ eval
+ repeat（begin単独ならよい）
+ try/catch

*1346210748*[プログラム意味論][モナド]モノイドと加群と圏の自由積

&lt;i&gt;C&lt;/i&gt;[M] を、モノイドMによる更新モナドのクライスリ圏として、

-  &lt;i&gt;C&lt;/i&gt;[M + N] = &lt;i&gt;C&lt;/i&gt;[M]*&lt;i&gt;C&lt;/i&gt; [N]

という指数法則は成立しそう。ただし、形がそれらしくなるように、モノイドの自由積をプラス記号で、圏の自由積をアスタリスクで書いている。

モノイドの自由積、加群の自由積、圏の自由積などはあまり注目も応用もされなかった気がする。自由積より原始的な概念に、境界による射の接合がある。終境界と始境界があれば、トレースも定義できる。オートマトンのアルファベットの演算がうまく定義できなかったのも、このへんのこと（自由積、境界による接合）が抜けていたせいかもしれない。

自由積と境界接合をちゃんと考えると、懸案の一部は解決するかもしれない。


</body>
</day>
<day date="2012-09-03" title="">
<body>
*1346630084*[映画]『プロメテウス』

&lt;em&gt;ネタバレ。&lt;/em&gt;

「リドリー・スコットも老いたか？」ってのが僕の感想。

SF映画としてつまらないわけじゃないし、ビジュアルも見応えがある。だが、『エイリアン』『ブレードランナー』を知っている僕としてはチョット … …。ギーガーの有機物っぽいデザインとか人間型ロボットの独特な感じは、あーやっぱりリドリー・スコット、懐かしい、という感じなんだけど、自己模倣に陥っている感じがする。

自分を模倣しているってことはつまり、「リドリー・スコットらしい」とも言えるんだけど、リドリー・スコット流／リドリー・スコット節つうよりは、なんかリドリー・スコット&lt;em&gt;風&lt;/em&gt;なんだよね。他の誰かがリドリー・スコットをリスペクトしてオマージュとして作りました、と言われても「そうか」と思えてしまう。

今となっては『エイリアン』も『ブレードランナー』も、その映像／ストーリーの記憶が定かでは無いけど、有機的で暗くて汚れた、だけどカッコイイ映像だったと思う。『プロメテウス』は、3Dでもあるし、なんかお金をかけた今風の、ちょっと小奇麗な画面を使ってしまって、僕には興ざめだなー。おどろおどろしい感じが薄くなってしまった。話は、この後『エイリアン』に回帰するらしいけど、ストーリーはともかく、映像が接合する気がしない。

『プロメテウス』のヒロイン；エリザベス・ショー博士（配役はスウェーデンの女優ノオミ・ラパス）は、『エイリアン』のリプリー同様に、超タフな女性。強い女性大好きな僕だから、ヒロインがタフなのはいいのだけど、エリザベスはちょっと強すぎだ。カッコイイを通り越して「こいつ、化物だろう」となって感情移入できない。いくらなんでも、あんなに強い人間はいないだろう。

女優ノオミ・ラパスはけっこういいと思うが、アカデミー主演女優賞のシャーリーズ・セロン（ヴィッカーズ役）が良かった。ストーリーのなかでもロボットと疑られたりするが、ちょっと無機質な美人。最後のほうでヴィッカーズの正体は（曖昧に）分かるが、このくだりは陳腐。

最初のシーンがよくわからん。最後のほうで出てくる大きな異星人（エンジニアと呼ばれている）と同じヤツが出てくるが、なんだったんだ？ 大きな異星人のキャラクターはけっこう好きだ。ウェイランド((ウェイランド社はリドリー・スコット作品に何度も登場。))というビル・ゲイツも真っ青な成功者が、神、創造主、救世主だと信じて会ったら、単に暴力的で身勝手な宇宙人だった、と。ウェイランドもガックリな身も蓋もない感じが良い。

単に暴力的で身勝手な宇宙人（so-called エンジニア）が作った生物兵器が、当の宇宙人と合体した生物があのエイリアンってことらしい。

ロボットのディビットもわけわからん奴だ。イケメンで憎めなかったりするが、コイツは少しオカシイ。

登場人物で親しみが持てたのは、プロメテウス号船長のヤネック、船員のチャンスとラヴェル、この3人のスタッフだけだな。

</body>
</day>
<day date="2012-09-05" title="">
<body>
*1346811742*[映画]『シティ・オブ・メン』

『プロメテウス』は最近見た映画だが、2008年8月に日本公開されたブラジル映画『シティ・オブ・メン』の話。

ロンドンオリンピックが終わって、次はブラジルだ。その前にワールドカップ・ブラジル大会もある。ファベーラと呼ばれるスラム街がやはり問題になっているらしい。ファベーラは固有名詞じゃなくて、リオデジャネイロなど（「など」か？）にたくさん存在するスラム街の総称。確かNHKの番組で「ホシーニャ」（固有名詞）を取り上げていたと思う。

『シティ・オブ・メン』では、リオ最大のファベーラのロッシーニャが舞台。2003年の映画『シティ・オブ・ゴッド』がファベーラの話で、同じスタッフが『シティ・オブ・メン』を作ったらしい。『シティ・オブ・ゴッド』は見てない。連続性はないみたい。地下鉄日比谷線恵比寿駅の出入口に『シティ・オブ・メン』の広告が貼ってあって、それで観に行った。日比谷線恵比寿駅の広告はけっこう僕には効果がある。『鉄男』とか『ゼブラーマン』も駅の広告がキッカケ。

『シティ・オブ・メン』は、日本で言えばヤクザ映画に相当するのだろう。リアルではあるが、それほどショッキングではない。ストーリーも陰惨って程じゃない。それなりの明るさがある。映像もキレイだ。いや、汚い街を取っているのだが美しいとでもいうか。いい映画だったな、と思う。


</body>
</day>
<day date="2012-09-07" title="">
<body>
*1347007025*[映画]モーガン・フリーマン

『ダークナイト ライジング』のルーシャス・フォックス役、『ウォンテッド』のスローン役だが、1994年『ショーシャンクの空に』（The Shawshank Redemption）のエリス・ボイド・&quot;レッド&quot;・レディング（Ellis Boyd &quot;Red&quot; Redding）役もモーガン・フリーマンだったのかー。

『ショーシャンクの空に』での役が Red だったのだけど、2010年に RED というタイトルの映画ではジョーって役をやっているそうな。


</body>
</day>
<day date="2012-09-13" title="">
<body>
*1347515130*[メモ]歯の治療

歯医者さんで、以前の並セラミックの被せ物をジルコニアに交換してもらった。

ジルコニアってのは新しいテクノロジーで優れものらしい。


</body>
</day>
<day date="2012-09-14" title="">
<body>
*1347597206*[映画]『タイムズスクエア』

『タイムズスクエア』（Times Square）、1980年か。僕は25歳前後だよね。何してたんだろう？ 一番イイカゲンな時代じゃないかな。何かしているようなしてないような。六本木で働いていたのは確か。

ストーリーはサッパリ憶えてない。音楽狂の15歳の少女ニッキーと若手政治家デイビッド・パールの1人娘パメラという二人が出てくる、とか。少女二人の物語だってのは覚えている。タイムズスクエアの喧騒の印象もなんか残っている。

一番覚えているのは、この少女二人が、「ニッキー」「パーミー」と大声で呼び合うシーン。友情の確認みたいな行為か？

*1347598465*[映画]『最強のふたり』と1977年と浮かれた時代

『最強のふたり』については感想を書きたいが、いずれってことで、使われている音楽とそれから連想した色々。

主人公のドリス（物語のなかでも本名じゃない）は、「クール・アンド・ザ・ギャング」と「アース・ウィンド・アンド・ファイアー」がいいとか言う。実際、『セプテンバー』（1978年）が映画のなかで使われている。

「アース・ウィンド・アンド・ファイアー」というと1977年の『宇宙のファンタジー』（Fantasy）だよね。けど、ネットでちょっと調べると、『ファンタジー』が大ヒットしたのは日本だけらしい。なんで「宇宙」だったんだろう？ 同じ年（1977年）にスティーブン・スピルバーグが『未知との遭遇』（Close Encounters of the Third Kind）を作っているんで、それの影響か。

『ファンタジー』は、僕にとっては与論島とリンクしてる。ということは、与論島に行ったのは1977だったのか。アラベスク (Arabesque) のデビューも1977年だ。「ハロー・ミスター・モンキー」も77年か78年だろう。「ハロー・ミスター・モンキー」は、ラジオ番組で糸居五郎が紹介したのを聞いた、それを今でも覚えている。

『サタデー・ナイト・フィーバー』も『007 わたしを愛したスパイ』も1977だ。『007 わたしを愛したスパイ』は、その頃くどいて（フラれた）女の子と日比谷で観たと思う。「日比谷ラジオシティ」とかに連れてこうと思ったが失敗した。「ラジオシティ」は入りにくい店だったな。後で六本木（つうか乃木坂か）「セック」には行ったが、確かそこでフラれた。

1976, 77, 78あたりは、第一次ディスコブームのどまんなか。僕が一番浮かれていた時代だったかも。

</body>
</day>
<day date="2012-09-15" title="">
<body>
*1347704162*[Caty]リクエストディスパッチの構造

イカンイカン、イカンイカンイカン！！

形式化／抽象化をしないと、いつまでたってもハッキリしないグダグダ状態が続く。リクエストディスパッチの基本は、いちおう「[http://d.hatena.ne.jp/m-hiyama/20120913/1347526455:title] 」に書いた。

僕はオブジェクト指向は好きじゃないが、&lt;em&gt;結果的&lt;/em&gt;にはオブジェクト指向っぽい話になる。「結果的」は今回のキーワードだ、as-a-result を、「結果的」を意味する形容詞に使おう。

Catyの型システムはサブタイプ／スーパータイプの宣言はないが、「結果的にサブタイプ」（as-a-result subtype、subtype as-a-result）はある。ダックタイピングと言ってもいい。リソースクラスのあいだに継承はないが、「結果的に継承」とか「結果的にサブクラス」という関係はある。この「結果的に＝意図してないが」というのは非常に重要な概念だと思う。

「結果的に継承」、「結果的にサブクラス」を定式化するために、3つの集合を考える。

+ 集合C -- クラス識別子の集合。Cの要素を単にクラスとも呼ぶ。Catyのリソースクラスに対応。
+ 集合S -- クラスのメソッドセレクタの集合。Sの要素はメソッドそのものではなくて、メソッドを起動するための記号。Catyでは、アクションインボーカーと言っているヤツ。
+ 集合U -- Catyでは、パス文字列全体の集合。すべてのリソースインスタンスの集合と言っても同じ。

抽象的なセッティングでは：

+ C -- 有限集合。それ以上の制限も意味もない。空でもいいが、空だと議論する意味が無い。
+ S -- 普通は無限集合。有限でもいい。空ではない。
+ U -- 普通は無限集合。有限でもいい。空ではない。

構造を与えるのは、Inst:C→Pow(U) と、A:C→Pow(S) という関数。r∈C に対して、Inst(r) は |r| と略記する。クラスrのインスタンスの集合が |r| 。InstとAの条件は：

+ r∈C に対して、 |r| は空ではない。
+ r, s∈C に対して、 r≠s ならば、|r|⊂|s|、|s|⊂|r|、|r|∩|s|=&lt;b&gt;0&lt;/b&gt;（空集合）のどれかが成立する。
+ r∈C に対して、A(r) は有限集合、空でもよい。

「rはsのサブクラス」と「rはsをオーバーライドする」を次のように定義する。

- rはsのサブクラス ⇔ |r|⊂|s|
- rはsをオーバーライドする ⇔ (|r|⊂|s| かつ A(r)∩A(s)≠&lt;b&gt;0&lt;/b&gt;)

(i, s)∈U×S をリクエストと呼ぶ。

- r |= (i, s) ⇔ (i∈|r| かつ s∈A(r))

次が成立する。

- (r |= (i, s) かつ r' |= (i, s) となるリクエストが存在する) ⇔ (rはr'をオーバーライドするか、r'はrをオーバーライドする)

以上で定義した「サブクラス」「継承」「オーバーライド」は、いずれも「結果的に（as-a-result）」であって、宣言するもの（ノミナル）ではない。構造的っちゃそうだが、やはり「意図せずに」という感じが強い。


</body>
</day>
<day date="2012-09-18" title="">
<body>
*1347947277*[メモ][気付いた]森田童子は女性だった

今まで（2012-09-16T17:53のあたりまで）僕は、森田童子は女性のような声の男性だと思っていた。彼、じゃなくて彼女ももう60歳だ。

</body>
</day>
<day date="2012-09-22" title="">
<body>
*1348296295*[気付いた][Caty][モノイド圏][トレース／コンパクト閉圏][プログラム意味論]プログラムの行列計算 その0

とりあえず、クライアント／サーバーのときの事実をメモしておく。

Cはクライアント側エンドポイント（状態、境界オブジェクト）の集合、Sはサーバー側エンドポイント（アクション、コントロールオブジェクト）の集合とする。CとSは排他的になっている。

CとSを頂点集合とする有向二部グラフを考える。有向二部グラフを記述する行列を Q:C→S、P:S→C とする。ちょっと工夫すれば、リダイレクトや（サーバー内の）フォーワードがあっても二部グラフの記述に持ち込める。

行列はラベル付き辺を記述する。ラベル付き辺に対して、ラベル（記号）の連接によって成分（係数）の積を定義する。和は、プログラムコードの多方向分岐か、単なる集合（集合を非決定性プログラムと考える）で入れる。係数に（非可換な）積と和があるので、行列計算はできる。

この行列計算の枠内で、I&lt;sub&gt;0&lt;/sub&gt;はクライアン側の開始状態集合（Cの空でない部分集合）を識別する行列とする。

- T&lt;sup&gt;(n)&lt;/sup&gt; = I&lt;sub&gt;0&lt;/sub&gt;;(Q;P)&lt;sup&gt;n&lt;/sup&gt;

と定義する。L = P;Q だとすると、

- T&lt;sup&gt;(n+1)&lt;/sup&gt; = Q&lt;sub&gt;0&lt;/sub&gt;;L&lt;sup&gt;n&lt;/sup&gt;;P

という公式が成立する。これは計算すれば自明だが、ものすごく役に立つ。

ここで出てくる行列は、エンドポイントをインデックスとしてスクリプトコード（プログラム）を係数値とする行列であり、行列計算がプログラムの合成／実行に対応する。

- 式＝スクリプトコード、値＝計算結果＝コンパイル／実行の結果
- 係数の積＝スクリプトコードの結合（連接）
- 係数の和＝スクリプトコードの非決定性選択

ポートインデックスをどう扱うか？を考えないといけない。

*1348297368*[気付いた][Caty][モノイド圏][トレース／コンパクト閉圏][プログラム意味論]プログラムの行列計算 その0.5

+ とりあえず二部グラフに対応する行列の場合に定式化する。
+ 二部グラフより複雑な有向グラフの場合も考える。
+ 二部グラフより複雑な場合も行列計算に帰着する。
+ ポートとポートバインディングを考える。
+ 行列より一般的なテンソル計算を考える。
+ インデックスセットの変換とか加工を考える。
+ 模倣、双模倣の概念はどうなるか？
+ 行列の同型／同値について考える。
+ 二重圏や双圏の構造を考える。
+ 任意のグラフ上のスクリプトに対する標準形があることを示す。

</body>
</day>
<day date="2012-09-25" title="">
<body>
*1348543601*[メモ]NetworkX（主にDiGraph）の使い方 (3)

GがNetworkXのグラフだとして、

+ G自体がノードイテレータとして使える。例： [n for n in G]
+ G.graph でグラフ全体の属性を得られる。
+ G.node でノードセットを辞書の形で得られる。
+ G.edge でエッジセットを辞書の形で得られる。
+ G.nodeのキーがノードで、値はノード属性
+ G.edgeのキーがソースノードで、値は「ターゲットノードと辺属性」の辞書
+ G自体が、G.edgeと同じように使える。G[1][2] とか G[1][3]['color']='blue' とか。
+ グラフ全体の属性の設定は G.graph['day']='Monday' とか。
+ ノード属性の設定は G.node[1]['room'] = 714 とか。
+ 辺（エッジ）属性の設定は G[1][2]['weight'] = 4.7 、G.edge[1][2]['weight'] = 4 とか。
+ G.nodes() でノードセット
+ G.edges() でエッジセット
+ 関数 nx.to_edgelist(G) でエッジリストを取り出す
+ 関数として、nx.nodes(G) がある。
+ 関数として、nx.edges(G) がある。
+ 関数として、nx.{set/get}_{node/edge}_attributes がある。
+ G.neighbors(n), G.successors(n) とかもある。

実験用には、次のようなグラフが使える。

+ nx.path_graph(4, nx.DiGraph())
+ nx.complete_graph(4, nx.DiGraph())
+ nx.cycle_graph(4, nx.DiGraph())


</body>
</day>
<day date="2012-09-27" title="">
<body>
*1348716926*[気付いた][圏一般論][TQFT][課題]プロ関手と行列とコボルディズム

何度も「気付いた」と書いている気がするが、、、、

プロ関手は行列の拡張概念だと思う。インデックスのセットを増やして、三重四重のインデックスを持つテンソルのようなものを考えても、本質的に次元は増えないとかつて書いた。そうやっても、点は点だし、線は線だ。つまりはグラフ概念から外にでない。その理由は、0×0 = 0、1×1 = 1 という特殊性にある。いくら掛け算しても2が出てこない。

プロ関手の場合は、境界が1次元であるので、(コ)ボルディズムとしては2次元が出てくる。Prof(C, D) := [C&lt;sup&gt;op&lt;/sup&gt;×D, &lt;b&gt;Set&lt;/b&gt;] という定義は、Cの反対圏とDを境界とする完全二部グラフから&lt;b&gt;Set&lt;/b&gt;へのグラフ写像とみなせる。値を取る圏&lt;b&gt;Set&lt;/b&gt;は圏だが、単一の0対象を加えて1次元分だけ“リフト”しておく。すると、2次元複体から2次元圏への準同型となり、行列の定義と整合する。

境界が圏であることから、プロ関手は本質的に次元が上がっている（2次元）。完全二部2次元複体から、より一般的な境界付き2次元複体にすれば、コボルディズム圏が作れる。値（係数）の圏も一般的な2次元の圏でよい。これで、2次元の行列計算がなんであるかがやっと見えてくるのではないか。

ところで、プロ関手をdistributorとも言うが、分配法則とは関係なくて、function : functor = distribution : distributor なんだそうな。

*1348718294*[気付いた][Caty]いくつかのキーワード： KoNSとサービス転送オブジェクト

クライアント／サーバーシステムで、クライアント側状態の遷移をする際に、「次にどこに遷移すべきか」あるいはむしろ「次に遷移するために何をなすべきか」の知識がいる。この知識を &lt;strong&gt;Knowledge of Next Step&lt;/strong&gt;、略して &lt;strong&gt;KoNS&lt;/strong&gt; と呼ぼう。

問題は、KoNSを誰が持っているか？ どう伝えるか？ クライアント側がすべてのKoNSを持っていて、サーバー側はRPCエンドポイントの集まり、のような形態も考えることができる。しかし、これはハイパーリンクアプリケーションじゃない。ハイパーリンクアプリケーションでは、KoNSをサーバー側が持っていて、それをその場その場でクライアント側に伝える。クライアントはKoNSを一切持たず、サーバーからの提供に頼る。

これがハイパーリンクアプリケーション、あるいはリンクトサービスの基本だ。KoNSを全体として図示するとハイパーリンクグラフになる。ハイパーリンクグラフを知っているとは、行動のシナリオを知っていることになる。シナリオは、局所的な選択の知識が時間方向に累積される結果として生じる。シナリオの全体が、局所的な情報で定義される。ローカル／グローバル、またはミクロ／マクロ対応がある。

ただし、KoNSの伝達方式（プロトコル）と記述方式（フォーマット）は前もって合意しておく必要がある。これは、KoNSを扱う上でのメタ知識となる。メタ知識は共有しながら、知識を決め打ちでなくてオンザフライでやり取りする。オンザフライでやり取りする分のオーバーヘッドはあるが、その代わりロバストになる。仕様変更でクライアントが壊れるリスクは減る。

KoNSを含めた転送オブジェクトを、以前から&lt;strong&gt;サービス転送オブジェクト&lt;/strong&gt;と呼んでいた。データ転送オブジェクトより情報が豊富で、KoNSが詰め込まれている。ハイパーメディアオブジェクトとほぼ同義だ。

*1348735368*[メモ]行列計算のネタ

本編に書くかも知れない。

+ 行列とは何か、どう捉えるか。
+ ナニカを長方形格子の形に配置したモノ
+ 格子の形状は I×J 。I、Jがインデックスセット。
+ 配置するナニカが係数（成分、要素）
+ 一般化：形式テンソル、多重行列、係数はコンパクト閉圏
+ 一般化：無限インデックス、係数は総和可能な圏
+ 一般化：境界付きグラフから圏への写像

</body>
</day>
<day date="2012-09-29" title="">
<body>
*1348888484*[Caty][説明]CatyのWeb処理： Webフィーチャとメタプログラミング

&lt;em&gt;Catyのドキュメンテーションに含めるつもりの記事。&lt;/em&gt;

CatyのモットーはできるだけWeb処理をやらないことだ。Webフレームワークとか言いながらも、一般的な言語処理の機能内で&lt;em&gt;ついで&lt;/em&gt;にWeb処理をしてしまう形態を理想としている。「Web特有の機能を付けない」「Web特有の処理をしない」と言ってもいい。Webに適合するための機能性は「&lt;strong&gt;アクション&lt;/strong&gt;」という概念だけに閉じ込めている。で、以下、アクション＝Web処理の話。

&lt;b&gt;[追記 date=&quot;2012-10-01&quot;]&lt;/b&gt;&lt;em&gt;「フィーチャ」って言葉を、ここで定義した意味で使うのはちょっと問題アリかもしれない。本来の用語では「モデル」。モデルってのも意味が広すぎてイヤなんだけど、フィーチャは「システムにインストール済みの機能」という意味で使いたい時がある。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

&lt;h4&gt;アクションの遂行処理&lt;/h4&gt;

アクションも単なるコマンドに過ぎない、と僕は強調している。今後さらにアクションの特殊性を&lt;em&gt;薄めていく&lt;/em&gt;つもりだ。アクションの特徴は次の3つ。

+ プロファイルが固定されている。
+ リモート起動が出来る。
+ 遂行（perform）出来る。

アクションのプロファイルは、arg0も含めてお約束で決められている。これによりすべてのアクションを一律に扱える。だが、この特徴には何らの特殊性もない。どんなコマンドでもプロファイルを持つ。そのプロファイルがたまたま制約されているだけだ。

&lt;strong&gt;リモート起動&lt;/strong&gt;は、外部からのリクエストにより実行（exec）できることだ。これが出来なきゃWeb処理に使えない。ただし、リモート起動（remote invocation）と直接起動（direct invocation）の違いはまったくない。アクション自体は、自分がリモート起動されたか直接起動されたかを&lt;em&gt;一切区別することができない&lt;/em&gt;。環境変数REQUEST_METHODなどがリモート起動時の情報を伝えるが、unclose構文で環境変数をセットできるので決め手にならない。これは、直接起動を使ってリモート起動を&lt;em&gt;100%エミュレート出来る&lt;/em&gt;ことを意味する。

&lt;strong&gt;遂行&lt;/strong&gt;（perform）は、実行（exec）とは違う。その違いは次の絵で示せる。この絵全体でやっていることが「アクションの遂行」である。

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img3/action-performing.gif&quot; &gt;

遂行をCatyScriptのコードで書けば（catch {*=&gt; ...} が今動かないが）：

&lt;pre class=&quot;code&quot;&gt;
 try --wall=superhard {
   some-action
 } |
 catch {
   normal =&gt; pass,
   signal =&gt; 
     try --wall=superhard {
       map-signal
     } |
     catch {
       normal =&gt; pass,
       *      =&gt; internal-server-error,
     },
   except =&gt;
     try --wall=superhard {
       map-exception
     } |
     catch {
       normal =&gt; pass,
       *      =&gt; internal-server-error,
     },
 }
&lt;/pre&gt;

単に実行するだけでなく、シグナルと例外を map-signal, map-exception に渡して面倒を見ることが遂行（perform）である。アクションを遂行するのはフレームワーク（Webシェル）の仕事だが、アクションを表現するクロージャ（closure-like object）を入力としてアクションを遂行するコマンド perform も提供される。また、ディスパッチャーコマンドとして lookup-and-perform ってのもある（単にexecするのは lookup-and-exec）。

&lt;h4&gt;Webフィーチャ&lt;/h4&gt;

&lt;strong&gt;Webフィーチャ&lt;/strong&gt;とは、Web特有の機能性を実現するための、基本となる型とコマンドのセットである。

ちなみに、&lt;strong&gt;フィーチャ&lt;/strong&gt;とは、型、コマンド、ファシリティ、アセット（静的HTLM、画像、JavaScriptファイルなど）の一式をまとめた概念である。モジュールという単位でうまくマトマリがつかないときフィーチャという単位を使う。Webフィーチャも、必ずしもモジュールと1:1対応はしない。

&lt;b&gt;[追記 date=&quot;2012-10-01&quot;]&lt;/b&gt;&lt;em&gt;「フィーチャ」の意味は上の説明のとおりだが、「Webフィーチャ」は不適切な気がしきた。冒頭の追記も参照。&lt;/em&gt;&lt;b&gt;[/追記]&lt;/b&gt;

Webフィーチャの実体は2つの型と4つのコマンドである。フィーチャを構成する型／コマンドの名前とコマンドのプロファイルは完全に決まっている。

+ 型 WebRaw
+ 型 Response
+ コマンド expand
+ コマンド response
+ コマンド map-signal
+ コマンド map-exception

オプションと引数は省略して、入出力プロファイルだけを書くと：

+ expand :: any -&gt; WebRaw
+ response :: WebRaw -&gt; Response
+ map-signal :: any -&gt; Response
+ map-exception :: Exception -&gt; Response

anyとExceptionはCaty標準の型である。map-signal と map-exception は、先ほどのアクション遂行で出てきたアレである。歴史的な事情から、WebRawの別名としてWebInput、Responseの別名としてWebOutputが使われる。これらの型／コマンドの典型的な使用例は次のようになる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/web-feature.gif&quot; &gt;

上の絵の説明は節を改めてする。

&lt;h4&gt;Webフィーチャの使われ方&lt;/h4&gt;

アクションは、その本質的な処理を行うセマンティック処理部と、Webへの出力の仲介をするWeb出力ラッパー（アダプター）の部分に別れる。Web出力ラッパーとして使ってよい基本コマンドは&lt;em&gt;2つだけ&lt;/em&gt;、関係する型も&lt;em&gt;2つ&lt;/em&gt;である。

+ 型 WebRaw ： Webメッセージ（HTTPリクエストとレスポンス）のエンティティボディとなりうるデータの型
+ 型 Response ： エンティティボディをヘッダで包んだデータの型
+ コマンド expand ： テンプレートのパスを引数に取り、入力をWebRawデータに変換するコマンド
+ コマンド response ： エンティティボディからレスポンスを作り出すコマンド

頻繁に使われるprintコマンドは、expand | response と定義されるので&lt;em&gt;基本コマンドではない&lt;/em&gt;。

アクション内で発生したシグナルと例外は、map-signal, map-exception に渡される。上の絵に描いてないが、Web出力ラッパー内の expand, responsも例外を引き起こすリスクがある。map-signal, map-exception の例外に関しては最終的にフレームワーク（Webシェル）が面倒を見る。

アクション内で発生するシグナル／例外を予測することはまったく不可能だが、Web(HTTP仕様）で定義されたリダイレクトとクライアントエラー／サーバーエラーに関しては、事前に定義しておくことができる。

&lt;pre class=&quot;code&quot;&gt;
exception HttpError = {
  &quot;status&quot;: integer(minimum=400, maximum=599),
  *: any?
};

type uri = common:uri;

@[register-public]
type HttpRedirect = @&amp; {
 &quot;status&quot;: integer(minimum=300, maximum=399),
 &quot;location&quot;: uri,
 *: any?
};
&lt;/pre&gt;

ステータス番号300番代のリダイレクトはシグナルで、ステータス番号400, 500番代のエラーは例外で知らせる。常識的に作られた map-signal, map-exception なら、これらのシグナル／例外を適切に処理する（HTTP仕様に従ったレスポンスを作る）だろう。

&lt;h4&gt;Webフィーチャの切り替え&lt;/h4&gt;

デフォルトでは、Catyに組み込まれているWebフィーチャが使われる。これを&lt;strong&gt;標準Webフィーチャ&lt;/strong&gt;（standard Web feature）と呼ぶ。標準以外のWebフィーチャは、&lt;strong&gt;非標準Webフィーチャ&lt;/strong&gt;（non-standard Web feature）、または&lt;strong&gt;代替Webフィーチャ&lt;/strong&gt;（alternative Web feature）と呼ばれる。

最近のCatyは、Webフィーチャを切り替える機能を持っている。これは、汎用のモジュールローディング機能を利用しているのだが、その汎用機能はWebフィーチャの切り替えを目的に開発されたものである。メカニズムはどうでもよくて（つうか、あまり詮索して欲しくない^^;）、重要なことは、前もって準備された複数のWebフィーチャを切り替えて動作させることが出来るってこと。

Webフィーチャの切り替え機能を使うと、標準ではないWebフィーチャにより、&lt;em&gt;Webの偽装（faking）が出来る&lt;/em&gt;のだ。アクションのコードは一切変えない。アクションは本物のWeb上で動作していると思っている。本番稼働と何一つ変わらない挙動を示す。この状態で我々は、好きなだけシステムを監視／調査／記録／テストできる。ニセ物のWebなので、普通では起こらないような現象を人工的に作り出すこともできる。高負荷状態やクラッキングのシミュレーションも出来る。もう、&lt;em&gt;やりたい放題&lt;/em&gt;だ。ムフフ。

「自分で自分を苛め抜く」という意味のマゾ・テストも実行できる。あー、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20091019/1255913310&quot;&gt;あこがれのマゾ・テスト&lt;/a&gt;。あー、虐めたい／虐められたーい。

代替Webフィーチャにより非標準のWebを作り出すにしても、システム自身のメタ情報（主に設計情報）にアクセスできないと全自動テストはできない。が、CatyのレイフィケーションAPIはかなり揃ってきたし、今後さらに精密なレイフィケーションが出来るようになる。メタプログラミングを駆使して代替Webフィーチャを作ることにより、今までとは次元が違うテストができだろうと期待している。

最後に一言注意しておくと； フィーチャを切り替えたり、コードトランスフォーム／コードシンセサイズを使ってテストをすることは、何もアクションに限らない。一般のコマンドセットに対しても同様の手法を使うことができる。関連するコマンド達を一連の“シナリオ”に沿って網羅的に実行する。全自動、無人、長時間の実行をする。

*1348912114*[Caty][説明]CatyのWeb処理の背景

ひとつ前の記事「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120929/1348888484&quot;&gt;CatyのWeb処理： Webフィーチャとメタプログラミング&lt;/a&gt;」の背景の理屈を少し追加説明しておく。メモ書き程度だが。

背景は、入れ子の、あるいは多段のインスティチューション。いろいろな圏が出てくる。

+ Graph -- 有向グラフの圏。自己ループも多重辺も認める、まったく任意のグラフの圏。ただし小さい（たかだか加算で十分）なグラフが対象。
+ Syn -- 構文的対象（syntactic objects）の圏。対象は、頂点ラベルと辺ラベルが付いたグラフだが、ラベルを頂点そのもの、辺そのものと同一視して、SynはGraphの部分圏と考える。
+ Exp -- 構文モナド。ExpはSynの上のモナドで、乗法と単位は、入れ子になった式の展開と基本記号を式とみなす操作。
+ Sig -- 指標の圏。インスティチューションの指標を与える。Sig⊆Syn⊆Graph と考える。指標も有向グラフとなる。
+ V -- 計算モデルの圏、Vはvalueから。もちろん、射もあるのだが、評価の結果が入るのがVという感じ。

Sigは指標の圏だが、指標は構文的なグラフとなっている。Σが指標＝グラフとして、Mod[Σ] := [Σ, V] と定義する。ここで、[Σ, V] は、グラフΣから圏Vへのグラフ写像の全体を、自然変換と同様な感じで圏とみなしたもの。関手圏とほとんど同じ構成だ。

Σ∈|Sig| として、Exp(Σ) はΣから構成された式の全体。(m:Σ→V)∈|Mod[Σ]| があれば、mをExp(Σ) にまで拡張できる。というか、拡張できるようなフレームワークを考える。m:Σ→V の拡張を Exp(m):Exp(Σ)→V とする。この拡張は、Mod[Σ] → Mod[Exp(Σ)] という関手を与える。

具体例に移る。Σ = Σ&lt;sub&gt;Web&lt;/sub&gt; をWebフィーチャの指標（インターフェイス）だとする。Σは、圏Sigに属する固有の指標になる。指標だから意味は持たない。Mod[Σ] = Mod[Σ&lt;sub&gt;Web&lt;/sub&gt;] を、単に Web ともかく。Web = Mod[Σ&lt;sub&gt;Web&lt;/sub&gt;] の対象がWebフィーチャになる。W&lt;sub&gt;0&lt;/sub&gt;∈|Web| が標準モデル＝標準Webフィーチャで、他のWebの対象はすべて非標準ということになる。

指標Σ上で組み立てられた式eは、e∈Exp(Σ+Γ) であり、Σ=Σ&lt;sub&gt;Web&lt;/sub&gt;なら、eはWebシステムの一部となるものである。ΓはΣ以外に依存している指標。Γの意味を固定すると、e∈Exp'(Σ) と考えることができて、eの評価は Mod[Σ] の要素に依存することになる。これは、指標 Σ=Σ&lt;sub&gt;Web&lt;/sub&gt; に従った実装である W∈Mod[Σ] = [Σ, V] を変えると、Webシステムの挙動が変わることを意味する。

なんか中途半端だが、メモだからここまでだ。

</body>
</day>
<day date="2012-10-01" title="">
<body>
*1349046994*[Caty][説明]ニセWebの作り方

&lt;em&gt;Catyのドキュメンテーションに含めるつもりの記事（の下書き）。&lt;/em&gt;

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20120929/1348888484&quot;&gt;CatyのWeb処理： Webフィーチャとメタプログラミング&lt;/a&gt;」の続き。

Catyにとって、&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20091019/1255913310&quot;&gt;マゾ・テスト&lt;/a&gt;は大きな目標だった((僕の感覚としては、マゾ・テストが一番大きな目標かな。あと、ハイパーバリデーションも同程度の重さがある。))。マゾ・テストを想定しないと、Catyの設計判断は理解できないだろう。例えば、goto制御の導入； マゾ・テストは無限走行（実際は長時間走行）する。そのためには、どうしてもgoto制御が必要だった。なんと言われようとgotoなのだ。今、Catyには「おとなしいgoto」としてforwardとrepeatが入っている。

もうひとつ、マゾ・テストに必要なことは、&lt;b&gt;現実世界の内部模型化&lt;/b&gt;だ。具体的には、インターネットをまったく使わないでWebアプリケーションを実行すること。localhost（ループバックインターフェイス）さえ使わない。ネットワーク機能とは&lt;em&gt;まったく無縁&lt;/em&gt;に、Catyの内部世界機構だけでWebアプリケーションを動かす。

Catyの内部世界にニセのWebを作り出すことになる。&lt;b&gt;スノーグローブのWeb、箱庭のWeb、ミニチュアのWeb、内部Web、ジオラマのWeb&lt;/b&gt;とか … 色々な呼び方をしてきたが、ともかくも“本物ではないWeb”だ。

ニセWebには3つの特徴がある。

+ ネットワーク機能を一切使わない
+ サーバーサイドプログラムには、本物との区別が付かない
+ Webクライアントを含む

「本物との区別が付かない」ことは極めて重要である。本物との差があれば、「ニセWebは所詮ニセ物だから、役に立たない」となってしまう。マゾ・テストは無人全自動で行うが、本物のWeb上で人間が手動で行うテストと同じ効果がなくてはならない。

&lt;h4&gt;アクションの構造：Webラッパー部&lt;/h4&gt;

Webアプリケーションの実体は、アクションの集合体である。アクションは、概念的に2つの部分に別れる。

+ 本来のセマンティックな処理を行う部分
+ Webとの入出力の面倒をみる部分

「Webとの入出力」で、特にWebへの出力のほうに注目する（Webからの入力（リクエスト）の偽装（faking）は簡単なのでたいした問題ではない）。「本来のセマンティックな処理」の後で行うことを、さらに次の二種に分ける。

+ 装飾（decoration）処理 ： 出力コンテンツを、人やクライアント側アプリケーションが見やすい形に飾ったり整えたり。
+ 転送（transfer）処理 ： クライアントまでデータを送り届ける。

場合により、装飾処理は省略されることがある（JSONを使ったWebAPIのときなど）。一方、転送処理は必ず行われる。そうでないとクライアント／サーバー型システムにならない。

&lt;em&gt;注意：現状のexpandコマンドをrenderコマンドにリネーム予定。renderを使って書く。&lt;/em&gt;renderの日本語は「描出」かな。

装飾処理と転送処理には、それぞれ次のコマンドが使われる。

+ render ： テンプレートパスを引数にして、そのテンプレートによりデータを装飾する。
+ responce ： 入力データにHTTPヘッダを付けてレスポンスデータを作る。

ここで、responseは、単に「レスポンスデータを作る」だけでなく、そのデータをクライアントまで届ける機能も内在していると考える。

&lt;h4&gt;responseコマンドの置き換え&lt;/h4&gt;

responseを、「データをクライアントまで届ける機能を内在している」と考えると、アクションの終りでは必ずresponseを呼ばなくてはならないことになる。関数の終りにreturnが必要なのと同じだ。アクション（の実装コード）がresponseで終わっているかどうか？ はフロー解析で分かるので、そうなってないときはエラーにできる。つまり、アクションは必ずresponseで終わっていると仮定してよい。（例外／シグナルは許容する。）

実際のWebサーバー環境下でアクションが動くとき、responseは実際に「データをクライアントまで届ける」ように機能する。メカニズム的には、アクションの外側のWebサーバー／Webアプリケーションコンテナーが転送を実現しているのだが、&lt;em&gt;responseが「転送の指示を出している」&lt;/em&gt;と言って差し支えない。

ニセWebを作るためには、responseが「ニセの転送」を指示するか／実行してしまえばよい。ニセであっても、&lt;em&gt;データの送り先はクライアント&lt;/em&gt;である。クライアント？ ニセの世界にクライアント（通常はブラウザと人間）なんているのか？ いるんです！ &lt;b&gt;They exist within the fake world.&lt;/b&gt; ニセWebの特徴の三番目に挙げた「Webクライアントを含む」がポイントになってくる。

ニセのWebクライアントは、コマンド（スクリプトコード）で実現される。このスクリプトコードはクライアントエミュレーション・スクリプトと呼ばれたりしてる。単にニセクライアントと呼んでもいいだろう。ニセWebの世界で「データをクライアントまで届ける」とは、「ニセクライアントであるコマンドを呼ぶ」ことに対応する。ニセのresponseは、ニセのクライアントに制御を移すのだ。制御の移し方の“トポロジー”は、ハイパーリンクグラフの情報から得られる。

ここで問題が生じる。サーバーとクライアント間の制御の移動は（概念的には）無限に続く。アクション（と呼ばれるコマンド）とニセクライアント（と呼ばれるコマンド）のあいだで、無限の相互呼び出しが発生する。通常はスタックを使い潰し破綻する。Catyにgoto制御が必要な本当の理由はここにある。forward制御は、スタックを消費しないで制御移譲ができるので、サーバー／クライアントのあいだの無限回の相互呼び出しを実現できる。

http://d.hatena.ne.jp/m-hiyama/20120828/1346114644 の最後の（短い）サンプルである「制御をピンポンして無限に Hello, world. を印字し続けるスクリプト」を参照のこと。

&lt;h4&gt;renderコマンドの置き換え&lt;/h4&gt;

クライアントが「ブラウザ＋人間」である場合、HTMLによる表示、しかも凝った表示が必要になる。ニセのクライアントであるクライアントエミュレーション・スクリプトは、凝ったHTMLを受け取っても困惑するだけだ。

renderコマンドを置き換えることにより、クライアントエミュレーション・スクリプトにとって都合のよいデータを作り出すことができる。

&lt;h4&gt;その他&lt;/h4&gt;

アクションが正常終了すれば、データはrender（省略可能）とresponseを通ってWebに出ていく。アクション内でシグナル／例外が発生すると、アクション内に書かれたresponseは通らない。シグナル／例外のハンドラーに制御が移り、そのなかで再びresponseされる。シグナル／例外のハンドラー内でも置き換えたresponseが使われれば、ニセWebは正しく機能するが、必要ならシグナル／例外のハンドラーをゴッソリ入れ替えてしまうこともできる。

本物のシグナル／例外ハンドラーでは、スタックトレースなどの詳細情報を潰してしまうことが多いので、テストやデバッグの目的では、ハンドラー（マッパー）を置き換えることになるだろう。

というわけで、response, render, map-signal, map-exceptionの置き換えでニセWebが出来る。最小の置き換えならresponseだけでもいけるはずだ。

*1349051939*[プログラム意味論]インスティチューション指標圏の直和と構文構成モナドのクライスリ圏

Σ、Δが指標とする。Expr(Σ) がΣから構成される式の集合だとする。Exprはモナドになるので、指標圏をモナド付きの圏と考える。このモナドのクライスリ圏の反対圏を考えると、これは「定義の圏」となる。それで、定義の圏においては、指標の直和 Σ+Δ が直積を与える。これはなかなかに象徴的な事実だと思った。

</body>
</day>
<day date="2012-10-02" title="">
<body>
*1349148564*[Caty]branch非決定性制御構造 ： ランダムウォーク

branchで非決定性の選択をする。forwardと組み合わせると、有向グラフ上のランダムフォークが簡単に書ける。

&lt;pre class=&quot;code&quot;&gt;
command foo :: string -&gt; never {
 [&quot;reached at foo, from &quot;, pass] | text:concat | cout;
 &quot;foo&quot; | forward hub
};

command bar :: string -&gt; never {
 [&quot;reached at bar, from &quot;, pass] | text:concat | cout;
 &quot;bar&quot; | forward hub
};

command baz :: string -&gt; never {
 [&quot;reached at baz, from &quot;, pass] | text:concat | cout;
 &quot;baz&quot; | forward hub
};

command hub :: string -&gt; never {
 pass &gt; from;
 sleep 500;
 %from |
 branch {
   foo =&gt; forward foo,
   bar =&gt; forward bar,
   baz =&gt; forward baz,
 }
};
&lt;/pre&gt;

&lt;img src=&quot;http://www.chimaira.org/img3/branch-sample.gif&quot;&gt;

いまいちグラフがうまく描けない。

&lt;pre class=&quot;code&quot;&gt;
 [
   gv:node foo,
   gv:node bar,
   gv:node baz,

   gv:node --shape=doublecircle hub,

   /* 戻りの中間のエッジポイント */
   gv:node --shape=point --label=&quot;&quot; to-foo,
   gv:node --shape=point  --label=&quot;&quot; to-bar,
   gv:node --shape=point  --label=&quot;&quot; to-baz,

   gv:edge foo hub,
   gv:edge bar hub,
   gv:edge baz hub,

   /* ハブノードからの戻り */
   gv:edge --style=dashed --arrowhead=none hub to-foo,
   gv:edge --style=dashed to-foo foo,
   gv:edge --style=dashed  --arrowhead=none hub to-bar,
   gv:edge --style=dashed to-bar bar,
   gv:edge --style=dashed  --arrowhead=none hub to-baz,
   gv:edge --style=dashed to-baz baz,
 ] | gv:graph 
&lt;/pre&gt;


</body>
</day>
<day date="2012-10-04" title="">
<body>
*1349334591*[リンク][プログラム意味論]オープングラフを使った理論

これは重要だと思う。

- Title: Open Graphs and Monoidal Theories (Submitted on 18 Nov 2010)
- Authors: Lucas Dixon, Aleks Kissinger
- URL: http://arxiv.org/abs/1011.4114

*1349335284*[Caty][プログラム意味論][その他代数]ソフトウェアにおける change-of-base

加群の理論だと、The change of base of a module M  のような言い方をする。これと、ぶっちゃけ何の関係もないが、雰囲気的に近い概念。

あるソフトウェアAが、ライブラリLに依存して作られているとき、LをL'に置き換えてAを動かすことが change-of-base 。多くの場合は破綻する。どうしたら破綻しないで有効に使えるか？ が課題。

*1349343223*[Caty]リソースとトリガー

アプリケーション、モジュール、コマンド／型などがメタオブジェクトグラフ（モグラ）に存在するのだが、リソースとトリガーはどうも異質だ。異質だから、取り扱うときの心構えは変える必要がある。

以前、なんかモタモタしていたのは、リソース（クラスとインスタンス）もモグラのなかで考えていたからだろう。むしろ、アクションとリソースインスタンスのマトリックス（直積）を考えて、これはモグラと別にしたほうがいい。モグラとは独立に管理したほうがいい。

</body>
</day>
<day date="2012-10-05" title="">
<body>
*1349402873*[Caty]コマンドラインで色々

&lt;b&gt;[追記]&lt;/b&gt;ヘボイが、misc::browser:show で&lt;em&gt;いちおう&lt;/em&gt;ブラウザに出せる。&lt;b&gt;[/追記]&lt;/b&gt;

最近使った例

+ gen:sample wsgi:Request
+ gen:sample --occur=min --string=implied wsgi:Request
+ gen:sample wsgi:Request | wsgi:req-to-env // 通常はエラーする
+ try --wall=superhard {gen:sample wsgi:Request | wsgi:req-to-env} // たまに成功する
+ try --wall=superhard {gen:sample wsgi:Request | dump | wsgi:req-to-env} | catch {normal =&gt; pass, except=&gt;void}
+ list:range 0 100 |each {try --wall=superhard {gen:sample wsgi:Request | dump | wsgi:req-to-env} | catch {normal =&gt; pass, except=&gt;undefined} }
+ list:range 0 100 |each {try --wall=superhard {gen:sample wsgi:Request | dump | wsgi:req-to-env} | catch {normal =&gt; pass, except=&gt;undefined} } | list:tighten
+ setenv x {list:range 0 100 |each {try --wall=superhard {gen:sample wsgi:Request | dump | wsgi:req-to-env} | catch {normal =&gt; pass, except=&gt;undefined} } | list:tighten}
+ %x |each {$.REQUEST_METHOD}

グラフの画像を動的／静的にレスポンスする方法

+ gv:node a
+ [gv:node a, gv:node b]
+ [gv:node a, gv:node b, gv:edge a b] | gv:graph
+ [gv:node a, gv:node b, gv:edge a b] | gv:graph | gv:draw --format=dot
+ [gv:node a, gv:node b, gv:edge a b] | gv:graph | gv:draw --format=svg | cout
+ [gv:node a, gv:node b, gv:edge a b] | gv:graph | gv:draw 
+ [gv:node a, gv:node b, gv:edge a b] | gv:graph | gv:draw | ct:show-image
+ [gv:node --shape=box a, gv:node b, gv:node c, gv:edge a b] | gv:graph | gv:draw | ct:show-image
+ [gv:node --shape=box a, gv:node b, gv:node c, gv:edge a b] | gv:graph | gv:draw | file:write /sample.gif
+ file:read /sample.gif
+ file:read /sample.gif | ct:show-image
+ file:read /sample.gif | response --ext=.gif
+ [gv:node --shape=box a, gv:node b, gv:node c, gv:edge a b] | gv:graph | gv:draw | response --ext=.gif

まだ作ってないが； dict-of-lists形式のグラフから実際の描画、それと簡単なグラフコンパイラでモジュールを生成して、そのモジュールによるランダムフォークを実行する。

次はWSGI関係。

+ request /
+ select-action /
+ wiki.Root.get --0=/
+ wsgi:make-env /
+ wsgi:make-env / | wsgi:process-env
+ wsgi:make-env / | wsgi:call-application
+ wsgi:make-env / | wsgi:lookup-and-exec
+ wsgi:make-env / | dump | wsgi:process-env | dump | wsgi:lookup-and-exec

*1349405745*[映画]『バイオハザードV: リトリビューション』

『バイオハザードV: リトリビューション』を観た。このシリーズ、Iは見てない； あとは見た。映画としての出来はIIが一番良くて、そのあとはなんか劣化している印象がある。しかし、僕にとっては別にまーそれでもいいし、それでも『バイオハザード』は見に行くのだ。なぜなら、もうホラーとかゾンビは期待してないわけで、キレイで強いオネーサンがかっこいいアクションを演じる、と、もうそれで十分。

アリスはもちろんだけど、ジル・バレンタインとエイダ（Ada）とレインも出てくる。いやー素晴らしい。僕のような観客は多いと思う、制作・監督のポール・W・S・アンダーソンはそのへんを知っているのだろう。割り切っている感じがするね。

ちょっと残念な感じがするのがジル・バレンタイン（シエンナ・ギロリー）かな。IIではとても良かった、僕はアリスより良かったと思うのだが、今回は黒髪から金髪に変わったこともあってか、かなり印象が違う。ちょっとオバサンぽいし。ミラ・ジョヴォヴィッチが鋭い印象を保っているのに対して、シエンナ・ギロリーは「強い女」としては衰えた感がある。

エイダ（Ada）をやっていたリー・ビンビンという女優さん、いいんだけど、ミラ・ジョヴォヴィッチの隣に立つと、ズングリに見えちゃう。実際は彼女もスタイルいいのだろうけど、ミラの手足の長さが普通じゃないからな。

さて、レイン・オカンポをやっていたミシェル・ロドリゲス、彼女はカッコイイですね。腕の太さがハンパないし。思いっきり強そう。『アバター』でヘリコプターを操縦していたのも彼女か。『世界侵略：ロサンゼルス決戦』にも出てた、女性兵士で； いまいち大暴れしてないけど。ともかく、あのマッチョぶりが素晴らしい。

</body>
</day>
<day date="2012-10-06" title="">
<body>
*1349504605*[Caty]属性付きスカラーデータの生成と検証

凡例：

- ×× -- まったく不可能
- × -- 極めて困難
- △ -- がんばれば出来る
- ○ --できる 

JSONスキーマのスキーマ属性：

|* 属性名  |* genでサポート可能か |* validateでサポート可能か |
| minimum  | ○                   | ○ |
| maximum  | ○                   | ○ |
| minLength| ○                   | ○ |
| maxLength| ○                   | ○ |
| format   | △                   | △ |
| pattern  | ×                   | ○ |
| minItems | ○                   | ○ |
| maxItems | ○                   | ○ |

Caty独自のスキーマ属性：

|* 属性名      |* genでサポート可能か |* validateでサポート可能か |
|remark        | ××                 | ×× |
|minProperties | ○                   | ○ |
|maxProperties | ○                   | ○ |
|tight         | ○                   | ○ |
|propNameFormat| △                   | △ |


</body>
</day>
<day date="2012-10-18" title="">
<body>
*1350534982*[Caty]デモ、忘れたことなど

+ browser:show が動かなかった？
+ テンプレートをその場で作ったせいで noescape を忘れた。テンプレートは先に作っておくべき。
+ showmo, showst, showur, showac とか覚えきれない。でも、覚えたほうがいい。
+ move-to-schemata もコマンド名を忘れた。
+ validate, gen:sample, fill
+ print と response 
+ select-action と request
+ CatyFITを全然紹介しなかった。
+ レイフィケーションは間接的でもいいかな。
+ 現状のコンソールヘルプは何か変だ。


</body>
</day>
<day date="2012-10-20" title="">
<body>
*1350714050*[メモ]GoogleのJavaScriptライブラリ サービス

こう書けばいいのか。オフラインだと動かないが、とりあえず便利。

&gt;|html|
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;google.load(&quot;jquery&quot;, &quot;1.4&quot;);&lt;/script&gt;
||&lt;


*1350714051*[Caty][メモ] TreeEditUI

/ProjectCaty/TmpWork/TreeEditUI/ というディレクトリがあるが、TmpWorkじゃなくて、Boxesにしようかな？

Boxesって意味不明なんだが、僕も起原がわからない。とにかく思い浮かんでしまった言葉だ。

</body>
</day>
<day date="2012-10-25" title="">
<body>
*1351119894*[メモ]Collaborative Dysfunction

アトラシアンの広告で Collaborative Dysfunction という言葉が使われていた。

*1351156568*[メモ][msched]課金とか謝礼とか

mschedタグのmってなんだっけ？ schedはスケジュールだけど。ん？ http://d.hatena.ne.jp/m-hiyama-memo/20081213/1229138718  にmeetingだって書いてある。meetingだったのか。

さて、最近またスケジュールを考えているが、セミナーとかの課金とか謝礼をどうするか？ とりあえず登場するモノコト人は：

+ 行動主体、ユースケースで言えばactor、あるいはagent、userと言ってもいいかも。
+ issue -- なんらかの課題、主題、セミナーや勉強会なら告知と考えてもいい。
+ event -- 実際に行われたコト
+ token -- 移動する値。本来の意味のトークンで、コインみたいなもの。お金やナントカポイントの抽象化。
+ move -- トークンの移動。
+ イベントと参加者の対する評価 -- よくわからん
+ flow -- moveの連続


</body>
</day>
<day date="2012-10-29" title="">
<body>
*1351471564*[メモ]ラベル付き遷移系の並列結合（並列じゃないな）

X = (S, L, δ) は「状態空間がSでラベル集合がLで遷移関係がδであるラベル付き遷移系とする。A, B を集合だとして、i:A→L、j:B→L は埋め込み。この2つの埋め込みを一緒にしたX = (S, L, δ, i, j) を射と考えて、X:A→B (S) とする。ホムセットは Hom(S; A, B) のように3つのパラメータを持つ。

Sを固定すると圏となる。Sを動かすとインデックス付き圏となる。

&lt;b&gt;[追記]&lt;/b&gt;見出しの「並列結合」は間違い。まー、世間的な用法ではあながち間違いとも言えないが。これはIO結合だ。IO結合が逐次処理されるか、並列処理されるかは別問題。状態遷移ベースの計算モデルにたいして、遷移系の操作はものすごく色々あるが、それらの操作と並列性はまったく独立した問題だった。実行はある種の関手であり、関手そのものと、関手の域／余域は別な概念。僕自身これを混同したいたと思う。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2012-11-01" title="">
<body>
*1351760440*[メモ]PayPalの手数料

PayPalで送金すると、通常 3.6%+40円 がかかる。プライベートな送金なら無料だが、この「プライベート」がどうもグレーで、違反するとアカウント停止。

&gt;|lisp|
(defun calc-pay-1 (x)
  (- (- x (* x 0.036)) 40))

(defun calc-pay-2 (x)
  (calc-pay-1 (calc-pay-1 x)))

(defun calc-pay (x r)
  (- (calc-pay-2 x) (* x r)))
||&lt;

1000円を中継して2回送金すると850円しか受け取れない。ムー。2000円で別に5%の手数料だと、1680円、3000円で2560円弱。なんかムシられている印象がある。

小額決済って、割があわないなー。

&lt;b&gt;[追記]&lt;/b&gt; オンラインで一旦支払って、なんかの事情で返金する状況を考えているのだけど、1,000円なら85%, 10,000円でも92%になってしまう。千円から一万円の額では、15%から8%が送金の移動だけで吹っ飛んでしまう。1回の移動でも8%から4%程度の負担になる。これは利便性の代償として適切なのか？ &lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2012-11-02" title="">
<body>
*1351828513*[プログラム意味論]並列処理

並列処理がやっと少しはわかった気がした。当たり前のことだが、「CPUとは何であるか？」を理解しないと並列処理は理解できない。別な言い方をすると、CPUの形式的な定義が必要。

ラベル付き遷移系は、状態空間とメソッド（ラベル）からなるから、クラスだと思ってよい。特定の状態点がオブジェクトだ。オブジェクト （＝状態点）の時間的な運動が実行になる。

オブジェクトにはデータオブジェクトとプロセスオブジェクトがある。この違いは何か？ プロセスオブジェクトはCPUを持つ、データオブジェクトは持たない。それだけだ。CPUとは何かというと、自律的自発的に時間発展するナニカなんだが、その定式化は結局は時間シェープ（時間の空間）となる。時間シェープTから状態遷移グラフ（離散的なトポロジーを持った状態空間）への写像が実行。

CPUの概念、自発性／自律性が、時間シェープとそこからの写像として定式できる。時間シェープの幾何学的な性質や幾何学的な操作を考えないでは、並列性、同期／非同期、待ち合わせなどは形式化できないだろう。


</body>
</day>
<day date="2012-11-03" title="">
<body>
*1351906883*[Caty]Catyの原理と図示法

Catyで実行可能なものは&lt;strong&gt;コマンド&lt;/strong&gt;である。コマンドだけが実行可能であり、コマンドしかない。その意味でコマンド一元論。アクションというのもあるが、これはWeb経由で呼び出し可能なコマンドをアクションと呼んでいるに過ぎない。

コマンドは入力と出力を持ち、入力も出力も型を持つ。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-command.gif&quot; &gt;

コマンド宣言は次のように書かれる。

&lt;pre class=&quot;code&quot;&gt;
// cmdは、入力の型がSで、出力の型がTであるコマンド

command cmd :: S -&gt; T;
&lt;/pre&gt;

入出力（StdIn/StdOut）以外に、オプションと引数によりコマンドに付加的な情報を渡せるが、今は触れない（http://d.hatena.ne.jp/m-hiyama-memo/20120104/1325644069 を参照）。

次の図は、ユースケース図に類似している。ユースケースの代わりにコマンドが描いてある。ユースケースは抽象的・概念的だが、コマンドは実際に動くものだ。その意味で、ユースケースより実装寄りで抽象度は低くなっている。アクターは、コマンドを実行する主体である。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-actor.gif&quot; &gt;

アクターがコマンドを実行する際に、なんらかのインターフェースを必要とすることがある。このインターフェースを便宜上「画面」と呼ぶことが多い。「画面」は比喩的な表現で、ホントに画面である必要はない。次の図では、画面（比喩的）をロバストネス図の境界オブジェクト風に描いてる。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-basic.gif&quot; &gt;

画面1はコマンドaを起動する画面、画面2はコマンドaの結果を表示する画面だ。点線矢印は時間推移を示す。つまり：

+ アクターは、aの起動画面である画面1で入力を準備し、起動指示を出す。
+ 画面1からやってきた入力データによりコマンドaが実行される。
+ コマンドaの実行結果が画面2に表示される。

これが一連のフローを形成する基本ステップとなる。

以下では、アクター（スティックマン）を描くのは省略する。画面（＝境界オブジェクト）にアクターはいつも貼りつていると考えてよい。次の図は画面の変種で、左は「aの結果表示とbの起動」を兼任している画面、右は「aの起動とaの結果表示」を兼任している画面である。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-variants.gif&quot; &gt;

基本ステップの組み合わせ方を示しておく。まずは、順次実行（逐次、直列）。コマンドaを実行し、次にコマンドbを実行する。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-sequence.gif&quot; &gt;

それと選択的実行。画面1から、コマンドaかコマンドbのどちらかを実行できる。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-choice.gif&quot; &gt;

次の図は、以上に述べたことを組み合わせた例。画面1からコマンドa, b, cのどれかを実行できる。aまたはbの結果は同じ画面1で確認できる。コマンドcを実行すると、その結果は別種の画面である画面2で確認できる。

&lt;img src=&quot;http://www.chimaira.org/img3/spd-example.gif&quot; &gt;

これらの図は有向グラフであり、有向辺（矢印）は、「入力データの流れと実行指示」または「出力データの流れ」を表してる。Webアプリケーションではそれぞれ「リクエスト」「レスポンス」となる。初期画面から有向辺をたどっていく経路は、アクターが経験する推移の系列（シナリオのインスタンス）を表現する。

画面が持つUIとしての機能性や美しさ（デザイン）はもちろん重要だが、どのようなコマンド（タスク、処理、仕事）をどのような順序で実行するのか、という全体の構造が明確でないと個々のUIも意味を失う。よって、このような図示法を用いたサービス構造のプランニングが重要となる。

最後にCatyで描いた図の実例。&lt;a href=&quot;http://www.chimaira.org/img3/spd-addrbook-j.gif&quot; &gt;実物大はコレ&lt;/a&gt;

&lt;img width=&quot;500&quot; src=&quot;http://www.chimaira.org/img3/spd-addrbook-j.gif&quot; &gt;

*1351907839*[Caty]ワイヤーとジャンクション （再）

http://d.hatena.ne.jp/m-hiyama-memo/20120104/1325658594 と同じ内容だが、もう一度説明。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/junctions.gif&quot; &gt;

+ 型Aのデータが流れるワイヤー
+ 値xが生成される
+ 値が特にvoidのときは、点線にする。voidが生成される、あるいはvoidが流れるワイヤー。
+ 型Aのデータを捨ててしまうためのワイヤー。ゴミ箱ワイヤー。結果はvoid。
+ 型Aのデータをコピーして同じ値を２つにする。
+ 別々にやってきた型Aのデータと型Bのデータを１つのタプルにまとめる。
+ タプルを分解する。
+ 型Aのデータをどちらか片方に流す。この白丸は非決定性。
+ 2箇所からのデータを単にマージする。出口の型は A∪B （A, Bと書いてあるが）。
+ 排他的ユニオン型 A|B のデータを型により振り分ける。

*1351921052*[メモ]PayPalとAmazonギフト券

PayPal以外に、ある種の送金機能としてAmazonギフト券がある。単なる番号だからメールで送れるし、誰かに譲渡することもできる。送金手数料はゼロだ。しかし：

- アマゾンで買い物をしない人には価値がない
- 現金に換金するのが困難。よくても8割くらい。現金の価値と考えると、PayPalより悪くなる。
- 有効期限がある。

アマゾンで買い物する予定がある人にはいいが、そうでないとダメだな。

</body>
</day>
<day date="2012-11-06" title="">
<body>
*1352183852*[メモ]ダウンロードとアカウント

ダウンロード用に、アカウントを発行してそれを使え、ってのは良くない方法だと思った。


</body>
</day>
<day date="2012-11-07" title="">
<body>
*1352280747*[Caty]CatyScriptとファシリティとエンティティ

Catyでは、コマンド／アクション（アクションはコマンドの特殊なもの）は薄緑の楕円で描くことにしている。単なる習慣だけど、習慣を守るとイチイチどうしようかと考えなくて済む。

CatyScriptは徹底的に図式的・絵的（pictorial/graphical/diagrammatic）な設計になっている。テキストで書くコマンドシェル言語だが、有向グラフによる可視化と対応するようになっている。スクリプトの基本要素であるコマンドノードは（今の習慣だと）薄緑の楕円なわけだ。

複数のコマンドノードのあいだを結ぶ矢印（ワイヤー、パイプ、ケーブル）には、まず、データフロー辺がある。CatyScriptでは、データフローと制御フローの区別がない。別な言い方をすると、制御は常にデータと共に流れるのだ。Catyでvoidデータが重要なのは、voidは&lt;em&gt;情報は運ばないが制御を運ぶ&lt;/em&gt;からだ。つまり、voidデータの受け渡しが、（実質的データ受け渡しを伴わない）制御の受け渡しとなる。

CatyScript／Catyスキーマの図示（可視化）では、ノードとなるコマンド、ワイヤー（のラベル）となる型以外に、次の要素が存在する。

- クライアント状態（state）
- ファシリティ（facility）

これらは、ロバストネス図では：

- バウンダリーオブジェクト
- エンティティオブジェクト

に対応する。もちろん、コマンドはコントロールオブジェクトに対応する。

最近になって、CatyScript／Catyスキーマでも、ファシリティの同義語（微妙に違うがほぼ同じ）として entity という言葉を使うことにした。ファシリティ／エンティティの図示の例は次。

&lt;img src=&quot;http://www.chimaira.org/img3/caty-entities-diag.gif&quot; &gt;

ファイルシステム（Catyではmafsと呼ぶ）に対するファイル書き込みと同時に、KVSに管理用メタデータも書くとする。Data.putアクション（Webから呼び出せるコマンドがアクション）が、ファイルシステムとKVSの両方に書き込みを行う。Data.getアクションは、ファイルシステムからの読み出し。Data.indexアクションが、管理メタデータ一覧（インデックス）をKVSから読む。そういう状況を図示している。

コマンド／アクションとファシリティ／エンティティを結ぶ辺（矢印）は3種類。

+ reads ： データを読み出す。
+ updates ： データを書き込んで更新する。
+ uses ： 読み書きの両方を行う。

&lt;b&gt;[追記]&lt;/b&gt;絵を描いたスクリプトを以下に貼る。&lt;b&gt;[/追記]&lt;/b&gt;

====

&gt;||
// -*- coding: utf-8 -*-
/* ロバストネス図のバックエンド側のサンプル */
module g;

command action-node [string name] :: void -&gt; gv:Node {
  gv:node 
    --fontsize=14.0
    --shape=ellipse
    --style=filled
    --color=black
    --fillcolor=darkseagreen2
  %1
};

command entity-node [string name] :: void -&gt; gv:Node {
  gv:node 
    --fontsize=14.0
    --shape=Mcircle
    --style=filled
    --color=black
    --fillcolor=darkorange3
  %1
};

/* エッジの指定順序は、常に アクション エンティティ の順 */

command reads-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --dir=back
    --label=reads
  %1 %2
};

command updates-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --label=updates
  %1 %2
};

command uses-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --dir=both
    --label=uses
  %1 %2
};

command sample :: void -&gt; gv:Digraph {
 [
   action-node act1,
   action-node act2,
   action-node act3,
   entity-node ent1,
   entity-node ent2,
   
   uses-edge act1 ent1,
   reads-edge act2 ent1,
   updates-edge act2 ent2,
   reads-edge act3 ent2,
 ] | gv:graph sample
};


command sample2 :: void -&gt; gv:Digraph {
 [
   action-node Data.get,
   action-node Data.put,
   action-node Data.index,

   entity-node &quot;mafs\npub&quot;,
   entity-node &quot;kvs\nindex&quot;,
   
   reads-edge Data.get &quot;mafs\npub&quot;,
   updates-edge Data.put &quot;mafs\npub&quot;,
   updates-edge Data.put &quot;kvs\nindex&quot;,
   reads-edge Data.index &quot;kvs\nindex&quot;,
 ] | gv:graph sample2
};

// End of Module
||&lt;

</body>
</day>
<day date="2012-11-08" title="">
<body>
*1352336370*[Caty]プランの記述と可視化

「設計」（design）より「プラン」（plan）という言葉を使おうと思う。これはH氏の提案だ。英辞郎でplanを引くと：

- 計画、企画、予定、今後の進め方
- 設計図、図面、平面図、伏図
- 意向、つもり、考え、意図 ◆通常複数形で使う

とあり、もともと&lt;em&gt;絵図の意味&lt;/em&gt;を持つようだ。素晴らしい。

システム構造のプラン記述法として、僕が想定しているのはロバストネス図だ。だが、ユースケース図やロバストネス図を意識するより前に、Catyを設計しているので、Catyの用語法はユースケース図／ロバストネス図のそれとはズレている。

|* ロバストネス図  |* Caty       |* Catyキーワード |
| バウンダリー     | クライアント状態 | state |
| コントロール     | コマンド／アクション | command/action |
| エンティティ     | ファシリティ／エンティティ | facility/enitity |
| アクター         |ユーザーロール | userrole |

用語&quot;entity&quot;が一致してるのは、最近導入して、意図的に同じ名称を採用したから。他は違う言葉だ。このズレを無理に直すと不都合もあるから、しばらくは気にしないことにする。むしろ、出自も言葉も違うのに、同じ概念を指し示している&lt;em&gt;符合と必然性&lt;/em&gt;のほうに注目すべきだろう。

これらの&lt;strong&gt;プラン要素&lt;/strong&gt;を描いた図を4つ、本編から拾って以下に貼る（原寸大、けっこう横幅ある）。レイアウト方法は違っているが：

- バウンダリー＝クライアント状態 → 黄色
- コントロール＝アクション → 薄緑
- アクター＝ユーザーロール → 白

という色目は共通している。

&lt;img src=&quot;http://www.chimaira.org/img2/lunch-reserve.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/lunch-reserve-ur.gif&quot; &gt;
&lt;img src=&quot;http://i.imgur.com/V56lz.gif&quot; &gt;
&lt;img src=&quot;http://www.chimaira.org/img2/draw-action-1.gif&quot; &gt;

それと、昨日の「アクションとエンティティの関係」の図。

&lt;img src=&quot;http://www.chimaira.org/img3/caty-entities-diag.gif&quot; &gt;

&lt;hr &gt;

これらの図を眺めていると、システムやサービスの構造を定義する行為（＝&lt;strong&gt;プランニング&lt;/strong&gt;）は、次の3つに分けると良さそうだ。

+ インタラクション・プランニング ： アクター、バウンダリー、コントロールの関係を定義する。Catyだと、クライアント状態（≒画面）の遷移がどのようなアクションを経由して行われるかを定義することになる。図（有向グラフ）では、状態→アクションのリクエスト辺、アクション→状態のレスポンス辺、アクション→アクションのリダイレクト辺などの繋がり具合いを描く。
+ エンティティ・プランニング ： コントロールとエンティティの関係を定義する。Catyだと、コマンド／アクションが、どのエンティティを利用するかを定義（宣言）することになる。図（有向グラフ）では、コマンド／アクションとエンティティのあいだに、reads, updates, uses の辺を描く。
+ アルゴリズム・プランニング ： これは、コマンドの内部を記述すること。プリミティブコマンドは別にして、コマンド／アクションはスクリプトコードとして実装される。スクリプトの構造はデータフローグラフ（＝制御フローグラフ＝フローチャート）として描ける。

コマンドが&quot;中央”の位置にあると考えれば：

+ インタラクション・プランニングは、コマンドのフロント側のプランニング
+ エンティティ・プランニングは、コマンドのバック側のプランニング
+ アルゴリズム・プランニングは、コマンド自体（その挙動）のプランニング

と考えることができる。

このような分類は層（tier）に分けることだが、それとは別に、分割統治原理に従いモジュールやパッケージの機構は準備している。複数のモジュールを繋ぎ合わせるメカニズムは&lt;strong&gt;ポート&lt;/strong&gt;と呼ぶ。次の図の、輪郭が点線の楕円がポートだ。ポートに入る矢印は、他のモジュールにある実際のノードに繋がることになる。繋がり具合いは別に定義する。（ポートを繋ぐ部分がまだ出来てない。）

&lt;img src=&quot;http://www.chimaira.org/img2/jstaskman-sample1.gif&quot; &gt;

CatyScriptはもともと、良く構造化された（well-structured）シェル言語として設計されている。プランニング言語を意図したわけではないが、ひるがえって「プランニング言語はどうあるべきか？」と考えると、それは「徹底的な可視化が可能な、良く構造化されたシェル言語」じゃないのか、とも思える。



</body>
</day>
<day date="2012-11-09" title="">
<body>
*1352439061*[Caty]不完全なモジュールを許容すること

Catyの諸々の定義やプログラムは、モジュールで構成される。そのモジュールを可視化すると、疑問符（'?'）やグレーの図形が表示されることがある。

&lt;img src=&quot;http://www.chimaira.org/img3/caty-incomplete-mod.gif&quot; &gt;

このモジュールのソースは次。

&lt;pre class=&quot;code&quot;&gt;
/** 
 * 不完全なモジュール 
 */
module tt in cara;

/** 型の定義は後でする（deferredで遅らせる） */
type Foo = deferred;

@[abstract]
state start :: any
links {
  root --&gt; Root.get;
};

resource Root(&quot;*&quot;) { 
/* リソースのパターンはまだハッキリしない（ワイルドカード） 
 * って、わざとらしすぎる。Rootは &quot;/&quot; だろうけどね。
 */

  action get(&quot;GET&quot;)
  :: _ -&gt; _ /* 入出力の型は明示されてない、アンダースコアでお茶を濁す */
  produces HomePage /* 生成するページはまだ定義してない */
  ; /* アクションの本体が定義されてない、書いてない */
  
};


state ViewItem for viewer :: any /* 状態の型はとりあえず何でもいい（any）とする */
links {
  /* リンク先は未定義 */
  next --&gt; View.next;
};

// End of Module
&lt;/pre&gt;

そもそも必要な定義を書かないとか、ダミーの目印を埋めておけばいいとかが多い。そのような&lt;em&gt;テケトーなモジュール&lt;/em&gt;を書いても、構文エラー（セミコロンが抜けているとか）がない限りはロードされる。正常にロードされたからこそ、可視化もできるわけだ。

こういう仕様になっているのは、Catyは&lt;em&gt;白紙から&lt;/em&gt;システム構造を記述することを想定しているからだ。白紙から構想を書き下すとき、ボトムアップよりはトップダウンで考えることが多い。上部構造（トップ側の構造）で参照している詳細（ボトム側の構造）が未定義だとエラーするではオハナシにならない。名前や関係を先に定義して、詳細や実装は後回しになる。当然に試行錯誤もする。

そのように、何もないところからシステムを組み立ていく行為を支援するには、&lt;em&gt;不完全で未定義部分が残るモジュール&lt;/em&gt;を認める必要がある。Catyのモジュールでは、明らかに破綻する／矛盾することを書かない限りはエラーとはしない。あるいはエラーを回避する方法（主にダミー構文）を準備している。

でも、最終的にはテキトーじゃ困る。これは、別途バリデーターとかリントツールにより解決する。これらのツールは、記述漏れや整合性をチェックして報告する。チェック用のツールの精度を上げれば、人間の不注意に起因する不完全さやリスク要因を事細かに指摘することもできる。

今見なおしてみると、アクションに対するHTTPメソッドは必ず書かなくてはならない、とか、「&lt;em&gt;テケトーさに欠ける&lt;/em&gt;」点も残っている。よりテケトー・イイカゲンにすべく改善しようと思う。


</body>
</day>
<day date="2012-11-10" title="">
<body>
*1352513105*[Caty]基本的な処理パターンの絵

Catyのコマンド／アクション、クライアント状態（≒画面、UI）、型チェックと分岐、ファシリティ／エンティティなどを使って、基本的な処理パターンを表現してみる。

&lt;img src=&quot;http://www.chimaira.org/img3/req-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//res-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//vali-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//load-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//save-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//func-c.gif&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3//send-c.gif&quot; &gt;


以下に描画用のソース。
====

&gt;||
// -*- coding: utf-8 -*-

/** ロバストネス風の図 */
module g;

command output-all :: void -&gt; void {
 req-c  | gv:draw --out=/req-c.gif;
 res-c  | gv:draw --out=/res-c.gif;
 vali-c | gv:draw --out=/vali-c.gif;
 load-c | gv:draw --out=/load-c.gif;
 save-c | gv:draw --out=/save-c.gif;
 func-c | gv:draw --out=/func-c.gif;
 send-c | gv:draw --out=/send-c.gif
};

command show-all :: void -&gt; void {
 file:read /req-c.gif  | ct:show-image;
 file:read /res-c.gif  | ct:show-image;
 file:read /vali-c.gif | ct:show-image;
 file:read /load-c.gif | ct:show-image;
 file:read /save-c.gif | ct:show-image;
 file:read /func-c.gif | ct:show-image;
 file:read /send-c.gif | ct:show-image
};

/** Request */
command req-c :: void -&gt; gv:Digraph {
 [ 
   state-node input,
   action-node command,
   req-edge input command
 ] | gv:graph --rankdir=LR Request
};

/** Response */
command res-c :: void -&gt; gv:Digraph {
 [ 
   state-node output,
   action-node command,
   res-edge command output
 ] | gv:graph --rankdir=RL Response
};

/** Validation */
command vali-c :: void -&gt; gv:Digraph {
 [
   gv:node --shape=point --style=invis vin,
   gv:node --shape=point --style=invis vout1,
   gv:node --shape=point --style=invis vout2,

   case-node type-check,

   gv:edge --label=&quot;&quot; vin type-check,
   gv:edge --label=OK type-check vout1,
   gv:edge --label=NG type-check vout2,
 ] | gv:graph --rankdir=LR Validation
};

/** Load */
command load-c :: void -&gt; gv:Digraph {
 [
   action-node command,
   entity-node store,
   reads-edge command store
 ] | gv:graph Load
};

/** Save */
command save-c :: void -&gt; gv:Digraph {
 [
   action-node command,
   entity-node store,
   updates-edge command store
 ] | gv:graph Save
};

/** Function */
command func-c :: void -&gt; gv:Digraph {
 [
   action-node command,
 ] | gv:graph Function
};

/** Send */
command send-c :: void -&gt; gv:Digraph {
 [
   state-node input,
   action-node command,
   port-node port,
   req-edge input port,
   req-edge command port
 ] | gv:graph Send
};

/* 基本図形 */

command case-node [string name] :: void -&gt; gv:Node {
  gv:node 
    --fontsize=14.0
    --shape=diamond 
    --style=filled
    --color=black
    --fillcolor=darkseagreen2
  %1
};

command state-node [string name] :: void -&gt; gv:Node {
  gv:node
    --fontsize=14.0
    --shape=note
    --style=filled
    --color=black
    --fillcolor=gold
  %1
};

command port-node [string name] :: void -&gt; gv:Node {
  gv:node 
     --fontsize=14.0
     --shape=ellipse
     --style=&quot;filled,dotted&quot;
     --color=black
     --fillcolor=darkseagreen2
  %1
};

command action-node [string name] :: void -&gt; gv:Node {
  gv:node 
    --fontsize=14.0
    --shape=ellipse
    --style=filled
    --color=black
    --fillcolor=darkseagreen2
  %1
};

command entity-node [string name] :: void -&gt; gv:Node {
  gv:node 
    --fontsize=14.0
    --shape=Mcircle
    --style=filled
    --color=black
    --fillcolor=darkorange3
  %1
};

command req-edge [string st, string ac] :: void -&gt; gv:Edge {
  gv:edge
    --fontsize=14.0
    --color=darkorchid3
  %1 %2
};

command res-edge [string ac, string st] :: void -&gt; gv:Edge {
  gv:edge
     --fontsize=14.0
     --color=crimson
  %1 %2
};

/* 以下、エッジの指定順序は、常に アクション エンティティ の順 */

command reads-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --dir=back
    --label=reads
  %1 %2
};

command updates-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --label=updates
  %1 %2
};

command uses-edge [string act, string ent] :: void -&gt; gv:Edge {
  gv:edge
    --dir=both
    --label=updates
  %1 %2
};


/* サンプル */

command sample :: void -&gt; gv:Digraph {
 [
   action-node act1,
   action-node act2,
   action-node act3,
   entity-node ent1,
   entity-node ent2,
   
   uses-edge act1 ent1,
   reads-edge act2 ent1,
   updates-edge act2 ent2,
   reads-edge act3 ent2,
 ] | gv:graph sample
};

command sample2 :: void -&gt; gv:Digraph {
 [
   action-node Data.get,
   action-node Data.put,
   action-node Data.index,

   entity-node &quot;mafs\npub&quot;,
   entity-node &quot;kvs\nindex&quot;,
   
   reads-edge Data.get &quot;mafs\npub&quot;,
   updates-edge Data.put &quot;mafs\npub&quot;,
   updates-edge Data.put &quot;kvs\nindex&quot;,
   reads-edge Data.index &quot;kvs\nindex&quot;,
 ] | gv:graph sample2
};

// End of Module
||&lt;

*1352517131*[メモ]アプリケーションを探すべき場所

デジタルカメラのソフトウェアである MyFinePix Studio はずっとずっと前にインストールしたらしい。CDROMを探す前にアプリケーションのメニューを先に探すべきだと思った。

それにしても、MyFinePix Studio とそのインストーラーは出来が悪い。

*1352536297*[プログラム意味論]並列処理、時間の空間、マンダラ

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20121102/1351828513&quot;&gt;並列処理&lt;/a&gt;」で述べた話に関係する。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20061207/1165485058&quot;&gt;“時間の空間”の圏&lt;/a&gt;

↑で「時間の空間」という変な日本語を導入した。それ以来「変な言葉」と後ろめたく思いながらも使い付けている。

- 「時間の空間」で検索： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%BB%FE%B4%D6%A4%CE%B6%F5%B4%D6

「時間シェープ」という言葉も導入したが、「時間の空間」のほうがシックリくる。結局、「時間シェープ／時間の空間」の両方を使い続ける気がする。

時間の空間（＝時間シェープ）は、時間パラメータを表現する幾何学的な対象だ。連続的図形よりむしろ離散的な図形を考えることが多い（デジタルな時間シェープ）。Tがとある時間シェープ、Sは状態遷移系だとして、実行の全体は Run(T, S) と書ける。この Run(T, S) を正確に記述することが大きな目標になる。

Run(T, S) がなんらかの圏のホムセット（むしろホム対象）となってくれるとうれしい。そうであるためには、時間シェープの圏&lt;i&gt;T&lt;/i&gt;が、状態遷移系の圏&lt;i&gt;S&lt;/i&gt;の部分圏になるような定式化が必要だ。圏論的に &lt;i&gt;T&lt;/i&gt;⊆&lt;i&gt;C&lt;/i&gt; 。

&lt;i&gt;T&lt;/i&gt;と&lt;i&gt;S&lt;/i&gt;が全然別な圏と考える定式化もある。例えば、コボルディズム圏Cobとベクトル空間（ヒルベルト空間が多いが）の圏Vectを使って（拡張）TQFTを定式化するのと類似の方法だ。

いずれにしても、Run(T, S) は構造を持ち、その構造はホモトピー的なものだろうと思う。アルファベットの集合にも、グラフ的／ホモトピー的な構造が必要なのだと思う。

これらのことを考えるとき注意すべきは、過剰な単純化はしないことだ。複雑な対象は複雑なのだ。このへんのところは、「マンダラ」という言葉でスローガンにしている。

- &lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20060606/1149560697&quot;&gt;現象のモデルはマンダラ&lt;/a&gt;
- 「マンダラ」で検索： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%A5%DE%A5%F3%A5%C0%A5%E9

複雑なものを扱うのはホントに疲れる。単純化したくなるし、実際に単純化が有効なこともあるが、なにかが抜け落ちてしまうケースもある。難しい。

</body>
</day>
<day date="2012-11-12" title="">
<body>
*1352681262*[圏一般論]錐（cone）

F:&lt;i&gt;D&lt;/i&gt;→&lt;i&gt;C&lt;/i&gt; が関手のとき、Cone(F:&lt;i&gt;D&lt;/i&gt;→&lt;i&gt;C&lt;/i&gt;) = Cone(F) はFの錐の圏とする。一方、Cone(F)[A] は |Cone(F)| の部分集合で、A∈|&lt;i&gt;C&lt;/i&gt;| を頂点とするF-錐の全体とする。G(A) := Cone(F)[A] として定義される対応は、反変関手にできる。GはFから作られた錐関手と言ってもいいかも。この錐関手の構成は重要。

&lt;b&gt;[追記]&lt;/b&gt;http://d.hatena.ne.jp/m-hiyama/20121113/1352775059 に書いた。&lt;b&gt;[/追記]&lt;/b&gt;
</body>
</day>
<day date="2012-11-13" title="">
<body>
*1352763168*[プログラム意味論]時間と空間を一緒にしたパターンの功罪

人は時間と空間を独立に考えるのが苦手だ。だから、時間と空間の使い方を一緒にパッケージ化したパターンを使いたがる。そのようなパターンの典型はcall/returnだ。call/returnは偉大な発明で、制御構造を考えることを劇的に簡単にした。

だが、どんな素晴らしいアイディアにも弊害やダークサイドがある。call/returnがあまりにも普及して、これが制御の基本構造のように思われてしまった。実際は、call/returnは相当に高級で複雑な構造だ。もっともっとプリミティブな構造に分解できる。そして、プリミティブ／アトミックな構造でないと記述できない現象や原理がある。

いったんはcall/returnを忘れて、より基本的な時間的構造、空間的構造によってcall/returnを再構築してみる必要がある。今の感触では、call/returnを採用すると、計算現象の整合的な記述はできないと思う。むしろ、call/returnは正確な記述の障害・弊害となる。ある水準の計算に、call/returnを持ち込んではいけないのだ。


</body>
</day>
<day date="2012-11-14" title="">
<body>
*1352859839*[プログラム意味論][気付いた]時間の空間、時点は不要、空間ワープ、無音ステップ、実行の同値性

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20121110/1352536297&quot;&gt;並列処理、時間の空間、マンダラ&lt;/a&gt;」あたりの続き。なにやらゴチャゴチャと考えている。

最近気付いたことは、時間の空間の基本要素は1セル（矢印）である「ステップ」であって、0セルである「時点」は不要だということ。0セルはあるにはあるのだが、副次的な働きしか持たない。通常は考える必要がない。考えてしまうことによって、色々と不都合があったのだと思う。

Tが時間の空間のとき、T&lt;sub&gt;0&lt;/sub&gt;は0セル＝時点の集合だが、これはまーどうでもいい。T&lt;sub&gt;1&lt;/sub&gt;を考える。T ＝ T&lt;sub&gt;1&lt;/sub&gt; と略記（乱用）することにする。Tは、順序（部分順序）集合だ。しかし、≦ よりは ＜ が意味を持つので、＜ を使うことが多い。

ｓ， t∈T に対して、ｓ ＜ t でも t ＜ s でもないとき、t ～ s と書く。t ～ s は、tとsが空間的に配置されていることを示す。このような順序構造は、グラフGの辺の集合 G&lt;sub&gt;1&lt;/sub&gt; = Edge(G) に対しても入れることができる。s, t∈G&lt;sub&gt;1&lt;/sub&gt;に対して、s ＜ t は、sとtをこの順で含む道の存在で定義される。

TとXが順序集合のとき、普通は単調写像fを準同型 f:T→X とするが、これはダメだ。全然ダメなのである。そうではなくて、

- s ＜ t ならば、f(t) ＜ f(s) ではない。

これが、fが準同型である条件。別な言い方をすると、順序の逆転現象（s ＜ t かつ f(t) ＜ f(s)）が起きないなら準同型。

時間の空間の1セルは&lt;strong&gt;ステップ&lt;/strong&gt;と呼ぼうと思う。ステップのあいだに順序があるのであって、時点に順序を考える必要はない。ステップの順序と矛盾しない順序を時点（0セル）の集合に入れることはできるが、たいして使わないだろう。

一番基本的な時間の空間は、{[0, 1], [1, 2], ..., [n-1, n]} というものだ。これを単に n と書いてもいいくらいだ（混乱があるけど）。Steps(n) := {[0, 1], [1, 2], ..., [n-1, n]} として、Steps(0)は空集合だとする。Sが状態遷移グラフとして、r:Steps(n)→S が一番基本的な実行となる。このとき、r([0, 1]) と r([1, 2]) が図形としては不連続となる。時点1において空間方向への瞬間移動（ワープ）が発生する。

また、無音記号、無音遷移に対応する無音ステップが必要かもしれない。時間は経過するが何も起きないことを表す。空間ワープや無音ステップは、実行の本質ではない。模倣関係においても、弱模倣のとき無音遷移を無視したり足したりする操作がある。実行の同値性（ある種のホモトピーだと思う）を考えるときは、空間ワープや無音ステップを無視する必要があるのだろう。

空間ワープ、無音ステップを考える必要があるのは、タイムシェアリング、コンテキストスイッチ、命令のシャフリング（マルチプレクサ、デマルチプレクサ）などを考えれば明らかだろう。

部分順序を持つステップの集まりである時間の空間に対して、直和と貼り合わせは自然に構成できる。解釈が難しいのは直積。単にグラフの直積なのか？ それとも「2次元の時間」が出てくるのか？ 単なる符丁としての2次元か？ 本質的な多次元構造なのか？ これが分からない。難しい。

&lt;b&gt;[追記]&lt;/b&gt; 
- ワープは、時間が経過しないのに状態点の移動が生じる。
- 無音遷移は、時間は経過するが状態点はそのまま（自己ループ、id）。

コンテキストスイッチとタイムフィラーの定式化だな。ワープと無音遷移は、有向グラフの辺ラベルとして予約記号にしておけばいいのか？
&lt;b&gt;[/追記]&lt;/b&gt;


</body>
</day>
<day date="2012-12-10" title="">
<body>
*1355095746*[メモ][掃除と整理]ゴミの分別

ゴミの分別って悩むよなー、

+ 薬 -- 残ってしまった錠剤とか飲み薬とか、そのまま捨てていいのか
+ 電球／蛍光灯
+ 電池
+ 傘 -- ビニール傘たまる。
+ OA機器の一部 -- キーボードだけ、マウスだけとか
+ CD-ROM -- イッパイある。

http://www.city.meguro.tokyo.jp/kurashi/shizen/gomi/katei_gomi/gomihinmokuichiran/index.html をみると：

- 薬（容器を除く）可燃ごみ
- 薬の容器（シート）資源
- 薬の容器（チューブ）可燃ごみ
- 薬の容器（びん）資源 家庭用に市販されている、錠剤のびんのみ。その他びんは不燃ごみ。

やっぱり、薬は面倒くさい。

- 蛍光管 不燃ごみ 新しいものが入っていたケースに入れて出してください。
- 電球	不燃ごみ 新しいものが入っていたケースに入れて出してください。

ケースは捨ててしまったよ。

&lt;em&gt;電池はさらに面倒&lt;/em&gt;だ。

- 電池には、たくさんの種類があります。電池の種類を確認してお出しください。
- マンガン乾電池、アルカリ乾電池は、地区サービス事務所や住区センターなどに設置した乾電池回収容器に入れてください。
- ボタン電池 お近くの電器店、時計店、カメラ店などにあるボタン電池回収缶に入れてください。
- ニカド電池、ニッケル水素電池、リチウムイオン電池は、リサイクル協力店に設置してあるリサイクルBOXに入れてください。

CDは可燃だったの、ヘー。

- ＣＤ（ＬＤ・ＤＶＤ）可燃ごみ カセットテープ等も同様です。

スプレー缶は：

- スプレー缶 不燃ごみ 必ず中身を使い切ってから、&lt;em&gt;別の袋に入れて「危険」と表示し、不燃ごみへ出してください。&lt;/em&gt;

布団は粗大ゴミか、まーデカイからな。カーテンは可燃だが、面倒だ。

- ふとん 粗大ごみ
- カーテン 可燃ごみ 可燃ごみに出す場合は、細かく切って出してください。 金具は取り外して不燃ごみへ出してください。


</body>
</day>
<day date="2012-12-18" title="">
<body>
*1355798983*[メモ][リンク]興味深い

- [google:SOME PLANAR ALGEBRAS RELATED TO GRAPHS]
- [google:QUANTUM COBORDISMS]
- [google:整数の分割]

*1355799044*[メモ]RequireJSのダミー

まだ不十分、つうか間違っているところもあるけど、とりあえずメモしておく。

http://d.hatena.ne.jp/m-hiyama/20120815/1344988132 で試しに使っている。

&gt;|javascript|
/* dummy-define.js -*- coding: utf-8 */

if (this &amp;&amp; !this.define) {
  define = function (name, deps, callback) {
    if (typeof name !== 'string') {
      // 引数は (deps, callback)
      deps = name;
      callback = deps;
    }
    if (!deps.splice) {
      // 引数は (callback)
      callback = deps;
    }
    if (!define._namespace) {
      // 登録先の名前空間がないときは、
      // 大域名前空間に名前を登録する
      var obj = callback();
      for (var p in obj) {
        this[p] = obj[p];
      }
    } else {
      // define._namespaceで指定された名前空間に名前を登録する
      var names = define._namespace.split('.');
      var currNs = this;
      var i = 0;
      for (; i &lt; (names.length - 1); i++) {
        var nm = names[i];
        if (!currNs[nm]) {
          currNs[nm] = {};
        }
        currNs = currNs[nm];
      }
      currNs[names[i]] = callback();
    }
  };
  // この関数がダミーである目印
  define._dummy = true;
}
||&lt;

*1355820594*[メモ]jQuery のバージョン確認

http://d.hatena.ne.jp/m-hiyama-memo/20121020/1350714050 で：

&gt;|javascript|
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;google.load(&quot;jquery&quot;, &quot;1.7&quot;);&lt;/script&gt;    
||&lt;

これでロードはされるが、詳細なバージョンはわからない。$().jquery で分かる。

</body>
</day>
<day date="2012-12-25" title="">
<body>
*1356397051*[リンク][DFD][セミナー]フロイド／ウォーシャル法と豊穣圏論

スタンフォードのヴァーン・プラット（Vaughan Pratt）が1989年に書いた論文に

- ENRICHED CATEGORIES AND THE FLOYD-WARSHALL CONNECTION

というのがある。実質4ページ（1行はみ出して5ページ）だが、含蓄に富み面白い。「[http://d.hatena.ne.jp/m-hiyama-memo/20070907/1189132181:title]」で参照している。

インターネットに残っているか？と思ったら、あった。よかった。

- http://boole.stanford.edu/pub/am4.pdf

冒頭に、次のアルゴリズムが出てくる。

&lt;pre class=&quot;code&quot;&gt;
for v do 
  for u, w do 
    δ&lt;sub&gt;uw&lt;/sub&gt; += δ&lt;sub&gt;uv&lt;/sub&gt;・δ&lt;sub&gt;vw&lt;/sub&gt;
&lt;/pre&gt;

アスキーだけで書けば：

&lt;pre class=&quot;code&quot;&gt;
for v in V {
  for u, w in V*V {
    d[u, w] += d[u, v]*d[v, w]
  }
}
&lt;/pre&gt;

d（もとのδ）は正方行列で、インデックス集合がV。単純有向グラフで言えば、頂点集合がVで、d[u, v]がuからvへの辺に付けられたラベル。ラベルのあいだに、+ と * という半環構造があれば、+= , * は意味を持つ。

上記の式は、頂点vを固定して、vの近傍であるスターごとに積和を取って、それをvに関して総和している。次のように書き換えると意味が変わる。

&lt;pre class=&quot;code&quot;&gt;
for u, w in V*V {
  for v in V {
    d[u, w] += d[u, v]*d[v, w]
  }
}
&lt;/pre&gt;

u, wを固定して、u, wを結ぶ短いパスに関して、すべてのパスに渡って総和し、それをすべての端点に関して足し上げる。

for文（総和、和分）の順序交換がある種の双対性になっている。

*1356407085*[メモ]新名称

Chimaira.org UgB (Underground Base)


</body>
</day>
<day date="2012-12-31" title="">
<body>
*1356928676*[Caty][メモ][Caty更新]Catyの変更や拡張

http://d.hatena.ne.jp/m-hiyama-memo/20121231/1356927784 から後の2012年後半の変更拡張：

+ file:writeに--mkdirオプションを追加 
+ pv, item, nth, xjson:get に --safe, --default オプション
+ 特殊コマンドもオプションの構文チェック
+ アプリケーション修飾を '::' に
+ sreifモジュールを実装して追加
+ リンク宣言（links の内部）にもアノテーションが書ける
+ case分岐でのエラーをTypeErrorからCaseUnmatchedに変更 
+ 状態記述の仕様変更 #844
+ 変数参照に、? と ?=を導入
+ json:merge をunbiased版に
+ コマンドパラメータに限って %? を導入
+ 型パラメータをコマンドのボディ内でも可視とする #502
+ call/forward のターゲットをモジュール修飾不要に 
+ call/forwardなしでも再帰コマンドが書けるようになった 
+ templateモジュールを導入
+ forwardでスクリプトファイルも実行可能に
+ Wikiプラグイン記法を導入 #869 
+ CatyScriptの型引数に型表現を書けるようになった  pass&lt;[string, {*:string}?]&gt; とか
+ validateこまんどを型パラメータ方式に変更
+ リクエストディスパッチャが排他でない場合にエラーとするよう修正 
+ begin/repeat の導入
+ cyclic dependency チェック
+ CDパスの曖昧さ解決 #882
+ 例外機構を実装
+ モジュールをまたぐ再帰の問題をmodule宣言のrelated節で解決
+ 単独のtryブロック #905
+ neverコマンド
+ Never例外
+ throwコマンド
+ signalコマンド
+ throws句にnotをサポート not throws Exc
+ mos:fullpathを実装 
+ unclose構文を実装  #937
+ 型 UncloseInput を定義
+ FIT内のマクロの参照を%%に変更 
+ uncloseに--clearオプションを追加 #933 
+ 例外処理に、--wallオプション #938 
+ runawayシグナルのサポート #945
+ env利用の有料化
+ instances構文を追加  #965
+ アクション起動時に環境変数ACTIONの追加	
+ wsgiモジュールを追加
+ GETの入力はnullに
+ OS_PLATFORM環境変数を追加 
+ gen:sampleの引数を型名ではなく型表現に変更 #984
+ gen:sampleに--modオプションを追加、モジュール指定ができる
+ mos:fullpath の仕様を他のコマンドでも使用するように（一部は）した
+ @[interactive] アノテーション
+ xjson:univ-prettyコマンドを追加
+ json:prettyの扱える範囲を標準的なJSONの範囲に制限 
+ （ほとんど）すべてのメタオブジェクトに位置情報（location）を埋め込む
+ validateに--modオプションを追加 
+ testモジュールを廃止
+ マルチプロファイルは廃止予定
+ on demandモジュールを実現
+ force-load特殊コマンドを実装
+ override-publicアノテーション  #1096
+ inspect:where-isを追加
+ override(&quot;&lt;Module Name&gt;&quot;)アノテーションを追加。任意のモジュールを上書き可能。#1090 
+ branch文を実装、まだ不十分
+ fill&lt;T&gt;コマンドを追加
+ no-auto-fillアノテーションを追加、このアノテーションの指定されたコマンドはデフォルト値の自動補完がされない。
+ gv:drawに--time, --timefileオプションを追加 
+ browserモジュールを追加
+ array-to-object に --multi オプション #1106
+ kyesコマンドを追加
+ InvalidInput --&gt; BadInput
+ レイフィケーションStateSummaryにforWhom項目
+ 任意のファイルからの force-load #1114 
+ flattenコマンドを追加  #1139 
+ file:mkdir にも --mkdir オプション
+ gen:&amp;#115;ampleをypicalアノテーションに対応
+ narrowコマンドを追加。 
+ reject-non-jsonコマンドを追加
+ open/close演算子をサポート
+ extract演算子をサポート
+ execコマンドを一部機能のみ実装 
+ UncloseConflict-&gt;SetEnvConflictにリネーム 
+ envに--toplevelオプションを追加 
+ call, forwardに--appオプションを追加 
+ takeに--objオプションを追加
+ CatyFITにおける例外種別をサポート #963
+ sreif:&amp;#108;ist-annotationsとshow-annotationを実装 
+ gen:&amp;#115;ampleをwith/withoutアノテーションに対応 
+ annotations名前空間の追加に伴い、レイフィケーションデータのアノテーション情報を&quot;anno&quot;にリネーム
+ インボーカーの動詞とメソッドの識別方法を変えた #1174
+ open演算子に型パラメータを追加 
+ CatyEnviron型を定義 
+ PackageNotFound例外型を追加。 
+ アノテーション構文サポート #1187
+ フラグメントの構文を変更({#ID ... } or (#ID ...)) 
+ 任意のコマンド／アクションに reads, updates, uses が書ける #1194
+ extract型演算も Ignore Tag Once
+ サーバーモードでも-uオプションを有効化
+ Catyアーカイバー
+ Catyインストーラー
+ Catyアンインストーラー
+ Catyチェッカー
+ cambの構文サポート #1224
+ init-appとremove-appを実装 
+ hconからのinit-app, remove-appが可能に 
+ nit-appをアプリケーションインスタンスの生成のみに限定、これまので同コマンドはsetup-appに移行
+ caty-archiverに--ignore-missingオプションを追加
+ caty-archiverのフィルターファイルにオプショナルなファイルの指定を追加(行頭に?) 
+ viva:&amp;#100;rawに--node=facilityを追加
+ マニフェストのdeprecatedサポート #1270
+ 特殊コマンドの名前 #1273
+ mailモジュールを追加
+ facilityとentityの構文を変えた #1357
+ 型エラー（妥当性の違反）を分類した例外を追加
+ python/app-manifest.xjsonに基づいて標準モジュールを読み込むように変更
+ load-mods（l）の引数仕様を拡張  #1389
+ 空式の導入

2012-12-31時点での課題と予定：

+ 特殊コマンドのヘルプの自動化
+ CatyScript構文のオンラインヘルプ
+ 変数参照構文の拡張
+ 別名とポート束縛
+ クラス演算とクラス表現
+ 順序付きオブジェクト（ordered object）データ
+ CDパス解釈の明確化
+ 三値論理とsetoid
+ Catyのクロージャの明確化
+ case構文とユニオン型
+ スキーマ属性の整理と拡張
+ フィルターのプラグイン化
+ フォーマット（サブセットタイプ）のプラグイン化

以下に、http://d.hatena.ne.jp/m-hiyama-memo/20121231/1356927784 までを再掲。

http://d.hatena.ne.jp/m-hiyama-memo/20120229/1330491076 から後の2012年前半の変更拡張：

+ debug:&amp;#102;userコマンドを追加(Linux用) 
+ cpl (Classical Propositional Logic) モジュールを追加、暫定的
+ gv:draw に --format=plaindot を追加
+ Caty起動時オプション --app に追加
+ callコマンドで.catyファイルの呼び出しを可能に
+ 文字列化コマンド to-string を追加
+ deprecatedログを追加 
+ os:platform コマンド追加 
+ 古いexecを廃止 
+ 型パラメータのデフォルト指定構文を導入、&lt;T default any&gt; など
+ hconをコンソールから起動可能に
+ 型ケース構文を導入 case 
+ 手続き的cond構文を導入
+ オブジェクトに対するeachの仕様を変更 #397 、each --obj の導入  #398
+ takeに--indfオプションで三値論理対応
+ takeに--objオプションでオブジェクト出力対応 #430
+ file:list の機能拡張 glob対応、末尾スラッシュの解釈、--recオプション
+ 定数定義constを導入
+ Caty起動オプションに --goodbye オプションを追加
+ catyをアプリケーション名として予約 
+ inspectモジュールを追加 #460 
+ Catyにクラスシステムを導入
+ helpアプリケーション、とりあえず動くレベル
+ テンプレートの区切り記号のクォーティングとして、&lt;&lt;, &gt;&gt;、{{, }} などを導入
+ helpアプリケーションにhelpモジュール追加 
+ CDパス（ColonDotパス）仕様を導入
+ Caty起動オプション --force-app を追加
+ state宣言の構文拡張、asとbaseobjectを追加、#528
+ docコメントを構造化、最初の一行を特別扱い  #533
+ 各種テンプレート変数より_接頭辞を削除（例： _CONTEXT --&gt; CONTEXT）
+ パッケージメタデータファイル pkg-manifest.xjson を導入
+ Catyの標準モジュールも.casmから読むように修正 
+ Catyコマンドラインで、同一名称の複数のオプションを許す
+ public.casmを廃止（モジュールの@[register-public]で代替）
+ call で任意のファイルを呼べるようにした
+ Web処理に三層のレイヤーアーキテクチャを導入
+ バイナリリテラル b&quot;...&quot; を導入
+ binモジュールを追加 
+ webioモジュールを追加
+ 環境変数の追加：QUERY_STRING, SERVER_SOFTWARE, SERVER_MODULE
+ pv, item, nth に --safeオプションを追加。
+ ext-content-typeコマンドを追加
+ アプリケーションごとにlibを持たせた、#639 
+ class構文を導入
+ classのrefers節、構文だけ対応
+ runtime.casmを追加、暫定的不完全
+ setenv, unsetenv特殊コマンドを追加
+ FITのabandon -&gt; suspend と変更 
+ XJSONパスで末尾の'?'をサポート
+ neqコマンドを追加

http://d.hatena.ne.jp/m-hiyama-memo/20120229/1330491076 再掲：

+ text:verify-chars追加
+ start.logにロギング
+ _OPTS, _ARGV変数
+ dribbleファイル機能
+ smarty-mxの実装 https://bitbucket.org/project_caty/dev/issue/17/smarty-mx
+ list:tightenを実装
+ object-to-array, array-to-objectを実装
+ テンプレートで仮想プロパティをサポート
+ list:range コマンド追加
+ smarty=smarty-mx とした
+ ハイフン1個オプションを廃止
+ path:matchesコマンド、テスト不十分
+ パス式アクセスに$記法を導入（実装方式はけっこうヒドイ）
+ ハイパーリンク記述を開始 https://bitbucket.org/project_caty/dev/issue/63/
+ httpコンソール
+ viva:draw
+ gen-data -&gt; gen:sampleに変更
+ リソースのヘルプを追加
+ viva:draw-action
+ 環境変数LANGUAGEを追加。主にi18nメッセージの言語選択に使われる。
+ viva:draw-actionに --loneオプション
+ caraとcasmの統合
+ call, forwardを追加。コマンド宣言にsignals節追加
+ start{...}を追加、参考：https://bitbucket.org/project_caty/dev/issue/114/
+ sleepを追加。
+ キーボード割り込みでREPの中断、Windowsではまともに動かない。
+ gen:urlを実装
+ &amp;lt;?caty-* の出現位置の制限を先頭200文字→先頭10行に変更
+ viva:draw/draw-action に --if-modified オプション
+ vivaの描画フォーマットにsvgeを追加
+ Literate形式のモジュール
+ Wikiにignoreプラグイン
+ caraにもlit形式
+ h, hc, ht, hrをコンソールに出力するよう修正(helpはこれまで通り)
+ schemata@this, actions@this を readonly で公開する。
+ patternスキーマ属性
+ userrole宣言、ユースケースのアクター概念を入れた（最小限）
+ 不明なuserroleに疑問符
+ --node=userrole の描画
+ Catyの名前文字の日本語対応
+ file:listでschemataやactionsを見られるように
+ globalをアプリケーションとして扱えるように
+ -マークで、別にどっちでもいいよトリガー
+ globalのWebアクセス禁止(Webからは存在しない扱い)
+ lexicalキーワードをsyntax宣言で使用可能に
+ portのナンチャッテ実装
+ ポートが束縛される機構／タイミングによりポートノードの色を変える
+ 不明なノードのSVG出力時、classにunknownを追加
+ 新CSSセレクターライブラリ
+ filter:json フィルターコマンド
+ filter:javascript フィルターコマンド
+ with, withoutアノテーションを実装
+ gv:drawを実装
+ コマンドがエラーになったときに、スクリプトでの位置を同時に出力
+ setモジュールを暫定的に追加

http://d.hatena.ne.jp/m-hiyama-memo/20120227/1330299117 再掲

+ osモジュールにコマンド追加
+ json:fix-on-selection
+ json:fix-on-selection に、インライン・インクルード機能としての $embed
+ pidファイル機能
+ server status を server だけで参照可能。
+ OSシグナル SIGTERM, SIGQUITに対応。Windowsでは不十分。
+ キーボード割り込みをシグナルハンドラで対応するよう変更。Windowsでは不十分。
+ isarray, isobjectフィルターを追加
+ smarty3のfunctionを実装。
+ その他 SmartyMinEx（smarty-mx）
+ モジュールにアノテーションを付けられる。
+ chcker.casm と checker:check-files、 まだ不十分。

http://d.hatena.ne.jp/m-hiyama-memo/20110623/1308807276 再掲

+ when-otherwiseのワイルドカード
+ PATH_INFO環境変数
+ 環境変数が直接参照可能に。
+ app.logとloggingモジュールを追加。
+ osモジュール os:exec-scriptコマンドを追加。
+ rc-once/*.caty による一回実行起動時スクリプト
+ 複数候補から選択した値の解決 json:fix-on-selectionコマンド、$selection, $embed。
+ モジュール循環依存性の検出
+ 型コンパイル方式を少しずつ改善
+ make-exception, throw-if-can。throw-if-canは今バグっている。
+ pathモジュール
+ when, eachにオプションが（構文上は）可能となる。
+ gen-dataの改善、@[typical]アノテーション
+ デーモンモードでのシグナル（SIGTERM, SIGHUPなど）に対応
+ SIGHUPではリスタートする。
+ PIDファイルをちゃんと消す。
+ システム情報の公開性を少し高めた。
+ 疑似タグのプロパティ名に文字列が使える。
+ 疑似タグでundefinedが使える。

予定：

- 型の包含性判定
- データセットのサポート

http://d.hatena.ne.jp/m-hiyama-memo/20110506/1304662541 再掲。

+ 変数生成 '&gt;'
+ 変数参照 '%'
+ パイプラインの一時的終了 ';'
+ eachによる変数スコープ（つうかエクステント）
+ casmでスクリプトコマンド定義
+ kindのナンチャッテ第一段階。
+ バッグ型
+ actions/*.cara
+ 新しいスキーマ属性 maxProperties, minProperties, propNameFormat, tight。（remarkは以前から。）
+ XJSONパス、XJSON get/put、パートはまだだが。
+ ignore-tag-onceルール、pv, item, nth とXJSONパス
+ 疑似タグ構文 '@?' '(' (name|string) ':' スカラーリテラル ')'
+ 任意のタグ '@*'
+ 任意の明示的タグ '@*!'
+ 型名タグ '@&amp;' 
+ undefined型と#'undefined
+ @[register-public]
+ CatyBNFのナンチャッテ実装： ::=, :=, = が使える。
+ /*{{{, }}}*/ コメント
+ debug特殊コマンド
+ --no-ambient, --no-appオプション
+ select-action, select-script, trace-dispatchコマンド
+ スキーマ記述用のPythonファイルの分離
+ *.caraにfiletypeを書ける
+ 例外型の定義（exception宣言）
+ deferred型
+ お尻スラッシュ問題に対して、マニフェストに &quot;missingSlash&quot; 追加。
+ _global.xjsonに &quot;addrsAllowed&quot;, &quot;addrsDenied&quot;
+ スタックトレースのWebへの出力
+ throws only
+ 総称コマンドの実行時具体化
+ 国際化フレームワーク
+ フィルターのコマンド化
+ deprecatedアノテーションの処理
+ defaultアノテーションの処理
+ moduleにdocコメント
+ 配列型の項目名
+ HTTPメソッドトンネリング
+ CatyFITのjudge欄
+ ハッシュ記法
+ timeメタコマンド
+ CatyFITにignore-spaceオプション

予定：

+ __integerスキーマ属性
+ whenにotherwiseワイルドカード
+ 複数プロファイル
+ オブジェクトのeach
+ ユニオン型のワイルドカード
+ importと名前の本籍追跡
+ tag-onlyデータ
+ コマンドオーバーロード（優先度低し）
+ テンプレートの elseif

中途半端または未着手：

+ profileスキーマ属性（これはそもそも間違いだった）
+ パラメータ付きのファシリティ
+ inspect-dispatchコマンド
+ アクションサーチのfinishing
+ ファイルタイプの登録抹消
+ auto-print, gen-data 
+ 動的総称型、動的総称コマンド
+ アクションの内部プロファイル
+ インスタンスドキュメンテーション
+ 初期化の最後にコマンドラインを実行するオプション
+  疑似タグによる分岐
+ 例外マッパースクリプト
+ rootApplication 設定 
+ validate --closed 
+ untagged演算子 ^ 

*1356927784*[Caty][メモ][Caty更新]Catyの変更や拡張

http://d.hatena.ne.jp/m-hiyama-memo/20120229/1330491076 から後の2012年前半の変更拡張：

+ debug:&amp;#102;userコマンドを追加(Linux用) 
+ cpl (Classical Propositional Logic) モジュールを追加、暫定的
+ gv:draw に --format=plaindot を追加
+ Caty起動時オプション --app に追加
+ callコマンドで.catyファイルの呼び出しを可能に
+ 文字列化コマンド to-string を追加
+ deprecatedログを追加 
+ os:platform コマンド追加 
+ 古いexecを廃止 
+ 型パラメータのデフォルト指定構文を導入、&lt;T default any&gt; など
+ hconをコンソールから起動可能に
+ 型ケース構文を導入 case 
+ 手続き的cond構文を導入
+ オブジェクトに対するeachの仕様を変更 #397 、each --obj の導入  #398
+ takeに--indfオプションで三値論理対応
+ takeに--objオプションでオブジェクト出力対応 #430
+ file:list の機能拡張 glob対応、末尾スラッシュの解釈、--recオプション
+ 定数定義constを導入
+ Caty起動オプションに --goodbye オプションを追加
+ catyをアプリケーション名として予約 
+ inspectモジュールを追加 #460 
+ Catyにクラスシステムを導入
+ helpアプリケーション、とりあえず動くレベル
+ テンプレートの区切り記号のクォーティングとして、&lt;&lt;, &gt;&gt;、{{, }} などを導入
+ helpアプリケーションにhelpモジュール追加 
+ CDパス（ColonDotパス）仕様を導入
+ Caty起動オプション --force-app を追加
+ state宣言の構文拡張、asとbaseobjectを追加、#528
+ docコメントを構造化、最初の一行を特別扱い  #533
+ 各種テンプレート変数より_接頭辞を削除（例： _CONTEXT --&gt; CONTEXT）
+ パッケージメタデータファイル pkg-manifest.xjson を導入
+ Catyの標準モジュールも.casmから読むように修正 
+ Catyコマンドラインで、同一名称の複数のオプションを許す
+ public.casmを廃止（モジュールの@[register-public]で代替）
+ call で任意のファイルを呼べるようにした
+ Web処理に三層のレイヤーアーキテクチャを導入
+ バイナリリテラル b&quot;...&quot; を導入
+ binモジュールを追加 
+ webioモジュールを追加
+ 環境変数の追加：QUERY_STRING, SERVER_SOFTWARE, SERVER_MODULE
+ pv, item, nth に --safeオプションを追加。
+ ext-content-typeコマンドを追加
+ アプリケーションごとにlibを持たせた、#639 
+ class構文を導入
+ classのrefers節、構文だけ対応
+ runtime.casmを追加、暫定的不完全
+ setenv, unsetenv特殊コマンドを追加
+ FITのabandon -&gt; suspend と変更 
+ XJSONパスで末尾の'?'をサポート
+ neqコマンドを追加

2012年6月までの更新は以上。2012年後半の次回のエントリーに。

以下に、http://d.hatena.ne.jp/m-hiyama-memo/20120229/1330491076 までを再掲

+ text:verify-chars追加
+ start.logにロギング
+ _OPTS, _ARGV変数
+ dribbleファイル機能
+ smarty-mxの実装 https://bitbucket.org/project_caty/dev/issue/17/smarty-mx
+ list:tightenを実装
+ object-to-array, array-to-objectを実装
+ テンプレートで仮想プロパティをサポート
+ list:range コマンド追加
+ smarty=smarty-mx とした
+ ハイフン1個オプションを廃止
+ path:matchesコマンド、テスト不十分
+ パス式アクセスに$記法を導入（実装方式はけっこうヒドイ）
+ ハイパーリンク記述を開始 https://bitbucket.org/project_caty/dev/issue/63/
+ httpコンソール
+ viva:draw
+ gen-data -&gt; gen:sampleに変更
+ リソースのヘルプを追加
+ viva:draw-action
+ 環境変数LANGUAGEを追加。主にi18nメッセージの言語選択に使われる。
+ viva:draw-actionに --loneオプション
+ caraとcasmの統合
+ call, forwardを追加。コマンド宣言にsignals節追加
+ start{...}を追加、参考：https://bitbucket.org/project_caty/dev/issue/114/
+ sleepを追加。
+ キーボード割り込みでREPの中断、Windowsではまともに動かない。
+ gen:urlを実装
+ &amp;lt;?caty-* の出現位置の制限を先頭200文字→先頭10行に変更
+ viva:draw/draw-action に --if-modified オプション
+ vivaの描画フォーマットにsvgeを追加
+ Literate形式のモジュール
+ Wikiにignoreプラグイン
+ caraにもlit形式
+ h, hc, ht, hrをコンソールに出力するよう修正(helpはこれまで通り)
+ schemata@this, actions@this を readonly で公開する。
+ patternスキーマ属性
+ userrole宣言、ユースケースのアクター概念を入れた（最小限）
+ 不明なuserroleに疑問符
+ --node=userrole の描画
+ Catyの名前文字の日本語対応
+ file:listでschemataやactionsを見られるように
+ globalをアプリケーションとして扱えるように
+ -マークで、別にどっちでもいいよトリガー
+ globalのWebアクセス禁止(Webからは存在しない扱い)
+ lexicalキーワードをsyntax宣言で使用可能に
+ portのナンチャッテ実装
+ ポートが束縛される機構／タイミングによりポートノードの色を変える
+ 不明なノードのSVG出力時、classにunknownを追加
+ 新CSSセレクターライブラリ
+ filter:json フィルターコマンド
+ filter:javascript フィルターコマンド
+ with, withoutアノテーションを実装
+ gv:drawを実装
+ コマンドがエラーになったときに、スクリプトでの位置を同時に出力
+ setモジュールを暫定的に追加

http://d.hatena.ne.jp/m-hiyama-memo/20120227/1330299117 再掲

+ osモジュールにコマンド追加
+ json:fix-on-selection
+ json:fix-on-selection に、インライン・インクルード機能としての $embed
+ pidファイル機能
+ server status を server だけで参照可能。
+ OSシグナル SIGTERM, SIGQUITに対応。Windowsでは不十分。
+ キーボード割り込みをシグナルハンドラで対応するよう変更。Windowsでは不十分。
+ isarray, isobjectフィルターを追加
+ smarty3のfunctionを実装。
+ その他 SmartyMinEx（smarty-mx）
+ モジュールにアノテーションを付けられる。
+ chcker.casm と checker:check-files、 まだ不十分。

http://d.hatena.ne.jp/m-hiyama-memo/20110623/1308807276 再掲

+ when-otherwiseのワイルドカード
+ PATH_INFO環境変数
+ 環境変数が直接参照可能に。
+ app.logとloggingモジュールを追加。
+ osモジュール os:exec-scriptコマンドを追加。
+ rc-once/*.caty による一回実行起動時スクリプト
+ 複数候補から選択した値の解決 json:fix-on-selectionコマンド、$selection, $embed。
+ モジュール循環依存性の検出
+ 型コンパイル方式を少しずつ改善
+ make-exception, throw-if-can。throw-if-canは今バグっている。
+ pathモジュール
+ when, eachにオプションが（構文上は）可能となる。
+ gen-dataの改善、@[typical]アノテーション
+ デーモンモードでのシグナル（SIGTERM, SIGHUPなど）に対応
+ SIGHUPではリスタートする。
+ PIDファイルをちゃんと消す。
+ システム情報の公開性を少し高めた。
+ 疑似タグのプロパティ名に文字列が使える。
+ 疑似タグでundefinedが使える。

予定：

- 型の包含性判定
- データセットのサポート

http://d.hatena.ne.jp/m-hiyama-memo/20110506/1304662541 再掲。

+ 変数生成 '&gt;'
+ 変数参照 '%'
+ パイプラインの一時的終了 ';'
+ eachによる変数スコープ（つうかエクステント）
+ casmでスクリプトコマンド定義
+ kindのナンチャッテ第一段階。
+ バッグ型
+ actions/*.cara
+ 新しいスキーマ属性 maxProperties, minProperties, propNameFormat, tight。（remarkは以前から。）
+ XJSONパス、XJSON get/put、パートはまだだが。
+ ignore-tag-onceルール、pv, item, nth とXJSONパス
+ 疑似タグ構文 '@?' '(' (name|string) ':' スカラーリテラル ')'
+ 任意のタグ '@*'
+ 任意の明示的タグ '@*!'
+ 型名タグ '@&amp;' 
+ undefined型と#'undefined
+ @[register-public]
+ CatyBNFのナンチャッテ実装： ::=, :=, = が使える。
+ /*{{{, }}}*/ コメント
+ debug特殊コマンド
+ --no-ambient, --no-appオプション
+ select-action, select-script, trace-dispatchコマンド
+ スキーマ記述用のPythonファイルの分離
+ *.caraにfiletypeを書ける
+ 例外型の定義（exception宣言）
+ deferred型
+ お尻スラッシュ問題に対して、マニフェストに &quot;missingSlash&quot; 追加。
+ _global.xjsonに &quot;addrsAllowed&quot;, &quot;addrsDenied&quot;
+ スタックトレースのWebへの出力
+ throws only
+ 総称コマンドの実行時具体化
+ 国際化フレームワーク
+ フィルターのコマンド化
+ deprecatedアノテーションの処理
+ defaultアノテーションの処理
+ moduleにdocコメント
+ 配列型の項目名
+ HTTPメソッドトンネリング
+ CatyFITのjudge欄
+ ハッシュ記法
+ timeメタコマンド
+ CatyFITにignore-spaceオプション

予定：

+ __integerスキーマ属性
+ whenにotherwiseワイルドカード
+ 複数プロファイル
+ オブジェクトのeach
+ ユニオン型のワイルドカード
+ importと名前の本籍追跡
+ tag-onlyデータ
+ コマンドオーバーロード（優先度低し）
+ テンプレートの elseif

中途半端または未着手：

+ profileスキーマ属性（これはそもそも間違いだった）
+ パラメータ付きのファシリティ
+ inspect-dispatchコマンド
+ アクションサーチのfinishing
+ ファイルタイプの登録抹消
+ auto-print, gen-data 
+ 動的総称型、動的総称コマンド
+ アクションの内部プロファイル
+ インスタンスドキュメンテーション
+ 初期化の最後にコマンドラインを実行するオプション
+  疑似タグによる分岐
+ 例外マッパースクリプト
+ rootApplication 設定 
+ validate --closed 
+ untagged演算子 ^ 


</body>
</day>
<day date="2013-01-09" title="">
<body>
*1357692786*[メモ][掃除と整理]ゴミ分別：CDとケースとアルバム

- ＣＤ（ＬＤ・ＤＶＤ）→ 可燃ごみ （カセットテープ等も同様です。）
- ＣＤケース → 可燃ごみ	  
- アルバム → 可燃ごみ

そうだったのかー。

*1357693846*[メモ][掃除と整理]ゴミ分別：電球：そんなこと言われても困る

- 電球 → 不燃ごみ 新しいものが入っていたケースに入れて出してください。

新しいものと交換しないときもある。

*1357694044*[メモ][掃除と整理]ゴミ分別：プラスチック類

資源もあるが、資源利用できないものは可燃。

</body>
</day>
<day date="2013-01-10" title="">
<body>
*1357798035*[メモ][掃除と整理]ゴミ分別：スプレー

- スプレー缶 → 不燃ごみ 必ず中身を使い切ってから、別の袋に入れて「危険」と表示し、不燃ごみへ出してください。

とあるが、薬（エアーサロンパス）のプラスチック製のスプレーはどうなるのだろう？

薬の捨て方は http://d.hatena.ne.jp/m-hiyama-memo/20121210/1355095746
</body>
</day>
<day date="2013-01-11" title="">
<body>
*1357863820*[メモ][掃除と整理]悩みのタネ

解決の前に、とりあえず悩みのタネを列挙する。

- まず書類！ 特にハードウェアなどのマニュアル／保証書とか
- 電池
- 電球、蛍光灯
- 薬（絆創膏とか風邪薬とか）
- 子供に関するブツ
- ネジとか工具とか
- 郵便物


</body>
</day>
<day date="2013-01-12" title="">
<body>
*1357965017*[Caty][メモ]過去の予定と現状

&lt;h5&gt;だいぶ昔の予定や課題&lt;/h5&gt;

+ __integerスキーマ属性 → やめた
+ whenにotherwiseワイルドカード → 済み
+ 複数プロファイル → やめた、代わりに単純オーバーロード
+ オブジェクトのeach → 済み
+ ユニオン型のワイルドカード → まだ仕様も未定、だがやるつもり
+ importと名前の本籍追跡 → aliasが欲しい、がまだ
+ tag-onlyデータ → 済み
+ コマンドオーバーロード → まだ
+ テンプレートの elseif → 済み
+ profileスキーマ属性（これはそもそも間違いだった）→ やめた
+ パラメータ付きのファシリティ → まだ
+ inspect-dispatchコマンド → 別な形で実現する
+ アクションサーチのfinishing → まだ、仕様も未定
+ ファイルタイプの登録抹消 → まだ
+ auto-print, gen-data  → 半分くらい出来たか？
+ 動的総称型、動的総称コマンド → ある程度は動くが、まだ
+ アクションの内部プロファイル → だいたい出来た
+ インスタンスドキュメンテーション → 頓挫
+ 初期化の最後にコマンドラインを実行するオプション → まだ
+ 疑似タグによる分岐 → case, condで間に合っている
+ 例外マッパースクリプト → できた
+ rootApplication 設定  → どうしようか？
+ validate --closed  → close型演算子をサポート、だが --close も必要かも
+ untagged演算子 ^ → 擬似プロパティとして実現した

&lt;h5&gt;だいぶ昔からずっとだが…&lt;/h5&gt;

- 型の包含性判定 → 出来てない
- データセットのサポート → 出来てない

&lt;h5&gt;2012-12-31時点での課題と予定&lt;/h5&gt;

+ 特殊コマンドのヘルプの自動化 → 済み
+ CatyScript構文のオンラインヘルプ
+ 変数参照構文の拡張
+ 別名とポート束縛
+ クラス演算とクラス表現
+ 順序付きオブジェクト（ordered object）データ
+ CDパス解釈の明確化
+ 三値論理とsetoid
+ Catyのクロージャの明確化
+ case構文とユニオン型
+ スキーマ属性の整理と拡張
+ フィルターのプラグイン化
+ フォーマット（サブセットタイプ）のプラグイン化

&lt;h5&gt;その他&lt;/h5&gt;

+ バッグ型の出現性に *, +, ? をサポート。
+ $PRJ/lib、どうするか？
+ 型パラメータ＋属性値パラメータを持つような型関数
+ コマンドへの型情報の渡し方（型引数、通常パラメータに文字列）
+ コマンドクロージャの定義をしっかり再考
+ スキーマにおいて、タグに対するもっと柔軟な指定、@a?,  @(a|b|c) など。
+ package.jsonとpython（engine）のバージョンチェッカー
+ Transferable型をちゃんと使って処理する。
+ 三値論理をチャント使う。
+ 引数変数への自動バインド
+ クエリーパラメータの扱い、賢い変換（sensible conversion）
+ ロケーションフリーなアクション
+ 単なるJSONファイルを使ったストレージシステム
+ branch構文が中途半端

</body>
</day>
<day date="2013-01-17" title="">
<body>
*1358388728*[Caty][TQFT][プログラム意味論]モノイド二重圏をモジュール計算に利用する

http://d.hatena.ne.jp/m-hiyama/20130117/1358383722 にモノイド二重圏の定義だけは書いた。Catyのモジュール計算に使うつもり。

モジュール、正確に言えば境界付きモジュールを水平1セルとみなす。境界データは、i&lt;sub&gt;0&lt;/sub&gt;:A→M、i&lt;sub&gt;1&lt;/sub&gt;:B→M という写像で与えられて、水平1セルとしては、(A→M←B):A→B というプロファイルとなる。

話が前後するが、そもそも（境界なし）モジュールとは何か？というと、ペトリネットである。ペトリネットは若干抽象化されていて、プレースノードとトランジションノードを持つ二部グラフで、ある制約を満たすもの。さらに頂点ラベリングが付く。トランジションノードは辺（の中点）ともみなせるので、トランジションノードの頂点ラベルは辺ラベルのように解釈することも出来る。

二重圏の0セルは離散ペトリネットとなる。境界データは、離散ペトリネットを通常の（制約を満たす）ペトリネットに埋め込む写像。横結合はグラフの貼り合わせで定義する。

縦セルは、離散ペトリネットおよびペトリネットのあいだの写像。結合は写像の合成になる。モノイド積は直和で与える。

水平1セル（なんだったら、境界構造を忘れてもいい）と2セルからなる圏が考えられる。この圏は通常のモノイド圏となるが、モノイド積は直和、空グラフで始対象もある。さらに有限余完備になってくれると、モジュールを素材にして工作が自由にできる圏になる。工作手段は、モジュールを頂点とする図式に対して余極限を取る構成法。

水平1セルの横結合は、2セルを射とする圏の余極限とは別物だが似てる。どちらも、V字形余スパンを繋いだW字形に対してまんなかのスパンの押し出し＝融合和を作る。ただし、プログラム意味論的／実務的に言えば、横結合と余極限構成は&lt;em&gt;まったく異なる&lt;/em&gt;。

横結合は、オートマトンの連接にあたる。それに対して、余極限構成は設計情報の集約作業となる。水平1セルと2セルの縦結合からなる圏が有限余完備なら、自動的に下部構造の二重圏と協調するような気がするが、ハッキリは分からない。

今はともかく、ペトリ的なオートマトンの連接（連結）、直和（モノイド積）、トレースと、それより上位（高次元）な部分のスパンと余極限構成（融合和、貼り合わせ）の実例を調べる。


</body>
</day>
<day date="2013-01-25" title="">
<body>
*1359077937*[子供]土曜の予定

午後４時

</body>
</day>
<day date="2013-01-26" title="">
<body>
*1359174907*[リンク][高次圏論]Bigroupoid 2-torsors

これは、Igor Bakovicの2007年の学位論文。次に言及がある。

- http://golem.ph.utexas.edu/category/2006/10/bakovic_on_2groupoid_2torsors.html
- http://golem.ph.utexas.edu/category/2008/11/bakovi_on_bigroupoid_bitorsors.html

PDFは次から入手可能。135ページ。

- http://edoc.ub.uni-muenchen.de/9209/
- http://www.irb.hr/korisnici/ibakovic/2torsbig.pdf

目次：

&gt;||
I Introduction 7
 1 The introduction 8
II One-dimensional theory 23
 2 Simplicial objects 24
 3 Internal categories and internal groupoids 33
 4 Nerves of categories 37
 5 Actions of categories and groupoids 40
 6 Small fibrations 49
III Two-dimensional theory 54
 7 Bicategories 55
 8 Nerves of bicategories 70
 9 Internal bicategories 72
 10 Pseudosimplicial categories 82
 11 Small 2-￣brations 86
 12 The second nonabelian cohomology 97
 13 Actions of bicategories 105
 14 Bigroupoid 2-torsors 115
 15 Simplicial interpretation of bigroupoid 2-torsors 121
IV The bibliography and biographical data 128
||&lt;

つまみ食いすると、単体的手法、神経、内部高次圏とかのアイディアが少しは分かるかも。

</body>
</day>
<day date="2013-01-30" title="">
<body>
*1359505368*[リンク][高次圏論]ルーリーの導来代数幾何

ルーリー（Lurie）が、2006年から2009年にかけて書いている一連の論文。

+ Derived Algebraic Geometry I: Stable Infinity Categories, http://arxiv.org/abs/math/0608228
+ Derived Algebraic Geometry II: Noncommutative Algebra, http://arxiv.org/abs/math/0702299
+ Derived Algebraic Geometry III: Commutative Algebra, http://arxiv.org/abs/math/0703204
+ Derived Algebraic Geometry IV: Deformation Theory, http://arxiv.org/abs/0709.3091
+ Derived Algebraic Geometry V: Structured Spaces, http://arxiv.org/abs/0905.0459

http://pantodon.shinshu-u.ac.jp/topology/literature/derived_algebraic_geometry.html によると、Integral Transforms and Drinfeld Centers in Derived Algebraic Geometry, http://arxiv.org/abs/0805.0157 が入門になるとのこと。


</body>
</day>
<day date="2013-02-01" title="">
<body>
*1359704742*[プログラム意味論][DFD][形式言語理論]拡張されたマイヒル／ネロードの定理

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20130129/1359428359&quot;&gt;スピヴァック理論&lt;/a&gt;とかの刺激で、マイヒル／ネロードの定理がけっこう分かってきた。

指標を圏、むしろ圏の表示（presentation）だと考える。具体的には有向グラフとパス同値関係のセット。有向グラフのルートノード／リーフノードと同じ定義で、圏のルート対象／リーフ対象を定義する。圏とその表示をしばしば同一視するので、指標は圏とも表示とも解釈する。表示付き圏（category with presentation, presented category）と考えれば問題ない。

指標Σに対して、Mod[Σ] := [Σ, &lt;b&gt;Set&lt;/b&gt;] と考える。パス同値関係の組を等式系Eと考えて、等式を満たす全体は、Mod[Σ, E] := [Σ, &lt;b&gt;Set&lt;/b&gt;]&lt;sub&gt;E&lt;/sub&gt; とか書く。可逆2-セルを持つ高次圏を考えればもっとスマートな定義ができる。

指標Σは多ソート隠蔽指標だとして、Σのルート対象とリーフ対象の全体をδ(Σ)と書き、Σの境界と呼ぶ。境界に属さないノードはそべて隠蔽ソートだとする。V:δ(Σ)→|&lt;b&gt;Set&lt;/b&gt;| を固定して、(Σ, V) をディリクレ指標と呼ぶ。ディリクレ指標 (Σ, V) のモデルは、Vの拡張となっているような関手 A:Σ→&lt;b&gt;Set&lt;/b&gt; である。モデルを、(Σ, V)-代数とも呼ぶ。

マイヒル／ネロードの定理は、(Σ, V)-代数の圏の構造定理となる。(Σ, V)-代数の圏のなかに、可達代数（reachable）の部分圏と可識代数（observable）の部分圏を定義できる。可達かつ可識な代数は同型を除いて一意的に存在して、それは圏のパスの集合（本質的にホムセット）で具体的に構成可能である。

ディリクレ指標 (Σ, V) に対する可達かつ可識な代数をマイヒル／ネロード代数と呼ぶことにすると、代数のモデル圏のなかにマイヒル／ネロード代数は必ず存在し、同型を除いて一意的である。


</body>
</day>
<day date="2013-02-13" title="">
<body>
*1360723987*[圏一般論][indexed/fibred圏]クリーベッジ

クリーベッジ（cleavage : 裂くこと、切開、分割、裂け目、割れ目、亀裂、溝）はセクションと似た意味だ。セクションは断面だから、&lt;em&gt;切開面&lt;/em&gt;でいいかな。

誰か（今はわからんダレカ）が、クリーベッジは語感がふさわしくない、と言っていた。choice of * がいいだろうと。超越的な選択の結果だからchoice。日本語にしたら「選択」、ウーン、これは使いたくないな。

切開面かクリーベッジでいいとしよう。up-to-isoで定まるナニカのなかからひとつを選び出したものだ。

*1360724122*[プログラム意味論][圏一般論]自己双対コンパクト閉2-圏としての関係圏

本文で話題にしているスピヴァック理論だけど、関係データモデルやERモデルをちゃんと吸収するには、アンビエント圏を関係圏にする必要があるようだ。

で、関係圏なのだが、コンパクト閉圏としては自己双対で、対象の双対は自分自身となる。しかし、射の双対は自分とは限らないので意味を持つ。f:A→B の双対は f&lt;sup&gt;*&lt;/sup&gt; じゃなくて f&lt;sup&gt;t&lt;/sup&gt; と書くことにする。関係の転置のほうが一般的だと思うので。

それと、関係圏では、ホムセットに包含順序が入る。順序構造を圏とみなして2-圏（圏で豊穣化された圏）とみなす。これにより、lax自然変換とoplax自然変換を考えることが出来る。lax/oplax変換は、データの時間的な変更を制御するのにどうしても必要。lax/oplax関手が出てくるかどうかはわからない。

転置と順序を使った基本関係は、f:A→B に対して（恒等射とidは同一視して）：

+ f;f&lt;sup&gt;t&lt;/sup&gt;⊆A
+ A⊆ f;f&lt;sup&gt;t&lt;/sup&gt;
+ f&lt;sup&gt;t&lt;/sup&gt;;f⊆B
+ B⊆f&lt;sup&gt;t&lt;/sup&gt;;f

この4つ。これらを使えば、関係の多重度、重複度、出現性、基数とか呼ばれている性質は記述できる。

</body>
</day>
<day date="2013-02-14" title="">
<body>
*1360806948*[圏一般論][用語法]再び quasiとpseudo

以前調べた → http://d.hatena.ne.jp/m-hiyama-memo/20060801/1154404268

quasiもpseudoも「擬」だが、quasiは「準」と訳すこともある。

&lt;h5&gt;quasi&lt;/h5&gt;

quasi-categoryは市民権を得ているようだ。

- http://ncatlab.org/nlab/show/quasi-category

quasi-functorって言葉もあるけど、どうもDG圏の文脈で使うみたい。例えば、

- http://arxiv.org/abs/1004.1918

&lt;h5&gt;pseudo&lt;/h5&gt;

pseudo-categoryはやっぱりあまり使われてないし、確定した定義もないようだ。個別事例としては、

- http://www.kurims.kyoto-u.ac.jp/EMIS/journals/JHRS/volumes/2006/n1a3/v1n1a3hl.pdf &quot;PSEUDO-CATEGORIES&quot;

pseudofunctorは、nLabにある。双圏のあいだの関手である弱2-関手の特殊ケースらしい。

- http://ncatlab.org/nlab/show/pseudofunctor

2-関手全般は：

- http://ncatlab.org/nlab/show/2-functor

形容詞への副詞として、Pseudo-abelianなんてのはある。

- http://en.wikipedia.org/wiki/Pseudo-abelian_category

&lt;h5&gt;Segal Enriched Categories&lt;/h5&gt;

検索中に見つけたもの。面白そう。

- http://golem.ph.utexas.edu/category/2010/09/bacard_on_segal_enriched_categ.html
- nhttp://arxiv.org/abs/1009.3673
- http://arxiv.org/find/math/1/au:+Bacard_H/0/1/0/all/0/1


</body>
</day>
<day date="2013-02-15" title="">
<body>
*1360895883*[圏一般論][メモ]フレイド／セドロフの図式的論理式記法

フレイド／セドロフが面白い記法を使っている。けっこう本質的かもしれない。

&lt;b&gt;[追記]&lt;/b&gt;そのフレイド／セドロフの本が紛失した。なんてこったい。いったいどこで？&lt;b&gt;[/追記]&lt;/b&gt;

Dは圏&lt;i&gt;C&lt;/i&gt;における図式、D'はDの拡張になっている図式とする。正確に言えば、DのシェープからD'のシェープへの埋め込みがあること。このとき、D | D' と書く。意味としては、「D は D' に拡張できる」。

論理記号∀、∃ と組み合わせて：

- D ∃| D' -- Dの拡張となるD'が存在する。∃D'.(D | D')
- ∀| D ∃| D' -- 任意のDに対して、Dの拡張となるD'が存在する。∀D.∃D'.(D | D')
- D ∀| D' ∃| D'' -- Dの拡張である任意のD'に対して、D'の拡張となるD''が存在する。∀D'(D | D').∃D''.(D' | D'') ≡ ∀D'.∃D''.[(D | D')⊃(D' | D'')]

∃! も使う。実際には図式で書いて、| は図式を区切る境界線となる。ANDやORも図式的で、ANDは仕切り線で上下に並べる。ORは別な場所に書く。ANDとORの区別がイマイチかもしれない。

いずれにしても、図式の拡張を基礎に置くのは面白く有効なアプローチだと思う。


</body>
</day>
<day date="2013-02-19" title="">
<body>
*1361242344*[圏一般論][関手データ]必要な圏論

部分写像の圏から付点集合&lt;b&gt;PtSet&lt;/b&gt;の圏を作って、&lt;b&gt;PtSet&lt;/b&gt;で考えたほうがいいだろう。モナドのクライスリ圏だし。

基本的な概念は：

+ 直積とその射影
+ 終対象
+ 等値核（イコライザー）
+ ファイバー積（引き戻し）
+ 部分対象

真偽値と述語の射があって、部分対象分類子があればトポスだが、任意の部分対象が等値核（方程式の解）で書けるような圏が、たぶん適切な圏。

有限完備で「部分対象が等式的に定義可能」な圏では、情報無損失分解の定理が成立する。

- 分解（スパン）が情報無損失なら、ファイバー積である。

別な言い方をすると：

- テーブルTがAとBに情報無損失分解できるなら、TをAとBからselect文で再構成できる。

ところで、フレイド／セドロフ記法はけっこう使える。


</body>
</day>
<day date="2013-02-27" title="">
<body>
*1361928447*[Caty]絵のソース

http://d.hatena.ne.jp/m-hiyama/20130227/1361928297 で示した絵のソース。

&lt;pre class=&quot;code&quot;&gt;
// this is CatyScript 
// Output File: schema-book-purchase-2r.gif
[
  gv:node --style=filled --fillcolor=skyblue String,
  gv:node --style=filled --fillcolor=skyblue YMD,
  gv:node --style=filled --fillcolor=pink    Person,
  gv:node --style=filled --fillcolor=skyblue Integer,
  gv:node --style=filled --fillcolor=pink    Book,
  gv:node --style=filled --fillcolor=skyblue DateTime,
  gv:node --style=filled --fillcolor=pink    Purchase,

  gv:edge --label=name      Person String,
  gv:edge --label=birth     Person YMD,
  gv:edge --label=isbn      Book Integer,
  gv:edge --label=person    Purchase Person,
  gv:edge --label=book      Purchase Book,
  gv:edge --label=dateTime  Purchase DateTime,
  gv:edge --label=personNum Purchase Integer,
  gv:edge --label=calcAge   YMD      Integer,
  gv:edge --label=num       Person   Integer,
  gv:edge --label=&quot;num~1&quot;   Integer  Person,
  gv:edge --label=age       Person   Integer,
] | gv:graph --label=book-purchase
&lt;/pre&gt;

&lt;img src=&quot;http://www.chimaira.org/img3/schema-book-purchase-2r.gif&quot; &gt;


</body>
</day>
<day date="2013-03-02" title="">
<body>
*1362213645*[Caty]絵のソース

http://d.hatena.ne.jp/m-hiyama/20130302/1362213537 で示した絵のソース。

&lt;pre class=&quot;code&quot;&gt;
// pred-call-tree.caty
[
gv:node any,
gv:node and,
gv:node or,
gv:node not,
gv:node nor,
gv:node every,
gv:node some,
gv:node eq,
gv:node lt,
gv:node gt,
gv:node neq,
gv:node lte,
gv:node gte,
gv:node isUndefined,
gv:node isDefined,
gv:node isIn,
gv:node has,
gv:node includes,
gv:node isNotIn,
gv:node hasNot,
gv:node isIncluded,
gv:node Member,
gv:node ArrayOpen,
gv:node ArrayClose,
gv:node ObjectOpen,
gv:node ObjectClose,

gv:edge nor not,
gv:edge nor or,

gv:edge every and ,
gv:edge some  or ,
/*gv:edge gt    lt,*/
/*gv:edge neq   eq,*/
/*gv:edge neq   not ,*/
/*gv:edge lte   gt ,
gv:edge lte   not ,
gv:edge gte   lt ,
gv:edge gte   not ,*/

/*gv:edge isUndefined or,*/
gv:edge isUndefined eq,
/*gv:edge isDefined   isUndefined ,
gv:edge isDefined   not ,*/
gv:edge isIn        some,
gv:edge isIn        eq ,

/*gv:edge has         isIn ,*/
gv:edge includes    every,
gv:edge includes    isIn,
/*gv:edge isNotIn     isIn,
gv:edge isNotIn     not ,
gv:edge hasNot      has ,
gv:edge hasNot      not ,
gv:edge isIncluded  includes,*/
gv:edge ArrayOpen   and,
gv:edge ArrayClose  ArrayOpen,
gv:edge ObjectOpen  and,
gv:edge ObjectClose ObjectOpen,

gv:edge --color=red  --dir=both --style=dashed has hasNot,
gv:edge --color=red  --dir=both --style=dashed eq neq,
gv:edge --color=red  --dir=both --style=dashed lte gt,
gv:edge --color=red  --dir=both --style=dashed gte lt,
gv:edge --color=red  --dir=both --style=dashed isDefined isUndefined,
gv:edge --color=red  --dir=both --style=dashed isIn isNotIn,


gv:edge --color=blue --dir=both --style=dotted includes isIncluded,
gv:edge --color=blue --dir=both --style=dotted lt gt,
gv:edge --color=blue --dir=both --style=dotted has     isIn ,
gv:edge --color=blue --dir=both --style=dotted hasNot  isNotIn ,
gv:edge --color=blue --dir=both --style=dotted lte  gte ,


] | gv:graph pred-call-tree

&lt;/pre&gt;



</body>
</day>
<day date="2013-03-04" title="">
<body>
*1362355307*[用語法][プログラム意味論]メイヤーの原則に関わる同義語とか

- アクセッサ、観測子（オブザーバー、オブザーバブル）、属性、プロパティ、カラム、フィールド、座標、リーダー、ゲッター、セレクター
- ミューテーター（ミューテーション）、更新子（アップデータ）、変更子（モディファイヤー）、狭義のメソッド、アクション、遷移（トランジション）、移動（move）、狭義のオペレータ

スロット、メンバー、フィーチャーなんてのはどっちつかず。

隠蔽ソート、可視ソートを前提に：

+ リーダー： 隠蔽ソートから任意のソートへ
+ selfアップデーター：隠蔽ソートから自分自身へ
+ transferringアップデーター：隠蔽ソートから別の隠蔽ソートへ
+ その他：あってもよい。

アサイクリック（非輪状）条件：リーダーサイクルは存在しない。

*1362355460*[用語法][圏一般論]一般関手モデルと同義語

- スキーマ、指標、インターフェイス、シェープ、ダイアグラム、基礎系／係数系
- 制約、法則、公理、表明、一貫性、整合性、2-セル生成系、（付加的）構造
- インスタンス、モデル、表現、実現、代数／余代数、状態、加群、前層、シェープ付きデータ
- スキーマ変換／発展、指標射、シェープ変換、構文的変換、基礎の置き換え（change of base）、幾何射

</body>
</day>
<day date="2013-03-05" title="">
<body>
*1362459124*[用語法][メモ][圏一般論]フレイド／セドロフ記法を誤解していた

&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130215/1360895883&quot;&gt;フレイドの図式的論理式記法&lt;/a&gt;だが、えらい誤解をしていた。

「!」は「∃!」の略記ではない。「!」は「もし存在するなら一意的」の意味。実際に存在することは&lt;em&gt;まったく主張してない&lt;/em&gt;。

- !x.P(x) ≡ ∀x, y.(P(x)∧P(y)⊃ x = y)

*1362464552*[気付いた][圏一般論]fill条件による圏的命題の記述

可換図式に関して：

- fillable -- 可換図式を満たす射が存在する。
- unique if fillable -- もしfillableなら、そのような射達（filling）は一意的
- uniquely fillable -- fillableで、fillingが一意的。
- u.t.i if fillable -- もしfillableなら、そのような射達（filling）はup-to-isoで一意的
- u.t.i-uniquely fillable -- fillableで、fillingがu.t.i unique。


</body>
</day>
<day date="2013-03-11" title="">
<body>
*1362960313*[気付いた][プログラム意味論]外部意味論と内部意味論、静的意味論と動的意味論

普通の意味論は静的で外部的。動的内部意味論も考えるといいことあるだろう。

意味論とは、構文領域&lt;i&gt;A&lt;/i&gt;から意味領域&lt;i&gt;X&lt;/i&gt;（どちらも圏）への関手のことである。スピヴァック流に言うなら、構文領域はスキーマで、意味論はスキーマの&lt;i&gt;X&lt;/i&gt;インスタンスを与える。

構文領域&lt;i&gt;A&lt;/i&gt;を意味領域&lt;i&gt;X&lt;/i&gt;に埋め込めるなら、余極限や極限により&lt;i&gt;X&lt;/i&gt;の対象と考えることができる。さらに意味論は、&lt;i&gt;X&lt;/i&gt;の射や対象とみなせるかもしれない。なんらか方法で、F:&lt;i&gt;A&lt;/i&gt;→&lt;i&gt;X&lt;/i&gt; を &lt;i&gt;X&lt;/i&gt;内のものfにレイファイできたとき、fを内部意味論という。内部意味論と外部意味論（普通の意味論）は相互に変換可能でなくてはならない。

時間的に変化する意味論が動的意味論だが、外部意味論であっても動的にはできる（時間パラメータを付けるだけ）。だが、内部意味論が力学系（動的系）として&lt;i&gt;X&lt;/i&gt;内で定式化できると、ほんとに動的になる。ほんとに動的とは、&lt;i&gt;X&lt;/i&gt;の内部で時間発展すること。

*1362960314*[プログラム意味論][圏一般論]関手のディリクレ（Dirichlet）条件

圏&lt;i&gt;C&lt;/i&gt;上に部分圏の族 (&lt;i&gt;A&lt;/i&gt;&lt;sub&gt;i&lt;/sub&gt; | i∈I)、&lt;i&gt;D&lt;/i&gt;上に部分圏の族 (&lt;i&gt;B&lt;/i&gt;&lt;sub&gt;j&lt;/sub&gt; | j∈J) が乗っているとする。F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; が関手として、次のタイプの条件をディリクレ条件と呼ぶ。

- Fを&lt;i&gt;A&lt;/i&gt;&lt;sub&gt;i&lt;/sub&gt;に制限すると、その像は&lt;i&gt;B&lt;/i&gt;&lt;sub&gt;j&lt;/sub&gt;に入る。

i, jの組み合わせは、φ:I→J があって、j = φ(i) と書ける。



</body>
</day>
<day date="2013-03-12" title="">
<body>
*1363056186*[気付いた][具体例][小咄][セミナー]ツリー、マトリックス、カリー化

ツリーとマトリックスの関係（http://d.hatena.ne.jp/m-hiyama/20121219/1355882745 ）て、マップ型（または配列型）のデータを関数とみなしてのカリー化の等式（同型の式） [I, [J, V]&amp;#93; ＝ [I×J, V] ＝ [J×I, V] ＝ [J, [I, V]&amp;#93; だ。

*1363058466*[気付いた][お絵描き][圏一般論][高次圏論]円の面積とn角形（n = 2, 1, 0）

つまらないバカみたいなことが、とても重要だってことがある。以下のこともそういうタグイのことだろう。

「半径rの円の面積は0だ」という話がある。円を円周（1次元の図形）と考えると確かにそうだ。円周（circle）と円盤（disk）は違う。

次元が違えばまったく別な図形 -- そうなのか？ 小さな円盤と点は区別が付かない。円周とトラーラス面とソリッドトーラスも区別がつかないかもしれない。円周も円盤も連続的に1点に縮退する。連続変形にギャップはない。

三角形はおなじみだがニ角形はそうでもない。ニ角形は2次元図形で紡錘形の断面みたいな形で、確かに角はふたつある。グロービュラー構成では基本だ。一角形も2次元で、水滴形といえばいいか。とんがった点は1つ、あとは円のような境界。零角形は、たんに1点。これは辺も面を持たないが、縮退してしまったと考える。円や円盤もとんがった所はないので零角形かもしれない。

射の平行対（共端な対）を描くにはニ辺形を使う。それが可換ならニ角形を使う。その二角形は線に退化する。自己射と恒等射を描くときは、水滴型の境界を描くだろう。それが可換なら一角形となり、零角形まで縮退する。

次元が低い図形に膜を貼り、膜の部分を潰して次元を下げていく操作だ。fill and collapse、潰しはホモトピー型を変えない。fillableは(コ)バウンダリに近い概念だと思う。

*1363081980*[Caty][メモ]空間レイアウト、時間スケジュール、カメラのパン

Catyで「状態」というものをUIコンポネント（ウィジェット）のスナップショットと考えたいのだが、複数の状態の複合状態とは、空間レイアウトに対応する。実際にレイアウトはしないが、空間レイアウトの素材一式が複合状態で、集合の直積で与えられる。

一方、時間的なスケジュールは遷移で与えられる。

ところが、空間と時間が入れ替わるときがある。例えば、画面サイズでレイアウトと遷移を大きく変形する必要がある。

カメラのパンは、空間と時間を入れ替えていると思う。




</body>
</day>
<day date="2013-03-15" title="">
<body>
*1363316006*[Caty][メモ][気付いた][プログラム意味論]RPCは素晴らしい

Webアプリケーションのモデルを100%RPCベースにすることにした。RPCにしたら、ほんとに考えやすくて何かと捗る。&lt;em&gt;今までナニヤッテタンカ？&lt;/em&gt;という感じ。

RPCベースにすると、RPCサーバーはストレージコレクションと考えることができる。ただし、値は手続きだが。今のところ、部分デカルト閉構造のような感じだが、モナド類似物として定式化できるかもしれない。代数構造があるのは明らかだし、この代数構造は実用性が高い、つうか今でもガッツリ使っている。この代数構造を生かしてナントカ、と思っている。

クライアント側のインタラクショングラフ（状態遷移図）とも相性がいい。

*1363335878*[子供]日曜日

午後５時

*1363340577*[Caty][メモ][気付いた][プログラム意味論]ボンドとその誘導ルール

ユーザーとの対話状況を記述するために、インタラクショングラフというものを考えている。基本的に、以前からあるハイパーリンクによる状態遷移グラフだが、次の2点が違う。

+ シーンという単位で状態をグループ化ができる。シーンは入れ子にできる。
+ 状態をボンドという辺でつなげることができる。

ボンドは&lt;b&gt;chemical bond&lt;/b&gt;のことで、次のような絵をイメージすればよい。

&lt;img src=&quot;http://www.chimaira.org/img3/bond1_ethene-molecule1.png&quot; &gt;

&lt;img src=&quot;http://www.chimaira.org/img3/bond2_chemical-bonding.jpg&quot; &gt;

ボンドで結合された一群の状態（のオカレンス）は、複合状態（化合物に相当）を形成する。元素（elemental state）以外の化合物（compound state）では、状態遷移を行うのは複合状態となる。シーンは、複合状態がその世界線束を描く時空領域（リージョン）のようなものだ。

ボンドの記述を律儀にすると面倒なので、初期状態のボンドだけを書く。これを基本ボンドと呼ぶ。基本ボンドと状態遷移パスから、次のルールで誘導ボンドを付け加える。

+ ボンドをたどっていけるノードにはボンドを足す。ボンドの推移的閉包を作ることになる。
+ 既にあるボンドと、近距離（シーン内）遷移パスをたどっていけるノーにはボンドを足す。遠距離遷移ではボンドは完全に壊れる。
+ 遷移が可逆（reversible）のときは、逆向きの遷移もたどる。

すべての誘導ボンドを加えたグラフが実際のインタラクショングラフになる。将来、同期機構を入れるかもしれない。誘導ボンドを含めたボンドで結ばれた状態（のオカレンス）は、同時にビュー上に存在することができる。状態（のオカレンス）の可達性は、ボンド（空間方向）と遷移（時間方向）の区別をなくしたグラフ上で定義される。


</body>
</day>
<day date="2013-03-18" title="">
<body>
*1363563432*[関手データ][メモ]いくつかの話題

+ インスタンス（モデル）の内部化＝意味論のレイフィケーション
+ チェンのリレーションシップ（アソシエーション）とは何なのか？
+ キー概念の整理、テーブル間の射の表現、結合のやり方
+ 関数従属性とはなにか？


</body>
</day>
<day date="2013-03-19" title="">
<body>
*1363673056*[Caty][メモ][気付いた][プログラム意味論]続・RPCは素晴らしい

うん、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130315/1363316006&quot;&gt;素晴らしい&lt;/a&gt;。

もうなんなんだろね、このスッキリ感は！！ 

やっぱりね、違和感が残る概念を取り入れてハイブリッドにするのは良くなかったよ、シミジミ。実際は後悔しているが、あんまり後ろ向きのことを言ってもしょうがない。&lt;b&gt;純RPC&lt;/b&gt;で行こう。


</body>
</day>
<day date="2013-03-21" title="">
<body>
*1363848807*[気付いた][プログラム意味論][関手データ]指数バンドルと指標

&lt;i&gt;C&lt;/i&gt;をデカルト閉圏、&lt;i&gt;C&lt;/i&gt;の指数を [A-&gt;B] と書く。Iを添字の集合として、(i∈I | [A&lt;sub&gt;i&lt;/sub&gt;-&gt;B&lt;sub&gt;i&lt;/sub&gt;])  のような添字族を僕は、&lt;i&gt;C&lt;/i&gt;の指数バンドルと呼んでいたが、指数バンドルって単に指標モジュール（一般的指標）に過ぎない。バンドルのセクションが指標のモデル（インスタンス）。

添字の集合Iが指標だが、暗黙にスター状グラフだと解釈しているときもある（余代数指標のとき）。Iが「射の集まり」だと気づきにくいが、いったん気づけばスピヴァック流のモデル理論（インスタンスの理論）が使える。


</body>
</day>
<day date="2013-04-01" title="">
<body>
*1364782877*[関手データ][プログラム意味論]時間の空間のスピヴァック流定式化

ずっと気にしてきた概念に「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%BB%FE%B4%D6%A4%CE%B6%F5%B4%D6&quot;&gt;時間の空間&lt;/a&gt;」がある。よくわかってない。

時間の空間もスピヴァック流に考えたらいいのではないか？ 個々の時間の空間を例えば時間スキーマと呼ぶ。時間スキーマは圏である（通常は順序集合を圏とみなしたもの）、対象は時点で、射は時間推進。

時間スキーマの全体が時間ドクトリンだが、スキーマの加工や組み合わせにより、ドクトリンには代数構造が入る。典型的には直和や貼り合わせだ。時間スキーマを境界付きグラフと考えれば、順次結合もできる。同期・待ち合わせは商構成になるかもしれない。

個々の時間スキーマではなくて、ドクトリンの（圏的）代数構造が問題なのだろう。このセッティングでのモデル（のインスタンス）は、運動＝実行＝runとなる。運動の準同型はホモトピーで与えられる。となると、アンビエント圏も高次圏か？

</body>
</day>
<day date="2013-04-05" title="">
<body>
*1365152962*[子供]日曜

午後3時の約束。

</body>
</day>
<day date="2013-04-08" title="">
<body>
*1365383967*[TQFT][圏一般論][DFD]圏的場

「圏ラベル付きのグラフ」という概念を何度か出したことがある。イエッター（Yetter）らの関手結び目理論でもそういうもの（圏ラベル付きのタングル）が出てくる。これは結局、関手の表現（presentation、representationではない）になっている。

物理で「場」という概念を使う。局所的に場は関数だ。が、場と関数は（局所的にでも）やっぱり別物だと思う。どう別物かを形式的には定義できないが、単なる関数に比べて場は物理的直観が働くのだと思う。

圏ラベル付きのグラフというのはいわば場のようなもので、単なる関手とは違ったメンタルモデルを持てる。このメンタルモデルが有利に働くこともあるだろう。また、場が局所的な関数（バンドルのセクション）の貼り合わせであるように、局所的な関手を（ファイバー付き圏やインデックス圏との関係で）貼り合わせて大域的な場を構成可能（あるいは不可能）かもしれない。バンドルの変換群のような働きを亜群がするのだろう、と思う。

以前からカテグラフ（categraph）／リグラフ（rigraph）と呼んでいたものが圏的場だ。主に、境界による貼り合わせを考えていたが、なにも境界に限らなくてもいいかもしれない。境界のない圏で、開集合に当たるような部分圏で定義された場を貼り合わせるほうが事例が多いかもしれない。

いずれの場合でも、場が棲んでいる圏のスパン／余スパンと極限／余極限構成が基本だ。

*1365387576*[Caty][関手データ]レイアウトとナビゲーションとスケッチ

- [http://d.hatena.ne.jp/m-hiyama-memo/20130312/1363081980:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20130315/1363340577:title]

↑に関係する話。

スピヴァックのOlog論文を1/3くらい読んだ。さすがにスピヴァック、あのニイチャンはいいこと言うよなー。

直積（より一般に極限）の説明にレイアウト（layout）という言葉を出している。A×B は、AとBの要素を空間的に一度に見せることになる。一度に見せるにはレイアウトが必要になる。一般的極限の場合は直積より複雑なレイアウトをすることになる。極限の構成ではレイアウトを考えることになる。ナルホドー。

直和・余極限はグループ（group; 数学用語じゃなくて日常的意味）といっているが、これはイマイチかな。A + B は空間的に一度に見せることはできなくて「AかBの一方」を選んで見せる、チョイスかな。AとBを両方見たいなら、時間的に順に辿らないといけない。だから、空間的レイアウトに対して時間的ナビゲーションを考えることになる。

極限も余極限も、素材の組織化・編成・配置（organization、arrangement）なのだが、極限が空間的な配置、余極限が時間的な配置となる。よって、極限構成がレイアウト設計、余極限構成がナビゲーション設計と言ってもいいだろう。

最近、僕が問題にしているのは空間方向と時間方向を相互に入れ替えることなんだよね。レイアウトとナビゲーションを入れ替えるとも言える。このためには、極限とか余極限を取る前の素材、つまり関手を扱う必要がある。関手自体だと扱いにくいから、例えば添字付き族（indexed family）とかラベル付き有向グラフとかの関手の表示（presentation）を経由して扱う。ひょっとして、&lt;del datetime=&quot;2013-04-09T08:16:18+09:00&quot;&gt;マッカイ&lt;/del&gt;マッケイ（Makkai）((http://ja.forvo.com/word/michael_makkai/))のスケッチってやつなのかな？

*1365389941*[関手データ]オッカム／スピヴァックの剃刀

オッカムの剃刀（英: Occam's razor）→ http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80

&gt;&gt;
必要が無いなら多くのものを定立してはならない。&lt;br&gt;少数の論理でよい場合は多数の論理を定立してはならない
&lt;&lt;

説明のための基本原理は最小に保て、ってことだと思う。他の仮定から導出できる定理を公理にしてはいけない、とも取れるが、もっと一般的に、非本質だと思えるものはドンドン考察の範囲から切り落としていけ、と拡大解釈したい。

関手データモデルは、普通の人が大事だと思っているものでもかまわずにバサバサ切り落としていった結果、単純な本質を見事に抽出した、という感じ。普通なら切り落とせないで残してしまう仮定や概念を捨てる能力が常人とは違ったわけだ。

あれは才能だろうが、凡人でも真似すれば明らかに改善する。真似しよう。剃刀を振り回そう、ただし危なくないように。

*1365406224*[メモ]その他メモ 予定

今日は色々書いた。が、まだ書くことはある。今日は無理そうだが。

- 関手 F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; があるときに、g∈&lt;i&gt;D&lt;/i&gt; に対して、逆像F&lt;sup&gt;-1&lt;/sup&gt;(f) を二部グラフとみて、この二部グラフ上の圏に値を持つラベリングを前送りする方法。ユニオン型の前送りとジョイン型の前送りを具体的に書き下す。たぶん、derivatorのホモトピー・カン拡張につながる。
- Tao of RPC というタイトルの記事。RPCの真髄は何か？ そのためにはメッセージフォーマットとエンドポイントネーミングに対するアダプテーションをしなくてはならない。


</body>
</day>
<day date="2013-04-09" title="">
<body>
*1365465066*[Caty][プログラム意味論]RPCの理想は失われた、だが…

- [http://d.hatena.ne.jp/m-hiyama-memo/20130315/1363316006:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20130319/1363673056:title]

RPCは、距離や方式に無関係に手続き呼び出しを行う技術。引数や戻り値のデータ形式の違いはマーシャラが吸収してくれる。距離と方式に関わる諸々の面倒はIDLコンパイラが引き受けてくれる。かくしてプログラマは、（ほとんど）何も気にせずに手続きを呼び出せる。直接呼び出しも遠隔呼び出しも区別する必要がない。距離がゼロでも2センチでも1万キロでも関係ないのだ。

まー、なんて素晴らしい。だが、RPCの崇高な理想はなぜか忘れられ、むしろ批判の対象になってしまった。「もっと現実を見るよ、距離や方式に無関係なんて出来やしない、距離と方式を意識するんだ！」と。なんという堕落だ、なんという怠惰だ、なんという迎合だ。かくいう僕も、この風潮に乗ってしまったのだから、他人をとやかく言えた義理ではない。

だが今は易きに流れたことを後悔している。RPCの理想はやはり実現されるべきなのだ。距離がゼロでも2センチでも1万キロでも関係なしに、その他諸々の差異や条件を忘れて、手続きを呼び出せるべきなのだ。1万キロの彼方にある手続きが、ここに（距離ゼロで）あるように扱えるのはホントに素晴らしい。

堕落と怠惰であてどなく底辺を彷徨うのはやめよう。もう一度、あの理想を思い出そうぜベイビー。

&lt;hr&gt;
&lt;b&gt;[追記]&lt;/b&gt;技術的には次も参照：

- [http://d.hatena.ne.jp/m-hiyama-memo/20120505/1336172779:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20120507/1336347850:title]

&lt;b&gt;[/追記]&lt;/b&gt;


</body>
</day>
<day date="2013-04-10" title="">
<body>
*1365584612*[Caty][プログラム意味論]Tao of RPC

「&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130409/1365465066&quot;&gt;RPCの理想は失われた、だが…&lt;/a&gt;」で、

&gt;&gt;
堕落と怠惰であてどなく底辺を彷徨うのはやめよう。もう一度、あの理想を思い出そうぜベイビー。
&lt;&lt;

と書いた。中途半端なハイブリッド方式はもうコリゴリだ。ほんとにロクなことがない、サイテーだったわ。純粋PRCモデルに回帰する。そして、無残に退化したRPC環境を現実的に回復させる。

RPCの真髄は、手続き呼び出しの距離や方式を捨象することだ。これさえ出来れば、他は要らない。

&gt;&gt;
直接呼び出しも遠隔呼び出しも区別する必要がない。距離がゼロでも2センチでも1万キロでも関係ないのだ。
&lt;&lt;

しかし当然、転送レイヤーとかメッセージングインフラとか呼ばれる基盤技術に影響される。現状では、ここはHTTP一択だろう。だが、だからといってHTTPベタベタにしては時計の針が逆戻り、まったく抽象化されてないウザウザ・ドロドロの世界だ（ほんとにコリゴリだってば）。

転送／メッセージングの制約はプロトコルと呼ばれるお約束だが、プロトコルは次を決めていると思ってよい。

+ 転送されるメッセージのフォーマット
+ エンドポイントの識別・命名方式

メッセージのフォーマットを型システムで表現できたとして（実際表現できる）、InMsg型、OutMsg型とする。エンドポイントの識別子の全体の集合をJとする。Jは通常、文字列全体の集合stringの部分集合となる； J⊆string 。

計算モデルの圏、つまりデータ型を対象として計算可能関数（Catyではコマンド）を射とする圏を&lt;i&gt;C&lt;/i&gt;とする。InMsgとOutMsgは圏&lt;i&gt;C&lt;/i&gt;の対象となる； InMsg, OutMsg∈|&lt;i&gt;C&lt;/i&gt;|。メッセージフォーマットの制約から、ホムセット &lt;i&gt;C&lt;/i&gt;(InMsg, OutMsg) に属する射（関数、コマンド）しか外部から呼び出せない。

外部から遠隔呼び出し可能な関数／コマンドを&lt;strong&gt;アクション&lt;/strong&gt;と呼ぶ。アクションの集合は圏&lt;i&gt;C&lt;/i&gt;のホムセットだから、

- Action = &lt;i&gt;C&lt;/i&gt;(InMsg, OutMsg)

もし、&lt;i&gt;C&lt;/i&gt;に指数があるなら、指数型 OutMsg&lt;sup&gt;InMsg&lt;/sup&gt; （上付きを避けたいときは [InMsg, OutMsg] とも書く）をActionと定義してもよい。&lt;i&gt;C&lt;/i&gt;(InMsg, OutMsg) は圏のホムセットだが、指数型 OutMsg&lt;sup&gt;InMsg&lt;/sup&gt; は圏の対象となる。ホムセットなら Action⊆&lt;i&gt;C&lt;/i&gt; （正確には、Action⊆Morphism(&lt;i&gt;C&lt;/i&gt;)）、指数対象なら Action∈&lt;i&gt;C&lt;/i&gt; （正確には、Action∈|&lt;i&gt;C&lt;/i&gt;|、|&lt;i&gt;C&lt;/i&gt;| = Object(&lt;i&gt;C&lt;/i&gt;)）。以下、指数ではなくてホムセットとして話す。

一般に、射 f:A→B in &lt;i&gt;C&lt;/i&gt; があるとき、fを遠隔呼び出し可能とするには、fをアクション化した Act(f) が必要。Act(f)∈Action、Action = &lt;i&gt;C&lt;/i&gt;(InMsg, OutMsg)。&lt;i&gt;C&lt;/i&gt;の任意の射をアクション化したいなら、Act:&lt;i&gt;C&lt;/i&gt;→Action というアクション化写像を定義する必要がある。ソフトウェア的には、（アクション化のための）ラッパーとかアダプターと呼ばれるものを定義する。任意の射をアクション化するのが無理なら、Act:&lt;i&gt;C&lt;/i&gt;→Action は部分写像となる。写像Actの定義域は「アクション化可能な射」の集合となる。

アクション化のラッパー／アダプターにより、メッセージフォーマットの問題は解決できる。次に、エンドポイントの識別子の問題。g:J→Action という部分写像を考える。gはgetとかlookupとか書けばよりわかりやすい。j∈J に対して g(j)∈Action、つまりgはキーjからアクションを引き当てる関数（ミスヒットがあるので部分写像だ）。(Action, J, g) は、Key-Value-Store構造を定義する。ただし、Valueがアクションだから、Key-Action-StoreとかKey-Procedure-Storeと言ったほうがいいかも。

(Action, J, g)のようにキー（識別子）からアクションを引く、そしてアプライする機構を&lt;strong&gt;パフォーマー&lt;/strong&gt;と呼ぶことにする。パフォーマーはPRCサーバーと同義である。

結局、RPCを可能とするには：

+ アクション化のラッパーを作る。
+ パフォーマーを作る。

これらの構造は、もとの計算モデル圏&lt;i&gt;C&lt;/i&gt;には一切手を加えない点が重要。呼ばれる側（callee）は、自分がラッパーに包まれていることも、外部で通用する識別子（キー）で引かれたことも、また外部から呼ばれていることさえもまったく知らない、知るスベもない。これがRPCのキモだ。メッセージフォーマットに依存したラッパーと、エンドポイント命名方式に依存したパフォーマーも独立している。依存関係は最小だ。

プロトコルが具体的に与えられたからといって、これらをベタベタグチャグチャに密結合させてはダメなのだ。って、このあいだまで僕自身がベタグチャをやっていた。ベタグチャの弊害やダメさ加減を十分自覚していたとも言い難い。モヤモヤ感と不満を抱いていただけだ。「堕落と怠惰であてどなく底辺を彷徨う」とはこのことだ。

僕がヘマをやらかしただけなら、一人で反省と自戒をすればいいことだが、ほとんどの人が違和感・不満さえ抱かずにベタグチャをやっている。恐ろしい。一番恐ろしいのは、ほんの少し前の自分が（違和感・不満を感じながらも）、自分と周りに対して懐疑も批判も出来なかったことだ。なんてこった。まー、やっと厚生の道を歩み出したが…


</body>
</day>
<day date="2013-04-11" title="">
<body>
*1365640594*[Caty][メモ]名前の意義と恐ろしさ

『千と千尋の神隠し』では、名前を奪われたり忘れてしまう事が、自己が喪失する事にように描かれていた（たぶん）。どこぞの民族だか部族だかで、本名は家族親族くらいしか知らず（教えず）、俗名というかあだ名みたいな呼び名を常用するという話を読んだ記憶がある。名前がないものは存在しないも同じだと思うことは多い。古来、言霊信仰なんてのもある。

ある程度の規模のソフトウェアでは、名前の管理に相当な手間を費やす。DNSなしでインターネットは使えない。ドメイン名が訴訟のタネになったり、高価で取り引きされたりする。Catyでも、名前の管理は一番悩むし、かけた労力も半端ではない。

ソフトウェアのメカニズム上も、名前（ID、キー）はもちろん必須だ。まずは参照／名指しに使う。通信で、実体が送れないときに代わりに名前を送ることができる。送り元と送り先で、名前の合意（参照先の一致）が取れていれば、実体を送る必要がない。この技法を&lt;b&gt;キー転送&lt;/b&gt;と呼ぼう。

キー転送はものすごくポピュラーな技法で至るところに使われている。僕が最近、恐ろしいと感じたのは、主客転倒、価値の逆転現象だ。キー転送で使うキーは、便宜上のもので単なる手段だ。実体の代理なら何でもいい。だが、キーも名前なので、名前としての価値が生じてしまう。キーがアイデンティティーの一部となる。実体の代理に過ぎなかったことが忘れ去られ、キー＝名前が主役となり、手段が目的とすり替えられる。

かくして、実体のあいだの対応や実体の操作が隠蔽される。話は完全に逆だ、隠蔽されるべきはキー転送という方便のほうなのだ。名前が、ほんとに価値やアイデンティティーにつながるものなのか、ポインターやキー転送のようなソフトウェア上の方便／手段に過ぎないのかはよくよく考える必要がある。バカみたいな処方箋だが、その名前を連番やUUIDにしたらどうか？ と一度は疑ったほうがいい。

*1365653157*[論理][リンク]LKの規則

次にLKの規則が列挙されている、これは助かる。

- http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%BC%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%88%E8%A8%88%E7%AE%97

そういえば、ここもあった。↓

- http://sakharov.net/sequent.html


</body>
</day>
<day date="2013-04-12" title="">
<body>
*1365729392*[Caty][関手データ]関手と圏の拡張とRPC

Gが圏の表示、Cat(G) = &lt;i&gt;C&lt;/i&gt; だとする。関手 F:&lt;i&gt;C&lt;/i&gt;→D は、Φ:G→&lt;i&gt;D&lt;/i&gt; で表示できる。（正確には、&lt;i&gt;D&lt;/i&gt;に忘却関手を働かせるが。）Fの代わりにΦを使えば記述はだいぶ楽になるのだが、そもそも「関手」という意識を薄めたい。

グラフの操作として直和 &lt;i&gt;D'&lt;/i&gt; := &lt;i&gt;D&lt;/i&gt; + G を作って、Φを&lt;i&gt;D'&lt;/i&gt;上のパス同値関係とみなしたい。実際には困難がある。Φ(A) = X とすると、AとXは別物で、AとXを繋ぐ射が存在しない。A|→X はあくまで関手としての対応で、関手で対応してもそこに射があるわけじゃない。

この困難を乗り越える技術がRPCではないかと思う。RPCは、異なる2つの圏のあいだに関手より実質的な内容を持つ射（同型射）を導入する働きを持つのだろう。おそらく。

*1365735934*[Caty][関手データ]ピグマリオン症候群、標準化、関手嫌悪

記憶が曖昧だが、ブルーバックスのJ.L.シンジ・著『相対性理論の考え方』のなかで、著者はピグマリオン症候群という言葉を使っていたと思う。戯曲に出てくるピグマリオンは、自分の作ったビーナス像に恋をしてしまったとか。物理の文脈だと、理論的モデルに心を奪われて物理的現象を見なくなってしまうことだろう。

名前、キー、IDばっかりに目がいってしまい、実体や実体のあいだの対応を見なくなってしまうのもピグマリオン症候群と呼んでいいかもしれない。本物ではない仮のもの、代理に過ぎないものを実体と勘違いしてしまう、あるいは実体より価値あるものとしてしまうのだから。

ID（主キー）とそれによる参照（外部キー）、通信における&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130411/1365640594&quot;&gt;キー転送&lt;/a&gt;は、ポピュラーで役に立つ技法だが、名前、キー、IDは本物ではない。実体がなんであるかを忘れてしまうピグマリオン症候群に陥っては、本物（実体）の世界とその構造が見えるわけもない。

ologとRDFの違いは、ologが関手を使うことだ。しかも部分的な関手（関手のスパン）を積極的に使う。関手を使わないとどうなるか？ 名前と構造を標準化するしかない。ほとんど常にこの方法・標準化が選択される。しかし、自分に嘘をつかずに考えて欲しい -- ほんとに名前や構造が標準化できると思う？ 今の僕は、「できる」という答は自分を偽った強がりか、幻覚を見ているとしか思えない。

名前は構造的であるべきか不透明であるべきか？ 不変であるべきか、日々改善すべきか？ 自然言語的分かりやすさはどう定義される？ 階層化の基準は？ マトリックス状の構造はどうする？ 親子関係や所属関係が多重なときは？ 自分に嘘をつかずに答えられるだろうか。

僕はスピヴァック流に関手を導入すべきと思うが、関手嫌悪があるのも事実。ひとつの事物にはひとつの名前（ID、キー）とかに拘るのもゆえなくもない。破綻するしかない標準化、救える手段である関手は嫌われる。「どうすりゃいいの？」とは思うが、まー、妥協点を探るしかない。

*1365737833*[Caty][関手データ][圏一般論]関手柱圏

F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; が関手のとき、関手Fの&lt;strong&gt;関手柱圏&lt;/strong&gt;（functor cylinder category）というものを定義する。図形的な雰囲気が、&lt;i&gt;C&lt;/i&gt;と&lt;i&gt;D&lt;/i&gt;を上面と下面（底面）として、Fが母線群を形成する柱体を連想させるのでこの名前にした。Cylinder(F)、より詳しくは Cylinder(F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt;) と書くことにする。

関手柱圏は、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130412/1365735934&quot;&gt;関手嫌悪&lt;/a&gt;への対策でもあるし、&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130412/1365729392&quot;&gt;RPCの定式化&lt;/a&gt;でもある。

圏は有限表示（有限な生成グラフと有限の等式制約）を持つとする。圏そのものよりはむしろ表示を扱う。Gが表示で、Cat(G) = &lt;i&gt;C&lt;/i&gt; とする。関手 &lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; と表示 G→&lt;i&gt;D&lt;/i&gt; を区別しないことにする。F:G→&lt;i&gt;D&lt;/i&gt; が関手のとき、表示の圏のなかで直和 G + &lt;i&gt;D&lt;/i&gt; を作る。次の操作をする。

- X∈|G| ごとに、i&lt;sub&gt;X&lt;/sub&gt;:X→F(X) という形式的な同型射を加える。i&lt;sub&gt;X&lt;/sub&gt; には逆 i&lt;sub&gt;X&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt; がある。

この操作を施した表示を H とする。|H| = |G| + |&lt;i&gt;D&lt;/i&gt;| で射（辺）と制約はi&lt;sub&gt;X&lt;/sub&gt;の分だけ増えている。この表示Hから生成された圏 &lt;i&gt;E&lt;/i&gt; := Cat(H) がFの関手柱圏Cylinder(F)となる。

&lt;i&gt;E&lt;/i&gt; = Cylinder(F) には次の特徴がある。

+ &lt;i&gt;C&lt;/i&gt;は、自然に&lt;i&gt;E&lt;/i&gt;の部分圏となる。&lt;i&gt;C&lt;/i&gt;⊆&lt;i&gt;E&lt;/i&gt;。
+ &lt;i&gt;D&lt;/i&gt;は、自然に&lt;i&gt;E&lt;/i&gt;の部分圏となる。&lt;i&gt;D&lt;/i&gt;⊆&lt;i&gt;E&lt;/i&gt;。
+ F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; は、F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;E&lt;/i&gt; とみなせる。
+ 埋め込み関手 &lt;i&gt;C&lt;/i&gt;→&lt;i&gt;E&lt;/i&gt; と F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;E&lt;/i&gt; のあいだに自然同型がある。

&lt;b&gt;[追記]&lt;/b&gt;もうひとつ重要な特徴がある。ただし、定式化が曖昧なんだけど。

M:&lt;i&gt;D&lt;/i&gt;→&lt;i&gt;A&lt;/i&gt; が、スピヴァックの意味のモデルインスタンスだとする。&lt;i&gt;A&lt;/i&gt;がアンビエント圏。F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; とMを結合した F;M = F&lt;sup&gt;*&lt;/sup&gt;M : &lt;i&gt;C&lt;/i&gt;→&lt;i&gt;A&lt;/i&gt; はもちろん&lt;i&gt;C&lt;/i&gt;上のインスタンスになる。

それとは別に、Mを&lt;i&gt;E&lt;/i&gt;（Cylinder(F)）上の&lt;a target=&quot;_blank&quot; href=&quot;http://d.hatena.ne.jp/m-hiyama/20130405/1365150165&quot;&gt;部分関手&lt;/a&gt;と考える。Mは&lt;i&gt;E&lt;/i&gt;の部分圏&lt;i&gt;D&lt;/i&gt;を定義域とするが、&lt;i&gt;E&lt;/i&gt;全域への“自然な拡張”をM&lt;sup&gt;~&lt;/sup&gt;とする。

ここで自然な拡張の意味が明らかではない。&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20101102/1288676747&quot;&gt;稠密な部分圏&lt;/a&gt;とか&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20081101/1225518932&quot;&gt;十分な部分圏&lt;/a&gt;とかが関わるだろう。ともかくこのM&lt;sup&gt;~&lt;/sup&gt;が在るとして、それは、Mと、F;Mの埋め込み &lt;i&gt;C&lt;/i&gt;⊆&lt;i&gt;E&lt;/i&gt; に伴う前送りとの&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama/20130406/1365233528&quot;&gt;貼り合わせ&lt;/a&gt;に一致すると思う。

&lt;b&gt;[/追記]&lt;/b&gt;


</body>
</day>
<day date="2013-04-13" title="">
<body>
*1365826966*[Caty][関手データ][圏一般論]関手とシリンダー圏

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130412/1365737833&quot;&gt;カンシュチュウケン（関手柱圏）&lt;/a&gt;」って口頭で言いにくい、&lt;strong&gt;シリンダー圏&lt;/strong&gt;にした。

んで、次のように考えている； 関手 F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; を記述するのはどうも難しい、つうか煩雑。そこで、Fのシリンダー圏を定義することによって関手の記述に代える。関手とそのシリンダー圏が（なんらかの意味で）同値であることを示せば、この方針は合理化できる。

ただし、関手から構成した後のシリンダー圏ではなくて、シリンダー圏それ自体の定義を与えなくてはならない。表示のレベルで考えれば、これは難しくない。排他的に与えられた2つの表示G, Hと、|G|で添字付けられた形式的同型射の族 {iX | X |G|} があればよい。形式的同型射の族と言ったが、この条件はもう少しゆるく出来るのかも知れない。ここらへんは、試行錯誤で塩梅を見て決める。

スピヴァックの言うパス同値関係は、等式的制約であり、自由圏におけるパスをどのように同一視するか、別言すれば商集合の作り方を指定している。p = q という等式（パス同値関係）で、左辺が（別にどっちでもいいが）グラフの辺、つまり長さ1のパスのときは、f = q となる。f := q と書いてみると、これはfを定義している式とみなすことができる。

つまり、定義とは等式制約の特殊な形なわけだ。一方、f =&gt; q と書いてみると、辺にパスを対応させているので関手ともみなせる。&lt;em&gt;等式的制約（同値関係の生成系）、定義、関手というのは似たようなもの&lt;/em&gt;なのだ。

関手の代わりにシリンダー圏を使うことは、上記の事実に依拠した発想だ。関手の記述は、シリンダー圏における等式制約または射の定義となる。ただし、あまりにも「同じ同じ」と統合してしまうと、かえって分かりにくくなる。ある程度の違いを残しておいたほうが良いこともある。このへんの匙加減が難しい。

*1365823822*[メモ][Caty]メタオブジェクを勘定する

&lt;pre class=&quot;code&quot;&gt;
/* 一時的 */
module t;

command count-mos [string app] :: void -&gt; object {
 %1 &gt; app;
 sreif:list-modules %app | mpl:fullnames &gt; mods | {&quot;mods&quot;: list:length} &gt; c1;
 %mods |
 each {
    pass &gt; mod;
    do {
      sreif:list-types       %mod | list:length &gt;: &quot;types&quot;,
      sreif:list-annotations %mod | list:length &gt;: &quot;annotations&quot;,
      sreif:list-commands    %mod | list:length &gt;: &quot;commands&quot;, 
      sreif:list-classes     %mod | mpl:fullnames &gt; clss | list:length &gt;: &quot;classes&quot;,
      sreif:list-resources   %mod | mpl:fullnames &gt; ress | list:length &gt;: &quot;resources&quot;,
    } &gt; cc1;
    %clss |
    each {
      pass &gt; cls;
      do {
         sreif:list-commands %cls | list:length &gt;: &quot;methods&quot;
      }
    } | {&quot;classDetails&quot;: pass} &gt; cc2;
    %ress |
    each {
       pass &gt; res;
       do {
         sreif:list-actions %res | list:length &gt;: &quot;actions&quot;
       }
    } | {&quot;resourceDetails&quot;:pass} &gt; cc3;
    [%cc1, %cc2, %cc3] | json:merge
 } | {&quot;modDetails&quot;: pass} &gt; c2;
 
 [%c1, %c2] | json:merge
};
 
command flatten-count :: (object | array) -&gt; [number*] {
 each {
  when {
     number =&gt; pass,
     * =&gt; flatten-count,
  }
 } | xjson:flatten
};
&lt;/pre&gt;

t:count-mos caty の結果：

&lt;pre class=&quot;code&quot;&gt;
{
    &quot;mods&quot;: 30, 
    &quot;modDetails&quot;: [
        {
            &quot;commands&quot;: 100, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 141, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 18, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 15, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 3, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 9, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 24, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 16, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 12, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 9, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 5, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 9, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 4, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 0, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 11, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 7, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 3, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 2, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 3, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 1, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 14, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 0, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 0, 
            &quot;resourceDetails&quot;: [
                {
                    &quot;actions&quot;: 1
                }, 
                {
                    &quot;actions&quot;: 1
                }, 
                {
                    &quot;actions&quot;: 1
                }, 
                {
                    &quot;actions&quot;: 4
                }
            ], 
            &quot;classes&quot;: 4, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [
                {
                    &quot;methods&quot;: 1
                }, 
                {
                    &quot;methods&quot;: 1
                }, 
                {
                    &quot;methods&quot;: 1
                }, 
                {
                    &quot;methods&quot;: 4
                }
            ], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 4
        }, 
        {
            &quot;commands&quot;: 10, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 6, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 3, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 6, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 2, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 7, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 79, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 9, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 3, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 8, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 2, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 3, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 4, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 3, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 14, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 13, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 0, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 0, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 8, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 10, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 1, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }, 
        {
            &quot;commands&quot;: 10, 
            &quot;resourceDetails&quot;: [], 
            &quot;classes&quot;: 0, 
            &quot;types&quot;: 2, 
            &quot;classDetails&quot;: [], 
            &quot;annotations&quot;: 0, 
            &quot;resources&quot;: 0
        }
    ]
}
&lt;/pre&gt;

</body>
</day>
<day date="2013-04-15" title="">
<body>
*1365984397*[Caty][関手データ][圏一般論][リンク]スケッチ

スピヴァックもスケッチには言及しているので、ほんのちょっとだけ調べてみた。次の論文を斜め読みした。

- http://www.cwru.edu/artsci/math/wells/pub/pdf/sketch.pdf

これは短くよくまとまっていると思う。

- スケッチは、60年代末にシャルル・エーレスマン（Charles Ehresmann）が考えたらしい。
- 発案者がミカエル・マッケイ（http://www.math.mcgill.ca/makkai/ 発音 http://ja.forvo.com/word/michael_makkai/）かと思ったが違った。マッケイは一般化したらしい。
- 初等スケッチ（elementary）または線形スケッチ（linear）というのが、スピヴァックのプレーンなスキーマに対応する。
- スケッチは、a species of mathematical structure の記述らしいが、a species of categorical structure ならドクトリンになる。
- 特に、multisorted（many-sorted）な構造にはスケッチが必要。one-sorted（single-sorted）な代数／余代数では済まないから。
- 指標の言葉でいえば、sorts, operations, projectively constructed sorts, injectively constructed sorts を定義する方法。
- 可換図式を単に図式（diagram）と呼んでいる。これは紛らわしいかも。
- 錐と余錐の集合を指定するが、錐の側面の可換性を仮定しないことがあるらしい？ 常に可換にしたほうがいいのではないか。
- 錐と余錐の代わりに、楔と余楔に一般化できるかもしれない。実際、エンド／コエンド計算を主体にした圏的計算系があったような気がする。
- 「スケッチの型」という概念が出てくるがいまいちハッキリしない。ドクトリンとみなしていいらしいが、ドクトリンがハッキリしないし。
- ドクトリンと言い出したのはローヴェルらしい。代数理論ももちろんローヴェル（リントン（Linton）も寄与している）。初等トポスもローヴェル（オリジナルはグロタンディーク）。
- 「スケッチを使って記述する」ことを動詞で「スケッチする」と言う。
- ドクトリンとセオリーの関係はよく理解できない。もうちょい調べたい。
- スケッチの分類トポス（classifying topos）があるらしい。

スケッチのデータベースへの応用だと次もあるが読んでない。

- http://www.cs.toronto.edu/~zdiskin/Pubs/ULReport-M97.pdf


</body>
</day>
<day date="2013-04-17" title="">
<body>
*1366166941*[人物][からみ系][お絵描き]David Yetter の発音

forvoで発音募集したら来てた

- http://ja.forvo.com/word/david_yetter/

「イエッター」というよりは「イエター」または「ヤター」かな。とりあえず「イエター」にしよう。



</body>
</day>
<day date="2013-04-19" title="">
<body>
*1366357171*[メモ]derivator

について調べなくてはならない。

*1366340156*[Caty][プログラム意味論][圏一般論]RPCが良い理由

圏論バイアスによる発言ではあるが、RPCが他の方法に比べて格段に優れているのは、圏論との相性が良いからだ。

手続きや状態のキー化（コード化）やマーシャリングは、部分デカルト閉構造で記述できる。同じ圏に複数の部分デカルト閉構造が載るのだが（それは普通）、それぞれから部分デカルト閉圏を作って、部分デカルト閉圏としての圏同値を与える関手や自然同型を考える。これがおよそRPC（より一般にxPC）の定式化になる。

遠隔呼び出しに関して言えば、ローカル圏とリモート圏（あるいはクライアント圏とサーバー圏）のあいだの関手を与えればいいのだが、一緒に自然同型が必要で、この自然同型（成分が同型射である自然変換）を与えるメカニズムがRPCの個別具体的な方式に対応する。RPC方式は自然変換なので、縦結合と横結合が可能となる（2-圏）。また、RPC方式の比較には3-セルが使える。

こういうことが自由に出来るってことはとんでもなく気持ちがいい。他の方式がとんでもなく気持ちが悪いのは、圏論的自由がほとんどないからだろう。僕としては手足をもがれた((この表現は「政治的に正しくない」と思うが、比喩的表現の言葉狩りには賛同しない。))ような状態だ。やっぱり耐えられるはずがない。

*1366340735*[Caty][プログラム意味論][圏一般論]RPCのreturn

RPCのcallには、2つの部分デカルト閉構造（評価構造とか適用構造と言ってもいい）が絡むのでけっこう複雑。しかしreturnは簡単。&lt;i&gt;C&lt;/i&gt;と&lt;i&gt;D&lt;/i&gt;が圏で（&lt;i&gt;C&lt;/i&gt; = &lt;i&gt;D&lt;/i&gt; でもよい）、F:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; が関手（あるいは部分関手）とする。別に、埋め込み関手 I:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;D&lt;/i&gt; があるとして、return::F⇒I という自然同型となる。

&lt;i&gt;C&lt;/i&gt;がクライアント圏で、&lt;i&gt;D&lt;/i&gt;はサーバー圏を含む十分に大きな圏だとする。Iは大きな圏&lt;i&gt;D&lt;/i&gt;への埋め込みなので、&lt;i&gt;C&lt;/i&gt;⊆&lt;i&gt;D&lt;/i&gt; と考えてよい。I(S) = S のようにIを恒等関手のようにみなす。return&lt;sub&gt;S&lt;/sub&gt;:F(S)→S という同型。F(S)は、クライアントサイドの型Sに対応するサーバーサイドの型。よって、return&lt;sub&gt;S&lt;/sub&gt;:F(S)→S によりサーバーサイドの戻り値と対応するクライアントサイドの戻り値が１：１に対応するのが保証される。

*1366357976*[メモ][関手データ][圏一般論]グルーイングの圏？

&lt;i&gt;C&lt;/i&gt;が有限完備かつ有限余完備な圏だとして、&lt;i&gt;C&lt;/i&gt;内の菱型の図式◇を考える。これは融合和（pushout 押し出し）になっているとする。図式として余極限錐（colimiting cone）になっている。

このような菱形を2つ並べた ◇◇ を考える。真ん中の上方は余スパンの形をしているので、ファイバー積を取る。下はスパンだから融合和をとる。すると、上側にファイバー積の◇、下側に融合和の◇を追加することになる。こうして出来た外側の大きな◇は、融合和になっているだろうか？

もしなっているなら、融合和を射とする圏ができる。

</body>
</day>
<day date="2013-04-22" title="">
<body>
*1366589546*[気付いた][関手データ][圏一般論]複階層的圏と圏の大域的構造

複階層的圏または多重階層的圏とは、圏&lt;i&gt;C&lt;/i&gt;といくつかの部分圏 &lt;i&gt;H&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt;, ..., &lt;i&gt;H&lt;/i&gt;&lt;sub&gt;n&lt;/sub&gt; の組で、

- 各&lt;i&gt;H&lt;/i&gt;&lt;sub&gt;i&lt;/sub&gt;（i = 1, ..., n）はやせた広い圏である。

&lt;em&gt;これだけ&lt;/em&gt;。

事例は、集合の包含関係（束）と構造的な親子関係（ツリー）を持つ圏。兄弟関係も必要かもしれない。これらの部分圏に名前を付けて

+ Includes
+ Parent
+ Elder
+ Younger

とする。射がそれぞれの部分圏に属するとき、小文字始まりのラベルを付けることにする。

+ includes : A→B
+ parent : A→B
+ elder : A→B
+ younger : A→B

これにより、ラベルの数を極端に減らすことができるし、ラベルの意味の共通性を同一名で表すことができる。また、射が特定の部分圏に入ることを矢印記号や辺の色などでグラフィカルに識別することができる。

parentのようなツリー状階層の場合、射を書かずに、親ノードをクラスターで表現することができる。elder/younger対はどちらか片方を書けば部分写像の概可逆性で推論できる。

&lt;hr&gt;

この複階層的圏を使うと、代数／余代数の別な（より扱いやすい）定式化ができる。例えば、兄弟に順序が付いたツリー構造を表す指標を次のように決める。

- parent
- next
- prev

関係圏をアンビエント圏に使うなら次も入れていい。

- children

このような名前を、それぞれがやせた広い圏を定義すると考える。対象ごとに、各やせた圏に所属する射を寄せ集めると、その対象のツリー構造ができ上がる。ツリー構造は圏全体で大域的に定義されていて、対象に関して局所化して見ることになる。局所化する前は複階層的圏なのだ。

これは、射の名前の取り扱いを劇的に簡単にする。φがやせた圏の名前だとして、A.φ と φ&gt;B  のような書き方で、射を（存在すれば）特定できる。こりゃ&lt;em&gt;すごくいい&lt;/em&gt;。


</body>
</day>
<day date="2013-04-23" title="">
<body>
*1366699008*[関手データ][圏一般論][プログラム意味論]大域指標と大域制約、圏の中核

昨日書いた「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130422/1366589546&quot;&gt;複階層的圏と圏の大域的構造&lt;/a&gt;」の方法。これは使えそうだなー、と思う。

今まで指標というと、ソートに対して単一の対象を対応させて考えていた。昨日の方法だと、ソートはすべての対象を表現することになる。よって、このような指標を&lt;strong&gt;大域指標&lt;/strong&gt;と呼ぶことにする。制約条件も、個別の余代数や代数の制約というよりは圏全体が満たすべき条件になる。&lt;strong&gt;大域制約&lt;/strong&gt;だ。

大域的な代数系では、関手の貼り合わせも関係するし、ハイパーリンクの定式化で登場したインターフェースのパターン（メタインターフェース）も関係するだろう。インターフェースのパターンはツリー言語／グラフ言語（「言語」はベキの部分集合に同じ）だから、ツリーオートマトン／グラフオートマトンのランという概念がアンビエント圏への関手となる。言語＝ランの集合だから、言語は関手圏の部分圏なのかもしれない。

オートマトンのランという概念は実用性が高い。始状態からランさせることが関手の構成になるからだ。ランを &lt;i&gt;J&lt;/i&gt;→&lt;i&gt;C&lt;/i&gt; のような関手と捉えるとき、I∈|&lt;i&gt;J&lt;/i&gt;| を定めて、Iの像を始状態と考える。&lt;i&gt;J&lt;/i&gt;の対象としてのIは&lt;strong&gt;中核対象&lt;/strong&gt;（nexus object）と呼ぶことにする。理想的な場合は中核上で定義された部分関手から関手全体が定まる。

*1366703349*[気付いた][関手データ]データマイグレーション関手は普通に使える！

スピヴァックのデータマイグレーション関手は、スキーマ発展に関して使おうと思っていたが、そんなたいそうなレベルではなくて、ものすごく普通に使える。「ものすごく普通」って日本語はドウナノ？だが、まー、とにかく多様に多用できるのだ（って、駄洒落）。

あるサイトのある時点のデータ状態は、なんらかのスキーマ&lt;i&gt;S&lt;/i&gt;上の適当な圏&lt;i&gt;C&lt;/i&gt;へのインスタンスと見てよい。グラフTとグラフ写像 x:T→&lt;i&gt;T&lt;/i&gt; を考える。このようなxを&lt;strong&gt;抽出子&lt;/strong&gt;（エクストラクター）と呼ぶことにする。抽出子は関手とみてもよいので、関手圏 [T, &lt;i&gt;S&lt;/i&gt;] を抽出子と変換の圏と考えることができる。インスタンスFは、[T, &lt;i&gt;S&lt;/i&gt;]→[T,&lt;i&gt;C&lt;/i&gt;] を誘導する。これは抽出子ごとにT上のモデルを対応させる。

抽出子は問い合わせ式であり、抽出子xによりT上に引き戻したFは問い合わせの結果となる。問い合わせ結果はテンプレートのコンテキストとなる。コンテキスト上の代数的操作として多項式関手を考えることができ、これはFSスケッチ（finite sumスケッチ＝任意の有限錐と直和余錐を持つスケッチ）でも表現可能だ。

多項式関手、スケッチ、問い合わせ式などが関手モデルで統一的に説明できそうだ。これに複階層的圏の手法を組み合わせれば、コンテンツ状態の一部から転送コンテナ（HTMLは典型的な転送コンテナ）を作り出す方法が柔軟に記述できるだろう。

*1366703953*[関手データ][圏一般論]derivatorの定義域の公理

Diag圏というらしい。人によってはDiagなんて考えないで&lt;b&gt;Cat&lt;/b&gt;をいきなり使ってしまうようだが。

+ 有限順序集合を圏とみたものはDiagの対象である。
+ Diagは有限和とプルバックで閉じている。（FSスケッチと同じ定義）
+ XがDiagの対象ならX&lt;sup&gt;op&lt;/sup&gt;もDiagに入る。
+ p:X→Y がグロタンディークファイブレーションで、YがDiagに入り、すべてのファイバーがDiagに入るなら、XもDiagに入る。

要するに普通の構成が出来るってことだ。最後の条件は置換公理と似てる。

prederivatorとは、上の公理を満たすDiagから&lt;b&gt;CAT&lt;/b&gt;への反変の厳密2-関手。Diagも&lt;b&gt;CAT&lt;/b&gt;も2-圏とみなしている。

- cf : http://ncatlab.org/nlab/show/Grothendieck+fibration

&lt;b&gt;[追記]&lt;/b&gt;Xの任意の点（対象）に対してオーバー圏とアンダー圏が作れるも公理に入っていた。 &lt;b&gt;[/追記]&lt;/b&gt;

</body>
</day>
<day date="2013-04-26" title="">
<body>
*1366952132*[関手データ][プログラム意味論]derivatorのメモ

- http://www.math.ru.nl/~mgroth/preprints/groth_seattle.pdf

これはGrothのポスターのような資料だが、4upでA4一枚に印刷できる。だが、字が小さい！読むと目が疲れる、シンドイ。

&lt;i&gt;C&lt;/i&gt; = (&lt;i&gt;C&lt;/i&gt;, W) が圏と弱同値射のクラスとして、これだけのセッティングで抽象ホモトピー論（abstract homotopy theory）ができる。細かいことをしたかったらキレン・モデル圏を使うが、Ho(&lt;i&gt;C&lt;/i&gt;) := W&lt;sup&gt;-1&lt;/sup&gt;&lt;i&gt;C&lt;/i&gt; でホモトピー圏が定義できる（ただし、「ホモトピー圏」という用語は多義でゆらぎあり、注意）。

Ho(&lt;i&gt;C&lt;/i&gt;)が構造が貧弱で使いにくいので、三角圏構造を与えたりするが、三角圏も色々と欠点がある。特に三角圏&lt;i&gt;T&lt;/i&gt;に対して、図式の圏（関手圏） [J, &lt;i&gt;T&lt;/i&gt;] が三角圏ではない。

そこで、derivatorだが、起源はアーベル圏&lt;i&gt;A&lt;/i&gt;に対して &lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;&lt;sub&gt;&lt;i&gt;A&lt;/i&gt;&lt;/sub&gt; := D([J, &lt;i&gt;A&lt;/i&gt;]) で定義される、&lt;b&gt;Cat&lt;/b&gt;→&lt;b&gt;CAT&lt;/b&gt; な関手。

- [J, &lt;i&gt;A&lt;/i&gt;] は関手圏だが、これもアーベル圏になる。
- D(-) はアーベル圏から導来圏を作る関手（導来関手とは呼ばないので注意！）。
- &lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;(J) は三角圏となる（することができる）ことが多い。
- &lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;(&lt;b&gt;1&lt;/b&gt;) でD(&lt;i&gt;A&lt;/i&gt;)を再現できる。
- D(&lt;i&gt;A&lt;/i&gt;)から&lt;i&gt;A&lt;/i&gt;を再現できるなら、&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;(&lt;b&gt;1&lt;/b&gt;)から&lt;i&gt;A&lt;/i&gt;を再現できるかも。
- derivatorの圏を考えることができて、それは“アーベル圏の圏”の代理となる。

&lt;b&gt;[追記]&lt;/b&gt;「D(&lt;i&gt;A&lt;/i&gt;)から&lt;i&gt;A&lt;/i&gt;を再現できるなら、&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;(&lt;b&gt;1&lt;/b&gt;)から&lt;i&gt;A&lt;/i&gt;を再現できるかも。」って、自分で書いておいて早速に意味がわからなくなった、後でまた調べよう。&lt;b&gt;[/追記]&lt;/b&gt;

*1366956720*[関手データ][圏一般論][気付いた]データマイグレーション関手の解釈

スピヴァック理論スゲーッ、とずっと言い続けているが、簡単な命題に簡単な具体例を入れると、ソフトウェア的にはけっこうな発見だったり、が毎日続いている。

本編に書いたderivatorの道具立てと用語で考えるとして、スキーマ射uに伴う前層の引き戻し（逆像 inverse image）関手はバックワード（逆方向）データマイグレーション関手だが、その左随伴はホモロジカル順像関手、右随伴はコホモロジカル順像関手と呼ぶ。なんで(コ)ホモロジカルなんだ？ って話はあるが、ともかくも、

- 左フォーワード（順方向）データマイグレーション関手＝ホモロジカル順像関手＝ホモトピー余極限関手
- 右フォーワード（順方向）データマイグレーション関手＝コホモロジカル順像関手＝ホモトピー極限関手

となる。これらの言葉があながち無関係でもないことを見るには、Xを任意のスキーマとして、&lt;b&gt;1&lt;/b&gt;を自明なスキーマとする。このとき、u = !&lt;sub&gt;X&lt;/sub&gt;:X→&lt;b&gt;1&lt;/b&gt; が存在するが、このuに関して、引き戻しと左前送り、右前送りを考える。

引き戻しは、定数値をX全体に広げることで、基本データ型をすべてテーブルにコピーすること。個々のテーブルに依存しない普遍的なデータを、データベースワイドで考えることになる。

右前送りは、一般のデータベースを単なる1個の集合にすることだが、これは、F:X→&lt;b&gt;Set&lt;/b&gt; という関手の極限を取ることと同じになる。Xのすべてのテーブルのジョインを作ることになる。別な解釈としては、データベースをX上のデータバンドル（データファイブレーション）と見て、セクションの空間を考える。このセクションはファイバーごとにテンデンバラバラじゃなくて、全体が接続（Xの射による平行移動）に対して一貫している。Xを空間とみたときの連続なセクションだが、位相は入ってないのでコヒーレントなセクションと呼ぼう。すると、右前送り Πu の像は、コヒーレントなセクション全体の集合となる。

セクションとしてコヒーレントでないものは意味がないので、単にセクションと言えばコヒーレントだとする。すると、Πu は大域セクションの集合となる。Γ(X, F） とも書いて、X上のF係数のセクション集合と呼ぶ。大域セクションの集合は、X上の0次のF係数コホモロジーを与える。それでコホモロジカルとなる。なるほど。

Πu = Γ(X, F) は、ある時点でのデータベース状態（スナップショット）を単一テーブルとしてダンプすることになる。これを単一テーブルとみして無邪気に変更すると滅茶苦茶になるので原則イミュータブルだが、アーカイブには使える。運用はできないが情報欠損はない。

一方の左前送りΣuだが、これは情報が欠損する。かなり潰れる。Πuの双対なので、F:X→&lt;b&gt;Set&lt;/b&gt;の余極限になるが、別な見方として状態遷移グラフで考えると、ナビゲーション同値による商集合となる。ナビゲーション同値とは、ナビゲーション（リンク）で移れる状態は同値とみなす同値関係。これで同値類を作ると、だいたいは連結成分の集合となる。あーなるほど、0次のホモロジーが出てきた。

左前送りは、直和以外では関連する情報群を潰してしまうので使えないだろう。リンクが同値関係とみなせるときに、冗長性を排除するためには使えるかもしれない。データベースで主に使うのは、右前送り＝コホモロジカル順像＝ホモトピー極限＝ジョイン構成 ということになる。

一番簡単な例を考えるだけでも、大域セクションと連結成分が出てくる。これは0次だが、高次のコホモロジーはどうやって作るのだろう？ 単体的手法／ナーブといったところか？ いずれにしても、今までとはリアリティが違う気がする。確かな具体例がある。


</body>
</day>
<day date="2013-04-30" title="">
<body>
*1367282054*[関手データ][Caty][気付いた]RPCの関手モデル的定式化

記法を今までと変える。

+ スキーマは斜体ではなくて普通書体とする。
+ スキーマの対象は小文字 a, b, cなど。
+ スキーマの射は小文字 u, v, wなど。
+ スキーマ射はf, g など。
+ モデルインスタンスはF, Gなど。
+ ドクトリンは斜体 &lt;i&gt;D&lt;/i&gt; など。

S, Tがスキーマ、FがT上のインスタンス、HがS上のインスタンスのとき、RPC機構とは、Fの射（F(u):F(a)→F(b) in &lt;b&gt;Partial&lt;/b&gt;）をHの射にマップする方法。具体的には、

+ 関手（接続） f:S→T
+ 自然変換 γ::H⇒f&lt;sup&gt;*&lt;/sup&gt;F 、f&lt;sup&gt;*&lt;/sup&gt;F は、fによるFの引き戻し。
+ Hのすべての成分は可逆である。

γの成分は、γ&lt;sub&gt;a&lt;/sub&gt;:H(a)→F(f(a)) となる。これが可逆だから、(γ&lt;sub&gt;a&lt;/sub&gt;)&lt;sup&gt;-1&lt;/sup&gt;:F(f(a))→H(a) が&lt;b&gt;Partial&lt;/b&gt;で存在する。γの成分ごとに逆にした自然変換をリターンまたはレスポンスと呼ぶ。

Fの射 F(w):F(c)→F(d) がSから起動されることはは、c=f(a), d=f(b), w=f(u) に対する γ&lt;sub&gt;a&lt;/sub&gt;;F(f(u)) : H(a)→F(f(b)) で記述される、γ&lt;sub&gt;a&lt;/sub&gt;;F(f(u)) をuに対するリモート実装（の起動）と呼ぶ。リモート実装にリターン（レスポンス）を加えると、リモート呼び出しが完了する。

γがアンビエント圏&lt;b&gt;Partial&lt;/b&gt;において可逆なのがミソで、γが引数転送、γ&lt;sup&gt;-1&lt;/sup&gt;が戻り値転送（逆の転送）となっている。

リモート呼び出しとローカル呼び出しを一緒に考えるには、スキーマSとTの直和（または余極限、融合和）を考えて、そこで議論する。ローカルとリモート（とその中間とか）を混ぜるには、圏の貼り合わせとそれにともなう関手（前層）の貼り合わせを使うことになるだろう。


</body>
</day>
<day date="2013-05-03" title="">
<body>
*1367555643*[関手データ][Caty][気付いた][プログラム意味論][圏一般論]色気に惑わされる

&lt;img src=&quot;http://www.chimaira.org/img3/star-costar.gif&quot;&gt; 

これは象徴的、あるいは比喩的な絵だ。以下の話も比喩的だ。

ノードと辺（矢印）からなるグラフを色塗りしている。各ノードは別な色にして、辺も塗り分けてある。二通りのルールで、辺を彩色している。どのようなルールかは簡単に推測できるだろう。

色の選び方や塗り分け方には好みやセンスがある。美意識だの政治的な信条とかもあるかもしれない（赤は広島カープの色だとか共産主義だとかナントカいろいろ）。

さて、このグラフにサイクルがあるかないか？ あるなら独立なサイクルは何個か？ という問題を考えるとしよう。そのとき色は関係するだろうか？ 関係するわけない！ グラフのトポロジー（形状）しか関係しない。

しかし、なまじ色があると、色を根拠に議論したがる。色は無関係、それどころか色は邪魔、色の議論から得られるものは何もなく不毛だったとしても色から離れられない。人間の理解や認識というものはそんなところがある。

色を忘れて形状だけに注目することは、色の捨象、抽象化となる。その抽象化ができない。「色を忘れろ」「彩色ルールなんてどうでもいい」と達観できないのだ。そして、形状に関する基本的で重要な事実を理解も認識もできない。色気に惑わされて目が曇る。偏見と予断のカタマリだ。もちろん、他人事ではない、自分のことだ。

*1367562359*[関手データ][Caty][気付いた][プログラム意味論][圏一般論]型定義も制約述語もインスタンスも問い合わせも区別する必然性はない

ということを、またしてもスピヴァックから教わった。

最近、gv:draw-data というコマンドを作ったのだが、データ（XJSONインスタンス）をグラフに描く。例えば、[@userNum 123, , &quot;hello&quot;] だと、次のようになる。

&lt;img src=&quot;http://www.chimaira.org/img3/draw-data-1.gif&quot; &gt;

もっと簡単な {&quot;x&quot;:2, &quot;y&quot;:2} だと次。

&lt;img src=&quot;http://www.chimaira.org/img3/draw-data-2.gif&quot; &gt;

gv:draw-dataは常にツリーを描くが、この例では値2が共有されているので、辺xと辺yを合流させてもいいい。

&lt;img src=&quot;http://www.chimaira.org/img3/draw-data-3.gif&quot; &gt;

普通はインスタンスをツリーに描くが、合流があってもいいので、一般的にはインスタンスのグラフはDAGとなる。ただし、インスタンスはサイクルは含まない（スキーマのグラフはサイクリックになる、再帰的定義があるから）。

さて、次の図は、{&quot;x&quot;: integer, &quot;y&quot;: integer} というスキーマの図だ。

&lt;img src=&quot;http://www.chimaira.org/img3/draw-data-4.gif&quot; &gt;

I = {&quot;x&quot;:2, &quot;y&quot;:3} 、S = {&quot;x&quot;: integer, &quot;y&quot;: integer} と置く。インスタンスIをスキーマSでバリデーションするとは、まずは次のような関手を作ることになる。

&lt;img src=&quot;http://www.chimaira.org/img3/validation-functor.gif&quot; &gt;

破線矢印が関手による対応。スキーマ側の末端ノードはintegerだが、これを関手の逆方向に沿って引き戻す。すると、インスタンスの2つの末端ノードにintegerが（逆方向に）運ばれて乗っかる。もともとあった定数 2, 3 と 型 integer を比較すると、

+ 2∈integer 
+ 3∈integer 

となるので、バリデーションが成功する。インスタンスをスキーマとみなせば、末端には整数のシングルトン型があるので、

+ {2}⊆integer 
+ {3}⊆integer 

という包含性による比較となる。

インスタンスもスキーマもグラフ＝圏であり、バリデーションとは関手の構成と末端ノードでの比較であることがわかる（グロタンディーク構成した圏における射の存在）。問い合わせの議論も同様に関手の構成として理解できる。

&quot;It's all categories and functors!&quot; とはこういうことだ。


</body>
</day>
<day date="2013-05-06" title="">
<body>
*1367819006*[関手データ][indexed/fibred圏]derivatorのopen/closeイマージョン

derivatorといえば、モーリッツ・コーツ（Moritz Groth）の学位論文が詳しい。216ページでとても読みきれんが。

- http://www.math.uni-bonn.de/people/grk1150/DISS/dissertation-groth.pdf

コーツは、ジョルジュ・マルツィニョティス（Georges Maltsiniotis）と親交はあるようだが、マルツィニョティスがコーツの先生ではないようだ。先生はケラー（Bernhard Keller）らしい。

それはそうと、イマージョン（immersion）の定義：

Let u: &lt;i&gt;J&lt;/i&gt; → &lt;i&gt;K&lt;/i&gt; be a fully-faithful functor which is injective on objects.

+  The functor u is called a &lt;b&gt;closed immersion&lt;/b&gt; or a &lt;b&gt;cosieve&lt;/b&gt; if whenever we have a morphism u(j) → k in &lt;i&gt;K&lt;/i&gt; then k lies in the image of u.
+ The functor u is called an &lt;b&gt;open immersion&lt;/b&gt; or a &lt;b&gt;sieve&lt;/b&gt; if whenever we have a morphism k → u(j) in &lt;i&gt;K&lt;/i&gt; then k lies in the image of u.

fully-faithful functor which is injective on objects であることから、&lt;i&gt;J&lt;/i&gt;⊆&lt;i&gt;K&lt;/i&gt; と思ってよい。それで、

+ j∈|&lt;i&gt;J&lt;/i&gt;| で j→k という&lt;i&gt;K&lt;/i&gt;の射があるなら k∈|&lt;i&gt;J&lt;/i&gt;| が成立するとき、&lt;i&gt;J&lt;/i&gt;は閉イマージョン。
+ j∈|&lt;i&gt;J&lt;/i&gt;| で k→j という&lt;i&gt;K&lt;/i&gt;の射があるなら k∈|&lt;i&gt;J&lt;/i&gt;| が成立するとき、&lt;i&gt;J&lt;/i&gt;は開イマージョン。

閉イマージョンは、外に向かう逃走に関して閉じている部分グラフ、開イマージョンは、内に向かう侵入に関して閉じている部分グラフ、という感じ。これは、圏の充満部分圏を作っていくときの方法になりそう。連結成分に近い。

*1367825275*[関手データ][Caty][indexed/fibred圏]スピヴァックのクエリーの圏と切断集合関手

Fがデータベースインスタンスで、Fのスキーマを S = Sch(F) とする。スピヴァックのリフティングクエリーの理論だと、Fのクエリーの圏 Query(F) が定義できる。Query(F) の対象は、四角形の図式だが、その一辺は、p:R→S という形をしている。このpがプローブだ。クエリーにそのプローブを対応させる関手をψとすると、ψ:Query(F)→&lt;b&gt;Sch&lt;/b&gt;/S となる。

クエリーに対して、そのlifting solutionsの集合を対応させると関手になる。この関手は Γ(Q, F) と書く。Qはクエリーで、Fがインスタンス。Γ(-, F)は、Query(F)→&lt;b&gt;Set&lt;/b&gt; という関手だが、Γ(-, -) を定義したい。Γ(-, -) の定義域は、Query(F) のFを動かした圏となるだろう。

一般に、Γ(X, F) は、空間X上の層Fの大域切断の集合を表すが、いま定義したΓとアナロジーがある。クエリーやプローブに対するΓは、空間上の大域切断を射に関して相対化したようなものだ。高次のコホモロジーはわからんが、少なくとも0次のコホモロジーは定義できる。それがΓだ。圏の表示の制約に不等式を使うと、1次のコホモロジーが出てくるんじゃないかと期待している。

*1367827369*[関手データ][Caty][indexed/fibred圏]スピヴァックのアナロジー

感じとしては、こうだと思う。

スキーマは空間だと思う。だから、ドクトリンは空間と連続写像の圏。空間Xの点の集合は|X|、Xは繋がり具合いも含めた情報を持つのでまー位相空間。ただし、今のところ1-複体のようなもので、高次セルは持たない（いずれは高次化したい）。1次元チェーンからの写像の空間は定義できるので、パス空間やループ空間は定義できる。柱体も定義できるからホモトピーもできる。

スキーマX上のデータベースインスタンスFは、空間X上の層Fと考える。グロタンディーク構成で、π:F→X というファイブレーションを考える。このファイブレーションの大域切断が大域レコード。Fは被覆空間、あるいは平行移動が定義されたバンドルのようなもので、一点（つまりテーブル）での切断が与えられるとパス持ち上げで大域切断＝大域レコードを構成できる。一点レコード（普通の意味の物理レコード）と大域レコードはあまり変わらない。

Γ(X, F)は大域切断＝大域レコードの集合。これは、derivatorのコホモロジー順像関手（＝逆像関手の右随伴）による構成と同じ。双対に、ホモロジー順像関手の定義できて、それは逆像関手の左随伴。

空間Xを埋め込みや連続写像で相対化するのが、プローブやクエリーの話。空間Xに対するΓ(X, F)をクエリーQに対するΓ(Q, F)に拡張できる。一方で、Γ(X, -) という拡張はあまり議論されてない。更新の話もコッチに関係しそう。




</body>
</day>
<day date="2013-05-07" title="">
<body>
*1367888494*[関手データ][indexed/fibred圏]derivatorの定義

ドゥニシャルル・シザンスキー（Denis-Charles Cisinski）とアムノン・ネーマン（Amnon Neeman）の &quot;Additivity for derivator K-theory&quot; http://www.math.univ-toulouse.fr/~dcisinsk/addkth.pdf より：

+ Der-1 (Non-triviality axiom) &lt;b&gt;D&lt;/b&gt;(Σ(i∈I | X&lt;sub&gt;i&lt;/sub&gt;)) → Π(i∈I | &lt;b&gt;D&lt;/b&gt;(X&lt;sub&gt;i&lt;/sub&gt;)) は圏同値。
+ Der-2 (Conservativity axiom) xがXの点（対象）として、族 (x&lt;sup&gt;*&lt;/sup&gt;:&lt;b&gt;D&lt;/b&gt;(X)→&lt;b&gt;D&lt;/b&gt;(&lt;b&gt;1&lt;/b&gt;) | x∈|X|) は保存的（conservative）である。保存的とは、φ:F→G が&lt;b&gt;D&lt;/b&gt;(X) の射のとき、すべてのxに対するx&lt;sup&gt;*&lt;/sup&gt;(φ) が&lt;b&gt;D&lt;/b&gt;(&lt;b&gt;1&lt;/b&gt;) 内で同型なら、φは&lt;b&gt;D&lt;/b&gt;(X)内で同型であること。同型の判定が点ごとにできる。
+ Der-3 (Direct image axiom) ドクトリン（定義域）の射に対して、標準逆像関手（引き戻し）の左随伴と右随伴がある。
+ Der-4 (Base change axiom) [記述が面倒なので後にする]
+ Der-5 (Essential surjectivity axiom) I = {0←1} という圏として、標準的に定義される &lt;b&gt;D&lt;/b&gt;(I×X) → [I&lt;sup&gt;op&lt;/sup&gt;, &lt;b&gt;D&lt;/b&gt;(X)] という関手は充満で本質的に上射である。

&lt;b&gt;D&lt;/b&gt;の定義域は、圏の圏だが、空間の圏だと思ってよい。よって、&lt;b&gt;D&lt;/b&gt;(-) は、空間の反変不変量を圏として与えるものだ。&lt;b&gt;D&lt;/b&gt;(-) は&lt;i&gt;X&lt;/i&gt;上の層の圏のようなもの。ただし、通常は&lt;b&gt;D&lt;/b&gt;自体が空間を隠し持っていて、空間の性質を反映している。

Der-1 は指数法則、Der-2は点ごとの局所性、Der-3は0次のホモロジー／コホモロジーがあること、Der-4が基底変換公式、Der-5は柱体とパス空間の関係を与える。層のコホモロジーと柱体を使ったホモトピーの一番基本的な部分は出来ることを保証している。そんな感じだ。

*1367917150*[関手データ][気付いた][形式言語理論]形式言語も関手圏？

アレ、アレレ？

形式言語理論の言語は、列とかツリーとかグラフとかの集合だけど、結局は関手圏なのではないか。GとHがグラフのとき、GからHへのグラフ準同型の集合は、準同型を関手とみなしてよいので、関手圏 [G, H] となる。形式言語理論のたいていの問題は、この圏の部分圏を調べることに帰着するような気がする。

</body>
</day>
<day date="2013-05-11" title="">
<body>
*1368242195*[関手データ][Caty]アプリケーション・モデルインスタンスの基本

関手モデルでは、圏Sがデータベーススキーマで、関手 F:S→&lt;b&gt;Partial&lt;/b&gt; がデータベースインスタンス。関手指向アプリケーションプランニングでは、圏Sがアプリケーションスキーマで、関手F:S→&lt;b&gt;Partial&lt;/b&gt; がアプリケーションインスタンス。って何も差がない。そう、差がない、&lt;em&gt;区別する必要性がない&lt;/em&gt;。

関手 F:S→&lt;b&gt;Partial&lt;/b&gt; と G:T→&lt;b&gt;Partial&lt;/b&gt; が2つのアプリケーションインスタンスのとき、関手 a:S→T （スキーマ射）と、自然変換 α::F⇒σ&lt;sup&gt;*&lt;/sup&gt;G の組（a, α）がアプリケーションインスタンスの準同型となる。このアプリケーション準同型は、ドクトリン（スキーマの集まり）&lt;b&gt;&lt;i&gt;D&lt;/i&gt;&lt;/b&gt; 上のモデル [-, &lt;b&gt;Partial&lt;/b&gt;] をインデックス付き圏とみて、グロタンディーク構成した平坦化圏（ファイバリング全圏）の射となる。

アプリケーションスキーマSに対して、S→&lt;b&gt;1&lt;/b&gt;に対する右随伴（derivatorならコホモロジー順像関手）Π! を作って、S上のアプリケーションインスタンスFを前送りすると、Fのコヒーレントな大域セクションの集合ができるが、これはコヒーレントな（正しい）挙動の全体。具体的シナリオ（シナリオのインスタンス）の全体と言ってもよい。



</body>
</day>
<day date="2013-05-14" title="">
<body>
*1368491010*[人物][メモ]W.D. Dwyer

Dwyerは「ドワイヤー」に近い。→ http://ja.forvo.com/search/Dwyer/

William G. Dwyer http://www3.nd.edu/~wgd/ さんのことです。



</body>
</day>
<day date="2013-05-17" title="">
<body>
*1368764744*[関手データ]コーツのderivator論文

モーリッツ・コーツ（Moritz Groth）のderivator論文を読んでいる。

- http://www.math.uni-bonn.de/~mgroth/groth_derivators.pdf

これは60ページくらい。216ページの学位論文よりはマシ。

- http://www.math.uni-bonn.de/people/grk1150/DISS/dissertation-groth.pdf

コーツはderivatorの定義域は一律に&lt;b&gt;Cat&lt;/b&gt;にしていて、図式の圏は定義してない。derivatorの定義も簡略化している感じだ。

+ 2つの圏に対する指数法則。任意個数の圏に関するものではない。
+ 同型が点ごとの局所的同型で判断できること。(f:X→Y) in J が同型 ⇔ ∀j∈|J|.[(fj:Xj→Yj) in D(e) が同型]
+ 引き戻し関手（逆像関手）の左・右随伴が存在すること。
+ ホモトピー極限／余極限が同型を導くこと。

最後の条件はよく分かってない。が、他の人の条件に比べると簡素化されている感じだ。


</body>
</day>
<day date="2013-05-18" title="">
<body>
*1368852069*[子供]明日の

14時から。

火曜は午前中かな。
</body>
</day>
<day date="2013-05-22" title="">
<body>
*1369189265*[メモ]ひょっとして？

ネストトランザクションのオペレータキューイングと単体的な手法を使った力学系の(コ)ホモロジーって同じか？ どっちにしろ圏のナーブになる感じだ。

スピヴァックの単体的データベースとも関係しそう。


</body>
</day>
<day date="2013-05-23" title="">
<body>
*1369289822*[圏一般論][プログラム意味論]両モナドとアイレンベルク／ムーア構成とメイヤー加群

両モナド (F, G, β) があるとき、アイレンベルク／ムーア構成により両代数の圏が構成できる。アイレンベルク／ムーア両代数の圏の対象がメイヤー加群のはずだ。たぶん。

</body>
</day>
<day date="2013-05-28" title="">
<body>
*1369715639*[モナド][モノイド圏]テンソル強度の一般論

必要だと思ってことが、「強度対、両側強度、可換性」に書いてあった。

- [http://d.hatena.ne.jp/m-hiyama-memo/20100607/1275867334:title]

可換強度、強モナドについては、

- [http://d.hatena.ne.jp/m-hiyama-memo/20060505/1146781124:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060123/1137978147:title]

次も読み返すとよい。

- [http://d.hatena.ne.jp/m-hiyama-memo/20060408/1144475364:title]

*1369716891*[関手データ][Caty]アプリケーション領域

ドクトリン、アンビエント圏、derivatorにより構成される構造をアプリケーション領域と呼ぶことにする。基本的なことは、次に書いてある。

- [http://d.hatena.ne.jp/m-hiyama/20130401/1364808727:title]

&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;⊆&lt;b&gt;Cat&lt;/b&gt; と、圏&lt;i&gt;Pres&lt;/i&gt;があって、&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;(Cat(P), &lt;i&gt;C&lt;/i&gt;) ＝ &lt;i&gt;Pres&lt;/i&gt;(P, Uncat(&lt;i&gt;C&lt;/i&gt;)) という双対 Cat -| Uncat がある状況で考える。Der:&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;→&lt;b&gt;CAT&lt;/b&gt;がderivatorで、アンビエント圏&lt;i&gt;A&lt;/i&gt;は、Der(e)（eは単位圏）として与えられる。


</body>
</day>
<day date="2013-05-30" title="">
<body>
*1369879315*[圏一般論][プログラム意味論]モノイドの加群のナーブ

A = (A, M, *) がモノイドM上の加群（AがM-集合）だとする。|C| = A、Mor(C) = A×M、dom(a, m) = a, cod(a, m) = a*m, (a, m);(b, n) = (a, mn) として圏Cができる。この圏のナーブを作ると、ナーブは単体的集合だが、これが加群Aのトランザクションの記述に役立つ。

モノイド上の加群ではなくて圏上の加群（圏の表現）のときはどうなるのだろう？ トランザクション、排他制御、並列実行とどう関係するのか？


</body>
</day>
<day date="2013-05-31" title="">
<body>
*1369977759*[圏一般論][モナド][プログラム意味論]フレイド圏と豊穣圏

&quot;Generic Models for Computational Effect&quot;でJohn Powerが指摘してること： J:&lt;i&gt;C&lt;/i&gt;&lt;sub&gt;0&lt;/sub&gt;→&lt;i&gt;C&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt; という関手で、identity-on-object なものは、[&lt;b&gt;→&lt;/b&gt;, &lt;b&gt;Set&lt;/b&gt;]-豊穣圏の対象とみなせる。&lt;b&gt;→&lt;/b&gt; は、 {・→・} という圏。

&lt;i&gt;V&lt;/i&gt;-豊穣圏を作るには、&lt;i&gt;V&lt;/i&gt;が対称モノイド圏である必要があるが、[&lt;b&gt;→&lt;/b&gt;, &lt;b&gt;Set&lt;/b&gt;]のモノイド積はpointwiseな直積で与えられる。

</body>
</day>
<day date="2013-06-01" title="">
<body>
*1370062503*[Caty]ハイパーオブジェクト

&lt;b&gt;ハイパーオブジェクト&lt;/b&gt;とは、しみじみ&lt;em&gt;難しい&lt;/em&gt;概念だ。オブジェクト指向パラダイムでも関数型パラダイムでも、うまく説明できない。むしろ、そういった既存のパラダイムは理解や解釈の邪魔になるだけだ。

ハイパーオブジェクトはリモートメソッド（ハイパーリンク）を持ったオブジェクトなのは事実だ。だが：

+ ハイパーオブジェクトはクラスを持たない。（クラス概念がない。）
+ ハイパーオブジェクトはコンストラクタを持たない。
+ それにも関わらず、ハイパーオブジェクトはインターフェイス（指標）を持つ。
+ ハイパーオブジェクトはデータオブジェクトでもあり、複雑なデータ構造を持つ（かも知れない）。
+ ハイパーオブジェクトは状態点（状態空間の点＝オカレンス）となる。

この奇妙な状況を理解するには、初期のC++のような原初的なオブジェクト指向もどきに遡って考えるとよいように思う。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/ho-old-style-object.gif&quot; &gt;

C++、というより、Cで自作オブジェクト指向もどきシステムを作ることを考える。インスタンスオブジェクトとは構造体に過ぎない。クラスの物理的実体は、関数ポインタを並べた配列だ。インスタンスはどれかのクラスに所属するので、構造体には「クラス＝ディスパッチテーブル」の先頭アドレス（ポインタ）を入れておく -- classと書いたフィールド（構造体メンバー）がそれだ。

データメンバー以外に、構造体にはメソッドが含まれる。メソッドは、ディスパッチテーブルのインデックス（先頭アドレスからのオフセット）で表すとする。例えば、番号2はdoThis関数を（間接的に）示す。番号3は、doThat関数を示す。

メソッド呼び出しは、構造体objのclassフィールドが指すディスパッチテーブル（のアドレス）obj.classに「メソッドの番号＝配列インデックス＝オフセット値」でアクセスする。obj.class[obj.doThis] でdoThisが得られる。thisを第一引数に入れるなら obj.class[obj.doThis](obj, arg) のようになる。

Webサイトは、原初的オブジェクト指向に少し似ている。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/ho-page-as-object.gif&quot; &gt;

クライアント側にロードされたページにはデータとリモートメソッドが含まれる。出自となったサイトへのポインタ（URL）はページ自体に埋め込まれてなくてもブラウザは把握している（originのリンク）。ページに含まれるアンカーが相対URL（パス）なら、サイト内での位置を示していることになる。サイトは、一種のディスパッチテーブルと見なせなくもない。ディスパッチのキーは番号ではなくてパス名となる。

WebアプリケーションをRPCベースのハイパーオブジェクトで考えた場合、実際はもっと複雑になる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/ho-hyper-object.gif&quot; &gt;

まず、ハイパーオブジェクトは複雑な階層的なデータ構造となり得る。リモートメソッド（へのトリガー）は、複雑なデータ構造のなかに&lt;em&gt;散りばめられている&lt;/em&gt;。単にフラットにメソッドが並んでいるわけではない。foo, bar, bazがトリガーだとして、それらが指す先が単一のサイトとは限らない。多重継承やマルチメソッドとも違って、ひとつのハイパーオブジェクトに色々な場所に散在するリモートメソッドを&lt;em&gt;混ぜていい&lt;/em&gt;のだ。

オブジェクト指向では、「データ構造」と「手続きモジュール」と「メモリアロケーションと初期化」を、クラス概念によってまとめ上げた。ハイパーオブジェクトでは、これらが&lt;em&gt;まとまってない&lt;/em&gt;。バランバランだ。データ構造と手続きモジュールの構造は無関係で、異なる編成がなされている。明白なコンストラクタはなく、すべてのメソッドがコンストラクタと言えなくもない。

このような状況でも、RPC、IDL、IDLコンパイラの概念は相変わらず有効だ。他の解釈や手法は破綻していて適用できない。

*1370064751*[圏一般論][モナド]圏の線形化／代数化、加群概念、豊饒圏の強モナド拡張

&lt;i&gt;C&lt;/i&gt;が圏のとき、&lt;i&gt;C&lt;/i&gt;を多元環や多元半環と関連付ける方法。Kは体とする。

- &lt;i&gt;C&lt;/i&gt;のK-線形化とは、ホムセット&lt;i&gt;C&lt;/i&gt;(A, B)から自由Kベクトル空間を作って、圏の結合も双線形にする。すると、K-ベクトル空間で豊饒化された圏が出来る。
- &lt;i&gt;C&lt;/i&gt;のK-圏多元環（圏環、圏代数）とは、Mor(&lt;i&gt;C&lt;/i&gt;）から自由Kベクトル空間を作って、（結合できないときは0にして）圏の結合を掛け算として導入する。K-多元環ができる。
- ピーター・セリンガーのND(&lt;i&gt;C&lt;/i&gt;)。ホムセット&lt;i&gt;C&lt;/i&gt;(A, B)のベキ集合を作って、&lt;i&gt;D&lt;/i&gt;(A, B) = Pow(&lt;i&gt;C&lt;/i&gt;(A, B)) として圏を作る。
- &lt;i&gt;C&lt;/i&gt;の圏半多元環。Pow(Mor(&lt;i&gt;C&lt;/i&gt;)) に圏の結合から掛け算を入れる。足し算は集合の合併。アルファベットΣからの言語代数と似ている。

K-線形化とセリンガーのND構成は、&lt;i&gt;V&lt;/i&gt;-豊穣圏の強モナド拡張として定式化できる。&lt;i&gt;V&lt;/i&gt;がモノイド圏で、Fが&lt;i&gt;V&lt;/i&gt;上の強モナドとする。

&lt;i&gt;C&lt;/i&gt;が&lt;i&gt;V&lt;/i&gt;-豊穣圏で、&lt;i&gt;C&lt;/i&gt;(A, B) = X, &lt;i&gt;C&lt;/i&gt;(B, C) = Y, &lt;i&gt;C&lt;/i&gt;(B, C) = Y として、c:X×Y→Z を結合射とする。Fが強モナドのとき、

- F(X)×F(Y) → F(F(X)×Y) → F(F(X×Y)) → F(X×Y) - F(m)→F(Z)

として、c':F(X)×F(Y)→F(Z) が定義できる。&lt;i&gt;D&lt;/i&gt;(A, B) := F(&lt;i&gt;C&lt;/i&gt;(A, B)) として定義した&lt;i&gt;D&lt;/i&gt;に&lt;i&gt;V&lt;/i&gt;-豊穣圏の構造が入る。クライスリ圏やアイレンベルク／ムーア圏とどう関係する？

それと、圏&lt;i&gt;C&lt;/i&gt;に対して、[&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;Set&lt;/b&gt;]、[&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;Ab&lt;/b&gt;]、[&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;CMon&lt;/b&gt;]、[&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;CMonZ&lt;/b&gt;]、[&lt;i&gt;C&lt;/i&gt;, &lt;b&gt;IdemCMon&lt;/b&gt;] などを調べる問題がある。&lt;b&gt;CMon&lt;/b&gt;は可換モノイド、&lt;b&gt;CMonZ&lt;/b&gt;は零付き可換モノイド、&lt;b&gt;IdemCMon&lt;/b&gt;はベキ等可換モノイドの圏。


</body>
</day>
<day date="2013-06-03" title="">
<body>
*1370213892*[圏一般論][モナド][復習]過去にこだわっていた概念

- circ-Kleisli： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=circ-Kleisli
- 作用乗法： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%BA%EE%CD%D1%BE%E8%CB%A1
- 両モナド： http://d.hatena.ne.jp/m-hiyama-memo/searchdiary?word=%CE%BE%A5%E2%A5%CA%A5%C9

*1370215825*[プログラム意味論][高次圏論][リンク]ホモトピーを使った計算モデル

- STATE SPACES AND DIPATHS UP TO DIHOMOTOPY ：&lt;br&gt; http://people.math.aau.dk/~raussen/GETCO/D02/hha.pdf , http://www.intlpress.com/HHA/v5/n2/a9/v5n2a9.pdf (絵付き)
- Simulations as Homotopies ：&lt;br&gt; http://www.math.uwo.ca/~kworytki/getco2.pdf 
- Simplicial models for concurrency ：&lt;br&gt; http://arxiv.org/abs/1011.6599
- A model category for the homotopy theory of concurrency ：&lt;br&gt; http://arxiv.org/abs/math/0308054
- Homotopy Theory of Labelled Symmetric Precubical Sets ：&lt;br&gt; http://arxiv.org/abs/1208.4494
- Types for Quantum Computing ：&lt;br&gt; http://homepages.ulb.ac.be/~rduncan/papers/rduncan-thesis.pdf



</body>
</day>
<day date="2013-06-11" title="">
<body>
*1370938924*[モナド][圏一般論]右カン拡張に関するラムダ計算と横閉な2-圏

右カン拡張を関手の指数とみなして、カン対応（Kan bijection）を中心にしてラムダ計算をする場合、その舞台となるのは、2-圏だろう。横結合を非対称テンソル積とみなす。テンソル積のオペランドが、dom/codを持つので、自由にテンソルできるわけではない。が、テンソル積の性質は持つ。

この非対称かつ部分的なテンソル積に対する閉構造（あるいは内部ホム）が問題となる。J, Gに対する&lt;sup&gt;J&lt;/sup&gt;G、または G/J と書ける右カン拡張が指数対象＝内部ホム対象となる。このような指数を持つ閉構造を持つ2-圏は、横閉（horizontally）な2-圏と言っていいだろう。

横閉は、「よこへい」と読む、横柄ではない。


</body>
</day>
<day date="2013-06-13" title="">
<body>
*1371110342*[モナド][お絵描き][リンク]Curienのストリング図

- Category theory: a programming language-oriented introduction 
- Pierre-Louis Curien 
- October 19, 2008 
- http://www.pps.univ-paris-diderot.fr/~mellies/mpri/mpri-ens/articles/curien-category-theory.pdf


- The Joy of String Diagrams
- Pierre-Louis Curien
- May 14, 2012
- http://hal.archives-ouvertes.fr/docs/00/69/71/15/PDF/csl-2008.pdf

*1371110439*[圏一般論][リンク]計算的な圏論 エンドの計算

- A Higher-Order Calculus for Categories
- Mario Ca'ccamo Glynn Winskel
- June, 2001
- ftp://ftp.daimi.au.dk/BRICS/RS/01/27/BRICS-RS-01-27.pdf

The Density Formula が載っている。

</body>
</day>
<day date="2013-06-15" title="">
<body>
*1371288619*[映画]『レポ』

『レポマン』て映画観たよな、確か。と思って、

- レポマン（Repo Man）http://ja.wikipedia.org/wiki/%E3%83%AC%E3%83%9D%E3%83%9E%E3%83%B3

なんか違うなー。これは観たことない。

ではこれ↓か？

- レポゼッション・メン（Repo Men）http://ja.wikipedia.org/wiki/%E3%83%AC%E3%83%9D%E3%82%BC%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%A1%E3%83%B3

違う。（原題では、Repo Man と Repo Men の違いしかない。）

僕が観た映画のなかでは、レポマンて言葉が頻繁に出てきていた。ウーン。？？。

渋谷シネライズのアーカイブからみつけた（http://www.cinemarise.com/theater/archives/films/2009005.html）。2009年3月21日-2009年4月24日の期間やっていた『REPO! レポ』（Repo! The Genetic Opera）だ。

- http://ja.wikipedia.org/wiki/REPO!_%E3%83%AC%E3%83%9D

お騒がせセレブ女優のパリス・ヒルトンと、イギリスのソプラノ歌手・サラ・ブライトマンが出ていた。そう、サラ・ブライトマン。今年、来日公演があるらしく、ポスターが出ていた。それを見て思い出したのだった。


</body>
</day>
<day date="2013-06-18" title="">
<body>
*1371512934*[圏一般論][計算]新DOTN

DOTNを新記法にして、次の規則を導入しようと思う。

- Eを自明な単位圏とする。|E| = {e}, Mor(E) = {e^}
- 対象a, 射f に対して、それの格上げを a~、f~ とする。
- 関手の結合と自然変換の横結合を * とする。
- 自然変換の縦結合を ; とする。

定義：

- e.a~ := a  :E→C
- e^.a~ := a^ :E→C
- e.f~ := f ::a~⇒b~ :E→C

次が成立する。

+ (a^)~ = (a~)^
+ (f;g)~ = f~;g~
+ (a.F)~ = a~*F
+ (f.F)~ = f~*F^

*1371540404*[圏一般論][計算]Cat上でのラムダ計算

&lt;b&gt;Set&lt;/b&gt;はデカルト閉圏でラムダ計算ができる。&lt;b&gt;Cat&lt;/b&gt;もデカルト閉圏だからラムダ計算ができる。だが、単なるデカルト閉圏じゃなくて、（厳密）2-圏だ。2セルである自然変換が計算の主役となる。2-圏におけるラムダ計算てのが必要だと思う。

</body>
</day>
<day date="2013-06-19" title="">
<body>
*1371602643*[圏一般論][計算][高次圏論][プログラム意味論]型付きラムダ計算の一般化

あとで本編に書く（たぶん）。

+ 高次元化（少なくとも2次元化）
+ 非対称化（関手結合をテンソル積とみなす）
+ 内部積（モノイド積）から作用積（テンソリング、余パワー）へ
+ 部分的な指数


</body>
</day>
<day date="2013-06-21" title="">
<body>
*1371784696*[圏一般論][プログラム意味論]Functors as Types

型の意味は関手で、項の意味は自然変換だと考える。型である関手の定義域は、「スキーマ、シェープ、指標」などと呼ばれる。型の定義域の全体はまた圏で、スキーマ圏、シェープ圏、指標圏などと呼ぶ。インスティチューションや導来子との類似性がある。

- 導来子の図式の圏 → スキーマ圏、シェープ圏、指標圏
- 導来子の値 → 指標に対するモデル圏
- 導来子の単位圏での値 → モデルのアンビエント圏

おそらく、総称（多相）の説明になるだろう。

</body>
</day>
<day date="2013-06-24" title="">
<body>
*1372033155*[高次圏論][プログラム意味論][Caty]Sets as Types と Functors as Types

Functors as Types については、[http://d.hatena.ne.jp/m-hiyama-memo/20130621/1371784696:title] に書いた。素朴な Sets as Types と、Functors as Types との関係はどうなるか？

- [http://d.hatena.ne.jp/m-hiyama/20130621/1371785971:title]

↑がヒントになる。集合→関手、関数→自然変換として埋め込む方法なんで、(Sets and Partial Functions)→(Functors and Nat. Transformations) という自然は対応を定義できる。

</body>
</day>
<day date="2013-06-25" title="">
<body>
*1372137287*[高次圏論][プログラム意味論][Caty][関手データ]Functors as Types とラムダ計算とカン拡張

Sをスキーマとか指標と呼ばれる圏（または圏の表示）として、型は関手圏 [S, &lt;i&gt;C&lt;/i&gt;] の対象となる。Sが含まれる圏の圏（ドクトリン）を&lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt;とする。

x:S→X in &lt;i&gt;&lt;b&gt;D&lt;/b&gt;&lt;/i&gt; が部分関手として、E:S→&lt;i&gt;C&lt;/i&gt; も部分関手（部分的に定義された、&lt;i&gt;C&lt;/i&gt;に値を取る意味）として、この状況自体を λx.E と表すことができる。別に R:X→&lt;i&gt;C&lt;/i&gt; があると、一種のカン拡張として (λx.E)・R を定義できる気がする。

*1372154749*[プログラム意味論][インスティチューション]圏論的な隠蔽指標と隠蔽代数

|&lt;i&gt;C&lt;/i&gt;| = V + H と直和分解されている圏が隠蔽指標。射を次のように呼ぶ。

|* dom(f) |* cod(f) |* fの呼び名 |
| H       | H       | transition |
| H       | V       | observer |
| V       | H       | constructor |
| V       | V       | calculation |

通常、calculationはないとする。M:&lt;i&gt;C&lt;/i&gt;→&lt;b&gt;Set&lt;/b&gt; が集合論的なモデル。Vの要素（対象）だけで定義されたモデルF:V→&lt;b&gt;Set&lt;/b&gt; を固定して、Fの拡張になるようなMを考える。そのようなMの全体は再び圏になる。この圏のついて調べるのが隠蔽指標と隠蔽代数の理論。


</body>
</day>
<day date="2013-06-29" title="">
<body>
*1372491521*[映画]『グランドマスター』と『SPIRIT』と、昔のカンフー映画

ふとしたことで、渋谷で『グランドマスター』を観た。ブルース・リー（1940～73年）にカンフーを教えた武術家、イップ・マン＝葉問（1893～1972年）の人生を描いた中国映画。史実に忠実とは思えないが、ともかくも実在のモデルがいる。葉問（イップ・マン）をトニー・レオン、宮若梅（ゴン・ルオメイ）なる強い女性をチャン・ツィイー というキャスト。監督・脚本・制作はウォン・カーウァイ（『ブロークン・アロー』のジョン・ウーと勘違いしていた）。

『イップ・マン 序章』って映画もあったらしい。

- http://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%83%E3%83%97%E3%83%BB%E3%83%9E%E3%83%B3_%E5%BA%8F%E7%AB%A0

映像が綺麗なのはまーそうなんだけど、ちょっと退屈した。もうちょっと娯楽的かと期待していたのだけど。伝記映画だから、人の一生と彼が生きた時代を描く感じ。理屈抜きのアクションが好きな僕にはちょっとなー。それと、いくつかの物語が並行で進むのだけど、ストーリーがスッキリしてなくて散漫冗長な印象、特に一線天（カミソリ）って人の話は余計じゃないのかな。

これを観て思い出したんは、香港アメリカ合作で中村獅童も出ていた『SPIRIT』(2006年)。

- http://ja.wikipedia.org/wiki/SPIRIT_%282006%E5%B9%B4%E3%81%AE%E6%98%A0%E7%94%BB%29

こっちもモデルがいて、フォ・ユァンジア（霍元甲）という、20世紀初頭に実在した中国の武術家。主演はジェット・リー。あんまり覚えてないが、アクション映画としてまーまー楽しめたような気がする。

ジェット・リーの映画では『HERO』と『エクスペンダブルズ』を観たかな。

- http://ja.wikipedia.org/wiki/HERO_%282002%E5%B9%B4%E3%81%AE%E6%98%A0%E7%94%BB%29
- http://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9A%E3%83%B3%E3%83%80%E3%83%96%E3%83%AB%E3%82%BA

それはそうと、なぜか『片腕ドラゴン』って香港映画も思い出したぞ。監督と主演はジミー・ウォング。日本公開が1972年か。随分と前だ、40年前だ。たぶん渋谷で観た。

『燃えよドラゴン』の悪役ヤン・スエ出演の『空手ヘラクレス』なんてのもあったな。ヤン・スエって、『燃えよドラゴン』では「ボロ」って役のキン肉マンです。アメリカではBoLo Yeungって名乗っているみたい。次の動画で、ブルース・リー、アンジェラ・マオなんかと一緒に出てます。

[http://www.youtube.com/watch?v=pB5N6QbwC2s:movie]

*1372492648*[映画][メモ]長男と観た映画

『踊る大捜査線 THE FINAL 新たなる希望』

- http://ja.wikipedia.org/wiki/%E8%B8%8A%E3%82%8B%E5%A4%A7%E6%8D%9C%E6%9F%BB%E7%B7%9A_THE_FINAL_%E6%96%B0%E3%81%9F%E3%81%AA%E3%82%8B%E5%B8%8C%E6%9C%9B

『猿の惑星：創世記（ジェネシス）』

- http://ja.wikipedia.org/wiki/%E7%8C%BF%E3%81%AE%E6%83%91%E6%98%9F:_%E5%89%B5%E4%B8%96%E8%A8%98

『ダイ・ハード/ラスト・デイ』

- http://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%83%BB%E3%83%8F%E3%83%BC%E3%83%89/%E3%83%A9%E3%82%B9%E3%83%88%E3%83%BB%E3%83%87%E3%82%A4

</body>
</day>
<day date="2013-07-08" title="">
<body>
*1373244665*[メモ][リンク][講座]JSON仕様と、Ajax

- JSONサイト： http://www.json.org/
- 構文の定義： http://tools.ietf.org/html/rfc4627
- ちなみにCSV： http://tools.ietf.org/html/rfc4180
- JSOView：https://addons.mozilla.org/ja/firefox/addon/jsonview/

- http://d.hatena.ne.jp/m-hiyama/20080728/1217205390   もう一度、ちゃんとJSON入門
- http://d.hatena.ne.jp/m-hiyama/20060327/1143418528   謝罪と訂正：JSONの構文を間違えていた


- http://d.hatena.ne.jp/m-hiyama/20100202/1265081108  BNF、EBNF、ABNF、まー正規表現だな


- http://d.hatena.ne.jp/m-hiyama/20121025/1351148120  最近のブラウザは、ネイティブJSONサポートがあるんだね


- http://d.hatena.ne.jp/m-hiyama/20090413/1239581682  JSONの可能性がグンと拡がるぞ！ JSONスキーマ



- http://d.hatena.ne.jp/m-hiyama/20080311/1205219856 とても素敵なデータ表現言語（やや難あり）


「とても素敵な」よりJSONデータの例：

&lt;pre class=&quot;code&quot;&gt;

{
 &quot;familyName&quot; : &quot;板東&quot;,
 &quot;givenName&quot; : &quot;トン吉&quot;,
 &quot;age&quot; : 27,
 &quot;sex&quot; : &quot;male&quot;,
 &quot;company&quot; :
  {
   &quot;name&quot; : &quot;(株)東西トラベル&quot;,
   &quot;url&quot; : &quot;http://www.example.jp/tozai-travel/&quot;
  },
 &quot;hobbies&quot; : [&quot;盆栽&quot;, &quot;釣り&quot;, &quot;版画&quot;]
}

&lt;/pre&gt;

- http://www.chimaira.org/misc/tonkichi.json
- http://b.hatena.ne.jp/entry/json/http://d.hatena.ne.jp/m-hiyama/
- 参考：http://developer.hatena.ne.jp/ja/documents/bookmark/apis/getinfo

&lt;pre class=&quot;code&quot;&gt;

var parsed = JSON.parse(
 '{&quot;familyName&quot; : &quot;板東&quot;, &quot;givenName&quot; : &quot;トン吉&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;,' +
 '&quot;company&quot; :  {&quot;name&quot; : &quot;(株)東西トラベル&quot;, &quot;url&quot; : &quot;http://www.example.jp/tozai-travel/&quot;},' +
 '&quot;hobbies&quot; : [&quot;盆栽&quot;, &quot;釣り&quot;, &quot;版画&quot;]}'
); 

var unparsed = JSON.stringify(parsed) ;

&lt;/pre&gt;


&lt;pre class=&quot;code&quot;&gt;

var parsed_2 = eval(
 '(alert(&quot;hello&quot;), {&quot;familyName&quot; :  &quot;板東&quot;, &quot;givenName&quot; : &quot;トン吉&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;,' +
 '&quot;company&quot; :  {&quot;name&quot; : &quot;(株)東西トラベル&quot;, &quot;url&quot; : &quot;http://www.example.jp/tozai-travel/&quot;},' +
 '&quot;hobbies&quot; : [&quot;盆栽&quot;, &quot;釣り&quot;, &quot;版画&quot;]})'
); 

var unparsed_2 = JSON.stringify(parsed_2) ;

&lt;/pre&gt;



*1373606801*[メモ][リンク][講座] 図形のアフィン変換ライブラリ

- http://d.hatena.ne.jp/m-hiyama/20090616/1245117533  アフィン変換なんて簡単だ
- http://d.hatena.ne.jp/m-hiyama/20090617/1245210412 アフィン幾何とアフィン変換の補足


- http://d.hatena.ne.jp/m-hiyama/20051017/1129510043  プログラマのためのJavaScript (11)：継承についてもう少し
- http://d.hatena.ne.jp/m-hiyama/20051018/1129605002   プログラマのためのJavaScript (号外)：こんな継承はどう？
- http://d.hatena.ne.jp/m-hiyama/20091204/1259889523   JavaScriptのクラスもどきで、getter/setter を使う

*1373606802*[メモ][リンク][講座] Lisp, LOGO, Prolog, Haskell etc. のリスト処理


*1373606803*[メモ][リンク][講座] LOGOのタートルグラフィックス


- http://d.hatena.ne.jp/m-hiyama/20090804/1249357682  モナドのサンプルに、JavaScriptで簡易タートル・グラフィックスとか作ってみた


*1373606804*[メモ][リンク][講座] JavaScriptのモジュールシステム

- http://d.hatena.ne.jp/m-hiyama/20120814/1344916537   JavaScriptで少数の大域的名前だけを定義したいとき
- http://d.hatena.ne.jp/m-hiyama/20120725/1343175517  大域名前空間を汚しまくっているJavaScriptライブラリを単一名前空間に押し込める方法

*1373606805*[メモ][リンク][講座] 逆ポーランド仮想マシン

- http://d.hatena.ne.jp/m-hiyama/20091125/1259117461  JavaScriptで仮想機械の勉強をしましょう

*1373606806*[メモ][リンク][講座] 簡単なプログラミング言語の構文処理

- http://d.hatena.ne.jp/m-hiyama/20060712/1152667443   あなたの「極小なプログラミング言語」は？
- http://d.hatena.ne.jp/m-hiyama/20091209/1260343463   JavaScriptで言語処理系の勉強をしましょう：構文解析準備編

*1373606807*[メモ][リンク][講座] JavaScriptで解約駆動プログラミング

- http://d.hatena.ne.jp/m-hiyama/20050927/1127790808  JS番外編：これって、アスペクト指向かぁ
- http://d.hatena.ne.jp/m-hiyama/20080718/1216370414  JavaScript用のアサーションを作ってみる
- http://d.hatena.ne.jp/m-hiyama/20120406/1333681648  ソフトウェアにとって大事なこと： 正しさが判断できること
- http://d.hatena.ne.jp/m-hiyama/20060403/1144025475  AspectJによる契約駆動開発 (準備＋蘊蓄編)
- http://d.hatena.ne.jp/m-hiyama/20130626/1372204714  メイヤー流の契約となんでもケーキ屋さん

*1373606808*[メモ][リンク][講座] グラフアルゴリズム

- http://d.hatena.ne.jp/m-hiyama/20121003/1349230179  有向グラフを表現するデータ形式について
- http://d.hatena.ne.jp/m-hiyama/20120412/1334193542  すごいグラフ処理ライブラリNetworkXの使い方


</body>
</day>
<day date="2013-07-12" title="">
<body>
*1373592646*[メモ][プログラム意味論]ライプニッツの同値性／等号

とか呼ぶことがある二項関係。モノの集合をU、性質の集合をPとする。

- x, y∈U に対して、x≡y ⇔ ∀p∈P.(p(x) = p(y))

以外にもこれは、メイヤーの原理とかマイヒル／ネロード型の定理で使われる。観測的、振る舞い的、実験的とか呼ばれる同一性の判定方法となっている。

「不可識別者同一の原理」と呼んだりするらしい。

</body>
</day>
<day date="2013-07-13" title="">
<body>
*1373691943*[メモ]時間

日曜、午後3時以降
木曜、午後4時以降


</body>
</day>
<day date="2013-07-16" title="">
<body>
*1373928949*[圏一般論][モナド]L修飾

L:&lt;i&gt;C&lt;/i&gt;→&lt;i&gt;C&lt;/i&gt; を自己関手として、&lt;i&gt;D&lt;/i&gt;(A, B) := &lt;i&gt;C&lt;/i&gt;(L(A), L(B)) として圏Dを定義する。これをLで修飾された（あるいはシフトされた）&lt;i&gt;C&lt;/i&gt;と考える。

自己関手と自然変換も同様にL修飾を考えて、結果的にモナドをL修飾する。

&lt;b&gt;[追記 date=&quot;翌日&quot;]&lt;/b&gt;ちょっと違うかも。&lt;b&gt;[/追記]&lt;/b&gt;

*1373933353*[圏一般論][プログラム意味論]フレイド圏の定義

ちゃんと定義（Cartesian effect categories are Freyd-categories より）

&gt;&gt;
A Freyd-category is an identityon-objects functor J : C → K where the category C has finite products, the category K is &lt;b&gt;symmetric premonoidal&lt;/b&gt; and the functor J is &lt;b&gt;strict symmetric premonoidal&lt;/b&gt;.
&lt;&lt;

圏Cに関する条件は弱くて単に有限積を持つだけ。通常は終対象も持つので、デカルト圏だと言ってよい。僕の目的では、デカルト半環圏の条件を付ける。Kは対称プレモノイド圏。

&gt;&gt;
A symmetric premonoidal category is a &lt;b&gt;binoidal category&lt;/b&gt; K together with an object I of K and &lt;b&gt;central&lt;/b&gt; natural isomorphisms [snip], subject to the usual coherence equations for symmetric monoidal categories
&lt;&lt;

対称プレモノイド圏はバイノイド圏に対称モノイド圏と同じ構造自然同型（一貫性条件）を入れたもの。[http://d.hatena.ne.jp/m-hiyama/20110106/1294276973:title]に書いてあある。


</body>
</day>
<day date="2013-07-18" title="">
<body>
*1374107282*[メモ] 時間

木曜、午後4時以降
</body>
</day>
<day date="2013-07-22" title="">
<body>
*1374453922*[メモ][講座][リンク]JSONとAjax

JSONは、基本的なスカラー型（null, boolean, number, stringの4種）データと、配列（リスト）、オブジェクト（ハッシュマップ）により構成される複合データだけをサポート。

&lt;h5&gt;ハイパーリンク&lt;/h5&gt;

ハイパーリンクはサポートできてない（しようとしたがうまくいってない）。

- http://d.hatena.ne.jp/m-hiyama/20100416/1271386224 JSONだってハイパーメディア -- JSONハイパースキーマ仕様をなんとかしたい  （$id と$refも使っている）
- http://tools.ietf.org/html/draft-zyp-json-schema-03#section-6 以前のハイパースキーマ仕様
- http://tools.ietf.org/html/draft-zyp-json-schema-04#section-4.2  最近

URI文字列の判定は、

+ 文字列の中身を見て推測する。
+ URI文字列を値とするプロパティ名を事前に約束する。

JSONViewは「文字列の中身を見て推測」している。約束としては、「&quot;$ref&quot; の値はURI」が多い。フラグメント識別子（HTMLのid属性）もない。が、約束としては、「&quot;$id&quot; の値はオブジェクトのID」とできなくもない。

&lt;h5&gt;Ajaxの一般的な話&lt;/h5&gt;

- http://d.hatena.ne.jp/m-hiyama/20121025/1351148120 最近のブラウザは、ネイティブJSONサポートがあるんだね

&lt;h5&gt;再帰処理&lt;/h5&gt;

ツリーの処理は再帰が定番。


</body>
</day>
<day date="2013-07-23" title="">
<body>
*1374551866*[メモ]本編用のエントリーでした

先ほどの更新は間違い：

- http://d.hatena.ne.jp/m-hiyama/20130723/1374551426

*1374569203*[メモ][Caty]apartness関係

三値論理を入れたので、分離していることを示すapartnessが重要になる。

- http://en.wikipedia.org/wiki/Apartness_relation
</body>
</day>
<day date="2013-07-24" title="">
<body>
*1374629804*[メモ][リンク]ハランの非加法幾何とかプループリントとか

シャイ・ハラン（Shai M. J. Haran）の非加法幾何の論文、

- http://arxiv.org/abs/0911.3522

Oliver Lorscheid のブループリントは、

- http://ncatlab.org/nlab/show/blueprint

から参照をたどる。


</body>
</day>
<day date="2013-08-01" title="">
<body>
*1375349177*[メモ][用語法] 展開レコード、サブレコード

Mongoでサブドキュメントって言葉を使っているから、サブレコードを使ってもいい気がする。

一方で、リンクをたどって展開したレコードも出てくる。これはそのまんま、リンク展開レコード、あるいは単に展開レコードかな。

集合としてのサブセットもあるので、ややこしいが、「展開レコードのサブレコードのサブセット」が重要な概念となる。重要なので、ビューコレクションとか名前を付けたが、どうもピンと来ない。
</body>
</day>
<day date="2013-08-05" title="">
<body>
*1375662966*[メモ][リンク][講座] JavaScriptのクラスもどきと、図形のアフィン変換ライブラリ

継承の話：

- http://d.hatena.ne.jp/m-hiyama/archive?word=%D3%AE%C6%FD%CE%E0 「哺乳類」で検索

動物→哺乳類→犬 のような例え話は嫌い。「関係ない」というか誤解する事のほうが多いだろう。説明によく使っている例は図形。

- http://d.hatena.ne.jp/m-hiyama/archive?word=javascript+function+Point 「javascript+function+Point」で検索

図形（平面内に限る）は

+ 点
+ 線分
+ 三角形
+ 四角形
+ 円

など。点は0次元の図形、線分は1次元の図形、n角形の周囲だけなら1次元、中身を考えると2次元。例えば、面積は2次元の図形でしか意味ない。

- 参考：http://d.hatena.ne.jp/m-hiyama/20100316/1268726449  長方形は長くない

図形はさまざまな観点から分類と階層化ができる。どの分類法が正しいということはない。目的によって考えればよい。図形に対する操作、あるいは図形の自発的行動も色々ある。操作を受動的に設計するか／能動的（自発的）に設計するかも目的によって考えればよい。図形の分類と操作・動作を、いろいろと考えてみよう。

分類と操作・動作を、プログラムにするときに便利な発想がクラスと継承：

- http://d.hatena.ne.jp/m-hiyama/20051017/1129510043  プログラマのためのJavaScript (11)：継承についてもう少し
- http://d.hatena.ne.jp/m-hiyama/20051018/1129605002   プログラマのためのJavaScript (号外)：こんな継承はどう？
- http://d.hatena.ne.jp/m-hiyama/20091204/1259889523   JavaScriptのクラスもどきで、getter/setter を使う

図形を扱うのだから、図形っぽい話もしよう。

- http://d.hatena.ne.jp/m-hiyama/20090616/1245117533  アフィン変換なんて簡単だ
- http://d.hatena.ne.jp/m-hiyama/20090617/1245210412 アフィン幾何とアフィン変換の補足
- http://d.hatena.ne.jp/m-hiyama/20090804/1249357682  モナドのサンプルに、JavaScriptで簡易タートル・グラフィックスとか作ってみた

アフィン変換は：

+ 点を点に移す。
+ 直線（線分）を直線に移す。
+ 二本直線（線分）の交点を交点に移す。（交わりの関係を保存する）

アフィン変換は6個の数値が表現できるが、それはなぜだろう？

おまけ：知っていると便利なJavaScriptのこと：

- http://d.hatena.ne.jp/m-hiyama/20121116/1353030826 JavaScriptの関数には、やたらに何でも突っ込める
- http://d.hatena.ne.jp/m-hiyama/20111206/1323158875 JavaScriptでnewが不要なコンストラクタ

*1375656767*[メモ]Emacs JavaScript インデントレベル

&gt;|lisp|
(setq js-indent-level 2)
||&lt;

*1375656930*[メモ][用語法][Caty]ナビゲーションのときのウォーカーの近傍

ウォーカーの視野（eyesight）と呼んではどうか？

</body>
</day>
<day date="2013-08-07" title="">
<body>
*1375856182*[用語法][論理]メタ記号を色々

- M |= A
- A1, ..., An |⇒ B
- |≡ (A1, ..., An → B)
- τ |≡ (A1, ..., An → B)

読み方は、

- model M satisfies formula A
- A1, ..., An entailes B
- (A1, ..., An → B) is valid
- τ ensures that (A1, ..., An → B) is valid


</body>
</day>
<day date="2013-08-12" title="">
<body>
*1376267995*[メモ][講座] JavaScriptのクラスもどきと、図形のアフィン変換ライブラリ (2)

関数

&gt;|javascript|
/* -*- coding: utf-8 -*- */
/* kk.js */

function f1(n) {
  return (n + 1);
}

var f2 = function(n) {
  return (n + 1);
}

function f3(n) {
  this.result = n + 1;
  return this.result;
}

function f4(n) {
  this.result = n + 1;
}

function f5(n) {
  this.result = n + 1;
  return this.result;
}
f5.message = &quot;hello&quot;;

var obj1 = {}
obj1.a = 100;
obj1.f = function (n) { return (n + 1);};

var obj2 = {
  a : 200,
  f : function (n) { return (n + 2);}
};

||&lt;

&gt;|html|
&lt;html&gt;
&lt;head&gt;
 &lt;script src=&quot;test.js&quot; &gt;&lt;/script&gt;
&lt;/head&gt;

&lt;h1&gt;Test&lt;/h1&gt;
||&lt;

+ オブジェクトって？
+ オブジェクトとObjectは違う？
+ 配列もオブジェクトなの？
+ 「Objectオブジェクト」
+ 関数はオブジェクト（要注意）である。
+ 関数は引数を渡して実行できる。「呼び出し」という。
+ 普通の丸括弧を使う以外の呼び出し方
+ 関数は値を返す（undefinedを返すことを含む）。
+ 関数はオブジェクトのセットアップにも使える。
+ 関数でセットアップされたオブジェクトには痕跡が残る。
+ 関数はオブジェクトだからプロパティを持てる。
+ オブジェクトのプロパティ値を関数にできる。
+ 関数のprototypeプロパティは特別な意味を持つ。
+ Objectオブジェクトの__proto__プロパティは特別な意味を持つ。
+ 「プロトタイプ」という言葉、分類のクラスとはまったく異なる発想。典型例、親玉、依頼先、便利屋、ヒーロー、…。
+ this, prototype, __proto__ ですべて説明が付く。

</body>
</day>
<day date="2013-08-16" title="">
<body>
*1376642779*[メモ][子供] 予定

- 日曜は午後2時から
- 金曜は午後6時から

</body>
</day>
<day date="2013-08-17" title="">
<body>
*1376706163*[プログラム意味論][モナド]Global State（ストレージ）を特徴付ける7つの公理

http://hal.inria.fr/docs/00/70/20/65/PDF/segal.pdf より、

- 1. annihilation lookup - update:&lt;br&gt; reading the value of a location &lt;i&gt;loc&lt;/i&gt; and then updating the location &lt;i&gt;loc&lt;/i&gt; with the obtained value is just like doing nothing.
- 2. interaction lookup - lookup:&lt;br&gt; reading twice the same location &lt;i&gt;loc&lt;/i&gt; is the same as reading it once.
- 3. interaction update - update:&lt;br&gt; storing a value &lt;i&gt;val&lt;/i&gt; and then a value &lt;i&gt;val'&lt;/i&gt; at the same location &lt;i&gt;loc&lt;/i&gt; is just like storing the value &lt;i&gt;val'&lt;/i&gt; in the location.
- 4. interaction update - lookup:&lt;br&gt; when one stores a value &lt;i&gt;val&lt;/i&gt; in a location &lt;i&gt;loc&lt;/i&gt; and then reads the location &lt;i&gt;loc&lt;/i&gt;, one gets the value &lt;i&gt;val&lt;/i&gt;.
- 5. commutation lookup - lookup:&lt;br&gt; The order of reading two different locations &lt;i&gt;loc&lt;/i&gt; and &lt;i&gt;loc'&lt;/i&gt; does not matter.
- 6. commutation update - update: the order of storing in two different locations &lt;i&gt;loc&lt;/i&gt; and &lt;i&gt;loc'&lt;/i&gt; does not matter.
- 7. commutation update - lookup:&lt;br&gt; the order of storing in a location &lt;i&gt;loc&lt;/i&gt; and reading in a location &lt;i&gt;loc'&lt;/i&gt; does not matter.

Gordon Plotkin and John Power &quot;Notions of Computation Determine Monads&quot; （http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf）の7ページに等式的にまとめてある。が、この等式系は分かりにくいと思う。

&lt;img src=&quot;http://www.chimaira.org/img3/global-state-7axioms.gif&quot; &gt;


</body>
</day>
<day date="2013-08-19" title="">
<body>
*1376873013*[メモ][講座] JavaScriptのクラスもどきと、図形のアフィン変換ライブラリ (3)

次がわかればJavaScriptは理解できたことになる。

+ すべてが Subject-Property-Value 構造。変数、名前、プロパティ、インデックスなどが事実上同じであることを理解する。同じメカニズムに異なる用語を使うのは習慣に過ぎない。
+ 「オブジェクト、Object、object」などの言葉を、日常的意味、狭い意味、広い意味など、多様な解釈と使い分けがあることを理解し慣れる。「目的語」とか「対象物」とか「メモリブロック」という意味も忘れない。
+ 関数の複数の「呼び出し方」を理解する。
+ 関数内のthisが何を意味するか理解する。

あとはデータの分類：

|*常識的な分類  |* 例         |* typeof |* constructor.name |
|未定義         |undefined    | | | 
|ヌル           |null         | | | 
|真偽値         |true, false  | | |
|数値           |3.14, -1, 100| | | 
|文字列         |&quot;&quot;, &quot;hello&quot;  | | | 
|配列           |[-1, &quot;hello&quot;]| | | 
|オブジェクト   |{x:1, y:2}   | | | 
|関数           |function(){return;} | | | 

ラッパーオブジェクト（boxing）があるのが落とし穴か。

*1376871870*[メモ][その他プログラミング]ブラウザのドラッグ・アンド・ドロップ

http://d.hatena.ne.jp/m-hiyama/20130815/1376530706 に書いたようにドラッグ・アンド・ドロップを調べた。

+ firefoxは、ドロップハンドラ内のエラーでリダイレクトする。stopPropagation() してもダメなようだ。
+ Chromeは、デフォルトのドラッグイメージ（ゴーストイメージ）の描画位置が間違っている。
+ ドロップゾーンの判定は、どのプラウザもイマイチ。
+ IEでは、setDragImageメソッドが存在しない。したがって、ドラッグイメージの設定は無理。
+ IEでは、dragendイベントが来ない。後始末が出来ない。
+ dropとdragendの順番はブラウザごとに異なる。firefoxとchromeでは逆だった。


</body>
</day>
<day date="2013-08-20" title="">
<body>
*1376963534*[Caty][気付いた][説明]letマップ付きグラフ

式を名前に束縛することは極めてよくある。&lt;strong&gt;letマップ&lt;/strong&gt;とは、この束縛機構を表すデータ構造だとする。ラムダ計算のlet式に相当する。再帰（自己言及）向けのletをletrecとして分けることが多いが、ここでは、letのなかにletrecも含めて考える。

letマップのひとつの項目を&lt;strong&gt;letエントリー&lt;/strong&gt;と呼ぶことにする。letエントリーは、名前とその名前が指す対象物へのポインターリンクから構成される。

例題として次のスキーマを考える。

&lt;pre class=&quot;code&quot;&gt;
type Friend = {
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: bestFriendChain
};

type bestFriendChain = {
  &quot;name&quot;: string,
  &quot;bestFriend&quot;: bestFriendChain,
}?;
&lt;/pre&gt;

名前 Friend, bestFriendChain に対応する2つのletエントリーも含めて図示すると次のようになる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/letMappedGraph-1.gif&quot; &gt;

ピンクと赤が、名前による参照に関わるのノードと辺。ピンク楕円のノードは、名前参照ノードで、構文的には「単なる名前の出現」に相当する。出現した名前は、いったんletエントリーを経由して他の式を参照することになる。letマップは&lt;strong&gt;名前空間&lt;/strong&gt;と言っても同じである。

&lt;h4&gt;インライン・ネーミング&lt;/h4&gt;

fetch問い合わせ式では、より簡略な表現ができる。

&lt;pre class=&quot;code&quot;&gt;
{
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: @= bestFriendChain {
      &quot;name&quot;: string,
      &quot;bestFriend&quot;: bestFriendChain,
   }?
}
&lt;/pre&gt;

bestFriendChainという名前による参照があるが、参照される先の名前をインラインで定義できる。インライン・ネーミングの構文が @= で、直後の式に名前を与える。この例では、次の部分式に名前bestFriendChainが与えられている。

&lt;pre class=&quot;code&quot;&gt;
{
   &quot;name&quot;: string,
   &quot;bestFriend&quot;: bestFriendChain,
}?
&lt;/pre&gt;

この部分式内に名前参照bestFriendChainが出てくるので、結果的に再帰構造となる。

インライン・ネーミングの場合も、暗黙のletマップを備えたグラフ構造なのだと考えることができる。式全体には名前が与えられてないが、空白の（あるいはデフォルトの）letエントリーが式全体を指しているとする。以下の図となる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/letMappedGraph-2.gif&quot; &gt;

&lt;h4&gt;サイクリックグラフ&lt;/h4&gt;

空白のletエントリーは省略して、letマップの枠線も省略すると次の図になる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/letMappedGraph-3.gif&quot; &gt;

bestFriendChainという名前により2つのノードが結ばれている。bestFriendChainという名前は、ローカルに定義したもので、別の名前、例えば foo にリネームしてもかまわない。論理の限量子束縛変数や、ラムダ計算のラムダ変数と同じく、名前の綴りはなんでもよくて自由にリネーム（アルファ変換）できる。なので、名前の綴りも無視してしまうと次の図になる。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/letMappedGraph-4.gif&quot; &gt;

図のピンクと赤の部分は、自分自身に戻る辺＝サイクルを表現するための方便に過ぎない。テキスト構文でサイクル（やシェアリング）を表現するためには、中間に名前を挟む必要がある。しかし、この一時的な名前は単なる便宜的な手段なので、図では不要なのだ。

結局、letマップと名前参照ノードを使って表現したかったスキーマのデータ構造は、次のようなサイクリックグラフだったわけだ。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img3/letMappedGraph-5.gif&quot; &gt;

テキスト構文として書き下す都合で、名前はどうしても必要だ。名前のメカニズムがletマップ（名前の定義）と参照ノード（名前の出現）だが、図＝グラフとしては不要であり、中間的・一時的な名前を排除すると事情が単純になる。

&lt;hr&gt;
以下にグラフ描画のソース。ほとんどコピペで作ったが全部載せておく。

====

&gt;||
/* -*- coding: utf-8 -*- */
/* letMapppedGraph-1.caty */

[

  [
     gv:node --shape=box --style=filled --fillcolor=pink --label=&quot;bestFriendChain&quot; e_bestFriendChain,
     gv:node --shape=box --style=filled --fillcolor=pink --label=&quot;Friend&quot; e_Friend,

  ] | gv:cluster  --label=&quot;let map&quot; letMap,

  gv:edge --color=red e_bestFriendChain bestFriendChain,
  gv:edge --color=red e_Friend Friend,

/*

type Friend = {
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: bestFriendChain
};
*/

  gv:node --label=&quot;{}&quot; Friend,
  gv:node --label=&quot;string&quot; Friend_name,
  gv:node --label=&quot;string?&quot; Friend_email,
  gv:node --label=&quot;string?&quot; Friend_addr,
  gv:node --style=filled --fillcolor=pink --label=&quot;→&quot; Friend_bestFriend,

  gv:edge --label=&quot;name&quot;  Friend Friend_name,
  gv:edge --label=&quot;email&quot;  Friend Friend_email,
  gv:edge --label=&quot;addr&quot;  Friend Friend_addr,
  gv:edge --label=&quot;bestFriend&quot;  Friend Friend_bestFriend,

  gv:edge --color=red Friend_bestFriend e_bestFriendChain,

/*

type bestFriendChain = {
  &quot;name&quot;: string,
  &quot;bestFriend&quot;: bestFriendChain,
}?;

*/
  gv:node --label=&quot;{}?&quot; bestFriendChain,
  gv:node --label=&quot;string&quot; bestFriendChain_name,
  gv:node --style=filled --fillcolor=pink --label=&quot;→&quot; bestFriendChain_bestFriend,

  gv:edge --label=&quot;name&quot;  bestFriendChain bestFriendChain_name,
  gv:edge --label=&quot;bestFriend&quot;  bestFriendChain bestFriendChain_bestFriend,
  gv:edge --color=red bestFriendChain_bestFriend e_bestFriendChain,


] | gv:graph letMappedGraph-1
||&lt;


&gt;||
/* -*- coding: utf-8 -*- */
/* letMappedGraph-2.caty */

[

  [
     gv:node --shape=box --style=filled --fillcolor=pink --label=&quot;bestFriendChain&quot; e_bestFriendChain,
     gv:node --shape=box --style=filled --fillcolor=pink --label=&quot; &quot; e_Friend,

  ] | gv:cluster  --label=&quot;let map&quot; letMap,

  gv:edge --color=red e_bestFriendChain bestFriendChain,
  gv:edge --color=red e_Friend Friend,

/*

{
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: @= bestFriendChain {
      &quot;name&quot;: string,
      &quot;bestFriend&quot;: bestFriendChain,
   }?
}

*/

  gv:node --label=&quot;{}&quot; Friend,
  gv:node --label=&quot;string&quot; Friend_name,
  gv:node --label=&quot;string?&quot; Friend_email,
  gv:node --label=&quot;string?&quot; Friend_addr,

  gv:edge --label=&quot;name&quot;  Friend Friend_name,
  gv:edge --label=&quot;email&quot;  Friend Friend_email,
  gv:edge --label=&quot;addr&quot;  Friend Friend_addr,
  gv:edge --label=&quot;bestFriend&quot;  Friend bestFriendChain,


  gv:node --label=&quot;{}?&quot; bestFriendChain,
  gv:node --label=&quot;string&quot; bestFriendChain_name,
  gv:node --style=filled --fillcolor=pink --label=&quot;→&quot; bestFriendChain_bestFriend,

  gv:edge --label=&quot;name&quot;  bestFriendChain bestFriendChain_name,
  gv:edge --label=&quot;bestFriend&quot;  bestFriendChain bestFriendChain_bestFriend,
  gv:edge --color=red bestFriendChain_bestFriend e_bestFriendChain,


] | gv:graph letMappedGraph-2
||&lt;


&gt;||
/* -*- coding: utf-8 -*- */
/* letMappedGraph-3.caty */

[

  gv:node --shape=box --style=filled --fillcolor=pink --label=&quot;bestFriendChain&quot; e_bestFriendChain,
  gv:edge --color=red e_bestFriendChain bestFriendChain,

/*

{
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: @= bestFriendChain {
      &quot;name&quot;: string,
      &quot;bestFriend&quot;: bestFriendChain,
   }?
}

*/

  gv:node --label=&quot;{}&quot; Friend,
  gv:node --label=&quot;string&quot; Friend_name,
  gv:node --label=&quot;string?&quot; Friend_email,
  gv:node --label=&quot;string?&quot; Friend_addr,

  gv:edge --label=&quot;name&quot;  Friend Friend_name,
  gv:edge --label=&quot;email&quot;  Friend Friend_email,
  gv:edge --label=&quot;addr&quot;  Friend Friend_addr,
  gv:edge --label=&quot;bestFriend&quot;  Friend bestFriendChain,


  gv:node --label=&quot;{}?&quot; bestFriendChain,
  gv:node --label=&quot;string&quot; bestFriendChain_name,
  gv:node --style=filled --fillcolor=pink --label=&quot;→&quot; bestFriendChain_bestFriend,

  gv:edge --label=&quot;name&quot;  bestFriendChain bestFriendChain_name,
  gv:edge --label=&quot;bestFriend&quot;  bestFriendChain bestFriendChain_bestFriend,
  gv:edge --color=red bestFriendChain_bestFriend e_bestFriendChain,


] | gv:graph letMappedGraph-3
||&lt;


&gt;||
/* -*- coding: utf-8 -*- */
/* letMappedGraph-4.caty */

[
  gv:node --shape=point --color=pink e_bestFriendChain,
  gv:edge --color=red e_bestFriendChain bestFriendChain,

/*

{
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: @= bestFriendChain {
      &quot;name&quot;: string,
      &quot;bestFriend&quot;: bestFriendChain,
   }?
}

*/

  gv:node --label=&quot;{}&quot; Friend,
  gv:node --label=&quot;string&quot; Friend_name,
  gv:node --label=&quot;string?&quot; Friend_email,
  gv:node --label=&quot;string?&quot; Friend_addr,

  gv:edge --label=&quot;name&quot;  Friend Friend_name,
  gv:edge --label=&quot;email&quot;  Friend Friend_email,
  gv:edge --label=&quot;addr&quot;  Friend Friend_addr,
  gv:edge --label=&quot;bestFriend&quot;  Friend bestFriendChain,


  gv:node --label=&quot;{}?&quot; bestFriendChain,
  gv:node --label=&quot;string&quot; bestFriendChain_name,
  gv:node --style=filled --fillcolor=pink --label=&quot;→&quot; bestFriendChain_bestFriend,

  gv:edge --label=&quot;name&quot;  bestFriendChain bestFriendChain_name,
  gv:edge --label=&quot;bestFriend&quot;  bestFriendChain bestFriendChain_bestFriend,
  gv:edge --color=red bestFriendChain_bestFriend e_bestFriendChain,


] | gv:graph letMappedGraph-4
||&lt;


&gt;||
/* -*- coding: utf-8 -*- */
/* letMappedGraph-5.caty */

[

/*

{
  &quot;name&quot;:  string,
  &quot;email&quot;: string?,
  &quot;addr&quot; : string?,
  &quot;bestFriend&quot;: @= bestFriendChain {
      &quot;name&quot;: string,
      &quot;bestFriend&quot;: bestFriendChain,
   }?
}

*/

  gv:node --label=&quot;{}&quot; Friend,
  gv:node --label=&quot;string&quot; Friend_name,
  gv:node --label=&quot;string?&quot; Friend_email,
  gv:node --label=&quot;string?&quot; Friend_addr,

  gv:edge --label=&quot;name&quot;  Friend Friend_name,
  gv:edge --label=&quot;email&quot;  Friend Friend_email,
  gv:edge --label=&quot;addr&quot;  Friend Friend_addr,
  gv:edge --label=&quot;bestFriend&quot;  Friend bestFriendChain,

  gv:node --label=&quot;{}?&quot; bestFriendChain,
  gv:node --label=&quot;string&quot; bestFriendChain_name,

  gv:edge --label=&quot;name&quot;  bestFriendChain bestFriendChain_name,
  gv:edge --label=&quot;bestFriend&quot;  bestFriendChain bestFriendChain,


] | gv:graph letMappedGraph-5
||&lt;

*1376978882*[メモ]ベキッチさん

クロアチアの女子テニス選手に Donna Vekic さんがいる。カタカナ書きだと「ドンナ ・ベキッチ」。不動点のBekicも音はたぶんベキッチだろう。

</body>
</day>
<day date="2013-08-21" title="">
<body>
*1377044007*[Caty][説明][形式言語理論]名前付けと名前参照によるサイクルとシェアリングの表現

「&lt;a href=&quot;http://d.hatena.ne.jp/m-hiyama-memo/20130820/1376963534&quot;&gt;letマップ付きグラフ&lt;/a&gt;」で、letマップ付きグラフは、結局はサイクルとシェアリングを持つグラフの表現だ、と述べた。逆に、サイクル／シェアリングを持つグラフから出発して、letマップ付きグラフを作ってみる。これにより、ふだん我々が使っている名前機構（名前空間、名前空間のエントリー、名前による参照）の構造と使い方が明確になる。

まず、例題のグラフ。ここで出てくるラベル、A, B, ... は、ノードの「名前」&lt;em&gt;ではなくて&lt;/em&gt;、説明用の識別ラベルである。名前に関係するノードは（後で）ピンクで示す。

&lt;img  src=&quot;http://www.chimaira.org/img3/cyclic-graph-1.gif&quot; &gt;

任意の連結グラフに&lt;a target=&quot;_blank&quot; href=&quot;http://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%91%E3%83%8B%E3%83%B3%E3%82%B0%E6%9C%A8&quot;&gt;スパニングツリー&lt;/a&gt;が存在する。スパニングツリーを選んで、スパニングツリー以外の辺を赤点線で示す。

&lt;img  src=&quot;http://www.chimaira.org/img3/cyclic-graph-1a.gif&quot; &gt;

赤点線の辺を、名前付け（naming）と名前参照（reference）に置き換える。ピンク四角が名前付けノード、ピンク楕円が名前参照ノードである。

&lt;img  src=&quot;http://www.chimaira.org/img3/cyclic-graph-2.gif&quot; &gt;

名前付けノードをデータツリーの一部に埋め込んでしまうのがインラインネーミング方式で、fetchで使われている@=構文がコレ。

&lt;img  src=&quot;http://www.chimaira.org/img3/cyclic-graph-3.gif&quot; &gt;

名前付けノードをデータツリーとは別な場所において、データツリーには名前参照ノードだけにするとletマップ方式となる。letマップ＝名前空間なので、通常の名前空間を使う方式はコレになる。

&lt;img  src=&quot;http://www.chimaira.org/img3/cyclic-graph-4.gif&quot; &gt;

テキスト構文として直接表現できる構造がツリーに限られるので、名前付けと名前参照を使ってサイクリックシェアリンググラフを表すことになる。名前の使用は原理的に避けられない手段ではあるが、間接的で冗長になるし、リンク用に導入する名前は恣意的となる。恣意的だからアルファ変換が可能だが、アルファ変換（系統的リネーム）の手間はバカにならない。

&lt;br&gt;
絵のソース。

====

&gt;||
/* cyclic-graph-1 */

[

  gv:node  A,
  gv:node  B,
  gv:node  C,
  gv:node  X,
  gv:node  Y,

  gv:edge --label=p A X,
  gv:edge --label=q A B,
  gv:edge --label=r X C,
  gv:edge --label=s B C,
  gv:edge --label=t C B,
  gv:edge --label=u C Y,
  gv:edge --label=v Y A,

] | gv:graph cyclic-graph-1
||&lt;

&gt;||
/* cyclic-graph-1a */

[

  gv:node  A,
  gv:node  B,
  gv:node  C,
  gv:node  X,
  gv:node  Y,

  gv:edge --label=p A X,
  gv:edge --label=q A B,
  gv:edge --color=red --style=dashed --label=r X C,
  gv:edge --label=s B C,
  gv:edge --color=red --style=dashed --label=t C B,
  gv:edge --label=u C Y,
  gv:edge --color=red --style=dashed --label=v Y A,

] | gv:graph cyclic-graph-1
||&lt;

&gt;||
/* -*- coding: utf-8 -*- */
/* cyclic-graph-2 */
[

  gv:node  A,
  gv:node  B,
  gv:node  C,
  gv:node  X,
  gv:node  Y,

  gv:node --style=filled --fillcolor=pink --shape=box a,
  gv:node --style=filled --fillcolor=pink --shape=box b,
  gv:node --style=filled --fillcolor=pink --shape=box c,

  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; a A,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; b B,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; c C,

  gv:node --style=filled --fillcolor=pink --label=&quot;a&quot; A_,
  gv:node --style=filled --fillcolor=pink --label=&quot;b&quot; B_,
  gv:node --style=filled --fillcolor=pink --label=&quot;c&quot; C_,

  gv:edge --label=p A X,
  gv:edge --label=q A B,
  gv:edge --label=r X C_,
  gv:edge --label=s B C,
  gv:edge --label=t C B_,
  gv:edge --label=u C Y,
  gv:edge --label=v Y A_,

] | gv:graph cyclic-graph-2
||&lt;

&gt;||
/* -*- coding: utf-8 -*- */
/* cyclic-graph-3 */
[

  gv:node  A,
  gv:node  B,
  gv:node  C,
  gv:node  X,
  gv:node  Y,

  gv:node --style=filled --fillcolor=pink --shape=box a,
  gv:node --style=filled --fillcolor=pink --shape=box b,
  gv:node --style=filled --fillcolor=pink --shape=box c,

  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; a A,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; b B,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; c C,

  gv:node --style=filled --fillcolor=pink --label=&quot;a&quot; A_,
  gv:node --style=filled --fillcolor=pink --label=&quot;b&quot; B_,
  gv:node --style=filled --fillcolor=pink --label=&quot;c&quot; C_,

  gv:edge --label=p A X,
  gv:edge --label=q A b,
  gv:edge --label=r X C_,
  gv:edge --label=s B c,
  gv:edge --label=t C B_,
  gv:edge --label=u C Y,
  gv:edge --label=v Y A_,

] | gv:graph cyclic-graph-3
||&lt;

&gt;||
/* -*- coding: utf-8 -*- */
/* cyclic-graph-4 */
[

  gv:node  A,
  gv:node  B,
  gv:node  C,
  gv:node  X,
  gv:node  Y,

  [
   gv:node --style=filled --fillcolor=pink --shape=box a,
   gv:node --style=filled --fillcolor=pink --shape=box b,
   gv:node --style=filled --fillcolor=pink --shape=box c,
  ] | gv:cluster --label=&quot;let map&quot; letmap,

  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; a A,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; b B,
  gv:edge --arrowhead=onormal --color=&quot;black:white:black&quot; c C,

  gv:node --style=filled --fillcolor=pink --label=&quot;a&quot; A_,
  gv:node --style=filled --fillcolor=pink --label=&quot;b&quot; B_,
  gv:node --style=filled --fillcolor=pink --label=&quot;c&quot; C_,
  gv:node --style=filled --fillcolor=pink --label=&quot;b&quot; B2_,
  gv:node --style=filled --fillcolor=pink --label=&quot;c&quot; C2_,

  gv:edge --label=p A X,
  gv:edge --label=q A B2_,
  gv:edge --label=r X C_,
  gv:edge --label=s B C2_,
  gv:edge --label=t C B_,
  gv:edge --label=u C Y,
  gv:edge --label=v Y A_,

] | gv:graph cyclic-graph-4
||&lt;

</body>
</day>
<day date="2013-08-23" title="">
<body>
*1377222363*[メモ]また間違えた

- http://d.hatena.ne.jp/m-hiyama/20130823/1377222190

別人のフリして2つのブログを書いてたりする人はどうすんだろうな。僕みたいな間違えはしないのか。いずれにしても注意力が必要だ、僕には無理。


</body>
</day>
<day date="2013-08-31" title="">
<body>
*1377919800*[Caty][お絵描き]連想コレクションの絵

連想コレクション（association collection）とは、RDBで関連テーブル（relationship table）とか呼ばれているようなもので、関連（数学用語では関係）だけを保持するためのコレクション。連想コレクションのレコードは参照のタプルとなる。

角丸の菱型は使えるかも。

&lt;pre class=&quot;code&quot;&gt;
[
 gv:node --fillcolor=orange --style=&quot;rounded,filled&quot; --shape=diamond X,
 gv:node A,
 gv:node B,
 gv:edge X A,
 gv:edge X B,
] | gv:graph
&lt;/pre&gt;

*1377920731*[Caty][お絵描き]矢印の形

本編 [http://d.hatena.ne.jp/m-hiyama/20130831/1377918991:title] を描くのに使ったのは、次のコマンド。

&lt;pre class=&quot;code&quot;&gt;
// -*- coding: utf-8 -*-

/** ロバストネス風の図 */
module g;

command arrow 
{
   @[default(false)]
   &quot;total&quot;: boolean?,

   @[default(false)]
   &quot;inj&quot;: boolean?,

   @[default(false)]
   &quot;surj&quot;: boolean?,

   @[default(false)]
   &quot;multi&quot;: boolean?,
 }
 [string name, string from, string to] :: void -&gt; gv:Edge
{
  %total | case {true=&gt;&quot;tee&quot;,  false=&gt;&quot;&quot;}       &gt; tail1;
  %inj   | case {true=&gt;&quot;inv&quot;,  false=&gt;&quot;&quot;}       &gt; tail2;
  %surj  | case {true=&gt;&quot;tee&quot;,  false=&gt;&quot;&quot;}       &gt; head1;
  %multi | case {true=&gt;&quot;crow&quot;, false=&gt;&quot;normal&quot;} &gt; head2;

  [%tail1, %tail2] | text:concat | cond{&quot;&quot;=&gt;&quot;none&quot;, *=&gt;pass} &gt; tail;
  [%head1, %head2] | text:concat                             &gt; head;

  [
    %1 &gt; name,
    %2 &gt; from,
    %3 &gt; to,
  ];

  %name &gt; label;

  gv:edge --dir=both --arrowtail=%tail --arrowhead=%head --label=%label %from %to
};
&lt;/pre&gt;


</body>
</day>
<day date="2013-09-02" title="">
<body>
*1378079000*[講座]リスト構造とリスト処理

なぜ、リストの自作は良い練習問題なのか？

+ 典型的なデータ構造とメモリーイメージに慣れる。
+ ポインタ・参照の操作に習熟できる。
+ 再帰処理が理解できる。
+ データのミュータビリティ、破壊的変更（上書き）と非破壊的操作（修正しながら転写）を理解できる。
+ 双方向リストやツリーに一般化できる。
+ さらに有向グラフ処理にも応用できる。有向グラフ処理はアルゴリズムの王様だろう。
+ 代数的データ構造に発展する。
+ 無限リストの遅延評価によるストリーム、イテレータなど。
+ リストモナドは、モナドの典型例。
+ 総称プログラミングでも良い例題。length, zipの一般化
+ 再帰から、map, foldへ。さらに一般化forld
+ 最近では、MapReduceによる並列処理。

リストは、実用上も理論上も、常にデータ構造の中核にあって、今でも新しい話題を提供している。例：http://d.hatena.ne.jp/m-hiyama/20130827/1377583720 に紹介した論文：

- Title: Parametric Datatype-Genericity
- Authors: Jeremy Gibbons, Ross Paterson
- URL: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/parametric.pdf

*1378080668*[プログラム意味論]アリティ付きフラット・ラムダ計算の記法

- ρ、τ ： 値割り当て、環境
- X, Y ： 束縛セット
- let X in t ： let式、letrecを含む
- X!u : 束縛（モジュール）X内で、uを定義する最小のlet式
- 【t|τ】 : 環境τのもとでの、項tの意味
- Ev(t) ： 閉じた項tの評価結果（意味を与える）
- Ev(t, τ) ： 環境τにおけるtの評価結果
- t[τ] ： 項tの環境τによる具体化（置換）
- X[Y] ： 束縛セットXの束縛セットYによる置換
- X :+ Y ： 束縛セットの非対称マージ
- τ :+ ρ : 環境の非対称マージ
- 《t|τ》 ： t[τ] と同じ。
- 《X|τ》 ： 束縛セットXの環境τによる具体化
- 《X|Y》 ： 束縛セットXの束縛セットYによる置換
- 【X|τ】 ： 束縛セットXの環境τにおける意味＝新しい環境

追加：

- D[n] ： [D&lt;sup&gt;n&lt;/sup&gt;, D] のこと
- D[n, m] ： (D[n])&lt;sup&gt;m&lt;/sup&gt; のこと
- Term(D)[n] ： アリティnの擬似項、D[n] を含む。
- Term(D)[n, m] ： (Term(D)[n])&lt;sup&gt;m&lt;/sup&gt;、D[n, m] を含む。



</body>
</day>
<day date="2013-09-03" title="">
<body>
*1378198017*[メモ][Caty][その他プログラミング] 1x1 gif画像のdata URI

- &quot;data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEHAAEALAAAAAABAAEAAAICTAEAOw==&quot;
- &quot;data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=&quot; 


</body>
</day>
<day date="2013-09-04" title="">
<body>
*1378256878*[プログラム意味論]アリティ付きフラット・ラムダ計算の記法 再度

構文領域で：

- 関数記号の集合： F = F&lt;sub&gt;0&lt;/sub&gt; + ...
- 変数記号の集合： V = V&lt;sub&gt;0&lt;/sub&gt; + ...
- 関数記号（のメタ変数）： f, g, h
- 変数記号（のメタ変数）： u, v, w
- アリティ0の変数記号（のメタ変数）： x, y, z
- ラムダ項（のメタ変数）： s, t
- 束縛セット： X, Y
- 束縛セットの変数uのボディ： X(u)
- uを定義する最小のlet式： X!u
- 束縛セットの置換： X[Y]、《X|Y》
- 束縛セットの“和”： X:+Y、X+:Y、X++Y

意味領域で：

- 意味論の圏： &lt;i&gt;C&lt;/i&gt;
- 値の領域： D∈|&lt;i&gt;C&lt;/i&gt;|
- 基本意味論： α、β : F&lt;sub&gt;*&lt;/sub&gt;→D[*]
- 値割り当て、環境: ρ、τ
- 環境τのもとでの、項tの意味： Eval(t, τ) = 【t|τ】
- 環境τのもとでの、束縛セットXtの意味： 【X|τ】
- 環境の“和”： ρ:+τ、ρ+:τ、ρ++τ



</body>
</day>
<day date="2013-09-05" title="">
<body>
*1378365210*[プログラム意味論][Caty][計算]とあるラムダ計算の計算例

「型を値とする」ラムダ計算なのだが、普通のラムダ計算と違う記号を使うと、視認性が悪くなって目で追いかけるのが大変なので、次のようにする。

+ 定数名、関数名は大文字の名前
+ ラムダ変数名は小文字と数字の組み合わせ
+ それ以外は普通の記法をそのまま使う。
+ let式を使う。
+ ひつだけ組み込みの演算子を持つ

組み込みの演算子は+だとして、単位元定数Eがあって、次を満たす。

+ (x + y) + z = x + (y + z) （結合律）
+ E + x = x + E = x （単位律）
+ x + y = y + x （可換律）
+ x + x = x （ベキ等律）

もともとは型の計算だったので、次のように変換するとそれらしくなる。

+ 丸括弧(, )を&amp;lt, &gt;にする。
+ 小文字λがいやなら大文字Λとする。
+ ネーミング（大文字小文字の使い方とか）を変える。
+ '+' を &amp;amp; に変える。

&lt;h4&gt;記法と計算方法&lt;/h4&gt;

β変換は次の形で使う。

- (λ(x, y).X)(a, b) ⇒ let {x = a, y = b} in X

letの後のブロックはコンテキストと呼ぶ。letの入れ子は、コンテキストの合成でフラット化できる。共通の変数（束縛の左辺の名前）を持たないletの入れ子は、コンテキストの単純マージ（可換なマージ）でフラット化できる。

- let {x = a, y = b} in (let {z = c} in X) ⇒ let {x = a, y = b, z = c } in X

逆に、大きなコンテキストを分割して入れ子として扱ってもよい。

- let {x = a, y = b, z = c } in X ⇒ let {x = a} in (let {y = b, z = c} in X)

コンテキストのマージと分割は、簡単だが重要なテクニックである。

let A in (X + Y) は、(let A in X) + (let A in Y) と変形できるので、演算+に関してletは分配する。

let A in X の略記として、臨時に X/A を使うことにする。X/A/B は (X/A)B 、つまり let B in (let A in X) の意味。略記 X/A を使うのは、let式の展開を遅延させる（後回しにする）ときである。+に対するletの分配法則は、(X + Y)/A = X/A + Y/A と書ける。

&lt;h4&gt;計算すべき式&lt;/h4&gt;

計算すべき式は次のとおり。

&gt;||
let {
  W  = λ(w).WB,
  FW = λ(f1, f2).(W(f1) + FWB),
  BW = λ(b1, b2).(W(b1) + BWB),
  LW = λ(l1, l2).(FW(l1, l2) + BW(l1, l2)),
  TW = λ(t1, t2).(LW(t1, t2) + TWB)
} in TW(a1, a2)
||&lt;

お尻がB（bodyのつもり）である名前（WB, FWB とか）は、それ以上は詮索しない式として扱う。

これを次のように分割しておく。

&gt;||
let {
  W  = λ(w).WB
}
in
  let {
    FW = λ(f1, f2).(W(f1) + FWB),
    BW = λ(b1, b2).(W(b1) + BWB)
  }
  in
    let {
       LW = λ(l1, l2).(FW(l1, l2) + BW(l1, l2))
    }
    in
      let {
        TW = λ(t1, t2).(LW(t1, t2) + TWB)
      } 
      in TW(a1, a2)
||&lt;

この分割は計算しやすいように定めたが、名前 TW, LW, BW, FW, Wのあいだの参照関係をDAG（Directed Acyclic Graph）に描いたときのorderと関係する。

&lt;h4&gt;内側から外側への計算&lt;/h4&gt;

計算すべき式の一番内側の、
&gt;||
      let {
        TW = λ(t1, t2).(LW(t1, t2) + TWB)
      } 
      in TW(a1, a2)
||&lt;

を計算してみる。

let式は構文的クロージャなので、コンテキストを使って式を展開（置換）する。すると、

&gt;||
(λ(t1, t2).(LW(t1, t2) + TWB))(a1, a2)
||&lt;

今後、適用が分かりにくいときは、明示的な適用演算子として中黒（・）を入れる。こうなる↓

&gt;||
(λ(t1, t2).(LW(t1, t2) + TWB))・(a1, a2)
||&lt;

適用はいったんlet式にするので、

&gt;||
let {t1 = a1, t2 = a2} in (LW(t1, t2) + TWB)
||&lt;

再び、展開（置換）する。TWBへの置換は遅延させるので略記を使う。

&gt;||
LW(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

let式 → 適用 → let式 というところが回りくどいが、置換は必ず（構文的）クロージャの展開で起きるとしたほうがスッキリすると思う。

次は、

&gt;||
    let {
       LW = λ(l1, l2).(FW(l1, l2) + BW(l1, l2))
    }
    in
      LW(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

の計算。クロージャの展開（置換）をして、

&gt;||
(λ(l1, l2).(FW(l1, l2) + BW(l1, l2)))・(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

let式に直して、

&gt;||
let {l1 = a1, l2 = a2} in (FW(l1, l2) + BW(l1, l2))  + TWB/{t1 = a1, t2 = a2}
||&lt;

またクロージャ展開して、

&gt;||
 FW(a1, a2) + BW(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

ここらへんで、最初に渡した実引数 (a1, a2) が順次“呼び出し先”に渡っていくのが理解できると思う。

次は、

&gt;||
  let {
    FW = λ(f1, f2).(W(f1) + FWB),
    BW = λ(b1, b2).(W(b1) + BWB)
  }
  in
    FW(a1, a2) + BW(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

クロージャ展開して、

&gt;||
 (λ(f1, f2).(W(f1) + FWB))・(a1, a2) + (λ(b1, b2).(W(b1) + BWB))・(a1, a2) + TWB/{t1 = a1, t2 = a2}
||&lt;

let式にして、

&gt;||
 let {f1 = a1, f2 = a2} in (W(f1) + FWB)
 +
 let {b1 = a1, b2 = a2} in (W(b1) + BWB)
 + 
 TWB/{t1 = a1, t2 = a2}
||&lt;

let式を展開（置換）して、一部は後回し、

&gt;||
 W(a1) + FWB/{f1 = a1, f2 = a2}
 +
 W(a1) + BWB/{b1 = a1, b2 = a2}
 + 
 TWB/{t1 = a1, t2 = a2}
||&lt;

演算+の結合律と交換律から

&gt;||
  W(a1) + W(a1) + FWB/{f1 = a1, f2 = a2} + BWB/{b1 = a1, b2 = a2} + TWB/{t1 = a1, t2 = a2}
||&lt;

演算+のベキ等律を使って、

&gt;||
  W(a1) + FWB/{f1 = a1, f2 = a2} + BWB/{b1 = a1, b2 = a2} + TWB/{t1 = a1, t2 = a2}
||&lt;

ベキ等律を使った変形は重要。

最後の計算、

&gt;||
let {
  W  = λ(w).WB
}
in
  W(a1) + FWB/{f1 = a1, f2 = a2} + BWB/{b1 = a1, b2 = a2} + TWB/{t1 = a1, t2 = a2}
||&lt;

これはもう結論書いてしまうと、

&gt;||
  WB/{w = a1} + FWB/{f1 = a1, f2 = a2} + BWB/{b1 = a1, b2 = a2} + TWB/{t1 = a1, t2 = a2}
||&lt;

略記をlet記法に戻すと、

&gt;||
 let {w = a1} in WB
 + 
 let {f1 = a1, f2 = a2}in FWB
 + 
 let {b1 = a1, b2 = a2} in BWB
 + 
 let {t1 = a1, t2 = a2} in TWB
||&lt;

&lt;h4&gt;外側から内側への計算&lt;/h4&gt;

&gt;||
let {
  W  = λ(w).WB
}
in
  let {
    FW = λ(f1, f2).(W(f1) + FWB),
    BW = λ(b1, b2).(W(b1) + BWB)
  }
  in
    let {
       LW = λ(l1, l2).(FW(l1, l2) + BW(l1, l2))
    }
    in
      let {
        TW = λ(t1, t2).(LW(t1, t2) + TWB)
      } 
      in TW(a1, a2)
||&lt;

この式に出てくるlet式のコンテキストを、外から内へと折りたたんで小さくする計算法もあるのでやってみる。

まず、一番外側の W  = λ(w).WB という束縛を、内側に展開して埋め込んでしまう。

&gt;||
  let {
    FW = λ(f1, f2).((λ(w).WB)・(f1) + FWB),
    BW = λ(b1, b2).((λ(w).WB)・(b1) + BWB)
  }
  in
    let {
       LW = λ(l1, l2).(FW(l1, l2) + BW(l1, l2))
    }
    in
      let {
        TW = λ(t1, t2).(LW(t1, t2) + TWB)
      } 
      in TW(a1, a2)
||&lt;

この段階で中黒（・）で書かれている適用を展開（β変換）してもいいのだが、そのまま残して先にlet式を折りたたんでいく。

&gt;||
    let {
       LW = λ(l1, l2).
            (  
              (λ(f1, f2).((λ(w).WB)・(f1) + FWB))・(l1, l2) 
            + 
              (λ(b1, b2).((λ(w).WB)・(b1) + BWB))・(l1, l2)
            )
    }
    in
      let {
        TW = λ(t1, t2).(LW(t1, t2) + TWB)
      } 
      in TW(a1, a2)
||&lt;

さらに、

&gt;||
      let {
        TW = λ(t1, t2).
             (
                (λ(l1, l2).
                  (  
                    (λ(f1, f2).((λ(w).WB)・(f1) + FWB))・(l1, l2) 
                  + 
                    (λ(b1, b2).((λ(w).WB)・(b1) + BWB))・(l1, l2)
                  )
                )・(t1, t2)
             + 
                TWB
             )
      } 
      in TW(a1, a2)
||&lt;

ここで、ラムダ式によるTWの明示的な表現が得られた。TW = λ(t1, t2).K と置いたKを求めよう。Kは次の式。

&gt;||
(
   (λ(l1, l2).
     (  
      (λ(f1, f2).((λ(w).WB)・(f1) + FWB))・(l1, l2) 
      + 
      (λ(b1, b2).((λ(w).WB)・(b1) + BWB))・(l1, l2)
     )
   )・(t1, t2)
+ 
   TWB
)
||&lt;

内側の (λ(f1, f2).( (λ(w).WB )・(f1) + FWB))・(l1, l2) を計算すると、

&gt;||
 (λ(f1, f2).((λ(w).WB)・(f1) + FWB))・(l1, l2)
⇒
 let {f1 = l1, f2 = l2} in ((λ(w).WB)・(f1) + FWB)
⇒
 ((λ(w).WB)・(l1) + FWB/{f1 = l1, f2 = l2})
⇒
 ((let {w = l1} in WB) + FWB/{f1 = l1, f2 = l2})
⇒
WB/{w = l1} + FWB/{f1 = l1, f2 = l2}
||&lt;

同様に、 (λ(b1, b2).( (λ(w).WB )・(b1) + BWB))・(l1, l2) は、

&gt;||
WB/{w = l1} + BWB/{b1 = l1, b2 = l2}
||&lt;

その外側は、

&gt;||
   (λ(l1, l2).
     (  
      WB/{w = l1} + FWB/{f1 = l1, f2 = l2}
      + 
      WB/{w = l1} + BWB/{b1 = l1, b2 = l2}
     )
   )・(t1, t2)
||&lt;

置換やコンテキストの合成を端折ると、

&gt;||
    (  
      WB/{w = t1} + FWB/{f1 = t1, f2 = t2}
      + 
      WB/{w = t1} + BWB/{b1 = t1, b2 = t2}
    )
||&lt;

ベキ等律により、

&gt;||
WB/{w = t1} + FWB/{f1 = t1, f2 = t2} + BWB/{b1 = t1, b2 = t2}
||&lt;

残っていた + TWB を足したものがKで、一番外側のラムダ抽象を元に戻した λ(t1, t2).K は、

&gt;||
λ(t1, t2).(
  WB/{w = t1} + FWB/{f1 = t1, f2 = t2} + BWB/{b1 = t1, b2 = t2} + TWB
)
||&lt;

(λ(t1, t2).K)・(a1, a2) を計算すると、

&gt;||

 λ(t1, t2).K)・(a1, a2) 
⇒
 let {t1 = a1, t2 = a2} in K
⇒
 let {t1 = a1, t2 = a2} 
 in 
   WB/{w = t1} + FWB/{f1 = t1, f2 = t2} + BWB/{b1 = t1, b2 = t2} + TWB
⇒
 WB/{w = a1} + FWB/{f1 = a1, f2 = a2} + BWB/{b1 = a1, b2 = a2} + TWB/{t1 = a1, t2 = a2} 
||&lt;

略記をlet記法に戻すと、

&gt;||
 let {w = a1} in WB
 + 
 let {f1 = a1, f2 = a2}in FWB
 + 
 let {b1 = a1, b2 = a2} in BWB
 + 
 let {t1 = a1, t2 = a2} in TWB
||&lt;

</body>
</day>
<day date="2013-09-06" title="">
<body>
*1378429322*[プログラム意味論]letとletrec

letとletrecを区別しないで、単にletと書いてletrecの意味でいいじゃないか、と思っていたが、そうじゃないな。

let {x = y, y = x} in x は意味があるが、letrec {x = y, y = x} in x はワケワカラン。letを単なる置換演算子と考える発想は余りなかったのだけど、再帰とは一切関係なしのletを使うのは便利かもしれない。

僕が今まで考えていたletは実はletrecなので、表記法は考えなおさないといけないな。let, letrec, where, whererec とか使うのか？ 他にmoduleとかget fromとか考えていて、

- get x form (module X) = letrec X in x

が基本。

*1378432671*[メモ] 予定変更

つうか、僕がとちったので、来週の火曜の午後4時だ。忘れないように書いておく。

*1378442500*[メモ][プログラム意味論][形式言語理論] profiled substitutions の圏

ウーン、ちゃんと書かないとやばいよなー、と思いつつ、極めてラフなメモ。近日中になんとかして、より詳しい記述をしたい。

変数と項のペアを束縛と呼ぶことにする。x = t のようにイコールで書く。束縛の集合、ただし変数はすべて違うものを束縛セットと呼ぶ。束縛と束縛セットはその使用目的により色々な名で呼ばれる。

+ assign, assignment
+ 付置（valuation）
+ 環境
+ コンテキスト
+ 置換、代入、展開
+ モジュール

ここでは、置換（substitution）としての束縛セットを扱う。

変数セットVを固定すると、V上で定義された置換の全体は合成に対してモノイドとなる。このモノイドは「モノイドに出来る」ってだけであまり自然なモノとは思えない。

変数セットVを固定せずに、任意の有限集合を変数セットだとみなして置換を考えて、置換＝束縛セットXの左辺変数の全体をLVar(X)、右辺に出現する変数の全体を RVar(X) として、RVar(X)⊆ A、B⊆LVar(X) である集合 A, Bを組み合わせて (A→B)X または (B←A)X と書く。これがプロファイル付き置換。

プロファイル付き置換の全体は自明な方法で圏になる。有限集合の直和をモノイド積としてモノイド圏ともなる。

問題は、このモノイド圏にトレース構造を入れること。構文構造だけを使ってトレースを組み立てるのが面白い問題だが、意味論を持ち込んで、意味論を使いながらトレースを入れてもいい。これら二つの手法を比較するのが最も興味深いトピックだ。

</body>
</day>
<day date="2013-09-07" title="">
<body>
*1378531162*[Mx][2013]ネタメモ 雑／最初のほう

+ 級数表示
+ f(x) = 1 + ax, g(x) = b + ax に対する不動点
+ ω総和可能半環
+ ω総和可能半環の具体例：boolean、max-plusとmin-plusがメイン
+ ω総和可能半環の構成：モノイドの上の畳み込み（ベキ集合だけ）、直積、正方行列、関数半環
+ 正規表現と構文図
+ 構文図で見るスターとプラス
+ 級数表示とラベル付き有向グラフ表示の関係：経路の集合という概念
+ 有向グラフあるところ圏あり
+ 境界付き空間（特に2D）、境界付きグラフ、境界付き圏（余談か）
+ 境界の一部をループ接合する操作＝トレース
+ 全トレースとトーラス化
+ 基本ステップを時間方向に延ばす（時間次元の追加）
+ 繰り返し＝時間次元に対する境界（過去と現在のスナップショット）の接合＝トレース＝トーラス化

*1378531306*[Mx][2013]状態旅行の世界設定

状態遷移を旅行と考えると、旅行する当人（粒子）とか団体旅行とか、世界の外から眺める人（神様）とかいる。中の人＝無視、外の神様＝鳥 と考えてもよい。

+ 状態空間＝特定時刻のスナップショットの空間
+ 状態空間は不変、時空が直積になる。
+ 状態空間も変化、時空が直積とは限らない。
+ ステップアロー＝離散時刻の時空線素
+ 時空シリンダー、時空チューブ＝両端の境界をスナップショットとして、ステップアローまたはステップパスを収容する入れ物。
+ ルーピング＝トーラス化＝トレース＝フィードバック


</body>
</day>
<day date="2013-09-09" title="">
<body>
*1378684279*[メモ][講座] 自由に考えて自由に試す

リスト処理は定番のデータ構造とアルゴリズムだが、それでも色々な自由度がある。ライブラリとして、どのような関数・メソッドを準備するか？ ミュータブルかイミュータブルか？ nilをどう扱うか？ などなど。

既存ライブラリでは、Underscore.js（それと互換のLo-Dash）が参考になるだろう。

- http://underscorejs.org/
- http://lodash.com/

ベンチマーク：

- http://jsperf.com/lo-dash-v1-1-1-vs-underscore-v1-4-4/2

forに比べて、リスト処理のmap, forEach, foldなどのほうが慣れると使いやすいし、短く簡潔で動的に書ける。

*1378687106*[メモ] 予定

火曜午後4時と木曜午前10時なので注意

</body>
</day>
<day date="2013-09-10" title="">
<body>
*1378773518*[説明][セミナー][お絵描き][具体例]コンウェイとエルゴットの双対性は絵が一番

&lt;img src=&quot;http://www.chimaira.org/img/looping.gif&quot; &gt;

図で、f&lt;sup&gt;†&lt;/sup&gt;は、fに対するコンウェイ（Conway）の不動点演算子。トレースを使って書くと、

- f&lt;sup&gt;†&lt;/sup&gt; = Tr(f;Δ)

となる。

f&lt;sup&gt;#&lt;/sup&gt;はエルゴットの繰り返し演算子。（右にある Tr(∇;f;Δ) は今回関係ない。）

f&lt;sup&gt;#&lt;/sup&gt; の表記として、

- Tr([ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;, f])

というのがある。ιは標準入射で、[,] は余タプリング。しかし、これでは不動点演算子との双対性がサッパリわからない。こういう表記はダメだと思うんだよな。絵で変形するば、左下のようになるが、さらに（ループの）スライディングで∇を移動してから巻き付いたワイヤーをアンワインディングすれば、Tr(∇;f) となる。

f&lt;sup&gt;†&lt;/sup&gt; = Tr(f;Δ) と、f&lt;sup&gt;#&lt;/sup&gt; = Tr(∇;f) なら、双対性は自明だ。まー、f&lt;sup&gt;†&lt;/sup&gt; = Tr(&amp;lt;π&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;, f&gt;) と書けば、Tr([ι&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;A,X&lt;/sub&gt;, f]) と対称になるんだけど。

*1378777582*[説明][セミナー][Mx][2013]ベクトルと行列の解釈

- ベクトル＝配位空間上の値分布＝状態＝状態空間の点
- 行列＝ベクトルの変換＝作用素＝状態遷移＝時間推進＝力学系の生成子

行列の計算＝（離散）作用素代数に慣れること。

*1378782708*[Mx][2013]ネアンデルタール線形代数

図形を射とするローヴェル理論。

5つの記法：

+ 象形文字：∇、II、X など
+ シッカリ行列： 升目欄と入出力矢印をシッカリ書いた行列、欄の幅・高さをちゃんとする。
+ 上から左： の絵図
+ 上から下： の絵図
+ 左から右： の絵図

基本的な行列：

+ Δ（∧）
+ ∇（Y、∨）
+ I
+ II, III, IIII, ...
+ !, !!, !!!, ...
+ i
+ i, ii, iii, ...
+ θまたは・
+ X
+ □（これは文字では書けない）∇;Δ のこと横向きの三角をくっつけたヤツ

法則：

+ Δの余結合律
+ Δ, ! の左右余単位律
+ Δ, X の余可換律
+ ∇の余結合律
+ ∇, i の左右単位律
+ ∇, X の可換律
+ a;! = !
+ i;a = i
+ ∇;Δ = □
+ Δ2 = (ΔΔ);(IXI)
+ ∇2 = (IXI);(∇∇);
+ Δ;∇  = I （べき等律）
+ 直和の交替律、エレベーター法則
+ f + g := Δ;(f g);∇ （足し算の定義）
+ Xのスワップスライド法則
+ スワップスライドの特殊形で、iのすり抜け
+ スワップスライドの特殊形で、!のすり抜け
+ fの線形性の記述 ∇とi
+ fの余線形性の記述、Δと!、どんな射も余線形
+ 射影の定義 π1 := I!、π2 := !I
+ ライデマイスターの2と3

イエター（yetter）の計算ルール：

+ 0ルール
+ 1ルール
+ 積ルール
+ 和ルール

R係数の行列 ＝ Rラベル付き有向完全二部グラフ

リグラフ ＝ Rラベル付き二境界付き有向グラフ

*1378805547*[Mx][2013][気付いた]記号法で印象が変わる (半)線形射のコンウェイ・ダガー

アフィン線形圏の不動点理論はけっこう難しい。ので扱わない。線形（正確には半線形かな）圏の不動点理論に限定する。線形圏でもけっこう難しい。そもそも不動点の存在を保証するのが難しい。係数半環になんらかの条件が必要だ。ベキ等な連続半環とか、そんなの。→ http://d.hatena.ne.jp/m-hiyama-memo/20061107/1162888657、http://d.hatena.ne.jp/m-hiyama-memo/20061026/1161847087 。

で、fは線形射（線形圏の射）とする。今まで、f:A×X→X と書いてきたが、パラメータ（制御変数）の空間はAじゃなくてTとするかな。f:T×X→X。Tだと時間みたいだ、って懸念もあるけど。

線形圏なので、f:T×X→X は、直和からの射 f:T+X→X と思ってよい。線形圏では直積と直和は一致して双積となるから。fは、a:X→X と b:T→X の余タプル [b, a] と書ける。つまり、f(t, x) = b(t) + a(x) 。線形圏では関数適用と掛け算は同じようなもんだから、一次形式 bt + ax が f(t, x) だと言ってもいい。

fの不動点を考えて、f&lt;sup&gt;†&lt;/sup&gt;(t) = μx.f(t, x) は Tr(f;Δ)。具体的に書くと、μx.(bt + ax) 。これ以上は絵を描かないと無理だが、次の絵の前半が参考になる。http://d.hatena.ne.jp/m-hiyama-memo/20100701/1277947580 より。

&lt;img width=&quot;600&quot; src=&quot;http://www.chimaira.org/img2/conway-prod-star.jpg&quot; &gt;

f(t, x) = bt + ax のコンウェイ不動点が (bt);a&lt;sup&gt;*&lt;/sup&gt; で与えられることが絵からわかる。固定されたtに対する bt = b(t) を改めてbと置けば、b;a&lt;sup&gt;*&lt;/sup&gt; = a&lt;sup&gt;*&lt;/sup&gt;b となり、素朴な級数計算の結果と一致する。

コンウェイ圏とは、トレース付きデカルト圏に他ならないが、さらに（半）線形性の条件を付けて線形コンウェイ圏ができる。これはコォゼン／クリーネ圏（Kozen-Kleene）と呼べるもんだろう。

</body>
</day>
<day date="2013-09-11" title="">
<body>
*1378866723*[Mx][2013][お絵描き][トレース／コンパクト閉圏]必須な絵算テクニック

絵算の欠点は、しばらくやってないと出来なくなる事だろう。勘（感、観）に頼るので、勘が鈍るのだ。

機械的な記号計算ではないので、どこ（場所、チャンバー）になに（変形規則の適用）をするかの判断に慣れがいる。視覚的な認識なのでアルゴリズム化が難しい。

絵算の話を文章でするのもナンダガ……
&lt;hr&gt;

線形（正確にはベキ等半線形）な圏のなかで、トレース、コンウェイダガー、クリーネスター、クリーネプラスなどの計算をするときに、ものすごく頻繁に使う技法がある。

ワイヤー本数が2→1であるような射（ボックス、団子、余対角∇もよく出る）に対するループ・スライディングをして、その後で巻き付いたワイヤーをアンワインディングする方法だ。絵算の定石（http://d.hatena.ne.jp/m-hiyama-memo/20100701/1277947580 ）はこの点について書いてある。

aのクリーネスターには、典型的な表現が3つある。

+ [0 1 / 1 a] という2×2行列のトレースを取る
+ ∇;Δ;(1 a)（空白をはさんで併置は直和）のトレースを取る。
+ 1 + f&lt;sup&gt;+&lt;/sup&gt;, f&lt;sup&gt;+&lt;/sup&gt; = Tr(∇;f;Δ) とする。

これら3つの同値性はすごく重要だが、「ループ・スライディング＋アンワインディング」を使う。2番目から3番目では、∇;Δ = □ という双代数律も使う。双代数律は、線形圏における行列の使用を合理化する根幹だろう。

他に、Tr(f;Δ) が実際に不動点を与えることを示すときも「ループ・スライディング＋アンワインディング」を使う。対角Δに沿ってfをダップ（dup）して、片一方のfをループ・スライディングする。アンワインディングすると、Tr(f;Δ) が出てくる。

Tr(f)をエルゴットダガーで表現する公式が、カザネスク／ステファネスク／ハイランド／長谷川の定理の肝で、プログラムf:A×X→B×X を出力部 f&lt;sub&gt;out&lt;/sub&gt;:A×X→B と変換部 f&lt;sub&gt;tran&lt;/sub&gt;:A×X→X に分けて、f&lt;sub&gt;loop&lt;/sub&gt; = Fix(f&lt;sub&gt;tran&lt;/sub&gt;) = (f&lt;sub&gt;tran&lt;/sub&gt;)&lt;sup&gt;†&lt;/sup&gt; の組み合わせでfを再現する。

手順は、[http://d.hatena.ne.jp/m-hiyama-memo/20061003/1159847522:title]と[http://d.hatena.ne.jp/m-hiyama-memo/20061003/1159883762:title]に書いてある。[http://d.hatena.ne.jp/m-hiyama-memo/20060614/1150266458:title]も関連する。このとき、もとのfをまずデカルト分解（デカルトペアリングで書く）して、それからトレースを取って、「ループ・スライディング＋アンワインディング」を行って (f&lt;sub&gt;tran&lt;/sub&gt;)&lt;sup&gt;†&lt;/sup&gt; の形を作る。

半線形圏＝双デカルト圏のデカルト分解、余デカルト分解、双代数律、それと「ループ・スライディング＋アンワインディング」を使えば、たいていの公式は出てくるだろう。アンワインディングは、クロス・スライディングとヤンキングを使ってるから、クロス（対称）を消去する効果がある。一方で、双代数律はクロスを作り出す効果がある。

*1378869707*[Mx][2013][プログラム意味論][DFD]トロピカルなクリーネ力学系

トロピカル環（半環）についは、

- [http://d.hatena.ne.jp/m-hiyama-memo/20080114/1200293620:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20060622/1150962733:title]

離散的な力学系に関しては、

- [http://d.hatena.ne.jp/m-hiyama-memo/20070907/1189132181:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20110725/1311551098:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20110801/1312158838:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20110713/1310515189:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20110709/1310176608:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20110709/1310205242:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20100628/1277684532:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20100615/1276570048:title]
- [http://d.hatena.ne.jp/m-hiyama-memo/20080119/1200726912:title]

熱帯状況（tropical setting）でクリーネな力学系を考えると、その特徴は：

+ 離散的、ただし連続現象の近似とみなすこともある。
+ 自律系（発展法則は時間によらないで一定）
+ 累積的（記憶を持つ、波頭だけではなくて掃過域を考える、粒子だけではなく軌跡も残る）
+ 累積する効果はベキ等である。アルゴリズム的には重複を気にしなくていいので有利。
+ 無限の未来で安定（停滞、平衡）する。イクィリブリアム（equilibrium）がある。

ベキ等で累積的なところが色々と特殊な現象を引き起こす原因かもしれない。ポアンカレ写像（Poincare map）、マルコフ分割（Markov partition）との関係も重要そうだが調べてない。

*1378878372*[メモ][リンク][講座]Logo in JS

- http://www.calormen.com/logo/


</body>
</day>
</diary>
