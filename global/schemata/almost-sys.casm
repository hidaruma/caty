// -*- coding: utf-8 -*-


/** システム定義の候補 
 * 一時的にこのモジュールに定義するが、
 * システム側に移される予定。
 */
module almost-sys; 

// AppManifest

/** ファシリティのターゲットドメイン
 * この型の値＝名前は、ファシリティの用途とデザインパターンの大分類を与える。
 */
type targetDomain = ("mafs"|"storage"|"session" | "other");

/** ファシリティバックエンドに関する基本情報 
 */
type FacilityBackendInfo =  {
  /** バックエンド名 */
  "name": string,
  /** バックエンドのモジュール＆クラスの名前 */
  "module": string,
  /** バックエンドの設定情報の型
   * 型の修飾名を指定する。
   */
  "configType": string(remark="型の名前"),

  /** このバックエンドの短い説明 */
  "description": string?,
  /** このバックエンドのより詳しい説明 
   * Wiki記法が使える。
   */
  "moreDescription": string?,
  /** バージョン
   * パッケージメタ情報と重複記述になるときは書かないほうがよい。
   */
  "version": string?,

  /** このバックエンドが実現するファシリティの用途とデザインパターン */
  "targetDomain": targetDomain?,
  /** ファシリティ宣言で使う標準的なファシリティ名 */
  "stdFacilityName": string?,

  *: any?

};

/** アプリケーションごとのファシリティバックエンドの基本情報を列挙する */
command list-backends
 [@[default("this")] string(remark="アプリケーション名")? app]
 :: void -> [FacilityBackendInfo*]
;

/** デフォルトのレコード型 
 */
@[register-public]
type DefaultRecord = {
 /** 主キーは id という名前の文字列フィールドである */
 "id": string?, 

 /* 他は任意 */
 *:any?
};


kind KeyType = lower (number | string | binary);
kind FragmentPathType = lower string?;
kind RecordType = lower object;

type Iterable<T> = ([T*] | foreign);


/** 
 * コレクションを操作するコマンドセット 
 */
@[hidden]
signature Collection
<
  /** レコードの型 */
  Record in RecordType default DefaultRecord,

  /** 主キー（IDフィールド）の型 */
  Key in KeyType default string,

  /** フラグメントパスの型
   * string または undefined に具体化して使う。
   */
  FragmentPath in FragmentPathType default string,
> =
{
 /** 主キー（IDフィールド）の型の名前
  */
  property keyType :: string(remark="キーの型の名前") ;

 /** レコードの型の名前
  */
  property recordType :: string(remark="キーの型の名前") ;


 /** 引数に与えられたキーにより単一レコードを取得する */
 @[reader]
 command lookup [Key key] :: void -> Record
         throws NotFound;

 /** 引数に与えられたキーとフラグメントパスからレコードポーションを得る 
  * フラグメントが返るので、出力型は動的。
  */
 @[reader]
 command get [Key key, FragmentPath? fragment-path] :: void -> any
         throws NotFound;

 /** レコードがコレクションに所属（∈）するかどうか判定する 
  * IDだけでなく、値の同一性もチェックする。
  */
 @[reader]
 command belongs :: Record -> boolean;

 /** キーに対応するレコードが存在するかどうか判定する */
 @[reader]
 command exists [Key key] :: void -> boolean;

 /** すべてのキーを列挙する */
 @[reader]
 command keys :: void -> Iterable<Key>; // eachの入力

 /** すべてのレコードを列挙する */
 @[reader]
 command all :: void -> Iterable<Record>; // eachの入力

 /** コレクションにレコードを挿入する 
  * 引数にキーが指定されれば、そのキーを使う。
  * 引数にキーが指定されず、レコードにもIDがないきはBadInput例外。
  */
 @[updater]
 command insert [Key? key] :: Record -> Record
   throws [AlreadyExists, BadInput]
 ;

 /** 単一レコードを置き換える */
 @[updater]
 command replace [Key key] :: Record -> Record
   throws NotExist
 ;

 /* == デフォルト実装付きのコマンドプロファイル == */

 /** 入力に与えられたキーとフラグメントパスからレコードポーションを得る */
 command get_ :: [Key, FragmentPath?] -> any throws NotFound {
   =[ pass > k, pass > p];
   get %k %p?
 };

 /** 存在すればレコードを取得し、そうでないならundefinedを返す */
 @[reader]
 command get-if-exists [Key key, FragmentPath? fragment-path] :: void -> Record? {
   exists %1 |
   case {
    true  => get %1 %2?,
    false => undefined,
   }
 };

 /** 存在すればレコードを置換し、そうでないなら新規作成する */
 @[updater]
 command put [Key? key] :: Record -> Record {
   pass > record;
   %1? |
   when {
     undefined => 
       %record | insert // -> output
       ,
     * => 
       pass > id; exists %id |
       case {
         true  => %record | replace %id,  // -> output
         false => %record | insert %id,   // -> output
       }
       ,
   }
 };


};
