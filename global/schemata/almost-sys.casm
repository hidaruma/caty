// -*- coding: utf-8 -*-

/** システム定義の候補 
 * 一時的にこのモジュールに定義するが、
 * システム側に移される予定。
 */
module almost-sys; 

/* カインド式に他のカインドの名前が使えない */
/*
kind KeyType = collection:KeyType;
kind FragmentPathType = collection:FragmentPathType;
*/

/* collection.casm よりコピペ */
kind KeyType = lower (number | string | binary);
kind FragmentPathType = lower string?;

type Iterable<T> = (foreign | [T*]);


/** 
 * ベースコレクションとして必要なコマンドセット 
 */
@[register-public]
signature Basable
<
  /** 主キー（IDフィールド）の型 */
  Key in KeyType default string,

  /** フラグメントパスの型
   * string または undefined に具体化して使う。
   */
  FragmentPath in FragmentPathType default string,
> =
{

 /* 接頭辞の p- は、partial(ly), portion を意味する */

 /** 入力データが指定されたレコードポーションにサブレコードとしてマッチするかどうか判定する 
  * 判定が困難なら indef を出力する。
  */
 @[reader]
 command p-matches [Key key, FragmentPath? frag-path]  :: any -> tboolean;

 /** キーとパスに対応するレコードポーションが存在するかどうか判定する */
 @[reader]
 command p-exists [Key key, FragmentPath? frag-path] :: void -> boolean;

 /** パスに対応するレコードポーションが存在するすべてのキーを列挙する */
 @[reader]
 command p-keys [FragmentPath? frag-path]:: void -> Iterable<Key>;

 /** コレクション内の、パスに対応するレコードポーションが存在するレコードの個数を返す */
 @[reader]
 command p-count [FragmentPath? frag-path] :: void -> integer(minimum=0);

 /** パスに対応するレコードポーションを列挙する */
 @[reader]
 command p-all [FragmentPath? frag-path] :: void -> Iterable<any>;

 /** 型チェックなしで、パスに対応するレコードポーションを列挙する
  */
 @[reader]
 command p-dump [FragmentPath? frag-path] :: void -> Iterable<any>;

};

// end of module
