// -*- coding: utf-8 -*-
module webio;

/* 注意 TODO：
 *
 * webResponseのwebは不要かも
 * 例外に webio_ を付けたのはタグ名の衝突回避のためだが、そもそもここで例外定義は不要か？
 * サンプルが入っている。
 *
 */

/* == 階層間のデータ変換
 
階層（レイヤー）
 
# semantic -- 応用固有のセマンティクスを持つデータ型
# generic -- 汎用のフォーマット
# raw -- (string | binary)、ただし、content-type によるメタ情報は持つ

# semantic階層では、Caty型システムがそのまま使われる。
# semantic階層では、CatyのGeneric型が使われが、さらにフォーマット名（実体はタグ名）により細分類される。
# raw階層（転送階層）では、MIMEメディア型の分類システムが使われる。

=== コマンドのネーミング

# semantic → generic : untranslate
# generic → raw : unparse
# raw → generic ：parse
# generic → semantic ： translate

型／フォーマットの情報はオプションとして渡す。引数では、順序を間違う恐れがある。

*/

/* === 例外 === */

/** 与えられたメタ情報が少なすぎるので、変換ができない */
exception webio_InsufficientMetainfo = Exception;

/** 変換中になんらかのエラーが発生した 
 * -- これは一般的なエラーとすべきか？
 */
exception webio_ConversionError = Exception;

/* === データ型 === */

/** MIMEメディア型の名前 */
type mediaType = common:mediaType;

/** raw階層（転送階層）で使われるデータ */
type Raw = (string | binary);

/** フォームを表現するオブジェクト */
type FormObj = {
    *: [(string|binary), (string|binary)*],
};


/** generic階層に属するデータ、フォーマットで分類されてる
 * 必要に応じて拡張する。
 */
type Generic = (
 /** データがないとき */
  @void null |

 /** JSONデータ */
  @json any |

 /** フォームデータ */
  @form FormObj |

// /** XMLデータ */
//  @xml XJX |

 /** プレーンテキストとみなせるデータ */
  @text string |

 /** その他のバイナリ、不明な場合も含む */
  @bytes binary |
);

/** Generic型の種別（フォーマットと呼ぶ）を表す文字列表現 */
type GenericFormatName = (
 /** データがないとき */
  "void" |

 /** JSONデータ */
  "json" |

 /** フォームデータ */
  "form" |

// /** XMLデータ */
//  "xm" |

 /** プレーンテキストとみなせるデータ */
  "text" |

 /** その他のバイナリ、不明な場合も含む */
  "bytes" |
);


/* === 変換コマンド === */

/** semanticデータをgenericデータにdownward変換する 

--formatは必須である。--formatの値により変換アルゴリズムを選択する。
--typeが指定されていれば、型情報を変換に利用するかもしれない。
--typeが指定されていないときは、型情報なしで行える変換を試みる。

例： webio:untranslate --format=form

*/
command untranslate
 {
   /** Caty型システムの型名 */
   "type" : typeName?,
  
   /** フォーマット名（タグ名）
    * 有限個の候補から選ぶ。
    */
   "format" : GenericFormatName,
 }
:: any -> Generic throws [webio_InsufficientMetainfo, webio_ConversionError]
    refers python:webio.Untranslate;

/** genericデータをrawデータにdownward変換する 

入力のタグ名（フォーマット名）により変換アルゴリズムを選択する。
--content-typeが指定されれば、そのメディア型に対する変換を行う。
--content-typeが指定されないときは、もっとも適切なメディア型が選ばれる。

例： webio:unparse --content-type=application/xml

*/
command unparse
 {
   /** MIMEメディア型 */
   "content-type" : mediaType?,
 }
:: Generic -> Raw throws [webio_InsufficientMetainfo, webio_ConversionError]
;

/** rawデータをgenericデータにupward変換する 

--content-typeが指定されてないときは、環境変数CONTENT_TYPEの値を使う。
CONTENT_TYPEもないときは、コマンドがメディア型を（なんらかの方法で）決める。

--formatが指定されてないときは、もっとも適切なフォーマットが選ばれる。

例： webio:parse --format=json

*/
command parse
 {
   /** MIMEメディア型 */
   "content-type" : mediaType?,

   /** フォーマット名（タグ名）
    * 有限個の候補から選ぶ。
    */
   "format" : GenericFormatName?,
 }
:: Raw -> Generic throws [webio_InsufficientMetainfo, webio_ConversionError]
;

/** genericデータをsemanticデータにupward変換する 

--typeが指定されていれば、型情報を使って変換を試みる。
--typeが指定されてないときは、型情報なしでできる範囲の変換を試みる。。
またはまったく変換しない。

例： translate --type=my:LunchOrder

*/
command translate
 {
   /** Caty型システムの型名 */
   "type" : typeName?,
 }
:: Generic -> any throws [webio_InsufficientMetainfo, webio_ConversionError]
;


/* == リクエスト発行 == 

リクエスト発行コマンドは、raw階層からの通信をスタートさせ、
サーバーからのレスポンスを出力する。

generic階層／semantic階層のデータを扱うときは、
階層間でのデータ変換コマンドを併用する。

ネットワーク接続がされてないときは、例外が発生する。

*/


/* === データ型 === */

/** リクエストに対するレスポンスの型 */
type WebResponse = deferred public:WebOutput;


/* === コマンド === */

 
/** HEADリクエストを発行する */
command head
 {
   /** デバッグ出力を行うか */
   @[default(false)]
   "debug": boolean?,

   /** リクエストタイムアウト時間（秒数、小数使用可能）*/
   "timeout" : number(minimum=0)?,

   /** 動詞
    * クエリー文字列に _verb= を追加する。
    * URLにもともと _verb= があった場合は上書きされる。
    */
   "verb": string?,
 }
 [uri requestTarget]
:: void -> WebResponse throws [Timeout, UnknownError]
  refers python:webreq.Head
;

/** GETリクエストを発行する */
command get
 {
   /** デバッグ出力を行うか */
   @[default(false)]
   "debug": boolean?,

   /** リクエストタイムアウト時間（秒数、小数使用可能）*/
   "timeout" : number(minimum=0)?,

   /** 動詞
    * クエリー文字列に _verb= を追加する。
    * URLにもともと _verb= があった場合は上書きされる。
    */
   "verb": string?,
 }
 [uri requestTarget]
:: void -> WebResponse throws [Timeout, UnknownError]
  refers python:webreq.Get
;

/** PUTリクエストを発行する */
command put
 {
   /** デバッグ出力を行うか */
   @[default(false)]
   "debug": boolean?,

   /** リクエストタイムアウト時間（秒数、小数使用可能）*/
   "timeout" : number(minimum=0)?,

   /** 動詞
    * クエリー文字列に _verb= を追加する。
    * URLにもともと _verb= があった場合は上書きされる。
    */
   "verb": string?,

   /** 入力データのメディア型
    * 環境変数CONTENT_TYPEは使用しない。
    * このオプションが省略されると、text/plainかapplication/octet-streamが使われる。
    */
    "content-type": mediaType?,
 }
 [uri requestTarget]
:: Raw -> WebResponse throws [Timeout, UnknownError]
  refers python:webreq.Put
;

/** POSTリクエストを発行する */
command post
 {
   /** デバッグ出力を行うか */
   @[default(false)]
   "debug": boolean?,

   /** リクエストタイムアウト時間（秒数、小数使用可能）*/
   "timeout" : number(minimum=0)?,

   /** 動詞
    * クエリー文字列に _verb= を追加する。
    * URLにもともと _verb= があった場合は上書きされる。
    */
   "verb": string?,

   /** 入力データのメディア型
    * 環境変数CONTENT_TYPEは使用しない。
    * このオプションが省略されると、text/plainかapplication/octet-streamが使われる。
    */
    "content-type": mediaType?,
 }
 [uri requestTarget]
:: Raw -> WebResponse throws [Timeout, UnknownError]
  refers python:webreq.Post
;

/** DELETEリクエストを発行する */
command delete
 {
   /** デバッグ出力を行うか */
   @[default(false)]
   "debug": boolean?,

   /** リクエストタイムアウト時間（秒数、小数使用可能）*/
   "timeout" : number(minimum=0)?,

   /** 動詞
    * クエリー文字列に _verb= を追加する。
    * URLにもともと _verb= があった場合は上書きされる。
    */
   "verb": string?,
 }
 [uri requestTarget]
:: void -> WebResponse throws [Timeout, UnknownError]
//  refers python:webreq.Delete
;

/** レスポンスを返す 
 * publicモジュールのresponseと基本的に同じだが、
 * このモジュールを自己完結的にするために含める。
 * --extオプションは便利機能なので入れてない。
 */
command response
 {
   /** レスポンスのステータスコード */
   @[default(200)]
   "status": integer?,

   /** 入力（Webへの出力）データのメディア型
    * 省略されると、環境変数CONTENT_TYPEの値を使用する。
    * 環境変数CONTENT_TYPEもないときは、text/plainかapplication/octet-streamが使われる。
    */
   "content-type": string?,
  
 /** エンコーディング（文字符号化方式）
    * エンコーディングが指定されると、文字列を指定のエンコーディングでencodeしてからWebに出力する。
    * Content-Typeヘッダのcharsetパラメータもセットされる。
    * テキストではないメディア型（例：image/gif）に指定したときの挙動は保証されない。
    * エンコーディングのデフォルトは、環境変数APP_ENCODINGが使われる。
    */
   "encoding": string?,
 }
:: Raw -> WebResponse
{
  public:response %--status?  %--content-type? %--encoding?
}
;


/* == サンプル == */

/** 汎用エコーバック 
 * アクションボディに、このコマンドだけを書けば
 * リクエスト内容のエコーバックができる。
 */
@[sample]
command echo-back
:: (null|binary|string) -> Response
{
  response --content-type=%CONTENT_TYPE
};

/** 汎用ダンプコマンド
 * このコマンドが呼ばれた時の環境をダンプして返す。
 * 結果はJSONデータ
 */
@[sample]
command dump {*:any?}[any*]
:: (null|binary|string) -> Response
{
  pass > in;
  {
    "input": %in,
    "env": env,
    "opts": %_OPTS,
    "argv": %_ARGV,
  } | json:response
};


/** JSONオブジェトをフォームにエンコードしてPOSTで送り、戻りを返す
 */
@[sample]
command encode-to-form-and-request
:: object -> Response
{
  webio:untranslate --format=form | 
  webio:unparse |
  webio:post --content-type=application/x-www-form-urlencoded
};


/** フォームデータをオブジェトにデコードし、その結果をJSONで戻す
 * このコマンドはactionに入れて使う。
 */
@[sample]
command decode-from-form-and-back
 [typeName myType]
:: string -> object
{
  %1 > myType;

  webio:parse --format=form | 
  webio:translate --type=%myType |
  json:response
};


// End of Module
