// -*- coding: utf-8 -*-
/** meta programming library */
module mpl;

/* メモ

 file:list --rec --long / | take{$.abspath | path:matches "*.txt"}

*/

/** リソースクラスに含まれるインスタンス（パス文字列）を列挙する */
command res-instances 
  {
    /** 実在するファイルを含めるか */
    @[default(false)]
    "existing": boolean?
  }
  :: reif:ResourceSummary -> [string*] 
{
 pass > res |
 [
   $.pathPattern > patt,
   $.instances   > inst,
 ];
 %patt |
 take {
   text:regmatch "^[^*]*$" 
 } > no-wild;

 %existing? |
 case {
  undefined | false => [],
  * => %res | existing-instances, 
 } > existing-insts;

 [%inst, %existing-insts, %no-wild] | list:concat
};

/** リソースクラスにマッチする実在のインスタンス（ファイル）を列挙する */
command existing-instances :: reif:ResourceSummary -> [string*] {
  [
    $.location.app > app,
    $.pathPattern  > patts,
  ];
  %patts | matched-files %app
};

/** パターンにマッチするファイル（パス文字列）を列挙する */
command matched-files [string? app] :: string | [string*] -> [string*] {
 when {
  string => [pass],
  * => pass,
 } > patts;

 %1? | $?="this" > app;
 ["pub@", %app, ":/"] | text:concat > root;

 file:list --rec --long %root | each {$.abspath} > files;
 %patts |
 each {
   pass > patt;
   %files |
   take {path:matches %patt}
 } | list:concat
};


/** URLを表現する構造体 */
type UrlStruct = {
  "pathInfo": string,
  "hostUrl": string,
  "appPath": string,
};

/** 型を表すテキスト（暫定） */
type typeText = string;

/** アクションを外部から起動するための情報 */
type ActionTriggerInfo = {
    @[default("")]
    "verb": string?,
    @[default("GET")]
    "method": httpMethod?,


    /** アクションのオプションパラメータの型
     * HTTPリクエストでは、クエリー文字列となる 
     */
    @[default("void")]
    "inputType": typeText?,

    /** アクションのオプションパラメータの型
     * HTTPリクエストでは、クエリー文字列となる 
     */
    @[default("{}")]
    "paramsType": typeText?,

    "targetUrl": UrlStruct?,

    "targetName": string?,
    "pathPattern": [string*]?,
};

/** リンクからトリガーセットを生成する 未完 */
command link-to-triggers [string prefix ] :: reif:Link -> any {
 pas > link | $.targets > targets;
 %1 > prefix;

 %targets |
 each {
   pass > act;
   [%prefix, %act] | text:concat > actPath;
   list-act-triggers %actPath
 } | list:concat

};

/** 状態からトリガーセットを生成する 未完 */
command state-to-triggers :: reif:StateSummary -> any {
 pass > stt | $.links > links;

 %stt | $.location | mod-name > prefix;

 %links |
 each --obj {
  link-to-triggers %prefix
 }

};

command mod-name
 ::   {"app":string, "pkg":string?, "mod":string?, *:any?} -> string
{
 pass > loc | $.pkg? |
 when {
   undefined => "",
   string => [pass, "."] | text:concat,
 } > pkg;
 %loc |
 [
   $.app, "::",
   %pkg,
   $.mod, ":",
 ] | text:concat
};

command res-name
 ::   {"app":string, "pkg":string?, "mod":string?, "cls": string, *:any?} -> string
{
 pass > loc | $.pkg? |
 when {
   undefined => "",
   string => [pass, "."] | text:concat,
 } > pkg;
 %loc |
 [
   $.app, "::",
   %pkg,
   $.mod, ":",
   $.cls, ".",
 ] | text:concat
};


command list-act-triggers [string actPath] :: void -> any/*[ActionTriggerInfo*]*/ {
 %1 > actPath;

 sreif:show-action %actPath |
 act-all-triggers
};

command act-all-triggers :: reif:ActionSummary -> any/*[ActionTriggerInfo*]*/ {

 pass > act | $.location | 
 [
   res-name > resPath,
   $.app > app,
 ];
 sreif:show-resource %resPath | res-instances > insts;
 
 %insts | dump --prefix="mpl:get-triggers" |
 each {
  pass > pathInfo;
  [
      %act |
      do {
         mos:get-canonical-name >: "targetName",
         $.invoker.verb   >: "verb",
         $.invoker.method >: "method",
         $.pathPattern >: "pathPattern",
      }
      ,
      {"targetUrl":{"hostUrl":%HOST_URL, "appPath":%APP_PATH, "pathInfo":%pathInfo}}
  ] | json:merge
 }

};

command list-app-triggers [string appPath] :: void -> [ActionTriggerInfo*] {
 %1 > appPath;

 sreif:show-application %appPath |
 app-all-triggers

};

command list-mod-triggers [string modPath] :: void ->  [ActionTriggerInfo*] {
 %1 > modPath;

 sreif:show-module %modPath |
 mod-all-triggers

};

command list-res-triggers [string resPath] :: void -> [ActionTriggerInfo*] {
 %1 > resPath;

 sreif:show-resource %resPath |
 res-all-triggers

};

command app-all-triggers :: reif:ApplicationSummary -> [ActionTriggerInfo*] {
  // mos:get-canonical-name > appPath; /* ここでも使えたほうがイイ */
  $.name > appPath;

  sreif:list-modules %appPath | 
  each {
    mod-all-triggers
  } | list:concat
};

command mod-all-triggers :: reif:ModuleSummary -> [ActionTriggerInfo*] {
  mos:get-canonical-name > modPath;

  sreif:list-resources %modPath | 
  each {
    res-all-triggers
  } | list:concat
};

command res-all-triggers :: reif:ResourceSummary -> [ActionTriggerInfo*] {
 [  
   res-instances > insts,
   mos:get-canonical-name > resPath,
 ];
 sreif:list-actions %resPath |
 each {
   do {
      mos:get-canonical-name >: "targetName",
      $.invoker.verb   >: "verb",
      $.invoker.method >: "method",
      $.pathPattern >: "pathPattern",
   }
 } > acts;

 %insts | dump --prefix="mpl:res-all-triggers" |
 each {
  pass > pathInfo;
  %acts |
    each {
      pass > obj;
      [
        %obj,
        {"targetUrl":{"hostUrl":%HOST_URL, "appPath":%APP_PATH, "pathInfo":%pathInfo}}
      ] | json:merge
    }
 } | list:concat

};

// End of Module
