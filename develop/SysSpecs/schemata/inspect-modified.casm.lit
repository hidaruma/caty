<<ignore -*- coding: utf-8 -*- >>

= Inspect

== 全般の注意

* 疑似タグについては、大幅に変更する予定なので、今はほっておく。
* 型名のネーミングは、新規追加と変更したところ以外はそのまま。ネーミングポリシーは揃ってない。
* QualifierMixin というミクシンを使っているため、多くのオブジェクト型が open-constraintsになっている。
  いずれ制約を閉じることにして、開発中はopenとする。


== 一般的定義（古い部分）

ここは（今回は）特に直してない。

<<{
/**
 * Catyランタイムのオブジェクト情報
 */
module inspect-modified in casm;

type typeExprText = string(remark="型表現のテキスト");
type exceptionName = string(remark="例外の名前");

/** コマンドプロファイル情報の簡易版 */
type ShortProfile = {
 /** コマンドの名前 */
 "name" : string,

 /** コマンドの型引数
  * コマンドが多相IOプロファイルを持つとき、束縛型変数（名前文字列）のリストを指定する。
  * IOプロファイルが具体的（単相）なときは空配列。
  */
 "typeVars" : [string*],

 /** 実装状況 */
 "implemented" : implemented?,

 /** オプションの型 */
 "opts" : typeExprText,

 /** 引数の型 
  * arg0は含まれないので、args[0]がargv[1]であることに注意
  */
 "args" : typeExprText,

 /** 入力の型 */
 "input" : typeExprText,

 /** 出力の型 */
 "output" : typeExprText,

 /** 例外の型 */
 "throws" : ([exceptionName*] | @only [exceptionName*])?,
 "signals" : ([exceptionName*] | @only [exceptionName*])?,

 /** deprecatedか否か */
 "deprecated" : boolean,

 // /** ファシリティの利用宣言 */
 //"facilityUsages": [FacilityUsage*]?,

  *: any?
};

/** 実装状況を示す値 
 */
type implemented = (
  /** 実装はない、宣言されているだけ */
  "none" |

  /** Python実装を持つ */
  "python" |

  /** CatyScript実装を持つ */
  "catyscript" |
);

/**
 * ファシリティの利用宣言
 */
type FacilityUsage = {
    "facilityName": string,
    "usageType": "reads" | "updates" | "uses",
};
}>>


== コマンド

これは対象外。

{{{
/** モジュールに含まれるコマンドを列挙する
 * 引数に指定されたモジュールに固有なコマンドだけを列挙する。
 * 別名として存在するコマンドや、そのモジュールから可視な別モジュールのコマンドは列挙しない。
 * 
 * モジュール名はパッケージ修飾を許す。
 * またアプリケーション名で修飾してもよい。
 * 例：
 *  * mymod
 *  * pkg.mymod
 *  * otherapp:somepkg.yourmod
 *  * this:pkg.mymod
 */
command list-cmd 
 {
   /** 当面、shortオプションのデフォルトはtrue */
   @[default(true)]
   "short" : boolean?,
 }
 [string moduleName] :: void -> [ShortProfile*]
 throws ModuleNotFound
 refers python:caty.core.std.command.inspect.ListCommands;

/** モジュール情報 */
type Module = {

 /** モジュールの名前 
  * パッケージ修飾されている可能性がある。
  */
 "name" : string,
 
 /** ドキュメンテーションコメント */
 "document": Doc,

 /** モジュールの記述構文 */
 "syntax" : ("casm" | "cara"), // "camb" はとりあえず除いておく

 /** モジュールが置かれている場所 */
 "place" : ("schemata" | "actions")
};

/** アプリケーションに含まれるモジュールを列挙する
 * 引数に指定されたアプリケーションに固有なモジュールだけを列挙する。
 * そのアプリケーションから可視なモジュールでも別なアプリケーションに所属するモジュールは列挙しない。
 * アプリケーションとしてcatyが指定された場合は、
 * Catyコアに組み込みのモジュールを列挙する。
 *
 */
command list-mod
 [string appName] :: void -> [Module*]
 throws ApplicationNotFound
 refers python:caty.core.std.command.inspect.ListModules;

/** モジュールの情報を取得する。
 */
command mod-info
 [string appName] :: void -> Module
 throws ApplicationNotFound
 refers python:caty.core.std.command.inspect.ModuleInfo;

/**
 * 引数の型に対するレイフィケーションイメージを出力する。
 */
command reify-type [string typeName] :: void -> ReifiedTypeTerm | RTypeDef
    throws [ApplicationNotFound, ModuleNotFound, TypeNotFound]
    reads schema
    refers python:caty.core.std.command.inspect.ReifyType;

/**
 * 引数のコマンドに対するレイフィケーションイメージを出力する。
 * アクションコマンドについては対象外。
 */
command reify-cmd [string cmdName] :: void -> ReifiedCommand
    throws [ApplicationNotFound, ModuleNotFound, CommandNotFound]
    reads schema
    refers python:caty.core.std.command.inspect.ReifyCmd;

/**
 * スキーマモジュールのレイフィケーションイメージを出力する。
 */
command reify-module [string modName] :: void -> ReifiedModule
    throws [ApplicationNotFound, ModuleNotFound, BadArg]
    refers python:caty.core.std.command.inspect.ReifyModule;

}}}

== レイフィケーション

# TypeAttribute を TypeQualifier に変更。→ さらに Mixinに変更。
# options を attributes に変更。
# annotation を anntations として、オブジェクトに変更。
# ReifiedAnnotation は削除。
# モジュールとクラスが名前空間なの**ではない**。モジュール／クラスは名前空間の入れ物であるコンテナ。
  名前空間は、types, commands, classes など。\\
 名前空間コンテナと名前空間の構造を反映するように、モジュール／クラス／リソースの定義を変更。
# 修正があった所に @~@ が付いている。
# ScalartとEnum型が意味的におかしいので、BasicTypeとしてまとめた。
# アットマーク1個のコメント /~/@ が変更に対する理由や疑問点など

<<{

/*レイフィケーション関係*/

/** ドキュメンテーションコメント */
type Doc = {
 /** 短い簡潔な記述 */
 "description": string,
 /** より詳しい説明 */
 "moreDescription" : string(remark="Wikiテキスト")?,
};

/** 共通の修飾情報 */
type QualifierMixin = { //@@

    /** 名前
     * nameもこのミクシンに含まれる、ただし省略可能
     * ミクシンを使用するときに必須にすることもできる。
     */
    "name": string?,

    // docコメントとアノテーションは、ほとんどどこにでも付けることができる
    "document": Doc?,
    "annotations": object?,

     *: any?
};


/** モジュールの共通構造 */
type ModuleStruct = QualifierMixin & { //@@
    "name": string,

   // モジュールは3つの名前空間を持つ
    "types": {
        *: ReifiedTypeTerm | ReifiedKind | ReifiedConst,
    },
    "commands": {
        *: ReifiedCommand
    },
    "classes": {
        *: ReifiedClass
    },

    *: any? //@open
};


/** モジュールのレイフィケーションイメージ */
type ReifiedModule = RCasm | RCara;

type RCasm = @casm ModuleStruct; //@@

type RCara = @cara (ModuleStruct & { //@@ 
    // caraの場合、さらに4つの名前空間が追加される
    "resources": {*: ReifiedResource}, 
    "userroles": {*: ReifiedUserRole},
    "states": {*: ReifiedState},
    "ports": {*: ReifiedPort},

    *: any? //@ open
    });


type ReifiedClass = @_class (QualifierMixin & { //@@
    "name": string,

   // クラスは名前空間コンテナだが、現状では1つだけの名前空間commandsを持つ
    "commands": {
        *: ReifiedCommand
    },

    *: any?
});


/** 型のレイフィケーションデータの修飾情報 
 * スキーマ属性が付く
 */
type TypeQualifierMixin = QualifierMixin & { //@@
     // スキーマ属性は名前（キー）で引けたほうが便利
    "attributes": object?,
    *: any?
};

//@@ 旧 REnum
//type REnum = @_enum (TypeQualifierMixin & {"enum": [(string|number|boolean|null)*]});

//@@ 旧RScalar
//type RScalar = @_scalar (TypeQualifierMixin & {
//    "name": string(remark="参照している型名"),
//    "typeArgs": [RTypeDef*],
//    }
//);

/** 組み込み型の名前 名前は予約されている 
 * どうせ名前をすべて排他的にはできないので
 * void, intgerも入れておいた
 * void = null, integer⊂number
 * 組み込み型（名前が予約語）は、全体として順序構造を作る。
 */
type BuiltinTypeName = (
  "undefined"
| "null"     
| "boolean"  
| "integer" // numberの部分型
| "number"   
| "string"   
| "binary"   
| "any"      
| "void"  // データ型としてはnullと同じ
| "never"    
| "foreign"  
| "univn"    
);

/** 組み込み型 */
type BuiltinType = @_builtin (TypeQualifierMixin & {
  "typeName" : BuiltinTypeName,

   *: any?
});

/** ブーリアンシングルトン型  */
type BooleanSingletonType = @_boolean (TypeQualifierMixin & {
  "value" : boolean,

   *: any?
});

/** 数値シングルトン型  */
type NumberSingletonType  = @_number  (TypeQualifierMixin & {
  "value" : number,

   *: any?
});

type KindExpr = deferred (string|null);

/** 文字列シングルトン型  */
type StringSingletonType  = @_string  (TypeQualifierMixin & {
  "value" : string,

   *: any?
});


//@ nullシングルトン, binaryシングルトンの必要性は感じない、必要なら入れるが。

/** 基本型 */
type BasicType = (
  BuiltinType | 
  BooleanSingletonType |
  NumberSingletonType  |
  StringSingletonType  |
);

/** 型変数 
 * 型変数とユーザー定義型の名前は区別する必要がない。
 * 束縛環境のなかで評価される
 */
type TypeVar = @_var (TypeQualifierMixin & {
  //@ TypeQualifierMixinが必要かどうかは疑問

  /** 名前は必須 */
  "name" : string,
  /** カインド */
  "kind" : KindExpr?,

   *: any?
});



type ReifiedTypeTerm = @type (TypeQualifierMixin & {
   // "name": string(remark="型名"), //@@ nameは、TypeQualifiedMixinに入っている（省略可能だが）
  "typeParams": [RTypeParam*] | null, //@ [] と null が冗長な気がするが、
  "typeBody": RTypeDef,

  *: any?
});

type RTypeDef = (RObject 
                | RArray 
                | BasicType //@@
                | RBag
                | RUnion
                | RIntersection
                | RUpdator
                | ROptional
                | RTag);

type RObject = @_object (TypeQualifierMixin & { //@@
  "pseudoTag": RPseudoTag?, //@ 塩漬け

  //@ objectとarrayとunionをほぼ同じ構造とする
  //@ specified properties と additional properties
  "specified": {*: RTypeDef}, 
  "additional": RTypeDef,

  *: any?
});


type RPseudoTag = @_pseudoTag ([string, any] | [null, null]); //@ 塩漬け

type RArray = @_array (TypeQualifierMixin & { //@@
  //@ objectとarrayとunionをほぼ同じ構造とする
  //@ specified items と additional items

  "specified": [RTypeDef*], 
  "additional": RTypeDef,

  *: any?
});

type RUnion = @_union (TypeQualifierMixin & { //@@
  //@ objectとarrayとunionをほぼ同じ構造とする
  //@ specified choices と additional choices

  "specified": [RTypeDef*], 
  "additional": RTypeDef,

   *: any?
});

// mark

type RBag = @_bag (TypeQualifierMixin & {
  "items": [RTypeDef*],

   *: any?
});


type RIntersection = @_intersection (TypeQualifierMixin & {
  "left": RTypeDef, 
  "right": RTypeDef,

   *: any?
});


type RUpdator = @_updator (TypeQualifierMixin & {
  "left": RTypeDef, 
  "right": RTypeDef,

   *: any?
});


type RTypeParam = @_typeparam {
    "var_name": string,
    "kind": KindExpr,
    "default": string | null,
};

type RTag = @_tag (TypeQualifierMixin & {
    "tag": string,
    "body": RTypeDef,

   *: any?
});

type ROptional = @_optional (TypeQualifierMixin & {
  "body": RTypeDef,

   *: any?
});

type ReifiedKind = deferred @kind object;

}>>

== コマンドのレイフィケーション

ここは（今回は）特に直してない。


<<{

type ReifiedCommand = @command (RHostLangCommand | RScriptCommand | RStubCommand);

type CommandQualifier = {
    "name": string,
    "annotations": object?,
    "typeParams": [RTypeParam*]?,
    "document": Doc?,
    "profiles": [RProfile*],
    "exception": [RTypeDef*]?,
    "resource": [FacilityUsage*]?,
};

type RProfile = {
    "opts": RObject?,
    "args": RArray?,
    "input": RTypeDef,
    "output": RTypeDef,
};

type RHostLangCommand = @_hostLang (CommandQualifier ++ {
    "refers": string,
    "script": undefined,
});

type RStubCommand = @_stub (CommandQualifier ++ {
    "refers": undefined,
    "script": undefined,
});

type RScriptCommand = @_script (CommandQualifier ++ {
    "refers": undefined,
    "script": ReifiedScript,
});

}>>


== スクリプト

ここは（今回は）特に直してない。


<<{
type ReifiedScript = (RCommandCall 
                    | RScalarVal
                    | RListBuilder 
                    | RObjectBuilder
                    | RTypeDispatch
                    | RTypeCase
                    | RTypeCond
                    | RTagBuilder
                    | RUnaryTagBuilder
                    | RFunctor
                    | RFragment
                    | RJson
                    | RPipe
                    | RDiscard
                    | RVarStore
                    | RVarRef
                    | RArgRef);

type RCommandCall = @_call {
    "name": string,
    "opts": [ROptProxy*],
    "args": [RArgProxy*],
    "typeArgs": [string*],
    "pos": [integer, integer],
};

type ROptProxy = ROption | ROptionLoader | ROptionVarLoader | RGlobOption;

type ROption = @_opt {
    "key": string,
    "value": any,
    "optional": undefined,
};

type ROptionLoader = @_optLoader {
    "key": string,
    "value": undefined,
    "optional": boolean,
};

type ROptionVarLoader = @_optVarLoader {
    "key": string,
    "value": any,
    "optional": boolean,
};

type RGlobOption = @_glob {};

type RArgProxy = RArgument | RNamedArg | RIndexArg | RGlobArg;

type RArgument = @_arg {
    "value": any,
};

type RNamedArg = @_narg {
    "key": any,
    "optional": boolean,
};


type RIndexArg = @_iarg {
    "index": any,
    "optional": boolean,
};


type RGlobArg = @_garg {
};

type RScalarVal = @_scalar (string|binary|number|null);

type RListBuilder = @_list [ReifiedScript*];

type RObjectBuilder = @_object {*: ReifiedScript};

type RTypeDispatch = @_when {"opts": [ROptProxy*], "cases": [(RTagBuilder|RUntag)*]};

type RTagBuilder = @_tag {"tag": string, "value": ReifiedScript};

type RUntag = @_untag  {"tag": string, "value": ReifiedScript};

type RUnaryTagBuilder = @_unaryTag {"tag": string};

type RTypeCase = @_case {
    "path": string?,
    "via": ReifiedScript?,
    "cases": [RCaseNode*],
};

type RTypeCond = @_cond {
    "path": string?,
    "cases": [RCaseNode*],
};

type RCaseNode = {
    "type": RTypeDef | @_wildcard,
    "body": ReifiedScript
};

type RFunctor = REach | RTake | RTime | RStart;

type REach = @_each FunctorBody;
type RTake = @_take FunctorBody;
type RTime = @_time FunctorBody;
type RStart = @_start FunctorBody;

type FunctorBody = {"opts": [ROptProxy*], "body": ReifiedScript};

type RFragment = @_fragment {
    "name": string,
    "body": ReifiedScript,
};

type RJson = @_jsonPath {
    "path": string,
    "pos": [integer, integer],
};

type RPipe = @_pipe [ReifiedScript, ReifiedScript];
type RDiscard = @_discard [ReifiedScript, ReifiedScript];
type RVarStore = @_store {"name": string};
type RVarRef = @_varref {"name": string, "optional": boolean};
type RArgRef = @_argref {"name": string, "optional": boolean};

}>>

== また型定義

修正箇所は移動した。
他は特に直していない。

<<{
type ReifiedConst = @const (TypeQualifierMixin & {
  "name": string, 
  "constBody": string|binary|number|integer|null|boolean|array|object|undefined|@*! (any|undefined),

   *: any?
});

type ReifiedResource = @_res {
    "name": string,
    "document": Doc,
    "annotations": object?,
    "filetype": {"contentType": string, "isText": boolean}?,
    "actions": {
        *: ReifiedAction,
    },
    "url": string,
};

type ReifiedAction = @_act {
    "name": string,
    "document": Doc,
    "annotations": object?,
    "profiles": [ReifiedActionProfile*],
    "invoker": string,
    "script": ReifiedScript,
    "lock": ReifiedScript?,
};

type ReifiedActionProfile = {
    "name": string?,
    "io_type": ("in" | "out" | "io")?,
    "input_type": (RTypeDef | "_")?,
    "output_type": (RTypeDef | "_")?,
    "produces": [string*],
    "relays": [string*],
    "redirects": [string*],
};

type ReifiedUserRole = {
    "name": string,
    "document": Doc,
    "annotations": object?,
};

type ReifiedPort = {
    "name": string,
    "document": Doc,
    "annotations": object?,
};

type ReifiedState = {
    "name": string,
    "document": Doc,
    "annotations": object?,
    "actors": [string*],
    "linkName": string|null,
    "modifier": string|null,
    "isBaseobject": boolean,
    "links": [RLink*],
    "type": RTypeDef,
};

type RLink = {
    "trigger": string | null,
    "type": "embeded" | "no-care" | "additional",
    "appearance": "*" | "+" | "!" | "?",
    "links-to": [[string, (string|null)]*],
    "path": string|null,
};

}>>
