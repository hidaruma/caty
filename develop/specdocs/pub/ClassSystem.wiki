<<ignore  -*- coding: utf-8 -*- >>

= Catyのクラスシステム

Catyにクラス概念を導入する。
が、オブジェクト指向言語／プログラミングにおける“クラス”とはだいぶ異なる -- OOPとCatyScriptはあまり相性がよくない。

== クラスを導入する目的

オブジェクト指向プログラミングをサポートするため**ではない**。

# モジュールの一階層下に名前空間コンテナを作れるようにする。
 ~ **名前空間コンテナ**とは、いくつかの名前空間を保持するモノで、
 アプリケーションやモジュールが既存の名前空間コンテナの例である。
# コマンドのarg0に渡すデータ型を制約できるようにする。
# スクリプトコマンドからファシリティを利用できるようにする。

実用上の一番の要求は、「スクリプトコマンドからファシリティを利用」だが、
これには、クラス概念と他の手法を組み合わせる。

クラスを導入しても、現状の型システム／コマンドシステムにほとんど影響はない。

== 名前空間コンテナとしてのクラス

例を挙げる。

{{{
module text;

/** 空白類を含まない文字列 */
type token = string(pattern="[^ \\t\\n]*");

/** 空白で区切られたトークン列 */
type tokens = string;

/** トークン処理 */
class tokens {
 /** tokensデータをtokenのリストにする */
 command to-list :: tokens -> [token*];

 /** トークンのリストを空白区切りで並べる */
 command from-list :: [token*] -> tokens {
   text:join " "
 };
};
}}}

この定義により、コマンド text:tokens.to-list, text:tokens.from-list が定義される。
パッケージによる名前階層を使った text.tokens:to-list, text.tokens:from-list と事実上同じである。

クラスの配下に次の名前空間が作られる。

# 型名の名前空間（カインド名と共用する予定）
# コマンド名の名前空間

モジュールトップレベルの場合と同じように、クラスの内側で、例外、フィルター、フォーマット、ポート、定数、構文（syntax）などを定義できる。
なぜなら、これらはすべて型かコマンドに過ぎないから。

「名前空間コンテナとしてのクラス」を導入しても、名前構造以外には現状との変更はあまりない。
クラスは、“//モジュール内モジュール//”として扱われる。
モジュールは、新たに「クラス名の名前空間」を保持することになる。
リソース名もクラス名として扱うので、リソース名はcaraモジュールのクラス名・名前空間にアロケートされる。
（caraはリソースを持つので、クラス概念を先行実装していると言える。）

パッケージ、モジュール、クラスという3種の名前階層が使えるので、
CatyScript以外の言語をCatyScriptにコンパイルする際の自由度が上がる。

== arg0制約

コマンドに渡されるarg0（0番目の引数）は、
通常のコマンドでは特に制約されない（なんらかの文字列が渡される）。
また、コマンド内でarg0を使うことも少ない。

クラス内で定義されたコマンドには、arg0に対する型制約を付けることができる。
ただし、型制約を明示的に書かなければ型チェックは働かない。

{{{
module geo;

type rgbValue = integer(minimum = 0, maximum = 255);
type Color = [rgbValue r, rgbValue g, rgbValue b];

type Point = @& {
 "x": number,
 "y": number,
 @[default([0, 0, 0])]
 "color" : Color?,
};

class Point(Point) {
  command move-to :: [number x, number y] -> Point {
    [nth 1 > x, nth 2 > y];
    %0 | xjson:get --safe color > color;
    @Point {"x": %x, "y": %y, "color" : %color?}
  };

  command set-color :: Color -> Point {
    pass > color;
    %0 | [pv x > x, pv y > y];
    @Point {"x": %x, "y": %y, "color" : %color}
  };
};
}}}

class Point(Point) の括弧内に指定された型がarg0を制約する。
なお、括弧内に指定されたPointは geo:Point型を意味する。
型名とクラス名は違う名前空間にアロケートされるので、型とクラスを**同名にしてもよい**。

仮に --0 によりarg0を渡せるとすると：

{{{
caty:root> @Point {"x":0, "y":0} > p; [10, 20] | geo:Point.move-to --0=%p
@Point {
    "y": 10,
    "x": 20,
}
caty:root> @Point {"x":0, "y":0} > p; [100, 100, 100] | geo:Point.set-color --0=%p
@Point {
    "y": 0,
    "x": 0,
    "color": [
        100,
        100,
        100
    ]
}
caty:root>
}}}

このようなことが出来たとしても、geo:Point型のデータは相変わらずイミュータブルで、
値が変更されると毎回作りなおされる。同一のオブジェクトを破壊的に変更しているわけではない。

== MUDとモニカー

Catyの型システムでは、**すべてのデータはイミュータブル**である。
同一性（アイデンティティ）を保ってデータに変更を加えることはできない。
値が異なれば、常に違うデータ（同一性はない）とみなす。

これに対する抜け道がひとつだけある。foreignデータである。
foreignデータは、実体が何でもあってもCatyからは区別ができないので、
Caty型システム内ではシングルトン型になっている。
シングルトン型のインスタンスは必然的にイミュータブルである。
したがって、foreignデータは**Catyからは**イミュータブルである。

しかし、実装言語（Python）はforeignデータを区別できる（つまり、//異なる同値関係で見ている//）ので、
foreignデータを破壊的に変更できる。この変更はCatyからは見えないので、型システムに怒られることはない。

上記の状況を使って、次のようなデータを導入できる。

* Catyからはforeignデータである。（シングルトンでありイミュータブル）
* 実装言語のオブジェクトであり、同一性と状態を持ち、破壊的な変更も許す。

このようなデータを**MUD**（マッド、mutable deta）と呼ぶ。
Caty型システム内のノーマルデータはすべてイミュータブルなので、
MUDはforeign型に限られる。（foreing型が常にMUDを表すとは限らない。MUDかどうかは実装言語側の判断となる。）

MUDを扱いやすくするために、メタデータを付加したデータを**モニカー**（moniker）と呼ぶ。

{{{
type Moniker = @__moniker {
 "class" : string,
 "state" : foreign,
 * : univ
};

kind MonikerType = lower Moniker;
}}}

== モニカーを使ったメソッド呼び出し

クラス内で定義されたコマンドを**メソッド**と呼ぶ（実際は単なるコマンドだが）。

モニカーには、クラス名（の文字列）がエンコードされている。
この情報を使って、実行時にメソッドを呼ぶことができる。

{{{
command call-method 
 [
  /** メソッドのローカル名 */
  string methodName, 
  /** メソッドのパラメータ */
  any* params
 ] 
 :: [univ, Moniker] | Moniker -> univ;
}}}

call-methodは次のことを行う。

# 入力のモニカーからクラス名を取り出す。
# クラス名と第一引数のメソッド名を結合して、メソッドのフルネームを作る。
# メソッドのarg0に、モニカーのstateの値（foreignデータ）をセットする。
# メソッドのパラメータはcall-methodの残余引数を使う。
# 入力の最初の項目をメソッドの標準入力とする。モニカーだけのときはnullを標準入力にする。
# 以上の設定で、メソッドを実行する。
# メソッドによって変更されたかも知れないstateを元のモニカーにセット（破壊的代入）をする。
  この破壊的代入はCaty型システムからは見えない。
# メソッドの出力を自分の出力として吐き出す。

引数の再解析が必要で、
モニカーの破壊的操作を行うので、
callと同様にcall-methodもCatyScript構文として実装する必要がある。
破壊的操作はCatyScriptでエミュレートすることは不可能である。

== メソッド呼び出し演算子

モニカーとメソッドローカル名（文字列）を左右の項とする二項演算子として '..'（ダブルドット）を導入する。
ただし、構文解析を容易にするため、モニカーのリテラルは使えず、モニカーを代入した変数を左の項に使うことにする。

メソッド呼び出しは、
%VAR..method の形となる。シングルドット %VAR.foo は、XJSONパス式として使うかもしれないので、'.' は避けた。
この文書内では、変数にシングルドットをパス式に使っている。

%in | %VAR..method arg は、[%in, %VAR] | call-method method arg と意味的には同値である。
しかし、コンパイル時の型解析／フロー解析で、呼び出すべきメソッドのフルネームが確定することが
多いので、単なるコマンド呼び出しにコンパイルできる可能性がある。

例えば、

{{{
module geo;

type PointMoniker = @__moniker {
 "calss" : "geo:Point",
 "state" : foreign,
};
}}}

と定義されていて、%VARにgeo:PointMoniker型データが入っているなら、
%Var..move-to は、geo:Point.move-to --0=%VAR.state と破壊的代入の組み合わせに展開できる。
実行時のメソッド・ルックアップは必要ない。

== MUDクラス

MUDを操作するメソッドをまとめたクラスを定義できる。

{{{
module geo;

type rgbValue = integer(minimum = 0, maximum = 255);
type Color = [rgbValue r, rgbValue g, rgbValue b];

type Point = foreign(remark="Pythonで実装されたポイントオブジェクト");

command _Point [number x, number y] :: void -> Point
 refers python:geo.point.NewPoint;

type PointMoniker in MonikerType = @__moniker {
 "calss" : "geo:Point",
 "state" : Point,
};

command Point [number x, number y] :: void -> PointMoniker {
 {
  "calss" : "geo:Point",
  "state" : _Point %1 %2,
 }
};

class Point(Point) {
  command move-to :: [number x, number y] -> void
    refers python:geo.point.MoveTo;

  command set-color :: Color -> void
    refers python:geo.point.SetColor;
};
}}}

コンストラクタコマンド geo:Point 0 0 を実行するとPointのモニカーが得られる。
geo:Point 0 0 > p; として変数を生成し、
メソッド呼び出し %p..move-to 10 20 により%pの状態を変更することができる。

== 環境変数によるDI

geo:Point 0 0 > p; のようにして作ったMUDモニカーは、変数pと同じ寿命を持つので、
複数のコマンドが同じストレージを操作するような用途には向いてない。

環境変数はスコープ／エクステントが長いので、
シェルが環境変数にMUDモニカーをセットしておけば、
複数のコマンドで同じMUDを使える。
この場合、MUDモニカーの初期化や後始末はすべてシュルが面倒をみる。
つまり、環境変数を使ったDIとなる。

特にファシリティをMUDクラスとして定義して、
ファシリティ・リクエスタをMUDモニカーとして準備すれば、
スクリプトコマンドから直接ファシリティを使用できるようになる。

== 不十分な点

=== 名前を揃える機能

データ型 geo:Point、
コンストラクタコマンド geo:Point、
クラス geo:Point を同名にしているのは単なるコンベンションであり、
人間がそうしている。
コンベンションと人の注意力やモラルに頼るのは好ましくないので、
constのように、複数の名前空間に同時に同じ名前を登録する機能が必要だろう。

=== スタティックメソッド

スタティックメソッドの扱いがハッキリしてない。

クラスを単なる名前空間として使うときは、クラス内コマンドはスタティックメソッドに相当する。
コマンドのarg0に特定のデータが渡されるときは、
arg0をインスタンスとするインスタンスメソッドとなる。

スタティックメソッドとインスタンスメソッドを構文的に区別して、
呼び出し方を変えるメカニズムが必要。

=== ステージの記述

クラスの計算モデルは状態遷移系で、
状態がモニカーのstateで表現される。
しかし、stateの値（状態点）はCatyから見えず、
あくまで実装言語系のなかに状態空間が存在する（隠蔽されたデータ型）。

状態空間をいくつかの（互いに交わらない）領域に分けたものをステージと呼び、
ステージを考慮してインターフェイスを書くと、精密・安全で自然な記述ができる。

ステージの記述は入れたい。
