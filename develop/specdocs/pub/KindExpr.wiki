<<ignore  -*- coding: utf-8 -*- >>

= カインド表現

== いくつかの注意

# "kind expression", "kind term" は同義語で、**カインド表現**、**カインド項** と呼ぶことにする。
# カインド名は、新しい独立した名前空間に入れる。型名やコマンド名と同じカインド名が使えてしまうが、
  これが問題になれば再考する（つうか、//問題になっているか//、後の例題で触れる）。
# 実用上の理由でnotneverを入れた。

== 構文

{{{
syntax Name  = lexical deferred string(remark="Catyの名前");
syntax QName = lexical deferred string(remark="モジュール名によるコロン修飾を許す名前");

syntax TypeExpr = deferred; // 任意の型表現
syntax ClosedTypeExpr = deferred; // 閉じた（型変数を含まない）型表現、後述

syntax KindExpr ::= BasicExpr | AndExpr;

syntax ComparisonExpr ::= ('upper' | 'lower') ClosedTypeExpr | 'notnever';

// syntax ForallExpr ::= 'forall' TypeArgs TypeExpr ; // 当面実装しない

syntax AtomicExpr ::= KindName | ComparisonExpr ; // 構文定義には使わないが、原子論理式

syntax BasicExpr ::= KindName | ComparisonExpr | '(' KindExpr ')' ;

syntax AndExpr ::= BasicExpr 'and' BasicExpr ('and' BasicExpr)* ;

syntax KindName = lexical QName ; // 他のモジュールのカインドも参照できる

}}}

<<ignore

syntax TypeArgs ::= '<' TypeArg (',' TypeArg)* '>' ; // 引数となる型変数の名前は重複しないこと

syntax TypeArg ::= TVarName ('in' KindExprOnArg)? ;

syntax TVarName = lexical Name;

syntax KindExprOnArg ::= deferred; // 要検討、後述

>>


==  strgモジュールの問い合わせ言語との対比

けっこう似てる。

|= カインド表現    |= 問い合わせ言語 |
| upper A          | @_GE a |
| lower A          | @_LE a |
| notnever         | @_NOT_NULL |
| J and K          | @_AND [P, Q] |


<<ignore 
forall<x> F は、f(i) が非負整数iに依存する式だとして、@_OR [f(0), f(1), f(2), ...] に似てると言える。

* x が 条件 @_OR [f(0), f(1), f(2), ...] を満たす ⇔ f(n) = x となるnがある。
* X が カインド forall<x> F に所属する ⇔ (λx.F)(A) = X となるAがある。

あるいは：

* x が 条件 @_OR [f(0), f(1), f(2), ...] を満たす ⇔ xが関数fの像に所属する ⇔ x∈Im(f)
* X が カインド forall<x> F に所属する ⇔ xが型関数λx.Fの像に所属する ⇔ X∈Im(λx.F)
>>


問い合わせ言語は**データに関する条件**を記述する。
カインド表現は**型（＝集合）に関する条件**を記述する。

== 自由型変数

x, y などは型変数（を表すメタ変数）、E, F, Gなどは型表現として、自由型変数（free type variables）の集合FTVを次のように定義する。

# Fが型の名前（型定数）aなら、FTV(F) = FTV(a) = {} （空集合）
# Fが自由型変数xなら、FTV(F) = FTV(x) = {x}
# Fが束縛型変数yなら、FTV(F) = FTV(y) = {} （空集合）
# FTV([F, G]) = FTV(F)∪FTV(G)
# FTV({"a":F, "b":G}) = FTV(F)∪FTV(G)
# FTV(F | G) = FTV(F)∪FTV(G)
# FTV(@t F) = FTV(F) （タグtには、構文的に型変数は入らない）
# FTV(F ++ G) = FTV(F)∪FTV(G)

型表現Fに現れる型変数yが束縛変数であるのは、type a<...> = F; という定義の文脈にあり、yが左辺の型引数リストに登場するとき。//型関数リテラルがあれば//、束縛型変数をもっとうまく説明できる。
名前が、「既に定義された型の名前」か「自由型変数」かの区別は、環境（名前の束縛の集合）がないと分からない。
環境がないとき／環境を無視するときは、すべて自由型変数と解釈する。

== 閉じた型表現

型変数を含まない型表現を**閉じた型表現**（基礎的型表現（ground type expression）、具体的型表現）と呼ぶ。

変数を最初から除外したBNF定義により閉じた型表現の構文を定義できるが、既に出来上がっている型表現F（のAST)が閉じているかどうかを調べるには、FTV(F) を計算して、FTV(F) = {} かどうかを判定する。
型表現Fの解釈の環境（アンビエント）があるなら、環境も参照して FTV(F) を求める。
決め打ちの文法（BNF）では環境の影響を考慮できない。

閉じた型表現は具体的な集合を確実に指し示す。しばしば、閉じた型表現とdenotationである集合を同一視する。
この同一視を合理化した方法が、Sets-as-Typesのエルブラン・モデル（Herbrand model）。

<<ignore

== forallの制限

カインドに型変数を持たせることはできない（総称カインドは考えない）ので、forallはボディとなる型表現の型変数をすべて束縛する。

forallカインド表現（タイガーブックではキーワードがpoly）は、Aが型引数リスト、Eが型表現として、forall A E の形で書ける。型引数リストAに含まれる型変数の集合をVars(A)と書くとして、
forallカインドには次の条件を課す。

* forall A E において、FTV(F) ⊆ Vars(A) でなくてはならない。

例：

# forall<x> [x, y] -- yが自由なのでエラー。ただし、yは「既に定義された型の名前」ではないとする。
# forall<x, y> [x, y] -- OK。xまたはyが「既に定義された型の名前」であったとしても、理論上は束縛変数に使うのが許される。
 しかし、//とてつもなく紛らわしい//のでエラーにすべき。
# forall<x, y, z> [x, y] -- OK。余分な型引数zがあってもいい。
# forall<x> string -- 意味はないが間違いではない。
# forall<> string -- 0個の型引数は構文上認められてないのでエラー。
# forall<x, x> [x, x] -- 型引数リストに同じ変数名を2回は書けないのでエラー。
# forall<x> [x, x] -- これはOK。
# forall<y> forall<x> [x, y] -- 理論上は何の問題もないが、forallのネストは構文上許さないことにする。エラー。
# forall<x> forall -- もし、forallという型が既に定義されていればエラーではない。が、これも紛らわしい。
  カインドで使うキーワードは型名としても禁止すべきか？
# kind integer = forall<x> string; -- 間違いではない。integerカインドに属する型はstring型だけ。//ヒドすぎる。//
  型名とカインド名を同じ名前空間（記号テーブル）に入れれば、これを禁止できる。

//予約語と名前空間構造//はもっと考える必要がある。



== 型引数内のカインド

先のBNF内の KindExprOnArg は、forallの型引数内で使うカインド表現、候補が2つある。

{{{
/** 名前しか許さない */
syntax KindExprOnArg ::= KindName ;

/** 任意のカインド表現を許す*/
syntax KindExprOnArg ::= KindExpr ;
}}}

プログラミング言語の関数定義のとき、function foo(x:S, y:T) のS、Tは名前しか許してない場合が多いから、
KindNameでもいいのだが、
実際上、いちいち名前を付けないと使えないのはメンドクサイ。任意のカインドが書けるのが望ましい。


これは、総称型（型関数）のときの型引数リストでも同じ。

{{{
kind NumberType = (lower number) and notnever; // neverを許してない

type Point2D<S in NumberType> = @point {"x":S, "y":S, *:any?}; // 色などのプロパティで拡張してよい
}}}

引数リスト内にインラインでカインドを書ければ：

{{{
type Point2D<S in (lower number) and notnever> 
     = @point {"x":S, "y":S, *:any?};
}}}

>>

== 意味論とアルゴリズムの概略

説明のときは型変数（を表すメタ変数）は小文字にする。A, B などは閉じた型表現（＝具体型）、
E, F などは型変数を含む**かもしれない**型表現とする。J, Kなどはカインド表現とする。
カインド表現に自由型変数を許さないので、カインド表現は常に閉じている。

型関数は、ラムダ記法で λx.F と書いて問題ないが、
多相型理論の型限量の記法 ∀x.F は論理式と一緒に出てくると//非常に紛らわしい//。
少し面倒だが、∀は使わずに Im(λx.F) と書く。Im(λx.F) は、「型関数 λx.F の像」として定義される型集合。
そして、型集合＝(インスタンスデータの集合)の集合＝カインド。

Aが具体的な型（＝集合）、Kが型集合（カインド、集合の集合）だとして、A∈K が判断できればいい。
以下では、
型表現とそれが表す集合、カインド表現とそれが表す型集合を適当に混同して話す（理由：厳密に区別すると面倒だから）。

# A∈(upper B) を判断できるか？ → B⊆A が判断できればよい。
# A∈(lower B) を判断できるか？ → A⊆B が判断できればよい。
# A∈(notnever) を判断できるか？ → A≠φ が判断できればよい。
# A∈(forall<x> F) を判断できるか？ → A∈Im(λx.F) が判断できればよい。
# A∈(forall<x in K> F) を判断できるか？ → A∈Im(λx.F) が判断できて、xの具体値Bに関して B∈K が判断できればよい。（詳細後述）
# A∈(J and K) を判断できるか？ → A∈J と A∈K が判断できればよい。

型の比較（集合の包含性判定）は、型解析系の“より基本的な機能”としてサポートする。

forallに関しては：

* A∈Im(λx.F) ⇔ ∃x.[(λx.F)(x) = A]

となる。∃x.[(λx.F)(x) = A] を満たすxの具体値（値といっても型だが）をBとすると、とあるBに関して次が成立する。

* (λx.F)(B) = A

(λx.F)(B) は、ラムダ計算の関数適用なので、項F内の変数xの出現を項Bで置き換えればよい。
置き換え操作（substitution）を{B/x}（use B instead of x）と書くことにすると、

* F{B/x} = A

型表現FとAが与えられてsubstitution {B/x} を求めるアルゴリズムが（型表現の）単一化になる。
タイガーブックのP.328に型単一化（unify）の例がある。

forall<x in K> F のように、xにカインド制約が付いているときは、単一化で求めたBに関して、さらに B∈K を判断する。

型引数が複数あるときは、単一化で求めるsubstitutionが {B,,1,,/x,,1,,, B,,2,,/x,,2,,, ...} の形になる。

== 型単一化

E, Fが任意の型表現として、E⊆F を満たすようにするsubstitutionを求めるアルゴリズムが非対称・型単一化である。
E＝F を満たすようにするsubstitutionを求めるアルゴリズムが（通常の）対称・型単一化である。

対称でも非対称でも、単一化が成功すれば最汎単一化子（most general unifier）と呼ばれるsubstitutionが出力され、
失敗すればもとの命題（不等式または等式）が否定される。

E⊆F を判断する非対称・型単一化プログラムがあれば、他の命題も判断できる。

* E＝F ⇔ E⊆F かつ F⊆E
* E≠φ ⇔ E⊆φ ではない

E⊆F、E＝F を判断する手順はほとんど同じなので、
実際はひとつのプログラムを（オプションを変えて）1回走らせれば事足りるだろう。

なお、非対称・型単一化のときの出力であるsubstitutionは、
{B,,1,,/x,,1,,, B,,2,,/x,,2,,, ...} の形ではなくて、
(B,,i,,, x,,i,,) か (x,,i,,, B,,i,,) の形のペアの集合。左右の区別があるので、順序付きペアが必要。
(B,,i,,, x,,i,,) は B,,i,,,⊆x,,i,, を意味し、
(x,,i,,, B,,i,,) は x,,i,,,⊆B,,i,, を意味する。
この解釈により、非対称・型単一化の出力を連立不等式系とみなせる。

余談：非対称型・単一化の出力を連立不等式系とみなして、それを解こうとすると解がイッパイあり過ぎる。
(B,,i,,, x,,i,,) と (x,,i,,, B,,i,,) の区別を無視して等式系とみなせば解の量が適正になると思われる。
これが最近のアイディア。

== 計画

構文だけを先にサポートする。
処理は何もしなくても、とりあえず説明用とドキュメンテーションとして使える。

Caty内では、定数1（整数のイチ）の最小の型はシングルトン型1（集合は{1}）だが、
実際には、カインド (upper 1) に属する全ての型が適合する。
よって、定数1の型付け（typing）とは、カインド (upper 1) を割り当てることであり、
実際はkindingになっている。

* 型Tが定数1の型である ⇔ T∈(upper 1)

こういうことを説明するためにも、カインド概念とカインドを記述する構文が必要。
