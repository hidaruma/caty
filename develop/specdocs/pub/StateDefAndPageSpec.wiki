<<ignore  -*- coding: utf-8 -*- 
  StateDefAndPageSpec
>>

= 状態定義とページ仕様

Catyは；

# Webサイト／Webアプリケーション作成の**並行分業**を可能にし、
# 分業されたそれぞれの作業担当者のあいだの**正確なコミュニケーション**を支援する。

その一環として、
状態（state）定義の情報から、Webページデザイナが参照する//ページ仕様書//を自動的に書き出せなくてはならない。
逆に、Webページデザイナが必要とする情報はすべて状態定義に含まれてなくてはならない。

以上の観点から、状態定義構文を見直す。




== 状態の表現

Webアプリケーションでは、
クライアント状態（アプリケーション状態）は、
「サーバー側で準備した状態の表現（reprentation）をクライアントに転送すること」により変更（遷移）される。

* [[http://d.hatena.ne.jp/m-hiyama/20100402/1270174064|Webアプリケーションの入出力と状態遷移]]
* [[http://d.hatena.ne.jp/m-hiyama/20100729/1280376048|Webサービスを設計するための単純明快な方法]]
* [[http://d.hatena.ne.jp/m-hiyama/20100811/1281490054|Webサービスの設計： ハイパーオブジェクトとトリガー]]
* [[http://d.hatena.ne.jp/m-hiyama/20100820/1282270208|Webサービスの設計：Webの状態遷移図の描き方]]

状態の表現形式／転送形式としてはHTML形式とJSON形式の2つを考える。
サーバー側の**アクション核**（action nucleus）から出力されたデータから、
状態表現を構築するために通常はテンプレートエンジンを使用する。

以下では、状態の表現形式／転送形式としてHTML形式を採用して、
Webデザイナがテンプレート（静的ページも特殊なテンプレートとして扱う）を書く状況を想定する。

== トリガーの種類

ハイパーリンクは、
クライアント状態（アプリケーション状態）とターゲットを結ぶ矢印（有向グラフの有向辺）として可視化される。
ハイパーリンクを表す矢印の根本が**トリガー**である。

トリガーは次の3種に分類される。（「dont-careトリガー」は「不定トリガー」に変更。）


# **埋め込み**（embedded）トリガー：アクション核の出力にハイパーリンク情報が含まれていること（embedded）が前提。
 アクション核の出力からトリガー（複数かもしれない）を取り出すコマンドを**トリガー抽出コマンド**と呼ぶ。\\
 リンク先が正しいかどうかはプログラマの責任となる。
# **追加**（additional）トリガー：アクション核の出力には情報がまったく含まれていないことが前提。
 デザイナがテンプレート内にトリガーウィジェット（アンカーやフォーム）直接記述する必要がある。\\
 リンク先が正しいかどうかはデザイナの責任となる。
# **不定**（indefinite）トリガー： 埋め込みトリガーか追加トリガーかが不明、またはどちらでもない方法でトリガーウィジェットが生成される。
 例えば、アクション核の出力を使ってテンプレートコードでトリガーウィジェットを生成するなど。

それぞれの種類のトリガーを根本＜ねもと＞に持つハイパーリンク矢印も同じ形容詞で呼ぶ。例えば「埋め込みリンク」。

== 状態定義の構文

基本となる構文は次の形：

{{{
state 名前 :: 型 links {
  トリガー --> ターゲット;
  ...
  ...
};
}}}

さらに正確な情報を付与するために、構文を拡張する。この構文拡張の動機となる要求は：

* 状態データとリンク情報の組み合わせ方（combination）を正確に伝える必要がある。

この目的のために次の構文要素を導入する。

# 状態データ型を、「as 名前」または「baseobject」で修飾できる。
# リンク記述部を「as 名前」で修飾できる。ただし、これができるのは、
状態データ型が無修飾か「as 名前」で修飾されているときに限る。

例を挙げる。

{{{
state Top:: TopInfo as info 
 links as news 
{
    latest* --> Latest.get;
    archive* --> Archive.get;
}
}}}

=== 状態データとリンクデータの組み合わせ方

リンクデータとは、状態定義のlinks節から作られるデータであり、その型は次のように定義される。

{{{
type Links = {
 * : [Trigger*]?
};
}}}

Links型オブジェクトのプロパティ名は、埋め込みリンクの**ラベル名**である。

状態データ（アクション核の出力データ）とリンクデータが組み合わせられてテンプレートコンテキストなる。

* テンプレートコンテキスト＝状態データ＋リンクデータ

状態データとリンクデータの組み合わせ方は次の2種類が
利用できる。ただし、二番目の方法は条件付きである。

# 状態データとリンクデータのそれぞれを、2つのプロパティとして持つオブジェクトを作る。
# 状態データとリンクデータをオブジェクトとしてマージする。
（状態データがオブジェクトのときだけ使える。）

より具体的に書けば：

# 名前付きペアリングを使う： テンプレートコンテキスト＝{"名前1": 状態データ, "名前2": 埋め込みリンクデータ }
# オブジェクトのマージを使う： テンプレートコンテキスト＝(状態データ ++ 埋め込みリンクデータ)

=== 名前付きペアリング

テンプレートコンテキスト＝{"名前1": 状態データ, "名前2": 埋め込みリンクデータ } となるが、2つの名前を次の形で指定する。

{{{
state 名前 :: 型 as 名前1
  links as 名前2 
{
  ...
  ...
};
}}}

名前付きペアリングがデフォルトの組み合わせ方であり、名前1のデフォルトがstate、名前2のデフォルトがlinksである。
つまり、asを書かないときは、

* テンプレートコンテキスト＝{"state": 状態データ, "links": 埋め込みリンクデータ } 

となる。

=== オブジェクトのマージ

状態データ（アクション核の出力データ）がオブジェクト型のときだけ使える。
次の形で指定する。

{{{
state 名前 :: 型 baseobject
  links
{
  ...
  ...
};
}}}

このときは、

* テンプレートコンテキスト＝(状態データ ++ 埋め込みリンクデータ)

となる。特に、埋め込みリンクデータがないとき（{}のとき）は、
テンプレートコンテキスト＝状態データ となる。
（一般には、状態データ型とテンプレート・コンテキスト型が一致するとは限らない。）


== トリガー構文

{{{
syntax 埋め込みトリガー ::= ラベル 出現性? 抽出コマンド? ;
syntax 追加トリガー ::= '+' ラベル 出現性? ;
syntax 不定トリガー ::= '-' ラベル 出現性? ;

syntax 出現性 ::= ('*' | '+' | '?' | '!') ;
}}}

# ラベル構文は[[NameSyntax.wiki|Catyの名前構文]]が使える。
# 出現性のデフォルトは '*' である。
# 抽出コマンドは、コマンド呼び出し構文が使える。'$'ではじまるパス式も使える。
# 抽出コマンドが省略されると、ラベルと同名のプロパティアクセスとみなされる。
したがって、状態データ型がオブジェクトでないとエラーとなる。


== HTML要素クラス名の規約

テンプレートデザイナは、トリガーに対応するHTML要素に対してラベルと同名のクラス名を指定する。
これにより、テンプレートと状態定義との対応関係を取ることができる。

トリガーラベルに接頭辞を付けてクラス名にしたいときは、
モジュールに定数TRIGGER_CLASS_PREFIXを定義する。

{{{
const TRIGGER_CLASS_PREFIX = "foo-";
}}}

== 状態定義構文のBNF定義

変更点：

# ('as' 状態プロパティ名 | 'baseobject')? が追加された。
# ('as' リンクプロパティ名)?  が追加された。
# リンク記述に、文書コメントとアノテーションを前置することができるようになった。
# トリガーのラベルは必須となった。
# 出現性が書けるようになった。
# 埋め込みラベルのとき、抽出コマンドを書けるようになった。


{{{

// 状態定義に、文書コメントとアノテーションを前置することができる。
syntax 状態定義 ::= 'state' 状態名 ('for' ユーザーロール名)? 
                    '::' 型表現 ('as' 状態プロパティ名 | 'baseobject')? リンク記述部? ';' ;

// baseobjectが指定されたときは、'as' リンクプロパティ名 は書けない。
syntax リンク記述部 ::= 'links' ('as' リンクプロパティ名)? '{' リンク記述* '}' ;

// リンク記述に、文書コメントとアノテーションを前置することができる。
syntax リンク記述 ::= トリガー '-->' ターゲット ';' ;

syntax トリガー ::= (埋め込みトリガー | 追加トリガー | 不定トリガー);

syntax ターゲット = deferred; // アクション／アクション並びを指定する
syntax 抽出コマンド = deferred; // コマンド呼び出し
syntax 型表現 = deferred;

syntax 埋め込みトリガー ::= ラベル 出現性? 抽出コマンド? ;
syntax 追加トリガー ::= '+' ラベル 出現性? ;
syntax 不定トリガー ::= '-' ラベル 出現性? ;

syntax 出現性 ::= ('*' | '+' | '?' | '!') ;
syntax 状態名 = 名前 ;
syntax ユーザーロール名 = 名前 ;
syntax 状態プロパティ名 = 名前 ;
syntax リンクプロパティ名 = 名前 ;
syntax ラベル = 名前 ;
syntax 名前 = string(remark="名前");
}}}

