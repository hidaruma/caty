<<ignore  -*- coding: utf-8 -*- >>

= 簡易ハイパー遷移記述

* 続き [[ReducedHypertransitions-2.wiki]]

ハイパーリンクによる状態遷移の記述を、“現状のCatyに加える変更と拡張を//できるだけ少なく//して”実現する。


== ハイパー遷移記述の簡易化（概要）

ハイパー遷移（ハイパーリンクによる状態遷移）を記述するには、次の要素技術が必要となる。

# データの特定の部分にアクセスしてデータセット（正確にはマルチセット）を作り出すセレクター（パターン表現）
# データの特定の部分を他の型に可逆変換するパート（パートは特殊なコマンドである）
# ハイパースキーマ構文
# 状態遷移記述構文

これらをすべてを実装するには相当の労力を必要とするので、機能を限定することにより、
より素早くハイパー遷移記述を実現する方法を探る。

簡易ハイパー遷移記述では、現状のCASM（Caty Schema Module）とCARA（Caty
Resources-and-Actions description）に小規模な変更を加えることによりハイパー遷移を記述する。
（注意：ここで述べる方法の実装が//簡単というわけではない//。）

# CASMに3つのアノテーションを導入する； @[trigger], @[anchor], @[form]。
 これにより、「オブジェクト型のプロパティとしてのトリガー」を実現する。
 //正式なハイパースキーマ構文は導入しない。//
# CARAのaction宣言に、links節を導入する。
  //正式な状態遷移記述構文は導入しない。//

この簡易ハイパー遷移記述から、実行可能なモックシステムを生成するためには、ヘルパーコマンド群を実装し、
アクション定義体（definition body）構文の拡張が必要となる。

# 次の3つのシステムコマンドを導入する； gen-data, fix-links, auto-print
# アクションの本体として、スクリプトコード（CatyScript）、refers節（Python）以外に、
  generates節を設ける。

名前がaというアクションの内部プロファイルが X -> Y であるとき、一例として次のようなスクリプトテンプレートが
モックシステムのために使われる。（これはあくまで一例に過ぎない。）

{{{
translate %X |
when {
  OK => gen-data %Y | fix-links %Y %a | auto-print %Y
  NG => auto-print TranslateError
}
}}}

このスクリプトで、内部プロファイル X -> Y に対応する部分は、gen-data %Y | fix-links %Y %a  だが、
このスクリプトブロックを特定する仕組みが必要になる。この点は別に述べる。


== 簡易ハイパー遷移記述の制限と問題点

今回提案するこの方式には、次のような制限と問題点がある。

# GData方式でJSONエンコードされたAtomリンクを記述することはできない。
# 既に定義されているハイパーリンク仕様を、この仕様に適合させる手段がない。
# クライアント側の状態を中心にした記述はできない。
# ハイパー遷移記述をモジュール化して再利用するのは困難である。
# ハイパーリンクは本来、アクションに対して定義されるものではなくて、
ハイパーメディア型のクライアント側状態ノードに対して定義されるものである。
その意味で、links節は自然な記述とは言いがたい。
# links節をアクションに対して定義するので、メンテナンス性が低い。

== @[trigger]アノテーション 

@[trigger]は、型定義文（type文）に付くアノテーションで、次の制約を意味する。

* 定義される型は [[TriggerTypes.wiki|Trigger型]]のサブタイプである。

サブタイプの判定が困難であるなら、@[trigger]は単なるコメントとして、
ユーザーに、Triggerとのインターセクション（&演算）を取るように要求してもよい。

== @[anchor], @[form] アノテーション

@[anchor] と @[form] は、オブジェクト型のプロパティ部分に付くアノテーションで、
1つの無名パラメータ（アノテーション属性）を取る。

例：

{{{
/** アンケートページ */
type Questionnaire = {
 "title" : string,
 @[form("ques")]
 "ques" : QuesForm,

 * : any?
};
}}}

@[anchor]、@[form] それぞれの制約と機能は次のとおり：

* @[anchor] -- このプロパティの値はAnchor型のサブタイプである（制約）。このプロパティにトリガー名を付ける（機能）。
* @[form] -- このプロパティの値はForm型のサブタイプである（制約）。このプロパティにトリガー名を付ける（機能）。

スキーマ処理系は、プロパティに関する制約を確認し、トリガー名を記憶し、
定義されたオブジェクト型がハイパーメディア型であるとマークする。

要検討：トリガー名の省略を許し、省略のとき、名前を自動的に付けるべきか？


== アクション宣言の links節

アクション宣言・定義文は、原則的にコマンド宣言・定義文と変わらないが、
インボーカー文字列をインライン（その場）でバインドする構文が付け加わっている。
さらに、アクション特有の節としてlinks節を設ける。（通常のコマンドにはlinks節は許さない。）

links節は、throws節, reads節などと同様に、プロファイルの後に任意個書ける節である。
当該アクションにより出力されたハイパーメディアからリンクされるアクションを記述する。

{{{

links節 ::= 'links' リンク先指定

リンク先指定 ::= リンク |  '[' リンク並び ']'

リンク並び  ::= 空 |  リンク (',' リンク)* ','?

リンク ::= トリガー名 '-->' アクション名

}}}

links節が意味的に正しいことを判定するには次の手順が必要となる。

# アクションに内部プロフィルが指定されており、内部余域型がハイパーメディア型である。
（型がハイパーメディア型であるかどうかはスキーマを参照して判断。）
# 各リンクのトリガー名は、ハイパーメディア型で定義されているトリガー名である。
# 各リンクのアクション名は、定義済みアクションの名前である。

以上の制約を満たしてないときは、構文的に正しくてもlinks節はエラーとなる。

CARAファイルのロード時には構文チェックだけをして、意味的なチェックは別なタイミングとすることも考えられる。

== gen-dataコマンド

gen-dataコマンドは、型名を引数にとり、その型のインスタンスデータを1つ返す。
どのようなインスタンスを返すかはランダムだが、各型ごとの生成アルゴリズムと確率分布を持つ。

{{{

command gen-data [typeName type-name] :: void -> any;

}}}

== fix-linksコマンド

fix-linksコマンドは、型名とアクション名を引数に取り、次のことを行う。

# 指定された型名とアクション名に対応する型とアクションの存在を確認する。また、
型名が示す型と、指定されたアクションの内部余域型と一致することを確認する。
存在しない／一致しないならエラー（例外）。
# 型名が示す型がハイパーメディア型でないなら、何もしないで入力を出力に送る。（エラーではない）
# 型名が示す型がハイパーメディア型のとき、指定されたアクションのlinks節を取り出す。
# 当該アクションのlinks節の情報と、リンク先アクションの情報を参照しながら、
 入力データのトリガーのhref, method, verbを具体化する。
# hrefに入れるべきURIパスにワイルドカードが含まれる場合は、適当なリテラルで具体化する。
# 入力データ内のトリガーが前もって具体化されているなら、リンクの正しさの確認だけをして書き換えはしない。


{{{

command fix-links [typeName type-name, string action-name] :: object -> object throws Exception;

}}}


== auto-printコマンド

auto-printコマンドは、入力のJSON（XJSON?）データに対応するHTMLレスポンスを機械的に生成する。
Firefoxアドオンの[[https://addons.mozilla.org/ja/firefox/addon/jsonview/|JSONView]] をサーバー側で実現するものである。

JSONViewと異なるのは、スキーマを参照することによりハイパーメディア型を判断し、
トリガーをHTMLアンカーまたはHTMLフォームに変換することである。
HTMLフォームを生成するときは、トリガーのinputDatatypeプロパティの値を見て、入力型の定義を参照してフォームを構築する。

* [[>http://d.hatena.ne.jp/m-hiyama/20101213/1292201095]]

{{{

command auto-print [typeName type-name] :: any -> WebResponse;

}}}


== generates節

アクション定義の定義体として、「generates スクリプトテンプレート名」を許す。

{{{

/** アンケートへの回答をポストする */
action post-ques ("/POST") :: -(my:Questionnaire -> my:Thanks) 
  links [
    /* my:Thanksには、
     * home, oneMore, privacyというトリガーが含まれる 
     */
    home --> Home.view, 
    oneMore --> Ques.get-ques, 
    privacy --> Common.get-privacy
  ]
generates Mock;

}}}

generatesが指定されていると、このアクションをパーズ・コンパイルする過程で、
スクリプトコードが自動生成されてセットアップされる。
ユーザーはCatyScriptまたはPythonでアクション定義をしなくても、
自動生成されたコードを利用できる。

スクリプトコード自動生成のメカニズムは、当面Pythonハードコード（システムに組み込み）で実装する。
利用可能なスクリプトテンプレート名も決め打ちとする。

== 部分的な実現（手抜き／後回し）の方法

* @[trigger] アノテーションは単なるコメントとして扱い、定義される型がTrigger型のサブタイプであることは人間が注意する。
* @[anchor], @[form] の制約チェックをしない。人間が注意する。
* gen-dataコマンドの実装を決め打ちにする。
* generates節を実装しない。手動でスクリプトを書くことにする。

== 簡易ハイパー遷移記述の拡張と強化

この方式は、簡易的な記述と素早く実装できることが主眼であり、拡張や強化の余地は少ない。
だが、Atomのリンクが扱えないのは痛いので、Atomリンクの記述と確認は実現したい（別に記述する）。

== 補足的な注意

* ハイパーメディア型定義（type文）とlinks節を含むアクション宣言（action文）は、
近くにあるほうが可読性が上がるので、
CARA内でtype文が書けたほうが便利だろう。そうなると、CASMとCARAの差はますますなくなってしまう。
* CASMでは、resource, action, bind の定義を禁止する事にして、
CARAは//単にCASMのスーパーセット//となるのが自然かもしれない。



----

* 続き [[ReducedHypertransitions-2.wiki]]
