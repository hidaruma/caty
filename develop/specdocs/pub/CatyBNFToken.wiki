<<ignore  -*- coding: utf-8 -*- >>

= CatyBNFのとりあえずの扱い方

== CatyBNFのトークン


=== 従来から使っていたトークン

# '=' -- 型定義本体の開始。
# ';' -- 文の終端記号。
# '?' -- 省略可能を示す
# '*' -- 任意回の繰り返しを示す
# '{', '}' -- 回数指定の繰り返しを示す（バッグ型 {[ ... ]} において使っている）
# '(', ')' -- グルーピング
# ':' -- ラベル付け演算子、オブジェクト内の':'とほぼ同じ用法
# '<', '>' -- パラメータリストの開始と終了、型パラメータではないが用法は類似
# ',' -- パラメータリストの区切り記号、回数指定繰り返しの区切り記号
# '@' -- タグの開始（タギング演算子）
# '@&' -- 型名タグ
# '|' -- ユニオン
# リテラル文字列（JSON文字列）
# 整数（JSON整数）
# 名前

=== 現在のCatyスキーマ言語にはない新しいトークン

# '??' -- '?'と同じ意味だが、制約が付く（詳細は省略）。
# '::=' -- 構文定義の本体を開始、':=' か '=' か ';' までが定義本体
# ':=' -- 暫定的な型定義の開始、';' で終端する。
# 一重引用符のリテラル文字列、エスケープすべき引用符が変わる以外はJSON文字列と同じ。
# '(:', ':)' -- ラベル付きグループの開始と終了

':', ':)', ':=', '::=' はいずれもコロンから始まるが2文字先読みで識別する。
'('と'(:'、'?'と'??'なども同様。

'???'は、「'??' と '?'」と判断する。
「'?' と '??'」でも「'??' と '?'」でも、解析すればどうせエラーだが、
トークナイズレベルでは、'???'→'??' '?'、
'????'→'??' '??' など。


=== BNFToken

空白類とコメント（文書コメントは別）は読み飛ばすとして、
以下に示すトークンを総称的に BNFToken と呼ぶ。

# リテラル文字列（JSON文字列）
# 一重引用符のリテラル文字列
# 整数（JSON整数）
# 名前
# '?', '*', '{', '}', '(', ')', ':', '<', '>',  ',', '@', '@&', '|'
# '??', '(:', ':)'

== syntax宣言文

syntax宣言文のパターンは次のどれかでである。
（syntax宣言に文書コメントとアノテーションを前置してよい。）


{{{

syntax 名前 = 型表現 ;

syntax 名前 ::= BNF定義式 ;

syntax 名前 ::= BNF定義式 := 型表現 ;

syntax 名前 ::= BNF定義式 = 型表現 ;

}}}

それぞれ、以下のアノテーション付き型宣言（型定義）文と同値として処理する。

{{{

@[__syntax(null)]
type 名前 = 型表現 ;

@[__syntax(null)]
type 名前 = deferred ;

@[__syntax(null)]
type 名前 = 型表現 ;

@[__syntax(null)]
type 名前 = 型表現 ;

}}}

BNF定義式の部分は解析しない。

== BNF定義式 

BNF定義式の部分は単に読み飛ばすが、いちおうは次の構文定義となる。

{{{

BNF定義式 ::= (文書コメント| BNFToken)*

}}}

BNF定義式は、後続する ';' か ':=' か '=' で終端する。
BNF定義式が空であってもよい。



