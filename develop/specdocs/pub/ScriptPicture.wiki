<<ignore  -*- coding: utf-8 -*- >>

= スクリプトの図示


スクリプトの図示の方針を述べる。
また、実例により、//誤解されやすいvoidとneverの違い//も説明する。

== 参考となる記事

デカルト圏やその拡張である圏の射を図示する話は、まず2004年に書いた次の記事がある。

* [[http://www.chimaira.org/docs/EtbDiagrams.htm|ETBダイアグラム]]

比較的最近の、Catyを意識した記事は：

* [[http://d.hatena.ne.jp/m-hiyama/20110422/1303464264|お絵描き圏論とCatyScriptの変数など]]
* [[http://d.hatena.ne.jp/m-hiyama/20110426/1303802931|変数なしプログラミングとお絵描き圏論]]

型解析の一般論が次にまとめてある。

* [[http://d.hatena.ne.jp/m-hiyama-memo/20110507]]

そのなかで図示の話もある。

* [[http://d.hatena.ne.jp/m-hiyama-memo/20110507/1304748980|型検査と制約解決：ジャンクション]]
* [[http://d.hatena.ne.jp/m-hiyama-memo/20110507/1304751227|型検査と制約解決：不等式的な型付けと制約系（連立不等式系）]]


以下の図は、これらの記事で使ったものを流用する。足りない分はアスキーアートを使う。

== 圏論からの注意

* 圏の対称ブレイディングにあたるクロスジャンクションは、レイアウトエンジンに任せる。
* マルチワイヤー（フラットケーブル）は使わずに、分流と合流を使う。これは、直積演算（平行タプル）を入れずに、
  コピータプリングだけを使うことに相当する。
* duplicatorは分流ジャンクション、discharge（とその双対）はvoidを使う。


== コマンド

コマンドは次のように図示する。

* f :~: X -> Y

{{http://www.chimaira.org/img2/caty-var-1.gif|}}

# ワイヤーのラベルの位置はどこでもよい（レイアウトエンジンに任せてもよい）。
# Pythonで実装されたネイティブコマンドは、黒に近い色にする。（ブラックボックスだから。）
# スクリプトで実装されたスクリプトコマンドは、ネイティブとは別な色にする。（グレーボックスだから薄めの色。）
# ワイヤーのラベルである型が複雑な型項（type term）であるときは無理に描かなくてもよい。

パラメータは次のように図示する。

* f P :~: X -> Y

{{http://www.chimaira.org/img2/caty-var-3.gif|}}

# この図では、パラメータは箱の上から入るようになっているが、こだわるとレイアウトに支障をきたすかもしれないので、
  むしろ、パラメータのワイヤーの色や形を変えたほうがいいだろう。
# パラメータのワイヤーを、引数ワイヤーとオプションワイヤーの2種に分ける案もある。これも色や形状で区別する。
# パラメータ変数と環境変数の扱いはほぼ同じである（後述）。

== パイプ結合

射の結合の基本は次のとおり。

* f :~: X -> Y 、g :~: Y -> Z のとき、結合 f | g 

{{http://www.chimaira.org/img2/caty-var-2.gif|}}

しかし、Catyのパイプ結合は、cod(f) = dom(g) ではなくて、cod(f) ⊆ dom(g) なら可能なので、
パイプを表すワイヤーの両端にラベルが付く。

{{{


 --[ f ]--Y--Z--[ g ]--

}}}

2つのボックスを繋ぐワイヤーに型のラベルが2つ付く。
煩雑になるようならワイヤーのラベルを適宜省略してもいいだろう。
正確な絵を描く場合は、ワイヤーの中間に「⊆」を表す小さなノードを入れて、
その左右に型のラベルを付ける。

{{{


 --Y--(⊆)--Z--

}}}

このような包含を表すワイヤーの確認が型検査の中心問題となる。


== void

voidは、ワイヤーが切れることで表す。f; は f | void | の略記だが、次のように表す。

* f; 

{{http://www.chimaira.org/img2/caty-var-5.gif|}}

コマンドfのプロファイルが X -> void のときも同じ絵になる。
コマンドfのプロファイルが void  -> Y のときは左右を入れ替えた絵になる。

voidは、非常に小さな四角や短い棒で表せばよいだろう。

注意すべきは、voidワイヤーは通常描かないが**存在している**ことである。neverが接続を完全に切ってしまうのに対して、
voidは見えないワイヤリングに寄与している。
（点線などでvoidワイヤーを描くこともある。）このことは、後の実例でも説明する。

== リテラル

リテラルデータも圏論的射であり、void -> シングルトン というプロファイルを持つ。
ラベルとしてリテラルをそのまま使う以外は通常のコマンドと同じに描くことができる。
しかし、色、形状などで区別したほうがいいだろう。

リテラルの射の域は常にvoidに決まっているので、入力のvoidワイヤーを描く必要はない。

== パラメータ変数、環境変数

パラメータ変数、環境変数などの前もって値を持つ変数は、リテラルと同じに扱ってよい。
リテラルと変数の境界は微妙で、null, true, falseなどはリテラルともいえるし、
前もって定義された変数名とも言える。

null, true, false をコマンドと解釈可能なことからも分かるように、
コマンドと変数の区別も曖昧である。圏論的にはどれも特殊な射なので、構文的な曖昧性が問題にはならない。
**意味論（圏の射）に曖昧性はない**。

== ローカル変数

ローカル変数は、パラメータ変数／環境変数とは扱いが**まったく異なる**。
本来は不要なもので、便宜上の分流ジャンクション（後述）に過ぎない。

ローカル変数（のジャンクション）は小さな黒丸（変数ポイント）で表す。
絵算では、ローカル変数の名前は不要だが、テキストスクリプトとの対応のために変数名をラベルにしてもよい。

ローカル変数が参照（'%'を使用）されるたびに、ローカル変数ノードからのワイヤーが引かれる。
したがって、参照回数と同じ本数のワイヤーがローカル変数ノードから出る（これは大域変数でも同じ）。

ローカル変数の生成を行う代入式は次のとおり。

* f > x 

{{http://www.chimaira.org/img2/caty-var-4.gif|}}


== ジャンクション

ジャンクションは、言語仕様で決まった構文要素に対応する射のことで、単なるボックスでは描き難いものである。

１本のワイヤーが複数のワイヤーに分かれる分流ジャンクション、
複数のワイヤーが１本にまとまる合流ジャンクションがある。
分流ジャンクションと合流ジャンクションは通常はペアになる。

特殊なジャンクションとして、単なるワイヤーであるストレートジャンクションがある。
voidによるワイヤーの切断（矢印の根元での切断と先端での切断）もジャンクションである。

== 配列ジャンクション

配列の分流ジャンクションは、小さな丸に文字'['を入れたノードを使う。
ノードから分流したワイヤーは、配列の項目（item）に接続する。
分流するワイヤーの本数は、配列の項目数に等しい。

配列の合流ジャンクションは、小さな丸に文字']'を入れたノードを使う。
配列の項目（item）から出るワイヤーが、このノードに合流する。
合流するワイヤーの本数は、配列の項目数に等しい。


== オブジェクトジャンクション

オブジェクトの分流ジャンクションは、小さな丸に文字'{'を入れたノードを使う。
ノードから分流したワイヤーは、オブジェクトのプロパティに接続する。
分流するワイヤーの本数は、オブジェクトのプロパティ数に等しい。

オブジェクトの合流ジャンクションは、小さな丸に文字'}'を入れたノードを使う。
オブジェクトのプロパティから出るワイヤーが、このノードに合流する。
合流するワイヤーの本数は、オブジェクトのプロパティ数に等しい。

プロパティから出て、オブジェクトの合流ジャンクションに向かうワイヤー上に、
プロパティ名のラベルを描く。型のラベルと区別する工夫が必要である（
一番単純な方法は引用符を付けることだろう）。

== ストレートジャンクション

ストレートジャンクションとは、passコマンドのことである。

{{http://www.chimaira.org/img2/caty-straight.gif|}}

単なるワイヤーだけ（描かない）か、または目立たないボックスとして描けばいいだろう。


== タギング演算子

タグ付けは演算子と考える。特殊なノードを用意し（例えば菱形とか）、タグ名でラベルする。

このタギング演算子ノードをコマンドボックスと同じように図示する。@x f は f | (tagging x) のように図示する。

== whenジャンクション

whenの分流ジャンクションは、小さな楕円に'when'を入れたノードを使う。
ノードから分流したワイヤーは、whenの選択肢（choice）に接続する。
分流するワイヤーの本数は、whenの選択肢数に等しい。

whenの合流ジャンクションは、ラベルなしで少し変わった形状（doublecircleとかoctagonとか）にすると
よさげ。
whenの選択肢から出るワイヤーが、このノードに合流する。
合流するワイヤーの本数は、whenの選択肢数に等しい。

whenの分流ジャンクションから出て、選択肢に向かうワイヤーに
whenのガード部（OK => とか）でラベル付けする。

== ブロックとフラグメント

ブロックもフラグメントも、サブグラフにより領域の枠を描けばよい。

whenはジャンクションとして扱っているのでブロックではない。
ブロックは、each, take, time, beginにより作られる。

ブロックには、それぞれの構文要素名でラベル付けする。
フラグメントには、フラグメントIDをラベルに付ける。

ブロックもフラグメントもそれ自体の入力と出力を持つので、
コマンドボックスとまったく同じように扱う。
コマンドがブラックボックスであるのに対して、
ブロックとフラグメントはホワイトボックス（グラスボックス）となっている。

なお、ID付きフラグメントではない、単なる丸括弧グループを図に描く必要はない。
そのような丸括弧はパージング時に消えている事が多い。

== 開始と終了

レイアウト方式に依存する話だが、開始と終了の位置が判断しにくいときは、
開始（入り口）と終了（出口）を示すノードを描いたほうがいいかもしれない。

== 大域脱出制御構造

throw, signal, redirect, forward などは大域脱出を引き起こす。
これらの図示は当面は考えないが、後の実例で少し触れている。

== 描画に関して

* 配列項目、オブジェクトプロパティ、when選択肢などのグルーピングのために
  隠れた（非表示の）サブグラフが必要かもしれない。
* 配列の項目は一例に並ぶように配置する必要がある。項目の順序を守る必要もある。
* noneノード、plaintextノード、Unicode記号文字、HTML-Like Labelなどを使う必要がありそうだ。
  特にIMGタグによる画像の使用は有効だろう。
* voidの表現に、noneノードとtee矢印の組み合わせが使えるかもしれない。
* レイアウトの際に、「実例」で述べるvoidワイヤーを考慮する必要があるかもしれない。
* voidワイヤーを描くなら、dashed か dottedスタイルだろう。
* 例外と環境（互いに双対）の表現に、noneノードとinv*矢印の組み合わせが使えるかもしれない。


== 実例

スクリプトコードは以下。

{{{

translate WikiFile |
when {
 OK=>(#out-ok
       $.body | file:write %PATH_INFO;
       [%APP_PATH, %PATH_INFO] | path:join | redirect
     ),
 NG=>(#out-ng 
       %APP_PATH | redirect
     ),
}
}}}

次の方法で描いている。

# コードフラグメントを別なグラフにしている。これにより１つのグラフが大きくなることを防げる。
# リテラルと変数は、同じ形状（楕円）のノードとして描いている。ラベルで区別できる。
# whenの合流は二重丸。
# 全体の開始は「丸に黒丸」、終了は「丸にバッテン」。
# $はgetコマンド（実際はxjson:getだった）のシンタックスシュガーと解釈。
# 赤の番号は後の説明用。

{{pict-sample-1.gif|}}

=== voidとnever

void（単元集合）とnever（空集合）は、1と0に相当する。
当然ながら1と0は違う。が、極めて多くの人が1と0を区別できてない。
1と0、つまり単元集合と空集合の混同は、型システムや推論系を崩壊させる。

* [[>http://d.hatena.ne.jp/m-hiyama/20110704/1309737089|0と1は違う -- 型システムの集合的意味論とか]]

voidは空でなくて存在するので、voidワイヤーも存在している。
煩雑になるのでvoidワイヤーを描かないだけで、描いてもよい。むしろ、//必要なら描くべき//、と言える。

上の図の赤い番号のあいだには、voidワイヤーが**存在している**。

~#out-ok

# 1 と 2
# 3 と 5
# 4 と 6

~#out-ng

# 1 と 2

一方で、大域脱出で値をまったく生成しないときは、出力の型はneverとなる。
制御は大域的なジャンプを行う。このジャンプを斜め上向きの⇒で表すとする。
redirectは大域的なジャンプを起こすので次のように描くことができる。
出力がneverである場合は、ワイヤーをまったく描かない。


{{pict-sample-2.gif|}}

これを考慮すると、スクリプト全体は次のようになる。

{{pict-sample-3.gif|}}

このスクリプトは、実は出力を伴った終了を持たない。
したがって、終了のマークである「丸にバッテン」は描かないのが正確な記述になる。


