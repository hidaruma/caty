<<ignore  -*- coding: utf-8 -*- >>

= URIパスのパターン その2

* [[URIPathPattern.wiki]]
* [[RequestDispatch.wiki]]

== 前置きと注意

[[URIPathPattern.wiki]] で定義した用語を使う。
パスのセグメントとファイル名は構文的に同じなので、
ファイル名も含めた意味で「セグメント」という言葉を使う。
セグメント、フィールドなどは、ワイルドカードを含むかも知れない。
ワイルドカードを含まない文字列を表すには形容詞「リテラル」を付ける。

== 2つのセグメントの排他性


αとβがセグメントのとき、幅（フィールドの個数）が違えば排他的になる。αとβが同じ幅のときだけ問題にすればよい。

αとβは同じ幅で、その幅をnとする。つまり、
α = α,,1,,.α,,2,,.….α,,n,,, β = β,,1,,.β,,2,,.….α,,n,, 。このαとβが排他的であるのは、少なくとも1つのi（1≦i≦n）に対して次が成立するときである。

* [条件A] α,,i,, も β,,i,, もワイルドカードではなくて、α,,i,, と β,,i,, は異なるリテラル文字列である。

この条件の否定は、次のようになる。

* すべてのiに対して、α,,i,, か β,,i,, の少なくとも一方はワイルドカードであるか、
または、α,,i,, と β,,i,, は同じリテラル文字列である。

このことから、 2つのセグメントの排他性を判断するには、次の作業が必要となる。

# セグメントの幅が違うことを確認する。
# 同じ幅のセグメントに対しては、フィールドごとの比較して、[条件A]が成立するフィールドを探す。

これらの判定に失敗すれば、2つのセグメントは排他的ではない。

== セグメント集合の排他性

Sがセグメント集合のとき、otherwiseパターンを除いた集合をS'とする。
複数のotherwiseパターンがあっても、それらは互いに排他的であり、otherwiseパターンは特別扱いするので、
S'に関して排他性の判定をすればよい。

S'に含まれるセグメントはk個であるとする。S'の排他性は、S'に含まれる要素の相互関係なので、
k×k = k^^2^^ 個の組み合わせに関する排他性の判定となる。
が、排他性の対称性と自分自身との排他性のチェックは不要なことから、[k×(k-1)]/2 回の排他性判定となる。

== 絶対パス集合の排他性

絶対パスの集合Pがあるとき、それが排他的であるとは次のことである。

まず、それぞれの絶対パスをセグメントに分解して、それをもとにトライ木を作る。
トライ木の辺はセグメントでラベル付けされる。同一ノードから出る辺に付けられたラベルであるセグメント集合は、ツリーの兄弟となる。

絶対パスの集合Pから作られたトライ木において、すべての兄弟が排他的なら、Pは排他的という。

排他的な絶対パスの集合Pが与えられると、リテラル絶対パスxに対して、次が成立する。

* //リテラルなxにマッチするPの絶対パスは**存在すれば一意的**である。//


== パターン集合の排他性

絶対パスの集合Pとファイル名の集合Fの組み合わせをパターン集合と呼ぶ。
パターンが排他的とは次のことである。

* 絶対パスの集合Pが排他的である。
* ファイル名の集合Fが（セグメント集合として）排他的である。

リテラルパスとパターン集合とのマッチングを、
(1)絶対パスの集合Pとのマッチング、(2)ファイル名の集合Fとのマッチングの順でするなら、次が成立する。

* //リテラルなxにマッチするパターン集合 (P, F) のパスまたはファイル名は**存在すれば一意的**である。//

----

* [[URIPathPattern.wiki]]
* [[RequestDispatch.wiki]]


